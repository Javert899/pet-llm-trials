structural patterns for soundness of business process models
b.f. van dongen
department of technology management, eindhoven university of technology, the netherlands.
b.f.v.dongen@tm.tue.nl
j. mendling
vienna university of economics and business administration, austria,
jan.mendling@wu-wien.ac.at
w.m.p. van der aalst
department of technology management, eindhoven university of technology, the netherlands.
w.m.p.v.d.aalst@tm.tue.nl
abstract
the correctness of business process models is of
paramount importance for the application on an enterprise
level. a severe problem is that several languages for busi-
ness process modelling do not have formal execution se-mantics which is a prerequisite to check correctness crite-
ria. in this context, soundness deﬁnes a minimum correct-
ness criterion that a process model should fulﬁl. in thispaper we present a novel approach to reason about sound-
ness based on so-called causal footprints . a causal foot-
print represents a set of conditions on the order of activitiesthat holds for every case of a process model. we identify
three kinds of error patterns that affect the soundness of a
process model, namely the deadlock pattern, the multiple
termination pattern, and the trap pattern. we use event-
driven process chains (epcs) and petri nets to demonstratethe applicability of our approach for both conceptual as for
formal process modelling languages. furthermore, it can
easily be applied to other languages, such as uml activ-ity diagrams or bpel. based on the trap pattern, we prove
that the “vicious circle”, that is heavily discussed in epc
literature, is unsound.
1. introduction
business process modelling is gaining increasing atten-
tion as a basis for the development of large-scale enterprise
information systems. in this context, business process mod-els can either be used as a formalization of requirements that
guide the implementation, as input for code generation in a
model-driven architecture, or as executable templates on adedicated process engine deﬁned e.g. with bpel. all these
three scenarios have in common that the correctness of the
business process models is of paramount importance for the
application on an enterprise level. formal errors such asdeadlocks can easily have a severe impact on the proﬁts of
an enterprise if a key business process is affected.
the detection of errors in a business process model is
complicated by two problems. first, there is a plethora of
languages for business process modelling (cf. [21]). even
though there are similarities concerning what workﬂow pat-
terns these languages supports (cf. [4]), analysis techniqueshave to be deﬁned for each language individually in or-
der to capture the speciﬁcs of the semantics. second, and
even worse, there are several business process modellinglanguages for which no formal semantics have been deﬁned
or that have only formal semantics when certain structural
conditions are fulﬁlled. still, any business process modelthat is used in the development of enterprise systems needs
to be checked in order to prevent ambiguities in the design
phase and errors at run-time. in this paper, we address thesetwo problems in a novel way.
while several available analysis techniques (e.g. for
petri nets) work on the state space that can be calculated
for a process model, we abstract from the actual behaviourby introducing a concept that is called causal footprint .
the idea of a causal footprint is to derive a set of condi-
tions on the order of activities that holds for the process
model and to utilize it for reasoning on the correctness.soundness is an important correctness criterion in this con-
text. in essence, a process is sound if and only if (a) any case
terminates in one of some pre-deﬁned termination states and(b) for all activities in the process there is at least one case
in which they can be executed. figure 1 illustrates that the
causal footprint gives an approximation of the process be-
1dcbefh
g i
aprocess model
causal footprint
figure 1. process model and causal footprint.
haviour in terms of conditions that every process instance
has to obey to. throughout this paper, we use event-drivenprocess chains (epcs) and petri nets to show the applica-
bility of causal footprints for both formal and conceptual
business process modelling languages. this choice is mo-tivated by the fact that epcs are widely used for the doc-
umentation of business process e.g. in the sap reference
model. furthermore, petri nets are a well-understood for-malism for the modelling of business processes that are used
for the formalization of a variety of languages and standards
(e.g. bpmn, bpel, xpdl, uml activity diagrams).
the remainder of this paper is structured as follows. in
section 2, we introduce epcs and petri nets. section 3provides the deﬁnition of causal footprints and a respective
mapping from epcs and from petri nets. section 4 contin-
ues with two patterns (deadlock and multiple termination)that are typically found in a causal footprint that has errors.
we use an example taken from the sap reference model to
illustrate our “pattern-based error detection” approach. fur-thermore, we provide a third pattern (trap pattern) that rep-
resents a necessary condition for soundness. we apply this
technique to the famous “vicious circle” (cf. [3, 17, 18]) toshow that it is not sound under anysemantics where block-
ing connectors are assumed to be unsound. in section 5, we
introduce the implementation of our technique as a plug-infor the prom framework. section 6 gives an overview of
related research on business process veriﬁcation. we con-
clude the paper with some conclusions and an outlook onfuture research.
2. preliminaries
in the introduction, we mentioned two process modelling
languages, namely petri nets and epcs. in this section,we introduce these modelling languages in the mathemat-
ical sense (that is, we formalize their structure). both of
these languages, and also the formalism we introduce later,are graph based. therefore, we start by introducing some
notation speciﬁcally for directed graphs.
deﬁnition 2.1. (pre-set and post-set) letg=(n,e)
be a directed graph and let n∈n. we deﬁne
g•n={m∈n|(m,n)∈e}as the pre-set and ng•={m∈
n|(n,m)∈e}as the post-set of nwith respect to the
graph g. if the context is clear, the superscript gmay be
omitted, resulting in •nandn•.
petri nets are a formal language that can be used to spec-
ify processes. since the language has formal and executablesemantics, processes modelled in terms of a petri net can be
executed by an information system. for an elaborate intro-
duction to petri nets, the reader is referred to [9, 22, 23].a petri net consists of two types of node elements (cf. fig-
ure 2):
transitions, which typically correspond to either an activ-
ity which needs to be executed, or to a “silent” step (cf.
a routing step) that takes care of routing. a transitionis drawn as a rectangle.
places, which are used to deﬁne the preconditions and
postconditions of transitions. a place is drawn as a
circle.
transitions and places are connected through directed arcs
in such a way that (i) places and transitions have at least one
incident edge and (ii) in every path, transitions and placesalternate (no place is connected to a place and no transi-
tion is connected to a transition). for completeness sake,
we mention that the petri nets we use in this paper corre-spond to a classic subclass of petri nets, namely workﬂow
nets (wf-nets, [1]), which are tailored towards workﬂow
modeling and analysis.
deﬁnition 2.2. (workﬂow net) ω=(p,t,f )is a work-
ﬂow net (or wf-net [1]) if:
-pis a ﬁnite set of places,
-tis a ﬁnite, non empty set of transitions, such that
p∩t=∅andt/negationslash=∅,
-f⊆(p×t)∪(t×p)is the ﬂow relation of the net,
- there exists exactly one p
i∈p, such that |•pi|=0,
- there exists exactly one pf∈p, such that |pf•|=0,
- all places and transitions are covered by the paths from
pitopf.
except for petri nets, we also use epcs to illustrate
our ideas. epcs provide an intuitive modeling language to
model business processes. epcs were introduced by keller,
n¨uttgens, and scheer in 1992 [15]. it is important to realize
that the language is not intended to be a formal speciﬁcation
of a business process. instead, it serves mainly as a means
of communication. epcs are extensively used in large-scaleenterprise modelling projects. one prominent example of a
publicly available model is the sap reference model [7, 16].
an epc consists of three types of node elements (cf. fig-ure 2):
functions, which are the basic building blocks. a function
corresponds to an activity (task, process step) whichneeds to be executed. a function is drawn as a box
with rounded corners.
events, which describe the situation before and/or after a
function is executed. functions are linked by events.an event may correspond to the position of one func-
tion and act as a precondition of another function.
events are drawn as hexagons.
connectors, which can be used to connect functions and
events to specify the ﬂow of control. there are three
types of connectors: ∧(and), ×(xor) and ∨(or).
connectors are drawn as circles, showing the type in
the centre.
functions, events, and connectors can be connected with
edges in such a way that (i) events have at most one incom-ing edge and at most one outgoing edge, but at least one
incident edge (i.e. an incoming or an outgoing edge), (ii)
functions have precisely one incoming edge and preciselyone outgoing edge, (iii) connectors have either one incom-
ing edge and multiple outgoing edges, or multiple incoming
edges and one outgoing edge, and (iv) in every path, func-tions and events alternate (no two functions are connected
to one-another and no two events are connected to one-
another, not even when there are connectors in between).furthermore, as a guideline, an event should never be fol-
lowed by a choice connector. the latter relates to the imple-
mentation where all components of an information system
that can handle a certain event, should handle it and no se-
lection is made between those components.
deﬁnition 2.3. (event-driven process chain)
ε=(f,e,c
and,cxor,cor,a)is an epc if:
-fis a ﬁnite set of functions,
-eis a ﬁnite set of events,
-c=cand∪cxor∪coris a ﬁnite set of connectors,
such that |c|=|cand|+|cxor|+|cor|,
-a⊆((f∪e∪c)×(f∪e∪c))is the ﬂow relation
of the net, such that:
- for all f∈fthere is one (f,x)∈aand one
(x,f)∈a,
- for all e∈ethere is at most one (e,x)∈aand
at most one (x,e)∈a,
- for all c∈cthere is either one (c,x)∈aand
more than one (x,c)∈a, or one (x,c)∈aand
more than one (c,x)∈a,
- for all f1,f2∈fholds(f1,f2)/negationslash∈a,
- for all e1,e2∈eholds(e1,e2)/negationslash∈a,
- on all paths, functions and events alternate.
note that in this section, we only provide an abstract syn-
tax of petri nets and epcs and do not give any semantics.
the reason is that we are not interested in the precise seman-
tics. as illustrated by figure 1 we aim for a causal footprinta
bc
d/\ a
bc
d /\
figure 2. epc and petri net for parallelism.
which is independent of speciﬁc semantical interpretations
(e.g., the or-join in epcs).
3. causality graphs
as we stated in the introduction, we will look at the
structure of epcs and petri nets to provide conditions for
soundness. we do so, by deriving a higher level speciﬁca-
tion, called a causality graph , that captures the intention of
the control ﬂow described in the process model. it is im-portant to realize that these causality graphs do not capture
the entire process model as such, in fact they are merely a
footprint of the control ﬂow in the given process model, i.e.they describe the approximate behaviour of a system at a
very high level.
let us look at process modelling in general. the inten-
tion of any process model is to capture the behaviour of aprocess in an understandable way, where the behaviour is
formed by the execution of activities within a case.
1
deﬁnition 3.1. (process behaviour/case)
lettbe a set of activities, and let φtbe a process con-
taining these activities. the behaviour of the process φt
is deﬁned as the set w⊆t∗, where t∗is the set of all
sequences that are composed of zero of more tasks from t.
aσ∈wis called a case, i.e. a possible execution of the
process. to denote an activity at a speciﬁc index in σ,w e
useσ[i], where iis the index ranging from 1to|σ|.
we have now formalized the behaviour of a process and
each of the modelling languages of section 2 is intended
to capture this behaviour in a structured way. as we statedbefore, we will look at processes at a very high level. there-
fore, we introduce the causality graph , representing a foot-
print of the process.
deﬁnition 3.2. (causality graph) letnbe a set of activi-
ties. we deﬁne a causality graph g=(n,f
lb,fla), where:
-nis a ﬁnite set of nodes (activities),
-flb⊆(p(n)×n)is a set of look-back links2,
-fla⊆(n×p(n))is a set of look-ahead links .
1note that we assume trace semantics here rather than more reﬁned
notions such as (branching/weak) bisimulation [14].
2withp(n), we denote the powerset of n,i . e .n/prime∈p(n)if and
only ifn/prime⊆nandn/prime/negationslash=∅.3.1. causal footprint
when a causality graph is used to describe a process, it
should be interpreted in the following way. for each look-
ahead link , we say that the execution of the source of that
link leads to the execution of at least one of the targets of
that link. a look-ahead link is denoted as a bullet with one
or more outgoing arrows. furthermore, for each look-back
link, the execution of the target is preceded by at least one
of the sources of that link. the notation of a look-back link
is a bullet with one or more incoming arrows. note that
we do not give any information about when in the futureor past executions took place, but only that they are there.
this way of describing a process is similar to the work pre-
sented in [12]. however, by splitting up the semantics in thetwo different directions (i.e. forward and backward), causal
footprints are more expressive. with footprints you can for
example express the fact that task ais always succeeded by
b, but that bcan also occur before a, which is typically hard
to express in other languages.
if a causality graph indeed describes a process like this,
w ec a l li ta causal footprint . we formalize this concept us-
ing the notion of cases.
deﬁnition 3.3. (causal footprint) lettbe a set of ac-
tivities, φ
tbe a process with behaviour w. furthermore,
lettiandtfbe such that ti,tf/negationslash∈tandti/negationslash=tf. further-
more, let g=(t∪{ti,tf},flb,fla)be a causality graph.
(for notational purposes, we say that for all σ∈wwith
n=|σ|,holds that σ[0] =tiandσ[n+1 ]= tf, i.e. we add
artiﬁcial starts and ends to each trace). we say that gis a
causal footprint graph of φt, denoted by g∈fφt, if and
only if:
1. for all (a,b)∈flaholds that for each σ∈wwith
n=|σ|, such that there is a 0≤i≤n+1 with
σ[i]=a, there is a j:i<j ≤n+1, such that
σ[j]∈b,
2. for all (a,b)∈flbholds that for each σ∈wwith
n=|σ|, such that there is a 0≤i≤n+1 with
σ[i]=b, there is a j:0≤j<i , such that σ[j]∈a,
it is clear from deﬁnition 3.3 that a causal footprint is
not unique, i.e., different processes can have common foot-
prints. for example, g=(t∪{ti,tf},∅,∅)is the causal
footprint of any process having activities t. therefore, we
aim at footprints that are more informative without trying
to capture detailed semantics. moreover, by using a transi-
tive closure, a causal footprint can be extended to be a moreinformative causal footprint.
in order to derive conditions for soundness of processes,
we need to consider the transitive closure of a causal foot-
print. to do so, we ﬁrst give a general way to transitively
close a causality graph.deﬁnition 3.4. (causal closure) letg=(n,f
lb,fla)
be a causality graph. we deﬁne g∗=(n,f∗
lb,f∗
la)to be
the causal closure of g, where f∗
lbandf∗
laare the smallest
possible sets, such that:
1.(a,b)∈flaimplies that (a,b)∈f∗
la,
2.(a,b)∈flbimplies that (a,b)∈f∗
lb,
3.(a,b)∈f∗
laimplies that for all n/prime⊆nholds that
(a,b∪n/prime)∈f∗
la,
4.(a,b)∈f∗
lbimplies that for all n/prime⊆nholds that
(a∪n/prime,b)∈f∗
lb,
5.(a,b)∈f∗
la,b∈band(b,c)∈f∗
la, implies that
(a,(b\{b})∪c)∈f∗
la,
6.(b,c)∈f∗
lb,b∈band(a,b)∈f∗
lb, implies that
((b\{b})∪a,c)∈f∗
lb,
the rules for causally closing a causal graph obviously
apply to a causal footprint as well. more importantly, the
causal closure of a causal footprint is a causal footprintagain and we refer to it as a footprint closure .
to illustrate that the causal closure of a causal footprint
is indeed also a causal footprint, assume that an activity a
in some process is always followed by at least one element
of the set b. we can then extend the set bby any element,
which corresponds to rules 3 and 4 of deﬁnition 3.4. nowconsider rule 5 and again assume ais always follows by
some element of the set b(i.e.(a,b)∈f
∗
la). furthermore,
we know that there is an activity b∈b, which is always fol-
lowed by one element of the set c(i.e.(b,c)∈f∗
la). then,
it is easy to see that the activity b∈bcan be substituted
byc, i.e.ais always followed by an element of c,o ra n
element of b, except b, i.e.(b\{b})∪c. note that is it im-
portant to ﬁrst remove bfromband then add all elements
ofc, since cmight contain b.
it is important that the rules for making a causal closure
are valid under the assumption that the process under con-
sideration has sound behaviour. obviously, when investi-gating soundness, soundness cannot be assumed right from
the beginning. however, in this paper, we only investigate
conditions for soundness using the following way of rea-
soning. if a process is indeed sound, it is safe to make
this assumption. if the process is not sound and we usethe causal closure, some of the derivations may not be cor-
rect. however, if we ﬁnd a error using the causal closure it
may result from a correct derivation showing a problem orthe initial assumption (the process is sound) was wrong. in
both cases, we can conclude that there is indeed a problem
and the process is not sound.
the latter property will be used in this paper, where we
actually do not have the full behaviour of a process, but only
the process model, describing the behaviour in a more orless formal way.
the fact that a causal footprint of a process is not unique
is irrelevant for the work presented in this paper. any prop-a
c ba
c bac bac b
xa
c bva
c b
/\a
c b xac bvac b
/\ac b
figure 3. mapping of epc to causal footprint.a a b b
c d c d
figure 4. mapping for
petri net.
erty that we derive that holds on a causal footprint of a pro-
cess, holds on the process itself. the better the causal foot-print of a process is, i.e. the more information it contains,
the more properties we are able to deduce. as an exam-
ple, again consider the graph that only has the activities of a
process as nodes and no edges. this graph is a causal foot-
print of any process, but it does not contain any informationabout the process.
3.2. deriving causal footprints
in the introduction, we stated that, as an example, we
would focus on soundness properties using epcs and petrinets. therefore, in this section, we present algorithms to de-
rive causal footprints of epcs and petri nets. this is done
in two stages. first, the models are translated to causalitygraphs in such a way that these graphs contain all elements
of the modelling languages and only causalities that can be
derived locally (i.e., immediate predecessor and successorrelationships). these graphs are then transitively closed and
projected onto the subset of interesting elements, thus lead-
ing to causal footprints.
deﬁnition 3.5. (epc to causal graph) letε=
(f,e,c
and,cxor,cor,a)be an epc, with the set of mod-
elling elements n/prime=f∪e∪cand∪cxor∪cor,t h es e t
of initial elements ni={n∈n/prime|ε•n=∅}and the set
of ﬁnal elements nf={n∈n/prime|nε•=∅}. we deﬁne a
causality graph gε=(n,f lb,fla)as follows:
-n=n/prime∪{ni,nf}, where ni,nf/negationslash∈n/primeandni/negationslash=nf,
-fla=
{(a,{b})∈n×p(n)|a∈f∪e∪cand∧b∈aε•}∪
{(a,b)∈n×p(n)|a∈cor∪cxor∧b=aε•}∪
{(ni,ni)}∪{(a,{nf})|a∈nf},
-flb=
{({a},b)∈p(n)×n|b∈f∪e∪cand∧a∈ε•b}∪
{(a,b)∈p(n)×n|b∈cor∪cxor∧a=ε•b}∪
{(nf,nf)}∪{({ni},a)|a∈ni}.
deﬁnition 3.5 gives an algorithm to derive a causality
graph from an epc and figure 3 a respective illustration.
however, since we want to talk about processes, we are only
interested in the functions and connectors of this epc andnot its events. by taking the causal closure of the causal-
ity graph and projecting it onto the functions and connec-tors (i.e. removing all events and all edges related to these
events), we obtain a causal footprint of the process mod-
elled by the epc. for this, we ﬁrst deﬁne a projection of a
causal graph.
deﬁnition 3.6. (causal graph projection) letg=
(n,f
lb,fla)be a causal graph and let n/primebe a set of
nodes, such that n/prime⊆n. we deﬁne the projection
g/prime=(n/prime,f/prime
lb,f/prime
la)ofgonton/prime, such that:
-flb/prime=flb∩(p(n/prime)×n/prime),
-fla/prime=fla∩(n/prime×p(n/prime))
property 3.7. (causal graph gives a causal footprint for
epc)
lettbe a set of activities and φta process over t.
letε=(f,e,c and,cxor,cor,a)be an epc that mod-
els the process φt. note that f=t. furthermore, let
gε=(n,f lb,fla)be a causality graph following deﬁni-
tion 3.5. the causal closure of gε,g∗
ε=(n,f∗
lb,f∗
la),
projected onto f∪c∪{ni,nf}, i.e.g∗
ε/prime=(f∪c∪
{ni,nf},f∗
lb/prime,f∗
la/prime), is a causal footprint of the process de-
ﬁned by the epc, i.e. g∗
ε/prime∈f(φt).
as we stated before, the translation rules from an epc to
a causal graph are given under the assumption that the epcis sound. however, soundness would imply that there are
clear executable semantics, which is not always the case.
therefore, our translation rules do not require explicit se-
mantics. the only requirement for our rules to hold is that
soundness should be deﬁned in such a way that a blockingconnector is considered to be unsound. under this assump-
tion, the proof of property 3.7 is rather intuitive, i.e. any
element in the epc is always followed by all its successors,unless it is an xor-split or or-split in which case the ele-
ment is followed by at least one of its successors. the same
applies for the join connectors.
similar to epcs, we derive a translation for wf-nets to
causality graphs and show that the result is a causal footprint
for the modelled process (cf. figure 4).
deﬁnition 3.8. (workﬂow net to causal footprint) let
ω=(p,t,f )be a wf-net, with the set of modelling ele-
ments n
/prime=p∪t, the initial place pi∈pand ﬁnal placepf∈p. we derive a causality graph gω=(n,f lb,fla)
as follows:
-n=t∪{ni,nf}, where ni,nf/negationslash∈n/primeandni/negationslash=nf,
-fla={(n,n/prime)∈n×p(n)|∃p∈p\{pf}n∈ω•p∧
n/prime=pω•}∪{(ni,piω•)}∪{(t,{nf})|t∈ω•pf},
-flb={(n/prime,n)∈p(n)×n|∃p∈p\{pi}n∈pω•
∧n/prime=ω•p}∪{(ω•pf,nf)}∪{({ni},t)|t∈piω•},
property 3.9. (causal graph gives a causal footprint for
workﬂow net) lettbe a set of activities and φta process
overt.l e tω=(p,t/prime,f)be a wf-net that models the
process φt. note that t/prime=t. furthermore, let gε=
(n,f lb,fla)be a causality graph following deﬁnition 3.8.
the causal closure of gω,g∗
ω=(n,f∗
lb,f∗
la), is a causal
footprint of the process deﬁned by the wf-net, i.e. g∗
ω∈
f(φt).
wf-nets have a clear executable semantics and therefore
a clear deﬁnition of soundness. for this deﬁnition, we knowthat a wf-net is not considered to be sound if it contains
deadlocks. therefore, the proof of property 3.9 is again
rather intuitive, i.e. a transition tis always followed by one
of the transitions that consumes a token that was produced
bytand vice versa.
both for wf-nets and epcs, we have deﬁned a transla-
tion to causal graphs, and we have shown that when thesecausal graphs are projected onto the interesting elements,
they are causal footprints of the process under considera-
tion. in the next section, we show that if these causal foot-
prints have certain properties, our assumption that the epc
or wf-net was sound is violated and therefore the processis not sound.
4. erroneous patterns
typically, processes are considered to be sound if and
only if the process fulﬁlls the following conditions:
- any case that is started terminates in one of some pre-
deﬁned termination states,
- for each activity in the process there is at least one pos-
sible occurrence sequence (i.e., case execution) going
from the initial state to a pre-deﬁned termination statethat contains this activity.
for wf-nets, the deﬁnition of soundness is such that
there is exactly one ﬁnal state, i.e. the state where thereis one token in the output place and no tokens in any other
place. furthermore, there can be no dead transitions.
the deﬁnition of soundness helps to identify three typi-
cal error patterns. two of them indicate potential errors thataffect the soundness of a business process model: deadlocks
(sect. 4.1) and multiple termination (sect. 4.2). section 4.3
illustrates the deadlock pattern with an example from thesap reference model. furthermore, the trap pattern gives
rise to a sufﬁcient condition for showing that a process is
not sound (sect. 4.4).
4.1. deadlock pattern
figure 5 shows a process having a simple deadlock
caused by an exclusive choice followed by a synchronizing
join (and-join). the process is depicted, both as an epc
and as a petri net. in this case, the and-join remains wait-
ing for both bandcto complete while only one of them is
activated. accordingly, the process cannot terminate prop-
erly and is therefore not sound. the respective petri net
contains a so-called “place-transition handle” (pt-handle,[13]) as there are alternative paths from one place to a tran-
sition that waits for all paths to complete.
deﬁnition 4.1. (deadlock pattern) lettbe a set of activ-
ities and φ
ta process over t.l e tg=(n,f lb,fla)be a
causal footprint of the process deﬁned, i.e. g∈f(φt).
if there is a (a,b)∈flawith|b|>1and there ex-
ists a (a,{d})∈flasuch that for all b∈bholds that
({b},d)∈flband(a,{b})/negationslash∈flathen we say that (a,b,d )
is adeadlock pattern .
in causality footprints such pt-handles always map to a
set of activities b(in our example b={b,c}) that all share
one look-ahead link from athat is in the causal graph of the
model and one common successor din the look-back link
set plus a look-ahead link from atod. furthermore, there
is no single look-ahead link from atob(i.e.(a,{b})and
(a,{c})do not exist). it can be proven that a pt-handle
always produces a deadlock pattern. the idea of the proof
is that there can be no predecessors of athat have a look-
ahead link to successors of a. therefore, there is no simple
look-ahead link from the start to activities that are succes-
sors of aand predecessors of d. following the soundness
assumption of the mapping of the and-join, dcan always
be reached from any activity in b. according to the look-
back links, every predecessor of dis executed which ﬁnally
contradicts that the successors of aare exclusive. yet, it
is still an open question whether models without errors can
a
da
b c
dx
/\a
b c
dxx
b c
figure 5. deadlock in epc and petri net and
the respective pattern in the causal footprint.produce a deadlock pattern. the reason is that the deadlock
pattern does not show that the paths from atobandatoc
are mutually exclusive. thus, if we ﬁnd a deadlock pattern
between aanddin the causal footprint, it is likely that this
really indicates a deadlock.
4.2. multiple termination pattern
figure 6 shows a process having an improper multiple
instantiation both as an epc and as a petri net. in this case,
the successors of dare executed each time a path to the
xor-join is completed. this leads to multiple terminations
of the process which is not sound. the respective petri net
contains a so-called “transition-place handle” (tp-handle,
[13]) as there are parallel paths from one transition to a set
of places that propagate each token.
deﬁnition 4.2. (multiple-termination pattern) lettbe
a set of activities and φta process over t.l e t g=
(n,f lb,fla)be a causal footprint of the process deﬁned,
i.e.g∈f(φt). i ft h e r ei sa (b,d)∈flbwith|b|>1
and there exists a ({a},d)∈flbsuch that for all b∈b
holds that (d,{b})∈flaand({a},b)/negationslash∈flbthen we say
that(a,b,d )is amultiple termination pattern .
in causal footprints such tp-handles always map to a set
of activities b(in our example b={b,c}) that all share
one look-back link to dthat is in the causal graph of the
model and one common predecessor ain the look-ahead
link set plus a look-back link from atod. furthermore,
there is no single look-back link from btod. it can be
proven that a tp-handle always produces a multiple termi-
nation pattern. the idea of the proof is analogous to the
proof for the deadlock pattern. furthermore, it is still an
open question, whether models without errors can produce
a multiple termination pattern. the reason is that the multi-ple termination pattern does not enforce that the paths from
btodand from ctodare mutually exclusive paths. thus,
if we ﬁnd a multiple termination pattern between aandd
in the causal footprint, it is likely that this really indicates
a multiple termination. however, in terms of an epc for
a
da
b c
d/\
xa
b c
dxb c
x
figure 6. multiple termination in epc and
petri net and the respective pattern in the
causal footprint.example, if the xor-join is replaced by an or-join, the
pattern can still be found, but one might argue that the epc
is sound. this however depends on the semantics of the
or-join.
4.3. sap reference model example
figure 7 gives a part of the “release and implementation
of measure” epc that is part of the asset accounting branchof the sap reference model [7, 16]. the corresponding
causal footprint includes the deadlock pattern. this pro-
cess part indeed contains a deadlock, e.g., taking the pathstarting with event “reserved funds to reduce” leads to a
deadlock before the last and-join.
4.4. trap pattern
so far, we have shown that we can take a process model
in terms of an epc or wf-net and that we can describe
the behaviour of the underlying process using a causal foot-
print. a causal footprint is declarative in nature, i.e. it
describes what happens, but it does not describe how ithappens. this property can be used to give conditions for
soundness.
deﬁnition 4.3. (singular trap pattern) lettbe a set of
activities and φ
ta process over t.l e tg=(n,f lb,fla)
be a causal footprint of the process deﬁned, i.e. g∈
f(φt). if there is a n∈n, such that (n,{n})∈fla,
or({n},n)∈flathen we say that (n)is asingular trap
pattern .
the singular trap pattern is stronger than the previous
patterns, since we can say that if a process contains sin-
gular trap pattern, the process is not sound. the proof ofthis property is trivial. the presence of a look-ahead link
(n,{n})means that if activity nappears once in a case,
xorder 
releasebudget s assigned order 
releaseactual 
costs are 
known
reserved 
funds to 
reducefunds to 
be set 
asidemanual 
fund re-
servation
/\item 
based on 
order
funds 
are 
reserved
/\/\
manual 
fund re-
ductionreserved funds are 
reducedmanual 
fund re-
duction
/\manual 
fund re-
servation
figure 7. epc from the sap reference model
and part of its causal footprint.then it appears inﬁnitely often in that case. therefore, ei-
ther the activity can never be performed, which means that
the activity is dead, or there is a livelock. similarly, if there
is a look-back link ({n},n)then every occurrence of activ-
itynhas to be preceded by activity n. therefore, activity n
can never be performed, thus indicating that it is dead.
deﬁnition 4.3 can easily be extended to a more general
pattern.
deﬁnition 4.4. (generalized trap pattern) lettbe a
set of activities and φta process over t.l e t g=
(n,f lb,fla)be a causal footprint of the process deﬁned,
i.e.g∈f(φt). if there is a non-empty set of nodes
n/prime⊂n, such that for all n/prime∈n/primethere is a n/prime/prime⊆n/prime
with(n/prime,n/prime/prime)∈flaor for all n/prime∈n/primethere is a n/prime/prime⊆n/prime
with(n/prime/prime,n/prime)∈flbthen we say that (n)is ageneralized
trap pattern .
the idea behind the generalized trap pattern is similar to
the singular one and they have the same property that the
process is not sound if the pattern occurs. again the proof
is straightforward, since as soon as one of the activities ofthe subset n
/primeoccurs, it will always lead to the execution of
another element of that set, implying that there is a livelock,
or the set is dead. for the look-back links the set is alwaysdead. note that these potential problems are related to the
concepts of traps and siphons in petri nets [9].
a
/\x
b
/\x
c
/\x
a
b c
figure 8. vicious circle and causal footprint.
figure 8 gives the famous epc for the vicious circle.
the epc shows that there is a possible paradox when us-ing multiple or-joins and has been extensively discussed
in literature(cf. [3, 17, 18]). the calculated causal footprint
indicates that the model is not sound, regardless of any se-
mantics , as long as a blocking connector is assumed to be
unsound.
5. tool support
the (pro)cess (m)ining framework prom has been de-
veloped as a completely plug-able environment for process
mining and related topics in the context of business pro-
cess analysis. it can be extended by simply adding plug-ins,i.e., there is no need to know or to recompile the source
code. currently, more than 80 plug-ins have been added.
the prom framework has been described before in [10] andcan be obtained via www.processmining.org. the architec-
ture of prom allows for ﬁve different types of plug-ins:
mining plug-ins which implement some mining algo-
rithm, e.g., mining algorithms that construct a petri netor epc based on some event log.
export plug-ins which implement some “save as” func-
tionality for some objects. for example, there are plug-
ins to save epcs, petri nets, spreadsheets, etc.
import plug-ins which implement an “open” functionality
for exported objects, e.g., load instance-epcs from the
aris process performance manager.
analysis plug-ins which typically implement some prop-
erty analysis on some mining result. for example, forpetri nets there is a plug-in which constructs place in-
variants, transition invariants, and a coverability graph.
conversion plug-ins which implement conversions be-
tween different data formats, e.g., from epcs to petrinets.
in the context of this paper, we developed two conver-
sion plug-ins and one analysis plug-in. first, we imple-mented two plug-ins to convert an epc or a petri net to
a causal footprint. the two conversion plug-ins follow the
rules presented in this paper and after conversion, they bothcalculate the causal closure of the result. the visualiza-
tion is done in such a way that only informative relations
are shown, i.e. only the relations for which there are no“larger” relations. the look-ahead links are shown in blue,
the look-back links are shown in red. however, even with
these restrictions, the resulting graph may still have manyconnections and appears to be “spaghetti-like”. . therefore,
we implemented an analysis plug-in to ﬁnd the erroneous
patterns as described in section 4. figure 9 shows the resultof the analysis plug-in, when applied on the epc containing
the vicious circle from figure 8. the left-hand side shows
the vicious circle in a generated layout. the right-hand side
shows a selected part of the generated causal footprint. we
chose to search for “singular trap patterns” and the plug-inreturned three results. then, we asked it to show the pattern
involving function “c”, at which point the function “c” was
highlighted in the epc as well as in the causal footprint.
for the practical application of our results it is impor-
tant to note that the prom framework is currently capableof reading and writing epcs to aml (native to the aris
toolset), epml (a standard for storing epcs) and the aris
graph format used by aris ppm. for petri nets, multipleformats are available, including the standard pnml format.
the framework is open-source and the latest release is avail-
able for download from www.processmining.org.figure 9. the vicious circle in prom
6. related work
the synchronization semantics of or-joins have been
one of the focal points of research on epcs. in [8] the so-
called relaxed soundness criterion is presented to guide themodeller towards the speciﬁcation of a sound wf-net from
an epc. the wofy awl approach introduced in [24] ex-
tends this work to y awl. the wofy awl tool has beenused to check the correctness of the epcs in the sap ref-
erence model [20] revealing that at least 5 % of the mod-
els have errors. in [11] an interactive veriﬁcation approachis presented that builds on reduction rules. the possibility
to provide executable semantics for epcs has been inves-
tigated in [18], where executable semantics are proven to
exist for a large sub-class of all epcs. the vicious circle
is an example of an epc for which no suitable semanticsexist. in [6] an approach is presented to efﬁciently calcu-
late the state space of an epc, thereby providing executable
semantics for the epc. the authors mainly motivate thiswork from the viewpoint of simulation/execution although
their approach can also be used for veriﬁcation purposes.
because of the semantical problems in some epcs the algo-rithm does not always provide a result [18]. our approach
based on causal footprints identiﬁes the vicious circle at
least to be unsound, but with a much simpler calculation.
in a way our approach is related to classical approaches
in petri nets where traps, siphons, handles, and invariants
are used to identify problems [1, 9, 13, 22]. in many casesthese structural properties are used to derive statements on
the behaviour of the petri net. however, instead of working
directly on a petri net representation we use a more abstract
representation that is language independent. moreover, we
use the causal closure to obtain our results.
causal graphs can be seen as a declarative language,
i.e., instead of using explicit control-ﬂow operators like se-
quence, iterations, etc., constraints are given. in this pa-per we consider two types of constraints (look-back links
and look-ahead links). these can easily be translated into
a temporal logic [19]. in [5], decserflow, the declarativeservice flow language, is deﬁned which includes the two
types of constraints used in this paper but also many oth-
ers. this illustrates that the approach presented in this pa-
per could be extended to include other types of constraintsin the causal footprint. in [5] its is shown how these can
be represented in linear temporal logic (ltl). moreover,
prom already contains an ltl checker which can check ar-bitrary ltl formulas on the basis of events logs [2].
7. conclusion and future work
in this paper, we have presented a novel approach for
checking soundness of business process models. we cap-
ture the intent of a process model by deriving a causal
footprint . such a footprint should be seen as an abstrac-
tion of the process behaviour. as a causal footprint does
not require an executable semantics of the process mod-
elling language, we can apply our analysis technique bothto formal languages such as petri nets and to concep-
tual/informal languages such as epcs. even though we use
these two languages throughout the paper to demonstratethe applicability of our technique, it can be easily adapted
to other languages such as uml activity diagrams, bpmn,
or bpel. this is especially helpful regarding the hetero-geneity of business process modelling languages. based on
causal footprints, we are able to identify three error patterns,
namely deadlocks, multiple termination, and traps. for the
latter we provide a proof that a trap pattern always implies
that the model is unsound.
the work presented here scratches the surface of a new
way of describing processes. instead of taking a process
model describing which activities have to be performed inwhich order, we derive a description of what can and can-
not be done. in this paper, we only looked at two types of
relations, i.e. one activity is always followed by at least oneof a set of other activities (look-ahead links) and the coun-
terpart in the other direction (look-back links). obviously,
this can be extended to more complex relations or relationsof a different nature. more importantly, the causal footprint
may be a way to bridge the gap between business process
modelling and business rules. in future research, we aim toidentify further relations and derivation rules and to provide
further conditions for a process model to be sound or not.
references
[1] w.m.p. van der aalst. the application of petri nets
to workﬂow management. the journal of circuits,
systems and computers , 8(1):21–66, 1998.
[2] w.m.p. van der aalst, h.t. de beer, and b.f. van don-
gen. process mining and veriﬁcation of properties:
an approach based on temporal logic. in r. meers-
man and z. tari et al., editors, otm conferences 2005 ,volume 3760 of lecture notes in computer science ,
pages 130–147. springer-verlag, berlin, 2005.
[3] w.m.p. van der aalst, j. desel, and e. kindler. on the
semantics of epcs: a vicious circle. in m. n ¨uttgens
and f. j. rump, editor, proc. of the 1st gi-workshop
on business process management with event-drivenprocess chains (epk 2002), trier, germany , pages
71–79, 2002.
[4] w.m.p. van der aalst, a.h.m. ter hofstede, b. kie-
puszewski, and a.p. barros. workﬂow patterns. dis-
tributed and parallel databases , 14(1):5–51, 2003.
[5] w.m.p. van der aalst and m. pesic. specifying,
discovering, and monitoring service flows: making
web services process-aware. bpm center report
bpm-06-09, bpmcenter.org, 2006.
[6] n. cuntz, j. freiheit, and e. kindler. on the semantics
of epcs: faster calculation for epcs with small statespaces. in m. nuettgens and f.j. rump, editors, pro-
ceedings of fourth workshop on event-driven pro-
cess chains (wi-epk 2005) , pages 7–23, hamburg,
germany, december 2005. gesellschaft fuer infor-
matik, bonn.
[7] t. curran and g. keller a. ladd. sap r/3 business
blueprint: understanding the business process ref-erence model . enterprise resource planning series.
prentice hall ptr, upper saddle river, 1997.
[8] j. dehnert and w.m.p. van der aalst. bridging the
gap between business models and workﬂow speci-
ﬁcations. international journal of cooperative infor-
mation systems , 13(3):289–332, 2004.
[9] j. desel and j. esparza. free choice petri nets ,v o l -
u m e4 0o f cambridge tracts in theoretical computer
science . cambridge university press, cambridge,
uk, 1995.
[10] b.f. van dongen, a.k.a. de medeiros, h.m.w. ver-
beek, a.j.m.m. weijters, and w.m.p. van der aalst.
the prom framework: a new era in process mining
tool support. in application and theory of petri nets
2005 , volume 3536 of lecture notes in computer sci-
ence , pages 444–454. springer-verlag, berlin, 2005.
[11] b.f. van dongen, h.m.w. verbeek, and w.m.p. van
der aalst. veriﬁcation of epcs: using reduction rules
and petri nets. in conference on advanced informa-
tion systems engineering (caise 2005) , volume 3520
oflecture notes in computer science , pages 372–
386. springer-verlag, berlin, 2005.
[12] h. eertink, w. janssen, p. oude luttighuis, w. b.
teeuw, and c. a. vissers. a business process de-
sign language. in fm ’99: proceedings of the world
congress on formal methods in the development ofcomputing systems-volume i , pages 76–95, london,
uk, 1999. springer-verlag.
[13] j. esparza and m. silva. circuits, handles, bridges
and nets. in g. rozenberg, editor, advances in
petri nets 1990 , volume 483 of lecture notes in
computer science , pages 210–242. springer-verlag,
berlin, 1990.
[14] r.j. van glabbeek and w.p. weijland. branching time
and abstraction in bisimulation semantics. journal of
the acm , 43(3):555–600, 1996.
[15] g. keller, m. n ¨uttgens, and a.w. scheer. semantische
processmodellierung auf der grundlage ereignisges-teuerter processketten (epk). ver ¨offentlichungen des
instituts f ¨ur wirtschaftsinformatik, heft 89 (in ger-
man), university of saarland, saarbr ¨ucken, 1992.
[16] g. keller and t. teufel. sap(r) r/3 process ori-
ented implementation: iterative process prototyping .
addison-wesley, 1998.
[17] e. kindler. on the semantics of epcs: resolving
the vicious circle. in j. desel and b. pernici andm. weske, editor, business process management, 2nd
international conference, bpm 2004 , volume 3080
oflecture notes in computer science , pages 82–97,
2004.
[18] e. kindler. on the semantics of epcs: a framework
for resolving the vicious circle. data and knowl-
edge engineering , 56(1):23–40, 2006.
[19] z. manna and a. pnueli. the temporal logic of reac-
tive and concurrent systems: speciﬁcation . springer-
verlag, new york, 1991.
[20] j. mendling, m. moser, g. neumann, h.m.w. ver-
beek, b.f. van dongen, and w.m.p. van der aalst. a
quantitative analysis of faulty epcs in the sap referencemodel. bpm center report bpm-06-08, bpmcen-
ter.org, 2006.
[21] j. mendling, g. neumann, and m. n ¨uttgens. the
workﬂow handbook 2005 , chapter a comparison of
xml interchange formats for business process mod-elling, pages 185–198. future strategies inc., 2005.
[22] t. murata. petri nets: properties, analysis and ap-
plications. proceedings of the ieee , 77(4):541–580,
april 1989.
[23] w. reisig and g. rozenberg, editors. lectures on petri
nets i: basic models , volume 1491 of lecture notes
in computer science . springer-verlag, berlin, 1998.
[24] h.m.w. verbeek, w.m.p. van der aalst, and a.h.m.
ter hofstede. verifying workﬂows with cancella-
tion regions and or-joins: an approach based on
invariants. beta working paper series, wp 156,eindhoven university of technology, eindhoven, the
netherlands, 2006.