table of contents
specifying and monitoring service flows: making web services process-
aware ............................................................ 1
w.m.p. van der aalst, m. pesic
author index ................................................. 45iispecifying and monitoring service flows:
making web services process-aware
w.m.p. van der aalst and m. pesic
department of technology management, eindhoven university of technology,
p.o.box 513, nl-5600 mb, ei ndhoven, the net herlands.
w.m.p.v.d.aalst@tm.tue.nl,m.pesic@tm.tue.nl
abstract. bpel has emerged as the de-facto standard for implement-
ing processes based on web services while formal languages like petri nets
have been proposed as an “academic response” allowing for all kinds ofanalysis. although languages such as bpel and petri nets can be used
to describe service ﬂows, they both tend to “overspecify” the process and
this does not ﬁt well with the autonomous nature of services. therefore,we propose decserflow as a declarative service flow language .b yu s -
ing a more declarative style, there is no need to overspecify service ﬂows.
the declarative style also makes decserflow an ideal language for mon-itoring web services, i.e., using process mining techniques it is possible
to check the conformance of service ﬂows by comparing the decserflow
speciﬁcation with reality. this can be used to expose services that do notfollow the rules of the game. this is highly relevant given the autonomous
nature of services.
1 introduction
web services, an emerging paradigm for architecting and implementing busi-
ness collaborations within and across organizational boundaries, are currently of
interest to both software vendors and scientists [4]. in this paradigm, the func-
tionality provided by business applications is encapsulated within web services:software components described at a semantic level, which can be invoked by
application programs or by other services through a stack of internet standards
including http, xml, soap [23], wsdl [24] and uddi [22]. once deployed,web services provided by various organiz ations can be inter-c onnected in order
to implement business collaborations, leading to composite web services .
today workﬂow management systems are readily available [7,58,68] and
workﬂow technology is hidden in many applications, e.g., erp, crm, and pdm
systems. however, their application is still limited to speciﬁc industries such as
banking and insurance. since 2000 there has been a growing interest in web
services. this resulted in a stack of internet standards (http, xml, soap,
wsdl, and uddi) which needed to be complemented by a process layer. sev-eral vendors proposed competing languages, e.g., ibm proposed wsfl (web
services flow language) [57] building on flowmark/mqseries and microsoft2
proposed xlang (web services for busin ess process design) [84] building on
biztalk. bpel [18] emer ged as a compromise between both languages.
the business process execution language for web services (bpel4ws, or
bpel for short) has become the de-fact os t a n d a r df o ri m p l e m e n t i n gp r o c e s s e s
based on web services [18]. systems such as oracle bpel process manager,
ibm websphere application server enterprise, ibm websphere studio appli-
cation developer integration edition, and microsoft biztalk server 2004 supportbpel, thus illustrating the practical relevance of this language. although in-
tended as a language for connecting web services, its application is not limited
to cross-organizational processes. it is expected that in the near future a wide
variety of process-aware information systems [30] will be realized using bpel.
whilst being a powerful language, bpel is diﬃcult to use. its xml repre-
sentation is very verbose and only readable to the trained eye. it oﬀers many
constructs and typically things can be implemented in many ways, e.g., using
links and the ﬂow construct or using sequences and switches. as a result onlyexperienced users are able to select the r ight construct. several vendors oﬀer
a graphical interface that generates b pel code. however, the graphical rep-
resentations are a direct reﬂection of the bpel code and are not intuitive toend-users. therefore, bpel is closer to classical programming languages than
e.g. the more user-friendly workﬂow management systems available today.
in discussions, petri nets [78] and pi calculus [67] are often mentioned as
two possible formal languages that could serve as a basis for languages such as
bpel. some vendors claim that their systems are based on petri nets or pi
calculus and other vendors suggest that they do not need a formal language to
base their system on. in essence there are three “camps” in these discussions:
the “petri net camp”, the “pi calculus ” (or process algebra) camp, and the
“practitioners camp” (also known as the “no formalism camp”). this was the
reason for starting the “petri nets and pi calculus for business processes” working
group [76] in june 2004. more than two years later the debate is still ongoingand it seems unrealistic that consensus on a single language will be reached.
this chapter will discuss the relation between petri nets and bpel and show
that today it is possible to use formal methods in the presence of languages like
bpel . however, this will only be the starting point for the results presented in
this chapter. first of all, we introduce a new language decserflow . second, we
show that process mining techniques can be very useful when monitoring web
services.
the language decserflow is a declarative service flow language , i.e., it is
intended to describe processes in the cont ext of web services. the main motiva-
tion is that languages like bpel and petri nets are procedural by nature, i.e.,
rather than specifying “what” needs to h appen these languages describe “how”
things need to be done. for example, it is not easy to specify that anything
is allowed as long as the receipt of a par ticular message is never followed by
the sending of another message of a particular type. decserflow allows for the
speciﬁcation of the “what” without having to state the “how”. this is similar3
to the diﬀerence between a program and its speciﬁcation. (for example, one can
specify what an ordered sequence is without specifying an algorithm to do so.)
in a service-oriented architecture a va riety of events (e.g., messages being
sent and received) are being logged [6, 73]. this information can be used for
process mining purposes, i.e., based on some event log it is possible to discover
processes or to check conformance [14,13]. the goal of process discovery is to
build models without a-priori knowledge, i.e., based on sequences of events one
can look for the presence or absence of certain patterns and deduce some process
model from it. for conformance checking there has to be an initial model. one
can think of this model as a “contract” or “speciﬁcation” and it is interesting to
see whether the parties involved stick to this model. using conformance checkingit is possible to quantify the ﬁt (fewer deviations result in a better ﬁt) and to
locate “problem areas” where a lot of deviations take place.
in this chapter we will show that there is a clear link between more declara-
tive languages such as decserflow and process mining .i no r d e rt od os o ,i ti s
i m p o r t a n tt ol o o ka tt h er o l e st h a tp r o c e s s speciﬁcations can play in the context
of web services [94,95]:
–decserflow can be used as a global model , i.e., interactions are described
from the viewpoint of an external observer who oversees all interactions be-
tween all services. such a model is also called a choreography model .n o t e
that such a global model does not need to be executable. however, the model
is still valuable as it allows for conformance checking, i.e., by observing inter-
actions it is possible to detect deviations from the agreed upon choreography
model. here decserflow is competing with languages such as the web ser-
vices choreography description language (ws-cdl) [54].
–decserflow can be used as a local model , i.e., the model that is used to
specify, implement, or conﬁgure a part icular service. here decserflow is
competing with languages such as bpel [18].
as discussed in [94,95], it is interesting to link global and local models. relating
global models (that are produced by analysts to agree on interaction scenarios
from a global perspective) to local mod els (that are produced during system
design and handed on to implementers) is a powerful way of ensuring that ser-vices can work together. although decs erflow can be used at both levels, we
will argue that it is particularly useful at the global level. moreover, we will
show that global models can be used to check conformance using process miningtechniques.
the remainder of this chapter is organized as follows. section 2 describes the
“classical approach” to processes in web se rvices, i.e., petri nets and bpel are
introduced and pointers are given to sta te-of-the-art mappi ngs between them.
section 3 ﬁrst discusses the need for a more declarative language and then intro-
duces the decserflow language. in sectio n 4 the focus shifts from languages to
the monitoring of services. finally ther e is a section on related work (section 5)
and a conclusion (section 6).4
2 classical approaches: bpel and petri nets
before we introduce the decserflow, we focus on two more traditional languages
for the modeling of service ﬂows, i.e., petri nets and bpel. petri nets are more
at the conceptual level and can only serve as a theoretical basis for the modelingand analysis of service ﬂows. bpel is em erging as the de-facto standard for
implementing processes based on web ser vices. in this section, we also discuss
the link between petri nets and bpel and present two tools: one to map petri
nets onto bpel and another to map bpel onto petri nets.
2.1 petri nets
petri nets [78] were among the ﬁrst formalisms to capture the notion of concur-
rency. they combine an intuitive graphical notation with formal semantics and
a wide range of analysis techniques. i n recent years they have been applied in
the context of process-aware information systems [30], workﬂow management [7,
9], and web services [64].
to illustrate the concept of petri nets we use an example that will be used in
the remainder of this chapter. this example is inspired by electronic bookstores
such as amazon and barnes and noble and taken from [16]. figure 1 shows apetri-net that will be partitioned over four partners: (1) the customer ,( 2 )t h e
bookstore (e.g., amazon or barnes and noble), (3) the publisher , and (4) the
shipper . as discussed in the introduction, figure 1 can be considered as a global
model, i.e., interactions are described from the viewpoint of an external observer
who oversees all interactions between all services.
the circles in figure 1 represent places and the squares represent transitions .
initially, there is one token in place start and all other places are empty (we
consider one book order in isolation [7]). transitions are enabled if there is a
token on each of input places. enabled transitions can ﬁreby removing one
token from each input place and producing one token for each output place. in
figure 1, transition place
c
order is enabled. when it ﬁres one token is consumed
and two tokens are produced. in the subsequent state (also called marking)
transition handle
 c
order is enabled. note that transitions rec
accand rec
decl
are not enabled because only one of their input places is marked with a token.
figure 1 represents an inter-organizational workﬂow that is initiated by a
customer placing an order (activity place
 c
order). this customer order is sent
to and handled by the bookstore (activity handle
 c
order). the electronic book-
store is a virtual company which has no books in stock. therefore, the bookstore
transfers the order of the desired book to a publisher (activity place
 b
order).
we will use the term “bookstore order” to refer to the transferred order. the
bookstore order is evaluated by the publisher (activity eval
 b
order) and either
accepted (activity b
accept ) or rejected (activity b
reject). in both cases an appro-
priate signal is sent to the bookstore. i f the bookstore receives a negative answer,
it decides (activity decide ) to either search for an alternative publisher (activ-
ityalt
publ) or to reject the customer order (activity c
reject). if the bookstore
searches for an alternative publisher, a new bookstore order is sent to another5
place_c_order handle_c_orderc_order
handle_c_order
place_b_orderb_order
eval_b_order
b_accept
b_rejectb_decline
rec_declc_declinedecidec_acceptalt_publ
b_confirmc_confirm
s_request
req_shipment
s_decline
s_confirms_rejects_accepteval_s_req
alt_shipper
inform_publ
prepare_b
send_bookprepare_s
ship
notifybook_to_s
book_to_c
notificationship_info
send_bill
bill
payment
payrec_acc
rec_book
rec_bill
handle_paymentc_rejectstart
end
fig. 1. a petri net describing the process as agreed upon by all four parties (i.e., the
global model).6
publisher, etc. if the customer receives a negative answer (activity rec
decl), then
the workﬂow terminates. i f the bookstore receives a positive answer (activity
c
accept ), the customer is informed (activity rec
acc) and the bookstore contin-
ues processing the customer order. the bookstore sends a request to a shipper
(activity req
shipment ), the shipper evaluates the request (activity eval
 s
req)
and either accepts (activity s
accept ) or rejects (activity b
reject)t h er e q u e s t .i f
the bookstore receives a negative answer, it searches for another shipper. this
process is repeated until a shipper accepts. note that, unlike the unavailability
of the book, the unavailability of a shipper cannot lead to a cancellation of the
order. after a shipper is found, the publisher is informed (activity inform
 publ),
the publisher prepares the book for shipment (activity prepare
 b), and the book
is sent from the publisher to the shipper (activity send
 book). the shipper pre-
pares the shipment to the customer (activity prepare
 s) and actually ships the
book to the customer (activity ship). the customer receives the book (activity
rec
book) and the shipper notiﬁes the bookstore (activity notify). the bookstore
sends the bill to the customer (activity send
 bill). after receiving both the book
and the bill (activity rec
bill), the customer makes a payment (activity pay).
then the bookstore processes the payment (activity handle
 payment )a n dt h e
inter-organizational workﬂow terminates.
fig. 2. two analysis plug-in of prom indicate that the petri net shown in figure 1
is indeed sound. the top window shows some diagnostics related to soundness. the
bottom window shows part of the state space.
the petri net shown in figure 1 is a so-called wf-net (workflow-net) be-
cause it has one input place ( start) and one output place ( end) and all places
transitions are on a path from start toend. using tools such as woﬂan [88]7
or prom [29] we can show that the process is sound [2,7]. figure 2 shows a
screenshot of the woﬂan plug-in of prom. soundness means that each processinstance can terminate without any problems and that all parts of the net can
potentially be activated. given a state reachable from the marking with just a
token in place start it is always possible to reach the marking with one token
place end. moreover, from the initial state it is possible to enable any transition
and to mark any place. using prom it is possible to prove that the petri netshown in figure 1 is sound, cf. figure 2.
one can think of the petri net shown in figure 1 as the contract between
the customer, the bookstore, the publishe r, and the shipper (i.e., global model).
clearly there are many customers, publishers, and shippers. therefore, the petri
net should be considered as the contract between all customers, publishers, and
shippers. however, since we model the processing of an order for a single book,
we can assume, without loss of generality, that only one customer, one publisher,
and at most one shipper (at any time) are involved. note that figure 1 abstractsfrom a lot of relevant things. however, given the purpose of this chapter we do
not add more details.
figure 3 shows the same process but now all activities are partitioned over the
four parties involved in the ordering of a book. it shows that each of the parties
is responsible for a part of the process. in terms of web services, we can think
of each of the four large shaded rectangles as a service. the petri-net fragments
inside these rectangles can be seen as speci ﬁcations of the corresponding services
(i.e., local models).
it is interesting to point out that in principle multiple shippers could be
involved, i.e., the ﬁrst shipper may decline and then another shipper is con-
tacted, etc. however, at any point in time, at most one shipper is involved ineach process instance. anothe r interesting aspect is the correlation between the
various processes of the partners. there may be many instances of the process
shown in area labelled bookstore in figure 3. however, each instance is unique
and messages passed over the places connecting the bookstore to the other part-
ners refer to a particular process instance. in general it is a non-trivial problem tocorrelate messages to process instances. s ee [6,73] for a more detailed discussion
on correlation.
we will refer to whole diagram shown in figure 3 as the choreography or
orchestration model of the four services.
2.2 bpel
bpel [18] supports the modeling of two types of processes: executable and ab-
stract processes. an abstract , (not executable) process is a business protocol,
specifying the message exchange behavior between diﬀerent parties without re-
vealing the internal behavior for any one of them. this abstract process views
the outside world from the perspective of a single organization or (composite)
service. an executable process views the world in a similar manner, however,
things are speciﬁed in more detail suc h that the process b ecomes executable,
i.e., an executable bpel process speciﬁes the execution order of a number of8
place_c_order handle_c_orderc_order
handle_c_order
place_b_orderb_order
eval_b_order
b_accept
b_rejectb_decline
rec_declc_declinedecidec_acceptalt_publ
b_confirmc_confirm
s_request
req_shipment
s_decline
s_confirms_rejects_accepteval_s_req
alt_shipper
inform_publ
prepare_b
send_bookprepare_s
ship
notifybook_to_s
book_to_c
notificationship_info
send_bill
bill
payment
payrec_acc
rec_book
rec_bill
handle_paymentc_rejectcustomer bookstore
publisher
shipperstart
end
fig. 3. the process as partitioned over (1) the customer ,( 2 )t h e bookstore ,( 3 )t h e
publisher , and (4) the shipper (i.e., four local models and their interconnections).9
activities constituting the process, the partners involved in the process, the mes-
sages exchanged between these partners, and the faultand exception handling
required in cases of errors and exceptions.
in terms of figure 3 we can think of abstract bpel as the language to specify
one service, i.e., describing the desired behavior of a single petri-net fragment
(e.g., shipper ).executable bpel on the other hand can be used as the means
to implement the desired behavior.
a bpel process itself is a kind of ﬂow-chart, where each element in the
process is called an activity . an activity is either a primitive or a structured
activity. the set of primitive activities contains: invoke , invoking an operation
on a web service; receive , waiting for a message from an external source; reply,
replying to an external source; wait, pausing for a speciﬁed time; assign ,c o p y -
ing data from one place to another; throw, indicating errors in the execution;
terminate , terminating the entir e service instance; and empty , doing nothing.
to enable the presentation of com plex structures the following structured
activities are deﬁned: sequence , for deﬁning an execution order; switch ,f o rc o n -
ditional routing; while, for looping; pick, for race conditions based on timing or
external triggers; ﬂow, for parallel routing; and scope, for grouping activities to
be treated by the same fault-handler. structured activities can be nested andcombined in arbitrary ways. within acti vities executed in parallel the execution
order can further be controlled by the usage of links(sometimes also called con-
trol links, or guarded links), which allows the deﬁnition of directed graphs. the
graphs too can be nested but must be acyclic.
as indicated in the introduction, bpel builds on ibm’s wsfl (web services
flow language) [57] and microsoft’s xl ang (web services for business process
design) [84] and combines the features of a block structured language inherited
from xlang with those for directed graphs originating from wsfl. as a resultsimple things can be implemented in two ways. for example a sequence can be
realized using the sequence orﬂowelements (in the latter case links are used to
enforce a particular order on the parallel elements), a choice based on certaindata values can be realized using the switch orﬂowelements, etc. however, for
certain constructs one is forced to use the block structured part of the language,
e.g., a deferred choice [8] can only be modeled using the pickconstruct. for
other constructs one is forced to use links, i.e., the more graph-oriented part of
the language, e.g., two parallel processes with a one-way synchronization requirealinkinside a ﬂow
. in addition, there are very subtle restrictions on the use of
links: “a link must not cross the boundary of a while activity, a serializable
scope, an event handler or a compensation handler... in addition, a link thatcrosses a fault-handler boundary must be outbound, that is, it must have its
source activity within the fault handler and its target activity within a scope
that encloses the scope associated with the fault handler. finally, a link must
not create a control cycle, that is, the source activity must not have the target
activity as a logically preceding activit y, where an activity a logically precedes
an activity b if the initiation of b semantically requires the completion of a.
therefore, directed gra phs created by links are always acyclic.” (see page 6410
in [18]). all of this makes the language complex for end-users. a detailed or
complete description of bpel is beyond the scope of this chapter. for moredetails, the reader is referred to [18] and various web sites such as the web site
of the oasis technical committee on ws-bpel [70].
2.3 bpel2pn and pn2bpel
as shown, both bpel and petri nets can b e used to describe the process-aspect
of web services. there are several proces s engines supporting petri nets (e.g.,
cosa, yawl, etc.) or bpel (e.g., oracle bpel, ibm websphere, etc.). bpel
currently has strong industry support while petri nets oﬀer a graphical language
and a wide variety of analysis tools (cf. figure 2). therefore, it is interesting to
look at the relation between two. first of all, it is possible to map bpel onto
petri nets for the purpose of analysis. second, it is possible to generate bpelon the basis of petri nets, i.e., mapping a graphical, more conceptual, language
onto a textual language for execution purposes.
several tools have been developed to map bpel onto petri nets (see sec-
tion 5). as a example, we brieﬂy describe the combination formed by bpel2pnml
and wofbpel developed in close collaboration with qut [72]. bpel2pnml
translates bpel process deﬁnitions int o petri nets represented in the petri net
markup language (pnml). wofbpel, built using woﬂan [88], applies static
analysis and transformation techniques to the output produced by bpel2pnml.
wofbpel can be used: (1) to simplify the petri net produced by bpel2pnmlby removing unnecessary silent transiti ons, and (2) to convert the petri net
into a so-called workflow net (wf-net) which has certain properties that sim-
plify the analysis phase. although primarily developed for veriﬁcation purposes,
bpel2pnml and wofbpel have also been used for conformance checking us-
ing abstract bpel processes [6].
<?xml version="1.0" encoding="utf-8"?>
<process xmlns="http://schemas.xmlsoap .org/ws/2003 /03/business-process/"
name="shippe r" xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
xsi:schemalocation="http://schemas.xmlsoap.org/ws/2003/03/business-process/ http://schemas.xmlsoap.o rg/ws/2003/03/business-process/"
targetnamespace="http://shipper">
 <sequence name="sequence_f3">
  <receive name="eval_s_req" />  <switch name="switch_f2">
<case condition="bpws:getvariabledata('accept', 'accept', '//type')!=1">  <invoke name="s_reject" /></case><case condition="bpws:getvariabledata('accept', 'accept', '//type')=1">  <sequence name="sequence_f1">
 <invoke name="s_accept" />
 <receive name="prepare_s" /> <invoke name="ship" /> <invoke name="notify" />
  </sequence></case>
  </switch></sequence>
</process>
fig. 4. the petri net describing the service oﬀered by the shipper is mapped onto
bpel code using workﬂownet2bpel4ws, a tool to automatically translate colored
petri nets into bpel template code.11
few people have been working on the tran slation from petri nets to bpel. in
fact, [9] is the only work we are aware of that tries to go from (colored) petri netsto bpel. using our prom tool [29] we can export a wide variety of languages to
cpn tools. for example, we can load petri net models coming from tools such as
protos, yasper, and woped, epcs coming from tools such as aris, aris ppm,
and epc tools, and workﬂow models coming from tools such as staﬀware and
yawl, and automatically convert the control-ﬂow in these models to petri nets.using our prom tool this can then be exported to cpn tools where it is possible
to do further analysis (state space analysis, simulation, etc.). moreover, wf-nets
in cpn tools can be converted into bpel using workﬂownet2bpel4ws [9,
55]. to illustrate this, consider the shipper service shown in figure 3. the wf-
net corresponding to the shipper process was modeled using the graphical editor
of the cosa workﬂow management system. this was automatically converted
by woﬂan to prom. using prom the pro cess was automatically exported to
cpn tools. then using workﬂownet2bpel4ws the annotated wf-net wastranslated into bpel template code. figure 4 shows both the annotated wf-
net in cpn tools (left) and the automatically generated bpel template code
(right).
the availability of the tools and systems mentioned in this section makes it
possible to support service ﬂows , i.e., the process-aspect of web services, at the
design, analysis, and enactment level. for many applications, bpel, petri nets,
or a mixture of both provide a good basis for making web services “process-
aware”. however, as indicated in the introduction, the focus of this chapter ison decserflow. section 3 introduces d ecserflow and shows that it is a truly
declarative language which addresses the problem of overspeciﬁcation typically
resulting from the procedural languages described in this section. after introduc-ing the language we focus on the monitoring of service ﬂows (section 4) speciﬁed
in terms of decserflow.
3d e c s e r f l o w
the goal of this section is to provide a “fresh view” on process support in thecontext of web services. we ﬁrst argue why a more declarative approach is needed
and then introduce a concrete language: decserflow.
3.1 the need for more dec larative languages
petri nets and bpel have in common that they are highly procedural, i.e., after
the execution of a given activity th e next activities are scheduled.
1seen from
the viewpoint of an execution language the procedural nature of petri nets and
1note that both bpel and petri nets support the deferred choice pattern [8], i.e., it is
possible to put the system in a state where several alternative activities are enabled
but the selection is made by the environment (cf. the pickconstruct in bpel). this
allows for more ﬂexibility. however, it does not change the fact that in essence bothpetri nets and bpel are procedural.12
bpel is not a problem. however, unlike the modules inside a classical system,
web services tend to be rather autonomous and an important challenge is thatall parties involved need to agree on an ov erall global process. currently, terms
likechoreography and orchestration are used to refer to the problem of agreeing
on a common process. some researchers distinguish between choreography and
orchestration, e.g., “in orchestration, there’s someone – the conductor – who tells
everybody in the orchestra what to do and makes sure they all play in sync. inchoreography, every dancer follows a pre-deﬁned plan - everyone independently
of the others.” we will not make this distinction and simply assume that chore-
ographies deﬁne collaborations between interacting parties , i.e., the coordination
process of interconnected web services all partners need to agree on. note that
figure 3 can be seen as an example of a choreography.
within the web services choreography working group of the w3c, a work-
ing draft deﬁning version 1.0 of the web services choreography description lan-
guage (ws-cdl) has been developed [54]. the scope of ws-cdl is deﬁned as
follows: “using the web services choreography speciﬁcation, a contract con-taining a global deﬁnition of the common ordering conditions and constraints
under which messages are exchanged, is produced that describes, from a global
viewpoint, the common and complementar y observable behavior of all the parties
involved. each party can then use the global deﬁnition to build and test solutions
that conform to it. the global speciﬁcation is in turn realized by a combinationof the resulting local systems, on the basis of appropriate infrastructure support.
the advantage of a contract based on a global viewpoint as opposed to any one
endpoint is that it separates the overall global process being followed by an in-dividual business or system within a domain of control (an endpoint) from the
deﬁnition of the sequences in which each business or system exchanges informa-
tion with others. this means that, as long as the observable sequences do not
change, the rules and logic followed within a domain of control (endpoint) can
change at will and interoperability is therefore guaranteed.” [54]. this deﬁnitionis consistent with the deﬁnition of choreography just given. unfortunately, like
most standards in the web services stac k, cdl is verbose and complex. somehow
the essence as shown in figure 3 is lost. moreover, the language again deﬁnesconcepts such as “sequence”, “choice”, and “parallel” in some ad-hoc notation
with unclear semantics. this suggests that some parts of the language are an
alternative to bpel while they are not.
however, the main problem is that ws-cdl, like petri nets and bpel, is
not declarative . a choreography should allow for the speciﬁcation of the “what”
without having to state the “how”. this is similar to the diﬀerence betweenthe implementation of a program and its speciﬁcation. for example, it is close
to impossible to describe that within a choreography two messages exclude one
another. note that such an exclusion constraint is not the same as making a
choice! to illustrate this, assume that there are two actions aandb.t h e s e
actions can correspond to exchange of messages or some other type of activitywhich is relevant for the choreography. the constraint that “ aandbexclude
one another” is diﬀerent from making a choice between aorb. first of all,13
aandbmay be executed multiple times, e.g., the constraint is still satisﬁed
ifais executed 5 times while bis not executed at all. second, the moment
of choice is irrelevant for the constraint. note that the modeling of choices in
a procedural language forces the designe r to indicate explicit decision points
which are evaluated at explicit decision times. therefore, there is a tendency to
overspecify things.
therefore, we propose a more declarative approach based on temporal logic
[61,74] as described in the following subsection.
3.2 decserflow: a declarative service flow language
languages such as linear temporal logic (ltl) [41,45,46] allow for the a more
declarative style of modeling. these languages include temporal operators suchas nexttime (
/circlecopyrtf), eventually ( 3f), always ( 2f), and until ( f/unionsqg), cf. table 1.
however, such languages are diﬃcult to read. therefore, we deﬁne a graphical
syntax for the typical constraints encoun tered in service ﬂows. the combination
of this graphical language and the mapping of this graphical language to ltl
forms the declarative service flow (decserflow) language . we propose decser-
flow for the speciﬁcation of a single service, simple service compositions, and
more complex choreographies .
table 1. brief explanation of the basic ltl temporal operators.
name
 notation
 explanation
nexttime
 /circlecopyrtf
fhas to hold at the next state, e.g., [a,f,b,c,d,e] ,
[a,f,f,f,f,f,b,c,d,e] ,[f,f,f,f,a,b,c,d,e] ,e t c .
eventually
 3f
fhas to hold eventually, e.g., [f,a,b,c,d,e] ,
[a,b,c,f,d,e] ,[abfcdfef] ,e t c .
always
 2f
fhas to always hold, e.g., [f,f,f,f,f,f] .
until
 f/unionsqg
gholds at the current state or at some future state, and
fhas to hold until gholds. when gholds fdoes not
have to hold any more. examples are [g,a,b,c,d,e] ,
[f,g,a,b,c,d,e] , [f,f,f,f,g,a,b,c,d,e] ,
[f,f,f,f,g,a,b,g,f,c,d,e,f,g] ,e t c .
developing a model in decserflow star ts with creating activities. the no-
tion of an activity is like in any other workﬂow-like language, i.e., an activity
is atomic and corresponds to a logical unit of work. however, the nature of therelations between activities in decserflow can be quite diﬀerent than in tradi-
tional procedural workﬂow languages (like petri nets and bpel). for example,
places between activities in a petri net d escribe causal dependencies and can be
used specify sequential, parallel, alternative, and iterative routing. using such
mechanisms it is both possible and necessary to strictly deﬁne howthe ﬂow
will be executed. we refer to the relations between activities in decserflow as
constraints . each of the constraints represents a policy (or a business rule). at14
any point in time during the execution of a s ervice, each constr aint evaluates to
trueorfalse. this value can change during the execution. if a constraint has the
value true, the referring policy is fulﬁlled. if a constraint has the value false,t h e
policy is violated. the execution of a service is correct (according to the dec-
serflow model) at some point in time if all constraints (from the decserflow
model) evaluate to true. similarly, a service has completed correctly if at the end
of the execution all constraints evaluate to true. the goal of the execution of
any decserflow model is not to keep the values of all constraints trueat all
times during the execution. a constraint which has the value falseduring the
execution is not considered an error. co nsider for example the ltl expression
2(a−→3b)w h e r e aandbare activities, i.e., each execution of ais eventually
followed by b. initially (before any activity is executed), this ltl expression
evaluates to true. after executing athe ltl expression evaluates to falseand
this value remains falseuntilbis executed. this illustrates that a constraints
may be temporarily violated. however, the goal is to end the service executionin a state where all constraints evaluate to true.
to create constraint s in decserflow we use constraint templates . each con-
straint template consists of a formula written in ltl and a graphical represen-tation of the formula. an example is the “response constraint” which is denoted
by a special arc connecting two activities aandb. the semantics of such an arc
connecting aandbare given by the ltl expression 2(a−→3b), i.e., any
execution of ais eventually followed by b. we have developed a starting set
of constraint templates and we will use these templates to create a decserflow
model for the electronic bookstore exam ple. this set of templates is inspired by
a collection of speciﬁcation patterns for model checking and other ﬁnite-state
veriﬁcation tools [32]. constraint templates deﬁne various types of dependen-cies between activities at an abstract level. once deﬁned, a template can be
reused to specify constraints between ac tivities in various decserflow models.
it is fairly easy to change, remove and add templates, which makes decserflow
an “open language” that can evolve and be extended according to the demands
from diﬀerent domains. there are three groups of templates: (1) “existence”, (2)“relation”, and (3) “negation” templates. because a template assigns a graphical
representation to an ltl formula, we will refer to such a template as a formula.
before giving an overview of the initial set of formulas and their notation,
we give a small example explaining the basic idea. figure 5 shows a decserflow
model consisting of four activities: a,b,c,a n d d. each activity is tagged with
a constraint describing to the number of times the activity should be executed,
these are the so-called “existe nce formulas”. the arc between aand bis an
example of a “relation formula” and corresponds to the ltl expression discussed
before: 2(a−→3b). the connection between cand ddenotes another
relation formula: 3d−→3c, i.e., if dis executed at least once, cis also
executed at least once. the connection between aand cdenotes a “negation
formula” (the ltl expression 3(a)⇔¬(3(b)) is not show in diagram but will15
a b
c [](a => <> b), i.e., 
every a is eventually 
followed by b
d1..*2 0..*
0..*b is executed
twice
<> d, i.e., d is 
executed at least once<>d => <>c, i.e., if d is
executed at least once, c is 
also executed at least once.
if a is executed at
least once, c is never executed
and vice versa.a can be executed 
an arbitrary
number of times
fig. 5. a decserflow model showing some example notations. (note that the temporal
operators 3and2are denoted as <>and [ ].)
be explained later). note that it is not easy to provide a classical procedural
model (e.g., a petri net) that allows for all behavior modeled figure 5.
existence formulas. figure 6 shows the so-called “existence formulas”. these
formulas deﬁne the cardinality of an activity. for example, the ﬁrst formulais called existence and its visualization is shown (i.e., the annotation “1 ..∗”
above the activity). this indicates that ais executed at least once. formulas
existence2 ,existence3 ,a n d existence
nall specify a lower bound for the number
of occurrences of a. it is also possible to specify an upper bound for the number
of occurrences of a.f o r m u l a s absence ,absence2 ,absence3 ,a n d absence nare also
visualized by showing the range, e.g., “0 ..n”f o rt h er e q u i r e m e n t absence n+1.
similarly, it is possible to specify the e xact number of occurrences as shown in
figure 6, e.g., constraint exactly n(a:activity ) is denoted by an nabove the
activity and speciﬁes that ashould be executed exactly ntimes.
table 2 provides the semantics for each of the notations shown in fig-
ure 6, i.e., each formula is expressed in terms of an ltl expression. formula
existence (a:activity ) is deﬁned as 3(a), i.e., ahas to hold eventually which
implies that in any full execution of the process aoccurs at least once. formula
existence n(a:activity ) shows how it is possible to express a lower bound n
for the number of occurrences of ain a recursive manner, i.e., existence n(a)=
3(a∧/circlecopyrt(existence n−1(a))). formula absence n(a:activity ) can be deﬁned as
the inverse of existence n(a). together they can be combined to express that
for any full execution, ashould be executed a prespeciﬁed number n, i.e.,
exactly n(a)=existence n(a)∧absence n+1(a).
relation formulas. figure 7 shows the so-called “relations formulas”. while an
“existence formula” describes the cardinality of one activity, a “relation for-mula” deﬁnes relation(s) (dependencies) between multiple activities. figure 7
only shows binary relationships (i.e., between two activities), however, in dec-16
0
a2..*
a
3..*
a
n..*
a
0..2
a
0..n
a0..1
a
2
a
n
a1
an..*
a
0..n
a
n
aa1..*
existence(a : activity)
existence2(a : activity)
existence3(a : activity)existence
n(a : activity)
absence(a : activity)
absence2(a : activity)absence3(a : activity)
absence
n+1(a : activity)
exactly1(a : activity)exactly2(a : activity)
exactly
n(a : activity)
fig. 6. notations for the “existence formulas”.
serflow there are also notations involving generalizations to three or more ac-
tivities, e.g., to model an or-split. for simplicity however, we ﬁrst focus on the
binary relationships shown in figure 7. all relation formulas have activities a
andbas parameters and these activities are also shown in the graphical rep-
resentation. the line between the two acti vities in the graphical representation
is unique for the formula, and reﬂects the semantics of the relation. the exis-
tence
 response formula speciﬁes that if activity ais executed, activity balso
has to be executed (at any time, i.e., either before or after activity ais exe-
cuted). according to the co-existence formula, if one of the activities aorbis
executed, the other one has to be executed also. while the ﬁrst two formulas
do not consider the order of activities, formulas response ,precedence and suc-
cession do consider the ordering of activities. formula response requires that
every time activity aexecutes, activity bhas to be executed after it. note that
this is a very relaxed relation of response, because bdoes not have to execute
straight after a, and another acan be executed between the ﬁrst aand the17
table 2. existence formulas.
name of formula
 ltl expression
existence (a:activity )
 3(a)
existence2 (a:activity )
3(a∧/circlecopyrt(existence (a)))
existence3 (a:activity )
3(a∧/circlecopyrt(existence2 (a)))
...
 ...
existence n(a:activity )
3(a∧/circlecopyrt(existence n−1(a)))
absence (a:activity )
 2(¬a)
absence2 (a:activity )
 ¬existence2 (a)
absence3 (a:activity )
 ¬existence3 (a)
...
 ...
absence n(a:activity )
 ¬existence n(a)
exactly1 (a:activity )
 existence (a)∧absence2 (a)
exactly2 (a:activity )
 existence2 (a)∧absence3 (a)
...
 ...
exactly n(a:activity )
existence n(a)∧absence n+1(a)
subsequent b. for example, the execution sequence [b,a,a,a,c,b] satisﬁes the
formula response . the formula precedence requires that activity bis preceded
by activity a, i.e., it speciﬁes that if activity bwas executed, it could not have
been executed until activity awas executed. according to this formula, the ex-
ecution sequence [a,c,b,b,a] is correct. the combination of the response and
precedence formulas deﬁnes a bi-directional execution order of two activities and
is called succession . in this formula, both response and precedence relations have
to hold between the activities aand b. thus, this formula speciﬁes that every
activity ahas to be followed by an activity band there has to be an activity
abefore every activity b. for example, the execution sequence [a,c,a,b,b]
satisﬁes the succession formula.
formulas alternate
 response ,alternate
 precedence and alternate
 succession
strengthen the response ,precedence and succession formulas, respectively. if
activity bisalternate response of activity a, then after the execution of an
activity aactivity bhas to be executed and between the execution of each two
activities aat least one activity bhas to be executed. in other words, after
activity athere must be an activity b, and before that activity bthere cannot
be another activity a. the execution sequence [b,a,c,b,a,b] satisﬁes the al-
ternate response . similarly, in the alternate precedence every instance of activity
bhas to be preceded by an instance of activity aand the next instance of ac-
tivity bcannot be executed before the next instance of activity ais executed.
a c c o r d i n gt ot h e alternate
 precedence , the execution sequence [a,c,b,a,b,a]
is correct. the alternate
 succession is a combination of the alternate
 response
and alternate
 precedence and the sequence [a,c,b,a,b,a,b] would satisfy this
formula.
even more strict ordering relations are speciﬁed by the last three constraints
shown in figure 7: chain
 response ,chain
 precedence and chain
 succession .t h e s e
require that the executions of the two activities ( aand b)a r en e x tt oe a c h18
existence_response(a, b) 
co_existence(a, b) 
response(a, b) 
precedence(a, b) 
succession(a, b) alternate_response(a, b) alternate_precedence(a, b) alternate_succession(a, b) 
chain_response(a, b) 
chain_precedence(a, b) chain_succession(a, b)
b aa bb aa ba bb aa ba ba ba ba b
fig. 7. notations for the “relation formulas”.
other. according to the chain
 esponse constraint the ﬁrst activity after activ-
ityahas to be activity band the execution [b,a,b,c,a,b] would be cor-
rect. the chain
 precedence formula requires that the activity ais the activity
directly preceding any band, hence, the sequence [a,b,c,a,b,a] is correct.
since the chain
 succession formula is the combination of the chain
 response and
chain
 precedence formulas, it requires that activities aand bare always exe-
cuted next to each other. the execution sequence [a,b,c,a,b,a,b] is correct
with respect to this formula.
table 3 shows the formalization of the “relations formulas” depicted in fig-
ure 7. existence
 response (a,b) is speciﬁed by 3(a)⇒3(b) indicating that
some occurrence of ashould always imply an occurrence of beither before or
after a.co
existence (a,b) means that the existence of one implies the existence
of the other and vice versa, i.e., 3(a)⇔3(b).response (a,b) is deﬁned as
2(a⇒3(b)),. this means that at any point in time where activity aoccurs
there should be eventually be an occurrence of b.precedence (a,b) is similar to
response but now looking backwards, i.e., if boccurs at all, then there should
be no occurrence of bbefore the ﬁrst occurrence of a.t h i si sf o r m a l i z e da s :
3(b)⇒((¬b)/unionsqa). note that we use the /unionsq(until) operator here: ( ¬b)/unionsqa19
table 3. relation formulas.
name of formula
 ltl expression
existence
 response (a:activity ,b:activity )
 3(a)⇒3(b)
co
existence (a:activity ,b:activity )
 3(a)⇔3(b)
response (a:activity ,b:activity )
 2(a⇒3(b))
precedence (a:activity ,b:activity )
 3(b)⇒((¬b)/unionsqa)
succession (a:activity ,b:activity )
 response (a,b)∧precedence (a,b)
alternate
 response (a:activity ,b:activity )
 2(a⇒/circlecopyrt((¬a)/unionsqb))
alternate
 precedence (a:activity ,b:activity )
 precedence (a,b)∧
2(b⇒/circlecopyrt(precedence (a,b)))
alternate
 succession (a:activity ,b:activity )
 alternate
 response (a,b)∧
alternate
 precedence (a,b)
chain
 response (a:activity ,b:activity )
 2(a⇒/circlecopyrt(b))
chain
 precedence (a:activity ,b:activity )
 2(/circlecopyrt(b)⇒a)
chain
 succession (a:activity ,b:activity )
 2(a⇔/circlecopyrt(b))
means that aholds (i.e., occurs) at the current state or at some future state,
and¬bhas to hold until aholds. when aholds¬bdoes not have to hold
any more (i.e., bmay occur). succession (a,b) is deﬁned by combining both
into: response (a,b)∧precedence (a,b).alternate
 response (a,b) is deﬁned as
2(a⇒/circlecopyrt((¬a)/unionsqb)), i.e., any occurrence of aimplies that in the next state
and onwards no amay occur until a boccurs. in other words, after activity
at h e r em u s tb ea na c t i v i t y b, and before that activity boccurs there can-
not be another activity a.alternate
 precedence (a,b) is a bit more complicated:
2((b∧/circlecopyrt(3(b)))⇒/circlecopyrt(a/unionsqb)). this implies that at any point in time where
boccurs and at least one other occurrence of bfollows, an ashould occur be-
fore the second occurrence of b.alternate
 succession (a,b) combines both into
alternate
 response (a,b)∧alternate
 precedence (a,b).chain
 response (a,b)i s
deﬁned as 2(a⇒/circlecopyrt(b)) indicating that any occurrence of ashould be directly
followed by b.chain
 precedence (a,b) is the logical counterpart: 2(/circlecopyrt(b)⇒a).
chain
 succession (a,b) is deﬁned as 2(a⇔/circlecopyrt(b)) and speciﬁes that any oc-
currence of ashould be directly followed by band any occurrence of bshould
be directly preceded by a.
negation formulas. figure 8 shows the “negation formulas”, which are the
negated versions of the “relation formulas”. (ignore the grouping of constraints
on the right-hand side of figure 8 for the moment. later, we will show that
the eight constraints can be reduced to th ree equivalence classes.) the ﬁrst two
formulas negate the existence
 response and co
existence formulas. the neg
exist-
ence
 response formula speciﬁes that if activity ais executed activity bmust
never be executed (not before nor after activity a). the neg
co
existence for-
mula applies neg
existence
 response from atoband from btoa.it is impor-
tant to note that the term “negation” should not be interpreted as the “logicalnegation” , e.g., if activity anever occurs, then both existence
response(a,b)
and neg
existence
 response(a,b) hold (i.e., one does not exclude the other). the20
neg_chain_succession(a, b) neg_chain_precedence(a, b) neg_chain_response(a, b) neg_succession(a, b) neg_precedence(a, b) neg_response(a, b) neg_co_existence(a, b) neg_existence_response(a, b) a b
a b
a b
a b
a b
a b
a b
a ba ba ba b
fig. 8. notations for the “negations formulas”.
neg
response formula speciﬁes that after the execution of activity a, activity b
cannot be executed any more. according to the formula neg
precedence activity b
cannot be preceded by activity a. the last three formulas are negations of formu-
laschain
 response ,chain
 precedence and chain
 succession .neg
chain
 response
speciﬁes that ashould never be followed directly by b.neg
chain
 precedence
speciﬁes that bshould never be preceded directly by a.neg
chain
 succession
combines both neg
chain
 response and neg
chain
 precedence . note that figure 8
does not show “negation formulas” for the alternating variants of response, prece-
dence, and succession. the reason is that there is no straightforward and intu-
itive interpretation of t he converse of an alternat ing response, precedence, or
succession.
table 4 shows the ltl expressions of the notations shown in figure 8. ta-
ble 4 also shows that some of the notions are equivalent, i.e., neg
co
existence and
neg
existence
 response are equivalent and similarly the next two pairs of three
formulas are equivalent. note that a similar grouping is shown in figure 8 where a
single representation for each group is suggested. neg
 existence
 response (a,b)
is deﬁned as 3(a)⇒¬(3(b)). however, since the ordering does not mat-
ter,neg
 existence
 response (a,b)=neg
 existence
 response (a,b) and hence co-
incides with neg
 co
existence (a,b).neg
 response (a,b) is deﬁned as 2(a⇒
¬(3(b))), i.e., after any occurrence of a,bmay never happen (or formu-
lated alternatively: any occurrence of bshould take place before the ﬁrst a).
neg
 precedence (a,b) is deﬁned as 2(3(b)⇒(¬a)), i.e., if bmay occur in
some future state, then acannot occur in the current state. it is easy to see that21
table 4. negation formulas (formulas grouped together are equivalent).
name of formula
 ltl expression
neg
existence
 response (a:activity ,b:activity )
 3(a)⇒¬(3(b))
neg
co
existence (a:activity ,b:activity )
 neg
existence
 response (a,b)∧
neg
existence
 response (b,a)
neg
response (a:activity ,b:activity )
 2(a⇒¬(3(b)))
neg
precedence (a:activity ,b:activity )
 2(3(b)⇒(¬a))
neg
succession (a:activity ,b:activity )
 neg
response (a,b)∧
neg
precedence (a,b)
neg
chain
 response (a:activity ,b:activity )
 2(a⇒/circlecopyrt(¬(b)))
neg
chain
 precedence (a:activity ,b:activity )
 2(/circlecopyrt(b)⇒¬(a))
neg
chain
 succession (a:activity ,b:activity )
 neg
chain
 response (a,b)∧
neg
chain
 precedence (a,b)
neg
 precedence (a,b)=neg
 response (a,b) because both state that no bshould
take place after the ﬁrst a(if any). since neg
 succession (a,b) combines both,
also neg
 succession (a,b)= neg
 response (a,b). the last three formulas are
negations of formulas chain
 response ,chain
 precedence and chain
 succession .i t
is easy to see that they are equivalent neg
 chain
 response (a,b)=neg
chain
 pre-
cedence(a,b) =neg
 chain
 succession (a,b).
figures 7 and 8 and the corresponding formalizations show only binary re-
lationships. however, these can easily be extended to deal with more activities.consider for example the response relationship, i.e., response (a,b)=2(a⇒
3(b)). this can easily be extended to response (a,b,c)=2(a⇒(3(b)∨
3(c)), i.e., every occurrence of ais eventually followed by an occurrence of b
orc. this can also be extended to a choice following aofnalternatives, i.e.,
response (a,a
1,a2,..., an)=2(a⇒(3(a1)∨3(a2)∨...∨3(an))).
many of the other formulas can be gener alized in a similar fashion and repre-
sented graphically in an intuitive manner. for example, response (a,b,c), i.e.,
ais eventually followed by an occurrence of borc, is depicted by multiple
arcs that start from the sa me dot. similarly, it is possible to have a precedence
constraint where diﬀerent arrows end i n the same dot indicating that at least
one of the preceding activities should o ccur before the subsequent activity is
executed.
decserflow is an extendible language, i.e., designers can add their own graph-
ical notations and provide their semantics in terms of ltl. for example, one can
add constraints similar to the control-ﬂow dependencies in classical languages
such as petri nets, epcs, etc. and draw diagrams similar to the diagrams pro-vided by these languages. however, the aim is to have a relatively small set of
intuitive notations. in this chapter we show only a core set. figure 9 assists in
reading diagrams using this core notation. when extending the language with
new constraints, it is important to use a set of drawing conventions as shown in
figure 9. for example, a dot connected to some activity ameans that “ aoccurs”
and is always associated to some kind of connection, a line without some arrow
means “occurs at some point in time”, an arrow implies some ordering relation,22
n..m
aon top the lower -bound ( n) and
upper-bound ( m) are spec ified.
a bthe dot shows how to read the constraint,i.e., it means “suppose that a occurs”.
the type of connection describes the type of constraint (inthis case “existence response”) and should be interpreteddepending on the location of the dot.
if a occurs, then also b should occur (at anytime), i.e.,
a btwo dots, i.e., read the “existence response” constraintfrom both sides, i.e.,
a bthe arrow should be interpreted as “is followedby” or “is preceded by” (in this case both).
a bthe negation symbol inverses the meaning of theconnection, i.e.,  in this case  “is not followed by”and “is not preceded by”.a
ana1
a2most of the binary constraintscan be extended to constraintsinvolving an arbitrary number of
activities.
...
fig. 9. explanation of the graphical notation.
two short vertical lines depict a negation, etc. note that figure 9 also shows the
response (a,a1,a2,..., an) constraint described earlier, i.e., ais followed by
at least one of its successors.
3.3 the amazon.com example in decserflow
in this subsection we revisit the amazo n.com example to show how decserflow
language can be used to model services. for this purpose, we will model the
customer service using existence, relation and negation formulas. in this way, wewill use the deﬁned templates for formulas, apply them to activities from our
example and thus create real constraints in our decserflow model. in addition to
this model of a single service, we will also show how the communication between
services can be presented with decser flow by modeling the communication of
the customer service with other services . we start by removing all arcs and places
from the example model. this results in an initial decserflow model populated
only by unconnected activities. next, we create necessary constraints for the
customer . adding constraints to the rest of the model is straightforward and
easy but not necessary for illustrating the decserflow language.
figure 10 shows the new model with decserflow constraints for the cus-
tomer . we added existence constraints for all activities which can be seen as
cardinality speciﬁcations above activities. activity place
c
order has to be exe-
cuted exactly one time. activities rec
accand rec
declcan be executed zero or23
handle_c_orderhandle_c_order
place_b_order eval_b_order
b_accept
b_reject decidec_acceptalt_publ
req_shipment
s_rejects_accepteval_s_req
alt_shipper
inform_publ
prepare_b
send_bookprepare_s
ship
notifysend_bill
handle_paymentc_rejectcustomer bookstore
publisher
shipperresponse responseplace_c_order1
rec_acc0..1
rec_decl0..1
pay0..1rec_bill0..1rec_book0..1precedence
precedenceprecedenceexistence_responseneg_co_existencesuccession
succession
successionprecedence
precedencesuccession
precedence
fig. 10. decserflow model.24
one time, depending on the reply of the bookstore. similarly, activities rec
book,
rec
billand paycan be executed at most one time.
every occurrence of place
 c
order is eventually followed by at least one oc-
currence of rec
accorrec
decl, as indicated by the non-binary relationship also
shown in figure 9. however, it is possi ble that both activities are executed,
and to prevent this we add the neg
co
existence constraint between activities
rec
accand rec
decl. so far, we have managed to make sure that after activ-
ityplace
 c
order one of the activities rec
accand rec
declwill execute in the
service. one problem remains to be solved – we have to specify that none of
the activities rec
accand rec
declcan be executed before activity place
 c
order.
we achieve this by creating two precedence constraints: (1) the one between the
activities place
 c
order and rec
accmaking sure that activity rec
acccan be ex-
ecuted only after activity place
 c
order was executed, and (2) the one between
activities place
 c
order and rec
declmaking sure that activity rec
declcan be
executed only after activity place
 c
order was executed. it is important to note
that the constraints related to place
 c
order,rec
acc,a n d rec
decltogether form
a “classical choice”. it may seem rather clumsy that four constraints are needed
to model a simple choice. however, (1) the four constraints can be merged into
a single notation and ltl formula that can be re-used in other diagrams and
(2) it is a nice illustration of how procedural languages like petri nets and bpel
tend to overspecify things. in fact, in a classical language one would not only im-plicitly specify four elementary constraints, and, in addition, one would typically
need to specify the data conditions. in d ecserflow one can add these conditions,
but one does not need to do so, i.e., one can drop any of the four constraintsinvolving place
c
order,rec
acc,a n d rec
decland still interpret the resulting set
of constraints in a meaningful way.
the next decision to be made is the dependency between the activities rec
acc
and rec
book. in the old model we had a clear sequence between these two activ-
ities. however, due to some problems or errors in the bookstore it might happen
that, although the order was accepted (activity rec
accis executed), the book
does not arrive (activity rec
bookis not executed). however, we assume that the
book will not arrive before the ord er was accepted. the constraint precedence
between the activities rec
accand rec
bookspeciﬁes that activity rec
bookcan be
executed only after activity rec
accwas executed. the old model speciﬁed that
the bill arrives after the book. this may not be always true. since the bill andthe book are shipped by diﬀerent services through diﬀerent channels, the order
of their arrival might vary. for example, it might happen that the shipper who
sends the book is closer to the location of the customer and the bookstore is onanother continent, or the other way around. in the ﬁrst scenario the book will
arrive before the bill, and in the second one the bill will arrive before the book.
therefore we choose not to create an ordering constraint between the activities
rec
bookand rec
bill. even more, our decserflow model accepts the error when
the bill arrives even without the book being sent. this could happen in the caseof an error in the bookstore when a declined order was archived as accepted, and
the bill was sent without the shipment of the book. however, we assume that25
every bookstore that delivers a book, also sends a bill for the book. we specify
this with the existence
 response constraint between the rec
bookactivity and
therec
billactivity. this constraint forces that if activity rec
bookis executed,
then activity rec
billmust have been executed before or will be executed after
activity rec
book. thus, if the execution of activity rec
bookexists, then also the
execution of activity rec
billexists. the constraint precedence between the ac-
tivities rec
billand paymeans that the customer will only pay after the bill was
received. however, after the bill was r eceived the customer does not necessarily
pay, like in the old model. it might happen that the received book was not the
one that was ordered or it was damaged. in these cases, the customer can decidenot to pay the bill.
besides for the modeling of a single se rvice, decserflow language can as
well be used to model the communicati on between services. in figure 10 we
can see how constraints specify the communication of the customer with the
bookstore and the shipper. first, the succession constraint between activity
place
c
order and handle
 c
order speciﬁes that after activity place
 c
order activ-
ityhandle
 c
order has to be executed, and that activity handle
 c
order can be
executed only after activity place
 c
order. this means that every order of a cus-
tomer will be handled in the bookstore, but the bookstore will handle the order
only after it was placed. the same holds (constraint succession ) for the pairs of
activities ( c
accept ,rec
acc), (c
reject,rec
decl)a n d( pay,handle
 payment ). the
relations between the pairs of activities ( ship,rec
book)a n d( send
 bill,rec
bill)
are more relaxed than the previous relations. these two relations are not suc-
cession , but precedence . we can only specify that the book will be received after
it was sent, but we cannot claim that the book that was sent will indeed be
received. it might happen that the shipme nt is lost or destroyed before the cus-
tomer receives the book. the same holds for the bill. because of this we create
the two precedence constraints. the ﬁrst preceden ce constraint is between activ-
ityshipand rec
bookto specify that activity rec
bookcan be executed only after
activity shipwas executed. the second one is between the activities send
 billand
rec
bill, according to which activity rec
billcan be executed only after activity
send
 billwas executed.
figure 10 shows how decserflow langu age can be used to specify services.
while the old petri net model speciﬁed the strict sequential relations betweenactivities, with decserflow we were able to create many diﬀerent relations be-
tween the activities in a more natural way. for the illustration, we developed
constraints only for the customer service and its communication with other ser-
vices, but developing of the rest of the model is as easy and straightforward.
3.4 mapping decserflow onto automata
decserflow can be used in many diﬀerent ways. like abstract bpel it can
be used to specify services but now in a more declarative manner. however,
like executable bpel we can also use it as an execution language. the dec-serflow language can be used as an execution language because it is based on
ltl expressions. every constraint in a decserflow model has both a graphical26
representation and a corresponding parameterized ltl formula. the graphical
notation enables a user-friendly interface and masks the underlying formula. theformula, written in ltl, captures the semantics of the constraint. the core of a
decserflow model consists of a set of act ivities and a number of ltl expressions
that should all evaluate to trueat the end of the model execution.
every ltl formula can be translated into an automaton [26]. algorithms for
translating ltl expressions into automata are given in [40,92]. the possibilityto translate an ltl expression into an automaton and the algorithms to do so,
have been extensively used in the ﬁeld of model checking [26]. moreover, the
initial purpose for developing such algorithms comes from the need to, given amodel, check if certain pr operties hold in the model. the spin tool [50] can be
used for the simulation and exhaustive formal veriﬁcation of systems, and as a
proof approximation system. spin uses an automata theoretic approach for the
automatic veriﬁcation of systems [86]. to use spin, the system ﬁrst has to be
speciﬁed in the veriﬁcation modelling language promela (process meta lan-guage) [50]. spin can verify the correctness of requirements, which are written
as ltl formulas, in a promela model using the algorithms presented in [40,48,
49,51,52,86,77,91]. when checking the correctness of an ltl formula, spinﬁrst creates an automaton for the negation of the formula. if the intersection of
this automaton and the system model automaton is empty, the model is correct
with respect to the requirement described in ltl. when the system model does
not satisfy the ltl formula, the intersection of the model and the automaton for
the negated formula will not be empty, i.e., this intersection is a counterexample
that shows how the formula is violated. the approach based on the negation of
the formula is quicker, because the spin runs veriﬁcation until the ﬁrst coun-
terexample is found. in the case of the formula itself, the veriﬁer would have tocheck all possible scenarios to prove th at a counterexample does not exist.
curse prayresponsebless
fig. 11. a simple model in decserflow.
unlike spin, which generates an automaton for the negation of the formula,
we can execute a decserflow model by c onstructing an automaton for the for-
mula itself . we will use a simple decserflow model to show how processes can
be executed by translating ltl formulas into automata. figure 11 shows a dec-serflow model with three activities: curse,pray,a n d bless. the only constraint
in the model is the response constraint between activity curse and activity pray,
i.e., response (curse,pray)=2(curse⇒3(pray)). this constraint speciﬁes that
if a person curses, (s)he should eventually pray after this. note that there is
no restriction on the execu tion of the activities prayand bless.t h e r ea r en o
existence constraints in this model, beca use all three activities can be executed
an arbitrary number of times.27
p2p1 p2bless
praypraycursecurse,bless
fig. 12. automaton for the formula response.
using the example depicted in figure 11, we brieﬂy show the mapping of ltl
formulas onto automata [40], which is used for execution of decserflow models.automata consists of states and transitio ns. by executing activities of decser-
flow model, we ﬁre transitions and thus change state of the related automaton.
automaton can be in an accep ting or not-accepting st ate. if the automaton is
in an accepting state after executing a cer tain trace (of decserflow activities),
the trace fulﬁls the related ltl formula . if the automaton is not in an accepting
state after executing a certa in trace, the trace violates the related ltl formula.
automata created by the algorithm presented in [40] deal with inﬁnite traces
and cannot be used for execution of ﬁnite traces like decserfl ow traces. there-
fore, a variation of this algorithm that enables work with ﬁnite traces is used
[41]. a more detailed introduction to automata theory and the creation of b¨ uchi
automata from ltl formulas is out of scope of this article and we refer theinterested reader to [26,40,41,48].
figure 12 shows a graph representation of the automaton which is generated
for the response constraint [40]
2. automaton states are represented as nodes, and
transitions as edges. an initial state is represented by an incoming edge with
no source node. an accepting state is rep resented as a node with a double-lined
border. the automaton in figure 12 has two states: p1and p2. state p1is both
the initial and accepting state. note that such automaton can also be generated
for a decserflow model with multiple constraints, i.e., for more than one ltlformula, by constructing one bigltl formula as a conjunction of each of the
constraints.
note that for illustration purposes, we only show a simpliﬁed automaton in
figure 12. any ltl expression is, actually, translated into a automaton, i.e, a
non-deterministic automaton for inﬁnite words . an automaton is deterministic
if in each state there is exactly one transition for each possible input. in case of adeterministic automaton, we can simply change the state of the automata when
executing an activity. to check the correctness of the execution, we check if the
current state is an accepting one. in non- deterministic aut omata, there can be
multiple transitions from a given state for a given possible input. in case of a
decserflow model, the fact that we are de aling with non-deterministic automata
2note that the generated automaton is a non-deterministic automaton. for reasons
of simplicity we use a deterministic automaton with the same results.28
means that executing an activity might transfer an automaton to more that one
next state - a setof possible states. to check the co rrectness of the execution, we
need to check if the current setof possible states contains at least one accepting
state. another issue when executing au tomata for decserflow models is the
fact that we assume that every execution will be completed at some point of
time, i.e., an execution of a decserflow model is a ﬁnite one. the original
algorithm for creating automata from ltl expressions generates automata forinﬁnite words, i.e., for inﬁnite executions [40]. that creates problems because
the criteria for deciding which states a re accepting are diﬀerent for ﬁnite and
inﬁnite words. therefore, we use a modiﬁed version of the original algorithm [41],which was constructed for veriﬁcation of ﬁnite software traces. we use the java
pathexplorer (jpax), a runtime veriﬁcation tool, as a basis [41]. the algorithm
in jpax assumes that the system will start the execution, and does not consider
empty traces. to allow an empty execution of a decserflow model, we add an
invisible activity initand a constraint initiate that speciﬁes that activity init
has to be executed as the ﬁrst activity in the model. we automatically execute
activity initat the beginning of the enactment of a decserflow model. another
small complication is that in the jpax implementation of [41], the
/circlecopyrtoperator
is slightly weaker (if there is no next step, /circlecopyrtfevaluates to true by deﬁnition).
this can be modiﬁed easily by redeﬁning /circlecopyrtfto (/circlecopyrtf∧3f).
the mapping for ltl constraints onto automata allows for the guidance of
people, e.g., it is possible to show wheth er a constraint is in an accepting state or
not. moreover, if the auto maton of a constrai nt is not in an accepting state, it is
possible indicate whether it is still possi ble to reach an accepting state. this way
we can color the constraints green (in accepting state), yellow (accepting state
can still be reached), or red(accepting state cannot be r eached anymore). using
the automaton some engine could even enforce a constraint, i.e., the automaton
c o u l db eu s e dt od r i v eac l a ssical workﬂow engine [7].
3.5 using decserflow to relate global and local models
in the ﬁrst part of the paper we distinguished between global and localmodels.
in the global model interactions are des cribed from the viewpoint of an external
observer who oversees all interactions b etween all services. local models are
used to specify, implement, or conﬁgure p articular services. clearly, both types
of models can be represented using decserflow. moreover, as just shown, it ispossible the construct an automaton to enact a decserflow speciﬁcation. this
seems particularly relevant for local m odels. as we will see in the next section,
both global and local models can be used for monitoring services. for example,given a decserflow speciﬁcation we can al so check whether each party involved
in a choreography actually sticks to the rules agreed upon. the prom framework
oﬀers the so-called ltl-checker to support this (cf. section 4.2). however, before
focusing on the monitoring of service ﬂo ws, we brieﬂy discuss the relevance of
decserflow in relating global and local models.
using decserflow both global and local models can be mapped onto ltl
expressions and automata. this allows for a wide range of model checking ap-29
proaches. for example, it is possible to check if the constraints in the local model
are satisﬁed by the global model and vice versa. note that the set of activitiesin both models does not need to be the same. however, given the logical na-
ture of decserflow this is not a problem. also note that the diﬀerent notions
of inheritance of dynamic behavior can be used in this context [2] (e.g., map
activities onto τactions). the only constraints that seem problematic in this
respect are chained relation formulas, i.e., chain
response ,chain
 precedence ,a n d
chain
 succession . these use the “nexttime” ( /circlecopyrtf) operator whose interpretation
depends on the context, i.e., from a global perspective an activity in one service
may be followed by an activity in another service thus violating some “nexttime”constraint. nevertheless, it seems that the ltl foundation of decserflow oﬀers
a solid basis for comparing global and local models and generating templates for
local models from some partitioned global model.
4 monitoring service flows
decserflow can be used to create both l ocal and global models. as shown in the
previous section, these models can be used to specify a (part of some) service
ﬂow and to enact it. in this section, we show that decserflow can also be used
in the context of monitoring service ﬂows .
in a service-oriented architecture, but al so in classical ent erprise systems,
a variety of events (e.g., messages being sent and received) are being logged.
this information can be used for process mining purposes, i.e., based on some
event log some knowledge is extracted. i n the context of service ﬂows an obvious
starting point is the interception of messages exchanged between the various
services. for example, soap messages can be recorded using tcp tunneling
techniques [6] or, if middleware solutions such as ibm’s websphere are used,
diﬀerent events are logged in a structured manner [73]. although possible, it
is typically not easy to link events (e.g. , soap messages) to process instances
(cases) and activities. however, as pointed out by many researchers, the problem
of correlating messages needs to be addressed anyway. hence, in the remainder,
we assume that it is possible to obtain an event log where each event can belinked to some process instance and some activity identiﬁer.
4.1 classiﬁcation of process mining
assuming that we are able to monitor activities and/or messages being ex-
changed, a wide range of process minin g techniques comes into reach. before
we focus on the relation between decser flow and process mining, we provide a
basic classiﬁcation of process mining approaches. this classiﬁcation is based on
whether there is an a-priori model (e.g., a decserflow speciﬁcation) and, if so,
how it is used.
–discovery : there is no a-priori model, i.e., based on an event log some model
is constructed. for example, using the αalgorithm [15] a process model can30
be discovered based on low-level events. there exist many techniques to
automatically construct p rocess models (e.g., in terms of a petri net) based
on some event log [15,17,27,28,89]. recently, process mining research also
started to target the other perspectives (e .g., data, resources , time, etc.). for
example, the technique described in [ 11] can be used to construct a social
network.
–conformance : there is an a-priori model. this model is compared with the
event log and discrepancies between the log and the model are analyzed.
for example, there may be a process model indicating that purchase ordersof more than 1 million euro require two checks. another example is the
checking of the so-called “four-eyes” principle. conformance checking may
be used to detect deviations, to locate and explain these deviations, andto measure the severity of these deviations. an example is the conformance
checker described in [79] which compa res the event log with some a-priori
process model expressed in terms of a petri net.
–extension : there is an a-priori model. this model is extended with a new
aspect or perspective, i.e., the goal is not to check conformance but to enrich
the model. an example is the extension of a process model with performance
data, i.e., some a-priori process model is used to project the bottlenecks on.
another example is the decision miner described in [80] which takes an a-
priori process model and analyzes ev ery choice in the process model. for
each choice the event log is consulted to see which information is typicallyavailable the moment the choice is mad e. then classical data mining tech-
niques are used to see which data elements inﬂuence the choice. as a result,
a decision tree is generated for each choice in the process.
figure 13 illustrates the classiﬁcation just given in the context of decser-
flow. the ﬁgure shows diﬀerent web services together realizing a service ﬂow.
a decserflow can be used to specify the w hole service ﬂow (global model) or
individual services (local models). as shown in figure 13, we assume that we areable to record events which are stored on some event log. given such an event
log, the three types of process mining (di scovery, conforman ce, and extension)
become possible.
discovery in the context of decserflow would mean that, based on the event
log, we discover a decserflow model, i.e., by analyzing the log diﬀerent con-
straints are discovered. for example, if an activity is always followed by another,
this can be easily be deduced from the log. currently, there exist many processdiscovery approaches [15,17,27,28,89]. although none of them is tailored to-
wards decserflow, it is easy to modify these to yield a (partial) decserflow
model. note that ordering relations discovered by the αalgorithm [15] can eas-
ily be visualized in decserflow.
conformance checking requires an a-priori decserflow model, e.g., a global
model showing the overall service ﬂow. this model can easily be compared with
the event logs, i.e., each constraint in the decserflow speciﬁcation is mapped
onto an ltl expression and it is easy to check whether the ltl expression
holds for a particular process instance. hence it is possible to classify process31
web servicesservice flow
decserflow
modelevent
logsspecifies
global model
discoveryrecords
events, e.g.,
via soap
messagesspecifies/
implementslocal modelsupports/
controls
extensionconformance
fig. 13. overview of the various process mining approaches related to decserflow.
instances into conforming or non-conforming for each constraint. this way it is
possible to show where and how frequent deviations occur. moreover, the (non-
)conforming process instances can be inv estigated further using other process
mining techniques, e.g., to discover the typical features of cases that deviate.
the third type of process mining also r equires an a-priori decserflow model.
however, now the model is extended with complementary information. for ex-
ample, performance data are projected onto the decserflow model or decision
trees are generated for decision points in the process.
as suggested by figure 13, decserflow can be used in combination with
various process mining approaches. it is important to note that the autonomous
nature of services, the declarative style of modeling (avoiding any overspeciﬁca-
tion), and process mining ﬁt well together. the autonomous nature of services
allows services to operate relatively independently. in many cases it is not pos-
sible to enforce control. at best one can agree on a way of working (the global
model) and hope that the other parties involved will operate as promised. how-ever, since it is often not possible to contr ol other services, one can only observe,
detect deviations, and monitor performance.
in the remainder of this section, we discuss some of the features of prom
[29]: a process mining framework oﬀerin g plug-ins for discovery, conformance,
and extension.
4.2 linking decserflow to the prom ltl checker
the prom framework [29] is an open-source infrastructure for process mining
techniques. prom is available as open source software (under the common pub-32
lic license, cpl) and can be downloaded from [75]. it has been applied to var-
ious real-life processes, ranging from administrative processes and health-careprocesses to the logs of complex machines and service processes. prom is plug-
able, i.e., people can plug-in new pieces of functionality. some of the plug-ins are
related to model transformations and various forms of model analysis (e.g., veri-
ﬁcation of soundness, analysis of deadlocks, invariants, reductions, etc.). most of
the plug-ins, however, focus on a particular process mining technique. currently,there are more than 100 plug-ins of which about half are mining and analysis
plug-ins.
starting point for prom are event logs in mxml format. the mxml format
is system-independent and using promimport it is possible to extract logs from
a wide variety of systems, i.e., systems based on products such as sap, people-
soft, staﬀware, flower, websphere, yawl, adept, aris ppm, caramba,
inconcert, oracle bpel, outlook, etc. and tailor-made systems. it is also possi-
ble to load and/or save a variety of models, e.g., epcs (i.e., event-driven processchains in diﬀerent formats, e.g., aris, aris ppm, epml, and visio), bpel
(e.g., oracle bpel, websphere), yawl, petri nets (using diﬀerent formats, e.g.,
pnml, tpn, etc.), cpns (i.e., colored petri nets as supported by cpn tools),and protos.
one of the more than 100 plug-ins oﬀered by prom is the so-called ltl
checker [3]. the ltl checker oﬀers an environment to provide parameters for
predeﬁned parameterized ltl expressions and check these expressions with re-
spect to some event log in mxml format. f or each process instance, it is deter-
mined whether the ltl expression holds or not, i.e., given an ltl expression all
process instances are partitioned on two classes: conforming and non-conforming.
we have predeﬁned 60 typical properties one may want to verify using the ltlchecker (e.g., the 4-eyes principle) [3]. these can be used without any knowledge
of the ltl language. in addition the user can deﬁne new sets of properties. these
properties may be application speciﬁc and may refer to data. each property is
speciﬁed in terms of an ltl expression. formulas may be parameterized, are
reusable, and carry explanations in html format. this way both experts andnovices may use the ltl checker.
recall that each model element of th e decserflow is mapped onto an ltl
expression. therefore, it is possible to use the prom ltl checker to assess theconformance of a decserfl ow model in the context of a real log. all notations
deﬁned in ﬁgures 6, 7, and 8 map directly onto ltl expressions that can be stored
and loaded into prom. currently, we d o not yet provide a direct connection
between the decserflow editor and the prom ltl checker. hence, it is not yet
possible to visualize violations on the decserflow editor. however, it is clearthat such integration is possible.
4.3 other process mining techniques in prom
clearly, the ltl checker is one of the most relevant plug-ins of prom in the con-
text of decserflow. however, the ltl checker plug-in is only one of more than
100 plug-ins. in this subsection, we show some other plug-ins relevant for process33
mining for service ﬂows. first, we show s ome plug-ins related to process discov-
ery. then, we show the prom conforma nce checker that has been successfully
used in the context of (bpel) service ﬂows.
the basic idea of process discovery is to derive a model from some event log.
this model is typically a process model. however, there are also techniques to
discover organization models, social networks, and more data-oriented modelssuch as decision trees. to illustrate the idea of process mining consider the log
shown in table 5. such a log could have been obtained by monitoring the soap
messages the shipper service in figure 3 exchanges with it its environment. note
that we do not show the content of the message. moreover, we do not show
additional header informat ion (e.g., information about sender and receiver).
table 5. an event log.
case identifier
 activity identifier
 time
 data
order290166
 s
request
 2006-04-02t08:38:00
 ...
order090504
 s
request
 2006-04-03t12:33:00
 ...
order290166
 s
confirm
 2006-04-07t23:55:00
 ...
order261066
 s
request
 2006-04-15t06:43:00
 ...
order160598
 s
request
 2006-04-19t20:13:00
 ...
order290166
 book
 to
s
 2006-05-10t07:31:00
 ...
order290166
 book
 to
c
 2006-05-12t08:43:00
 ...
order160598
 s
confirm
 2006-05-20t07:01:00
 ...
order210201
 s
request
 2006-05-22t09:20:00
 ...
order261066
 s
confirm
 2006-06-08t10:29:00
 ...
order290166
 notification
 2006-06-13t14:44:00
 ...
order160598
 book
 to
s
 2006-06-14t16:56:00
 ...
order261066
 book
 to
s
 2006-07-08t18:01:00
 ...
order090504
 s
decline
 2006-07-12t09:00:00
 ...
order261066
 book
 to
c
 2006-08-17t11:22:00
 ...
order210201
 s
decline
 2006-08-18t12:38:00
 ...
order160598
 book
 to
c
 2006-08-25t20:42:00
 ...
order261066
 notification
 2006-09-27t09:51:00
 ...
order160598
 notification
 2006-09-30t10:09:00
 ...
using process mining tools such as prom it is possible to discover a process
model as shown in figure 14. the ﬁgure shows the result of three alternative
process discovery algorithms: (1) the αminer shows the result in terms of a petri
net, (2) the multi-phase miner shows the result in terms of an epc, and (3) theheuristics miner shows the result in terms of a heuristics net.
3they are all able
to discover the shipper service as speciﬁed in figure 3. note that figure 14
shows the names of the messages rather than the activities because this is the
information shown in table 5. note that the algorithms used in figure 14 can
3note that prom allows for the mapping from one format to the other if needed.
figure 14 shows the native format of each of the three plug-ins.34
easily be modiﬁed to generate decserflow models, i.e., constraints imposed by
e.g. a petri net can be mapped onto decserflow notations.
fig. 14. the output of three process discovery algorithms supported by prom when
analyzing the event log shown in table 5.
for process discovery we do not assume th at there is some a-priori model, i.e.,
without any initial bias we try to ﬁnd the a ctual process by analyzing some event
log. however, in many applications there is some a-priori model. for example, we
already showed that prom’s ltl checker can be used to check the conformance
of a decserflow model. however, prom is not limited to decserflow can can also
be used to check the conformance of a sp eciﬁcation in terms of abstract bpel,
epc, or petri nets. to illustrate this, assume that we add an additional process
instance to table 5 where the notiﬁcation is sent before the book is shipped to
the customer (i.e., in figure 3 activity notify takes place before activity ship).
if we assume there is some a-priori model in terms of a petri net, we can
use the conformance checker plug-in of prom. figure 15 shows the result of
this analysis (top-right corner). it shows that the ﬁtness is 0.962 and also high-
lights the part of the model where the de viation occurs (the place connecting
ship/book
 to
cand notify /notiﬁcation ). an event log and petri net “ﬁt” if the
petri net can generate each trace in the l og. in other words: the petri net describ-
ing the choreography should be able to “parse” every event sequence observed by
monitoring e.g. soap messages. in [79] it is shown that it is possible to quantify
ﬁtness as a measure between 0 and 1. the intuitive meaning is that a ﬁtnessclose to 1 means that all observed events can be explained by the model (in the
example about 96 percent). however, the precise meaning is more involved since35
fig. 15. both the conformance checker plug-in and the ltl checker plug-in are able
to detect the deviation.
tokens can remain in the network and not all transactions in the model need to
be logged [79].
unfortunately, a good ﬁtness only does not imply conformance, e.g., it is easy
to construct petri nets that are able to parse any event log (corresponding to
a decserflow model without any constraints, i.e., a model described by true).
although such petri nets have a ﬁtness of 1 they do not provide meaningfulinformation. therefore, we use a second dimension: appropriateness . appropri-
ateness tries to capture the idea of occam’s razor , i.e., “one should not increase,
beyond what is necessary, the number of en tities required to explain anything”.
appropriateness tries to answer the following question: “does the model de-
scribe the observed process in a suitab le way?” and can be evaluated from both
astructural and a behavioral perspective. to explain t he concept in more detail
it is important to note that there are two extreme models that have a ﬁtness of
1. first of all there is the model that starts with a choice and then has one pathper process instance, i.e., the model simply enumerates all possibilities. this
model is “overﬁtting” since it is simply another representation of the log, i.e.,
it does not allow for more sequences than those that were observed in the log.
therefore, it does not oﬀer a better understanding than what can be obtained
by just looking at the aggregated log. secondly, there is the so called “ﬂower
petri net” [79] that can parse any log, i.e., there is one state in which all activ-
ities are enabled. this model is “underﬁtting” since it contains no information
about the ordering of activities. in [79] it is shown that a “good” process modelshould somehow be minimal in structure to clearly reﬂect the described behav-
ior, referred to as structural appropriateness , and minimal in behavior in order36
to represent as closely as possible what actually takes place, which will be called
behavioral appropriateness . the prom conformance checker supports both the
notion of ﬁtness and the various notions of appropriateness.
in [6] we have demonstrated that any (abstract) bpel speciﬁcation can
automatically be mapped onto a petri net that can be used for conformance
checking using prom’s conformance checker.
figure 15 also shows the ltl checker plug-in while checking the response
property on book
 to
cand notiﬁcation . this check shows that indeed there is
one process instance where activity notify takes place before activity ship.t h i s
example shows that it is possible to compare a decserflow speciﬁcation and an
event log and to locate the deviations.
5 related work
since the early nineties, workﬂow technology has matured [39] and several text-books have been published, e.g., [7,30]. most of the available systems use some
proprietary process modeling language and, even if systems claim to support
some “standard”, there are often all kinds of system-speciﬁc extensions and lim-itations. petri nets have been used for the modeling of workﬂows [7,25,30] but
also the orchestration of web services [65]. like most proprietary languages and
standards, petri nets are highly procedural. this is the reason we introduced the
decserflow language in this chapter.
several attempts have been made to capture the behavior of bpel [18] in
some formal way. some advocate the use of ﬁnite state machines [35], others
process algebras [34], and yet others abstract state machines [33] or petri nets [71,62,83,87]. (see [71] for a more detailed literature review.) for a detailed analysis
of bpel based on the workﬂow patterns [8] we refer to [90]. few researchers have
explored the other directio n, e.g., translating (colored) petri nets into bpel [9].
the work presented in this chapter is also related to the choreography lan-
guage “let’s dance” [94,95]. let’s dance is a language for modeling service in-
teractions and their ﬂow dependencies. the focus of let’s dance is not so much
on the process perspective (although a p rocess modeling notation is added); in-
stead it focuses on interaction patterns and mechanisms. similar to decserflow
it is positioned as an alternative to the web services choreography description
language (ws-cdl) [54].
clearly, this chapter builds on earlier work on process discovery, i.e., the
extraction of knowledge from event logs (e.g., process models [15,17,27,37,38,
47] or social networks [12]). for example, the well-known αalgorithm [15] can
derive a petri net from an event log. in [6] we used the conformance checkingtechniques described in [79] and implemented in our prom framework [29] and
applied this approach to soap messages generated from oracle bpel. the
notion of conformance has also been discussed in the context of security [10],
business alignment [1], and genetic mining [66].
it is impossible to give a complete overvi ew of process mining here. therefore,
we refer to a special issue of computers in industry on process mining [14] and a37
survey paper [13]. process mining can be s een in the broader context of business
(process) intelligence (bpi) and business activity monitoring (bam). in [43,44,81] a bpi toolset on top of hp’s process manager is described. the bpi
toolset includes a so-called “bpi process mining engine”. in [69] zur muehlen
describes the pisa tool which can be used to extract performance metrics from
workﬂow logs. similar diagnostics are provided by the aris process performance
manager (ppm) [53]. the latter tool is commercially available and a customizedversion of ppm is the staﬀware process monitor (spm) [85] which is tailored
towards mining staﬀware logs.
the need for monitoring web services ha s been raised by other researchers.
for example, several research groups have been experimenting with adding mon-
itor facilities via soap monitors in axis [19]. [56] introduces an assertion lan-
guage for expressing business rules and a framework to plan and monitor theexecution of these rules. [21] uses a monitoring approach based on bpel. mon-
itors are deﬁned as additional services and linked to the original service compo-
sition. another framework for monitoring the compliance of systems composedof web-services is proposed in [60]. this approach uses event calculus to specify
requirements. [59] is an approach based on ws-agreement deﬁning the crona
framework for the creation and monitoring of agreements. in [42,31], dustdar et
al. discuss the concept of web services mining and envision various levels (web
service operations, interactions, and workﬂows) and approaches. our approachﬁts in their framework and shows that web-services mining is indeed possible.
in [73] a tool named the web service navigator is presented to visualize the
execution of web services based on soa p messages. the authors use message
sequence diagrams and graph-based representations of the system topology. note
that also in [5] we suggested to focus less on languages like bpel and more on
questions related to the monitoring o f web services. in [6] we showed that it
is possible to translate abstract bpel into petri nets and soap messages ex-
changed between services into event logs represented using the mxml format(i.e., the format used by our process mining tools). as a result we could demon-
strate that it is possible to compare the modeled behavior (in terms of a petri
net) and the observed behavior (in some event log). we used oracle bpel anddemonstrated that it is possible to monitor soap messages using tcp tunnel-
ing technique [6]. this comparison could be used for monitoring deviations and
to analyze the most frequently used parts of the service/choreography.
this chapter discussed the idea of conformance checking by comparing the
observed behavior recorded in logs wi th some predeﬁned model. this could be
termed “run-time conforman ce”. however, it is also po ssible to address the issue
ofdesign-time conformance , i.e., comparing diﬀerent process models before en-
actment. for example, one could compare a speciﬁcation in abstract bpel with
an implementation using executable bpel. similarly, one could check at design-
time the compatibility of diﬀerent services. here one can use the inheritance
notions [2] explored in the context of workﬂow management and implementedin woﬂan [88]. axel martens et al. [62–64,82] have explored questions related
to design-time conformance and compatibility using a petri-net-based approach.38
for example, [63] focuses on the proble m of consistency between executable and
abstract processes and [64] presents an approach where for a given composite ser-vice the required other services are gen erated. also related is [36] were message
sequence charts (mscs) are compiled into the “finite state process” notation
to describe and reason about web service compositions.
6c o n c l u s i o n
this chapter focussed on service ﬂows both from the viewpoint of speciﬁca-
tion/enactment and monitoring.
first, we discussed more traditional approaches based on petri nets and
bpel. we showed that petri nets provide a nice graphical representation and a
wide variety of analysis techniques, and mentioned that bpel has strong indus-try support making it a viable execution platform. we also showed that there are
mappings from bpel to petri net for the purpose of analysis (cf. bpel2pnml
and wofbpel [72]). moreover, it is possible to translate graphical languages
such a petri nets to bpel (cf. workﬂownet2bpel4ws [55]). using such tech-
niques it is also possible to translate languages such as epcs, bpmn, etc. tobpel.
although the ﬁrst author has been invo lved in the development of these tools
and these tools are mature enough to be applied in real-life applications, bothpetri nets and bpel are rather procedural and this does not ﬁt well with the
autonomous nature of services. therefore, we proposed a new, more declarative
language: decserflow . although decserflow is graphical, it is grounded in tem-
poral logic. it can be used for the enactment of processes, but it is particularly
suited for the speciﬁcation of a single service or a complete choreography. in the
last part of this chapter, the focus shifted from languages to process mining. we
showed that the combination of decser flow and process mining (conformance
checking in particular) is useful in the setting of web services. moreover, weshowed that decserflow can be combine d well with the conformance-checking
techniques currently implemented in prom (cf. the ltl checker plug-in).
decserflow also seems to be an interesting proposal for linking global and
local models. if both the global model (i.e., the view on the process as seen
by some external observer) and one or more local models (i.e., the speciﬁcation
or implementation of a single service or service composition) are modeled in
decserflow, standard model checking techniques can be used to compare both.
to conclude we would like to mention that all of the presented analysis and
translation tools can be downloaded from various websites: [75] (prom), [20]
(bpel2pnml and wofbpel), and [93] (workﬂownet2bpel4ws).
references
1. w.m.p. van der aalst. business alignment: using process mining as a tool
for delta analysis. in j. grundspenkis and m. kirikova, editors, proceedings
of the 5th workshop on business process modeling, development and support39
(bpmds’04) , volume 2 of caise’04 workshops , pages 138–145. riga technical
university, latvia, 2004.
2. w.m.p. van der aalst and t. basten. inheritance of workﬂows: an approach
to tackling problems related to change. theoretical computer science , 270(1-
2):125–203, 2002.
3. w.m.p. van der aalst, h.t. de beer, and b.f. van dongen. process mining and
veriﬁcation of properties: an approach based on temporal logic. in r. meers-
man and z. tari et al., editors, on the move to meaningful internet systems
2005: coopis, doa, and odbase: otm confederated international confer-
ences, coopis, doa, and odbase 2005 , volume 3760 of lecture notes in com-
puter science , pages 130–147. springer-verlag, berlin, 2005.
4. w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. web service com-
position languages: old wine in new bottles? in g. chroust and c. hofer,
editors, proceeding of the 29th euromicro conference: new waves in system
architecture , pages 298–305. ieee computer society, los alamitos, ca, 2003.
5. w.m.p. van der aalst, m. dumas, a.h.m. ter hofstede, n. russell, h.m.w. ver-
beek, and p. wohed. life after bpel? in m. bravetti, l. kloul, and g. zavattaro,
editors, ws-fm 2005 , volume 3670 of lecture notes in computer science , pages
35–50. springer-verlag, berlin, 2005.
6. w.m.p. van der aalst, m. dumas, c. ouyang, a. rozinat, and h.m.w. verbeek.
choreography conformance checking: an approach based on bpel and petri
nets (extended version). bpm center report bpm-05-25, bpmcenter.org, 2005.
7. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, meth-
ods, and systems . mit press, cambridge, ma, 2002.
8. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
9. w.m.p. van der aalst, j.b. jørgensen, and k.b. lassen. let’s go all the way:
from requirements via colored workﬂow nets to a bpel implementation of
a new bank system paper. in r. meersman and z. tari et al., editors, on
the move to meaningful internet systems 2005: coopis, doa, and odbase:
otm confederated international conferences, coopis, doa, and odbase 2005 ,
volume 3760 of lecture notes in computer science , pages 22–39. springer-verlag,
berlin, 2005.
10. w.m.p. van der aalst and a.k.a. de medeiros. process mining and security:
detecting anomalous process executions and checking process conformance. in
n. busi, r. gorrieri, and f. martinelli, editors, second international workshop
on security issues with petri nets and other computational models (wisp 2004) ,
pages 69–84. star, servizio tipograﬁco area della ricerca, cnr pisa, italy,
2004.
11. w.m.p. van der aalst, h.a. reijers, and m. song. discovering social networks
from event logs. computer supported cooperative work , 14(6):549–593, 2005.
12. w.m.p. van der aalst and m. song. mining social networks: uncovering inter-
action patterns in business processes. in j. desel, b. pernici, and m. weske, edi-
tors, international conference on business process management (bpm 2004) ,v o l -
ume 3080 of lecture notes in computer science , pages 244–260. springer-verlag,
berlin, 2004.
13. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.40
14. w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining ,s p e c i a l
issue of computers in industry, volume 53, number 3. elsevier science publishers,
amsterdam, 2004.
15. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
16. w.m.p. van der aalst and m. weske. the p2p approach to interorganizational
workﬂows. in k.r. dittrich, a. geppert, and m.c. norrie, editors, proceedings of
the 13th international conference on advanced information systems engineering(caise’01) , volume 2068 of lecture notes in computer science , pages 140–156.
springer-verlag, berlin, 2001.
17. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
18. t. andrews, f. curbera, h. dholakia, y. goland, j. klein, f. leymann, k. liu,
d. roller, d. smith, s. thatte, i. trickovic, and s. weerawarana. business processexecution language for web services, version 1.1. standards proposal by bea
systems, international business machines corporation, and microsoft corpora-
tion, 2003.
19. apache axis, http://ws.apache.org/axis/ .
20. babel, expressiveness comparison and interchange facilitation between busi-
ness process execution languages, http://www.bpm.fit.qut.edu.au/projects/
babel/tools/ .
21. l. baresi, c. ghezzi, and s. guinea. smart monitors for composed services. in
icsoc ’04: proceedings of the 2nd international conference on service orientedcomputing , pages 193–202, new york, ny, usa, 2004. acm press.
22. t. belwood and et al. uddi version 3.0. http://uddi.org/pubs/uddi\_v3.htm ,
2000.
23. d. box, d. ehnebuske, g. kakivaya, a. layman, n. mendelsohn, h. nielsen,
s. thatte, and d. winer. simple object access protocol (soap) 1.1. http:
//www.w3.org/tr/soap , 2000.
24. e. christensen, f. curbera, g. meredith, and s. weerawarana. web services
description language (wsdl) 1.1. http://www.w3.org/tr/wsdl , 2001.
25. p. chrzastowski-wachtel. a top-down petri net based approach for dynamic
workﬂow modeling. in w.m.p. van der aalst, a.h.m. ter hofstede, and m. weske,
editors, international conference on business process management (bpm 2003) ,
volume 2678 of lecture notes in computer science , pages 336–353. springer-
verlag, berlin, 2003.
26. e.m. clarke, o. grumberg, and d.a. peled. model checking . the mit press,
cambridge, massachusetts and london, uk, 1999.
27. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
28. a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275–301,
1998.
29. b.f. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters,
and w.m.p. van der aalst. the prom framework: a new era in process mining
tool support. in g. ciardo and p. darondeau, editors, application and theory
of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
444–454. springer-verlag, berlin, 2005.41
30. m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.
31. s. dustdar, r. gombotz, and k. baina. web services interaction mining. techni-
cal report tuv-1841-2004-16, information systems institute, vienna university
of technology, wien, austria, 2004.
32. m.b. dwyer, g.s. avrunin, and j.c. corbett. patterns in property speciﬁcations
for finite-state veriﬁcation. in icse ’99: proceedings of the 21st international
conference on software engineering , pages 411–420, los alamitos, ca, usa, 1999.
ieee computer society press.
33. d. fahland and w. reisig. asm-based semantics for bpel: the negative control
ﬂow. in d. beauquier and e. b¨ orger and a. slissenko, editor, proc. 12th interna-
tional workshop on abstract state machines , pages 131–151, paris, france, march
2005.
34. a. ferrara. web services: a process algebra approach. in proceedings of the 2nd
international conference on service oriented computing , pages 242–251, new york,
ny, usa, 2004. acm press.
35. j.a. fisteus, l.s. fern´ andez, and c.d. kloos. formal veriﬁcation of bpel4ws
business collaborations. in k. bauknecht, m. bichler, and b. proll, editors, pro-
ceedings of the 5th international conference on electronic commerce and webtechnologies (ec-web ’04) , volume 3182 of lecture notes in computer science ,
pages 79–94, zaragoza, spain, august 2004. springer-verlag, berlin.
36. h. foster, s. uchitel, j. magee, and j. kramer. model-based veriﬁcation of web
service composition. in proceedings of 18th ieee international conference on
automated software engineering (ase) , pages 152–161, montreal, canada, oc-
tober 2003.
37. w. gaaloul, s. bhiri, and c. godart. discovering workﬂow transactional be-
havior from event-based log. in r. meersman, z. tari, w.m.p. van der aalst,
c. bussler, and a. gal et al., editors, on the move to meaningful internet sys-
tems 2004: coopis, doa, and odbase: otm confederated international con-
ferences, coopis, doa, and odbase 2004 , volume 3290 of lecture notes in
computer science , pages 3–18, 2004.
38. w. gaaloul and c. godart. mining workﬂow recovery from event based logs. in
w.m.p. van der aalst, b. benatallah, f. casati, and f. curbera, editors, business
process management (bpm 2005) , volume 3649, pages 169–185. springer-verlag,
berlin, 2005.
39. d. georgakopoulos, m. hornick, and a. sheth. an overview of workﬂow manage-
ment: from process modeling to workﬂow automation infrastructure. distributed
and parallel databases , 3:119–153, 1995.
40. r. gerth, d. peled, m.y. vardi, and p. wolper. simple on-the-fly automatic
veriﬁcation of linear temporal logic. in proceedings of the fifteenth ifip wg6.1
international symposium on protocol speciﬁcation, testing and veriﬁcation xv ,
pages 3–18, london, uk, 1996. chapman & hall, ltd.
41. d. giannakopoulou and k. havelund. automata-based veriﬁcation of temporal
properties on running programs. in ase ’01: proceedings of the 16th ieee in-
ternational conference on automated software engineering , page 412, washington,
dc, usa, 2001. ieee computer society.
42. r. gombotz and s. dustdar. on web services mining. in m. castellanos and
t. weijters, editors, first international workshop on business process intelli-
gence (bpi’05) , pages 58–70, nancy, france, september 2005.42
43. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321–343, 2004.
44. d. grigori, f. casati, u. dayal, and m.c. shan. improving business process qual-
ity through exception understanding, prediction, and prevention. in p. apers,
p. atzeni, s. ceri, s. paraboschi, k. ramamohanarao, and r. snodgrass, ed-
itors, proceedings of 27th international conference on very large data bases
(vldb’01) , pages 159–168. morgan kaufmann, 2001.
45. k. havelund and g. rosu. monitoring programs using rewriting. in proceedings
of the 16th ieee international conference on automated software engineering(ase’01) , pages 135–143. ieee computer society press, providence, 2001.
46. k. havelund and g. rosu. synthesizing monitors for safety properties. in pro-
ceedings of the 8th international conference on tools and algorithms for the con-struction and analysis of systems (tacas 2002) , volume 2280 of lecture notes
in computer science , pages 342–356. springer-verlag, berlin, 2002.
47. j. herbst. a machine learning approach to workﬂow management. in pro-
ceedings 11th european conference on machine learning , volume 1810 of lecture
notes in computer science , pages 183–194. springer-verlag, berlin, 2000.
48. g.j. holzmann. the model checker spin. ieee trans. softw. eng. , 23(5):279–
295, 1997.
49. g.j. holzmann. an analysis of bitstate hashing. form. methods syst. des. ,
13(3):289–307, 1998.
50. g.j. holzmann. the spin model checker: primer and reference manual.
addison-wesley, boston, massachusetts, usa, 2003.
51. g.j. holzmann and d. peled. an improvement in formal veriﬁcation. in forte
1994 conference , bern, switzerland, 1994.
52. g.j. holzmann, d. peled, and m. yannakakis. on nested depth-ﬁrst search. in the
spin veriﬁcation system, proceedings of the 2nd spin works hop.), pages 23–32.
american mathematical society, 1996.
53. ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com , 2002.
54. n. kavantzas, d. burdett, g. ritzinger, t. fletcher, and y. lafon. web services
choreography description language, v ersion 1.0. w3c working draft 17-12-04,
2004.
55. k.b. lassen and w.m.p. van der aalst. workﬂownet2bpel4ws: a tool for
translating unstructured workﬂow processes to readable bpel. beta working
paper series, wp 167, ei ndhoven university of tec hnology, eindho ven, 2006.
56. a. lazovik, m. aiello, and m. papazoglou. associating assertions with business
processes and monitoring their execution. in icsoc ’04: proceedings of the
2nd international conference on service oriented computing , pages 94–104, new
york, ny, usa, 2004. acm press.
57. f. leymann. web services flow language, version 1.0, 2001.
58. f. leymann and d. roller. production workﬂow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
59. h. ludwig, a. dan, and r. kearney. crona: an architecture and library for
creation and monitoring of ws-agreements. in icsoc ’04: proceedings of the
2nd international conference on service oriented computing , pages 65–74, new
york, ny, usa, 2004. acm press.
60. k. mahbub and g. spanoudakis. a framework for requirents monitoring of
service based systems. in icsoc ’04: proceedings of the 2nd international con-43
ference on service oriented computing , pages 84–93, new york, ny, usa, 2004.
acm press.
61. z. manna and a. pnueli. the temporal logic of reactive and concurrent systems:
speciﬁcation . springer-verlag, new york, 1991.
62. a. martens. analyzing web service based business processes. in m. cerioli, ed-
itor, proceedings of the 8th international conference on fundamental approaches
to software engineering (fase 2005) , volume 3442 of lecture notes in computer
science , pages 19–33. springer-verlag, berlin, 2005.
63. a. martens. consistency between executable and abstract processes. in pro-
ceedings of international ieee conference on e-technology, e-commerce, and
e-services (eee’05) , pages 60–67. ieee computer society press, 2005.
64. p. massuthe, w. reisig, and k. schmidt. an operating guideline approach to
the soa. in proceedings of the 2nd south-east european workshop on formal
methods 2005 (seefm05) , ohrid, republic of macedonia, 2005.
65. m. mecella, f. parisi-presicce, and b. pernici. modeling e-service orchestration
through petri nets. in proceedings of the third international workshop on tech-
nologies for e-services , volume 2644 of lecture notes in computer science , pages
38–47. springer-verlag, berlin, 2002.
66. a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. using ge-
netic algorithms to mine process models: representation, operators and results.
beta working paper series , wp 124, ei ndhoven university o f technology, eind-
hoven, 2004.
67. r. milner. communicating and mobile systems: the pi-calculus . cambridge
university press, cambridge, uk, 1999.
68. m. zur muehlen. workﬂow-based process controlling: foundation, design and
application of workﬂow-driven process information systems . logos, berlin, 2004.
69. m. zur m¨ uhlen and m. rosemann. workﬂow-based process monitoring and con-
trolling - technical and organizational issues. in r. sprague, editor, proceedings
of the 33rd hawaii international conference on system science (hicss-33) , pages
1–10. ieee computer society press, los alamitos, california, 2000.
70. oasis web services business process execution language (wsbpel) tc, http:
//www.oasis-open.org/committees/tc\_home.php?wg\_abbrev=wsbpel .
71. c. ouyang, w.m.p. van der aalst, s. breutel, m. dumas, a.h.m. ter hofstede,
and h.m.w. verbeek. formal semantics and analysis of control flow in ws-
bpel. bpm center report bpm-05-15, bpmcenter.org, 2005.
72. c. ouyang, e. verbeek, w.m.p. van der aalst, s. breutel, m. dumas, and a.h.m.
ter hofstede. wofbpel: a tool for automated analysis of bpel processes. in
b. benatallah, f. casati, and p. traverso, editors, proceedings of service-oriented
computing (icsoc 2005) , volume 3826 of lecture notes in computer science ,
pages 484–489. springer-verlag, berlin, 2005.
73. w. de pauw, m. lei, e. pring, l. villard, m. arnold, and j.f. morar. web
services navigator: visualizing the execution of web services. ibm systems
journal , 44(4):821–845, 2005.
74. a. pnueli. the temporal logic of programs. in proceedings of the 18th ieee
annual symposium on the foundations of computer science , pages 46–57. ieee
computer society press, providence, 1977.
75. process mining home page, http://www.processmining.org .
76. process modelling group, http://process-modelling-group.org .
77. a. puri and g.j. holzmann. a minimized automaton representation of reachable
states. in software tools for technology transfer , volume 3. springer-verlag,
berlin, 1993.44
78. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
79. a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 163–176. springer-verlag, berlin,
2006.
80. a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. faideiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420–425. springer-verlag, berlin, 2006.
81. m. sayal, f. casati, u. dayal, and m.c. shan. business process cockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb’02) ,
pages 880–883. morgan kaufmann, 2002.
82. b.h. schlingloﬀ, a. martens, and k. schmidt. modeling and model checking web
services. electronic notes in theoretical computer science: issue on logic and
communication in multi-agent systems , 126:3–26, mar 2005.
83. c. stahl. transformation von bpel4ws in petrinetze (in german). master’s
thesis, humboldt university, berlin, germany, 2004.
84. s. thatte. xlang web services for business process design, 2001.85. tibco. tibco staﬀware process monitor (spm). http://www.tibco.com , 2005.
86. m.y. vardi and p. wolper. an automata-theoretic approach to automatic program
veriﬁcation. in in proceedings of the 1st symposium on logic in computer science ,
pages 322–331, cambridge, massachusetts, usa, 1986.
87. h.m.w. verbeek and w.m.p. van der aalst. analyzing bpel processes us-
ing petri nets. in d. marinescu, editor, proceedings of the second international
workshop on applications of petri nets to coordination, workﬂow and busi-
ness process management , pages 59–78. florida international university, miami,
florida, usa, 2005.
88. h.m.w. verbeek, t. basten, and w.m.p. van der aalst. diagnosing workﬂow
processes using woﬂan. the computer journal , 44(4):246–279, 2001.
89. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.
90. p. wohed, w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. analysis of
web services composition languages: the case of bpel4ws. in i.y. song, s.w.liddle, t.w. ling, and p. scheuermann, editors, 22nd international conference
on conceptual modeling (er 2003) , volume 2813 of lecture notes in computer
science , pages 200–215. springer-verlag, berlin, 2003.
91. p. wolper and d. leroy. reliable hashing without collision detection. in proc.
5th int. conference on computer aided veriﬁcation , pages 59–70, 1993.
92. p. wolper, m.y. vardi, and a.p. sistla. reasoning about inﬁnite computation
paths. in proceedings of the 24th ieee symposium on foundation of cumputer
science , pages 185–194, tucson, arizona, november 1983.
93. workﬂownet2bpel4ws, http://www.daimi.au.dk/ ~krell/
workflownet2bpel4ws/ .
94. j.m. zaha, a. barros, m. dumas, and a.h.m. ter hofstede. lets dance: a lan-
guage for service behavior modeling. qut eprints 4468, faculty of informationtechnology, queensland university of technology, 2006.45
95. j.m. zaha, m. dumas, a.h.m. ter hofstede, a. barros, and g. dekker. service in-
teraction modeling: bridging global and local views. qut eprints 4032, faculty
of information technology, queensland university of technology, 2006.