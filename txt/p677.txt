runtime veriﬁcation
of ltl-based declarative process models
fabrizio maria maggi1,⋆, michael westergaard1,⋆⋆,
marco montali2,⋆⋆⋆,a n dw i lm . p .v a nd e ra a l s t1
1eindhoven university of technology, the netherlands
{f.m.maggi,m.westergaard,w.m.p.v.d.aalst }@tue.nl
2krdb research centre, free university of bozen-bolzano, italy
montali@inf.unibz.it
abstract. linear temporal logic (ltl) on ﬁnite traces has proven to
be a good basis for the analysis and enactment of ﬂexible constraint-
based business processes. the declarelanguage and system beneﬁt from
this basis. moreover, ltl-based languages like declare can also be used
for runtime veriﬁcation. as there are often many interacting constraints,
itisimportanttokeeptrackof individual constraints and combinations of
potentially conﬂicting constraints . inthispaper,weoperationalize theno-
tionof conﬂicting constraints anddemonstratehow innovativeautomata-
based techniques can be applied to monitor running process instances.
conﬂicting constraints are detecte d immediately and our toolset (real-
ized using declare and prom) provides meaningful diagnostics.
keywords: monitoring,lineartemporallogic,finitestateautomata,
declarative business processes, operational support, process mining.
1 introduction
linear temporal logic (ltl) provides a solid basis for design-time veriﬁcation
and model checking. moreover, ltl has also been used for the runtime veriﬁca-
tionof dynamic, event-based systems. in thi s latter setting, d esired properties
are expressed in terms of ltl. these properties and/or their conjunction are
translated to a monitor which can be used to dynamically evaluate whether the
current trace, representing an evolvi ng run of the system, complies with the
desired behavior or not.
traditionally, ltl-based approaches were mainly used to verify or moni-
tor running programs. however, the need for ﬂexibility and a more declarative
view on work processes fueled the interest in the business process management
⋆research carried out as part of the poseidon project at thales under the re-
sponsibilities of the embedded systems institute (esi). the project is partially
supported by the dutch ministry of economic aﬀairs under the bsik program.
⋆⋆research supported by the technology foundation stw, applied science division
of nwo and the technology program of the dutch ministry of economic aﬀairs.
⋆⋆⋆research supported by the nwo “visitor travel grant” initiative and by the eu
project fp7-ict acsi (257593).
s. khurshid and k. sen (eds.): rv 2011, lncs 7186, pp. 131–146, 2012.
c/circlecopyrtspringer-verlag berlin heidelberg 2012132 f.m. maggi et al.
(bpm) ﬁeld. the declarelanguage and system [11] show that it is possible to
model ltl constraints graphically such that end user can understand them,
while a workﬂow engine can enact the corresponding process. constraints may
be enforced by the declare system or are monitored while the process unfolds.
each graphical constraint in declare is represented as an ltl formula, and
the global process model is formalized as the conjunction of all such “local”
formulas. hence, there are two levels: (a) individual constraints well-understood
by the end-user and (b) global constraints resulting from the interaction of local
constraints. runtime veriﬁcation must provide intuitive diagnostics for every in-
dividual constraint, tracking its state as the monitored process instance evolves,
butatthesametimealsoprovidediagnosticsfortheoverallprocessmodel,giving
a meaningful feedback obtained from the combination of diﬀerent constraints.
in [6], we have investigated automata-based techniques for the runtime veriﬁ-
cationofltl-basedprocessmodels. inparticular,weproposed colored automata
to provideintuitive diagnosticsforsingularconstraintsandwaysto continuever-
iﬁcation even after a violation has taken place. intuitively, a colored automaton
is a ﬁnite state automaton built for the whole set of constraints composing a
process model, where each state c ontains speciﬁc information ( colors) indicating
the state of individual constraints.
here, we again use colored automata for runtime veriﬁcation. however, now
we focus on the interplay of constraints , i.e., we detect violations that cannot
be attributed to a single constraint in isolation, but result from combinations of
conﬂicting constraints. to do so, we extend a variant of the four-valued rv-ltl
semantics [2] with the notion of conﬂicting constraint set , in eﬀect adding a ﬁfth
truth valueindicating that while a constraintis notviolating the speciﬁcationon
its own, the interplay with other constraints makes it impossible to satisfy the
entire system. given the current trace of a system’s instance, a set of constraints
is conﬂicting if, for any possible continuation of the instance, at least one of such
constraints will be eventually viol ated. hence, our approach is able to detect
constraint violations as early as possible. we show how to compute minimal
conﬂicting sets, i.e., conﬂicting sets where the conﬂict disappears if one of the
constraints is removed. we present ou r framework in the context of process
models (as it was developed in that context), but it is applicable to any system
described, directly or indirectly, using a set of ﬁnite automata.
our approach has been implemented in the context of the declare system1
and prom2. we provide diagnostics that assist end-users in understanding the
nature of deviations and suggest recovery strategies focusing on the constraints
that are truly causing the problem.
the remainder of this paper is organi zed as follows. section 2 presents some
background material, and, in sect. 3, we introduce our runtime veriﬁcation
framework. section 4 explains the core algorithms used in our approach. we
have been applying our approach to various real-world case studies. in sect. 5,
1www.win.tue.nl/declare/
2www.processmining.orgruntime veriﬁcation of ltl-based declarative process models 133
under way 
using engine
under way 
sailingconstrained by 
her draughtmooredresponded
existence
precedencenot coexistence
fig. 1.example declare model
we report on the monitoring of declare constraints in the context of maritime
safety and security. section 6 concludes the paper.
2 background
in this section, we introduce some background material illustrating the basiccomponents of our framework. using a running example, we introduce declare,
present rv-fltl, an ltl semantics for ﬁnite traces, and an approach to trans-
late a declare model to a set of automata for runtime veriﬁcation.
2.1 declare and running example
declare is a declarative process modeling language and a workﬂow system based
on constraints [9]. the language is grounded in ltl, but has an intuitive graphi-
calrepresentation.diﬀerently fromimperative models that are “closed”,declare
models are “open”, i.e., they specify undesired behavior and allow everythingthat is not explicitly forbidden. the declare system is a full-ﬂedged workﬂow
management system that, being based on a declarative language, oﬀers more
ﬂexibility than traditional workﬂow systems.
figure 1 shows a simple declare model used within the maritime safety and
security ﬁeld. we use this example to explain the main concepts. it involves fourevents(depicted asrectangles,e.g., under way using engine )andthree constraints
(shown as arcsbetween the events, e.g., not coexistence ). in our example, a vessel
can be under way , either using an engineorsailingbut not both, as indicated by
thenot coexistence between the two events. a vessel can be constrained by her
draught, but only after being under way sailing (as a vessel with an engine cannot
be constrained by draught and a sailing vessel cannot be constrained before it isunder way). this is indicated by the precedence constraint. due to harbor policy,
only vessels with an engine can be moored(sailing ships are instead anchored).
this is indicated by the responded existence ,w h i c hs a y st h a ti f mooredoccurs,
under way using engine has to occur before or after. note that events represent
changes in the navigationalstate of a ship and then are considered to be atomic.
each individual declare constraint can be formalized as an ltl formula talk-
ing about the connected events. let us consider, for example, fig. 1, naming
the ltl formulas formalizing its diﬀerent constraints as follows: ϕ
nis the not
coexistence constraint, ϕpis the precedence constraint and ϕris the responded134 f.m. maggi et al.
existence constraint. using m,s,eand cto respectively denote moored,under
way sailing ,under way using engine and constrained by her draught ,w et h e nh a v e
ϕn=(♦e)⇒(¬♦s)ϕp=(♦c)⇒(¬c/unionsqs)ϕr=(♦m)⇒(♦e)
the semantics of the whole model is determined by the conjunction of these
formulas.
2.2 ltl semantics for constraint-based business processes
traditionally, ltl is used to reason over inﬁnite traces. when focusing on
runtime veriﬁcation, reasoning is carri ed out on partial, ongoing traces, which
describe a ﬁnite portion of the system’s execution. among the possible ltlsemantics on ﬁnite traces, we use a variant of runtime veriﬁcation linear tem-
poral logic (rv-ltl), a four-valued semantics proposed in [2]. indeed, the four
values used by rv-ltl capture in an intuitive way the possible states in which
declare constraints can be during the ex ecution. diﬀerently from the original
rv-ltl semantics, which focuses on trace suﬃxes of inﬁnite length, we limitourselves to possible ﬁnite continuations (rv-fltl). this choice is motivated
by the fact that we consider process insta nces that need to complete eventually.
this has considerable impact on the corresponding veriﬁcation technique: rea-soning on declare models is tackled with standard ﬁnite state automata (instead
o f ,s a y ,b ¨ uchi automata).
we denote with u|=ϕthe truth value of an ltl formula ϕin a ﬁnite trace u,
according to fltl [5], a standard ltl sem antics for dealing with ﬁnite traces.
deﬁnition 1 (rv-fltl). the semantics of [u|=ϕ]
rvis deﬁned as follows:
–[u|=ϕ]rv=/latticetop(ϕpermanently satisﬁed byu) if for each possible ﬁnite
continuation σofu:uσ|=ϕ;
–[u|=ϕ]rv=⊥(ϕpermanently violated byu) if for each possible ﬁnite
continuation σofu:uσ/negationslash|=ϕ;
–[u|=ϕ]rv=/latticetopp(ϕpossibly satisﬁed byu)i fu|=ϕbut there is a possible
ﬁnite continuation σofusuch that uσ/negationslash|=ϕ;
–[u|=ϕ]rv=⊥p(ϕpossibly violated byu)i fu/negationslash|=ϕbut there is a possible
ﬁnite continuation σofusuch that uσ|=ϕ.
we denote b4={/latticetop,⊥,/latticetopp,⊥p}and assume an order ⊥≺⊥p≺/latticetopp≺/latticetop.
wesayaformulaissatisﬁed(orviolated),ifitispermanentlyorpossiblesatisﬁed
(or violated).
as we have seen for declare, we do not l ook at speciﬁcations that consist
of a single formula, but rather at speciﬁcations including sets of formulas. we
generalize this aspect by deﬁning an ltl process model as a set of (ﬁnite trace)
ltl formulas, each capturing a speciﬁc business constraint.
deﬁnition 2 (ltl process model). an ltl process model is a ﬁnite set of
ltl constraints φ={ϕ1,...,ϕ m}.runtime veriﬁcation of ltl-based declarative process models 135
s0!e&!ss3
s
s2e!e
s1e
!ss-
s0!c&!ss2
s
s1c-
-s0!m&!e
s2e
s1m-
e!e
fig. 2.local automata for ϕn,ϕp,a n dϕrfrom the example in fig. 1
one way to verify at runtime an ltl process model φ={ϕ1,...,ϕ m}is to test
the truth value [ u|=φ]rv=[u|=/logicalandtext
i=1,...,mϕi]rv. this approach, however,
does not give any information about the truth value of each member of φin
isolation. a solution for that is to test the truth values [ u|=ϕi]rv,i=1,...,m
separately. this is, however, still not enough. let us consider, for example, the
declaremodel representedinf ig.1. after executingthe trace moored,under way
sailing, the conjunction ϕn∧ϕp∧ϕris permanently violated but each member
of the conjunction is not ( ϕnis possibly satisﬁed, ϕpis permanently satisﬁed,
andϕris possibly violated). therefore, to give insights about the state of each
constraint of an ltl process model and st ill detect non-local violations, we need
to check both global and local formulas.
2.3 translation of an ltl process model to automata
taking advantage of ﬁniteness of traces in the rv-fltl semantics, we construct
adeterministic ﬁnite state automaton showing the state of each constraint given
a preﬁx (we simply refer to such an automaton as “automaton”). an automatonaccepts a trace if andonly if it does not viol atethe constraint, a nd is constructed
by using the translation in [3].
for the constraints in the model in fig. 1, we obtain the automata depicted
in fig. 2. in all cases, state 0 is the in itial state and accepting states are in-
dicated using a double outline. a gray background indicates that the state ispermanent (for both satisﬁed and violated). as well as transitions labeled with
a single letter (repesenting an event), we also have transitions labeled with one
or more negated letters; they indicate that we can follow the transition for anyevent not mentioned. this allows us to use the same automaton regardless of
the exact input language. when we replay a trace on an automaton, we know
that if we are in an accepting state, the c onstraint is satisﬁed, and when we are
in a non-accepting state, it is violated. we can distin guish between the possi-
ble/permanent cases by the background; states with a gray background indicate
that the state is permanent.
we can use these local automata directly to monitor each constraint, but
to detect non-local violations we also need a global automaton .t h i sc a nb e
constructed as the automaton product of the local automata or equivalently as
the automaton of the conjunction of the individual constraints [12].
the global automaton for our example is shown in fig. 3. we use state
numbers from each of the automata from fig. 2 as state names, so state 202136 f.m. maggi et al.
000001
m
fc202e
320sc,s
e
c,s
e,m
fig. 3.global automaton for our example
corresponds to constraint not coexistence being in state 2, constraint precedence
being in state 0, and constraint responded existence being in state 2. these
names are for readability only and do not indicate we can infer the states of
local automata from the global states. to not clutter the diagram, we do not
show self loops. these can be derived: every state also has a self-loop transitionfor any transition not otherwise explicit ly listed. accepting states in the global
automaton correspond to states where all constraints are satisﬁed. in a non-
accepting state, at least one constr aint is possibly violated. state fcorresponds
to all situations where it is no longer possible to satisfy all constraints. we note
that state 321 is not present in fig. 3 even though none of the local automata
is in a permanently violated state and it is in principle reachable from state
001 via a s. the reason is that from this state it is never possible to reach a
state where all constraints together are satisﬁed. indeed, by executing the tracemoored,under way sailing ,under way with engine , for instance, we obtain the
trace 000 →
m001→sf→ef. hence, we correctly identify that after the ﬁrst
event, we possibly violate so me constraints, and after under way sailing there is
a non-local violation and we cannot satisfy all constraints together anymore.
the global automaton in fig. 3 allows us to detect the state of the entire
system, but not for individual constraints. in [6], we introduced a more elaborate
automaton, the colored automaton . this automaton is also the product of the
individual local automata, but now we inc lude information about the acceptance
state for each individual constraint. the colored automaton for our example is
shown in fig. 4. we retain the state numbering strategy, but add a second
line describing which constraints are sa tisﬁed. in this case, each state of the
coloredautomatonreallycontainsindica tionsabouttheacceptancestateforeach
individual constraint. if a constraint is satisﬁed in a state, we add the ﬁrst letter
of the name of the constraint in uppercase (e.g., rindicating that the constraint
responded existence is permanently satisﬁed in state 202). if a constraint is only
possibly satisﬁed, we put parentheses around the letter (e.g., (r)in state 320).if
a constraint is possibly violated in a state, we add the letter in lowercase (e.g., r
instate001),andifaconstraintispermanentlyviolated,weomititentirely(e.g.,
precedence is permanently violated in state 011). executing the trace moored,
under way sailing ,under way using engine on the colored automaton, we obtain
the trace 000 →m001→s321→e122. we can see in state 122 that we have
permanently violated the constraint not coexistence and permanently satisﬁed
the others (pr). note that the presence of an undesired situation, attesting anruntime veriﬁcation of ltl-based declarative process models 137
000
(n)(p)(r)
001
(n)(p)rm010
(n)(r)
c
202
(n)(p)re
320
(n)p(r)s011
(n)r
c
e
321
(n)prsm
212
(n)re310
(n)(r)
s
e311
(n)r
s112
r
122
prscse
m
e
em e
fig. 4.colored automaton for the example in fig. 1
unavoidable future violation, is already detected in state 321. however, in 321,
theproblemcannotbe attributedtoasingleconstraint.theproblemisnon-local
and is caused by the interplay between not coexistence and responded existence
(the ﬁrst forbidding and the other requiring the presence of event under way
using engine ). we capture this kind of situation by introducing the notion of
conﬂicting constraint sets.
3 conﬂicting constraint sets
the colored automaton des cribed in the previous section is able to detect both
local and non-local violations. however, it does not provide enough information
for user-friendly diagnostics. to do so, we have to identify the smallest parts of
the original ltl process model that cause a problem. we tackle this issue by
characterizing the relationship betw een the overall state of the system and the
one of individual constraints. in particular, we show that the global state can
be determined from the local states only when an explicit notion of conﬂicting
setis deﬁned and included in the semantics. in this respect, we ﬁrst look at the
truth value of subsets of the original speciﬁcation:
deﬁnition 3 (monitoring evaluation). given an ltl process model φand
a ﬁnite trace u,w ed e ﬁ n et h es e t s ps(φ,u)={ψ⊆φ|[u|=ψ]rv=s}
fors∈b4. the monitoring evaluation of trace uw.r.t.φis thenm(φ,u)=
(p⊥(φ,u),p⊥p(φ,u),p/latticetopp(φ,u),p/latticetop(φ,u)).
as our goalis to deduce the globalstate of a system fromthe states of individual
constraints, we need to analyze the structure of elements of m(φ,u). it can be
observed that m(φ,u) is a partition of the powerset of φ:
property 1 (partitioning). given an ltl process model φand a ﬁnite trace u,
m(φ,u) is a partition of the powerset of φ, i.e.,/uniontext
s∈b4ps(φ,u)=2φand for
s,s/prime∈b4withs/negationslash=s/prime:ps(φ,u)∩ps/prime(φ,u)=∅.138 f.m. maggi et al.
this is realized by observing that every subset of φhas exactly one assigned
truth value. second, for two subsets of φ,ψ/prime⊆ψ/prime/prime⊆φ, the larger one is not
easier to satisfy:
property 2 (inclusion). given an ltl process model φand a ﬁnite trace u,t h e n
forψ/prime⊆ψ/prime/prime⊆φand ans∈b4,i fψ/prime∈ps(φ,u)t h e nψ/prime/prime∈ps/prime(φ,u)f o rs o m e
s/prime∈b4withs/prime/precedesequals.
this stems from monotonicity of truth values of conjunctions. third, perma-
nently satisﬁed constraints do not change the truth value of sets of constraints:
property 3 (eﬀect of permanently satisﬁed constraints). g i v e na nl t lp r o c e s s
modelφand a ﬁnite trace u,a n da ψ∈ψsuch that [ u|=ψ]rv=/latticetop,i f
ψ∈ps(φ,u)f o rs o m e s∈b4,t h e nψ\{ψ}∈ps(φ,u).
this stems from the fact that for any exte nsion, the permanently satisﬁed one
reduces to true and can be removed using identity /latticetop∧ψ=ψfor any constraint
ψ. this allows us to characterize the structure of sets with a given truth value:
property 4 (structure of global states). given an ltl process model φand a
ﬁnite trace u, for a subset of constraints ψ⊆φ
1.ψ∈p/latticetop(φ,u) if and only if ∀ψ∈ψ,[u|=ψ]rv=/latticetop,
2.ψ∈p/latticetopp(φ,u) if and only if ∀ψ∈ψ,[u|=ψ]rv∈{ /latticetop,/latticetopp}and∃ψ∈ψsuch
that [u|=ψ]rv=/latticetopp,
3. ifψ∈p⊥p(φ,u), then∀ψ∈ψ,[u|=ψ]rv∈{ /latticetop,/latticetopp,⊥p}and∃ψ∈ψsuch
that [u|=ψ]rv=⊥p,a n d
4. ifψ∈p⊥(φ,u)a n d∀ψ∈ψ,[u|=ψ]rv/negationslash=⊥,t h e n∃ψ∈ψsuch that
[u|=ψ]rv=⊥p.
the ﬁrst item is seen by assuming that some constraint exists in φthat is not
permanently satisﬁed for u. equivalently, there exists a ﬁnite continuation of u
where this constraint is not satisﬁed and the conjunction of all constraints in
φis not satisﬁed for u. the second and third are seen by similar arguments.
the last one is seen by observing that if a set has only possibly or permanently
satisﬁed members, it is itself possibly or permanently satisﬁed.
given an ltl process model φ,at r a c e u, and a subset ψ⊆φ, we can easily
identify whether ψbelongs to p/latticetop(φ,u)o rp/latticetopp(φ,u) by simple inspection of the
stateofindividualconstraintsinthecoloredautomatonmentionedearlier.forthe
ﬁrsttwo items of prop.4, the states of the constraintsin a node completely char-acterize,inthiscase,theglobalstateoft hesystem.however,w ecannotdetermine
whetherasetbelongsto p
⊥p(φ,u)orp⊥(φ,u)onlybylookingatthestateofindi-
vidual constraints:prop. 4 only givesus implication in one direction in this case.
we introduce a ﬁfth truth value of constraints ⊥cthat allows us to deduce
the state of the entire system from the state of individual constraints. thisreﬂects that a constraint is not permanently violated, but is in conﬂict with
others so the entire system cannot be satisﬁed again. to better characterize the
problem when a permanent violation occurs, we minimize the sets originatingthe violation. therefore, we look at minimal subsets ψ∈p
⊥(φ,u). a ﬁrst groupruntime veriﬁcation of ltl-based declarative process models 139
of these minimal subsets are singletons {ψ}withψ∈p⊥(φ,u). a second group
consists of conﬂicting sets :
deﬁnition 4 (conﬂicting set). given an ltl process model φand a ﬁnite
traceu,ψ⊆φis aconﬂicting set ofφw.r.t.uif:
1.ψ∈p⊥(φ,u),
2.∀ψ∈ψ,[u|=ψ]rv/negationslash=⊥,a n d
3.∀ψ∈ψ,[u|=ψ\{ψ}]rv/negationslash=⊥.
we extend the semantics of rv-f ltl to capture conﬂicting sets:
deﬁnition 5 (rvc-fltl). the semantics of [u,φ|=ϕ]rv cis deﬁned as
[u,φ|=ϕ]rv c=/braceleftbigg
⊥cif there is a conﬂicting set ψ⊆φs.t.ϕ∈ψ
[u|=ϕ]rvotherwise.
therefore, we can introduce a variant of prop. 4 allowing us to determine the
global state solely using local values:
theorem 1 (structure of global states). given an ltl process model φ
and a ﬁnite trace u,t h e n
1.[u|=φ]rv=/latticetop,i fa n do n l yi f ∀ψ∈φ,[u,φ|=ψ]rv c=/latticetop,
2.[u|=φ]rv=/latticetopp,i fa n do n l yi f ∀ψ∈φ,[u,φ|=ψ]rv c∈{ /latticetop,/latticetopp}and
∃ψ∈φsuch that [u,φ|=ψ]rv c=/latticetopp,
3.[u|=φ]rv=⊥p,i fa n do n l yi f ∀ψ∈φ,[u,φ|=ψ]rv c∈{ /latticetop,/latticetopp,⊥p}and
∃ψ∈φsuch that [u,φ|=ψ]rv c=⊥p,
4.[u|=φ]rv=⊥if and only if ∃ψ∈φsuch that [u,φ|=ψ]rv c∈{ ⊥c,⊥}.
in [6], we explain how to modify the original ltl process model on the ﬂy in an
eﬃcient way when a violation occurs. the refore, when a non-local violation is
detected, it can be useful to identify minimal sets of constraints to be removed
in the original ltl process model to recover from the violation. we capture this
as arecovery set :
deﬁnition 6 (recovery set). given an ltl process model φand a ﬁnite
traceusuch that [u|=φ]rv=⊥,t h e nψ⊆φis a recovery set of φ/primew.r.t.φ
anduif
1.[u|=φ\ψ]rv/negationslash=⊥
2.∀ψ∈ψ,[u|=φ\(ψ\{ψ})]rv=⊥.
intuitively, we must remove exactly one constraint from each conﬂicting set in
φ, but if two (or more) conﬂicting sets overlap, we can remove one from the
intersection to make a smaller recovery set.
let us consider the declare model represented in fig. 1. we name the ltl
constraintsof this model as speciﬁed in s ect. 2.1. figure 5 show s a graphical rep-
resentation of the constraints’ evolution: events are displayed on the horizontal140 f.m. maggi et al.
fig. 5.one of the views provided by our monitoring system. colors show the state
constraints while the process instance evolves; red(viol) refers to ⊥,yellow(poss. viol )
to⊥p,green(poss. sat)t o/latticetopp,blue(sat) refers to /latticetop,a n d orange(conﬂict)t o⊥c.
axis. the vertical axis shows the three constraints. initially, all three constraints
are possibly satisﬁed. let u0=εdenote the initial (empty) trace:
[u0,φ|=ϕn]rv c=/latticetopp[u0,φ|=ϕp]rv c=/latticetopp[u0,φ|=ϕr]rvc=/latticetopp
event mooredis executed next ( u1=moored), we obtain:
[u1,φ|=ϕn]rv c=/latticetopp[u1,φ|=ϕp]rv c=/latticetopp[u1,φ|=ϕr]rvc=⊥p
note that [ u1|=ϕr]rv=⊥pbecause the responded existence constraintbecomes
possibly violated after the occurrence of moored. the constraint is waiting for
the occurrence of another event (execution of under way using engine ) to become
satisﬁed again. then, under way sailing is executed ( u2=moored,under way
sailing), leading to a situation in which constraint precedence is permanently
satisﬁed, but not coexistence and responded existence are in conﬂict.
[u2,φ|=ϕn]rv c=⊥c[u2,φ|=ϕp]rv c=/latticetop[u2,φ|=ϕr]rv c=⊥c
note that we have exactly one conﬂicting set, {ϕn,ϕr}. indeed, if we look at
the automaton in fig. 4, from 321 it is not possible to reach a state where boththese constraints are satisﬁed. moreov er, no supersets can be a conﬂicting set
(due to minimality). {ϕ
n,ϕp}is not a conﬂicting set as they are both satisﬁed
in 122, and {ϕn,ϕp}is not a conﬂicting set as it is temporarily satisﬁed. the
next event is under way using engine (u3=moored,under way sailing, under
way using engine ), resulting in:
[u3,φ|=ϕn]rv c=⊥[u3,φ|=ϕp]rv c=/latticetop[u3,φ|=ϕr]rv c=/latticetop
not coexistence becomes permanently violated because under way using engine
and under way sailing cannot coexist in the same trace. note that this violation
has been detected as early as possible b y our monitoring system; already whenruntime veriﬁcation of ltl-based declarative process models 141
under way sailing occurred,the conﬂicting set of constraintsshowedthat it would
be impossible to satisfy all constraints at the same time. however, it is stillpossible to see that the responded existence constraint beco mes permanently
satisﬁed by the under way using engine event.
4 deciding rvc-fltl using automata
in this section, we give algorithms for detecting the state of sets of constraints.
we start by giving algorithms for the extra information we have added to the
automata in sect. 2, and then focus on how to compute the information aboutconﬂicting sets contained in the colored automaton.
4.1 local automata
we get most of the information exhibited in the local automata in fig. 2 from
the standard translation in [3]. the only thing missing is the background color
indicating whether a constraint is permanently/possibly satisﬁed or violated.
we get the background information by marking any state from which an
accepting state is always/never reachab le. we can do this eﬃciently using the
strongly connected compon ents (sccs) of the automaton (this can be computed
in linear time using tarjan’s algorithm [10]). we look at components with only
outgoing arcs to components already processed (initially none), and we color a
component gray only if i) it contains nod es that are all accepting/non-accepting
and ii) all (if any) reachable components contain the same type states and are
colored. this is also linear in the input automaton.
if the automaton we get is deterministic and minimal, we know that at most
one accepting state will have gray back ground and at most o ne non-accepting
state will have gray background. these can be identiﬁed as the (unique) accept-ing and non-accepting states with a self- loop allowing all events. all automata
in fig. 2 satisfy this, and we see they all have at most one gray state of each
kind. using these automata, we can decide the state of a constraint ( /latticetop,⊥,/latticetop
p,
or⊥p) with respect to each trace, but we ca nnot detect non-local violations.
4.2 global automaton and its combination with local automata
we cancompute the globalautomatondirectly usingthe sameapproachadopted
for local automata (following [12] for better performance). this is the approach
used for the automaton in fig. 3. using this automaton, we compute the state ofthe global system, but not for individual constraints. in this way, we can detect
non-local violations, but we cannot compute conﬂicting sets nor decide the state
of individual constraints.
to infer the state of the entire system as well as of individual constraints, we
can use at the same time the local and global automata. however, this forces usto replay the trace on many automata: the global one plus nlocal ones, where
nis the number of constraints. moreove r, we cannot here detect exactly which
constraints are conﬂicting, only that there are some, making this approach lessuseful for debugging.142 f.m. maggi et al.
4.3 colored automaton
to identify conﬂicting sets, we construc t a colored automaton (like the one in
fig. 4) using the method described in [6]. we then post-process it to distinguish
permanently/possibly satisﬁed or violated states (by computing sccs, exactly
like we did for the local automata).
toadditionallycomputeconﬂictingsets,wenoticethattheyaresharedamong
states in an scc (if a set of constraints cannot be satisﬁed in a state, it also
cannot be satisﬁed in states reachable from it, and all states in an scc are
reachable from each other by deﬁnition). furthermore, conﬂicting sets have tobe built using possibly satisﬁed and possibly violated constraints of an scc. we
can ignore permanently sa tisﬁed constraints becaus e of prop. 3 and item 3 of
def. 4. we can ignore permanently violated constraints due to item 2 of def. 4.
in an scc, all states share permanently violated and satisﬁed constraints as
they can all reach each other, so we can ob tain all interesti ng constraints by
looking at one of the states in isolation.
due to item 1 for def. 4 and prop. 2, we only have to consider states that
are permanently violated for computation of conﬂicting sets (gray states withsingle outline in fig. 4). we notice that the conﬂicting sets of an scc have to be
super-sets of conﬂicting sets of all su ccessor sccs or contain a constraint that
in a successor scc is permanently violated. this is seen by a weaker version
of the argument for members of sccs sharing conﬂicting sets, as reachability
is only true in one direction. the inclusion may be strict due to minimality ofconﬂicting sets (item 3 of def. 4).
we thus start in terminal sccs (sccs with no successors) and compute the
conﬂicting sets. this is done by considering all subsets composed of possiblyviolated/satisﬁed constraints with more than one member and checking whether
they are satisﬁable in the component. this can be done by examining all states
of the scc and checking if there is one where all members of the considered
subset are (possibly) satisﬁed. we can perform this bottom-up or top-down.
the bottom-up approach starts with set s with two elements and adds elements
until a set become unsatisﬁable, exploiting minimality (item 3 of def. 4) in that
no superset of a conﬂicting set is a conﬂict ing set. alternatively, we can compute
the sets top-down, starting with all possible violated/satisﬁed constraints andremoving constraints until the set becomes satisﬁed, exploiting that subsets of
a set of satisﬁed constraints do not need to be considered due to monotonicity.
which one is better depends on the size of the conﬂicting sets.
for each globally unsatisﬁable scc we recursively compute for all successors
and then build conﬂicting set bottom-up, starting with all possible (minimal)
unions of conﬂicting sets or singleton permanently violated properties of suc-
cessors. for the example in fig. 4, state 112 has, for instance, no conﬂicting
sets, but two permanently violated constraints ( ϕ
nandϕp). computing con-
ﬂicting sets for 311 only needs to consider sets containing (at least) one of
these, and as ϕpis permanently violated, we can ignore it. the only possi-
bility,{ϕn,ϕr}, is indeed a conﬂicting set. for state 310 we need to consider
unions of the conﬂicting sets and permanen tly violated constraints of successorsruntime veriﬁcation of ltl-based declarative process models 143
of 311 and 112, i.e., {c1∪c2|c1∈{ {ϕn},{ϕp}},c 2∈{ {ϕn,ϕr},{ϕp}}}=
{{ϕn,ϕr},{ϕn,ϕp},{ϕp,ϕn,ϕr},{ϕp}}which can be reduced by removing sets
containing ϕp(which is permanently violated in 310) to {{ϕn,ϕr}}.w ef u r t h e r -
more remove any supersets of contained s ets (none in this case), and use the sets
as basis for computing conﬂicting sets. as {ϕn,ϕr}is satisﬁable in 310, such
constraints do not constitute a conﬂict ing set, hence 310 has no conﬂicting sets.
each scc can have exponentially many conﬂicting sets in the number of
constraints (assume we have nconstraints and construct a scc with all states
possibly satisfying exactlyn
2constraints and possibly violating the remaining;
as all sets have the same size, none can be subsets of the others, and we have
n!
n
2!∈o(2n
2) such sets). in our initial experim ents, we have never seen examples
with more than a few possibly violated/satisﬁed constraints, so in practice this
is acceptable. future work includes valid ating that this is also true for large
real-life examples. if the pre-computation proves to be too expensive, we can
also perform the algorithm at run-time, only computing conﬂicting sets when
we reach a globally permanently violated state. by caching and sharing the
results between instances (as well as inter mediate results imposed by recursion),
we should be able to provide accep table runtime performance.
in our running example, executing the trace moored,under way sailing ,w e
obtain the trace 000 →m001→s321. using our algorithm to compute the
conﬂicting sets, we see that in terminal scc 122 in fig. 4, we have no conﬂicting
sets, but a single permanently violated constraint ϕn. in state 321, we have
exactly one conﬂicting set, {ϕn,ϕr}.
5 case study
we now present a real case study focused on monitoring vessel behavior in the
context of maritime safety and security . it has been provided by thales, a global
electronics company deliver ing mission-critical information systems and services
for aerospace, defense, and security. for the sake of brevity, the results obtained
in the case study are only partially illustrated in this section. here, we only want
to give an example of a possible application of our framework.
in our experiments, we use diﬀerent logs describing the behavior of diﬀerent
types of vessels. these logs have been co llected by a maritime automatic identi-
ﬁcation system (ais) [4], which acts as a transponder that logs and sends events
to an ais receiver. each log contains a se t of process instances corresponding
to the behavior of vessels of the same type (e.g., passenger ship ,fishing boat ,
dredgerortanker). an eventin a processinstance is a change in the navigational
state of the vessel (e.g., moored,under way using engine ,at anchor ,under way
sailing,o r restricted maneuverability ). the logs are one-week excerpts of larger
logs tracing the behavior of each vessel in the long term.
starting from these logs, exploiting process mining techniques [1], we discover
declare models representing the beha vior of each vessel type. a fragment of
the discovered model for dredger is shown in fig. 6. the ultimate goal is to
consequentlyusethese modelsto monitornewvesselbehaviors,usingthe colored
automata-based approach outlined in this contribution.144 f.m. maggi et al.
under way
using enginerestricted 
maneuverability
mooredat anchor
under way 
sailing
fig. 6.discovered model for vessel type dredger; dashed constraints represent a con-
ﬂicting set arising after the occurrence of at anchor
more speciﬁcally, to construct the m odel in fig. 6, we apply the declare
discovery technique described in [7]. we ﬁx the not coexistence and response
constraints as possible candidate constraints (the response indicating that if the
source event occurs, then the target ev ent must eventually occur). the miner
identiﬁes all the not coexistence and response constraints that are satisﬁed in all
the tracesofthe log.however,when thelog is anexcerptofa largerlog,it is pos-sible to make the discovery process more ﬂ exible by accepting a constraint also
if it is possibly violated in some traces: b eing each execution trace incomplete,
such a constraint could be satisﬁed in the continuation of the trace.
even though the miner only identiﬁes constraints that never give rise to a
permanent violation by themselves, it i s possible that conﬂicting sets of con-
straints exist in the discovered model. the conﬂicting sets are caused by the
fact that, to extract the reference models from the logs, the miner checks each
constraint separately while accepting possibly violated constraints. this makes
the approach presented in this paper relevant in the prompt identiﬁcation of
an actual conﬂict during the monitoring process. for example, fig. 6 contains
a conﬂict when at anchor is executed; the conﬂicting c onstraints are depicted
with dashed lines. in this speciﬁc case, e ach constraint of the conﬂicting set is a
recovery set: the conﬂict is solved by removing any of them from the model.
6c o n c l u s i o n
we have introduced the runtime veriﬁcation of ﬂexible, constraint-based processmodels formalized in terms of ltl on ﬁnite traces, focusing on violations arising
from interference of multiple constraints. a conﬂicting set provides a minimal
set of constraints with no continuation where all constraints can be satisﬁed.
to do so, we have exploited in a novel way established results achieved in the
ﬁeldoftemporallogicsandruntimeveriﬁcation.inparticular,wehaveconsidereda ﬁnite-trace variation of the rv-ltl semantics [2], following the ﬁnite state
automata approach of [3] and the optimized algorithms proposed in [12] for
the generation of automata. such automata are employed to provide intuitivediagnostics about the business constraints during execution of a model. more
speciﬁcally, we have shown how local and/or global information can be provided
by combining the use of local automata and of a global automaton, or using a
single colored automaton to provide full information.runtime veriﬁcation of ltl-based declarative process models 145
all the techniques presented in this paper have been fully implemented in
declare and prom. in particular, we have developed an operational support(os)providerforprom[1,13],exploiti ngtherecentlyintroducedosservice.the
os service is the backbone for implementing process mining techniques that are
not used in a post-mortem manner, i.e., on already completed process instances,but are instead meant to provide runtime support to running executions. our
provider takes in input a declare model, and exploits the colored automata-
based techniques presented here to track running instances and give intuitive
diagnostics to the end users, graphically showing the status of each constraint,
as well as reporting local and non-local violations (see fig. 5 for an example).in the latter case, recovery sets are computed, showing the minimal possible
modiﬁcations that can be applied to the model to alleviate the detected conﬂict.
monitoring business constraints can be also tackled by using the event calcu-
lus (ec) [8]. the two approaches are orthogonal to each other: the ec can only
provide diagnostics about local violations, but is easier to augment with other
perspectivessuchasmetrictime constraintsanddatarelatedaspects.we plantoinvestigate the incorporation of metric time aspects also in an automaton-based
approach, relying on timed automata for veriﬁcation.
references
1. van deraalst, w.m.p.: process mining: discovery,conformance and enhancement
of business processes. springer, heidelberg (2011)
2. bauer, a., leucker, m., schallhart, c.: comparing ltl semantics for runtime
veriﬁcation. in: logic and computation, pp. 651–674 (2010)
3. giannakopoulou, d., havelund, k.: automata-based veriﬁcation of temporal
properties on running programs. in: p roc. ase, pp.412–416 (2001)
4. international telecommunications union. technical characteristics for a universal
shipborne automatic identiﬁcation system using time division multiple access inthe vhf maritime mobile band, recommendation itu-r m.1371-1 (2001)
5. lichtenstein, o., pnueli, a., zuck, l.d.: the glory of the past. in: proc. of logic
of programs, pp. 196–218 (1985)
6. maggi, f.m., montali, m., westergaard, m., van der aalst, w.m.p.: monitoring
business constraints with linear temporal logic: an approach based on colored
automata. in: rinderle-ma, s., toumani, f., wolf, k. (eds.) bpm 2011. lncs,vol. 6896, pp. 132–147. springer, heidelberg (2011)
7. maggi, f.m., mooij, a.j., vander aalst, w.m.p.: user-guided discovery of declar-
ative process models. in: proc. of cidm, pp. 192–199 (2011)
8. montali, m., maggi, f.m., chesani, f., mello, p., van der aalst, w.m.p.: moni-
toring business constraints with the event calculus. technical report deis-lia-
002-11, university of bologna, italy, lia series no. 97 (2011)
9. pesic, m., schonenberg, h., van der aalst, w.m.p.: declare: full support for
loosely-structured processes. in: proc. of edoc, pp. 287–300 (2007)
10. tarjan, r.: depth-first search and linear graph algorithms. siam journal on
computing, 146–160 (1972)146 f.m. maggi et al.
11. van der aalst, w.m.p., pesic, m., schonenberg, h.: declarative workﬂows: balanc-
ing between ﬂexibility and support. computer science - r&d (2009)
12. westergaard, m.: better algorithms for analyzing andenacting declarative work-
ﬂow languages using ltl. in: rinderle-ma, s., toumani, f., wolf, k. (eds.) bpm
2011. lncs, vol. 6896, pp. 83–98. springer, heidelberg (2011)
13. westergaard, m., maggi, f.m.: modelling and veriﬁcation of a protocol for oper-
ational support using co loured petri nets. in: proc. of atpn 2011 (2011)