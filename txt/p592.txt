process discovery: capturing the invisible
wil m. p. van der aalst
department of mathematics and computer science,
technische universiteit eindhoven, the netherlands.
w.m.p.v.d.aalst@tue.nl
abstract. processes are everywhere. organizations have business pro-
cesses to manufacture products, provide services, purchase goods, handle
applications, etc. also in our daily lives we are involved in a variety of
processes, for example when we use our car or when we book a trip via
the internet. although such operational processes are omnipresent, they
are at the same time intangible. unlike a product or a piece of data, pro-
cesses are less concrete because of their dynamic nature. however, more
and more information about these processes is captured in the form of
event logs. contemporary systems ranging from copiers and medical de-
vices to enterprise information systems and cloud infrastructures record
events. these events can be used to make processes visible. using pro-
cess mining techniques it is possible to discover processes. this provides
the insights necessary to manage, control, and improve processes. pro-
cess mining has been successfully applied in a variety of domains ranging
from healthcare and e-business to high-tech systems and auditing. de-
spite these successes, there are still many challenges as process discovery
shows that the real processes are more \spaghetti-like" than people like
to think. it is still very dicult to capture the complex reality in a suit-
able model. given the nature of these challenges, techniques originating
from computational intelligence may assist in the discovery of complex
processes.
1 introduction
process mining is a relative young research discipline that sits between machine
learning and data mining on the one hand and process modeling and analysis on
the other hand [3]. process mining includes the automated discovery of processes
from event logs. based on observed events (e.g., activities being executed or
messages being exchanged) a process model is constructed. since most processes
are highly concurrent and activities may have complex dependencies, simple
techniques such as sequence mining [8] are unable to capture the underlying
process adequately.
process mining aims at the analysis of operational processes that are repeat-
able. if there are only few instances following the same process, it is typically
impossible to reconstruct a reasonable process model. examples of operational
processes are the treatment of patients having a particular type of cancer, han-
dling customer orders by a furniture factory, booking business trips within aconsultancy rm, opening new bank accounts, handling insurance claims, re-
pairing high-end copiers, etc. these processes are instantiated for specic cases.
examples of cases (i.e., process instances) are patient treatments, customer or-
ders, business trips, insurance claims, etc. although both organizations and in-
dividuals are constantly involved in a multitude of processes, little attention
is given to these processes. of course people talk about processes and parts of
these processes are supported by it systems. some organizations even document
their processes using a variety of notations. however, a detailed analysis of what
actually happens is typically missing.
unlike products, processes are less tangible. processes may only exist in the
minds of people and it is dicult to \materialize processes". one could argue
that \information" is similar to \processes" in this respect. in fact, some people
like to distinguish between data, information, and knowledge. nevertheless, in
many cases it is possible to \print" information elements and view these as prod-
ucts. for example, it is possible to print all information in an electronic patient
record. for processes this is more dicult. processes may emerge from human
behavior or may be partly controlled by procedures and/or information systems.
many processes are documented in the form of normative or descriptive models.
however, these models are human-made artifacts that do not necessarily say
much about the actual process. as a result, there may be a disconnect between
model and reality. moreover, the people involved in a process are typically un-
able to understand the corresponding process model and cannot easily see what
is actually going on (especially if the products are services or data).
fig. 1. one of the few of today's processes that can easily be observedto illustrate this consider the production line shown in figure 1. this is
one of the few processes that can easily be observed. the products are physical
entities rather than information or services. moreover, the routing of work is
partly dened by the physical layout of the production line. most of today's
processes do not have such a physical representation. think for example of a
hospital, a municipality, or an insurance company where processes are much
more dynamic and driven by people rather than machines. in such less tangible
processes there is a strong desire to visualize the actual ow of work.
fortunately, more and more information about processes is being recorded
in the form of event logs. today's information systems log enormous amounts
of events. classical workow management systems (e.g. filenet), erp systems
(e.g. sap), case handling systems (e.g. flower), pdm systems (e.g. wind-
chill), crm systems (e.g. microsoft dynamics crm), middleware (e.g., ibm's
websphere), hospital information systems (e.g., chipsoft), etc. provide very de-
tailed information about the activities that have been executed [3]. moreover,
more and more devices are connected to the internet today, thus allowing for
unprecedented streams of data. this \data explosion" is an important enabler
for process mining.
models
analyzesrecords 
events, e.g., 
messages, 
transactions, 
etc.specifies
configures
implements
analyzessupports/
controls
people machines
organizationscomponentsbusiness 
processes
fig. 2. three types of process mining: (1) discovery, (2) conformance, and (3) exten-
sion
the idea of process mining is to discover, monitor and improve real pro-
cesses (i.e., not assumed processes) by extracting knowledge from event logs. we
consider three basic types of process mining (figure 2):
{discovery : there is no a-priori model, i.e., based on an event log some model
is constructed. for example, using the -algorithm [6] a process model can
be discovered based on low-level events.{conformance : there is an a-priori model. this model is used to check if
reality, as recorded in the log, conforms to the model and vice versa. for
example, there may be a process model indicating that purchase orders of
more than one million euro require two checks. another example is the
checking of the four-eyes principle. conformance checking may be used to
detect deviations, to locate and explain these deviations, and to measure
the severity of these deviations. an example, is the conformance checking
algorithm described in [28].
{extension : there is an a-priori model. this model is extended with a new
aspect or perspective, i.e., the goal is not to check conformance but to enrich
the model. an example is the extension of a process model with performance
data, i.e., some a-priori process model is used on which bottlenecks are pro-
jected. another example is the decision mining algorithm described in [27]
that extends a given process model with conditions for each decision.
orthogonal to the three types of mining, there are at least three perspectives.
the control-ow perspective focuses on the control-ow, i.e., the ordering of
activities. the goal of mining this perspective is to nd a good characterization
of all possible paths, e.g., expressed in terms of a petri net or some other notation
(e.g., epcs, bpmn, uml ads, etc.). the organizational perspective focuses
on information about resources hidden in the log, i.e., which performers are
involved and how are they related. the goal is to either structure the organization
by classifying people in terms of roles and organizational units or to show the
social network. the case perspective focuses on properties of cases. cases can
be characterized by their path in the process or by the originators working on a
case. however, cases can also be characterized by the values of the corresponding
data elements. for example, if a case represents a replenishment order, it may
be interesting to know the supplier or the number of products ordered.
this article will focus on process discovery, i.e., distilling a model from an
event log describing the control-ow. first, we present the basic problem. then
we present a concrete algorithm. the algorithm is able to capture concurrency,
but has problems dealing with less structured models. subsequently, we list the
challenges in process discovery. finally, we describe some typical applications and
an outlook on process mining as a grand challenge for computational intelligence.
2 process discovery
in this section, we describe the goal of process discovery. in order to do this,
we present a particular format for logging events and a particular process mod-
eling language (petri nets). based on this we sketch various process discovery
approaches.
2.1 event logs
the goal of process mining is to extract knowledge about a particular (oper-
ational) process from event logs, i.e., process mining describes a family of a-
posteriori analysis techniques exploiting the information recorded in audit trails,transaction logs, databases, etc. typically, these approaches assume that it is
possible to sequentially record events such that each event refers to an activ-
ity(i.e., a well-dened step in the process) and is related to a particular case
(i.e., a process instance). furthermore, some mining techniques use additional
information such as the performer or originator of the event (i.e., the person /
resource executing or initiating the activity), the timestamp of the event, or data
elements recorded with the event (e.g., the size of an order).
to clarify the notion of an event log consider table 1 which shows a fragment
of some event log. only two traces are shown, both containing four events. each
event has a unique id and several properties. for example event 35654423 belongs
to casex123 and is an instance of activity athat occurred on december 30th
at 11.02, was executed by john, and costed 300 euros. the second trace (case
x128) starts with event 35655526 and also refers to an instance of activity a. the
table 1. a fragment of some event log.
case id event id properties
timestamp activity resource cost : : :
x123 35654423 30-12-2008:11.02 a john 300 : : :
x123 35654424 30-12-2008:11.06 b john 400 : : :
x123 35654425 30-12-2008:11.12 c john 100 : : :
x123 35654426 30-12-2008:11.18 d john 400 : : :
x128 35655526 30-12-2008:16.10 a ann 300 : : :
x128 35655527 30-12-2008:16.14 c john 450 : : :
x128 35655528 30-12-2008:16.26 b pete 350 : : :
x128 35655529 30-12-2008:16.36 d ann 300 : : :
: : : : : : : : : : : : : : : : : : : : :
information depicted in table 1 is the typical event data that can be extracted
from today's systems.
systems store events in very dierent ways. process-aware information sys-
tems (e.g., workow management systems) provide dedicated audit trails. in
other systems, this information is typically scattered over several tables. for
example, in a hospital events related to a particular patient may be stored in
dierent tables and even dierent systems. for many applications of process min-
ing, one needs to extract event data from dierent sources, merge these data,
and convert the result into a suitable format. we advocate the use of the so-
called mxml (mining xml) format that can be read directly by prom ([2]).
tools such as our prom import framework allow developers to quickly imple-
ment plug-ins that can be used to extract information from a variety of systems
and convert this into mxml. mxml is able to store the information shown in
table 1. most of this information is optional, i.e., if it is there, it can be used
for process mining, but it is not necessary for control-ow discovery.since we focus on control-ow discovery, we only consider the activity column
in table 1. this means that an event is linked to a case (process instance) and
an activity, and no further attributes are needed. events are ordered (per case),
but do not need to have explicit timestamps. this allows us to use the following
very simple denition of an event log.
denition 1 (event, trace, event log). letabe a set of activities. 2a
is atrace , i.e., a sequence of events. l2i b(a)is an event log , i.e., a multi-set
of traces.
the rst four events in table 1 form a trace ha;b;c;di. this trace represents
the path followed by case x123. the second case ( x128) can be represented by
the traceha;c;b;di. note that there may be multiple cases that have the same
trace. therefore, an event log is dened as a multi-set of traces.
amulti-set (also referred to as bag) is like a set where each element may
occur multiple times. for example, [ horse;cow5;duck2] is the multi-set with eight
elements: one horse, ve cows and two ducks. i b( x) is the set of multi-sets (bags)
overx. we assume the usual operators on multi-sets, e.g., x[yis the union of
x and y,xnyis the dierence between xandy,x2xtests ifxappears inx,
andxyevaluates to true if xis contained in y. for example, [ horse;cow2][
[horse2;duck2] = [ horse3;cow2;duck2], [horse3;cow4]n[cow2] = [ horse3;cow2],
[horse;cow2][horse2;cow3], and [ horse3;cow1]6[horse2;cow2]. note that
sets can be considered as bags having only one instance of every element. hence,
we can mix sets and bags, e.g., fhorse;cowg[[horse2;cow3] = [horse3;cow4].
in the remainder, we will use the following example log: l1= [ha;b;c;di5;
ha;c;b;di8;ha;e;di9].l1contains information about 22 cases; ve cases following
traceha;b;c;di, eight cases following trace ha;c;b;di, and nine cases following
traceha;e;di. note that such a simple representation can be extracted from
sources such as table 1, mxml, or any other format that links events to cases
and activities.
2.2 petri nets
the goal of process discovery is to distil a process model from some event log.
here we use petri nets [26] to represent such models. in fact, we extract a
subclass of petri nets known as workow nets (wf-nets) [1].
denition 2. anpetri net is a tuple (p;t;f )where:
1.pis a nite set of places ,
2.tis a nite set of transitions such thatp\t=;, and
3.f(pt)[(tp)is a set of directed arcs, called the ow relation .
an example petri net is shown in figure 3. this petri net has six places
represented by circles and four transitions represented by squares. places may
contain tokens. for example, in figure 3 both p1 andp6 contain one token,
p3 contains two tokens, and the other places are empty. the state, also calledmarking , is the distribution of tokens over places. a marked petri net is a pair
(n;m ), wheren= (p;t;f ) is a petri net and where m2i b(p) is a bag over
pdenoting the marking of the net. the initial marking of the petri net shown
in figure 3 is [ p1;p32;p6]. the set of all marked petri nets is denoted n.
fig. 3. a petri net with six places ( p1,p2,p3,p4,p5, and p6) and four transitions ( t1,
t2,t3, and t4)
letn= (p;t;f ) be a petri net. elements of p[tare called nodes . a node
xis an input node of another node yi there is a directed arc from xtoy(i.e.,
(x;y)2f). nodexis an output node ofyi (y;x)2f. for anyx2p[t,
x=fyj(y;x)2fgandx=fyj(x;y)2fg. in figure 3,t3 =fp3;p6gand
t3=fp5g.
the dynamic behavior of such a marked petri net is dened by the so-called
ring rule . a transition is enabled if each of its input places contains a token. an
enabled transition can rethereby consuming one token from each input place
and producing one token for each output place.
denition 3 (firing rule). let(n;m )be a marked petri net with n=
(p;t;f ). transition t2tisenabled , denoted (n;m )[ti, itm. the ring
rule [intn is the smallest relation satisfying for any (n;m )2n
and anyt2t,(n;m )[ti)(n;m ) [ti(n;(mnt)[t).
in the marking shown in figure 3, both t1 andt3 are enabled. the other two
transitions are not enabled because at least one of the input places is empty.
ift1 res, one token is consumed (from p1) and two tokens are produced (one
forp2 and one for p3). formally, ( n;[p1;p32;p6]) [t1i(n;[p2;p33;p6]). so the
resulting marking is [ p2;p33;p6]. ift3 res in the initial state, two tokens are
consumed (one from p3 and one from p6) and one token is produced (for p5).
formally, (n;[p1;p32;p6]) [t3i(n;[p1;p3;p5]).let (n;m 0) withn= (p;t;f ) be a marked p/t net. a sequence 2tis
called a ring sequence of (n;m 0) i, for some natural number n2i n, there exist
markingsm1;:::;mnand transitions t1;:::;tn2tsuch that=ht1:::tniand,
for alliwith 0i<n , (n;mi)[ti+1iand (n;mi) [ti+1i(n;mi+1).
let (n;m 0) be the marked petri net shown in figure 3, i.e., m0= [p1;p32;p6].
the empty sequence =hiis enabled in ( n;m 0). the sequence =ht1;t3i
is also enabled and results in marking [ p2;p32;p5]. another possible ring se-
quence is=ht3;t4;t3;t1;t4;t3;t2;t1i. a marking misreachable from the
initial marking m0i there exists a sequence of enabled transitions whose r-
ing leads from m0tom. the set of reachable markings of ( n;m 0) is denoted
[n;m 0i.
fig. 4. the reachability graph of the marked petri net shown in figure 3
for the marked petri net shown in figure 3 there are 12 reachable states.
these states can be computed using the so-called reachability graph shown in
figure 4. all nodes correspond to reachable markings and each arc corresponds
to the ring of a particular transition. any path in the reachability graph corre-
sponds to a possible ring sequence. for example, using figure 4 is is easy to see
thatht3;t4;t3;t1;t4;t3;t2;t1iis indeed possible and results in [ p2;p3;p4;p5]. amarked net may be unbounded, i.e., have an innite number or reachable states.
in this case, the reachability graph is innitely large, but one can still construct
the so-called coverability graph [26].
2.3 workow nets
for process discovery, we look at processes that are instantiated multiple times,
i.e., the same process is executed for multiple cases. for example, the process
of handling insurance claims may be executed for thousands or even millions
of claims. such processes have a clear starting point and a clear ending point.
therefore, the following subclass of petri nets (wf-nets) is most relevant for
process discovery.
denition 4 (workow nets). letn= (p;t;f )be a petri net and ta fresh
identier not in p[t.nis aworkow net (wf-net) i:
1.object creation :pcontains an input place i(also called source place) such
thati=;,
2.object completion :pcontains an output place o(also called sink place) such
thato=;,
3.connectedness :n= (p;t[ftg;f[f(o;t);(t;i)g)is strongly connected, i.e.,
there is a directed path between any pair of nodes in n.
clearly, figure 3 is not a wf-net because a source and sink place are missing.
figure 5 shows an example of a wf-net: start =;,end=;, and every node
is on a path from start toend.
ab
cd e
p2end
p4p3 p1
start
fig. 5. a workow net with source place i=start and sink place o=end
not every wf-net represents a correct process. for example, a process repre-
sented by a wf-net may exhibit errors such as deadlocks, tasks which can never
become active, livelocks, garbage being left in the process after termination, etc.
therefore, we dene the following correctness criterion.denition 5 (soundness). letn= (p;t;f )be a wf-net with input place i
and output place o.nissound i:
1.safeness :(n;[i])is safe, i.e., places cannot hold multiple tokens at the same
time,
2.proper completion : for any marking m2[n;[i]i,o2mimpliesm= [o],
3.option to complete : for any marking m2[n;[i]i,[o]2[n;mi, and
4.absence of dead tasks :(n;[i])contains no dead transitions (i.e., for any
t2t, there is a ring sequence enabling t).
the wf-net shown in figure 5 is sound. soundness can be veried using
standard petri-net-based analysis techniques. in fact soundness corresponds to
liveness and safeness of the corresponding short-circuited net [1]. this way e-
cient algorithms and tools can be applied. an example of a tool tailored towards
the analysis of wf-nets is woan [29]. this functionality is also embedded in
our process mining tool prom [2].
2.4 problem denition and approaches
after introducing events logs and wf-nets, we can dene the the main goal of
process discovery.
denition 6 (process discovery). letlbe an event log over a, i.e.,l2
i b(a). aprocess discovery algorithm is a function that maps any log lonto
a petri net (l) = (n;m ). ideally,nis a sound wf-net and all traces in l
correspond to possible ring sequence of (n;m ).
the goal is to nd a process model that can \replay" all cases recorded in
the log, i.e., all traces in the log are possible ring sequences of the discovered
wf-net. assume that l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9]. in this case the
wf-net shown in figure 5 is a good solution. all traces in l1correspond to
ring sequences of the wf-net and vice versa. note that it may be possible that
some of the ring sequences of the discovered wf-net do not appear in the log.
this is acceptable as one cannot assume that all possible sequences have been
observed. for example, if there is a loop, the number of possible ring sequences
is innite. even if the model is acyclic, the number of possible sequences may
be enormous due to choices and parallelism. later in this article, we will discuss
the quality of discovered models in more detail.
since the mid-nineties several groups have been working on techniques for
process mining [6, 3, 7, 11, 13, 15, 16, 30], i.e., discovering process models based
on observed events. in [5] an overview is given of the early work in this domain.
the idea to apply process mining in the context of workow management sys-
tems was introduced in [7]. in parallel, datta [13] looked at the discovery of
business process models. cook et al. investigated similar issues in the context
of software engineering processes [11]. herbst [22] was one of the rst to tackle
more complicated processes, e.g., processes containing duplicate tasks.most of the classical approaches have problems dealing with concurrency.
the-algorithm [6] is an example of a simple technique that takes concurrency
as a starting point. however, this simple algorithm has problems dealing with
complicated routing constructs and noise (like most of the other approaches
described in literature). in [15, 16] a more robust but less precise approach is
presented.
recently, people started using the \theory of regions" to process discovery.
there are two approaches: state-based regions and language-based regions. state-
based regions can be used to convert a transition system into a petri net [4, 12].
language-based regions add places as long as it is still possible to replay the log
[10, 32]
more from a theoretical point of view, the process discovery problem is related
to the work discussed in [9, 19, 20, 25]. in these papers the limits of inductive
inference are explored. for example, in [20] it is shown that the computational
problem of nding a minimum nite-state acceptor compatible with given data
is np-hard. several of the more generic concepts discussed in these papers can
be translated to the domain of process mining. it is possible to interpret the
problem described in this paper as an inductive inference problem specied in
terms of rules, a hypothesis space, examples, and criteria for successful inference.
the comparison with literature in this domain raises interesting questions for
process mining, e.g., how to deal with negative examples (i.e., suppose that
besides log lthere is a log l0of traces that are not possible, e.g., added by a
domain expert). however, despite the relations with the work described in [9,
19, 20, 25] there are also many dierences, e.g., we are mining at the net level
rather than sequential or lower level representations (e.g., markov chains, nite
state machines, or regular expressions), tackle concurrency, and do not assume
negative examples or complete logs.
the above approaches assume that there is no noise or infrequent behav-
ior. for approaches dealing with these problems we refer to the work done by
christian g unther [21], ton weijters [30], and ana karla alves de medeiros
[23].
3 the alpha algorithm
after introducing the process discovery problem and providing an overview of
approaches described in literature, we focus on the -algorithm [6]. the -
algorithm is not intended as a practical mining technique as it has problems with
noise, infrequent/incomplete behavior, and complex routing constructs. never-
theless, it provides a good introduction into the topic. the -algorithm is very
simple and many of its ideas have been embedded in more complex and robust
techniques. moreover, it was the rst algorithm to really address the discovery
of concurrency.3.1 basic idea
the-algorithm scans the event log for particular patterns. for example, if
activityais followed by bbutbis never followed by a, then it is assumed that
there is a causal dependency between aandb. to reect this dependency, the
corresponding petri net should have a place connecting atob. we distinguish
four log-based ordering relations that aim to capture relevant patterns in the
log.
denition 7 (log-based ordering relations). letlbe an event log over a,
i.e.,l2i b(a). leta;b2a:
{a >lbi there is a trace =ht1;t2;t3;:::tniandi2f1;:::;n 1gsuch
that2landti=aandti+1=b,
{a!lbia>lbandb6>la,
{a#lbia6>lbandb6>la, and
{aklbia>lbandb>la.
consider for example l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9].c >l1dbe-
causeddirectly follows cin traceha;b;c;di. however,d6>l1cbecausecnever di-
rectly follows din any trace in the log. >l1=f(a;b);(a;c);(a;e);(b;c);(c;b);(b;d);
(c;d);(e;d)gcontains all pairs of activities in a \directly follows" relation. c!l1
dbecause sometimes ddirectly follows cand never the other way around ( c>l1d
andd6>l1c).!l1=f(a;b);(a;c);(a;e);(b;d);(c;d);(e;d)gcontains all pairs of
activities in a \causality" relation. bkl1cbecauseb >l1candc >l1b, i.e,
sometimescfollowsband sometimes the other way around. kl1=f(b;c);(c;b)g.
b#l1ebecauseb6>l1eande6>l1b. #l1=f(a;a);(a;d);(b;b);(b;e);(c;c);(c;e);
(d;a);(d;d);(e;b);(e;c);(e;e)g. note that for any log loveraandx;y2a:
x!ly,y!lx,x#ly, orxkly.
the log-based ordering relations can be used to discover patterns in the
corresponding process model as is illustrated in figure 6. if aandbare in
sequence, the log will show a>lb. if afterathere is a choice between bandc,
the log will show a!lb,a!lc, andb#lcbecauseacan be followed by band
c, butbwill not be followed by cand vice versa. the logical counterpart of this
so-called xor-split pattern is the xor-join pattern as shown in figure 6(b-c). if
a!lc,b!lc, anda#lb, then this suggests that after the occurrence of either
aorb,cshould happen. figure 6(d-e) shows the so-called and-split and and-
join patterns. if a!lb,a!lc, andbklc, then it appears that after abothb
andccan be executed in parallel (and-split pattern). if a!lc,b!lc, and
aklb, then it appears that cneeds to synchronize aandb(and-join pattern).
figure 6 only shows simple patterns and does not present the additional
conditions needed to extract the patterns. however, the gure nicely illustrates
the basic idea.
consider for example wf-net n2depicted in figure 7 and the log event log
l2= [ha;b;c;d;e;f;b;d;c;e;g i;ha;b;d;c;e;gi;ha;b;c;d;e;f;b;c;d;e;f;b;d;c;e;g i].
the-algorithm constructs wf-net n2based onl2. note that the patterns in
the model indeed match the log-based ordering relations extracted from thefig. 6. typical process patterns and the footprints they leave in the event log
a bc
de
p({a,f},{b}) ilp({b},{c})
p({b},{d})p({c},{e})
p({d},{e})g
ol p({e},{f,g})f
fig. 7. wf-net n2derived from l2= [ ha; b; c; d; e; f; b; d; c; e; g i;ha; b; d; c; e; g i;
ha; b; c; d; e; f; b; c; d; e; f; b; d; c; e; g i]event log. consider for example the process fragment involving b,c,d, ande.
obviously, this fragment can be constructed based on b!l2c,b!l2d,ckl2d,
c!l2e, andd!l2e. the choice following eis revealed by e!l2f,e!l2g,
andf#l2g. etc.
({a,b},{c})l l({c},{d,e})
fig. 8. wf-net n3derived from l3= [ha; c; d i45;hb; c; d i42;ha; c; e i38;hb; c; e i22]
another example is shown in figure 8. wf-net n3can be derived from
l3= [ha;c;di45;hb;c;di42;ha;c;ei38;hb;c;ei22]. note that here there are two
start and two end activities. these can be found easily by looking for the rst
and last activities in traces.
3.2 algorithm
after showing the basic idea and some examples, we describe the -algorithm.
denition 8 ( -algorithm). letlbe an event log over t.(l)is dened as
follows.
1.tl=ft2tj92lt2g,
2.ti=ft2tj92lt=rst()g,
3.to=ft2tj92lt=last()g,
4.xl=f(a;b)jatl^a6=; ^btl^b6=; ^ 8a2a8b2ba!l
b^ 8a1;a22aa1#la2^ 8b1;b22bb1#lb2g,
5.yl=f(a;b)2xlj8(a0;b0)2xlaa0^bb0=)(a;b) = (a0;b0)g,
6.pl=fp(a;b )j(a;b)2ylg[fil;olg,
7.fl=f(a;p (a;b ))j(a;b)2yl^a2ag[f (p(a;b );b)j(a;b)2yl^b2
bg [f (il;t)jt2tig [f (t;ol)jt2tog, and
8.(l) = (pl;tl;fl).
lis an event log over some set tof activities. in step 1 it is checked which
activities do appear in the log ( tl). these will correspond to the transitions of
the generated wf-net. tiis the set of start activities, i.e., all activities that
appear rst in some trace (step 2). tois the set of end activities, i.e., all activ-
ities that appear last in some trace (step 3). steps 4 and 5 form the core of the
-algorithm. the challenge is to nd the places of the wf-net and their connec-
tions. we aim at constructing places named p(a;b )such thatais the set of input
transitions (p(a;b )=a) andbis the set of output transitions ( p(a;b )=b).1
2
m1
2
nfig. 9. place p(a;b )connects the transitions in set ato the transitions in set b
the basic idea for nding p(a;b )is shown in figure 9. all elements of ashould
have causal dependencies with all elements of b, i.e., for any ( a;b)2ab:
a!lb. moreover, the elements of ashould never follow any of the other
elements, i.e., for any a1;a22a:a1#la2. a similar requirement holds for b.
let us consider l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9]. clearlya=fagand
b=fb;egmeet the requirements stated in step 4. also note that a0=fag
andb0=fbgmeet the same requirements. xlis the set of all such pairs that
meet the requirements just mentioned. in this case, xl1=f(fag;fbg);(fag;fcg);
(fag;feg);(fag;fb;eg);(fag;fc;eg);(fbg;fdg);(fcg;fdg);(feg;fdg);(fb;eg;fdg);(fc;eg;fdg)g.
if one would insert a place for any element in xl1there would be too many
places. therefore, only the \maximal pairs" ( a;b) should be included. note
that for any pair ( a;b)2xl, non-empty set a0a, and non-empty set
b0b, it is implied that ( a0;b0)2xl. in step 5 all non-maximal pairs are
removed. so yl1=f(fag;fb;eg);(fag;fc;eg);(fb;eg;fdg);(fc;eg;fdg)g.
every element of ( a;b)2ylcorresponds to a place p(a;b )connecting tran-
sitionsato transitions b. in addition plalso contains a unique source place il
and a unique sink place ol(cf. step 6).
in step 7 the arcs are generated. all start transitions in tihaveilas an
input place and all end transitions tohaveolas output place. all places p(a;b )
haveaas input nodes and bas output nodes. the result is a petri net (l) =
(pl;tl;fl) that describes the behavior seen in event log l.
thus far we presented three logs and three wf-nets. clearly (l2) =n2,
and(l3) =n3. in gures 7 and 8 the places are named based on the sets yl2
andyl3. moreover, (l1) =n1modulo renaming of places (because dierent
place names are used in figure 5). these examples show that the -algorithm
is indeed able to discover wf-nets based event logs.
figure 10 shows another example. wf-net n4can be derived from l4=
[ha;b;e;fi2;ha;b;e;c;d;b;fi3;ha;b;c;e;d;b;fi2;ha;b;c;d;e;b;fi4;ha;e;b;c;d;b;fi3],
i.e.,(l4) =n4.({a},{e})l l
({e},{f})({b},{c,f}) ({a,d},{b})({c},{d})fig. 10. wf-net n4derived from l4= [ ha; b; e; f i2;ha; b; e; c; d; b; f i3;
ha; b; c; e; d; b; f i2;ha; b; c; d; e; b; f i4;ha; e; b; c; d; b; f i3]
3.3 limitations
in [6] it was shown that the -algorithm is able to discover a large class of
wf-nets if one assumes that the log is complete with respect to the log-based
ordering relation >l. this assumption implies that, for any event log l,a>lb
ifacan be directly followed by b. we revisit the notion of completeness later in
this article.
1
2
fig. 11. wf-net n5derived from l5= [ha; c; e; g i2;ha; e; c; g i3;hb; d; f; g i2;hb; f; d; g i4]
even if we assume that the log is complete, the -algorithm has some prob-
lems. there are many dierent wf-nets that have the same possible behavior,
i.e., two models can be structurally dierent but trace equivalent. consider for
examplel5= [ha;c;e;gi2;ha;e;c;gi3;hb;d;f;gi2;hb;f;d;gi4].(l5) is shown in
figure 11. although the model is able to generate the observed behavior, the
resulting wf-net is needlessly complex. two of the input places of gare re-
dundant, i.e., they can be removed without changing the behavior. the places
denoted as p1andp2are so-called implicit places and can be removed without
allowing for more traces. in fact, figure 11 shows only one of many possible
trace equivalent wf-nets.fig. 12. incorrect wf-net n6derived from l6= [ ha; ci2;ha; b; c i3;ha; b; b; c i2;
ha; b; b; b; b; c i1]
the original -algorithm has problems dealing with short loops, i.e., loops
of length 1 or 2. this is illustrated by wf-net n6in figure 12 which shows
the result of applying the basic algorithm to l6= [ha;ci2;ha;b;ci3;ha;b;b;ci2;
ha;b;b;b;b;ci1]. it is easy to see that the model does not allow for ha;ciand
ha;b;b;ci. in fact, in n6, transition bneeds to be executed precisely once and
there is an implicit place connecting aandc. this problem can be addressed
easily as shown in [24]. using an improved version of the -algorithm one can
discover the wf-net shown in figure 13.
fig. 13. wf-net n7having a so-called \short-loop"
a more dicult problem is the discovery of so-called non-local dependen-
cies resulting from non-free choice process constructs. an example is shown in
figure 14. this net would be a good candidate after observing for example
l8= [ha;c;di45;hb;c;ei42]. however, the -algorithm will derive the wf-net
without the place labeled p1andp2. hence,(l8) =n3shown in figure 8 al-
though the traces ha;c;eiandhb;c;dido not appear in l8. such problems can
be (partially) resolved using rened versions of the -algorithm such as the one
presented in [31].
the above examples show that the -algorithm is able to discover a large
class of models. the basic 8-line algorithm has some limitations when it comes to
particular process patterns (e.g., short-loops and non-local dependencies). some
of these problems can be solved using various renements. however, several more
fundamental problems remain as shown next.1
2fig. 14. wf-net n8having a non-local dependency
4 challenges in process discovery
the-algorithm was the rst process discovery algorithm to adequately cap-
ture concurrency. today there are much better algorithms that overcome the
weaknesses of the -algorithm. these are either variants of the -algorithm or
completely dierent approaches (e.g., based on regions or genetic algorithms).
however, there are still several challenges. below we list some of these challenges.
the rst problem is that many algorithms have problems with complex
control-ow constructs . for example, the choice between the concurrent exe-
cution of bandcor the execution of just eshown in figure 5 cannot be handled
by many algorithms. most algorithms do notallow for so-called \non-free-choice
constructs" where concurrency and choice meet. the concept of free-choice nets
is well-dened in the petri net domain [14]. however, in reality processes tend
to be non-free-choice. in the example of figure 5, the -algorithm is able to deal
with the non-free-choice construct. however, it is easy to think of a non-free-
choice process that cannot be discovered by the -algorithm (see for example
n8in figure 14). the non-free-choice construct is just one of many constructs
that existing process mining algorithms have problems with. other examples
are arbitrary nested loops, cancelation, unbalanced splits and joins, partial syn-
chronization, etc. in this context it is important to note that process mining is,
by denition, restricted by the expressive power of the target language , i.e., if a
simple or highly informal language is used, process mining is destined to produce
less relevant or over-simplied results.
the second problem is the fact that most algorithms have problems with
duplicates . the same activity may appear at dierent places in the process or
dierent activities may be recorded in an indistinguishable manner. consider for
example figure 5 and assume that activities aanddare both recorded as x(or,
equivalently, assume that aand dare both replaced by activity x). hence, an
event log could be l0
1= [hx;b;c;xi5;hx;c;b;xi8;hx;e;xi9]. most algorithms will
try to map the rst and the second xonto the same activity. in some cases this
make sense, e.g., to create loops. however, if the two occurrences of x(i.e., aand
d) really play a dierent role in the process, then algorithms that are unable to
separate them will run into all kinds of problems, e.g., the model becomes more
dicult or incorrect. since the duplicate activities have the same \footprint" in
the log, most algorithms map these dierent activities onto a single activity thus
making the model incorrect or counter-intuitive.the third problem is that many algorithms have a tendency to generate
inconsistent models . note that here we do not refer to the relation between the
log and the model but to the internal consistency of the model by itself. for
example, the -algorithm may yield models that have deadlocks or livelocks
when the log shows certain types of behavior. when using petri nets as a model
to represent processes, an obvious choice is to require the model to be sound (i.e.,
free of deadlocks and other anomalies). unfortunately, this can typically only be
achieved by severely limiting the expressiveness of the modeling languages (e.g.,
require it to be block structured).
the fourth and last problem described here is probably the most important
problem: existing algorithms have problems balancing between \overtting" and
\undertting" . overtting is the problem that a very specic model is generated
while it is obvious that the log only holds example behavior, i.e., the model
explains the particular sample log but a next sample log of the same process
may produce a completely dierent process model. undertting is the problem
that the model over-generalizes the example behavior in the log, i.e., the model
allows for very dierent behaviors from what was seen in the log. the problem
of balancing between \overtting" and \undertting" is related to the notion of
completeness discussed next.
5 completeness: between overtting and undertting
when it comes to process mining the notion of completeness is very important.
like in any data mining or machine learning context one cannot assume to have
seen all possibilities in the \training material" (i.e., the event log at hand). for
wf-netn1in figure 5 and event log l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9], the
set of possible traces found in the log is exactly the same as the set of possible
traces in the model. in general, this is not the case. for example, the trace
ha;b;e;c;dimay be possible but did not (yet) occur in the log. process models
typically allow for an exponential or even innite number of dierent traces (in
case of loops). moreover, some traces may have a lower probability than others.
therefore, it is unrealistic to assume that every possible trace is present in the
event log.
the-algorithm assumes a relatively weak notion of completeness to avoid
this problem. although n2has innitely possible ring sequences, a small log like
l2= [ha;b;c;d;e;f;b;d;c;e;g i;ha;b;d;c;e;gi;ha;b;c;d;e;f;b;c;d;e;f;b;d;c;e;g i]
can be used to construct n2. the-algorithm uses a local completeness notion
based on>l, i.e., if there are two activities aandb, andacan be directly
followed by b, then this should be observed at least once in the log.
to illustrate the relevance of completeness, consider a process where in princi-
ple 10 tasks which can be executed in parallel and the corresponding log contains
information about 10000 cases. the total number of possible interleavings is 10!
= 3628800. hence, it is impossible that each interleaving is present in the log as
there are fewer cases than potential traces. even if there are 3628800 cases in the
log, it is extremely unlikely that all possible variations are present. to motivatethis consider the following analogy. in a group of 365 people it is very unlikely
that everyone has a dierent birthdate (probability 365! =3653650). similarly,
it is unlikely that all possible traces will occur for any process of some complex-
ity. it is even worse as some sequences are less probable than others. weaker
completeness notions are therefore needed. note that for the process where 10
tasks which can be executed in parallel, local completeness can reduce the re-
quired number of observations dramatically. for example, for the -algorithm
only 10(10 1) = 90 rather than 3628800 dierent observations are needed to
construct the model.
completeness is closely linked to the notions of overtting and undertting
mentioned earlier. it is also linked to occam's razor, a principle attributed
to the 14th-century english logician william of ockham. the principle states
that \one should not increase, beyond what is necessary, the number of entities
required to explain anything", i.e., one should look for the \simplest model" that
can explain what is in the log. using this principle dierent algorithms assume
dierent notions of completeness.
fig. 15. the so-called \ower petri net" allowing for any log containing activities
fa; b; : : : h g
process mining algorithms needs to strike a balance between \overtting" and
\undertting". a model is overtting if it does not generalize and only allows
for the exact behavior recorded in the log. this means that the corresponding
mining technique assumes a very strong notion of completeness: \if the sequence
is not in the event log, it is not possible.". an undertting model over-generalizes
the things seen in the log, i.e., it allows for more behavior even when there are no
indications in the log that suggest this additional behavior. an example is shown
in figure 15. this so-called \ower petri net" allows for any sequence starting
with start and ending with end and containing any ordering of activities in
between. clearly, this model allows for event log l1(without the added start
and endactivities) but also many more, e.g., all other example logs mentioned
in this article and many more.let us now consider another example showing that it is dicult to balance be-
tween being too general and too specic. consider wf-net n3shown in figure 8
andn8shown in figure 14. both nets can produce log l8= [ha;c;di45;hb;c;ei42]
and onlyn3can produce l3= [ha;c;di45;hb;c;di42;ha;c;ei38;hb;c;ei22]. clearly,
n3is the logical choice for l3. moreover, although both nets can produce l8, it is
obvious that n8is a better model for l8as none of the 87 cases required the two
additional alternatives. however, now consider l9= [ha;c;di99;hb;c;di1;ha;c;ei2;
hb;c;ei98]. one can argue that n3is a better model for l9as all traces can be
reproduced. however, 197 out of 200 traces can be explained by the more pre-
cise model n8. if the three traces are seen as deviations, the main behavior is
captured by n8and notn3. such considerations show that there is a delicate
balance and that it is non-trivial to compare logs and process models. hence, it
is dicult, if not impossible, to select the \best" model.
in [28] notions such as tness and appropriateness have been quantied. an
event log and petri net \t" if the petri net can generate each trace in the log.1
in other words: the petri net should be able to \parse" (i.e., reproduce) every
activity sequence observed. in [28] it is shown that it is possible to quantify t-
ness as a measure between 0 and 1. the intuitive meaning is that a tness close
to 1 means that all observed events can be explained by the model. however,
the precise meaning is more involved since tokens can remain in the net and
not all transactions in the model need to be logged [28]. unfortunately, a good
tness alone does not imply that the model is indeed suitable, e.g., it is easy
to construct petri nets that are able to reproduce any event log (cf. the \ower
model" in figure 15). although such petri nets have a tness of 1, they do not
provide meaningful information. therefore, in [28] a second dimension is intro-
duced: appropriateness . appropriateness tries to answer the following question:
\does the model describe the observed process in a concise way?". this notion
can be evaluated from both a structural and a behavioral perspective. in [28] it is
shown that a \good" process model should somehow be \minimal in structure"
to clearly reect the described behavior, referred to as structural appropriate-
ness, and \minimal in behavior" in order to represent as closely as possible what
actually takes place, which is called behavioral appropriateness . the prom con-
formance checker [28] supports both the notion of tness and various notions of
appropriateness, i.e., for a given log and a given model it computes the dierent
metrics.
although there are dierent ways to quantify notions such as tness and
appropriateness, it is dicult to agree on the denition of an \optimal model".
what is optimal seems to depend on the intended purpose and even given a
clear metric there may be many models having the same score. since there is
not \one size ts all", it is important to have algorithms that can be tuned to
specic applications.
1it is important not to confuse tness with overtting andundertting . a model that
is overtting or undertting may have a tness of 1.why is process mining a dicult problem? there are obvious reasons that
also apply to many other machine learning problems. examples are noise and a
large search space. however, there are also some specic problems:
{there are no negative examples (i.e., a log shows what has happened but
does not show what could not happen),
{due to concurrency, loops, and choices the search space has a complex struc-
ture and the log typically only contains a fraction of all possible behaviors,
and
{there is no clear relation between the size of a model and its behavior (i.e.,
a smaller model may generate more or less behavior while classical mdl
methods typically assume some monotonicity property).
6 applications
despite the challenges mentioned, there are mature techniques available today.
prom supports the major process mining techniques described in literature. ro-
bust techniques such as the fuzzy miner [21] and the heuristic miner [30] can
analyze complex event logs eciently and eectively. these techniques have been
implemented in prom which can be downloaded from www.processmining.org .
fig. 16. screenshot of prom while analyzing an event log of a housing agencyin this paper, we do not elaborate on more advanced process mining tech-
niques and their implementations in prom. figure 16 shows a screenshot of prom
while analyzing a log containing 208 cases that generated 5987 events. the left
part shows an animation of the discovered fuzzy model, i.e., the recorded events
are replayed on top of the discovered process model. this gives insights in bot-
tlenecks, deviations, etc. the right part depicts a so-called dotted chart showing
a helicopter view of all events in the log.
most other tools in this area only implement one specic technique and focus
on a single perspective and technique. there are also a few commercial tools.
most notable are futura reect by futura process intelligence and bpmjoneby
pallas athena. these two tools support process discovery based on genetic min-
ing [23] and should be seen as a re-implementation of plug-ins already present in
prom (making it faster and more user-friendly). comprehend by open connect,
interstage automated business process discovery and visualization by fujitsu,
process discovery focus by iontas, and enterprise visualization suite by busi-
nesscape are some examples of commercial tools that oer some form of process
discovery. typically such tools can only discover sequential models and are, in
terms of functionality, comparable to a handful of the 250 plug-ins of prom. an-
other example is the aris process performance manager (aris ppm) by ids
scheer which has adopted the idea to extract social networks from event logs
from prom. until recently, aris ppm did not support control-ow discovery
in the sense described above. however, it was possible to link events to process
fragments that are then glued together as they occur. the drawback of this ap-
proach is that the model still needs to be made manually. despite the limitations
mentioned, these examples show that there is a growing interest from software
vendors (and their customers) in process mining.
we have applied process mining in a wide variety of organizations:
{municipalities (e.g., alkmaar, heusden, harderwijk, etc.)
{government agencies (e.g., rijkswaterstaat, centraal justitieel incasso bu-
reau, justice department)
{insurance related agencies (e.g., uwv)
{banks (e.g., ing bank)
{hospitals (e.g., amc hospital, catharina hospital)
{multinationals (e.g., dsm, deloitte)
{high-tech system manufacturers and their customers (e.g., philips health-
care, asml, thales)
{media companies (e.g. winkwaves)
based on these experiences, we highlight three application domains where
process mining can be extremely valuable.
6.1 hospital information systems
for many years hospitals have been working on electronic patient records
(epr), i.e., information about the health history of a patient, including all pastand present health conditions, illnesses and treatments, is managed by the infor-
mation system. although there are still many problems that need to be resolved
(mainly of a non-technical nature), today's hospital information systems already
contain a wealth of event data. for example, by dutch law all hospitals need
to record the diagnostic and treatment steps at the level of individual patients
in order to receive payment. this so-called \diagnose behandeling combinatie"
(dbc) forces dutch hospitals to record all kinds of events. clearly, there is
a need for process discovery, conformance checking, and process improvement
(e.g., reducing ow times) in the health-care domain.
6.2 municipal information systems
municipalities are continuously confronted with new regulations that need to be
implemented. although these processes are typically not \controlled" by some
process engine, the processes are documented and the activities in these processes
are recorded. conformance checking is highly relevant as compliance is important
in public administration. moreover, many regulations have legal deadlines, so
conformance checking with temporal constraints and time prediction is relevant.
for example, if it is predicted that a case will not be dealt with before the legal
deadline, appropriate actions can be triggered. moreover, there are many less
structured processes where discovery can be very useful.
6.3 high-tech deployed systems
increasingly high-tech deployed systems such as high-end copiers, complex med-
ical equipment, lithography systems, automated production systems, etc. record
events which allow for the remote monitoring of these systems. for the man-
ufacturers of such systems it is interesting to use process mining, e.g., are the
systems used in the way they should be used and do systems show signs of de-
viating behavior. the \customercare remote services network" of philips
healthcare (ph) is a nice example of an enabling technology for process mining.
through this network ph is recording events from systems all over the world
(e.g., x-ray machines in hospitals). process mining can be used to see if main-
tenance is needed and gives good insight in whether the medical equipment is
used as intended.
7 process mining: a grand challenge for computational
intelligence
computational intelligence (ci) is sometimes dened as \a branch of computer
science studying problems for which there are no eective computational algo-
rithms" [17]. the techniques used are often inspired by nature and typical exam-
ples are neural networks, fuzzy sets, rough sets, swarm intelligence, evolutionary
computing, and genetic algorithms [18]. clearly, there are also relationships witharticial intelligence, reenforcement learning, data mining, machine learning, and
pattern recognition.
in this paper, we presented an overview of process mining and zoomed in on
the challenge of process discovery by presenting a simple mining algorithm. the
-algorithm was presented because of its simplicity and because it forms the
basis for many other discovery algorithms. however, there are also other process
discovery techniques that use approaches more common in ci. the genetic miner
[23] uses genetic algorithms and the fuzzy miner [21] uses a variety of quantitative
measures to decide whether there may be causal dependency or not. given the
nature of the problem, it seems that also other typical ci techniques such as
neural networks, rough sets, and reenforcement learning could be used for process
discovery (and other forms of process mining). in fact, the problem described in
this paper can be seen as a grand challenge for ci researchers given its many
intricate diculties.
as indicated in the introduction, processes are less tangible than products
or data. processes tend to be elusive; they emerge and dissolve and many actors
may inuence parts of it. yet most individuals and organizations are involved in
a multitude of processes and many of these processes are essential for their exis-
tence. although processes are considered important and are frequently discussed,
there is little attention for studying them in detail. it seems that lion's share of
attention goes to their high-level design and management at an aggregate level,
while neglecting the analysis of the actual process events. until recently, it was
dicult to systematically record events. however, the \data explosion" in all
domains where it systems are used, makes process mining techniques viable.
in many branches of science researchers study reality, e.g., physicists study
matter and its motion through spacetime, chemists study the composition, struc-
ture, and properties of matter, and biologists study evolution, organisms, cells,
and genes. in these branches of science it is common to discover reality by obser-
vation or to test a model using real-life observations. computer science is mainly
a design science, i.e., often some new (typically virtual) reality is created. how-
ever, for building information systems that work well in reality, it is vital to
understand the processes they are supposed to support. this illustrates the im-
portance of process mining. therefore, the ieee recently launched the ieee
task force on process mining chaired by the author of this article. this task
force has been established in the context of the data mining technical commit-
tee (dmtc) of the computational intelligence society (cis) of the institute of
electrical and electronic engineers, inc. (ieee). the goal of this task force is
to promote the research, development, education and understanding of process
mining. more concretely, its purpose is to make end-users, developers, consul-
tants, and researchers aware of the state-of-the-art in process mining, promote
the use of process mining techniques and tools, stimulate new applications, play
a role in standardization eorts for logging event data, and organize tutorials,
special sessions, workshops, panels. the interested reader is invited to contribute
to the work of the ieee task force on process mining.acknowledgment
the author would like to thank the many people involved in the development of
prom and the organizations sponsoring our work on process mining.
references
1. w.m.p. van der aalst. the application of petri nets to workow management.
the journal of circuits, systems and computers , 8(1):21{66, 1998.
2. w.m.p. van der aalst, b.f. van dongen, c.w. g unther, r.s. mans, a.k. alves
de medeiros, a. rozinat, v. rubin, m. song, h.m.w. verbeek, and a.j.m.m.
weijters. prom 4.0: comprehensive support for real process analysis. in j. kleijn
and a. yakovlev, editors, application and theory of petri nets and other models of
concurrency (icatpn 2007) , volume 4546 of lecture notes in computer science ,
pages 484{494. springer-verlag, berlin, 2007.
3. w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters, b.f. van dongen, a.k.
alves de medeiros, m. song, and h.m.w. verbeek. business process mining: an
industrial application. information systems , 32(5):713{732, 2007.
4. w.m.p. van der aalst, v. rubin, b.f. van dongen, e. kindler, and c.w. g unther.
process mining: a two-step approach to balance between undertting and over-
tting. software and systems modeling , 2009.
5. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
6. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
7. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ow logs. in sixth international conference on extending database technology ,
pages 469{483, 1998.
8. r. agrawal and r. srikant. mining sequential patterns. in proceedings of the
11th international conference on data engineering (icde'95) , pages 3{14. ieee
computer society, 1995.
9. d. angluin and c.h. smith. inductive inference: theory and methods. computing
surveys , 15(3):237{269, 1983.
10. r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on
regions of languages. in g. alonso, p. dadam, and m. rosemann, editors, inter-
national conference on business process management (bpm 2007) , volume 4714
oflecture notes in computer science , pages 375{383. springer-verlag, berlin,
2007.
11. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
12. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets
from finite transition systems. ieee transactions on computers , 47(8):859{882,
august 1998.
13. a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275{301,
1998.14. j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
15. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362{376. springer-verlag, berlin, 2004.
16. b.f. van dongen and w.m.p. van der aalst. multi-phase mining: aggregating
instances graphs into epcs and petri nets. in d. marinescu, editor, proceedings of
the second international workshop on applications of petri nets to coordination,
workow and business process management , pages 35{58. florida international
university, miami, florida, usa, 2005.
17. w. duch. what is computational intelligence and where is it going? in w. duch
and j. mandziuk, editors, challenges for computational intelligence , volume 1420
ofstudies in computational intelligence , pages 1{13. springer-verlag, berlin, 2007.
18. a.p. engelbrecht. computational intelligence: an introduction . wiley & sons,
2007.
19. e.m. gold. language identcation in the limit. information and control ,
10(5):447{474, 1967.
20. e.m. gold. complexity of automaton identication from given data. information
and control , 37(3):302{320, 1978.
21. c.w. g unther and w.m.p. van der aalst. fuzzy mining: adaptive process sim-
plication based on multi-perspective metrics. in g. alonso, p. dadam, and
m. rosemann, editors, international conference on business process management
(bpm 2007) , volume 4714 of lecture notes in computer science , pages 328{343.
springer-verlag, berlin, 2007.
22. j. herbst. a machine learning approach to workow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183{194. springer-verlag, berlin, 2000.
23. a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245{304, 2007.
24. a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science , pages
389{406. springer-verlag, berlin, 2003.
25. l. pitt. inductive inference, dfas, and computational complexity. in k.p. jan-
tke, editor, proceedings of international workshop on analogical and inductive
inference (aii) , volume 397 of lecture notes in computer science , pages 18{44.
springer-verlag, berlin, 1989.
26. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
27. a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. fiadeiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420{425. springer-verlag, berlin, 2006.
28. a. rozinat and w.m.p. van der aalst. conformance checking of processes based
on monitoring real behavior. information systems , 33(1):64{95, 2008.
29. h.m.w. verbeek, t. basten, and w.m.p. van der aalst. diagnosing workow
processes using woan. the computer journal , 44(4):246{279, 2001.30. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151{162, 2003.
31. l. wen, w.m.p. van der aalst, j. wang, and j. sun. mining process models with
non-free-choice constructs. data mining and knowledge discovery , 15(2):145{180,
2007.
32. j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. in k. van hee and r. valk,
editors, proceedings of the 29th international conference on applications and the-
ory of petri nets (petri nets 2008) , volume 5062 of lecture notes in computer
science , pages 368{387. springer-verlag, berlin, 2008.