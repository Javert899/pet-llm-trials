information systems and e-business management manuscript no.
(will be inserted by the editor)
measuring precision of modeled behavior
a. adriansyah j. munoz-gama
j. carmona b.f. van dongen 
w.m.p. van der aalst
received: date / accepted: date
abstract conformance checking techniques compare observed behavior (i.e.,
event logs) with modeled behavior for a variety of reasons. for example, dis-
crepancies between a normative process model and recorded behavior may
point to fraud or ineciencies. the resulting diagnostics can be used for au-
diting and compliance management. conformance checking can also be used
to judge a process model automatically discovered from an event log. models
discovered using dierent process discovery techniques need to be compared
objectively. these examples illustrate just a few of the many use cases for
aligning observed and modeled behavior. thus far, most conformance check-
ing techniques focused on replay tness, i.e., the ability to reproduce the event
log. however, it is easy to construct models that allow for lots of behavior (in-
cluding the observed behavior) without being precise .
in this paper, we propose a method to measure precision of process mod-
els, given their event logs by rst aligning the logs to the models. this way,
the measurement is not sensitive to non-tting executions and more accurate
values can be obtained for non-tting logs. furthermore, we introduce sev-
eral variants of the technique to deal better with incomplete logs and reduce
possible bias due to behavioral property of process models. the approach has
been implemented in the prom 6 framework and tested against both articial
and real-life cases. experiments show that the approach is robust to noise and
applicable to handle logs and models of real-life complexity.
a. adriansyahb.f. van dongen w.m.p. van der aalst
department of mathematics and computer science
eindhoven university of technology
p.o. box 513, 5600 mb eindhoven, the netherlands
e-mail:fa.adriansyah,b.f.v.dongen,w.m.p.v.d.aalst g@tue.nl
j. munoz-gamaj. carmona
universitat politecnica de catalunya
barcelona, spain
e-mail:fjmunoz,jcarmonag@lsi.upc.edu2 adriansyah, munoz-gama, carmona, van dongen and van der aalst
examination radiology 
therapy update record 
allergy test chemotherapy 
post-chemo home care 
operation start a ‚Äúflower‚Äù model ( f) an overfitting (precise) model ( p)
event log 
abcd 
acbe 
afgh 
abibcd 1,230 
1,442 
435 
1,893 trace frequency ab cd
e
fghitherapy update record 
allergy test chemotherapy post-chemo examination radiology operation radiology update record therapy 
update record radiology home care start end 
a bc d
i b c d
c b e
f g h
fig. 1: example of an extremely imprecise (undertting) and precise model (overtting)
for a given log.
keywords precision measurement log-model alignment conformance
checkingprocess mining
1 introduction
the starting point for most business process management (bpm) activities
are process models, as they provide insights into possible scenarios [21]. process
models are used for analysis (e.g., simulation [5]), enactment [21], redesign [18],
and process improvement [28,29]. therefore, they should reect the dominant
behavior accurately. the increasing availability of event data enables the ap-
plication of conformance checking [2,4,30]. conformance checking techniques
compare recorded process executions in the form of event logs with process
models to quantify how \good" are the models with respect to their execu-
tions.
conformance can be viewed along multiple orthogonal dimensions: (1) t-
ness, (2) precision, (3) generalization, and (4) simplicity [2,14]. in this paper,
we focus on the precision dimension. given an event log and a process model,
precision penalizes the model for allowing behavior that is unlikely given the
observed behavior in the log. take for example the two models and the event
log in figure 1. both models show a cancer patient handling process in a hos-
pital and are shown using petri net formalism [27].1all traces in the log can be
reproduced by both models, i.e., the traces perfectly tthe models. however,
notice that the \ower" model ( f) may provide misleading insights, as it also
allows for much more behavior not appearing in the log. in contrast, the other
model ( p) only allows traces that occur in the log. hence, the precision of
model pis better than model fwith respect to the log.
many existing precision metrics (e.g., [25, 30, 34]) do not explicitly take
into account possible deviations between the behavior observed in the event
log with the behavior modeled in the models, while many case studies show
1for the reader not familiar with petri nets, a petri net is a bipartite graph that contains
two types of nodes: places (circles) and transitions (boxes). a place may contain tokens
(black dots), and a transition can re if its predecessor places contain a token. when red, a
transition removes a token from each input place and adds a token to each successor place.measuring precision of modeled behavior 3
that such deviations often occur in practice (e.g., [11,16,19,20,23,31,35,36]).
thus, these metrics might be biased due to untting logs and models. in this
paper, we explicitly take deviations between the observed behavior in event
logs and the modeled behavior in process models into account and propose a
robust approach to measure the precision between a (possibly non-tting)
event log and a model. first, we align the log and the model to nd, for each
trace, those complete activity sequences in the model that are most similar
to the trace. then we use these alignments to measure precision between the
original log and the model. in this paper, we generalize the approach presented
in [9] by introducing various possible ways of computing precisions based on
alignments, their log completeness requirements, and their issues in order to
obtain accurate precision values.
the remainder of this paper is organized as follows: section 2 shows the
notations and preliminary concepts that are used throughout this paper. align-
ments between event logs and models are explained in section 3. the alignment-
based precision approach is presented in section 4. in section 5 we propose a
series of extensions for the basic precision approach. experimental results are
given in section 6. section 7 concludes the paper.
2 preliminaries
conformance checking requires as input both a process model and an event
log. therefore, we rst formalize process models and logs after introducing a
set of notations that is used in the remainder of this paper.
2.1 sequence and multiset
letwbe a set. for (nite) sequences of elements over a set w, we useto
denote an empty sequence. a concatenation of sequences 1and2is denoted
with12.wdenotes the set of all nite sequences over w. we refer to the
i-th element of a sequence as[i] and we usejjto represent the length of
sequence. we say that any x2(ww) is a pair. we use1(x) and2(x)
to refer to the rst and the second element of pair xrespectively. we general-
ize this notation to sequences: i() =hi([1]);:::;i([jj])i. for example,
1(h(a;b);(b;c);(b;d)i) =h1((a;b));1((b;c));1((b;d))i=ha;b;bi. for all
qw,#qdenotes the projection of 2wonq, e.g.,ha;a;b;ci#fa;cg=
ha;a;ci.p(q) denotes the powerset of q, e.g.,p(fa;bg) =ffg;fag;fbg;fa;bgg.
amultisetmoverwis a mapping m:w!in. we overload the set
notation, using;for the empty multiset and 2for the element inclusion. we
write e.g.,m= [p2;q] orm= [p;p;q ] for a multiset mwithm(p) = 2,m(q) = 1,
andm(x) = 0 for all x62fp;qg. we usejmjto indicate the total number of
elements in multiset m(e.g.,j[p2;q]j= 3).4 adriansyah, munoz-gama, carmona, van dongen and van der aalst
2.2 event log and process model
the starting point for conformance checking is an event log . an event log
records the execution of all cases (i.e., process instances). each case is described
by a trace, i.e., an activity sequence. dierent cases may have exactly the same
trace. in reality, not all activities performed in a process are logged. we dene
the set of all logged activities from the universe of activities aasala. an
event log over alis a multiset l:al!in. for example, the log in figure 1
is formalized as [ ha;b;c;di1230;ha;c;b;ei1442;ha;f;g;hi435;ha;b;i;b;c;di1893].
note that for simplicity, we omit brackets for sequences of activities in figure 1.
similarly, a process model denes a set of sequences of activities that leads
to proper termination of the process. furthermore, some activities in a process
may not appear in its model. thus, we dene a set of modeled activities
over the set of all activities aasama. a process model is a (possibly
innite) set of complete activity sequences mam, i.e., executions from
the initial state to some nal state. consider for example the precise model
(p) in figure 1. assuming that the end state is reached when the \end"
place contains exactly one token, the model is formalized by the nite set
fha;b;c;di;ha;c;b;ei;ha;f;g;hi;ha;b;i;b;c;dig. note that the set of modeled
activities and the set of logged activities may be disjoint, i.e., am\alcan
be the empty set. we consider activities that appear in event logs but not
modeled in process models as activities that are allowed to occur anytime.
furthermore, modeled activities in process models that never occur in event
logs are considered as unlogged activities. thus, their absence in the logs is
not counted as violations to the models.
3 cost-optimal alignment
an alignment between an event log and a process model relates the occurrences
of activities in the log to the execution steps of the model. as the execution
of a case is often performed independently of the execution of another case,
aligning is performed on the basis of traces.
for each trace in an event log that ts a process model, each \move" in
the trace (i.e., an event observed in the log) can be mimicked by a \move"
in the model (i.e., an action executed in the model). however, this is not the
case if the trace does not t the model perfectly. we use the symbol to
denote \no move" in either the log or the model. hence, we introduce the set
a
l=al[fg where any x2a
lrefers to a \move in log" and the set
a
m=am[fg where anyy2a
mrefers to a \move in model". formally,
amove is represented by a pair ( x;y)2a
la
msuch that:
{(x;y) is a move in log ifx2alandy=,
{(x;y) is a move in model ifx=andy2am,
{(x;y) is a synchronous move/move in both ifx2al,y2am, andx=y,
{(x;y) is a illegal move in all other cases.measuring precision of modeled behavior 5
examination 
radiology therapy 
update record 
allergy test chemotherapy post-chemo home care operation 
p0p1
p3
p2
p4p5
p6 p7a b
cd
ei
f g h
fig. 2: process model that is neither overtting nor imprecise for the log in figure 1.
1=abde
acbe2=abde
abce3=abde
acbd
4=abde
abcd5=abde
abce6=abde
afgh
fig. 3: some alignments between trace l=ha;b;d;eiand the model in figure 2.
we usealmto denote the set of all pairs of legal moves , i.e., all possible
pairs of move in log, move in model, and move in both.
along this section, let lbe a log over al, letl2lbe a trace, and let m
be a model. an alignment betweenlandmis a sequence 2almwhere
the projection of the rst element (ignoring ) yieldsl(i.e.,1()#al=l)
and projection of the second element (ignoring ) yields a complete sequence
ofm(i.e.,2()#am2m).
take for example an untting trace l=ha;b;d;eiand the model in
figure 2. assuming that the end state of the model is reached when place p5in
the model contains exactly one token, the model has an innite set of complete
activity sequences (i.e., fha;b;c;di;ha;c;b;di;ha;b;c;ei;ha;c;b;ei;ha;f;g;hi;
ha;b;i;c;b;ei;:::g). some possible alignments between land the model are
shown in figure 3.
the moves are represented vertically in figure 3, e.g., the second move of
1is (;c), indicating that the model moves cwhile the log does not make
any move. note that the projection of an alignment between a trace and a
model to all of its movements on model yields a complete activity sequence al-
lowed by the model. this property is not always ensured by other conformance
checking approaches. for example, given a trace and a process model, when
using the approach in [30], the so-called \missing tokens" are added to allow
the activities that occur in the trace but not supposed to occur according to
the model. the addition of such missing tokens introduces extra behavior that
is not allowed in the original process model.
to measure the cost of an alignment, we dene a distance function :
alm!inwhere for all ( al;am)2alm;((al;am)) = 0 ifal=am6 adriansyah, munoz-gama, carmona, van dongen and van der aalst
and(al;am) = 1 otherwise.2the distance function can be generalized to
alignments 2almby taking the sum of the costs of all individual moves:
() =p
(al;am)2((al;am)). using this function, the cost of alignment 1
is(1) =((a;a))+((;c))+((b;b))+((d;))+((e;e)) = 0+1+0+1+0 =
2. note that the function returns the number of mismatches in the alignment.
given a trace from an event log and a process model, we are interested
in an activity sequence from the model that is similar to the trace. there-
fore, we dene the set of alignments  l;m=f2almjis an alignment
betweenlandmgto be all possible alignments between landm. accord-
ingly, we dene the set of optimal alignments as the set of all alignments with
minimum cost, i.e.,  o
l;m=f2 l;mj802 l;m()(0)g. it is easy
to see that there can be more than one optimal alignment between a trace
and a model. for example, f1;2;3;4;5gis the set of optimal alignments
between the trace l=ha;b;d;eiand the model in figure 2.
for all alignments 2alm;m() =2()#amdenotes the projection of
to modeled activities. by denition, the bottom part of all alignments yields
a complete activity sequence of the model. thus, given an optimal alignment
betweenlandm, the projection m() provides an activity sequence that
both perfectly ts mand closest to l. in the example shown in figure 2,
m(1) =ha;c;b;eiis one of the complete activity sequences of mthat is
most similar to trace ha;b;d;ei.
given a log and a model, constructing all optimal alignments between all
traces in the log and the model is computationally expensive [7,8]. thus, com-
puting all optimal alignments between traces and process models with real-life
complexity may not always be feasible in practice. thus, instead of computing
all optimal alignments between traces in the log and the model to obtain in-
sights into deviations, one may also compute just some representative optimal
alignments for each trace. in this paper, we investigate both approaches. we
dene three functions that provide optimal alignments between traces in the
log and the model:
{
m:a
l!p (alm) returns all optimal alignments between traces of l
andm, such that for all l2l;
m(l) = o
l;m,
{1
m:a
l!almreturns one optimal alignment between traces of land
m, such that for all l2l;1
m(l)2 o
l;m, and
{r
m:a
l!p (alm) returns representatives of optimal alignments be-
tween traces of landm, such that for all l2l;r
m(l) o
l;m.
in [7, 8, 10] various approaches to obtain an optimal alignment between a
trace and a model with respect to dierent cost functions are investigated.
given a trace lofland a model m, if there are multiple optimal align-
ments,1
mchooses one of them according to other external criteria. with our
previous example, suppose that 1
mselects an alignment that has the longest
consecutive occurrence of synchronous moves in the beginning, 1
m(l) =4.
2the distance function can be user-dened, but for simplicity we use a default distance
function that assigns unit costs to moves in log/model only.measuring precision of modeled behavior 7
in [7,8], an a?-based algorithm is proposed to compute one optimal align-
ment between a trace and a model. the same algorithm can be extended to
provide more than one optimal alignment between them. given a trace lof
land a model m, the algorithm constructs one optimal alignment by comput-
ing a shortest path from the initial to the nal state of the state space of the
synchronous product between landm. it is shown in [8] that all shortest
paths from the initial to the nal state of the state space yields an optimal
alignment. for each state in the state space, the algorithm records a shortest
path from the initial state to reach this state and thus, becomes the represen-
tative of all other shortest paths from the initial state to the state. an optimal
alignment is constructed from a shortest path from the initial state to the nal
state that is also representing all other shortest paths that connect the same
pair of states. by recording all represented shortest paths during state space
exploration for each state, we can obtain all shortest paths from the initial to
the nal state of the state space (i.e., obtain all optimal alignments ).
furthermore, we can form groups of all shortest paths from the initial to
the nal state according to some criteria and take one representative path for
each group. this way, we can get a number of representatives of all shortest
paths between one up to the total number of all shortest paths from the initial
to the nal state. there are many possible ways of grouping shortest paths
(i.e., grouping optimal alignments). one possibility is to group them based on
their sub-path similarity (i.e., the followed sub-path in the state space). for
example, one may group them based on the last step taken in the paths before
they reach the nal state. such a grouping can be easily performed without
much extra computation using the constructed state space. moreover, this way
of grouping allows computation of the exact number of represented optimal
alignments for each representative by iterating through the state space. the
interested reader is referred to [7,8] for details on the constructed state space
with thea?-based algorithm approach. note that to minimize the number
of states that need to be explored, some optimizations can be performed to
avoid visiting \similar" states more than once (e.g., pruning, prioritization
of states [22, 32]). in such cases, the constructed state space may be pruned.
thus, the number of represented shortest paths computed using the approach
proposed before may only provide a lower bound to the actual number of
represented shortest paths.
given a set of representatives of all optimal alignments, each representa-
tive may represent a dierent number of optimal alignments. for all repre-
sentatives2r
m(l);repm() denotes the number of optimal alignments
represented by . furthermore, due to possible pruning of state space, for all
1;22r
m(l) :p
02r
m(l)repm(0)j o
l;mj, i.e., the total number of
represented optimal alignments by the representatives is a lower bound of the
total number of all optimal alignments.
take for example a trace l=hai. all optimal alignments between the
trace and the model in figure 2 are shown in figure 4. suppose that we
dene function raccording to the extension to the a?algorithm we de-
scribed before, r(l) =f7;9;10gwhererepm(7) = 1 (7represents8 adriansyah, munoz-gama, carmona, van dongen and van der aalst
7=a
afgh8=a
abcd9=a
acbd
10=a
acbe11=a
abce
fig. 4: all optimal alignments between trace l=haiand the model in figure 2.
f7g),rep(9) = 2 (9representsf8;9g), andrep(10) = 2 (10represents
f10;11g). in this example, (7);(9);(10) areha;f;g;hi;ha;c;b;di, and
ha;c;b;eirespectively.
for simplicity, in the remainder we omit the model notation min func-
tions
m;1
m;r
m;m, andrepmif the context is clear. note that in cases
where a process model has duplicate tasks (more than one task to represent an
activity) or invisible tasks (tasks whose execution are not logged), approaches
to construct alignments (e.g., [7,10]) keep the mapping from all model moves
to the tasks they correspond to. hence, given an alignment of a trace and such
models, we know exactly which task is executed for each model move. we refer
to [7,10] for further details on how such mapping is constructed.
4 computing precision
given an event log and a model, the technique described in the previous sec-
tion provides a set of optimal alignments for each trace in the log. this section
presents a technique to compute precision based on the use of these optimal
alignments per trace. the technique considers 'one' or 'all' optimal alignments,
and is based on the methods described in [24{26]. however, there is a funda-
mental dierence: whereas in [24{26] precision is measured based on log-based
model replay, the approach in this section is based on alignments [9]. the
advantages are manifold. first of all, traces in the log do not need to be com-
pletely tting. in [24{26] the non-tting parts are simply ignored. for most
real-life situations, this implies that only a fraction of the event log can be used
for computing precision. second, the existence of indeterminism in the model
poses no problems when using the alignments. in [24{26], ad-hoc heuristics
were used to deal with indeterminism. finally, the use of alignments instead
of log-based model replay improves the robustness of conformance checking.
the remainder of this section is devoted to explain how precision can be cal-
culated from the alignments.
precision is estimated by confronting model and log behavior: imprecisions
between the model and the log (i.e., situations where the model allows more
behavior than the one reected in the log) are detected by juxtaposing behavior
allowed by the log and the one allowed by the model. this juxtaposition is done
in terms of an automaton: rst, an automaton is built from the alignments.
then, the automaton is enhanced with behavioral information of the model.
finally, the enhanced automaton is used to compute the precision. in themeasuring precision of modeled behavior 9
l
trace freq (1)l()l
1=hai 1ha;f;g;hiha;f;g;hi
ha;c;b;ei
ha;c;b;di
ha;b;c;di
ha;b;c;ei
2=ha;b;c;di 1ha;b;c;diha;b;c;di
3=ha;c;b;ei 1ha;c;b;eiha;c;b;ei
4=ha;f;g;hi 1ha;f;g;hiha;f;g;hi
5=ha;b;i;b;c;di 1ha;b;i;b;c;diha;b;i;b;c;di
table 1: model perspective of the alignments ('one' and 'all') for the model in figure 2
and the log [ 1;2;3;4;5].
remainder of the section we will use the following running example: the model
shown in figure 2 and the log l= [1;2;3;4;5], containing the 5 traces
that appear in in table 1.
in order to build the automaton, log behavior must be determined in terms
of model perspective, i.e., we consider the optimal alignments ( 1or) of
each trace in the log for this purpose. for example, given the running example
logl= [1;2;3;4;5] and the model in figure 2, the trace 1has 5
optimal alignments, (1) =f7;8;9;10;11g, shown in figure 4. for this
example, we assume that the alignment assigned to 1by1based on an
external criterion corresponds to 7, i.e.,1(1) =7. on the other hand,
traces2::: 5are perfectly tting, and therefore, each trace has only one
optimal alignment containing only synchronous moves. in particular, given an
alignment, in order to build the automaton, we only consider the projection
of model moves, i.e., (). table 1 shows all the projection of model moves
for the alignments of log l= [1;2;3;4;5]. we use (1)land()l
to denote the application of function on all the alignments provided by
the functions 1andrespectively for the traces in log l. we can omit
the subindex lwhenever the context is clear. note that, by denition, any
alignment projection () is a valid complete activity sequence of the model.
using1(or), the automaton is built considering all the prexes for
the sequences in (1) (or ()) as the states. for instance, given a sequence
ha;b;c;diresulting of (1)(2), the states considered are ,hai,ha;bi,ha;b;ci
andha;b;c;di. formally, the alignment automaton aa= (q;;;;! ) is de-
ned such that:
{the set of statesqcorresponds to all prexes.
{the set of labelscorresponds to the activities.
{the arcs:q!qdene the concatenation between prexes and
activities, e.g., states ha;b;ciandha;b;c;diare connected by arc labeled d.
{the state corresponding with the empty sequence is the initial state.
{the function !:q!irdetermines the weight of each state according to
its importance for the precision computation.10 adriansyah, munoz-gama, carmona, van dongen and van der aalst
2f
ci
e i
i
i5 5 1 1
11 1 1 1
1
1
2 2 2a cb
f
ghb
ed
ci b c d
e
d
a ac acb ab 
abcd 
abc 
acbe 
afgh afg af abi abib abibc abibcd 
legend 
imprecision 
state <label>
fig. 5: automaton using 1and the model of figure 2.
aac ab 
af acb abc 
afg abi
acbd abce 
afgh abib 
abcd 
acbe abibc abibcd 
2.4f
ci
ei
i
i55 1.4 1.4
1.20.21 1 1 1
1.4
0.21.2
1.2 1.21.2a cb
fg hbd
ed
ecib c d
legend 
imprecision 
state <label>
fig. 6: automaton using and the model of figure 2.
figures 5 and 6 show the resulting automata for the model in figure 2 and
loglusing the functions 1andrespectively.3function!is represented
as the number in the states of the gures: informally, !(s) represents the
importance (frequency, but also alignment variation, as explained below) of
states. for instance, given the automaton of 1(figure 5), the state hai
must have more weight than the state ha;cibecause there are more traces
with prexhai(all 5 sequences of (1)) than the ones with prex ha;ci(only
ha;c;b;ei). a naive approach for dening the !function would be to split
equally the importance of the process among all the alignment projections.
this naive approach is valid for the automaton for 1, since each trace in the
log has just one alignment associated. however, in the case of the automaton
for, this naive approach will be biased, giving more importance to those
log traces with more optimal alignments.
3for the sake of readability, in the gures, we use the label abcas an abuse of notation
for referring to the sequence ha;b;ci.measuring precision of modeled behavior 11
hence we propose the !function to distinguish the two situations that arise
regarding the alignments used. let us rst dene the !function for alignment
depending of the alignment automaton used:
{case1: letmbe a model, let lbe an event log, let l2lbe a trace
inl, letl(l) be the frequency of l, and let=1(l) be the optimal
alignment between landmobtained by 1. the weight of is dened
as:!() =l(l), i.e., the weight is directly related with the frequency of
the trace. for instance, given that all traces in the log of table 1 have a
frequency of 1, the weight of alignment 1(5) is 1 (the same for the rest
of alignments of 1).
{case: letmbe a model, let lbe an event log, let l2lbe a trace
inl, letl(l) be the frequency of l, and let2(l) be one of
the optimal alignments between landm. the weight of is dened
as!() =l(l)1=j(l)j, i.e., the weight is split equally among all
the alignments of the log trace, taking into account the frequency of the
trace within the log. for instance, the weight of alignment 9of trace1
is 11=5 = 0:2, while the weight of unique alignment of 5is 11=1 = 1.
once function !is dened for alignments in 1and, we dene it for a
prex (intermediate state) as follows: let sbe a state of the automaton, and let
be the sequences used to construct the automaton ( 1or). the weight
of statesis dened as
!(s) =x
82!() ifsis a prex of () (or 0 otherwise)
the weights of the states of gures 5 and 6 are shown next to the states.
for example, in figure 5, the state haiappears in all 5 sequences of (1), and
therefore, its weight is 5. in figure 6, the state ha;fiappear in model moves
projection of two alignments of (one with weight 0 :2 since the trace 1has
5 optimal alignments, and the other with weight 1). therefore, the weight of
stateha;fiis 1:2.
once the log behavior has been determined in terms of an automaton, the
confrontation with the actual model behavior is required in order to determine
the precision of the system. for each state of the automaton, we compute its
set of available actions , i.e., possible direct successor activities according to the
model (av), and then compare it with the set of executed actions , i.e., activities
really executed in the log ( ex). take for example state ha;b;ciof automaton
created using the function 1shown in figure 5, and the model in figure 2.
the set of executed actions of the state is ex(ha;b;ci) =fdg, i.e., for all traces
with prexha;b;ci, their direct successor is only d. the set of available actions
for the state is av(ha;b;ci) =fd;e;igbecause after performing the sequence of
activitiesha;b;ci, the model allows to do d;e;ori. note that, by construction
ex(s)av(s), i.e., the set of executed actions of a given state is always a
subset of all available actions according to the model.
the activities that are allowed according to the model, but do not occur in
the event log are used to collect the imprecisions of the system, i.e., an activity12 adriansyah, munoz-gama, carmona, van dongen and van der aalst
that escapes from the log behavior. these imprecisions are represented as small
lled states in the automaton in the gures. for example, the imprecisions of
the stateha;b;ciarefd;e;ignfdg=fe;ig. the computation and analysis of
these imprecisions are the cornerstone of the precision checking technique pre-
sented in this paper. all identied imprecisions can be analyzed and further
used to correct the model and make it more precise. furthermore, in order
to globally estimate precision, these imprecisions in turn are weighted. conse-
quently, we dene the align-precision ( ap)metric of a system represented by
the automaton aa= (q;;;;! ) as follows:
ap(aa) =p
s2q!(s)jex(s)j
p
s2q!(s)jav(s)j
for example, the precision for the automaton derived from 1shown in
figure 5 is 0 :79. the precision for the automaton of shown in figure 6 is
0:83.
the presented precision approach in this section relies on the concept of
alignments. alignments are only dened for process models whose terminating
states are reachable from their initial states. a process model whose termina-
tion state is not reachable from its initial state does not have any sequence of
activities that leads to proper termination. thus, the approach in this paper is
limited to process models whose proper terminations are reachable from their
initial states.
in practice, process models may have tasks whose execution are not logged
or simply not labeled with any activity, i.e., invisible tasks. furthermore, some
tasks may have the same activity label, i.e., duplicate tasks. both invisible and
duplicate tasks may inuence the behavior allowed by process models, there-
fore they need to be taken into account explicitly when measuring precision.
we use tasks in place of activities when measuring precision of models with
duplicate/invisible tasks, i.e., given a log and a model with duplicate/invisible
tasks,apis computed by taking into account tasks that are executed in the
log (obtained from alignments between traces in the log and the model) and
possible direct successor tasks according to the model. furthermore, although
all models in this paper are shown as petri nets, the approach is extendable
to all process models for which translations to petri nets are available, such
as bpmn [17], yawl [21], and causal nets [3].
5 extensions of the precision metric
the approach presented in section 4 uses the prex of complete activity se-
quences to represent states of the automaton. this implies that given a com-
plete activity sequence , other sequences with slightly dierent permutation
of activities are placed in dierent branches of constructed automaton than
than. given a process model that allows many possible interleaving of ac-
tivities, and an event log, the approach can only provide a perfect precisionmeasuring precision of modeled behavior 13
abcdefghi
abdcefhgi
acbdegfhi
acdbeghfi
adbcehfgi
adcbehgfi1
1
1
1
1
1trace frequency 
6 62 1 1
a cc
aab abc abcd 
legend 
imprecision 
state <label>abcde abcdef abcdefg 1 1 1
d e f g
21 1
bac acb acbd acbde acbdeg acbdegf 1 1 1
d e g f
1 1
acd acdb acdbe acdbeg acdbegh 1 1 1
b e g hbabcdefgh abcdefghi1 1h i1 1
abd abdc abdce abdcef abdcefh 1 1 1
c e f h
abdcefhg abdcefhgi1 1g i
acbdegfh acbdegfhi1 1h i
acdbeghf acdbeghfi1 1f id
d21 1
bad adb adbc adbce adbceh adbcehf 1 1 1
c e h f
adbcehfg adbcehfgi1 1g id
1 1
adc adcb adcbe adcbeh adcbehg 1 1 1
b e h g
adcbehgf adcbehgfi1 1f icg
hg
g
hh
f
h
f
hh
f
f
gg
f
gfstart end ab
c
degf
hievent log process model 
automata 
fig. 7: example of and event log and a process model that allows the interleaving of several
activities. precision of the model using the approach in [9] is less than perfect although all
interleaving of activity b;c;d andf;g;h appear in the log.
value if all permutations of the interleaving activities are observed in the log.
this requirement may be too restrictive in some cases.
take for example the process model and the log shown in figure 7. the
model allows for the interleaved execution of b,candd. this behavior is also
reected in the log, containing all possible permutations of b,candd. the
model also allows the interleaving of f,gandh, and all possible permutations
off,gandhare also contained in the log. one may expect a perfect precision of
1 for such model and log. however, given the presented approach, the precision
is 0:8. the automaton of figure 7 shows the imprecisions detected. notice
that prexha;b;ciof traceha;b;c;d;e;f;g;h;i iand prexha;c;biof trace
ha;c;b;d;e;g;f;h;i imanifests as two dierent states even when the executed
activities and their frequency in both prexes are the same. for the given
example, the minimum number of traces necessary to reach a precision of
1 is 36. this number increases exponentially with the increasing degree of
concurrency of the considered model. in such cases, some level of abstraction
in the way states are represented is desirable.
in section 4 we show that dierent ways of aligning traces of event logs to
process models (i.e., using 1 optimal alignment or all optimal alignments per
trace) may also inuence precision. while computing 1 optimal alignment is
computationally less expensive than computing all optimal alignments, it only14 adriansyah, munoz-gama, carmona, van dongen and van der aalst
provides approximations of the precision value without much more diagnostics
information that can be exploited to obtain insights into precision. represen-
tative alignments may oer a better degree of trade-o between measurement
accuracy, additional insights into precision, and computation time.
finally, other than the way states are represented, the direction for which
the automaton is constructed may also inuence precision measurement. most
of the existing approaches, e.g., [9, 24], construct an automaton from the be-
ginning of the traces forward. thus, choices that are made in the beginning
of traces may have bigger inuence on precision value than choices that are
made towards the end of traces.
in this section we present three extensions of the technique presented in
section 4:
{dierent state representations that do not take into account ordering of
activities to deal with the possible incompleteness of the log (section 5.1),
{using representative alignments to get better trade-o between measure-
ment accuracy and computation time (section 5.2), and
{dierent directions to construct automaton to deal with the possible bias
produced by the direction used to compute precision (section 5.3)
5.1 abstraction on the state representation
in [6], the states of an event log can be obtained by taking the set, multi-
set, and sequence of activities. to measure precision, we propose two possible
state representations that can be chosen depending on the desired level of
abstractions:
{ordered : a state is a sequence of activities. this is the same representation
as the one used in [9,24{26]. for example, the states for prex ha;b;ciand
ha;c;biin figure 7 are dierent.
{unordered : a state is a multi-set of activities, i.e., the order among tasks
does not matter, but the number of executions of each task does. for exam-
ple, the states for ha;b;ciandha;c;biare the same, i.e., [ a;b;c ]. however,
the states forha;b;iiandha;b;i;biare not the same, i.e., [ a;b;i ] and [a;b2;i]
respectively, because frequency matters.
figures 8 and 9 show the automata for the running example of section
4, considering the unordered state representation. these automata contain
dierences with respect to their ordered homologous (figures 5 and 6). for
example, instead of having two states ha;b;ciandha;c;bifor prexesha;b;ci
andha;c;bi, both prexes are now represented as a single state [ a;b;c ]. this
representation reduces the number of imprecisions and hence increases pre-
cision values. using unordered state representation and precision calculation
as explained in section 4, the model in figure 7 has a precision value of 1
(perfect). it is worth mention that in [6], the authors also propose the use of
setas state representation. however, this is not applicable to our case: unlikemeasuring precision of modeled behavior 15
[a][a,c][a,b]
[a,f][a,b,c]
[a,f,g][a,b,i]
[a,f,g,h][a,b2,i]
[a,b,c,e][a,b2,i,c][a,b2,i,c,d]
2f
ci
ei
i5 5 1 2
11 1 1 1
2 2 2a cb
f g hb
ecib c d
[a,b,c,d]d1
legend 
imprecision 
state <label>
fig. 8: automaton using 1(unordered state representation), and the model of figure 2.
[a][a,c][a,b]
[a,f][a,b,c]
[a,f,g][a,b,i]
[a,f,g,h][a,b2,i]
[a,b,c,e][a,b2,i,c][a,b2,i,c,d]
2.4f
ci
ei
i5 5 1.4 2.8
1.41 1 1 1
1.2 1.2 1.2a cb
f g hb
ecib c d
[a,b,c,d]d1.4
legend 
imprecision 
state <label>
fig. 9: automaton using (unordered state representation) and the model of figure 2.
sequence or multiset, a set does not preserve the number of activities executed,
and therefore, it may represent a (possible innite) number of dierent model
states. for example, given the model in figure 2, the set fa;b;igrepresents
ha;b;ii,ha;b;i;bi,ha;b;i;b;ii, . . . . the idea of using the state representation of
an aligned trace to measure precision is also introduced in [4], where precision
is measured after representing the states of traces to the states of the models
constructed with an ordered representation (i.e., sequence). however, similar
to [9], the metric values are highly inuenced by choices that are made in the
beginning of the trace rather than the one that are made towards the end of
the trace.
5.2 representative alignment
given a trace and a process model, provides all optimal alignments. how-
ever, as shown in [9], it is an expensive option in terms of computation time.
the use of only one alignment per trace (i.e., 1) solves this issue in cases
where time is a priority, but may sacrice accuracy. as a trade-o between
time and accuracy, in this paper we propose precision measurement based on
representatives of all optimal alignments (see section 3). in this section, we
revisit the precision measurement to include this notion.
figure 10 shows the model moves projection of the representatives of all
optimal alignments ( (r)) for the running example shown previously in sec-
tion 4. the construction of the automaton is dened identically as in the
presented approach, with only one dierence: the weight function of the align-
ments. let lbe a trace of log l, letl(l) be the frequency of l, let16 adriansyah, munoz-gama, carmona, van dongen and van der aalst
examination 
radiology therapy 
update record 
allergy test chemotherapy post-chemo home care operation 
p0p1
p3
p2
p4p5
p6 p7a b
cd
ei
f g hrepresentatives process 
model 
fig. 10: process model, traces, and representatives of all optimal alignments of all traces.
aac ab 
af acb abc 
afg abi
acbd 
afgh abib 
abcd 
acbe abibc abibcd 
2f
ci
e i
i
i5 5 1.8 1.8
1.40.41 1 1 1
1
1
1.2 1.2 1.2a cb
f ghbd
ed
cib c d
e
legend 
imprecision 
state <label>
fig. 11: automaton using r(ordered state representation) and the model of figure 2.
mbe a model, and let 2r(l) be a representative alignment for trace
l. in such case, the weight of the alignment !() needs to be proportional
to the number of alignments represented by , i.e.,rep(). thus, we dene
!() =l(l)rep()=p
02r(l)rep(0). for instance, given the trace 1in
figure 10, let 1be the representative alignment such that (1) =ha;c;b;di.
the number of alignments represented by 1isrep(1) = 2. the total number
of optimal alignments represented by the representative alignments associated
with1isp
02r(1)rep(0) = 5. hence, the weight !(1) = 12=5 = 0:4. as
another example in figure 10, let 2be the only representative alignment asso-
ciated with 5, such that (2) =ha;b;i;b;c;di. the representative alignment
2represents 1 optimal alignment. since the number of all optimal alignments
represented isp
02r(5)rep(0) = 1, the weight of 2is!(2) = 11=1 = 1.
figures 11 and 12 reect the automata for the running example of the
previous section, when representative alignments and dierent state represen-
tations are used.
note that there can be more than one ways to compute representative
alignments from a given model and a trace. given an event log and a model,
the selection of representative alignments between each trace in the log and
the model obviously inuences the automata that can be constructed between
the log and the model.measuring precision of modeled behavior 17
[a][a,c][a,b]
[a,f][a,b,c]
[a,f,g][a,b,i]
[a,f,g,h][a,b2,i]
[a,b,c,e][a,b2,i,c][a,b2,i,c,d]
2f
ci
ei
i5 5 1.8 2.8
1.41 1 1 1
1.2 1.2 1.2a cb
f g hb
ecib c d
[a,b,c,d]d1.4
legend 
imprecision 
state <label>
fig. 12: automaton using r(unordered state representation) and the model of figure 2.
5.3 forward and backward precision
in the approach presented in section 4, the prexes of the complete activity
sequences are used to build the automaton. for example, given a complete
activity sequence ha;b;c;di, the states constructed from the sequence are the
empty sequence (corresponding with ha;b;c;di, whereindicates a point of
interest in the sequence), hai(forhab;c;di),ha;bi(forha;bc;di),ha;b;ci
(forha;b;cdi) and nallyha;b;c;di(forha;b;c;di). in other words, only
the activities in the past are used and we move forward on the complete
activity sequences. this approach is used by all existing precision checking
techniques [24{26].
in [6], the authors show that any point in the sequence (represented as
) may represent two complementary visions: the past activities seen until
that point (as it has been shown above), but also the future activities to
come until the ending of the case. for instance, given ha;bc;di,ha;biare
the activities occurred, while hc;diare the activities to happen. both ha;bi
andhc;diare used in [6] as two dierent states that can be derived from the
same point in the sequence. in this section, we use the same idea to present
abackward precision measurement, that complements the forward approach
presented before. the combination of both metrics will lead to a measurement
unbiased by the direction of the precision checking. for the sake of clarity we
will use ordered state representation to illustrate the remainder of the section,
although the analogous procedure is applicable for unordered representation.
letbe the option chosen to compute precision, i.e., 1,orr. in order
to build the automaton for the backward precision measurement, we consider
the prexes of the reversed complete activity sequences in (). in other words,
given () =ha;b;c;diof the alignment 2, we use 0() =hd;c;b;aito
determine the states, resulting in the following 5 states: (corresponding with
hd;c;b;ai),hdi(forhdc;b;ai),hd;ci(forhd;cb;ai),hd;c;bi(forhd;c;b
ai) and nallyhd;c;b;ai(forhd;c;b;ai). analogously, the set of complete
activity sequences of mis also reversed.4the rest of the precision checking is
performed as it is described in section 4.
4notice that, for the case of petri nets with one unique initial and nal markings, the
set of all reversed complete activity sequences can be generated by simulating the behavior
of a net obtained from the original net by reversing its arcs and swapping their initial with
nal marking.18 adriansyah, munoz-gama, carmona, van dongen and van der aalst
d dc dcb b a
1 1 1 1c bdcba 
1aa
b
da ab abc b
ca
b
1 1 1 1a b cabcd
1da
ca
bc d
model and automaton reversed model and automaton 
start end a
bc dstart end 
fig. 13: example of model and resulting automaton for both forward and backwards ap-
proaches.
figure 13 shows an example of two automata constructed by moving in
forward direction (left) and by moving backward (right). notice the dierence
of identied imprecisions shown by the two automata. finally, precision values
obtained using forward and backward-constructed automaton can be combined
(e.g., the average), resulting in a balanced precision metric unbiased by the
direction of the automaton constructed. note that more sophisticated and ex-
ible combinations of both metrics are also possible. in section 6, we investigate
the dierences in precision values produced by the various approaches using a
variety of even logs and models.
6 experiments
we have implemented the proposed precision calculation as a prom 6 plugin
named \check precision based on align-etconformance" in the \etconfor-
mance" package, publicly available from www.processmining.org . we used
it to perform a range of experiments to test the robustness of our proposed
approach using both synthetic and real-life models (petri nets) and logs.
6.1 evaluating unidimensionality of metrics
the rst set of experiments was performed to evaluate the precision measure-
ments provided by the proposed metrics. in particular, we measured whether
the proposed precision metrics are unidimensional [33], i.e., not sensitive to
non-ttingness of event logs. we measured precision between various logs and
models whose expected values are known. furthermore, we compared the val-
ues obtained against existing state-of-the-art metrics for precision: etcp[24],
behavioral precision [34], and weighted behavioral precision [12].
by combining the models and log in figure 1 in various ways, we created
new models whose expected precision values are between the two extremes.
two models were combined by merging the end place of one with the initially
marked place of another. the merged models were named according to the
name of their original models, e.g., pfmodel is the result of merging the
end place of pwith the initially marked place of f. the activity names in
the original models and logs were renamed before the models and logs weremeasuring precision of modeled behavior 19
fig. 14: precision values of the logs/models in figure 1 and their combinations provided
by alignment-based approach (i.e., computed using all optimal alignments, ordered, and
forward-constructed automata). if all behavior are observed in the original logs, all mea-
surements are insensitive to non-tting traces.
merged such that the original models and logs can be easily distinguished
from the merged results. precision values were measured 30 times using 30
event logs, each consists of 5,000 traces, generated by simulating the precise
model (i.e., pp). for sake of completeness, we also measured the precision
of the overtting model ( p) and the ower model ( f) using 30 logs of 5,000
traces generated by simulating the pmodel. this way, each log contains all
the possible behavior of the model that generates it (i.e., all directly follow
relations between two activities that are allowed according to the model are
recorded in the log).
the top part of figure 14 shows the alignment-based precision values, mea-
sured using all optimal alignments per trace of the logs. the experiment with
one and representative alignments per trace yields identical results. this re-
sult shows that by observing suciently enough behavior in the event logs,
all alignment-based metrics provide similar intuition about precision of mod-
els, i.e., overtting models have high precision values and \ower" models have
low precision values. note that there are slight dierences between various con-
gurations of metrics, i.e., states (ordered/unordered) and forward/backward
constructed automata.
to evaluate the robustness of the metrics against non-tting logs, we took
the models and logs from the previous experiments and created untting logs
by removing nrandom events per trace from the tting logs. to ensure that the
logs are untting, only activities that belong to the precise part (i.e., mapped
toppart) are removed. furthermore, the measurements are compared against
existing metrics. we use the cobefra tool [13] to measure behavioral precision
[34] and weighted behavioral precision [12]) and use prom 6 to measure etcp.
the bottom part of figure 14, figures 15{16, and table 2 show some of the
results.20 adriansyah, munoz-gama, carmona, van dongen and van der aalst
fig. 15: comparison between precision values obtained using alignment-based approach
(i.e., computed using all optimal alignments, ordered, and forward-constructed automata)
and other metrics ( etcp[24], behavioral precision [34], and weighted behavioral precision
[12]). only the alignment-based approach is not sensitive to non-tting logs/models.
the bottom part of figure 14 shows that the metrics proposed in this paper
are robust to tness problems. even in cases where almost half of the events
in all traces are removed, all alignment-based metrics provide similar value as
the ones provided for perfectly tting traces. figure 15 shows a comparison
between the precision values provided by alignment-based metrics and other
existing metrics. for readability, we only show one alignment-based metric: the
one computed using all-optimal alignments and forward-constructed automata
whose states are constructed by taking into account activity ordering. note
that in cases where logs are perfectly tting the models, all metrics provide
similar precision intuition. in fact, the alignment-based precision values shown
in figure 15 are the same as the etcpvalues. however, in cases where logs are
non-tting, other metrics may show misleading precision insights. the etcp
metric provides low precision for model pfwith respect to perfectly tting
logs (i.e., 0.25). however, the value rises to 0.82 when 3 events are removed
from the logs, because for all non-tting traces it ignores the rest of the traces
after the rst non-tting event occur. similarly, both weighted and unweighted
behavioral precision metrics provide lower precision values for non-tting logs
than the ones provided for perfectly tting logs. even for overly tting models
pandpp, both metrics provide precision values below half (i.e., indicating the
models are imprecise). this occurs because both metrics mixed both perfectly-
tting and non-tting traces in construction of articial negative events, which
leads to misleading construction of articial negative events.
figure 16 shows the inuence of noise by removing some events in the logs.
as shown in the gure, other than the alignment-based precision metric, pre-
cision values of all metrics may change signicantly even with only one event
removed from all traces. due to the randomness of the location of removed
events, the etcpmetric may both increases or decreases with the presence of
non-tting traces. both weighted and unweighted behavioral precision metrics
decreases when more events are removed because incorrect articial negative
events are introduced. note that the number of negative events tends to de-
crease when traces in the log gets more vary because of the removal of events.
the set of experiments also shows some interesting insights into dierences
between alignment-based metrics. table 2 reports the results for model pf. inmeasuring precision of modeled behavior 21
fig. 16: precision values of dierent metrics for perfectly tting logs and non-tting logs
created by removing some events in the logs. only the alignment-based approach metric
(i.e., computed using all optimal alignments, ordered, and forward-constructed automata)
is insensitive to non-tting logs.
table 2: precision values of the pfmodel, measured using dierent state representations
(ordered/unordered) and direction (forward/backward). if all behavior are observed, both
1-alignment and representative alignment provide good approximation of all-alignments.
automata construction direction
forward backward combined
#removed 0 1 2 3 0 1 2 3 0 1 2 3
ord. one 0.25 0.24 0.24 0.24 0.19 0.19 0.19 0.18 0.22 0.22 0.21 0.21
rep 0.25 0.25 0.24 0.24 0.19 0.19 0.19 0.19 0.22 0.22 0.22 0.21
all 0.25 0.25 0.24 0.24 0.19 0.19 0.19 0.19 0.22 0.22 0.22 0.21
unord. one 0.26 0.25 0.25 0.25 0.19 0.19 0.19 0.18 0.22 0.22 0.22 0.22
rep 0.26 0.26 0.25 0.25 0.19 0.19 0.19 0.19 0.22 0.22 0.22 0.22
all 0.26 0.25 0.25 0.25 0.19 0.19 0.19 0.19 0.22 0.22 0.22 0.22
legend
ord./unord : ordered/unordered state representations
one/rep/all : one/representative/all alignments
cases where the whole behavior is recorded in event logs, precision values only
depend on the state representation of the automaton (ordered/non-ordered)
and the direction for the automata construction. when all possible behavior
are observed, the automata constructed using 1-alignment and all-alignments
per trace are identical. similar results are obtained from the experiments using
the other models ( p,f,fp,pp,ff ). table 2 shows slight dierences between
precision values that are measured using dierent state representations or dif-
ferent directions in the automata construction.
figure 17 shows a comparison between precision values provided by the two
metrics for models pfandfp. as shown in the gure, precision values of
alignment-based metrics provided by forward-constructed automata for model
pfis higher than the values provided by backward-constructed automata for
the same model, regardless of the noise level and the state representation (or-
dered/unordered). in contrast, the values provided by the latter is higher than
the former for the fpmodel. this shows that the position of the precise part
of the models inuences precision values. precision values are higher when the
direction of constructed automata starts with precise part of process mod-
els. in this case, we clearly see the inuence of forward/backward direction
of constructed automata to precision values. to balance the inuence, one of
the simplest way is to take the average between the values provided by both22 adriansyah, munoz-gama, carmona, van dongen and van der aalst
fig. 17: precision values of the pfandfpusing all-alignments per trace, with dierent
state representations (ordered/non-ordered) and direction (forward/backward). higher pre-
cision is obtained when the direction of automata construction starts with precise part of
the models.
a1
a2
an... b1
b2
bn... start end (i) (ii)‚Äúparallel ‚Äù model ‚Äúchoice ‚Äù model 
fig. 18: (i) a model that only allows one activity per trace, and (ii) a model that allows
interleaving between all activities.
directions. figure 17 shows that the precision values obtained by combining
both values are almost similar between model pfandfp.
in this section, non-tting logs are created by removing activities randomly.
given a process model and a tting trace, there are other ways to make the
trace non-tting, such as swapping some activities and add extra activities to
the trace randomly. regardless of the approach to introduce noise, an optimal
alignment between a non-tting trace and the model provides a good \guess" of
a complete activity sequences allowed by the model that should have occurred
instead of the trace. this way, precision is measured independently from other
conformance metrics, i.e., the tness metric. other approaches investigated in
this section do not explicitly handle such non-ttingness. hence, they are not
unidimensional and may yield misleading results as shown by the experiment
results.
6.2 observed behavior requirements
the second set of experiments were conducted to investigate how much behav-
ior must be observed in the event logs in order to measure perfect precision
accurately. we use two models that, despite having the same number of activ-
ities, have totally dierent number of complete activity sequences. the rst
model only allows choice among activities (i.e., is named \choice" model)
and the second model allows the interleaving of all activities (i.e., is named
\parallel" model) (see figure 18). for our experiments, we used models that
consist of 9 activities (with invisible task \start" and \end" for the \parallel"
model).measuring precision of modeled behavior 23
fig. 19: alignment-based precision values for \parallel" ,\choice" ,\parallel-
parallel" , and \choice-choice" models. the values provided using unordered represen-
tation of states automata provide perfect precision without having to observe all interleaving
behavior. missing values on weighted/unweighted behavioral precision indicate that no result
was obtained after 1 hour computation.
similar to the set of experiments in section 6.1, we randomly generated
perfectly tting logs for both models with various number of traces per log
and then measured their precision values. experiments are repeated 30 times
for each combination of models and number of traces per log. we conducted
the same experiments with models constructed by merging the two models in
various order ( \choice-choice" ,\choice-parallel" ,\parallel-choice" ,
\parallel-parallel" ). the results of the experiments are shown in figure 19
and figure 20.
both figure 19 and figure 20 reveal that even if logs are generated from
models, all alignment-metrics require some degree of log completeness before
they provide perfect precision value of 1.00. as expected, a perfect precision
value for a \choice" and a \choice-choice" models can be obtained after
observing much fewer traces than the ones required to obtain the same preci-
sion value for both \parallel" and\parallel-parallel" models. in theory,
the minimum number of traces in an event log required to see all possible be-
havior of a \choice" model with 9 activities is 9, while the minimum number
of traces to see all possible interleaving of activities in a \parallel" model
is 9! = 362;880 traces. in all experiments, alignment-based precision metrics
with unordered automata state representation provide perfect precision val-
ues with less number of observed traces than the one with ordered automata.
this shows that in conditions where not all behavior are observed in event
logs, precision values computed using unordered automata state representa-
tion provides an upper-bound for the ones computed using ordered automata.
the gure also shows that in all experiments, the etcpvalues are the same as
the alignment-based precision values computed using ordered automata state
representation because all traces perfectly t their models. interestingly, in the
experiments with model \choice" and\choice-choice" , both the weighted
and unweighted behavioral precision metrics provide a perfect value (1.00) for
logs with only one trace but provide very low values (below 0.2) for other
logs that contain more than one trace (i.e., logs with 10, 100, 1,000, to 5,000
traces). the reason the (un)weighted behavioral precision values is so high is
that the articial negative events construction only take into account logged
activities. when an activity in a trace of the logs is replayed to construct ar-24 adriansyah, munoz-gama, carmona, van dongen and van der aalst
fig. 20: precision values of models with combination of choice and parallel control-ow
patterns. higher precision values are obtained when automata are constructed from the
direction where the parallel part of the models exists (the rst three gures). missing values
indicate that no result was obtained after 1 hour computation.
ticial negative events, other than the logged activity both models allow only
unlogged activities (invisible tasks). thus, no negative articial events were
constructed and therefore the precision of the models with respect to the logs
are 1.00. furthermore, the results also show that the time spent to compute
alignment-based metrics is not necessarily higher than the time required to
compute other existing metrics such as the (un)weighted behavioral precision.
in some of the experiments with models \parallel" and\parallel-parallel" ,
no result was obtained after 1 hour computation for (un)weighted behavioral
precision while the alignment-based precision metrics were computed in less
than 1 minute for each pair of model and log.
figure 20 shows the precision values obtained from experiments with mod-
els\choice-parallel" and\parallel-choice" . interestingly, the results of
the experiment with \choice-parallel" model performed using forward au-
tomata construction (i.e., top-left-most of figure 20) is identical to the one
given by the experiment with \parallel-choice" model using backward au-
tomata construction (bottom-second from left of figure 20). similarly, the
results of experiment with \parallel-choice" model performed using for-
ward automata construction (i.e., bottom-left of figure 20) is identical to
the one given by the experiment with \choice-parallel" model using back-
ward automata construction (top-second from left of figure 20). these re-
sults show that precision values are inuenced by the location of parallel-
choice constructs: precision values are higher when automata are constructed
from the direction where parallel construction lies. the combined precision
value computed by averaging the precision values obtained from both forward
and backward-constructed automata is less inuenced by such construction
as shown in the third gures from the left side of figure 20. as shown in
the gures, the measured precision values for both \choice-parallel" andmeasuring precision of modeled behavior 25
table 3: real-life logs and models used for experiments
log #cases #events process model #deviation/trace
#place #trans
bouw-1 139 3,364 33 34 9.75
bouw-4 109 2,331 31 31 7.27
mlog1 3,181 20,491 15 12 5.33
mlog2 1,861 15,708 16 19 1.45
mlog3 10,271 85,548 24 21 14.50
mlog4 4,852 29,737 16 27 2.09
mlog5 25,846 141,755 14 24 1.21
isalalog 77 459 26 39 0.68
fig. 21: precision values of real-life logs and models. only the 1-alignment approach man-
ages to provide precision results for all logs/models.
\parallel-choice" models using the combined precision values are identical.
none of non-alignment-based approaches in this set of experiments managed
to provide perfect precision values. note that no result was obtained after 1
hour of computation for both weighted and unweighted behavioral precision
metric calculations and logs of size of 1,000 traces and larger.
6.3 real-life logs and models
to evaluate the applicability of the approach to handle real life logs, we used
8 pairs of process models and logs from two dierent domains (see table 3),
where 7 logs and models were obtained from municipalities in the netherlands.
in particular, we took the collections of logs and models from the coselog
project [1,15]. the remaining pair of log and model is obtained from a hospi-
tal in the netherlands5. the logs and models from municipalities are related
to dierent types of building permission applications, while the hospital log
is related to patient handling procedure. all processes have unlogged tasks,
and some of the models allow loops. table 3 shows an overview of the logs
and models used in the experiments. #deviations/trace column indicates the
number of asynchronous moves after aligning all traces in the logs with their
corresponding models. as shown in table 3, all logs are not perfectly tting to
the corresponding models. we measure the precision values for all logs and the
computation time required. the results are shown in figure 21 and figure 22.
5seehttp://www.healthcare-analytics-process-mining.org/26 adriansyah, munoz-gama, carmona, van dongen and van der aalst
fig. 22: computation time comparison of alignment-based precision measurement using
combined values (from backward and forward automata construction). y-axis values are
shown in a logarithmic scale.
figure 21 reports the precision values obtained for real-life logs and models.
only the approach based on 1-alignment provides precision values for all real-
life logs and models in the experiments. the approach based on all-optimal
alignments per trace had out-of-memory problems when dealing with relatively
complex process models and logs such as \bouw-1" (33 places, 34 transitions),
\bouw-4" (31 places, 31 transitions), and \mlog-3" (24 places, 21 transi-
tions). precision measurements based on representative of optimal alignments
also had the same problems dealing with the hospital log (i.e., \isalalog").
although the model of the log is relatively small, it contains many unlogged
tasks (tasks whose execution are not logged), allows loops, and allow many
interleaving activities such that the size of state space required to compute
even representative of all optimal alignments is large and does not t memory.
nevertheless, notice the similarity of the computed precision values using
all three alignments (1-align, all-align, and representatives). from all pairs of
logs and models, only 2 of them have precision value below 0.7. this shows that
in reality, process models are made to be relatively precise such that meaning-
ful insights into the process can be obtained. interestingly, dierent precision
values are provided by dierent metrics in the experiment with log and model
\bouw-4" when both one and representative alignments are used. the preci-
sion value provided by ordered-forward metric for the model is around 0.44
(showing imprecision) while the unordered-backward precision metric provides
a value of 0.7 (i.e., precise). as discussed in section 6.1 and section 6.2, this
indicates that more observations are required to measure the particular log
and model accurately.
figure 22 reports the computation time required to measure precision of
real-life logs and models using the alignment-based approach with combined
precision values between forward and backward-constructed automata. the
y-axis of the charts are shown in logarithmic scale. as shown in the gure, the
computation time of precision measurement with all-alignments takes much
longer than the ones required by one or representative alignments. all mea-
surements using 1-alignment/representative alignments were computed in less
than 10 seconds. notice the similarity between the left and right graph on
the gure (except the isalalog that has out-of-memory problem in the ap-
proach with representative alignments). in fact, we obtained identical resultsmeasuring precision of modeled behavior 27
table 4: representative optimal alignments in real-life logs
log#opt. alignments #opt. alignments #representatives
(lower bound) represented per trace
min max avg min max min max avg
bouw-1 1 4,096 69.41 1 4,096 1 11.00
bouw-4 15,300,287 146,617.87 1 5,300,287 1 21.01
mlog1 1 1,844 74.24 1 976 1 21.00
mlog2 1 6 1.05 1 6 1 11.00
mlog3 1 136 13.95 1 84 1 21.12
mlog4 1 48 3.65 1 48 1 11.00
mlog5 1 54 3.46 1 54 1 21.00
fig. 23: precision values (left) and computation time (right) comparison between
alignment-based precision measurements and existing precision measurements using real-
life logs and models. y-axis values in the right chart are shown in a logarithmic scale.
missing values indicate that no result was obtained after 1 hour of computation
for all other combination of state representations (ordered/unordered) and di-
rections where automata is constructed (forward/backward). this shows that
the dierent directions of the automata construction and state representations
are not signicantly inuencing computation time. instead, most computation
time of precision measurement is spent in the alignment of logs and process
models. another interesting observation is that the time spent to compute rep-
resentative alignments are similar to the time spent to compute 1-alignment.
thus, we recorded the number of generated representatives for the experiments
and other statistics to investigate this. the results are shown in table 4.
table 4 shows that the average number of representatives per trace that
one can obtain using the extension of the a?algorithm from real-life logs
and models is close to one in all experiments (see #representatives per trace
column). this explains why the computation time between precision based
on 1-alignment is not much dierent than the one based on representatives.
interestingly, some traces in real-life logs have more than 5:3 million optimal
alignments (see log \bouw-4"). further investigations found that a trace with
so many optimal alignments is incomplete (only consists of one event) while its
model allows for many interleavings between activities. hence, there are many
possible activity interleavings that one can perform to complete the process
and construct an optimal alignment from the trace. the optimal alignment of
the same trace is also the one that represents more than 5:3 million optimal
alignments. this shows that it is also important to take into account tness
values before measuring precision. precision measurements that are based on
severely non-tting logs may be misleading.28 adriansyah, munoz-gama, carmona, van dongen and van der aalst
figure 23 shows a comparison of precision values and computation time
between alignment-based precisions (represented by the ones computed using
1-alignment per trace, unordered state representation, and averaging values
between forward-backward constructed automata) and other approaches. in
most cases, the alignment-based approach yields higher values than other ap-
proaches. the right-side of the gure shows that the computation time of
both weighted and unweighted behavioral precision is much higher than the
computation time of both the alignment-based precision and etcp.
7 conclusions
the quality of process models is often measured merely based on the propor-
tion of observed behavior in event logs that can be reproduced by the model
(i.e., tness). models that allow for much more behavior than the behavior
observed in event logs may provide misleading insights. many approaches to
quantify precision assume perfect tness, while this assumption is rarely be-
ing satised in practice. this results in unreliable precision measurements as
shown in this paper. therefore, we have developed an approach that rst aligns
an event log and a process model. this step is crucial to measure precision
more accurately, especially in those cases where the log is non-tting. the pre-
alignment of log and model makes it possible to explicitly identify deviations
and measure precision more accurately.
given a process model and an event log, we use an automata-based ap-
proach to measure precision. automata are mainly used as a means to jux-
tapose the behavior of the model with the behavior observed in the log. we
showed that the choice of state representation in the construction of the au-
tomata inuences the precision value obtained. as illustrated by our experi-
ments, a state representation that takes into account the ordering of activity
and not just the frequency requires much more observed behavior to provide
high precise value. in cases where the log is not complete (i.e., more behav-
ior in reality may occur than the behavior recorded in the log), the state
representation that ignores ordering can be used to provide an upper bound
for the precision value of the model. furthermore, we have identied several
behavioral properties of process models that may cause a biased precision
measurement depending on the choice of direction to construct automata. to
minimize such bias, we proposed average precision value between the automata
obtained using forward and backward directions.
computing all optimal alignments between a process model and an event
log is computationally expensive, being not feasible in practice. we showed
that precision values based on both 1-alignment and representative optimal
alignments are good approximation of the values obtained using the all-optimal
alignments approach. we also showed that the precision measurement based on
representative optimal alignments provides a trade-o between computation
time and metric quality, providing more diagnostics information (i.e., lower
bound of the number of optimal alignments). nevertheless, identifying the
\optimal" trade-o between computation time and rich diagnostic information
remains a challenge for practical cases.measuring precision of modeled behavior 29
we stress that precision alone is not sucient to determine the quality of
process model with respect to its observed behavior. other dimensions, such as
tness, generalization, and simplicity, must be considered altogether to provide
a comprehensive evaluation on how \good" is a model, given its executions.
references
1. van der aalst, w.: business process conguration in the cloud: how to support and
analyze multi-tenant processes? in: g. zavattaro, u. schreier, c. pautasso (eds.)
proceedings of the 9th ieee european conference on web services (ecows 2011),
pp. 3{10. ieee computer society press (2011)
2. van der aalst, w.: process mining: discovery, conformance and enhancement of busi-
ness processes. springer verlag (2011)
3. van der aalst, w., adriansyah, a., van dongen, b.: causal nets: a modeling lan-
guage tailored towards process discovery. in: proceedings of the 22nd international
conference on concurrency theory, concur'11, pp. 28{42. springer-verlag, berlin,
heidelberg (2011)
4. van der aalst, w., adriansyah, a., van dongen, b.: replaying history on process
models for conformance checking and performance analysis. wiley interdisciplinary
reviews: data mining and knowledge discovery 2(2), 182{192 (2012)
5. van der aalst, w., van hee, k.: workow management: models, methods, and systems.
mit press, cambridge, ma, usa (2004)
6. van der aalst, w., rubin, v., verbeek, h., van dongen, b., kindler, e., gunther, c.:
process mining: a two-step approach to balance between undertting and overtting.
software and system modeling 9(1), 87{111 (2010)
7. adriansyah, a., van dongen, b., van der aalst, w.: conformance checking using cost-
based fitness analysis. in: proceedings of the 2011 ieee 15th international enterprise
distributed object computing conference, helsinki, finland, edoc '11, pp. 55{64.
ieee computer society (2011)
8. adriansyah, a., van dongen, b., van der aalst, w.: memory-ecient alignment of
observed and modeled behavior. tech. rep. bpm-03-03, bpmcenter.org (2013)
9. adriansyah, a., munoz-gama, j., carmona, j., van dongen, b., van der aalst, w.:
alignment based precision checking. in: m.l. rosa, p. soer (eds.) business process
management workshops, lecture notes in business information processing , vol. 132,
pp. 137{149. springer berlin heidelberg (2013)
10. adriansyah, a., sidorova, n., van dongen, b.: cost-based fitness in conformance
checking. in: 11th international conference on application of concurrency to sys-
tem design (acsd), 2011, pp. 57{66 (2011)
11. banescu, s., zannone, n.: measuring privacy compliance with process specications. in:
proceedings of the 2011 third international workshop on security measurements and
metrics, metrisec '11, pp. 41{50. ieee computer society (2011)
12. vanden broucke, s., de weerdt, j., baesens, b., vanthienen, j.: improved articial
negative event generation to enhance process event logs. in: j. ralyt, x. franch,
s. brinkkemper, s. wrycza (eds.) advanced information systems engineering, lecture
notes in computer science , vol. 7328, pp. 254{269. springer berlin heidelberg (2012)
13. vanden broucke, s., de weerdt, j., vanthienen, j., baesens, b.: a comprehensive bench-
marking framework (cobefra) for conformance analysis between procedural process
models and event logs in prom. in: proceedings of the ieee symposium on compu-
tational intelligence and data mining, cidm 2013, part of the ieee symposium series
on computational intelligence 2013, ssci 2013 (2013)
14. buijs, j., van dongen, b., van der aalst, w.: on the role of fitness, precision, gener-
alization and simplicity in process discovery. in: r. meersman, h. panetto, t. dillon,
s. rinderle-ma, p. dadam, x. zhou, s. pearson, a. ferscha, s. bergamaschi, i. cruz
(eds.) on the move to meaningful internet systems: otm 2012, lecture notes in com-
puter science , vol. 7565, pp. 305{322. springer berlin heidelberg (2012)
15. buijs, j., van dongen, b., van der aalst, w.: towards cross-organizational process
mining in collections of process models and their executions. in: f. daniel, k. barkaoui,
s. dustdar (eds.) business process management workshops, lecture notes in business
information processing , vol. 100, pp. 2{13. springer berlin heidelberg (2012)30 adriansyah, munoz-gama, carmona, van dongen and van der aalst
16. cook, j., wolf, a.: software process validation: quantitatively measuring the corre-
spondence of a process to a model. acm transactions on software engineering and
methodology (tosem) 8, 147{176 (1999)
17. dijkman, r., dumas, m., ouyang, c.: semantics and analysis of business process
models in bpmn. information and software technology 50(12), 1281{1294 (2008)
18. dumas, m., rosa, m.l., mendling, j., reijers, h.: fundamentals of business process
management. springer (2013)
19. gerke, k., cardoso, j., claus, a.: measuring the compliance of processes with reference
models. in: proceedings of the confederated international conferences, coopis, doa,
is, and odbase 2009 on on the move to meaningful internet systems: part i, otm
'09, pp. 76{93. springer-verlag, berlin, heidelberg (2009)
20. greco, g., guzzo, a., pontieri, l., sacca, d.: discovering expressive process models by
clustering log traces. ieee trans. on knowl. and data eng. 18, 1010{1027 (2006)
21. hofstede, a., van der aalst, w., adams, m., russell, n.: modern business process
automation. springer-verlag (2010)
22. kristensen, l., schmidt, k., valmari, a.: question-guided stubborn set methods for
state properties. formal methods in system design 29(3), 215{251 (2006)
23. m.petkovic, prandi, d., zannone, n.: purpose control: did you process the data for
the intended purpose? in: w. jonker, m. petkovic (eds.) secure data management,
lecture notes in computer science , vol. 6933, pp. 145{168. springer (2011)
24. munoz-gama, j., carmona, j.: a fresh look at precision in process conformance.
in: proceedings of the 8th international conference on business process management,
bpm'10, pp. 211{226. springer-verlag, berlin, heidelberg (2010)
25. munoz-gama, j., carmona, j.: enhancing precision in process conformance: stability,
condence and severity. in: proceedings of the ieee symposium on computational
intelligence and data mining, cidm 2011, april 11-15, 2011, paris, france, pp. 184{
191. ieee (2011)
26. munoz-gama, j., carmona, j.: a general framework for precision checking. inter-
national journal of innovative computing, information and control (ijicic) 8(7(b)),
5317{5339 (2012)
27. murata, t.: petri nets: properties, analysis and applications. proceedings of the ieee
77(4), 541{580 (1989)
28. pande, p., neuman, r., cavanagh, r.: the six sigma way: how ge, motorola, and
other top companies are honing their performance. mcgraw-hill (2000)
29. porter, l., parker, a.: total quality managementthe critical success factors. total
quality management 4(1), 13{22 (1993)
30. rozinat, a., van der aalst, w.: conformance checking of processes based on monitor-
ing real behavior. information systems 33, 64{95 (2008)
31. rozinat, a., de jong, i., g unther, c., van der aalst, w.: process mining applied to
the test process of wafer steppers in asml. ieee transactions on systems, man and
cybernetics - part c 39, 474{479 (2009)
32. schmidt, k.: stubborn sets for standard properties. in: proceedings of the 20th interna-
tional conference on application and theory of petri nets, pp. 46{65. springer-verlag,
london, uk, uk (1999)
33. de weerdt, j., de backer, m., vanthienen, j., baesens, b.: a critical evaluation study of
model-log metrics in process discovery. in: m. muehlen, j. su (eds.) business process
management workshops, lecture notes in business information processing , vol. 66,
pp. 158{169. springer berlin heidelberg (2011)
34. de weerdt, j., de backer, m., vanthienen, j., baesens, b.: a robust f-measure for
evaluating discovered process models. in: ieee symposium series on computational
intelligence, pp. 148{155. ieee (2011)
35. weidlich, m., polyvyanyy, a., desai, n., mendling, j.: process compliance measure-
ment based on behavioural proles. in: proceedings of the 22nd international conference
on advanced information systems engineering, caise'10, pp. 499{514. springer-verlag,
berlin, heidelberg (2010)
36. weijters, a., van der aalst, w., de medeiros, a.a.: process mining with the heuristics
miner-algorithm. tech. rep., eindhoven university of technology, eindhoven (2006).
beta working paper series, wp 166