case handling: a new paradigm for
business process support
wil m.p. van der aalst1, mathias weske2, dolf gr ¨unbauer3
1dept. of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb eindhoven, the netherlands
e-mail:w.m.p.v.d.aalst@tm.tue.nl
2hasso plattner institute for software systems engineering
prof.-dr.-helmertstrasse 2-3, 14482 potsdam, germany
e-mail:weske@hpi.uni-potsdam.de
3pallas athena, p.o. box 747, nl-7300 as, apeldoorn, the netherlands
e-mail:dolf.grunbauer@pallas-athena.com
abstract
case handling is a new paradigm for supporting ﬂexible and knowledge intensive
business processes. it is strongly based on data as the typical product of these pro-cesses. unlike workﬂow management, which uses predeﬁned process control struc-
tures to determine what should be done during a workﬂow process, case handling
focuses on what canbe done to achieve a business goal. in case handling, the know-
ledge worker in charge of a particular case actively decides on how the goal of that
case is reached, and the role of a case handling system is assisting rather than guid-
ing her in doing so. in this paper, case handling is introduced as a new paradigm forsupporting ﬂexible business processes. it is motivated by comparing it to workﬂow
management as the traditional way to support business processes. the main entities
of case handling systems are identiﬁed and classiﬁed in a meta model. finally, thebasic functionality and usage of a case handling system is illustrated by an example.
key words : case handling, workﬂow management systems, adaptive workﬂow, ﬂexibil-
ity, business process management
1 introduction
1.1 context
during the last decade workﬂow management concepts and technology [6, 7, 21, 26,
31, 32, 35] have been applied in many enterprise information systems. workﬂow man-
agement systems such as staffware, ibm mqseries workﬂow, cosa, etc. offer genericmodeling and enactment capabilities for structured business processes. by making graph-
ical process deﬁnitions, i.e., models describing the life-cycle of a typical case or workﬂow
instance in isolation, one can conﬁgure these systems to support business processes. re-
cently, besides pure workﬂow management systems many other software systems have
adopted workﬂow technology, for example erp (enterprise resource planning) systems
such as sap, peoplesoft, baan, oracle, as well as crm (customer relationship man-
agement) software.
however, there appears to be a severe gap between the promise of workﬂow technol-
ogy and what systems really offer. as indicated by many authors, workﬂow management
1systems are too restrictive and have problems dealing with change [6, 9, 11, 15, 19, 24,
29, 30, 52]. in particular, many workshops and special issues of journals have been de-
voted to techniques to make workﬂow management more ﬂexible [6, 9, 29, 30]. some
authors stress the fact that models should be as simple as possible to allow for maximum
ﬂexibility [11]. other authors propose advanced techniques to support workﬂow evolu-
tion and the migration of cases of one workﬂow model to another [15, 52]. if the process
model is kept simple, only a more or less idealized version of the preferred process is
supported. as a result, the real run-time process is often much more variable than the
process speciﬁed at design-time. in contemporary workﬂow technology, the only way to
handle changes is to go behind the system’s back. if users are forced to bypass the work-ﬂow system quite frequently, the system is more a liability than an asset. if the process
model attempts to capture all possible exceptions [46], the resulting model becomes too
complex to manage and maintain. these and many other problems show that it is difﬁcult
to offer ﬂexibility without losing control.
1.2 terminology
to illustrate the deﬁciencies of contemporary workﬂow management and to motivate the
case handling paradigm, we use the metaphor of a blind surgeon. before doing so we
ﬁrst introduce some standard workﬂow terminology. workﬂow management systems are
case-driven , i.e., they focus on a single process instance.1this means that only business
processes describing the handling of one workﬂow instance in isolation are supported.
many cases can be handled in parallel. however, from the viewpoint of the workﬂow
management system these cases are logically independent. to handle each case, the
workﬂow management system uses the corresponding workﬂow process deﬁnition . the
process deﬁnition describes the routing of the case by specifying the ordering of activ-
ities. activities are the logical units of work and correspond to atomic pieces of work,
i.e., each activity is executed by one worker (or another type of resource) and the result is
either “commit work” or “abort and roll back”.
to specify the ordering of activities typically some graphical language such as petri
nets [1] or workﬂow graphs [52] is used. these languages allow for sequential, condi-
tional, and parallel routing of cases. some of the workﬂow management systems allow
for more advanced constructs [8]. typically, an activity which is enabled for a given casemay be executed by many workers, and many workers may execute a given activity. to
support the distribution of work, the concept of a roleis used. a worker can have mul-
tiple roles, but an activity has only one role. if activity a has role r, then only workers
with role r are allowed to execute activities of type a. based on this information, the
workﬂow management system works as follows: the corresponding workﬂow process
deﬁnition is instantiated for each new case, i.e., for each case (e.g., request for infor-
mation, insurance claim, customs declaration, etc.) a new workﬂow instance is created.
based on the corresponding workﬂow process deﬁnition, the workﬂow engine calculates
which activities are enabled for this case. for each enabled activity, one work-item is put
in the in-tray of each worker having the appropriate role. workers can pick work-items
from their in-tray. by selecting a work-item the worker can start executing the corre-
sponding activity, etc. note that, although a work-item can appear in the in-tray of many
workers, only one worker will execute the corresponding activity. when a work-item is
1please do not confuse “case-driven” processes with “case handling”. the case-handling paradigm can
be used to support case-driven processes. however, conventional workﬂow technology can also be used to
case-driven processes.
2selected, the workﬂow management system launches the corresponding application and
monitors the result of executing the corresponding activity. note that the worker only
sees work-items in his/her in-tray, and when selecting a work-item only the information
relevant for executing the corresponding activity is shown.
1.3 four problems
in this paper, we argue that the lack of ﬂexibility and — as a result — the lack of usability
of contemporary workﬂow management systems to a large extent stems from the fact that
routing is the only mechanism driving the case, i.e., work is moved from one in-tray to
another based on pre-speciﬁed causal relationships between activities. this fundamental
property of the workﬂow approach causes the following problems:
•work needs to be straight-jacketed into activities . although activities are con-
sidered to be atomic by the workﬂow system, they are not atomic for the user.
clustering atomic activities into workﬂow activities is required to distribute work.
however, the actual work is done at a much more ﬁne-grained level.
•routing is used for both work distribution and authorization . as a result, workers
can see all the work they are authorized to do. moreover, a worker is not authorized
to do anything beyond the work-items in her in-tray. clearly, work distribution andauthorization should not coincide. for example, a group leader may be authorized
to do the work offered to any of the group members, but this should not imply that
all this work is put in his worklist. since distribution and authorization typically
coincide in contemporary workﬂow management systems, only crude mechanisms
can be used to align workﬂow and organization.
•by focusing on control ﬂow the context, i.e., data related to the entire case and
not just the activity, is moved to be background. typically, such context tunneling
results in errors and inefﬁciencies.
•routing focuses on what should be done instead of what canbe done. this push-
oriented perspective results in rigid inﬂexible workﬂows.
it is worth noting that not only traditional workﬂow technology suffers from these prob-
lems. recent approaches to ﬂexible workﬂow management are still based on routing as
the only mechanism for process support and, hence, suffer from the problems mentioned.
1.4 blind surgeon metaphor
we use the “blind surgeon metaphor” to illustrate the four problems identiﬁed by placing
them in a hospital environment. in a hospital both operational ﬂexibility and well-deﬁned
procedures are needed. therefore, workﬂow processes in a hospital serve as benchmark
examples for ﬂexible workﬂow management, cf. [39]. note that the “blind surgeon
metaphor” is not restricted to hospital environments, similar issues can be observed in
a wide range of other knowledge-intensive application scenarios.
consider the ﬂow of patients in a hospital as a workﬂow process. one can consider
the admission of a patient to the hospital as the creation of a new case. the basic workﬂow
process of any hospital is to handle these cases. the activities in such a workﬂow include
all kinds of treatments, operations, diagnostic tests, etc. the workers are, among others,
surgeons, specialists, physicians, laboratory personnel, nurses. each of these workers has
3one or more roles, and each task requires a worker having a speciﬁc role. for example, in
case of appendicitis the activity “remove appendix” requires the role “surgeon”. clearly,
we can deﬁne hospital workﬂows in terms of process deﬁnitions, activities, roles, and
workers.
in the setting of “hospital workﬂows”, we again consider the four problems identiﬁed
before. suppose that work in hospitals would be straight-jacketed into activities . this
would mean that workers would only execute the actions that are speciﬁed for the activity,
i.e., additional actions would not be allowed, and it would also not be possible to skip
actions. such a rigorous execution of the work speciﬁed could lead to life-threatening
situations. in hospital environments it is crucial that knowledgeable persons can decide onactivities to perform based on the current case and their personal experiences. in general,
workﬂow process models cannot represent the complete knowledge of the experts and all
situations that might occur.
suppose that the routing in hospital processes would be used for both work distribu-
tion and authorization . this would mean that activities can only be executed if they are
in the in-tray of a worker. since distribution and authorization then coincide, it would not
be possible to allow for initiatives of workers, e.g., a physician cannot request a blood test
if the medical protocol does not specify such a test.
context tunneling is also intolerable. this would mean that the information for sur-
geons, specialists, physicians, laboratory personnel, and nurses is restricted to the infor-
mation that is needed for executing a speciﬁc task. in contrast, given a speciﬁc medical
situation, doctors and nurses may take advantage from consulting the complete medical
record of the patient, based on the current state of the patient and their personal knowl-
edge and experiences.
finally, it is clearly undesirable that the medical staff of a hospital would limit their
activities to what should be done according to the procedure rather than what canbe done.
the medical protocol typically speciﬁes what should be done instead of what can be done.
such descriptions are useful to guide workers. however, it is clear that restricting the
workers to the workﬂow speciﬁed in the medical protocol would lead to absurd situations.
it is clear that such a “tunnel vision”, i.e., a straight-ahead vision without attention
for contextual information, is not acceptable in any hospital process. consider for ex-
ample a surgeon who would ignore all information which is not directly related to the
surgical procedure. a straightforward implementation of such a process using contem-
porary workﬂow management systems would result in surgeons that are blind for this
information, just doing the actions speciﬁed for the activities in their in-trays. this “blind
surgeon metaphor” illustrates some of the key problems of present-day workﬂow man-
agement technology.
1.5 case handling
in this paper, we propose case handling as a new paradigm for supporting knowledge-
intensive business processes . by avoiding the blind surgeon metaphor, a wide range of
application scenarios for which contemporary workﬂow technology fails to offer an ad-
equate solution will beneﬁt from this new paradigm. the core features of case handling
are:
•avoid context tunneling by providing all information available (i.e., present the case
as a whole rather than showing just bits and pieces),
•decide which activities are enabled on the basis of the information available rather
4than the activities already executed,
•separate work distribution from authorization and allow for additional types of
roles, not just the execute role,
•allow workers to view and add/modify data before or after the corresponding activ-
ities have been executed (e.g., information can be registered the moment it becomes
available).
based on these key properties, we believe that case handling provides a good balance
between the data-centered approaches of the 80-ties and the process-centered approaches
of the 90-ties. inspired by business process re-engineering (bpr) principles [22] work-
ﬂow engineers have focused on processes neglected the products being produced by these
processes [2]. case handling treats both data and processes as ﬁrst-class citizens. this
balance seems to be highly relevant for knowledge intensive business processes.
this paper builds on the results presented in [5], where we focused on case handling
in the context of a speciﬁc case handling tool named flow er[13]. besides flow er
of pallas athena there are few other case handling tools. related products are e.c.h.o.
(electronic case-handling for ofﬁces), a predecessor of flow er, the staffware case
handler [44] and the cosa activity manager [43], both based on the generic solution
of bpi [14], and vectus [33, 34]. instead of focusing on a speciﬁc product, we gener-
alize some of the ideas used in these tools into a conceptual model which clearly showsthe difference between case handling and traditional workﬂow management. then, we
demonstrate the applicability of the case handling concept using flow er.
1.6 outline
the remainder of this paper is organized as follows. section 2 introduces case handling
by focusing on the differences between case handling and traditional workﬂow manage-
ment. section 3 presents a conceptual model which describes the key features of casehandling. case handling environments are precisely characterized in section 4 by a math-
ematical formalization of their static and dynamic aspects. note that sections 2, 3 and 4
are tool independent. section 5 describes the case-handling system flow erusing a re-
alistic example. then we provide pointers to current case-handling applications based on
flow er. finally, we discuss related work and conclude the paper. in the conclusion we
position case handling in a broader spectrum involving other approaches such traditional
production workﬂow, ad-hoc workﬂow, and groupware.
2 the case handling paradigm
the central concept for case handling is the case and not the activities or the routing. the
case is the “product” which is manufactured, and at any time workers should be aware of
this context. examples of cases are the evaluation of a job application, the verdict on a
trafﬁc violation, the outcome of a tax assessment, and the ruling for an insurance claim.
to handle a case, activities need to be executed. activities are logical units of work.
many workﬂow management systems impose the so-called acid properties on activities
[1, 26]. this means that an activity is considered to be atomic and either carried out
completely or not at all. case handling uses a less rigid notion. activities are simply
chunks of work which are recognized by workers, e.g., like ﬁlling out an electronic form.
as a rule-of-thumb, activities are separated by points where a transfer of work from one
5worker to another is likely or possible. please note that activities separated by points
of ‘work transfer’ can be non-atomic, e.g., the activity ‘book business trip’ may include
tasks such as ‘book ﬂight’, ‘book hotel’, etc.
clearly activities are related and cases follow typical patterns [8]. a process is the
recipe for handling cases of a given type. in many workﬂow management systems, the
speciﬁcation of a process ﬁxes the routing of cases along activities, and workers have
hardly any insight in the whole. as a result exceptions are difﬁcult to handle because
they require unparalleled deviations from the standard recipe.
since in dynamic application environments exceptions are the rule, precedence rela-
tions among activities should be minimized. if the workﬂow is not exclusively drivenby precedence relations among activities and activities are not considered to be atomic,
then another paradigm is needed to support the handling of cases. workers will have
more freedom but need to be aware of the whole case. moreover, the case should be
considered as a ‘product’ with structure and state. for knowledge-intensive processes,
the state and structure of any case is based on a collection of data objects . a data object
is a piece of information which is present or not present and when it is present it has a
value. in contrast to existing workﬂow management systems, the logistical state of the
case is not determined by the control-ﬂow status but by the presence of data objects. this
is truly a paradigm shift: case handling is also driven by data-ﬂow instead of exclusively
by control-ﬂow.
it is important that workers have insight in the whole case when they are executing
activities. therefore, all relevant information should be presented to the worker. more-
over, workers should be able to look at other data objects associated to the case they are
working on (assuming proper authorization). forms are used to present different views
on the data objects associated to a given case. activities can be linked to a form to presentthe most relevant data objects. forms are only a way of presenting data objects. the link
between data objects, activities, and processes is speciﬁed directly. each data object is
linked to a process. so-called freedata objects can be changed while the case is being
handled. all other data objects are explicitly linked to one or more activities as a manda-
tory and/or a restricted data object. if a data object is mandatory for an activity, it is
required to be entered in order to complete the corresponding activity. if a data object is
restricted for an activity, then it can only be entered in this activity or some other activity
for which the data object is restricted. if data object dis mandatory for activity a,acan
only be completed if dhas been entered. if dis restricted to aand no other activities,
dcan only be entered in a. note that dmay be mandatory for activity aandrestricted
toa, i.e., mandatory and restricted are two orthogonal notions. moreover, forms are in-
dependent of these two notions. for example, the form attached to an activity may or
may not show mandatory/restricted data objects. however, if dis mandatory for activity
aand restricted to only a, but not in the form linked to a, then this will cause a dead-
lock since it is not possible to complete a. therefore, mandatory and/or restricted data
objects are typically in the corresponding form. moreover, in many cases the form will
contain additional data elements which are either free or mandatory for other activities in
the process.
note that mandatory data objects can he considered as some kind of postcondition .
this observation raises the question why there is not a precondition (i.e., data objects have
to exist before execution) in addition or instead of this postcondition. this functionality
can be obtained by adding a dummy activity just before the activity which requires a
precondition, i.e., the dummy activity has a postcondition which can be interpreted as a
precondition of the subsequent activity. in other words, the dummy acts as a guard.
6actors are the workers executing activities and are grouped into roles. roles are
speciﬁc for processes, i.e., there can be multiple roles named ‘manager’ as long as they
are linked to different processes. one actor can have multiple roles and roles may have
multiple actors. roles can be linked together through role graphs. a role graph speciﬁes
‘isa’ relations between roles. this way, one can specify that anybody with role ‘manager’
also has the role ‘employee’. for each process and each activity three types of roles need
to be speciﬁed: the execute role, the redo role, and the skip role.
•theexecute role is the role that is necessary to carry out the activity or to start a
process.
•theredo role is necessary to undo activities, i.e., the case returns to the state be-
fore executing the activity. note that it is only possible to undo an activity if all
following activities are undone as well.
•theskip role is necessary to pass over activities.
in order to skip over two consecutive activities, the worker needs to have the skip role for
both activities. the three types of roles associated to activities and processes provide a
very powerful mechanism for modeling a wide range of exceptions. the redo ensures a
very dynamic (as it is dependent on the role of the employee and the status of the case) and
ﬂexible form of a loop. the skip takes care of a range of exceptions that would otherwise
have to be modeled in order to pass over activities. of course, there are ways of avoiding
undesirable effects: you can deﬁne the ‘no-one’ or ‘nobody’ role that is higher than all the
other roles, i.e., no user has this role, and therefore, the corresponding action is blocked.
you can also deﬁne an ‘everyone’ role that is lower than all others. an activity with the
‘no-one’ redo role can never be undone again and it would then also not be possible togo back to an earlier activity. this is a very effective way to model ‘points of no return’.
using “everyone” as an execute role means that the activity can be carried out by anyone
who at least has a role in that process (because that person is then, after all, at least
equal to the everyone role). note that in addition to these three roles, one could consider
additional roles, e.g., the “responsible role” or the “supervisor role”. for a case one could
also deﬁne the “case manager role”, etc.
the variety of roles associated to a case or an activity shows that in case handling
it is possible to separate authorization from work distribution. when using the classical
in-tray, one can only see the work-items which need to be executed. the only way to
get to a case is through work-items in the in-tray, i.e., authorization and work distribution
coincide. for case handling the in-tray is replaced by a ﬂexible query mechanism . this
mechanism allows a worker to navigate through all active and also to completed cases.
the query “select all cases for which there is an activity enabled which has an execute
role r” can be used to emulate the traditional in-tray. in fact, this query corresponds
precisely to the work queue concept used in the in-tray of the workﬂow managementsystem staffware. by extending the query to all roles a speciﬁc worker can fulﬁll, it is
possible to create a list of all cases for which the worker can execute activities at a given
point in time. however, it is also possible to have queries such as “select all cases that
worker w worked on in the last two months” and “select all cases with amount exceeding
80k euro for which activity a is enabled”. by using the query mechanism workers can
get a handle to cases that require attention. note that authorization is separated from
work distribution. roles are used to specify authorization. standard queries can be used
to distribute work. however, the query mechanism can also be used to formulate ad-hoc
queries which transcend the classical in-tray.
7workﬂow management case handling
focus work-item whole case
primary driver control ﬂow case data
separation of case data
and process controlyes no
separation of authoriza-
tion and distributionno yes
types of roles associatedwith tasks execute execute, skip, redo
table 1: differences between workﬂow management and case handling.
to conclude this section, we summarize the main differences between workﬂow man-
agement, as supported by contemporary workﬂow technology, and case handling (cf. ta-
ble 1). the focus of case handling is on the whole case, i.e., there is no context tunneling
by limiting the view to single work-items. the primary driver to determine which activ-ities are enabled is the state of the case (i.e., the case data) and not control-ﬂow related
information such as the activities that have been executed. the basic assumption driving
most workﬂow management systems is a strict separation between data and process. only
the control data is managed. the strict separation between case data and process control
simpliﬁes things but also creates integration problems. for case handling the logistical
state of a case (i.e., which activities are enabled) is derived from the data objects present,
therefore data and process cannot be separated! unlike workﬂow management, case han-
dling allows for a separation of authorization and distribution. moreover, it is possible to
distinguish various types of roles, i.e., the mapping of activities to workers is not limited
to the execute role.
3 the case handling meta model
after motivating case handling and introducing the basic concepts of this new paradigm insections 1 and 2, we now identify the main entities of case handling environments as well
as their relationships. in doing that we move from a rather informal discussion towards
more precise modeling of case handling environments. an object-oriented approach is
used for this endeavor, since it provides powerful modeling constructs which proved to be
adequate for dealing with the complexity in case handling. we use the de facto standard
in object oriented analysis and design, the uniﬁed modeling language (uml); mainly
its structural features are used. the case handling meta model represents artifacts which
are required to deﬁne cases and environments in which cases are executed; it is shown infigure 1.
case deﬁnition is the central class of the case handling meta model. case deﬁni-
tions are either complex (cases with internal structure) or atomic (cases without internal
structure), referred to as complex case deﬁnitions and activity deﬁnitions, respectively.
complex case deﬁnitions consist of a number of case deﬁnitions, resulting in a hierar-
chical structuring of cases in sub-cases and activities. in the case handling meta model,
this property is represented by a recursive association between complex case deﬁnition
and case deﬁnition. obviously each complex case deﬁnition consists of at least one case
deﬁnition, and each case deﬁnition may occur in at most one complex case deﬁnition, as
represented by the cardinalities of that association in figure 1.
8case definition
complex case definition activity definition-sub1..*
-super 0..1
data object definition forms definition
0..* 1..*0..10..*role
-from
0..*
-to0..*
-free 0..*
0..*0..*0..*-is_a 0..*
0..*
0..*
0..*0..*0..*
-mandatory-restricted1..*
0..*activity role type1..*
0..*case role type
figure 1: case handling meta model, schema level.
9since case handling is a data-driven approach, activity deﬁnitions are associated with
data object deﬁnitions. in particular, each activity deﬁnition is associated with at least one
data object deﬁnition. this association is partitioned into two main types, i.e., mandatory
and restricted. if a data object deﬁnition is mandatory for an activity deﬁnition then the
respective data value has to be entered before that activity can be completed; however,
it may also be entered in an earlier activity. a restricted association indicates that a data
value can only be entered during a particular activity.
restricted and mandatory associations between activities and data are an important
implementation vehicle for business process support, since an activity can only be com-
pleted if and when values for the mandatory data objects are provided. activity deﬁnitionsare also associated with forms deﬁnitions. forms are used to visualize data objects which
are offered to the user. forms are closely associated with activities, and they are an im-
portant means to business process support. the ﬁelds displayed in a form associated with
an activity correspond to mandatory as well as restricted data objects for that activity.
2in
addition, the deﬁnition of forms may also contain data objects that are mandatory for sub-
sequent activities. this feature allows ﬂexible execution of business processes, since data
values can be entered at an early stage, if the knowledge worker decides to do so. data
object deﬁnitions may also be free; free data objects are not associated with particular
activities; rather they are deﬁned in the context of complex case deﬁnitions. hence, they
can be accessed at any time during the case execution. free data objects are represented
by an association of data object deﬁnition with complex case deﬁnition. the context of a
case can be presented by such a form. as indicated above, providing the knowledge with
as much information as possible is an important aspect of case handling systems.
roles are used more thoroughly in case handling than in workﬂow management. in
particular, there are multiple roles associated with a given case deﬁnition, and these roleshave different types. typical roles types associated with an activity are execute (to execute
an activity), skip (to skip an activity that is not required during a particular case), and
redo (to jump back to previous activities of the case with the option of re-doing these
activities or re-conﬁrming data object values which have already been entered). role
types associated with complex case deﬁnitions are, for example, manager and supervisor,
to indicate persons which may manage or supervise complex cases; typically these roles
are mapped to management personnel of an organization. role types for activities are
represented by an association class called activity role type , linking the role class and
the activity deﬁnition class, while role types for complex cases are represented by an
association class between the complex case deﬁnition and the role class.
the example shown in figure 2 illustrates the concepts introduced in the case han-
dling meta model. it shows how cases, data objects and forms and their associations as
well as organizational aspects are represented. we start by discussing the overall structure
of the case deﬁnition. there is one complex case deﬁnition c1, which consists of activity
deﬁnitions a1,a2, anda3, represented by the indirect recursion of complex case deﬁ-
nitions and case deﬁnitions in the meta model, shown as a dotted line connecting c1to
its sub-cases. as shown in that ﬁgure, data object deﬁnition d1is mandatory for a1,a2
anda3.d2is mandatory for a2, andd3is restricted for a3. since d1is mandatory
fora1, the form deﬁnition f1associated with a1holds a ﬁeld for d1. however, there is
also a ﬁeld for d2in that form. the knowledge worker in charge of a case based on that
case deﬁnition may enter a value for d1whena1is ready for execution. in addition, she
may also enter a value for d2at this instant, which implicitly performs a
2as well. this
2as indicated before, the form may not contain all mandatory/restricted data objects. however, this may
cause deadlocks or other anomalies.
10a1 a2 a3
d1 d2 d3f1
d0d1
d4c1d2d0
d4d1f3
d0
r1
exec
r2skipd1
d3d2f2
free
free
restricted mandatorymandatory
mandatory
mandatory
figure 2: abstract example introducing the schema level of the case handling meta model.
is due to the fact that d2is the only mandatory data object for a2. notice, however, that
d3cannot be entered neither during a1nor during a2, since it is restricted to a3and
can therefore only be executed in the context of a3, using the form associated with it.
the activities of the case are ordered: a1is followed by a2anda3, represented
by the recursive association with roles toandfrom in the meta model. there are ﬁve
data object deﬁnitions d0through d4. dotted lines marked with association type names
represent the associations between activity deﬁnitions and data object deﬁnitions. as in-
dicated above, d1is mandatory for a1,a2anda3,d2is mandatory for a2, while d3is
restricted for a3.d0andd4are free data elements, which appear in form deﬁnition f3,
associated with the overall case deﬁnition c1. notice that form deﬁnition f1contains
not only a ﬁeld d1representing data object deﬁnition d1(mandatory for the completion
ofa1), but also d2(for data object deﬁnition d2which is mandatory for a2) andd0(for
data object deﬁnition d0which is free). as discussed above, during a1the knowledge
worker may already enter a data value for d2, although this is not required for the com-
pletion of a1. however, a1cannot complete before d1 is entered ( d1is mandatory for
a1). the knowledge worker may use the information presented in d0to work efﬁciently
on the case. not to overload the ﬁgure, the roles are not speciﬁed completely. in fact, only
the roles for a1are speciﬁed: r1andr2are associated with a1, where the association
withr1is of type execute (persons with role r1may execute this activity), while the
association with r2is of type skip (persons with role r2may skip this activity). this
means that during the enactment of cases based on case deﬁnition c1, only knowledge
workers which can play role r1are permitted to perform activities based on a1, and only
persons with role r2may skip that activity.
figure 1 only shows entities at the schema level, i.e., entities such as (complex) case
deﬁnitions, roles, activity deﬁnitions, data object deﬁnitions, and forms deﬁnitions. these
entities are speciﬁed at design-time. at run-time, other entities come into play, e.g., con-crete cases, actors, activities, data objects, and forms. for example, a case deﬁnition
“insurance claim” describes an insurance claim at the type level and not at the instance
11case
complex case activity-sub1..*
-super 0..1
data object form 0..* 0..*0..10..1actor
0..*1..* 1..*
0..*-from
0..*
-to0..*
0..*
-free 0..*1..*0..*0..1
0..*activity role
case role
figure 3: case handling meta model, instance level.
level. case “insurance claim 993567 ﬁled by jones on august 10th” is an instantiation
of case deﬁnition “insurance claim” and is example of an entity created and handled at
run-time. entities on the instance level are represented by the case handling model shown
in figure 3. in this model concrete cases are in the center of attention. the overall struc-
ture of the object model shown in figure 3 is similar to the structure of the meta model
shown in figure 1. for example, as case deﬁnitions are generalizations of complex case
deﬁnitions and activity deﬁnitions in the meta model, cases are generalizations of com-
plex cases and activities in the case handling model. furthermore, there is a precedence
ordering between cases, represented by a recursive relationship with roles toandfrom in
both levels of abstraction. the main differences between the two models are the organi-
zational embedding and the forms. in particular, while roleis a class in the meta model,
actor is a class in the case handling model. the cardinality of forms and form deﬁnitions
are different in both models. in the meta model (schema level), each forms deﬁnition
is associated with an arbitrary number of activity deﬁnitions, while in the case handling
model (instance level) each form is associated with at most one activity. this is due to the
fact that forms are instantiated for each activity with which they are associated. there are
activities without forms to cater for automatic activities, for example automated queries
to external database systems.
figure 3 assumes that at run-time the same form can be instantiated multiple times,
i.e., if two activities share the same forms deﬁnition, there may be two copies of the same
form. an alternative interpretation used by e.g. flow eris to see a form as simply a view
on the data and not allow multiple instances of the same form for the same case at the
same time. for this interpretation, the cardinalities in figure 3 should be like in figure 1.
124 a formal framework for case handling
this section formalizes most of the concepts introduced in the ﬁrst half of this paper. the
main purpose of this endeavor is to precisely describe the dynamics of a case handling
environment, i.e., an execution model for case handling. note that the meta model intro-
duced in the previous section only considers static aspects. the meta model structures
relevant entities at both the schema level and instance level. however, it does not specify
the dynamics.
in this section, we will specify the dynamics using a formal model. first, we introduce
a formal model describing a case deﬁnition. in this model, we abstract from certain
entities (e.g., forms) and focus on activities and data objects. based on this formal model,
we describe the execution model for case handling in terms of state-transition diagramsand eca-rules. finally, we discuss the relation between the formal model and the entities
excluded from the formal model, e.g., forms and actors.
4.1 case deﬁnition
a case deﬁnition describes the way a case of a speciﬁc type is handled. clearly, the case
deﬁnition is a good starting point for formalizing the dynamics of case handling. for
presentation purposes, we will limit our formalization of case handling to activities, data
objects, and their interrelationships. these are the core entities which determine the exe-
cution semantics of case handling. the formalization will exclude forms and roles. more-
over, we do not consider nested case deﬁnitions, i.e., we assume that a case deﬁnition only
contains activity deﬁnitions and not complex case deﬁnitions. note that the latter is not a
real limitation: any hierarchical model can be ﬂattened by recursively replacing complexcase deﬁnitions by their decompositions. forms and roles can be excluded because they
only indirectly affect the execution semantics. given these restrictions, we can deﬁne a
case deﬁnition as follows.
deﬁnition 4.1 a tuple cd =(a, p, d, dom,mandatory ,restricted ,free,condition )
is called case deﬁnition , if the following holds:
•ais a set of activities deﬁnitions ,
•p⊆a×ais aprecedence relation ,
•dis a set of data object deﬁnitions ,
•dom ∈d/mapsto→2
uis a function mapping each data object onto its domain (2u
denotes the power set of u), i.e., the domain of a data object deﬁnition is a set of
values over some universe u,
•mandatory ⊆a×dis a relation which speciﬁes mandatory data object deﬁni-
tions ,
•restricted ⊆a×dis a relation which speciﬁes restricted data object deﬁnitions ,
•free⊆dis a relation which speciﬁes free data object deﬁnitions ,
•condition ∈a/mapsto→2bspeciﬁes activity conditions , where bis a set of partial
bindings, i.e., b={f∈d/negationslash→u|∀d∈dom (f),f(d)∈dom (d)}
such that
13•pis acyclic,
•d=free∪{d∈d|∃a∈a:(a, d)∈mandatory ∪restricted }, and
•free∩{d∈d|∃a∈a:(a, d)∈mandatory ∪restricted }=∅.
/diamondmath
it is easy to relate deﬁnition 4.1 to the meta model shown in figure 1. set ain deﬁ-
nition 4.1 corresponds to the class activity deﬁnition in figure 1. set dcorresponds to
the class data object deﬁnition . function dom can be considered to be an attribute of
the class data object deﬁnition . relation pcorresponds to the association denoting the
precedence relation. note that we require pto be acyclic, i.e., there are no loops.3func-
tions mandatory and restricted correspond to the two associations connecting activities
and data object deﬁnitions. set free corresponds to the association connecting complex
case deﬁnitions and data object deﬁnitions. note that we do not consider nested case def-
initions. therefore, it sufﬁces to consider only one case deﬁnition and a set is enough to
model free data objects. free data objects can neither be mandatory nor restricted. note
that a data object deﬁnition can be both mandatory and restricted at the same time.
function condition can be seen as an attribute of class activity deﬁnition in figure 1.
each activity deﬁnition has a condition which is deﬁned as a set of bindings. a binding
is a set of values for speciﬁc data objects. an activity can only be executed if the actual
values of data objects match at least one of its bindings. if not, the activity is bypassed.
functions dom and condition provide a very simplistic type system and constraint lan-
guage. these can be upgraded to more advanced languages. the choice that activities
are bypassed if the activity condition evaluates to false is merely chosen for reasons of
simplicity. every activity acts as an and-join/and-split [31]. therefore, sequential and
parallel routing are possible by setting the activity conditions to true. alternative routing,
normally speciﬁed through xor-splits and xor-joins, can be obtained by adding activ-
ity conditions such that each activity in one branch either evaluates to true or to false.
this style of process modeling corresponds to the routing semantics of inconcert [47]. it
is important to note that activities for which the condition evaluates to false (i.e., there is
no binding matching the current values) are skipped and not blocked . it is possible to use
a less simplistic routing language.
deﬁnition 4.1 is illustrated by the sample case deﬁnition shown in figure 2. this case
deﬁnition is formalized as c1=(a, p, d, dom,mandatory ,restricted ,free,condition ),
such that a={a1,a2,a3},p={(a1,a2),(a2,a3)},d={d0,d1,...d 4}, and
•mandatory ={(a1,d1),(a2,d1),(a3,d1),(a2,d2)},
•restricted ={(a3,d3)},
•free ={d0,d4}.
figure 2 does not specify dom and condition . let us assume that dom (d1) = {true,
false},dom (d2) ={red,green,yellow },dom (d3) ={1,2,3,4,5,6,7,8,9,10}, and
dom (d4) = string . i.e., d1is a boolean, d2is a color, d3is a number, and d4is
some free text. condition (a1) = {}, which indicates that there is only one possible
3we do not allow loops. as a result we have a partial order of activities. this is not a fundamental
restriction. it is possible to have block structured loops like in mqseries workﬂow [32]. however, it isnot easy to extend this to the pattern “arbitrary cycles” described in [8]. however, for structured loops the
extension is straightforward. in fact, the case-handling system flower supports this.
14binding for activity a1and this binding is the empty binding. the empty binding is the
function with an empty domain. therefore, there are no requirements with respect to the
values of data objects. this makes sense since a1is the ﬁrst activity to be executed.
condition (a2) = {{(d1,true)}}, which indicates that a2can only be executed if the
value of d1is set to true.condition (a3) ={{(d2,red)},{(d2,green )}}, which in-
dicates that a3can only be executed if the value of d2is set to redorgreen . suppose
that in activity a1data object d1is set to false andd2is set to red. as a result activity
a2is bypassed because condition (a2)does not contain a binding where d1is set to
false . after skipping a2, activity a3becomes enabled. a3is not skipped because there
is a binding where d2is set to red({(d2,red)}). an alternative condition for a3is
condition (a3) = {{(d1,true),(d2,red)},{{(d1,false )},(d2,green )}}. this indi-
cates that a3can only be executed if d1is true and d2is red, or d1is false and d2
is green. otherwise a3is bypassed. note that these examples have only been given to
show how conditions can be speciﬁed in terms of bindings.
4.2 dynamics
as a basis for the speciﬁcation of the dynamic behavior of case handling systems, the
behavior of activities has to be deﬁned properly. in this paper, state-transition diagrams
are used for this purpose. in a given organization, each case deﬁnition is assigned to a
particular type of business event, which triggers the instantiation of a case according to
the case deﬁnition. for example, receiving a message informing an insurance company
on a claim is a typical business event. there might be case deﬁnitions for which many
business events are triggering.
when a case is instantiated, its activities are created. on its creation, an activity is in
the initial state. if and when it becomes available for execution, it enters the ready state.
when it is selected by the user it starts running. it can either be completed or it can be
interrupted. in the latter case, the data entered during the interrupted activity is saved.
the activity can be started again, and the data is still available at that time. if all data
objects of a given activity are entered, for instance during previous activities, it performs
the auto-complete state transition to enter the completed state. activities may be skipped
or bypassed. the user may skip an activity if she decides that it is not required. when
due to the evaluation of conditions certain branches are not followed, the activities on thatparticular branch of the case deﬁnition are bypassed.
an important aspect of case handling systems is the ability to re-execute previous ac-
tivities. this feature is represented by speciﬁc redo transitions from the passed, skipped,
and completed states. activities which have been redone can be re-executed. the behav-
ior of activities is shown in figure 4.
while activities are an important artifact in case handling, the case is mainly con-
trolled on the basis of states of data objects, associated with the particular case. it is
important to stress that not only the life-cycle of activities can be described by states and
state transitions, but also data objects. to see this, consider the state transitions that data
objects may take as shown in figure 5. on the creation of a data object, it adopts the un-
deﬁned state. data objects can be deﬁned, either by users ﬁlling in forms which represent
these data, or they can be deﬁned automatically, for example, by running queries against
a database and transferring the result values to the data objects. activities for which data
objects are mandatory can be redone (cf. the redo role), which results in a state transition
of data objects to the unconﬁrmed state. by conﬁrming the values, data objects re-enterthe deﬁned state.
15initial ready running
passed skipped completedenable
disableselect
redocomplete
redo redointerrupt
bypassskipauto-complete
figure 4: dynamic behavior of activities.
undefined defined
unconfirmeddefine
redo confirm
figure 5: states of data objects.
based on the above considerations, the state space of a case is deﬁned as follows:
deﬁnition 4.2 letcd =(a, p, d, dom,mandatory ,restricted ,free,condition )be a
case deﬁnition. the case state space sbased on cd is deﬁned as cartesian product
s=as×dsover an activity state space asand a data state space ds, such that
•as=a/mapsto→{ initial ,ready,running ,completed ,passed ,skipped }, and
•ds=d/mapsto→{ undeﬁned }∪({deﬁned ,unconﬁrmed }×u)
/diamondmath
this deﬁnition simply states that the state of a case is characterized by the states of its
activities (as characterized by figure 4) and the states of data objects (as characterized
by figure 5). each data object is either undeﬁned, deﬁned, or – after a redo operation –
unconﬁrmed. in the latter case, a value is stored for the data object.
it is useful to deﬁne terms describing the relative order of activities within the context
of a given case deﬁnition. given a case deﬁnition cd =(a, p, d, dom,mandatory ,
restricted ,free,condition ), for each activity a∈a
•preceding (a)={a/prime∈a|(a/prime,a)∈p+}, and
•subsequent (a)={a/prime∈a|(a, a/prime)∈p+}.
where p+=/uniontext
i>0piis the non-reﬂexive transitive closure of p.
case handling systems make use of case deﬁnitions to guide users in handling cases.
in order to do that, the system has to make sure that a given activity is ﬂagged ready for
execution if and only if the preconditions of that activity are met. to be able to specify if
an activity should be executed or bypassed, we use the following auxiliary function. let
cd =(a, p, d, dom,mandatory ,restricted ,free,condition )be a case deﬁnition and
16s=as×dsits state space. function α∈ds/mapsto→(d/negationslash→u)maps elements of the data
state space onto sets of deﬁned data objects and their values, i.e., αﬁlters out data objects
which are undeﬁned or unconﬁrmed. αcan be speciﬁed as follows: for any ds∈ds:
α(ds): ={(d, v)∈d×u|ds(d)=( deﬁned ,v)}. using this function, we can deﬁne
whether an activity a∈ashould be executed, considering to the data objects given a
state state ds∈ds:cpre(a, ds ): =∃f∈condition (a):f⊆α(ds).cpre(a, ds )is
called the precondition of activity ain data state ds. note that cpre∈(a×ds)/mapsto→b.
note that if this condition evaluates to true, a user with the proper role can select the
activity for execution. if the condition evaluates to false, the activity is bypassed. again
we would like to stress that activities may be bypassed but not blocked like in most otherlanguages.
in addition to a precondition which depends on the data state, there is also a post-
condition depending on the data state. c
post∈(a×ds)/mapsto→bis an auxiliary function
for specifying postconditions. for each a∈aandds∈ds,cpost(a, ds ): = {d∈
d|(a, d)∈mandatory }⊆dom (α(ds))is the postcondition of activity ain data state
ds.
functions cpreandcpostonly focus on the data state ds∈ds. clearly, the data
state is not sufﬁcient to determine the dynamics, also the activity state as∈as, the
causal relations speciﬁed by p, and the state-transition diagrams shown in figures 4 and
5 matter. to specify the semantics of case handling we augment the state transitions
shown in figure 4 with rules speciﬁed using an event condition action (eca) style of
formalization [45]. each state transition shown in figure 4 is described by a rule of the
following form: onevent ,ifcondition ,then action . the event describes the trigger
to evaluate the rule and typically corresponds to a user action. if there is no external
event needed to trigger the rule (i.e., a system trigger), this part of the rule is omitted.the condition is a boolean expression in terms of the state of the case, i.e., the activity
state ( as∈as) and the data state ( ds∈ds). the action is a state transition in the
state-transition diagram. using such eca-rules, the semantics are deﬁned as follows.
deﬁnition 4.3 letcd =(a, p, d, dom,mandatory ,restricted ,free,condition )be a
case deﬁnition, a∈aan activity, as∈asthe activity state, and ds∈dsthe data state.
the state transitions shown in figure 4 are deﬁned by the following eca-rules.
•if∀a
/prime∈preceding (a):as(a/prime)∈{passed, skipped, completed }
then enable (a, as, ds )
•if∃a/prime∈preceding (a):as(a/prime)/negationslash∈{passed, skipped, completed }
then disable (a, as, ds )
•onuser trigger (an actor with the proper execute role selects the activity)
ifcpre(a, ds )
then select (a, as, ds )
•onuser trigger (activity is interrupted by the actor working on the activity)
iftrue
then interrupt (a, as, ds )
•onuser trigger (activity is completed by the actor working on the activity)
ifcpost(a, ds )
then complete (a, as, ds )
17•ifcpre(a, ds )∧cpost(a, ds )
then auto complete (a, as, ds )
•onuser trigger (activity is skipped by an actor with the proper skip role)
ifcpre(a, ds )
then skip(a, as, ds )
•if¬cpre(a, ds )
then bypass (a, as, ds )
•onuser trigger (activity is redone by an actor with the proper redo role)
if∀a/prime∈subsequent (a):as(a/prime)∈{initial, ready }
then redo (a, as, ds )
/diamondmath
the eca rules should be interpreted in the context of the state-transition diagram shown
in figure 4. a rule can only be applied if the corresponding activity is in the proper
state, e.g., action bypass (a, as, ds )corresponds to a state transition of state ready to state
passed and, therefore, can only be executed if activity ais in state ready. most of the
rules are fairly straightforward. the only rule which deserves some explanation is the
last one, redo (a, as, ds ). to redo an activity all subsequent activities should either be in
state initial or ready or also rolled back. therefore, one should ﬁrst roll back activities
whose subsequent activities are ready or initial and then recursively roll back the other
activities. note that it is possible that a direct predecessor of an activity that is in state
ready can be rolled back. if this is the case, action disable (a, as, ds )automatically puts
the predecessor in state initial.
deﬁnition 4.3 only relates to the state-transition diagram shown in figure 4. in the
next deﬁnition we give similar rules for the state-transition diagram shown in figure 5.
deﬁnition 4.4 letcd =(a, p, d, dom,mandatory ,restricted ,free,condition )be a
case deﬁnition, d∈da data object, as∈asthe activity state, and ds∈dsthe data
state. the state transitions shown in figure 5 are deﬁned by the following eca-rules.
•onuser trigger (an actor enters the value of a data object in a form)
if(∃a∈a:(a, d)∈restricted )⇒(∃a∈a:(a, d)∈restricted ∧as(a)=
running )
then deﬁne (d, as, ds )
•onsystem trigger (if an activity is redone all data elements associated to the ac-
tivity are triggered)iftrue
then redo (d, as, ds )
•onuser trigger (the value of a data object is conﬁrmed by an actor having access
to some form)
if(∃a∈a:(a, d)∈restricted )⇒(∃a∈a:(a, d)∈restricted ∧as(a)=
running )
then conﬁrm (d, as, ds )
/diamondmath
18it is interesting to note that the state-transitions in figure 5 are relatively independent of
the states of activities. this is the essence of case handling, the data objects are leading
and data values may be entered at various places. only restricted data objects are closely
bound to activities. this is reﬂected in the conditions given in deﬁnition 4.4.
4.3 other aspects
the formalization given in terms of the state-transition diagrams and the eca rules only
partially incorporates aspects such as forms and roles. therefore, we discuss the relation-
ships between these aspects and deﬁnitions 4.1, 4.2, 4.3, and 4.4.
form deﬁnitions are linked to activity deﬁnitions and complex case deﬁnitions. typ-
ically, if (a, d)∈mandatory , then data object dalso appears in the form linked to
activity a. note that a form linked to an activity may contain entries for data objects that
are not mandatory. these additional entries may be used to enter data which is needed
in subsequent activities or to view and modify data produced in preceding activities. the
additional entries increase ﬂexibility by decoupling data objects and activities. there may
even be forms which are not linked to any activity. forms do not determine whether a data
object is mandatory, restricted, or free. this is a matter between activities and data ob-jects. given the limited impact of forms on the dynamics of case handling, we abstracted
from this aspect.
roles are linked to activities. we distinguish at least the following three role types:
exec, skip and redo. these roles are mentioned in the event part of the eca rules given
in deﬁnition 4.3 and deﬁnition 4.4. for example, it is only possible to skip an activity
if the event that leads to action skip(a, as, ds )is generated by an actor that has the skip
role.
an issue that was not addressed is the separation between work distribution and au-
thorization. in traditional workﬂow management systems work distribution and autho-
rization coincide. for case handling we propose the query mechanism mentioned before.
users can simply state an ad-hoc query or use a predeﬁned query. the query “select all
cases for which there is an activity in state ready which has an execute role r” can be used
to emulate the traditional in-tray. the query mechanism is used to give an actor a handle
to a case and not to a speciﬁc activity. once an actor has a handle to a case, she can select
activities that are in state ready. note that authorization is governed by the exec, skip andredo roles. work distribution is governed by the query mechanism.
5 flow er
in this section we introduce a concrete case handling product: flow er. flow er[5,
12, 13] is pallas athena’s case handling product. flow eris consistent with the case
handling meta model (cf. section 3) and the formal framework (cf. section 4). however,flow eroffers much more features than discussed in the previous sections. for example,
section 4 assumes a rather basic control ﬂow model where eventually all activities are
either bypassed, skipped, or completed. in this basic model it is not possible to select
one alternative branch, have multiple instances, deferred choice, etc. [8]. as a result,
section 4 presents only a simpliﬁcation of the actual functionality of flow er. note
that the goal of this paper is to show the essence of case handling and not a concrete
product. nevertheless, we think it is interesting a see a concrete application of flow er
to illustrate the case-handling paradigm.
19 
figure 6: complex case deﬁnition motorclaim .
flow erconsists of a number of components: flow erstudio, flow ercase guide,
flow erconﬁguration management (cfm), flow erintegration facility, and flow er
management information and case history logging. in this paper, we limit ourselves to
flow erstudio and flow ercase guide. flow erstudio is the graphical design en-
vironment. it is used during build-time to deﬁne case deﬁnitions, consisting of activities,
precedences, data objects, roles, and forms. flow ercase guide is the client application
which is used to handle individual cases.
now we consider a ﬁctive insurance company’s process for handling claims for mo-
tor car damage. figure 6 shows a top-level view of the workﬂow process motorclaim in
flow erstudio. the right-hand side of figure 6 shows a graphical representation of the
process. the left-hand side shows a list of data object deﬁnitions. the left-hand side of
the window can also be used to list all form deﬁnitions, mappings (to connect to external
information sources) and complex case deﬁnitions (subprocesses). as figure 6 shows
the case handling process starts with the creation of a case (activity case creation ), fol-
lowed by the activity claim start . activity claim start is linked to a form which en-
ables the user to enter the claim data and the scanned hand-written form supplied by the
claimant. both data objects are restricted, i.e., they can only be entered in this step inthe process. after completing the form associated to activity claim
start the subpro-
cess register claim is started. note that this corresponds to a complex case deﬁnition
in terms of our meta model (cf. figure 1). complex case deﬁnitions are named plans
in flow er.register claim is a so-called static plan which means that it does not in-
volve any choices and is instantiated only once. the top-level view of register claim
is shown in figure 7. register claim consists of a number of activities which all need
to be executed and each of these activities corresponds to obtaining certain data objects.
after completing register claim , four complex case deﬁnitions are handled in parallel:
getmedical report ,getpolice record ,assign loss adjuster , and witness statements .
getmedical report ,getpolice record , and assign loss adjuster correspond to sub-
processes which start with a system choice and are named system decision plans. each
of these subprocesses contains several activities. a detailed description of these subpro-
cesses is beyond the scope of the paper. the same holds for the processing of witness
statements. however, the complex case deﬁnition witness statements is a so-called dy-
20 
figure 7: complex case deﬁnition register claim .
namic subplan. this means that it can be instantiated multiple times and each of these
instances is handled in parallel. a dynamic subplan can have the following attributes: ex-
pansion name ,minimum instances , and max expansions . the attribute expansion name
is used to identify each instance. for the subplan witness statements the name of the
witness is used). the attribute minimum instances is used to specify how many instances
should be created (in this case the number of eye witnesses speciﬁed by the data object
nrwitnesses entered in register claim ) the attribute max expansions is used to set an
upper limit for the number of instances (in this case 5; note that new instances can be
created on-the-ﬂy).
after completing getmedical report ,getpolice record ,assign loss adjuster , and
witness statements , complex case deﬁnition policy holder liable is executed. this sub-
process starts with a user decision and is therefore named a user decision plan. pol-
icyholder liable contains seven activities. again details are omitted.
the case deﬁnition of motorclaim comprises 173 data object deﬁnitions. this num-
ber shows the relevance of data. each data object has a name and a type and is linked to a
plan (i.e., a complex case deﬁnition). the left-hand side of figure 8 shows these attributes
for the data object deﬁnition claimant contacted . this is a boolean data object indicating
whether the policy holder has been contacted. initially this data object is set to false. as
the right-hand side of figure 8 shows, claimant contacted is restricted to activity con-
tactpolicy holder . this activity is part of the complex case deﬁnition register claim
shown in figure 7. note that one data object deﬁnition can be restricted to multiple ac-
tivity deﬁnitions and that one activity deﬁnition can have multiple restricted data object
deﬁnitions. this is consistent with the cardinalities of the association restricted shown in
figure 1. mandatory data objects are speciﬁed when deﬁning an activity. figure 9 shows
two activities and the corresponding lists of mandatory data objects. for example, data
object deﬁnition accident date is mandatory for activity deﬁnition collect case data. all
data object deﬁnitions are linked to a speciﬁc complex case deﬁnition (i.e., including re-
stricted and mandatory data elements). for example, the left-hand side of figure 8 shows
21 
  
figure 8: attributes of the data object deﬁnition claimant contacted .
thatclaimant contacted is linked to plan register claim . this is consistent with the meta
model which identiﬁes the association free(cf. figure 1) which links complex case def-
initions and data object deﬁnitions. however, the realization in flow erimplies that all
mandatory and restricted data objects are also linked to a complex case deﬁnition (i.e.,
plan).
the case deﬁnition of motorclaim comprises 21 form deﬁnitions. one form def-
inition can be linked to many activity deﬁnitions. for example, form deﬁnition col-
lectcase data is linked to the ﬁrst four activities of register claim . figure 9 shows
two activity deﬁnitions sharing this form. let us focus on the ﬁrst three steps of regis-
terclaim (figure 7). activity deﬁnition collect case data has 5 mandatory data object
deﬁnitions (accident date, persons injured, etc.). activity deﬁnition policy holder data
has 14 mandatory data object deﬁnitions (name of policy holder, policy number, etc.).
activity deﬁnition opposite party data has 10 mandatory data object deﬁnitions (name
of opposite party, address, etc.). there is no overlap between these mandatory data ob-
jects. however, form deﬁnition collect case data includes all these data objects since
the form is shared among these activities. this means that when a worker is executing the
ﬁrst step in the process (i.e., activity collect case data), she will see information relevant
for subsequent steps in the process. moreover, the worker can already enter data and
this way implicitly execute subsequent steps. by entering the 5+14+10 = 29 mandatory
data objects mentioned before, the ﬁrst three steps are executed through ﬁlling out a sin-
gle form. this example demonstrates the essence of case handling: the focus is on the
whole case rather a single work-item and data objects rather than control-ﬂow constructs
are driving the workﬂow.
as figure 10 shows, six roles are relevant for the motorclaim case deﬁnition: no-
body ,manager ,supervisor ,claim adjuster ,doctor , and data collector . the arcs in the
role graph correspond to the isaassociation shown in figure 1. note that nobody is the
most powerful role. if no actors are assigned this role, it can be used to disable undesir-
able skip or redo actions as was explained in section 2. the role data collector is the
weakest role and this role can be fulﬁlled by anybody having any of the six roles shown
in figure 10. each activity deﬁnition has three types of roles assigned to it. figure 11
22 
  
figure 9: properties of activities, including speciﬁcation of mandatory data objects.
 
figure 10: role graph editor of studio showing the six roles involved.
23 
figure 11: the execute, redo, and skip roles of collect case data.
shows the execute, redo, and skip roles of collect case data.collect case data can be
executed by workers with at least the role data collector (i.e., all actors having any of the
six roles), it can be redone by workers with at least the role claim adjuster (i.e., all actors
except the ones just having the doctor ordata collector ) role, and it can be skipped by
workers with at least the role manager (i.e., all actors with either the role manager or
nobody ).
figures 6, 7, 8, 9, 10, and 11 show windows of the design tool studio. actors (i.e.,
workers) access cases through the so-called flow ercase guide. access to cases is lim-
ited by the associated roles. note that flow ersupports the separation of authorization
and work distribution. the role mechanism is used for authorization. work distribution
is supported through a query mechanism as explained in section 2.
figure 12 shows the case guide showing the state of a case of type motorclaim .
the case guide shows the whole case. the left-hand-side shows the hierarchy of the
case deﬁnition. the right-hand side of the case guide shown in figure 12 is divided
into three parts. the top part is used for navigation. the bottom part is used to access
forms which are independent of activities, e.g., form case overview can be opened at
any time and shows information about letters sent, letters received, the accident form,
etc. in the middle part of the right-hand side for the window, the so-called wavefront is
shown. the wavefront is the most essential piece of information provided by the case
guide since it shows the state of the case in terms of activities that have been executed orskipped, activities that are enabled, and activities that are not (yet) enabled. the wavefront
provides a time line. activity claim
start is on the right of this time line indicating that it
has been executed. static plan (i.e., subprocess/complex case deﬁnition) register claim
is on the time line indicating that it is ready to be executed. getmedical report and the
other plans/activities at the top level are on the left of the time line indicating that they
are not (yet) enabled. by double clicking the icon of register claim , the wavefront for
the activities/plans inside register claim is shown. by double-clicking an activity, the
execution of the corresponding activity starts. if the ﬁrst activity of register claim (i.e.,
collect case data) is started, the form shown in figure 13 is opened. this form, also
named collect case data , consists of two pages. figure 13 only shows the ﬁrst page.
the ﬁrst six data objects shown in the form correspond to the activity collect case data.
the data objects under “insuro client” correspond to activity policy holder data and
24 
figure 12: the flow ercase guide.
25 
figure 13: the form associated with some of the activities in register claim .
the data objects under “opposite party” correspond to activity opposite party data. the
form collect case data is linked to these three activities, i.e., a single form is shared
among multiple activities. however, whether data objects are mandatory or restricted
depends on the current activity. note that as indicated before all three activities can be
performed through a single form, i.e., there is no need to open and close forms in-between
activities. however, a worker can ﬁll out only the top part of the form collect case data
and thus only executed the ﬁrst step in register claim .
in this section, we have shown an application of case handling using flow er. the
application is fairly straightforward. however, even rather straightforward workﬂow pro-
cesses may involve many data objects and activities. the motorclaim applications con-
sists of 8 complex case deﬁnitions, 30 activity deﬁnitions, 173 data object deﬁnitions, 21
forms, and 6 roles. unlike typical workﬂow solutions, data is not hidden inside appli-
cations. the fact that a considerable number of data objects are identiﬁed and used for
guiding workers through case executions shows that the process is primarily data-driven
and thus a nice illustration of the case handling paradigm.
266 applications of case handling
in this section we brieﬂy discuss practical implementations of case handling systems
based on flow er. at this point in time several dutch organizations are switching from
a traditional workﬂow management system to flow er. in many cases the switch is
triggered by the problems addressed in the introduction. an example of such an orga-
nization is the uwv . the employee insurance implementing body (uitvoering werk-
nemersverzekeringen, or uwv) is responsible for the implementation of employee insur-
ance schemes, such as the sickness insurance scheme (zw), the national health insurance
scheme (zfw), the unemployment insurance scheme (ww) and the occupational disabil-
ity insurance scheme (wao). the uwv levies the contributions under these schemes,
assesses beneﬁt applications and sees to the payment of beneﬁts. uwv is a new organi-zation which joins former organizations (uitvoeringsinstellingen, or uvi’s) such as guo,
gak, cadans, uszo, bouwnijverheid, and lisv. formally the organization was created
on 1-1-2002. the goal of joining these organizations into the uwv is twofold: improve
quality and reduce costs. to achieve this goal, the merger triggered the development of a
common ict strategy and standards. for workﬂow management and case handling within
the uwv , flow erwas selected as the standard product. one of the ﬁrst applications of
flow erwas in the complaints and appeals department of uwv/gak. a system based
on flow erruns within all 25 branch ofﬁces (1000 users) of the uwv/gak and handles
about 110.000 complaints and 15.000 appeals per year. the processes supported by this
system are complex, need to deal with many exceptions, and involve many documents.
since flow eris a rather new tool and the organizations applying flow erare not eager
to provide detailed information about their processes (e.g., for reasons of conﬁdentiality),
we cannot provide any details of current implementations. instead we conclude with a
list of typical application domains of a tool like flow er:
•payment institutions (issuing payments, handling complaints and appeals),
•banks and insurance companies (credit facilities, claims processing),
•government bodies (processing vertical products),
•telecommunications (client and contract administration),
•housing corporations (real estate administration),
•educational institutions (student and course administration),
•health care (patient registration and administrative processing),
•police (supporting police ﬁeld work),
•courts of law (writs, summonses), and
•it companies and departments (incidents, requests for changes).
it is important to note that flow erhas been applied in each of these application domains,
i.e., it is not only a list of possible applications: it lists areas where case handling has been
applied using flow er.
277 related work
as was mentioned in the introduction, many researchers have recently addressed the issue
of workﬂow ﬂexibility; a number of workshop reports, edited books, and special issues
of journals were devoted to this topic, e.g., [6, 9, 16, 23, 27, 29, 30]. agostini and de
michelis [11] argue that very simple workﬂow models should be used and exceptions
should be dealt with by hand through so-called “linear jumps”. other authors, e.g., [15],
give concrete adaptation rules. some authors even state that “workﬂow change is a work-
ﬂow” [19]. several authors propose a more declarative style of specifying workﬂows, for
example the v ortex paradigm [25]. approaches like [16, 23, 27] use the metaphor of an
active document. these are just a few pointers to the elaborate literature on workﬂow
ﬂexibility.
the problems with respect to designing process models for real-life processes have
been recognized in [24, 41]. herrmann [24] seeks a solution by using semi-structured
workﬂow models. reijers et al. [41] propose a product-driven approach to emphasize
the role of data objects in the design of workﬂows. the latter approach can easily be
combined with the case handling paradigm.
this paper builds on [5] which introduced the basic idea of case handling without
providing a meta model, formalization, realistic examples, etc. in [10] we presented the
application of case handling in a concrete project. in [40] we put this work in the context
of traditional workﬂow systems.
schuschel et al. introduce an integrated approach for process planning and coordi-
nation, based on planning algorithms developed by the artiﬁcial intelligence community.
pre conditions and post conditions are used to derive goals based on a current situation.
while this work is on a conceptual level and no implementation of the ideas is given, it
introduces planning as a vehicle for ﬂexible process modeling, which is strongly related
to case handling [42].
increasingly, agent technology is used to build workﬂow management systems [49,
36, 37, 48]. the agent architecture allows for additional ﬂexibility. despite the many
agent-based workﬂow prototypes, the authors are unaware of any commercial applica-
tions of agents in the workﬂow domain. the approach based on agents is related to the
work on proclets [4], where complex workﬂows are partitioned into interacting simple
workﬂows using the ideas of [50].
vendors of workﬂow management systems have also been struggling with ﬂexibility
issues. systems such as inconcert (tibco, [47]) allow for ad-hoc routing of workﬂow
instances (i.e. cases). however, these systems require on-the-ﬂy modiﬁcations of process
models by end-users. we know of only few systems that claim to support case handling.
we elaborated on flow erdeveloped by pallas athena [5, 13, 12]. the functionality
of flow eris more-or-less consistent with the meta model and formalizations given in
this paper. vectus (london-bridge/hatton blue) and the staffware case manager [44]
are two other systems also aiming at case handling. initially the focus of vectus was on
workﬂow support for legal applications. since london-bridge has acquired hatton blue,the focus has shifted to customer relationship management (crm). the staffware case
manager (scm) extends the staffware workﬂow management system with case handling
functionality. the scm can be seen as a layer between the workﬂow management system
and the applications. the scm allows for easy access to case related documents and
is able to reﬁne staffware steps (i.e., workﬂow activities) into more ﬁne-grained tasks.
in essence, the resulting approach is still process-driven and not data-driven. the only
way to get to the scm is through the standard work-queue mechanism of the staffware
28workﬂow management system. therefore, the meta model and the formal framework for
case handling systems do not apply to the scm. similar to scm is the cosa activity
manager (cam) [43]. both scm and cam are based on the activity manager of bpi
[14].
besides contemplating concrete case handling systems, it is interesting to consider
case handling in the context of computer supported cooperative work and, more speciﬁ-
cally, groupware systems [18, 28]. an interesting classiﬁcation of collaborative technolo-
gies is given in [17]. there ellis presents a taxonomy dividing collaborative technologies
into four classes of functionality:
•keepers support the access and change to shared artifacts. typical issues that are
of primary concern to keepers are access control, versioning, backup, recovery,
and concurrency control. examples of keepers include the vault in a product data
management (pdm) system, a repository with drawings in a cad/cam system,
and a multi media database system.
•coordinators are concerned with the ordering and synchronization of individual
activities that make up the whole process. typical issues addressed by coordinators
are process design, process enactment, enabling of activities, and progress moni-
toring. the key functionality of a workﬂow management system is playing the role
of coordinator.
•communicators are concerned with explicit communication between participants
in collaborative endeavors. typical examples are electronic mail systems and video
conferencing systems, and basic issues that need to be addressed are message pass-
ing (broadcast, multicast, etc.), communication protocols, and conversation man-
agement.
•team-agents are specialized domain-speciﬁc pieces of functionality. a team agent
is typically a system acting on behalf of a speciﬁc person or group and executing a
speciﬁc task. examples include an electronic agenda and a meeting scheduler.
the functionality of workﬂow management systems is usually limited to the coordinator
role. clearly a case handling system supports the keeper, coordinator, and communicator
roles. a case handling system extends the traditional workﬂow management system with
the keeper role (data objects are under the control of the case handling system) and better
support for the communicator role (the separation for work distribution and authoriza-
tion and the ability to attach semi-structured information to cases). groupware systems
(i.e., excluding workﬂow technology) tend to be weak on the coordination dimension,
and stronger on the keeper, communicator, and team-agent functions. many groupwaresystems provide various kinds of support for group decision-making, but they do not have
any explicit notion of workﬂow processes. lotus notes combined with domino workﬂow
[38] forms an exception, which does provide all four functions. therefore, it is interesting
to compare lotus notes/domino workﬂow with the case handling paradigm presented in
this paper. domino workﬂow supports the so-called binder concept which is a logical
structure grouping documents related to one case. moreover, the keeper, coordinator and
communicator roles are truly integrated. however, the routing between activities is com-
parable to a traditional workﬂow management system, i.e., the approach is process-driven
rather than data-driven. therefore, lotus notes/domino workﬂow should not be consid-
ered a case-handling system. nevertheless, lotus notes/domino workﬂow is targeting
similar problems.
29explicitly
structured
implicitly
structured
ad-hoc
structured
unstructured
data-driven process-drivenad-hoc workflow
groupwareproduction
workflow
case handling
figure 14: positioning case handling.
8 conclusions
this paper introduced case handling as a new paradigm for supporting ﬂexible business
processes. using the “blind surgeon metaphor” we introduced case handling and high-lighted the problems with respect to contemporary workﬂow technology. in section 2
we compared case handling with traditional workﬂow management. striking differences
are the difference in focus (on the whole case rather than an individual work-item) and
the difference in driving force (also data-driven, not only process-driven). to precisely
deﬁne the case handling metaphor we provided a meta model at both the schema level
and the instance level, and a formal mathematical framework specifying the dynamics of
case handling in terms of state-transition diagrams and eca rules. finally, we presented
an example and discussed related work and products.
in the introduction of this paper, we identiﬁed four problems. these problems are
addressed by case handling in the following way:
•context tunneling is avoided by providing all information available (i.e., present the
case as a whole rather than showing just bits and pieces),
•activities are enabled on the basis of the information available rather than the activ-
ities already executed,
•work distribution is separated from authorization and additional types of roles (i.e.,
not just the execute role) are added,
•workers are allowed to view and add/modify data before or after the correspond-
ing activities have been executed (e.g., information can be entered the moment it
becomes available).
to conclude this paper, we position case handling in the context of groupware, pro-
duction workﬂow, and ad-hoc workﬂow using figure 14. traditional groupware products
like lotus notes and ms exchange and production workﬂow systems like staffware and
30mqseries workﬂow form two ends of a spectrum. as figure 14 shows, traditional group-
ware products are data-driven (focus on the sharing of information rather than the pro-
cess) and support only unstructured processes. note that lotus notes and exchange are
not “process-aware” (unless components like domino workﬂow are added). production
workﬂow are process-aware and aim at structured processes. in order to enact a workﬂow
using a production workﬂow system one needs to explicitly specify all possible routes.
if something is not explicitly speciﬁed at design time, it is not possible. ad-hoc work-
ﬂow management systems like inconcert (tibco), ensemble (filenet), and teamware
flow (teamware group) allow for the creation and modiﬁcation of workﬂow processes
during the execution of the processes. each case has a private process model and there-fore the traditional problems encountered when changing a workﬂow speciﬁcation can
be avoided. ad-hoc workﬂow management systems allow for a lot of ﬂexibility. the
workﬂow management system inconcert even allows the user to initiate a case having
an empty process model. when the case is handled, the workﬂow model is extended to
reﬂect the work conducted. another possibility is to start using a template. the moment
a case is initiated, the corresponding process model is instantiated using a template. after
instantiation, the case has a private copy of the template, which can be modiﬁed while the
process is running. inconcert also supports “workﬂow design by discovery”: the rout-
ing of any completed workﬂow instance can be used to create a new template. this way
actual workﬂow executions can be used to create workﬂow process deﬁnitions. figure 14
shows that ad-hoc workﬂow management systems like inconcert are process-driven and
ad-hoc structured. note that, per case, there has to be an explicit process model. al-
though interesting, the practical relevance of ad-hoc workﬂow is limited since it assumes
that workers can modify models at run-time. although ﬂexible, this poses many problems
ranging from unauthorized actions to incomplete cases.
as figure 14 shows, case handling should be positioned in-between groupware, pro-
duction workﬂow, and ad-hoc workﬂow. note that case handling is both process driven
and data driven. on the one hand, it is possible to create data-driven workﬂows by using
mandatory data objects. on the other hand, it is possible to deﬁne causal dependencies
like in a traditional workﬂow system. using a data-driven approach it is possible to allow
for many routes without explicitly specifying them. moreover, additional roles like skip
and redo also enable implicit routes through the workﬂow. if each task has “everyone” as
its execute, skip, and redo role, there are hardly any constraints. if all data elements are
mandatory and restricted and each task has “nobody” as its skip and redo role, one ob-
tains the functionality comparable to a traditional workﬂow system. hence case handling
encompasses the traditional workﬂow paradigm.
clearly there is a trade-off between support and ﬂexibility. systems that offer a lot
of support tend to be inﬂexible (e.g., production workﬂow). systems that offer a lot
of ﬂexibility tend to offer less support to the process (e.g., groupware products). at a
ﬁrst glance, support and ﬂexibility may even seem to be contrasting. as demonstratedin this paper, the case handling paradigm offers an interesting balance between support
and ﬂexibility. nevertheless, future research will be aiming at further developing the case
handling concepts and empirical proof of the statements made in this paper. moreover, the
case handling paradigm does not solve all problems related to change. note that structural
changes will still lead to problems such as the dynamic change bug [3, 20, 39, 51].
31acknowledgements
we thank all the people from the flow erdevelopment team of pallas athena for their
insights in case handling and their support with respect to the use of flow er. speciﬁ-
cally we would like to thank paul berens for sharing knowledge of case handling. we also
thank eric verbeek for his technical support in using flow erand moniek stoffele for
applying the case handling concept to the building processes of heijmans [10]. finally,
we thank the three reviewers for their useful comments.
references
[1] w.m.p. van der aalst. the application of petri nets to workﬂow management. the
journal of circuits, systems and computers , 8(1):21–66, 1998.
[2] w.m.p. van der aalst. on the automatic generation of workﬂow processes based on
product structures. computers in industry , 39:97–111, 1999.
[3] w.m.p. van der aalst. exterminating the dynamic change bug: a concrete ap-
proach to support workﬂow change. information systems frontiers , 3(3):297–317,
2001.
[4] w.m.p. van der aalst, p. barthelmess, c.a. ellis, and j. wainer. proclets: a frame-
work for lightweight interacting workﬂow processes. international journal of co-
operative information systems , 10(4):443–482, 2001.
[5] w.m.p. van der aalst and p.j.s. berens. beyond workﬂow management: product-
driven case handling. in s. ellis, t. rodden, and i. zigurs, editors, international
acm siggroup conference on supporting group work (group 2001) , pages
42–51. acm press, new york, 2001.
[6] w.m.p. van der aalst, j. desel, and a. oberweis, editors. business process manage-
ment: models, techniques, and empirical studies , volume 1806 of lecture notes in
computer science . springer-verlag, berlin, 2000.
[7] w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
[8] w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
[9] w.m.p. van der aalst and s. jablonski. dealing with workﬂow change: identiﬁca-
tion of issues and solutions. international journal of computer systems, science,
and engineering , 15(5):267–276, 2000.
[10] w.m.p. van der aalst, m. stoffele, and j.w.f. wamelink. case handling in con-
struction. automation in construction , 12(3):303–320, 2003.
[11] a. agostini and g. de michelis. improving flexibility of workﬂow management
systems. in w.m.p. van der aalst, j. desel, and a. oberweis, editors, business
process management: models, techniques, and empirical studies , volume 1806 of
lecture notes in computer science , pages 218–234. springer-verlag, berlin, 2000.
32[12] pallas athena. case handling with flower: beyond workﬂow . pallas athena bv,
apeldoorn, the netherlands, 2002.
[13] pallas athena. flower user manual . pallas athena bv, apeldoorn, the nether-
lands, 2002.
[14] bpi. activity manager: standard program - standard forms (version 1.2) . work-
ﬂow management solutions, oosterbeek, the netherlands, 2002.
[15] f. casati, s. ceri, b. pernici, and g. pozzi. workﬂow evolution. in proceedings of
er ’96 , pages 438–455, cottubus, germany, oct 1996.
[16] p. dourish, w.k. edwards, j. howell, a. lamarca, j. lamping, k. petersen, m. sal-
isbury, d. terry, and j. thornton. a programming model for active documents. in
proceedings of the 13th annual acm symposium on user interface software and
technology , pages 41–50. acm press, 2000.
[17] c.a. ellis. an evaluation framework for collaborative systems. technical report,
cu-cs-901-00, university of colorado, department of computer science, boulder,
usa, 2000.
[18] c.a. ellis, s.j. gibbs, and g. rein. groupware: some issues and experiences.
communications of the acm , 34(1):38–58, 1991.
[19] c.a. ellis and k. keddara. a workﬂow change is a workﬂow. in w.m.p. van
der aalst, j. desel, and a. oberweis, editors, business process management: mod-
els, techniques, and empirical studies , volume 1806 of lecture notes in computer
science , pages 201–217. springer-verlag, berlin, 2000.
[20] c.a. ellis, k. keddara, and g. rozenberg. dynamic change within workﬂow sys-
tems. in n. comstock, c. ellis, r. kling, j. mylopoulos, and s. kaplan, editors,
proceedings of the conference on organizational computing systems , pages 10 –
21, milpitas, california, august 1995. acm sigois, acm press, new york.
[21] l. fischer, editor. workﬂow handbook 2001, workﬂow management coalition .
future strategies, lighthouse point, florida, 2001.
[22] m. hammer and j. champy. reengineering the corporation . nicolas brealey pub-
lishing, london, 1993.
[23] e. heinrich and h. maurer. active documents: concept, implementation and ap-
plications. journal of universal computer science , 6(12):1197–1202, 2000.
[24] t. herrmann, m. hoffmann, k.u. loser, and k. moysich. semistructured models
are surprisingly useful for user-centered design. in g. de michelis, a. giboin,
l. karsenty, and r. dieng, editors, designing cooperative systems (coop 2000) ,
pages 159–174. ios press, amsterdam, 2000.
[25] r. hull, f. llirbat, e. simon, j. su, g. dong, b. kumar, and g. zhou. declarative
workﬂows that support easy modiﬁcation and dynamic browsing. in g. geor-gakopoulos, w. prinz, and a.l. wolf, editors, work activities coordination and
collaboration (wacc’99) , pages 69–78, san francisco, february 1999. acm
press.
33[26] s. jablonski and c. bussler. workﬂow management: modeling concepts, archi-
tecture, and implementation . international thomson computer press, london, uk,
1996.
[27] b. karbe and n. ramsperger. support of cooperative work by electronic circulation
folders. in conference on ofﬁce information systems, acm special interest group
on ofﬁce information systems , pages 109 – 117. acm sigois, acm press, new
york, 1990.
[28] s. khoshanﬁan and m.buckiewicz. introduction to groupware, workﬂow, and
workgroup computing . john wiley and sons, new york, 1995.
[29] m. klein, c. dellarocas, and a. bernstein, editors. proceedings of the cscw-
98 workshop towards adaptive workﬂow systems , seattle, washington, november
1998.
[30] m. klein, c. dellarocas, and a. bernstein, editors. adaptive workﬂow systems ,
volume 9 of special issue of the journal of computer supported cooperative work ,
2000.
[31] p. lawrence, editor. workﬂow handbook 1997, workﬂow management coalition .
john wiley and sons, new york, 1997.
[32] f. leymann and d. roller. production workﬂow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
[33] london bridge group. vectus application developer’s guide . london bridge
group, wellesbourne, warwick, uk, 2001.
[34] london bridge group. vectus technical architecture . london bridge group,
wellesbourne, warwick, uk, 2001.
[35] d.c. marinescu. internet-based workﬂow management: towards a semantic
web, volume 40 of wiley series on parallel and distributed computing . wiley-
interscience, new york, 2002.
[36] m. merz, b. liberman, and w. lamersdorf. using mobile agents to support in-
terorganizational workﬂow-management. international journal on applied artiﬁ-
cial intelligence , 11(6):551–572, 1997.
[37] m. merz, b. liberman, and w. lamersdorf. crossing organisational boundaries
with mobile agents in electronic service markets. integrated computer-aided en-
gineering , 6(2):91–104, 1999.
[38] s.p. nielsen, c. easthope, p. gosselink, k. gutsze, and j. roele. using lotus
domino workﬂow 2.0, redbook sg24-5963-00 . ibm, poughkeepsie, usa, 2000.
[39] m. reichert and p. dadam. adeptﬂex: supporting dynamic changes of workﬂow
without loosing control. journal of intelligent information systems , 10(2):93–129,
1998.
[40] h. reijers, j. rigter, and w.m.p. van der aalst. the case handling case. interna-
tional journal of cooperative information systems , 12(3):365–391, 2003.
34[41] h. reijers and k. v oorhoeve. on the optimal design of processes and information
systems (in dutch). informatie , 42:50–57, december 2000.
[42] h. schuschel and m. weske. integrated workﬂow planning and coordination. in
14th international conference on database and expert systems applications , vol-
ume 2736 of lecture notes in computer science , pages 771–781, prague, czech
republic, 2003. springer-verlag, berlin.
[43] software-ley. cosa activity manager . software-ley gmbh, pullheim, germany,
2002.
[44] staffware. staffware case handler — white paper . staffware plc, berkshire, uk,
2000.
[45] m. stonebraker. the integration of rule systems and database systems. tkde ,
4(5):415–423, 1992.
[46] d.m. strong and s.m. miller. exceptions and exception handling in computerized
information processes. acm transactions on information systems , 13(2):206–233,
1995.
[47] tibco. tib/inconcert process designer user’s guide . tibco software inc., palo
alto, ca, usa, 2000.
[48] e. verharen, f. dignum, and s. bos. implementation of a cooperative agent ar-
chitecture based on the language-action perspective. in m. singh, a.. rao, and
m. wooldridge, editors, agent theories, architectures, and languages , volume
1365 of lecture notes in computer science , pages 31–44. springer-verlag, berlin,
1998.
[49] e.m. verharen, f. dignum, and s. bos. implementation of a cooperative agent
architecture based on the language-action perspective. in intelligent agents , vol-
ume 1365 of lecture notes in artiﬁcial intelligence , pages 31–44. springer-verlag,
berlin, 1998.
[50] peter wegner. why interaction is more powerful than algorithms. communications
of the acm , 40(5):80–91, 1997.
[51] m. weske. formal foundation, conceptual design, and prototypical implemen-
tation of workﬂow management systems. habilitation’s thesis, university ofm¨unster, germany, 2000.
[52] m. weske. formal foundation and conceptual design of dynamic adaptations in
a workﬂow management system. in r. sprague, editor, proceedings of the thirty-
fourth annual hawaii international conference on system science (hicss-34) .
ieee computer society press, los alamitos, california, 2001.
35about the authors
wil van der aalst is a full professor of information systems and head of the information
systems department of the faculty of technology management at eindhoven university
of technology. currently he is also an adjunct professor at queensland university of
technology (qut) working within the centre for information technology innovation
(citi). his research interests include information systems, simulation, process mining,
petri nets, process models, workﬂow management systems, veriﬁcation techniques, en-
terprise resource planning systems, computer supported cooperative work, and interorga-
nizational business processes.
mathias weske is a professor of computer science and chair of the business process
technology research group at hasso plattner institute for software systems engineering at
the university of potsdam. his research interests include workﬂow management, business
process management, software architectures for process-oriented information systems,
service oriented computing, and software product lines. he is a member and vice chair of
the executive committee of gi sig emisa (german computer science society special
interest group on development methods for information systems and their application),
and a member of ieee and acm.
dolf gr ¨unbauer is a senior software engineer of flower, a product developed by pallas
athena. he has a master of science degree in applied mathematics at the univeristy
of twente. since 1990 he has been working on architecture, design, theoretical founda-
tion and implementation of workﬂow- and case handling systems for different companies
across the software industry.
36