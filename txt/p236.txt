emit: a process mining tool
b.f. van dongen and w.m.p. van der aalst
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
b.f.v.dongen@tue.nl
abstract. process mining oﬀers a way to distill process models from
event logs originating from transactional systems in logistics, banking,
e-business, health-care, etc. the algorithms used for process mining are
complex and in practise large logs are needed to derive a high-qualityprocess model. to support these eﬀorts, the process mining tool emit
has been built. emit is a tool that imports event logs using a standard
xml format as input. using an extended version of the α-algorithm
[3, 8] it can discover the underlying process model and represent it in
terms of a petri net. this petri net is then visualized by the program,
automatically generating a “smart” layout of the model. to support thepractical application of the tool, various adapters have been developed
that allow for the translation of system-speciﬁc logs to the standard
xml format. as a running example, we use an event log generated bythe workﬂow management system staﬀware.
1 introduction
during the last decade workﬂow management concepts and technology [2, 4, 10,
11] have been applied in many enterprise information systems. workﬂow man-
agement systems such as staﬀware, ibm mqseries, cosa, etc. oﬀer generic
modeling and enactment capabilities for structured business processes. by mak-ing graphical process deﬁnitions, i.e., models describing the life-cycle of a typ-
ical case (workﬂow instance) in isolation, one can conﬁgure these systems to
support business processes. besides pure workﬂow management systems manyother software systems have adopted workﬂow technology. consider for example
erp (enterprise resource planning) systems such as sap, peoplesoft, baan
and oracle, crm (customer relationship management) software, etc. despite
its promise, many problems are encountered when applying workﬂow technol-
ogy. one of the problems is that these systems require a workﬂow design, i.e., adesigner has to construct a detailed model accurately describing the routing of
work. modeling a workﬂow is far from trivial: it requires deep knowledge of the
workﬂow language and lengthy discussions with the workers and managementinvolved.
instead of starting with a workﬂow design, one could also start by gathering
information about the workﬂow processes as they take place. in this paper it isassumed that it is possible to record events such that (i) each event refers to a
task (i.e., a well-deﬁned step in the workﬂow), (ii) each event refers to a case
(i.e., a workﬂow instance), and (iii) events are totally ordered. most informationsystem will oﬀer this information in some form. note that (transactional) systems
such as erp, crm, or workﬂow management systems indeed provide event logs.it is also important to note that the applicability of process mining is not limited
to workﬂow management systems. the only requirement is that it is possible to
collect logs with event data. these event logs are used to construct a processspeciﬁcation which adequately models the behavior registered.
the term process mining is used for the method of distilling a structured
process description from a set of real executions. in this paper we do not givean overview of related work in this area. instead we refer to the survey paper [6]
and a special issue of computers in industry [7].
in this paper, the process mining tool emit is presented. using an example
log generated by staﬀware, we illustrate the various aspects of the tool. in section
3, the xml format used to store logs is described. section 4 discusses the three
main steps of the mining process. section 5 discusses the export and visualization
of the petri nets discovered in the mining process. finally, we conclude the paper.
2 running example
to illustrate the functionality of emit , an example log generated by the staﬀware
[12] is used. since staﬀware is one of the leading workﬂow management systems,it is a nice illustration of the practical applicability of emit . for presentation
purposes we consider a log holding only six cases, as shown in table 1.
although the log presented here is rather small (only six cases) it is already
hard to ﬁnd the structure of the underlying workﬂow net by just examining
the log. therefore, a tool like emit is needed. however, before emit can be
used, the log is translated into a generic input format that is tool-independent,i.e., emit does not rely on the speciﬁc format used by a system like staﬀware.
instead there is a “staﬀware adapter” translating staﬀware logs to the xml
format described in the next section.
3 a common xml log format
every log ﬁle contains detailed information about the events as they take place.however, commercial workﬂow system use propriety logging formats. therefore,
emit uses a tool-independent xml format. since events in the log refer to state
changes a ﬁrst step is to describe the states in which each speciﬁc task can be.for this purpose we use a transactional model.
3.1 a transactional model
to describe the state of a task the finite state machine (fsm) shown in fig-
ure 1 is used. the fsm describes all possible states of a task from creation to
completion. the arrows in this ﬁgure describe all possible transitions betweenstates and it is assumed that these transitions are atomic events (i.e. events that
take no time) that appear in the log. all states and the transitions between those
states will be discussed below.case 1 | case 4
step description event user yyyy/mm/dd hh:mm | step description event user yyyy/mm/dd hh:mm--------------------------------------------------------------- | ---------------------------------------------------------------
start bvdongen@staffw_ 2002/04/18 09:05 | start bvdongen@staffw_ 2002/04/18 09:05
a processed to bvdongen@staffw_ 2002/04/18 09:05 | a processed to bvdongen@staffw_ 2002/04/18 09:05a released by bvdongen@staffw_ 2002/04/18 09:05 | a released by bvdongen@staffw_ 2002/04/18 09:05
b processed to bvdongen@staffw_ 2002/04/18 09:05 | c processed to bvdongen@staffw_ 2002/04/18 09:05
b released by bvdongen@staffw_ 2002/04/18 09:05 | c released by bvdongen@staffw_ 2002/04/18 09:05d processed to bvdongen@staffw_ 2002/04/18 09:05 | f processed to bvdongen@staffw_ 2002/04/18 09:05e processed to bvdongen@staffw_ 2002/04/18 09:05 | e processed to bvdongen@staffw_ 2002/04/18 09:05d released by bvdongen@staffw_ 2002/04/18 09:06 | f released by bvdongen@staffw_ 2002/04/18 09:06e released by bvdongen@staffw_ 2002/04/18 09:06 | e released by bvdongen@staffw_ 2002/04/18 09:06
g processed to bvdongen@staffw_ 2002/04/18 09:06 | h processed to bvdongen@staffw_ 2002/04/18 09:06
g released by bvdongen@staffw_ 2002/04/18 09:06 | h released by bvdongen@staffw_ 2002/04/18 09:06i processed to bvdongen@staffw_ 2002/04/18 09:06 | i processed to bvdongen@staffw_ 2002/04/18 09:06i released by bvdongen@staffw_ 2002/04/18 09:06 | i released by bvdongen@staffw_ 2002/04/18 09:07
terminated 2002/04/18 09:06 | terminated 2002/04/18 09:07
case 2 | case 5
step description event user yyyy/mm/dd hh:mm | step description event user yyyy/mm/dd hh:mm--------------------------------------------------------------- | ---------------------------------------------------------------
start bvdongen@staffw_ 2002/04/18 09:05 | start bvdongen@staffw_ 2002/04/18 13:47
a processed to bvdongen@staffw_ 2002/04/18 09:05 | a processed to bvdongen@staffw_ 2002/04/18 13:47a released by bvdongen@staffw_ 2002/04/18 09:05 | a released by bvdongen@staffw_ 2002/04/18 13:49
b processed to bvdongen@staffw_ 2002/04/18 09:05 | c processed to bvdongen@staffw_ 2002/04/18 13:49
b released by bvdongen@staffw_ 2002/04/18 09:05 | c released by bvdongen@staffw_ 2002/04/18 13:53d processed to bvdongen@staffw_ 2002/04/18 09:05 | f processed to bvdongen@staffw_ 2002/04/18 13:53e processed to bvdongen@staffw_ 2002/04/18 09:05 | e processed to bvdongen@staffw_ 2002/04/18 13:53e released by bvdongen@staffw_ 2002/04/18 09:06 | e released by bvdongen@staffw_ 2002/04/18 13:56d released by bvdongen@staffw_ 2002/04/18 09:06 | f released by bvdongen@staffw_ 2002/04/18 13:57
g processed to bvdongen@staffw_ 2002/04/18 09:06 | h processed to bvdongen@staffw_ 2002/04/18 13:57
g released by bvdongen@staffw_ 2002/04/18 09:06 | h released by bvdongen@staffw_ 2002/04/18 13:59i processed to bvdongen@staffw_ 2002/04/18 09:06 | i processed to bvdongen@staffw_ 2002/04/18 13:59i released by bvdongen@staffw_ 2002/04/18 09:06 | i released by bvdongen@staffw_ 2002/04/18 14:04
terminated 2002/04/18 09:07 | terminated 2002/04/18 09:07
case 3 | case 6
step description event user yyyy/mm/dd hh:mm | step description event user yyyy/mm/dd hh:mm--------------------------------------------------------------- | ---------------------------------------------------------------
start bvdongen@staffw_ 2002/04/18 09:05 | start bvdongen@staffw_ 2002/04/18 13:48
a processed to bvdongen@staffw_ 2002/04/18 09:05 | a processed to bvdongen@staffw_ 2002/04/18 13:48a released by bvdongen@staffw_ 2002/04/18 09:05 | a released by bvdongen@staffw_ 2002/04/18 13:48
c processed to bvdongen@staffw_ 2002/04/18 09:05 | b processed to bvdongen@staffw_ 2002/04/18 13:48
c released by bvdongen@staffw_ 2002/04/18 09:05 | b released by bvdongen@staffw_ 2002/04/18 13:53f processed to bvdongen@staffw_ 2002/04/18 09:05 | d processed to bvdongen@staffw_ 2002/04/18 13:53e processed to bvdongen@staffw_ 2002/04/18 09:05 | e processed to bvdongen@staffw_ 2002/04/18 13:53e released by bvdongen@staffw_ 2002/04/18 09:06 | d released by bvdongen@staffw_ 2002/04/18 13:56f released by bvdongen@staffw_ 2002/04/18 09:06 | e released by bvdongen@staffw_ 2002/04/18 14:10
h processed to bvdongen@staffw_ 2002/04/18 09:06 | g processed to bvdongen@staffw_ 2002/04/18 14:10
h released by bvdongen@staffw_ 2002/04/18 09:06 | g released by bvdongen@staffw_ 2002/04/18 14:13i processed to bvdongen@staffw_ 2002/04/18 09:06 | i processed to bvdongen@staffw_ 2002/04/18 14:13i released by bvdongen@staffw_ 2002/04/18 09:06 | i released by bvdongen@staffw_ 2002/04/18 14:15
terminated 2002/04/18 09:07 | terminated 2002/04/18 14:15
table 1. a staﬀware workﬂow log.
newsuspended
scheduled active complete
terminatedschedule resume suspend
start complete
abort withdraw
fig. 1. an fms showing the states and transitions of a task.–new: this is the state in which a task starts. after creation of the task this is
the initial state. from this state the task can be scheduled (i.e. it will appearas a work-item in the worklist). in the staﬀware example, this schedule event
is shown as the “processed to” line.
–scheduled : when a task is sent to one or more users, it becomes scheduled.
after that, two things can happen. either the task is picked up by a user whostarts working on it, or it is withdrawn from the worklist. the “start” event is
not logged by staﬀware, but most other systems do, e.g., inconcert logs this
event as “task
acquire”. staﬀware logs the “withdraw” event. again
staﬀware uses a diﬀerent term (“withdrawn” rather than “withdraw”).
–active : this state describes the state of the task while a user is actually
working on it. the user is for example ﬁlling out the form that belongsto this task. now three things can happen. first, a task can be suspended
(for example when the user goes home at night while the work is not com-
pletely ﬁnished). second, the task can be completed successfully and third,the task can be aborted. in the staﬀware log, only the “complete” event
appears as “released by”. the “abort” and “suspend” events are not logged
in staﬀware.
–completed : now the task is successfully completed.
–suspended : when a task is suspended, the only thing that can happen is that
it becomes active again by resuming the task. note that it is not possible for
a task to be aborted or completed from this state. before that, it has beenresumed again.
–terminated : now the task is not successfully completed, but it cannot be
restarted again.
it can be seen that the staﬀware example does not contain all the possible
information. for example, it cannot be shown at which moment an employeeactually started working on a task. on the other hand, the staﬀware log contains
information that does not ﬁt into our fsm. some of that information however
can be very useful. therefore, another kind of event is deﬁned, namely normal .
in our example the “start” and “terminated” events that refer to the start and
end of a case have normal as event type.
note that staﬀware is just used as an example. for other systems, e.g., erp
systems, crm systems, or other workﬂow management systems, alternative
mappings are used. however, the resulting mapping is always made onto the
finite state machine described in figure 1.
3.2 xml format
after deﬁning the possible states of a task, a standard format for storing logs
can be deﬁned. this format is described by the following dtd:
1
1the dtd describes the current format of emit. a new and extended format speci-
ﬁed in terms of an xml schema has been deﬁned. future generations of emit will
be based on this format. see http://www.processmining.org for more details.<!element workflow_log (source?,process+)>
<!element source empty>
<!attlist source program cdata #required>
<!element process (case*)>
<!attlist process id id #required>
<!attlist process description cdata "none"><!element case (log_line*)>
<!attlist case id id #required>
<!attlist case description cdata "none">
<!element log_line (task_name, event?, date?, time?, originator?)>
<!element task_name (#pcdata)><!element event empty>
<!attlist event kind (normal|schedule|start|withdraw|
suspend|resume|abort|complete) #required>
<!element date (#pcdata)>
<!element time (#pcdata)>
<!element originator (#pcdata)>
this xml format describes a workﬂow log in the following way. first, the
process that is logged needs to be speciﬁed. in the staﬀware example as shown
in table 1 only one process is shown. then, for each process a number of cases is
speciﬁed. the staﬀware example contains six cases. each of these cases consistof a number of lines in the log. for each line, a “log
line” element is used.
this element typically contains the name of the task that is present in the log.
further, it contains information about the state transition of the task in thetransactional model, a timestamp and the originator of the task. except for the
originator of the task, all this information is used by emit in the mining process.
(the originator information is added for future extensions.) emit can be used
to convert log ﬁles from diﬀerent systems into the common xml format. for this
purpose, external programs are called by emit . the list of programs available
can be extended by anyone who uses the tool to suit their own needs.
4 the mining process
the mining process consists of a number of steps, namely the pre-processing, theprocessing and the post-processing. the core algorithm used in the processing
phase that is implemented in emit is the α-algorithm. this algorithm is not
presented in this paper. for more information the reader is referred to [3, 8, 14]or http://www.processmining.org.
4.1 pre-processing
in the pre-processing phase, the log is read into emit and the log based ordering
relations are inferred based on that log. in order to build these relations, theassumption is made that the events in the log are totally ordered. however,
several reﬁnements can be made. first of all, it is possible to specify which events
should be used in the rediscovering process. when using the default settings, onlythe “complete” event of a task is taken into account. basically, the log on which
the ordering relations will be built is the original log where all entries (elementtype “log
line”) corresponding to event types not selected are removed. however,
if a case contains a “withdraw” or “abort” event and that event is not speciﬁed
then the whole case is excluded. the second option is that parallel relations canbe inferred based on time-information present in the log. as described in [8],
two tasks aandbare considered to be in parallel if and only if in the log, a
is directly followed by bat least once and bis directly followed by aat least
once. however, here the assumption is made that aandbare atomic actions,
while in real situations tasks span a certain time interval. the beginning and
the end of such a task however can be considered atomic. emit is capable of
inferring parallelism for all events of a certain task, if ﬁrst task ais started and
then task bis started before task ahas ended. in order to let emit do this,
the user can give the boundaries of the intervals in terms of event types. for the
staﬀware example, one proﬁle is set to “schedule” and “complete”. for staﬀware
this is a logical deﬁnition since tasks are always scheduled in the same order bythe system, i.e., although things can be executed in parallel, they are scheduled
sequentially. by setting the proﬁle to “schedule” and “complete”, emit is still
able to detect parallelism.
fig. 2. emit pre-processing.
when all options are set, the pre-processing phase can start by clicking the
“build relations” button as shown in figure 2. now, the relations are built asdescribed above, but also the loops of length one and two are identiﬁed. by
clicking the “edit relations” button, the program advances to the processing
phase.
4.2 processing
in the next phase, the core α-algorithm is called. however, since the α-algorithm
cannot deal with loops of length one and two, some reﬁnements are made. firstof all, all tasks that are identiﬁed as a loop of length one (cf. [3, 8]) are taken out
of the set of tasks. these loops are then plugged back in later in the processingphase. second, for all tasks that are identiﬁed as loops of length two, the relations
are changed. if two tasks are identiﬁed as being a loop of length two together,
say task aand task b, then a parallel relation between the two exists, a/bardblb.
this relation is removed and two new relations are added in the following way:
a→bandb→a. more about these reﬁnements can be found in [1].
fig. 3. emit processing.
to build a petri net, the “make petri net (alpha)” button should be clicked
as shown in figure 3. now, the core α-algorithm is called and a petri net is
constructed. when the petri net is built, the loops of length one are added to itand the result is automatically exported to the dotformat. this format serves
as input for the dotprogram [9] that will visualize the petri net in a smart way.
the output created by dotis loaded back into emit again and the result of the
mining algorithm is shown.
when the petri net is constructed, emit is ready for the post-processing
phase.
4.3 post-processing
in this phase, the original log is loaded into the program again. using the original
log and the petri net generated in the processing step, additional informationcan be derived. besides, the relations inferred in the pre-processing phase can
be altered. to calculate additional information for the petri net, the original
log is used. since the petri net that is rediscovered should be able to generatethe same log traces as were given as input, a simple algorithm is used. first,
a token is placed in the source place of the petri net. now, for one case, the
tasks appearing in the log are ﬁred one by one. of course, only the tasks thatare actually used in the pre-processing are taken into account. every time a
token enters a place by ﬁring a transition, a timestamp is logged for this token.when the token is consumed again, timing information is added to the place.
this timing information consist of three parts. first, there is the waiting time .
this is the time a token has spent in a place while the transition consuming thetoken was enabled. second, there is the synchronization time. this is the time
a token spent in a place while the transition consuming the token was not yet
enabled. this typically happens if that transition needs multiple tokens to ﬁre.finally there is the sojourn time, which is the sum of the two. an example of
these times for the place connecting d-complete with g-schedule can be found
in the lower right part of figure 3.
this process is repeated for all cases. if everything goes well, then a message
is given and the picture showing the petri net is updated. this update is done
to show the probabilities for each choice in the petri net. if a place has multiple
outgoing arcs, a choice has to be made. the probability that each arc is chosenis basically the number of occurrences of the transition on that arc in the log
divided by the sum of all occurrences of all transitions with an incoming arc
from that place. the timing information for each place can be made visible inthe lower right corner of the window by just clicking on a speciﬁc place in the
picture. some metrics for the waiting time, the synchronization time and the
sojourn time are shown.
if, when replaying the original log, a transition is unable to ﬁre, a message
is generated stating the name of the transition. such a message is only given
for the ﬁrst error. the second error message that can be generated is that after
completing a case there are still tokens remaining in the net. in order to solveproblems generated by the program, it is possible to change the set of ordering
relations that are inferred in the pre-processing phase. by clicking on a transition
in the petri net, all relations involving that transition will be shown (except the# relation, which represents the fact that two tasks have no causal or parallel
relation). these relations can then be altered.
5 exporting the petri net
after the petri net has been rediscovered, it can be exported. by clicking the
“export petri net” button the petri net is saved in three diﬀerent formats. each
format is saved in a separate ﬁle(s):
–low detail dot : this output format is used to export only the basic petri net
with probabilities added to all arcs (if available). no timing informationwill be shown in this output ﬁle. together with the dotﬁle, a number of
html ﬁles are created. these ﬁles can be used together with the dot“jpg”
and “imap” export to make a web page. each of these html ﬁles contain
timing information for a speciﬁc place.
–high detail dot : this output format is used to export the basic petri net with
probabilities added to all arc (if available) and timing information.–woﬂan : this output format can be imported by woﬂan for further analysis
[13]. woﬂan supports veriﬁcation of the discovered model.
fig. 4. emit post-processing.
after exporting the discovered model in various formats, some options for dot
can be set. the “p-net orientation” setting speciﬁes whether the petri net should
be draw from left to right or from top to bottom. the “page size” setting can
be set to “a4” or “letter”. if these options are set, dotc a nb eu s e dt oc r e a t e
pictures and other exports. the buttons “make jpg/map” and “make ps/jpg”
can be used to generate the graphics ﬁles. this way emit provides several ways
to visualize the mining result.
6 conclusion
in this paper emit is presented as a tool to mine process models from timed
logs. the whole conversion process from a log ﬁle in some unspeciﬁed format
towards a petri net representation of a process model is described in a numberof diﬀerent steps. along the way, an example is used to illustrate the use of
the tool. we invite the reader to use the tool. the tool is available for down-
load from http://www.processmining.org. this download includes some 30 ex-
amples, both artiﬁcial and practical. the example presented in this paper is
called “sw
ex14.log” and it is converted into “sw ex14.xml”. both ﬁles are
included in the download.
in the future we plan to extend the tool in various ways. first of all, we
plan to enhance the mining algorithm to be able to deal with complex process
patterns, invisible/duplicate tasks, noise, etc. [1]. second, we are developing ad-
ditional adaptors to extract information from more real-life systems (e.g., sapand flower). third, we are working on embedding parts of the system in the
aris process performance monitoring (ppm) tool and exporting the result to
bpr tools like protos. we are extending the scope of the mining process toinclude organizational data, data ﬂow, social network analysis, etc. last but
not least, we are merging the tools emit, thumb [14], and minson [5] into anintegrated tool.
references
1. a.k.a. de medeiros and w.m.p. van der aalst and a.j.m.m. weijters. workﬂow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science ,p a g e s
389–406. springer-verlag, berlin, 2003.
2. w.m.p. van der aalst, j. desel, and a. oberweis, editors. business process man-
agement: models, techniques, and empirical studies , volume 1806 of lecture notes
in computer science . springer-verlag, berlin, 2000.
3. w.m.p. van der aalst and b.f. van dongen. discovering workﬂow performance
models from timed logs. in y. han, s. tai, and d. wikarski, editors, international
conference on engineering and deployment of cooperative information systems
(edcis 2002) , volume 2480 of lecture notes in computer science , pages 45–63.
springer-verlag, berlin, 2002.
4. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
5. w.m.p. van der aalst and m. song. mining social networks: uncovering interac-
tion patterns in business processes. in m. weske, b. pernici, and j. desel, editors,international conference on business process management (bpm 2004) ,l e c t u r e
notes in computer science, springer-verlag, berlin, 2004.
6. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
7. w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining ,s p e c i a l
issue of computers in industry, volume 53, number 3. elsevier science publishers,
amsterdam, 2004.
8. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining: dis-
covering process models from event logs. qut technical report, fit-tr-2003-03,queensland university of technology, brisbane, 2003. (accepted for publication
in ieee transactions on knowledge and data engineering.).
9. at&t. graphviz - open source graph drawing software (including dot).
http://www.research.att.com/sw/tools/graphviz/.
10. s. jablonski and c. bussler. workﬂow management: modeling concepts, architec-
ture, and implementation . international thomson computer press, london, uk,
1996.
11. f. leymann and d. roller. production workﬂow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
12. staﬀware. staﬀware 2000 / gwd user manual . staﬀware plc, berkshire, united
kingdom, 2000.
13. h.m.w. verbeek, t. basten, and w.m.p. van der aalst. diagnosing workﬂow
processes using woﬂan. the computer journal , 44(4):246–279, 2001.
14. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.