precision and fitness in object-centric process
mining
jan niklas adams
chair of process and data science
rwth aachen university
aachen, germany
niklas.adams@pads.rwth-aachen.dewil m.p. van der aalst
chair of process and data science
rwth aachen university
aachen, germany
wvdaalst@pads.rwth-aachen.de
abstract —traditional process mining considers only one single
case notion and discovers and analyzes models based on this.
however, a single case notion is often not a realistic assumption
in practice. multiple case notions might interact and inﬂuence
each other in a process. object-centric process mining introduces
the techniques and concepts to handle multiple case notions. so
far, such event logs have been standardized and novel process
model discovery techniques were proposed. however, notions for
evaluating the quality of a model are missing. these are necessary
to enable future research on improving object-centric discovery
and providing an objective evaluation of model quality. in this
paper, we introduce a notion for the precision and ﬁtness of an
object-centric petri net with respect to an object-centric event log.
we give a formal deﬁnition and accompany this with an example.
furthermore, we provide an algorithm to calculate these quality
measures. we discuss our precision and ﬁtness notion based on
an event log with different models. our precision and ﬁtness
notions are an appropriate way to generalize quality measures
to the object-centric setting since we are able to consider multiple
case notions, their dependencies and their interactions.
keywords —object-centric process mining, precision, fitness
i. i ntroduction
in the past years, process mining [1] has introduced a data-
driven way to discover and analyze processes. the introduced
techniques and algorithms enable organizations to discover the
true underlying process from the data of its execution rather
than manually designing what is assumed to be the process.
these techniques work on an event log which records the
executed activities for different cases. each event has an activ-
ity and is attributable to exactly one case, e.g., the customer,
order, patient, etc.. the attribute used to assign an event to
a case is called the case notion. the event log, therefore,
describes in which order the activities can be executed for
such cases.
however, this already shows the central limitation of tra-
ditional process mining: the single case notion. in practice,
the assumption that every event is only related to exactly
one case is unrealistic. one such example could be an event
describing activity load cargo for objects plane1 and bag1
at2021-10-02 17:23 . if one considers this event and the
corresponding event log, what would be the case notion? the
plane to be loaded with cargo or the bag to be loaded into
we thank the alexander von humboldt (avh) stiftung for supporting our
research.the plane? by focusing on only one case notion one would
omit the behaviour of the other case notions, e.g., focusing
on only the plane would omit the process of checking in and
transporting baggage. uniting the different case notions into
one single, comprehensive process model allows us to consider
dependencies between the executions that are not available
otherwise.
object-centric process mining [2] addresses these problems
and aims to deﬁne techniques and standards for retrieving
and analyzing comprehensive, easy-to-understand models of
processes with multiple case notions. an event log format [3]
and a ﬁrst discovery technique [4] have already been intro-
duced. this discovery technique yields an object-centric petri
net. however, the missing key to enable further research on
object-centric process discovery on the one hand and objective
model evaluation on the other hand are quality criteria that link
object-centric model and log and specify the conformance of
the model. in traditional process mining quality criteria like
precision, ﬁtness, simplicity and generality are used to express
the quality of a model with respect to a log [1]. these can
be used to compare different models of the same event log,
evaluate the results of different discovery algorithms, specify
the conformance of a handmade process model and more.
so far, there are no quality measures to evaluate an object-
centric petri net. to facilitate further research we need a way
to describe the quality of an object-centric petri net, e.g., how
well it ﬁts the data or how precisely it describes the data.
due to multiple case notions and many-to-many relationships
ﬁtness and precision notions from traditional process mining
can not trivially be adapted to the object-centric setting.
in this paper, we introduce a ﬁtness and precision notion for
object-centric petri nets with respect to object-centric event
logs. our ﬁtness notion can be seen as an object-centric
adaption to replaying traces [5], the precision notion as a
generalization of the escaping edges precision [6].
the paper is structured as follows. in section ii, we dis-
cuss other approaches of handling multiple case notions. in
section iii, we introduce object-centric event logs and petri
nets and illustrate them on the basis of a running example. in
section iv, we formally introduce our ﬁtness and precision
notion. this is further accompanied by our running example.
in section v, we present an algorithm to calculate bothprecision and ﬁtness. we use three different models with
respect to an event log in section vi to evaluate our introduced
notions. we conclude this paper in section vii.
ii. r elated work
in this section, we introduce the related work on handling
multiple case notions and the techniques to determine ﬁtness
and precision in traditional process mining.
the different approaches to handle multiple case notions
can be grouped into three categories: interacting processes,
colored petri net approaches, and novel modeling techniques.
we discuss the corresponding approaches, their disadvantages
and how object-centric petri nets relate to these.
several approaches to handle multiple case notions use
individual processes with some notion for interaction between
them. the ﬁrst method that was introduced is proclets [7],
describing interacting workﬂow processes. over time, this
concept was extended to cover many-to-many relationships [8]
and different analysis techniques [9]. another modeling tech-
nique is artifact-centric modeling [10], [11]. process discovery
techniques for artifact-centric modeling have been developed
[12], as well as conformance checking methods [13], [14].
to deal with the complexity of artifact-centric modeling, [15]
introduced a restricted artifact-centric process model deﬁnition
where no concurrency is allowed within one artifact. the main
disadvantage of these approaches is the absence of a single
comprehensive model of the process as they show interacting
individual processes. furthermore, models tend to get too
complex and hard to understand.
the second approach to handle multiple case notions are
colored petri nets. db-nets [16] introduce a modeling tech-
nique to include a data-perspective into a process model
using a colored petri net. however, the modeling is hard to
understand for a user and it targeted to a modeling, not a
mining setting. furthermore, there is a plethora of approaches
that uses colored petri nets with some restrictions, e.g., no
concurrency within one case notion and discarding variable
one-to-many relationships, which restrictions render them in-
feasible in many settings. the discussion of these approaches
is outside the scope of this paper.
the third group includes newly proposed modeling tech-
niques to condense a process with multiple case notions to
one model. object-centric behavioral constraints (ocbc)
[17] are a recently introduced approach to show behavior
and relationships of different objects in one model. discovery
algorithms as well as quality measures have been proposed for
this discovery technique [18]. however, since ocbc builds
on top of a data format that records the whole evolution of
a database the models tend to get complex and the proposed
techniques are not scalable. multiple view point models [19]
introduce less complex models where the discovery is more
scalable. a process model can be constructed by correlating
events via objects. [4] extends this approach to discover object-
centric petri nets, petri nets with places of different colors
and arcs that can consume a variable amount of tokens.
object-centric petri nets can model a process with multiplecase notions in one single model, consider one-to-many and
many-to-many relations, concurrency within case notions and
a scalable discovery algorithm is available. therefore, object-
centric petri nets alleviate most of the drawbacks from other
approaches in the related work with respect to multiple case
notions.
since quality metrics play an important role in traditional
process mining several techniques to determine ﬁtness and
precision have been proposed. techniques for determining ﬁt-
ness include causal footprints, token-based replay, alignments,
behavioral recall and eigenvalue recall [20]. in this paper,
we use an adaptation of a replaying ﬁtness, i.e., whether the
preoccurring activities of an event can be replayed on the
object-centric petri net. techniques for determining precision
include escaping edges precision, negative event precision and
projected conformance checking [21]. the adaptation of these
techniques to object-centric event logs and petri nets each pose
their own challenges. i.e., dealing with multiple case notions
and variable arcs in the petri net. in this paper, we propose
a generalization of the escaping edges precision [6] which
links an event to a state in the process model and determines
the behavior allowed by model and log and, subsequently, the
precision. this can also be seen as an object-centric adaptation
of replaying history on the process model to determine ﬁtness
and precision [22].
iii. o bject -centric process mining
object-centric process mining moves away from the single
case notion of traditional process mining, i.e., every event is
related to exactly one case, and opens up the possibility for
one event being related to multiple, different case notions.
the foundations were deﬁned in [4]. we introduce these key
concepts of object-centric process mining in this section. these
are accompanied by a running example of a ﬂight process that
considers planes and how the associated baggage is handled.
it describes the operations of the plane, i.e., fueling, cleaning
and lift off, and the handling of baggage, i.e., check-in, loading
and pick up. we ﬁrst introduce some basic deﬁnitions and
notations.
deﬁnition 1 (power set, multiset, sequence) .let x denote a
set.p(x)denotes the power set of these elements, the set of
all possible subsets. a multiset b:x!nassigns a frequency to
each element in the set and is denoted by [xm]forx2xand
frequencym2n. a sequence of length nassign positions
to elements x2xof a set:f1;:::;ng!x. it is denoted
by=hx1;:::;xni. the concatenation of two sequences is
denoted with 12. concatenation with an empty sequence
does not alter a sequence hi=. the number of elements in
a sequenceis given bylen().
the central part of object-centric process mining are objects.
each object is of exactly one object type.
deﬁnition 2 (object and object types) .letabe the universe
of activities. let uobe the universe of objects and uotbe the
universe of object types. the function otyp:uo!uotmapstable i
example of an object -centric event log l1
event id activity plane baggage
e1 fuel plane p1
e2 check-in b1
e3 check-in b2
e4 load cargo p1 b1,b2
e5 lift off p1
e6 unload p1 b1,b2
e7 pick up @ dest b1
e8 pick up @ dest b2
e9 clean p1
e10 fuel plane p2
e11 check-in b3
e12 check-in b4
e13 load cargo p2 b3,b4
e14 lift off p2
e15 unload p2 b3,b4
e16 clean p2
e17 pick up @ dest b3
e18 pick up @ dest b4
each object to its type.
the two universes, of objects and of object types, contain
all possible objects and all possible object types. every object
o2uohas a typeotyp(o). in our example we are considering
object types ot=fplanes;baggageg. we have, in total, six
objects:o=fp1;p2;b1;b2;b3;b4gof which two are planes
and four are baggage, indicated by the ﬁrst letter of the object,
i.e.,otyp(p1)=otyp(p2)=plane;otyp(b1)==otyp(b4)
=baggage . in general, we are interested in recording the
behaviour of objects over time, i.e., at which point in time
activities were executed that concern objects. this is done
using an object-centric event log. the ocel format [3]
records the corresponding activity, timestamp and objects of
each object type for an event. additional attributes are stored
for each object. we use a reduced deﬁnition of the object-
centric event log to focus on the aspects relevant for this paper.
deﬁnition 3 (object-centric event log) .letuebe the
universe of event identiﬁers. an object-centric event log is a tu-
plel=(e;ot;o; act;omap;)of event identiﬁers eue,
object types otuot, objectsouo, a mapping function
from event to activity act:e!a, a mapping function from
event to related objects omap:e!p(o)and a total order.
this deﬁnition gives us event identiﬁers of which each
is related to an activity and to some objects. these event
identiﬁers are subject to a total order, i.e., by the time of
their occurrence. an example of an object-centric event log
is depicted in table i. it consists of the events with the
identiﬁerse=fe1;:::;e 18g. the event identiﬁer is unique
and provides the order of events. the activity of an event,
e.g.,act(e4)=load cargo is given as well as the related ob-
jects, e.g.,omap(e4)=fp1,b1,b2g. discovering process mod-
els from event data plays a central role in process mining as
it is a data-driven way to uncover the true nature of a process.
one way to represent process models are petri nets [1]. van der
aalst and berti [4] introduce the concept of object-centric petri
fig. 1. example of an object-centric petri net ocpn 1.
nets and provide an algorithm to discover an object-centric
petri net from an object-centric event log. an object-centric
petri net is a colored petri net where the places are colored as
one of the object types and some arcs can consume a variable
amount of tokens.
deﬁnition 4 (object-centric petri net) .letn=(p;t;f;l )
be a petri net consisting of places p, transitions t, ﬂow
relationsf(tp)[(pt)and a labeling function l:t9a.
an object-centric petri net is a tuple ocpn =(n;pt;f var)of
petri netn, a mapping of places to object types pt:p!ot
and a set of variable arcs fvarf. we introduce the notations:
t=fp2pj(p;t)2fgis the preset of a transition t.
t=fp2pj(t;p)2fgis the postset of a transition t.
tpl(t)=fpt(p)jp2t[tgare the object types associated
to a transition t.
tplnv(t)=fpt(p)jp2p^f(p;t);(t;p)g\(fnfvar)6=;gare
the non-variable object types associated to transition t.
an example of an object-centric petri net for the ﬂight
process is depicted in figure 1. places are indicated by circles
and transitions are indicated by rectangles. arcs are indicated
by arrows while variable arcs are indicated by double arrows.
the object type of a place is shown by its color, blue being
type plane and red being type baggage . the label of each
transition is depicted inside the transition itself. the transition
with no label is a so called silent transition. we refer to this
transition as . this deﬁnition of the petri net itself is not
sufﬁcient to describe a process and the behavior it allows. we
need to introduce further concepts. we, ﬁrst, introduce the
concept of a marking. places of object-centric petri nets can
hold tokens of the same object type. the marking of an object-
centric petri net can be expressed as objects being associated
to places of the corresponding object type.
deﬁnition 5 (marking of an object-centric petri net) .let
ocpn =(n;pt;f var)be an object-centric petri net withn=(p;t;f;l ). the set of possible tokens is described by
qocpn =f(p;o)2puojpt(p)=otyp(o)g. a marking is a
multiset of tokens m2b(qocpn ).
a marking describes the current state of the petri net. it
states which objects are contained in which places. we can
move between markings by ﬁring transitions. the concept of
a binding is used to describe this. a binding is a tuple of a
transition and the involved objects of every object type. the
objects of the corresponding color in the binding are consumed
in the input places and produced in the output places. a
binding is only enabled at a given marking if each input place
of the corresponding transition holds at least the tokens of this
object type contained in the binding.
deﬁnition 6 (binding execution) .let ocpn =(n;pt;f var)be
an object-centric petri net with n=(p;t;f;l ).b=f(t;b)2
t(uot9p(uo))jdom(b)=tpl(t)^8ot2tplnv(t)jb(ot)j=1g
deﬁnes the set of all possible bindings. the consumed tokens of
a binding (t;b)2bare deﬁned by cons(t;b)=[(p;o)2qocpnj
p2t^o2b(pt(p))]and the produced tokens are deﬁned by
prod(t;b)=[(p;o)2qocpnjp2t^o2b(pt(p))]. a binding
(t;b)2bin marking mis enabled if cons(t;b)m. the
execution of an enabled binding in marking mleads to
markingm0=m cons(t;b)+prod(t;b). this is denoted by
m(t;b)   !m0
m(t;b)   !m0indicates that the occurrence of binding
(t;b)in marking mleads to marking m0. multiple sub-
sequent enabled bindings can be encoded as sequence
=h(t1;b1);:::; (tn;bn)i2b. a sequence that starts in mark-
ingm0and results in marking mnis encoded as m0  !mn.
we can take a binding at the load cargo transition of the petri
net in figure 1 as an example. we assume a marking where
the input places of load cargo contain plane p1and baggages
b1;b2according to their color [(pl3;p1);(pl4;b1);(pl4;b2)].
in this state of the petri net the binding of load cargo and
p1;b1;b2is enabled since the input places of the transition
contain enough tokens of objects contained in the binding.
the binding can be executed and leads to a new marking
where the tokens of p1;b1;b2moved from the input to the
output places of load cargo . we can construct a sequence of
such enabled bindings that describes the execution of several
bindings after each other. in this way, we can express that one
marking is reachable from another marking in the petri net.
we deﬁne initial and ﬁnal markings. together with the object-
centric petri net these form an accepting object centric petri
net. all binding sequences starting from an initial marking and
ending in a ﬁnal marking form the accepted behavior of that
accepting object-centric petri net.
deﬁnition 7 (accepting object-centric petri net) .let
ocpn =(n;pt;f var)be an object-centric petri net
withn=(p;t;f;l )and letminit;mfinalb(qocpn)
be initial and ﬁnal markings of that petri net.
ocpna=(ocpn;minit;mfinal) is a tuple that
describes an accepting object-centric petri net. =f2bjm2minit^m02mfinal^minit  !mfinalg
describes all the binding sequences, i.e., the accepted
behavior of the petri net.
in our example, an accepted behavior is a binding sequence
that starts in a marking with only tokens in the places pl1and
pl2and ends in a marking with only tokens in the places pl10
andpl11. the algorithm of [4] can be used to discover such
accepting object-centric petri nets.
these concepts are sufﬁcient to describe the behavior al-
lowed by an object-centric petri net. starting in an initial
marking all binding sequences are allowed that lead to a ﬁnal
marking. however, if we consider our event log in table i
and our model in figure 1 the question arises of how well
the process model describes the object-centric event log. so
far research on object-centric process mining has focused
on specifying standardized event log formats and discover-
ing models. the missing key to enable further research on
improving object-centric process discovery are quality criteria
for a discovered object-centric model.
iv. f itness and precision for object -centric petri
nets
generally speaking, ﬁtness and precision compare the be-
haviour seen in a data set to the behaviour possible in a
model. the more behavior of the data set the model allows
the ﬁtter it is. the more behaviour the model allows that is
not covered by the data set the more imprecise it is. this
general notion of ﬁtness and precision can be adapted to event
logs and process models by comparing the recorded activity
sequences in the event log to the possible activity sequences in
the process model [22] in traditional process mining. however,
this can not easily be adapted to object-centric event logs and
petri nets. the main problem is multiple case notions of an
event. there is no single sequence of previously occurring
activities for an event anymore. multiple involved objects are
associated to different activity sequences that were previously
executed for them. furthermore, even if there is only one
object involved in an event, an activity sequence of one object
might be dependent on the occurrence of an activity sequence
of another object. compare the exemplary event log in table i.
before event e5,lift off of planep1, happens, the baggages
b1andb2have to be loaded into the plane, making this event
also dependent on these two objects even though they are not
included in the event itself. we deﬁne a context notion that
describes the previously executed activity sequences of the
objects on which an event depends. the dependent objects and
their relevant events are extracted by constructing the event-
object graph.
deﬁnition 8 (event-object graph and context of an event) .
letl=(e;ot;o; act;omap;)be an object-centric event
log, letot2ot be an object type and let o2obe an object.
we introduce the following notations:
gl=(v;k)is the event-object graph of the event log l
withv=eandk=f(e0;e)2eeje0<e^omap(e)\
omap(e0)6=;g.fig. 2. event-object graph of events fe1; : : : ; e 9gof log l1
 e=fe02vj9=he0;:::;ei2e8i2f1;:::;len () 1g
(i;i+1)2kgis the event preset of an event e2e.
 e#o=hact(e1);:::;act(en)isuch that
 fe02ejo2omap(e0)g=fe1;:::;eng
e1<:::<e n
the context of an event is deﬁned as context e(ot) = [e#oj
o2s
e02e[fegomap(e0)^otyp(o)=ot]for anyot2ot.
analogously to the single case notion, each single object
has a simple sequence of its previously occurring activities. we
use a multiset of sequences to cover the possibility of an event
being related to multiple objects of the same object type with
the same sequence. we use the event-object graph to grasp
every object on which the execution of an event depends and
up to which event it depends on this object. the event-object
graph introduces a directed edge between events if they share
an object. for an event e, all other events that have a directed
path to event eform the event preset of e, the events on which
the execution of edepends. the full event-object graph of
eventse1toe9of logl1is depicted in figure 2. take event
e5as an example. the event preset of e5is formed by all events
that are directly or transitively connected to e5, i.e., that have
a directed path the e5in the event-object graph. this includes
e1ande4but alsoe2ande3even though they do not share any
objects with e5. therefore,e5=fe1;e2;e3;e4g. this shows
that the event preset includes all events on which the execution
of an event depends, also the transitive dependencies. to
construct the context we take all objects that appear in the
event preset and the event itself, map them onto their sequence
of activities in the event preset and construct a multiset of the
objects’ sequences for each object type. for e5this includes
the objectsp1;b1;b2. we construct the sequences of these and
combine them to the context contexte5(plane )=[hfuel plane;
load cargoi];contexte5(baggage )=[hcheck-in;load cargoi2]
the context can colloquially be described as everything that
had to happen for this event to occur. we use the context to
link log and model behaviour. the context speciﬁes several
sequences of activities executed for different object types. a
binding sequence of an object-centric petri net, thus, also has
a context if we consider the executed activity sequences of all
the objects in this binding sequence.deﬁnition 9 (context of a binding sequence) .let
ocpna=(ocpn;minit;mfinal) be an accepting
object-centric petri net with ocpn =(n;pt;f var)and
n=(p;t;f;l ). let=h(t1;b1);:::; (tn;bn)ibe a sequence
of enabled bindings of that petri net. we introduce the
following notations:
(t;b)#o=hl(t)iifo2b(typ(o))^t2dom(l)otherwise
(t;b)#o=hi.
#o=(t1;b1)#o:::(tn;bn)#ois the preﬁx of an object
for a binding sequence.
context(ot)=[#ojo2s
i2f1;:::;ngbi(ot)]for anyot2uot
is the multiset of preﬁxes in a binding sequence, also
called context of the binding sequence.
given a binding sequence, we can project it onto the
transition labels for each object that is included in at least
one of the bindings. we do this by projecting each binding of
the sequence onto its transition label if the object is contained
in the binding. if the transition is a silent transition, i.e., it has
no label, this projection yields the empty sequence. the labels
are concatenated into a sequence of labels. this is the preﬁx
for an object. the preﬁxes are united into a multiset for each
object type. to illustrate this we use the petri net from figure 1
and a binding sequence. in our example, a binding consists
of a transition name and bounded objects bof each object
type:1=h(fuel plane;b(plane ) =fp1g;b(baggage ) =fg);
(check-in;b(plane ) =fg;b(baggage ) =fb1g);(check-in;
b(plane ) =fg;b(baggage ) =fb2g);(load cargo;b(plane ) =
fp1g;b(baggage )=fb1,b2g)i. all objects that appear in this
sequence arefp1,b1,b2g. the projected preﬁx for p1is
hfuel plane;load cargoi. for each b1andb2this sequence is
hcheck-in;load cargoi. the context for this binding sequence
is, therefore, context1=contexte5.
given a certain context one can look at all the possible
binding sequences that have this context. all of the states that
are reached after executing any of these binding sequences are
the states that are reachable given this context.
deﬁnition 10 (context reachable states) .letl=
(e;ot;o; act;omap;)be an object-centric event log,
ocpnabe an accepting object-centric petri net and
e2ebe an event. we assume the existence of an oracle
states :(ocpna;contexte)!p(m)that retrieves the reachable
states with a binding sequence of context e.
for a given context one can collect all the states that are
reachable from the initial marking by a binding sequence that
produces the same context. we illustrate this with the model of
figure 1 and contexte5. the binding sequence 1has the same
context and results in marking [(p5,p1 );(p6,b1 );(p6,b2 )].
there are four more binding sequences: 2=1(;fb1g),
3=1(;fb2g),4=1(;fb1g)(;fb2g)and5=1
(;fb2g)(;fb1g).these are binding sequences that
also execute the silent transition. as this does not
inﬂuence the context they all have the same context.
all these possible binding sequences deﬁne the four
reachable states of the context: states (ocpn 1;contexte5) =f[(pl5,p1 );(pl6,b1 );(pl6,b2 )];[(pl5,p1 );(pl8,b1 );(pl6,b2 )];
[(pl5,p1 );(pl6,b1 );(pl8,b2 )];[(pl5,p1 );(pl8,b1 );(pl8,b2 )]g.
the allowed behaviour of the model is speciﬁed by the
enabled activities of the model in any of the reachable states
of a context.
deﬁnition 11 (enabled model activities) .letl=
(e;ot;o; act;omap;)be an object-centric event log,
e2ebe an event, ocpn a=(ocpn;minit;mfinal)be
an accepting object-centric petri net with ocpn =(n;
pt;f var)andn=(p;t;f;l ).enocpn(e)=fl(t)j(t;b)2b^
9m2states (ocpna;contexte)9m02b(qocpn)m(t;b)   !m0g
describes the enabled activities in the model for the corre-
sponding context of an event.
applying this to our running example, we extract the
enabled activities for any state in states (ocpn 1;contexte5).
there are the two enabled activities lift off andpick up , i.e.,
enocpn 1(e5) =flift off;pick up @ destg.
with the so far introduced concepts we can already derive
the context of an event and state the possible behavior of the
model for this context. to retrieve precision and ﬁtness of the
model we now need to specify the behavior that is given by
the log. the behavior recorded in the event log is speciﬁed by
comparing the subsequent activities for the same context.
deﬁnition 12 (enabled log activities) .letl =
(e;ot;o; act;omap;)be an object-centric event log
ande2ebe an event. enl(e)=fact(e0)je02e^
contexte0=contextegdeﬁnes the enabled log activities for the
corresponing context of an event.
we illustrate that using our running example of contexte5.
there is one other event that has the same context which is
e14. the activity that is executed for both events of this context
islift off , i.e.,enl1(e5) =flift offg.
the enabled log and model activities are calculated for the
context of each event and the share of behaviour contained in
the log and also allowed by the model, the ﬁtness, is calculated.
if all the behavior of the log is also allowed in the model it
has a ﬁtness of 1, if all replaying ends up in a ﬁnal marking
one could speak of perfect ﬁtness.
deﬁnition 13 (fitness) .letl=(e;ot;o; act;omap;)
be an object-centric event log and ocpn abe an accepting
object-centric petri net. the ﬁtness of ocpn awith respect to
l is ﬁtness (l;ocpna) =1
jejp
e2ejenl(e)\enocpna(e)j
jenl(e)j.
the enabled log and model activities are calculated for the
context of each event and the share of behaviour allowed
by the model and also contained in the log, the precision,
is calculated. not replayable events are skipped. if all the
behavior allowed by the model is also contained in the log
the model is perfectly precise.
deﬁnition 14 (precision) .letl=(e;ot;o; act;omap;)
be an object-centric event log and ocpn abe an accept-
ing object-centric petri net. ef=fe02ejenocpn a(e0)6=;g
is the set of replayable events. the precision of ocpn aalgorithm 1: enabled model activities of a context
input event log and context;
output enabled model activities of this context;
collect all events that have this context;
foreach event with this context do
extract the binding sequence of visible transitions
from the event preset;
create initial state and append to queue;
while state in queue do
pop ﬁrst state of the queue;
ifbinding sequence is fully replayed in this
state then
add enabled activities of this state to the
results;
ifnext binding enabled then
execute binding and enqueue the resulting
state;
else
enqueue all resulting states from enabled
bindings of silent transitions;
with respect to l is calculated by precision (l;ocpna) =
1
jefjp
e2efjenl(e)\enocpna(e)j
jenocpna(e)j.
the ﬁtness and precision metrics retrieve single compre-
hensive numbers about the quality of the model. we apply
this to our running example. for all the events the enabled
activities of the log are also allowed by the model. the
ﬁtness of the model is, therefore, ﬁtness (l1;ocpn 1)=1. the
only events where the enabled model activities exceed the
enabled log activities are events e5;e6;e14;e15. for each of
these events, pick up @ dest is enabled in the model but
not in the log, i.e., the model allows for baggage to be
picked up before the baggage was unloaded which is not
contained in the event log. we, therefore, retrieve a precision
ofprecision (l1;ocpn 1)=0:89.
v. c alculating precision and fitness
in this section, we discuss an algorithm to calculate preci-
sion and ﬁtness. our algorithm is based on replaying the events
on the model. the implementation of our algorithm is available
on github1. the calculation of ﬁtness and precision can be
divided in two steps: determining the enabled log activities
and the enabled model activities.
constructing the contexts and calculating the enabled log
activities is straightforward according to deﬁnition 8 and
deﬁnition 12. we construct the event-object graph for the
event log, extract the event preset for each event, calculate
the preﬁx for each object and merge these preﬁxes into the
context. we, subsequently, collect the activities of all events
with the same context as the enabled activities of this context.
due to variable arcs and silent transitions the calculation of
enabled model activities is not trivial. we, therefore, introduce
1https://github.com/niklasadams/precisionfitnessocpma)
 c)
b)
fig. 3. a) object-centric ﬂower model, b) restricted model, c) appropriate model
an algorithm to determine the enabled model activities which
is depicted in algorithm 1. the core idea of our algorithm
is to replay the events for each context and determine the
enabled activities in the resulting states of the object-centric
petri net. for a given context we collect all the events that have
this context. for each of these events we extract the binding
sequence of visible transitions recorded in the event log. we
do this by projecting the event preset of an event onto the
bindings described by the events, i.e., transition and objects.
see the event log l1in table i and event e5with event preset
e5=fe1;e2;e3;e4gas example. the corresponding binding
sequence of visible transitions that need to be replayed are the
bindings of e1toe4, consisting of the transition and recorded
objects, in order of their occurrence. we replay each binding
sequence under consideration of silent transitions. this is a
breadth-ﬁrst search through the states reachable by executing
the binding sequence and silent transitions. when the binding
sequence is fully replayed all enabled activities are added to
the set of enabled model activities for this context.
one important aspect for the practicality of these ﬁtness
and precision notion is the complexity of the algorithm. the
computation of the measures consists of computing enabled
log and enabled model activities. determining enabled log
activities is done in quadratic time since the event log has to
be traversed once for each event to determine the preset. the
computation of enabled model activities depends on the log
and the petri net. it depends linearly on the number of events,however, two factors can lead to an exponential increase in
the computation time: silent transitions and the number of
objects. coherent clusters of silent transitions with choices
within one object type lead to the necessity to replay through
all the possible reachable states to align the process model with
the log, if possible. especially when considering that multiple
objects of one object type can be involved the state space that
needs to be searched grows exponentially. this is a problem
when considering, e.g., object-centric petri nets mined by the
inductive miner on a log with, e.g., noise.
vi. e valuation
in this section, we discuss our precision and ﬁtness notion
by applying it to three different models of one synthetic event
log and analyzing the results. we do this to assess whether
our precision and ﬁtness notion can be interpreted analogously
to the notions of traditional process mining, i.e., provide an
intuitive interpretation for experts and practitioners. we use
an object-centric ﬂower model, a model that is tailored to the
most frequent process execution and an appropriate model.
the ﬁrst model is an object-centric adaptation to a ﬂower
model, it is depicted in figure 3a. in traditional process
mining, a ﬂower model is used to describe a process where
every transition can be executed at any time. the ﬁtness is
very high since it covers any behavior seen in the log. the
precision, however, is very low since all transitions can happen
at any time, also behavior that is not covered by the event log.
for an object-centric ﬂow model, we expect a high ﬁtness andtable ii
results for different models
fitness precision skipped events
flower model (figure 3a) 1 0:25 0%
restricted model (figure 3b) 0:31 0:95 54%
appropriate model (figure 3c) 1 0:57 0%
low precision.
the second model is a model that just accounts for the most
frequent activity sequence of each object type, it is depicted in
figure 3b. this is a very restrictive model that only allows for
little behavior. in traditional process mining, the precision of
such a model is high as the little behavior it covers is contained
in the log. the ﬁtness, however, would be low since such a
model only suits the most frequent execution of the process.
we expect a low ﬁtness and high precision for our notions.
the third model is an appropriate representation of the
underlying process, it is depicted in figure 3c. we, therefore,
expect high measures for ﬁtness and precision.
the results calculated by our algorithm are displayed in
table ii. the appropriate model ﬁts the event log perfectly and
has a precision of 0.572. this is a high precision compared
to the ﬂower model which also ﬁts perfectly but has a
low precision since it always allows for every activity to
be executed. the restricted model shows an almost perfect
precision. however, missing concurrency, choice and activities
lead to a very low ﬁtness and approximately 54% of the events
where the context can not be replayed and which can not
be considered. in summary, our ﬁtness and precision notion
behave analogously to the ones of traditional process min-
ing and, therefore, yield an intuitive and easy-to-understand
object-centric deﬁnition of ﬁtness and precision.
vii. c onclusion
in this paper, we introduced a precision and ﬁtness notion
for object-centric petri nets with respect to an object-centric
event log. we use the concept of a context to relate log and
model behavior and calculate the enabled activities for the
context in the model and the log. we handle contexts that
are not replayable on the petri net by excluding them from
the precision calculation. we provide an algorithm and imple-
mentation of calculating these quality metrics. we evaluate our
contributions by comparing the quality measures for one event
log and three different models. our ﬁtness and precision notion
offer an objective way to evaluate the quality of an object-
centric petri net with respect to an object-centric event log.
in the future, we want to use these concepts for evaluation of
improved object-centric process discovery. other future lines
of research could focus on handling non-replayable context,
e.g., by the calculation of object-centric alignments or on
providing approximations for models with large state spaces
for replay. furthermore, other quality metrics considered in
2on the ﬁrst look this precision looks low for an appropriate model.
however, consider that the object-centric petri net makes no limitation on
the order of activity executions between object types. if pay order is always
executed before end route this is not represented by the petri net and,
therefore, an imprecision.traditional process mining, i.e., generality and simplicity, could
be investigated.
references
[1] w. m. p. van der aalst, process mining: data science in action .
springer, 2016.
[2] ——, “object-centric process mining: dealing with divergence and
convergence in event data,” in sefm 2019. , ser. lncs, vol. 11724.
springer, 2019, pp. 3–25.
[3] a. f. ghahfarokhi, g. park, a. berti, and w. m. p. van der aalst,
“ocel: a standard for object-centric event logs,” in adbis (short
papers) 2021 , ser. ccis, vol. 1450. springer, pp. 169–175.
[4] w. m. p. van der aalst and a. berti, “discovering object-centric petri
nets,” fundam. informaticae , vol. 175, no. 1-4, pp. 1–40, 2020.
[5] a. rozinat and w. m. p. van der aalst, “conformance checking of
processes based on monitoring real behavior,” inf. syst. , vol. 33, no. 1,
pp. 64–95, 2008.
[6] j. munoz-gama and j. carmona, “a fresh look at precision in process
conformance,” in bpm 2010. , ser. lncs, vol. 6336. springer, pp.
211–226.
[7] w. m. p. van der aalst, p. barthelmess, c. a. ellis, and j. wainer,
“workﬂow modeling using proclets,” in coopis 2000. , ser. lncs, vol.
1901. springer, pp. 198–209.
[8] d. fahland, “describing behavior of processes with many-to-many
interactions,” in petri nets 2019. , ser. lncs, vol. 11522. springer,
pp. 3–24.
[9] v . denisov, d. fahland, and w. m. p. van der aalst, “multi-dimensional
performance analysis and monitoring using integrated performance
spectra,” in icpm 2020 , ser. ceur, vol. 2703. ceur-ws.org, pp.
27–30.
[10] d. cohn and r. hull, “business artifacts: a data-centric approach to
modeling business operations and processes,” ieee data eng. bull. ,
vol. 32, no. 3, pp. 3–9, 2009.
[11] d. calvanese, m. montali, m. esta ˜nol, and e. teniente, “veriﬁable uml
artifact-centric business process models,” in cikm 2014. acm, pp.
1289–1298.
[12] x. lu, m. nagelkerke, d. van de wiel, and d. fahland, “discovering
interacting artifacts from erp systems,” ieee trans. serv. comput. ,
vol. 8, no. 6, pp. 861–873, 2015.
[13] d. fahland, m. de leoni, b. f. van dongen, and w. m. p. van der
aalst, “behavioral conformance of artifact-centric process models,” in
bis 2011 , ser. lnbip, vol. 87. springer, pp. 37–49.
[14] ——, “conformance checking of interacting processes with overlapping
instances,” in bpm 2011. , ser. lncs, vol. 6896. springer, pp. 345–361.
[15] m. l. van eck, n. sidorova, and w. m. p. van der aalst, “guided
interaction exploration in artifact-centric process models,” in cbi 2017 .
ieee computer society, pp. 109–118.
[16] m. montali and a. rivkin, “db-nets: on the marriage of colored petri
nets and relational databases,” trans. petri nets other model. concurr. ,
vol. 12, pp. 91–118, 2017.
[17] w. m. p. van der aalst, g. li, and m. montali, “object-centric
behavioral constraints,” corr , vol. abs/1703.05740, 2017.
[18] g. li, r. m. de carvalho, and w. m. p. van der aalst, “automatic
discovery of object-centric behavioral constraint models,” in bis 2017. ,
ser. lnbip, vol. 288. springer, pp. 43–58.
[19] a. berti and w. m. p. van der aalst, “extracting multiple viewpoint
models from relational databases,” in simpda revised selected papers ,
ser. lnbip, vol. 379. springer, 2019, pp. 24–51.
[20] a. f. syring, n. tax, and w. m. p. van der aalst, “evaluating con-
formance measures in process mining using conformance propositions,”
trans. petri nets other model. concurr. , vol. 14, pp. 192–221, 2019.
[21] n. tax, x. lu, n. sidorova, d. fahland, and w. m. p. van der aalst, “the
imprecisions of precision measures in process mining,” inf. process.
lett., vol. 135, pp. 1–8, 2018.
[22] w. m. p. van der aalst, a. adriansyah, and b. f. van dongen,
“replaying history on process models for conformance checking and
performance analysis,” wiley interdiscip. rev. data min. knowl. discov. ,
vol. 2, no. 2, pp. 182–192, 2012.