an activity instance based hierarchical framework
for event abstraction
chiao-yun li, sebastiaan j. van zelsty, and wil m.p. van der aalstz
fraunhofer fit, birlinghoven castle, sankt augustin, germany
process and data science (pads) chair, rwth-aachen university, germany
email:chiao-yun.li@Ô¨Åt.fraunhofer.de,ysebastiaan.van.zelst@Ô¨Åt.fraunhofer.de,zwvdaalst@pads.rwth-aachen.de
abstract ‚Äîprocess mining allows one to analyze and extract
knowledge from event data , i.e., records of process executions
stored in information systems. most process mining techniques
are directly applied to the data as recorded in the system.
applying automated process discovery techniques, i.e., a core
process mining technology, directly on such data yields complex
process models describing millions of different execution paths.
other techniques applied to such discovered process models and
system-level data, e.g., conformance checking or performance
analysis techniques, often generate complex and over-detailed
results. the results obtained by directly applying process mining
techniques on system-level data are, therefore, hard to interpret
by a human analyst and greatly differ from the business level.
therefore, in this paper, we propose a generic hierarchical
framework for event abstraction. we formalize the framework,
which uses the notion of activity instances as an input and allows
for hierarchical abstraction of event data. in addition, we propose
an instantiation of the framework, which describes two key
functions of the framework, i.e., abstract concept identiÔ¨Åcation
and abstract entity extraction. the framework, together with the
instantiation, is evaluated both quantitatively and qualitatively.
the experiments show that, without compromising the quality of
results, the abstraction allows users to easier analyze a process.
index terms ‚Äîprocess mining, event abstraction, earth mover‚Äôs
distance
i. i ntroduction
organizations strive to improve their (well-deÔ¨Åned) business
processes to achieve competitive advantage. the effective im-
provement of processes requires an accurate understanding of
the actual execution of these processes. to obtain such insights
into the processes executed, process mining [1] allows one to
analyze and exploit the information captured in event data , i.e.,
the records of executions performed in the context of a process.
process models visualize/explain the behavior of a process
such that human analysts can interpret its described behavior.
as such, many process mining techniques use process models,
e.g., one may automatically discover a process model that
describes the behavior of the process recorded in the event
data by using process discovery algorithms.
according to [2], a human analyst can only process and
interpret a limited number of tasks or execution paths in a
process model. hence, to facilitate the general interpretability
of a process model, one typically applies abstraction principles
when modeling a process. for example, consider a medical
process. rather than modeling all activities performed by
the front-desk employee to register a patient, one typically
models the patient registration as a single activity. however,information systems typically record all activities performed
(and often additional lower-level system calls and functions).
hence, applying process mining directly on the data captured
yields overly detailed and complex process models describing
hundreds of activities and millions of execution paths.
to increase the interpretability of process mining results,
event abstraction techniques are typically applied [3]. such
techniques pre-process the event data by grouping the recorded
‚Äúlow-level events‚Äù into a higher-level activity notion, i.e.,
activities at the business level. process models discovered
based on the abstracted event log are of a higher level of
abstraction and thus allow analysts to gain a better end-to-
end understanding of the process. for example, identifying
the deviations that have a signiÔ¨Åcant impact on the business is
easier with a limited number of concepts in a process model
discovered by applying existing process discovery techniques.
nevertheless, some existing event abstraction techniques
require explicit domain knowledge to perform abstraction.
furthermore, most techniques are designed to be applied on se-
quences of events . after applying the techniques once, the re-
sulting event log describes a partial order of activity instances.
hence, if the abstracted event log is still too Ô¨Åne-grained, the
techniques cannot be further applied on the abstracted log.
therefore, in this paper, we propose a hierarchical framework
for event abstraction which allows for the integration of several
existing event abstraction techniques. the framework is based
on the notion of activity instances , which differs from the
typical concept of events used in process mining. as such,
this work can be seen as an effort to standardize an end-to-
end framework for event abstraction that allows for various
instantiations. we propose an accompanying instantiation of
our framework, characterizing the two core functions of the
framework, i.e., an abstract concept identiÔ¨Åcation and entity
extraction strategies. we evaluate the instantiation of our
framework both quantitatively and qualitatively. the results
indicate that, without compromising the quality of the models
discovered, the abstracted process is easier to comprehend.
the remainder of this paper is structured as follows. we
present preliminaries in section ii and provide a running
example in section iii. the framework and its instantiation
are introduced in section iv and v, respectively. we evaluate
our approach in section vi. section vii gives an overview of
the related work. limitations are discussed in section viii,
followed by the conclusion in section ix.table i: running example: an activity instance log l.
cid id activity start time complete time
1 1 apply loan (a) 2021.01.01 09:02 2021.01.01 09:02
1 2 check credit (c) 2021.01.04 09:30 2021.01.06 11:32
1 3 examine application (e) 2021.01.04 09:30 2021.01.07 09:45
1 4 decide (d) 2021.01.09 13:47 2021.01.10 10:20
1 5 decide (d) 2021.01.10 16:00 2021.01.12 08:48
1 6 decide (d) 2021.01.13 15:00 2021.01.15 09:20
1 7 notify applicant (n) 2021.01.16 10:23 2021.01.16 10:23
2 8 apply loan (a) 2021.01.01 10:06 2021.01.01 10:06
2 9 examine application (e) 2021.01.06 08:50 2021.01.10 08:45
2 10 check credit (c) 2021.01.07 11:16 2021.01.09 17:38
2 11 decide (d) 2021.01.12 11:12 2021.01.14 14:00
2 12 examine application (e) 2021.01.14 14:02 2021.01.14 14:00
2 13 decide (d) 2021.01.15 09:24 2021.01.18 10:28
2 14 notify applicant (n) 2021.01.20 16:07 2021.01.20 16:07
ii. p reliminaries
partial orders: given an arbitrary set x, we write
p(x)=fx0jx0xgto denote its powerset. jxjdenotes
the number of elements in x. a relationoverx
(xx) is a strict partial order over x, written
(x;), if and only if 8x2x(xx)(isirreÔ¨Çexive ),
8x1;x22x(x1x2=)x2x1)(isanti-symmetric ), and
8x1;x2;x32x(x1x2^x2x3=)x1x3)(istransitive ).
given (x;)andx0x, we let (x0;0)be the in-
duced partial order onx0, where0=\(x0x0). given
x2xand(x;), we deÔ¨Åne pred x(x;)=fx02xjx0xg
andsucc x(x;)=fx02xjxx0gfor the predecessors and
successors of xinx. in the remainder, we write pred(x)
andsucc(x)ifxis clear from the context (or not relevant).
givensucc(x), we writesucck(x)for the successors that are
at the largest distancedkofxinsucc(x). for example,
given the partial order in figure 1a, succ1(a)=fb;dgand
succ2(a)=fb;c;dg. similarly,predk(x)refers to the predeces-
sors ofxof depthdk. figure 1a visualizes a partial order
as a graph. for simplicity, we often visualize the transitive
reduction1of a partial order as in figure 1b, where the arc
(a;c)is removed yet cis still reachable from a.
event data: most process mining techniques require a log
describing records of executions of processes as an input. in
this paper, we use the notions of activity instance (a record of
a task executed in a process), case (a process instance), and
activity instance log (a collection of process instances). table i
sketches a synthetic example log. every row corresponds to an
instance of an activity executed in the context of a case. for
1a transitive reduction of a directed graph is a directed graph with the same
vertices and as few edges as possible maintaining the same reachability.
(a) the partial order.
 (b) the transitive reduction
of the partial order.
fig. 1: representation of a partial order over fa;b;c;dg.example, the Ô¨Årst row indicates that the apply loan activity
(short-hand notation: activity a) was executed at 9:02 am,
january 1st, 2021 and the second row indicates that check
credit (short-hand notation: activity c) was executed from 9:30
am, january 4th, 2021 until 11:32 am, january 6th, 2021 .
each activity instance has a unique id(the second column).
the case identiÔ¨Åer (the Ô¨Årst column cid) allows us to identify
for which case the activity instance was executed. for example,
the Ô¨Årst 7activity instances are executed for a case identiÔ¨Åed
by case-identiÔ¨Åer 1. we formalize the notions of an activity
instance, a case, and an activity instance log as follows.
deÔ¨Ånition 1 (activity instance). an activity instance de-
scribes the (historical) execution of an activity, which is
described by a set of attributes. we let abe the universe
of activity instances, uactthe universe of activities, and uts
the universe of timestamps. the following attributes of a2a
can be obtained by the projection functions:
id:a!n+s.t.8a;a02a(id(a)=id(a0) =)a=a0),
act:a!u act, whereact(a)denotes the activity of a,
st:a!u ts, wherest(a)denotes the start time of a,
ct:a!u ts, wherect(a)denotes the completion time
ofas.t.st(a)ct(a).
deÔ¨Ånition 2 (case, activity instance log). letabe the
universe of activity instances. a case ca describes a set
of activity instances executed in the context of a process
instance. a case cexplicitly deÔ¨Ånes a partial order (c;),
i.e.,8a;a02c(aa0,ct(a)<st(a0)). letcp (a)denote
the set of all possible cases. an activity instance log lc
is a set of cases where 8c;c02l(c\c0=;). the set of all the
possible logs of a process is denoted as lp (c).
in the remainder, we refer to the activity instance class
of said activity instances, e.g., the activity instance class of
instances with id 4,5and6in table i is decide (d). the valid
classes of a log lare denoted as (l)=s
c2lfact(a)ja2cg.
iii. r unning example
in this section, we introduce a running example which we
use in this paper to illustrate and explain the framework. con-
sider a loan application process. after an applicant submits an
application for a loan, the bank checks the applicant‚Äôs credit
and examines the application. depending on the amount
applied for and the information of the applicant, the ap-
plication may be examined again and go through several
underwriters. the bank notiÔ¨Åes the applicant of the Ô¨Ånal
decision, i.e., approval or rejection of the application. table i
shows an activity instance log lfor the process described,
where each row represents an activity instance with the
corresponding attributes. for example, for case 1(written as
c1),c1=fa1;c2;e3;d4;d5;d6;n7g2. since each case deÔ¨Ånes a
partial order over its activity instances, the activity instance
log in table i can be seen as a collection of partial orders. a
graphical representation of l, i.e., represented as a collection
2for simplicity, given an activity instance awhereid(a)=kand
act(a)=b, we writebkin the rest of the paper.(a) case 1
 (b) case 2.
fig. 2: graphical representation of l(for simplicity, the
example cases are depicted by the transitive reduction of the
partial order deÔ¨Åned on the activity instances.).
of partial orders, is shown in figure 2, where each node
represents an activity instance labeled with the abbreviation
of its activity name and its idas subscript.
table ii shows an abstracted log after applying the proposed
framework on l. the activity classes c,e, anddare abstracted
to an abstraction class c1at hierarchy level 1. activity in-
stancesaandnform singleton abstraction classes at hierarchy
level 1. inc1, all the activity instances related to c1are
grouped together as an instance of c1. inc2, we extract two
instances of c1,fe9;c10;d11gandfe12;e13g. the collection
of the cases in table ii is a log at hierarchy level 1. finally,
we apply the framework on the log abstracted and compute a
log at hierarchy level 2as shown in table iii, where all the
classes at level 1are grouped as a single class at level 2.
iv. f ramework
in this section, we introduce the proposed framework. we
explain the framework using the running example introduced
in section iii and deÔ¨Åne the input and output for each
component in the framework.
figure 3 presents a schematic overview of the framework.
a hierarchy of abstractions is obtained by iteratively applying
the framework. in each iteration i2n+, Ô¨Årst, we discover
the applicable abstraction classes at the next hierarchy level,
i.e., at level i+1(represented by abstraction oracle function
'). the corresponding instances of each abstraction class are
extracted by the function . in the log at level i, the detected
instances of an abstraction class, are replaced by instances
of the abstracted class, i.e., generating the log at level i+1.
for example, in l1in table ii, the instances c2;e3;d4;d5;d6
oflin table i are collapsed into a single instance of class
c1(instance id 2in table ii). the same holds for instances
e9;c10;d11and instances e12andd13, i.e., instances 5and6,
respectively in table ii. for each abstraction class, a sublog
(class log ) describing all the instances of the class is created.
table ii: a log l1at hierarchy level 1abstracted from l,
wherec1=fc;d;eg.
cid id class instances start time complete time
1 1fag fa1g 2021.01.01 09:02 2021.01.01 09:02
1 2c1fc2;e3;d4;d5;d6g2021.01.04 09:30 2021.01.15 9:20
1 3fng fn7g 2021.01.16 10:23 2021.01.16 10:23
2 4fag fa8g 2021.01.01 10:06 2021.01.01 10:06
2 5c1fe9;c10;d11g 2021.01.06 08:50 2021.01.14 14:00
2 6c1fe12;d13g 2021.01.14 14:02 2021.01.18 10:28
2 7fng fn14g 2021.01.20 16:07 2021.01.20 16:07table iii: a log l2at hierarchy level 2, abstracted from l1,
wherec2=ffag;fng;c1g.
cid id class instances start time complete time
1 1c2ffa1g;c12;fn7gg 2021.01.01 09:02 2021.01.16 10:23
2 2c2ffa8g;c15;c16;fn14gg 2021.01.01 10:06 2021.01.20 16:07
for example, class c1describes activity instance classes c,
d,e. based onl, a class log lc1is constructed, containing
activity instances 2:::6forc1and instances 9:::13forc2.
similarly, for singleton classes fag, class logs containing
activity instances 1and8are created. thus, the underlying
behavior recorded for activity instance 2in table ii, i.e., the
instance of c1, is described by activity instances 2:::6in
table i, captured in the previously described class log lc1.
the framework‚Äôs output, i.e., a log at level i+1, is computed
and can be used as the input for the next iteration. the process
repeats until the level speciÔ¨Åed by the user. the total collection
of the results obtained at each iteration forms a hierarchical
abstraction of the input data.
first, we discover the applicable classes at each level. if we
consider the activities recorded in the system as abstraction
level 0, a class at level i>0is simply a collection of classes
at leveli 1. the notion of class hierarchy is as follows.
deÔ¨Ånition 3 (hierarchy of classes). letuactbe the universe
of process activities. the universe of classes of a process at
leveli2n, i.e.,ui
class, is recursively deÔ¨Åned as ui
class=uactif
i=0andui
class=p(ui 1
class)nf;g fori>0.
in the running example, u0
class=fa;c;d;e;ng.
we identify classes u1
class=ffag;c1;fngg, where
c1=fc;d;eg, andu2
class=fc2g, wherec2=ffag;c1;fngg.
for each class discovered, we extract the corresponding
instances from the log. within a case, multiple instances of
the same abstraction class may be identiÔ¨Åed, e.g., instances 5
and6in table ii both represent an instance of c1. we deÔ¨Åne
a hierarchy of instances as follows.
deÔ¨Ånition 4 (hierarchy of instances). letui
class be the
universe of classes at level i2nandutsbe the universe of
timestamps. an instance at level idescribes the presumed
(historical) execution of a class at level iand consists of
the executions at level i 1ifi>0. letabe the universe
of activity instances. the universe of instances at level i
is deÔ¨Åned asai=aand8i2ai(class(i)=act(i))ifi=0,
elseai=p(ai 1)nf;g and8i2ai(class(i)2ui
class). the
corresponding attributes can be derived from the underlying
instances at the lower-level such that, given i2ai, wherei2n,
st:ai!uts, wherest(i)denotes the start time
ofis.t.st(i)=st(i)ifi=0 (since i2a), else
st(i)=min(fst(i0)ji02ig),
ct:ai!uts, wherect(i)denotes the completion
time of is.t.ct(i)=ct(i)ifi=0, else
ct(i)=max(fct(i0)ji02ig).
note that we do not impose the constraint that all the instances
at levelimust be in an instance at level i+1.fig. 3: schematic overview of proposed approach.
instances in a case at level i2ntogether form an instance at
leveli+1. in the running example, we extract four instances
i4,i5,i6, andi7at level 1fromc22lin table i. hence, the
same case at level 1, written as c1
2, contains these extracted
instances, i.e., c1
2=fi4;i5;i6;i7g. these instances describe the
activity instancesfa8g,fe9;c10;d11g,fe12;d13g, andfn14g,
respectively, of the underlying log l. similarly, at level 2(l2
in table iii), c2
2describes one instance of c2and consists of
all instances of c1
22l1(table ii).
deÔ¨Ånition 5 (hierarchy of cases and logs). letaibe the
universe of instances at level i2n. the universe of cases
at leveli, i.e.,ci, is recursively deÔ¨Åned as ci=cifi=0
elsecip(p(ai 1))s.t.8ci2ci,ciis a derivative case of
ci 12ci 1where8i2ci(ici 1)and8i;i02ci(i\i0=;). the
universe of logs at level i2nis deÔ¨Åned asli=lifi=0else
lip(p(ci 1))s.t.8l2li,lis the collection of all the
derivative cases of cases in li 1.
note that an activity , an activity instance , acase, and an
activity instance log can be seen as the building blocks of a
hierarchy of classes, instances, cases, and logs, respectively.
to extract the classes and instances at different level of the
hierarchy, we deÔ¨Åne two key oracle functions, class abstraction
function'and instance extraction function as shown in
figure 3. first, the class abstraction function 'groups the
classes at the lower-level and extracts the classes at the next
level as follows.
deÔ¨Ånition 6 (class abstraction oracle). letlibe the
universe of logs at level i2n. anith-order class abstrac-
tion oracle 'idetects the possible applicable classes at
leveli+1, i.e.,'i:li!p(ui+1
class), whereui+1
classis the uni-
verse of classes at level i+1, such that, given l2li,
8ci2(l)(9ci+12'(l)(ci2ci+1)).
in the running example l, we identify three classes at level 1
with'0(l)=ffag;c1;fngg, wherec1=fc;d;eg. given the
logl1extracted from l, we identify the classes at level 2
as'1(l1)=fc2g, wherec2=ffag;c1;fngg. intuitively, an
instance of class ci, wherei2n+, contains the instances of
the classes at the lower-level in ci. for example, the instances
inc1in table i with activities c,d, andeare collected as one
instance i2in table ii since c1=fc;d;eg. the extraction of
instances is deÔ¨Åned as follows.deÔ¨Ånition 7 (instance extraction oracle). giveni2n, let
cibe the universe of cases at level iandui
class andaibe
the universe of classes and instances at level i, respec-
tively. an instance extraction oracle at level i iis a
functioni:cip(ui+1
class)!p(ai+1), s.t., given case c2ci
and a valid class deÔ¨Ånition at level i+1ci+12ui+1
class,
an instance at level ican only be assigned to at most
one instance at level i+1, i.e.,8i;i02i(c;ci+1)(i\i0=;),
and8i2i(c;ci+1)8i002i(class(i00)2ci+1). we overload
i(c;ci+1)and writei(li;ci+1)=fi(c;ci+1)jc2lig.
with the deÔ¨Ånition, the instances of c1,c2, and
c3from'0(l0)can be extracted as 0(l0;'0(l0))=
fi1;i2;i3;i4;i5;i6;i7g, where each row in table ii represents
an instance and the corresponding attributes. for example, i5is
an instance of c2(class(i5)=c2) extracted from e9;c10, and
d11(i5=fe9;c10;d11g) inc0
2such thatst(i5)=2021:01:06
08:50 andct(i5)=2021:01:14 10:06 . in figure 3, we color
the activity instances of the same class at level 1with the
same color and group the activity instances if they belong to
the same instance at level 1with a dashed line.
finally, for every class identiÔ¨Åed, we create a class log
containing the instances of the class. in the running exam-
ple, given0(l;'0(l)), we extract class logs lfag=fi1;i4g,
lc1=fi2;i5;i6g, andlfng=fi3;i7gin table ii. given a class,
the corresponding class log is deÔ¨Åned as follows.
deÔ¨Ånition 8 (class log). letlibe a log at level i2n
andci+1ui+1
classbe the applicable classes at level i+1,
i.e.,ci+1='(li). a class log of c2ci+1, written as lc,
is the collection of the instances of the class cwhere
lc=fiji2i(li;ci+1)(class(i)=c)g:
given the deÔ¨Ånitions, the extraction of a hierarchy of logs
and class logs is trivial provided the instances. to summarize,
the framework takes a log at level i2nand discovers the
applicable classes at level i+1with abstraction oracle '. the
instances of each class identiÔ¨Åed are extracted using . for
every class, we collect the instances of each class and generate
a log, which contains the data of a subprocess represented with
the class. the Ô¨Ånal output is a log at level i+1computed from
the instances extracted. the process repeats until the level that
a user speciÔ¨Åed and creates a hierarchy of abstractions.v. a ninstantiation
in this section, we introduce an instantiation of the two
core oracle functions in the proposed framework: (1) the class
abstraction'and (2) the instance extraction oracle for every
abstraction level.
a. abstracting classes
given a process, it is intuitive to group the classes that have
similar surrounding behavior as a class at the higher level. we
deÔ¨Åne classes to be similar if they having similar preceding
and following classes.
first, we extract the classes preceding ( preceding patterns )
and following ( following patterns ) every class within a certain
window size (w). to increase the probability that two classes
group together, we let ^predw
c(i)and ^succw
c(i)be a set of
welements randomly selected from predw
c(i)andsuccw
c(i),
respectively. the patterns are extracted as below.
deÔ¨Ånition 9 (preceding and following patterns). given a
logl, letcbe all the classes of instances in l. for every
c2c, the preceding and following patterns of care
ppred
c=[
c2lffclass(i0)ji02^predw
c(i)gji2c(class(i)=c)g;
psucc
c=[
c2lffclass(i0)ji02^succw
c(i)gji2c(class(i)=c)g:
we denote all the preceding and following patterns in las
ppred=s
c2cppred
c andpsucc=s
c2cpsucc
c.
the green (top) and blue (bottom) rows in figure 4a present
the preceding and following patterns of lwith window size
1. the arrows in figure 4a indicate if a pattern precedes or
follows an activity in l. for example, ais followed byfcgand
fegand preceded with an empty set (since ais the Ô¨Årst activity
in all the cases in l). based on the preceding and following
patterns, we quantify the difference between any two classes
using earth mover‚Äôs distance (emd ) [4].
deÔ¨Ånition 10 (preceding and following similarity). let
ppredandpsuccbe the preceding and following patterns of
the classes cin a logl. the frequency that a pattern p
precedes or follows a class c2care
fpred(c;p)=j[
c2lf^predw
c(i)ji2c(class(i)=c)gj;
fsucc(c;p)=j[
c2lf^succw
c(i)ji2c(class(i)=c)gj:
the probability that a pattern pprecedes or follows a class
cisppred(c;p)=fpred(c;p)=p02ppredfpred(c;p0)and
psucc(c;p)=fsucc(c;p)=p02psuccfsucc(c;p0), respectively.
let the distance between any different patterns be 0and1
otherwise. according to [5], the emd between any c;c02c
of the preceding and following patterns are as follows.
emdpred(c;c0)=1 p2ppred(ppred(c;p) ppred(c0;p);0);
emdsucc(c;c0)=1 p2psucc(psucc(c;p) psucc(c0;p);0):
(a) frequency.
 (b) probability.
 (c) updated.
fig. 4: pattern graphs for the running example l.
the labels of the arrows in figure 4a and 4b show the
frequency and probability of a pattern precedes and follows a
class. for instance, in figure 4b, there is a 50% probability
thatdgoes tofdgand50% thatdgoes tofng. we quantify
the similarity of classes using the probability. if the average
similarity of the classes, deÔ¨Åned as 1 emd for preceding
and following patterns, is greater than a threshold provided
by the user, we consider them similar enough and group them
together. the corresponding arrows and frequency labels are
updated as shown in figure 4c, where the threshold is set to
0:25. then, we compute the probability of the edges and repeat
the process until no classes can be grouped. the Ô¨Ånal output,
i.e., sets of classes grouped, are the classes at the next level.
note that, for the singletons classes that are not grouped, we
deÔ¨Åne them as a class at the next level.
b. extracting instances
we propose two solutions for extracting the instances. the
Ô¨Årst one is straightforward. for each case c, we deÔ¨Åne an
instance iof a classcat leveli2n+as the collection of
all the instances in cwhere their classes are in c, i.e.,
i=fi0ji02c^class(i0)2cg.
the second solution proposed ‚Äúcuts‚Äù the instances in a case
according to the start and completion classes identiÔ¨Åed. a
(sub)process often starts and completes with speciÔ¨Åc activities,
e.g., receive an application, forward a case to another depart-
ment, reject a purchase request, ..., etc. an instance of a class
at the higher level can be extracted by ‚Äúcutting‚Äù a case using
the potential start and completion classes at the lower level,
i.e., endpoint classes. there are two steps in the extraction.
first, we identify the endpoint classes at the lower level for a
class at higher level. for instance, given the running example
l, supposec1=fc;d;eg. we identify das the completion
class ofc1(ccomplete
c1 ) andfc;egas the start classes ( cstart
c1).
given the endpoint classes identiÔ¨Åed, we compute the
‚Äúcutting points‚Äù of a case, which fall between the instances
with the start and completion classes. for example, in fig-
ure 2, givencstart
c1=fegandccomplete
c1 =fdg, we extract three
instances of c1,i2=fc2;e3;d4;d5;d6g,i5=fe9;c10;d11g, and
i6=fe12;d13g. in case 2, we ‚Äúcut‚Äù the case between d11and
e12based on their classes which indicates the initiation of a
new instance at the higher level. we identify the cutting points
based on the start and completion classes as below.
deÔ¨Ånition 11 (identifying cutting points). given a log li,
wherei2n, and the applicable classes ci+1. letcstart
c andtable iv: parameter setting of abstraction level ( l), window
size ( w), similarity threshold ( s), dependency threshold of
hm, and noise threshold of imÔ¨Çc ( imÔ¨Çc ) and imf.
l w s imÔ¨Çc hm-dependency threshold imf-noise threshold
min 0 1 0 0 0 0
max 3 10 1.0 1.0 1.0 1.0
step 1 1 0.1 0.1 0.1 0.1
ccomplete
c be the start and completion classes of c2ci+1. for
everyc2li, we perform the following steps.
1)select the instances with the start and completion classes
i=fiji2c(class(i)2cstart
c[ccomplete
c )g.
2)extract a set of timestamps that represent the
cutting points t=fst(i)ji2c(class(i)2cstart
c^
fclass(i0)ji02^succ1
i(i;)gccomplete
c )g.
3)sort the timestamps extracted into a list
^t=h1;2;:::;jtji, where81i<jjtj (^t(i)^t(j)).
4)collect the instances s.t. every instance at level i+1is a
set of instances at level iin between the timestamps ex-
tracteds
1k<j^tjfiji2c(class(i)2c)^st(i)^t(k)^
(k<j^tj!ct(i)<^t(k+1)^k=j^tj!ct(i)>max (^t)))g.
we apply the same process to all the cases in liand extract
all the instances of cat leveli+1.
finally, with the instances extracted, the abstract log at the
next level and the class logs are computed and applied as an
input for the next iteration until the level that a user speciÔ¨Åed.
vi. e valuation
in this section, we evaluate the proposed framework with
the instantiation. first, we present a quantitative evaluation by
comparing the quality metrics of discovered process models
with and without applying abstraction. then, we present
the models discovered to showcase the applicability of the
framework.
a. quantitative evaluation
in this section, we evaluate the quality of process models
with and without abstraction by applying existing discovery
algorithms on the abstract logs. to fairly compare the results,
we Ô¨Çatten the process models discovered using the logs at
different levels, i.e., an abstract model , by replacing each
transition in the model with a model discovered using the class
log of the corresponding transition ( class model ). we repeat
the replacement process until all the transitions are labeled
with classes at level 0, i.e., the classes, or activities, in the
processes without applying abstraction. meanwhile, we adopt
the Ô¨Årst solution proposed to extract the instances to compare
with results without abstraction.
we evaluate the process models using two datasets [6], [7].
we apply inductive miner - infrequent & life cycle (imÔ¨Çc) [8]
for discovering abstract models (as it is the only discov-
ery algorithm known that can handle life cycle transitions
reasonably). the class models are discovered using different
fig. 5: the process model without abstraction, i.e., level 0,
discovered using hm with dependency threshold 0:2on [7].4
versions of the inductive miner, i.e., (im) [9], (imf) [10] and
(imd) [11], and, the heuristic miner (hm) [12].
using the aforementioned logs and algorithms, we con-
ducted various experiments with different parameter settings
of our framework. an overview of the total parameter setup
is presented in table iv. in table v we present the average
results obtained in terms of Ô¨Åtness [14], precision [15], and
f1-score of the Ô¨Çattened models using token-based replay
technique.4. the simplicity is evaluated for both Ô¨Çattened and
abstract models, which are intended for human analysts [16].
we observe that the simplicity of the obtained models
increases for higher levels of abstraction. for the abstract
models this is to be expected, i.e., these models contain
less elements. however, we also observe slight increase for
the Ô¨Çattened models, which is more surprising. for [6], we
observe an increase of f1-score for the Ô¨Çattened models when
we increase the abstraction levels. this is mainly caused by
a signiÔ¨Åcant increase in precision for the models based on
higher levels of abstraction. however, generally, the Ô¨Åtness
levels of the corresponding models is lower. for [7], similar
results are obtained, however, the drop in Ô¨Åtness is too large
compared to the gain in precision, i.e., f1-scores for higher
levels of abstraction are worse compared to the raw event data.
nonetheless, these result conÔ¨Årms the ability of abstraction
techniques to counter the typical underÔ¨Åtting behavior of
process discovery algorithms on raw event data. for the impact
of the parameters, we observe that the similarity threshold and
the discovery algorithm used (along with the corresponding
parameters) have stronger impact to the quality of the process
models comparing to other parameters.
b. qualitative evaluation
the complexity and density of a process model are known to
impact the understandability for a human analyst [2], [17]. to
demonstrate the applicability of the framework, we compare
the process models with and without abstraction. figure 5
presents an impression of a process model without abstraction.
the abstract models at levels 1to3are shown in figure 6,
with the class models discovered using the same parameter
setting as the one without abstraction. note that though the
labels are unclear, yet the Ô¨Ågures sketch the overall structure
of the process models.
3see [9] for the process tree representation and [13] for petri nets.
4see https://owncloud.fraunhofer.de/index.php/s/zs2rfvji47g1ck3 for all
results. due to space limitations we only show aggregate results.table v: average Ô¨Åtness, precision, and f1-score of Ô¨Çattened process models per level, where process models at level 0
refer to the models discovered without applying abstraction.
fitness precision f1-score simplicity-flatten simplicity-abstract
level 00.9697 0.7956 0.8728 0.5829 -
bpi 13 [7]level 10.6858 0.9817 0.7857 0.6385 0.9382
level 20.7172 0.9802 0.8116 0.6402 0.9615
level 30.7245 0.9802 0.8177 0.6401 0.9661
level 00.8043 0.8627 0.6979 0.5437 -
sepsis [6]level 10.7430 0.9584 0.8264 0.5857 0.9698
level 20.7441 0.9595 0.8280 0.5860 0.9753
level 30.7443 0.9598 0.8283 0.5861 0.9756
fig. 6: abstract and class models of [7] at hierarchy levels 1to3with setting of window size 4, similarity threshold 0:9, and
imÔ¨Çc noise threshold 0:2. the Ô¨Åtness/precision (f1-score) of the Ô¨Çattened models are 0:3898 /1:0(0:5609) ,0:7118 /1:0(0:8317) ,
and0:7987 /1:0(0:8881) at level 1to3, respectively.3
by using the divide-and-conquer strategy, compared to
figure 5, a human analyst only needs to interpret a limited
number of behaviors at a time. additionally, we observe a
change of the behavior in the abstraction. in the abstract model
of level 1, the classc2is in parallel with two singleton classes.
they are grouped as c3in level 2 and the two singleton classes
are beforec2at level 2. the quality of the Ô¨Çattened models,
i.e., Ô¨Åtness, precision, and f1-score, increases with the change.
to summarize, we evaluated our framework both quanti-
tatively and qualitatively. the quantitative evaluation shows
that the precision is higher with abstraction and the quality of
the process models depends mainly on the similarity threshold
and the discovery algorithm applied. in qualitative evaluation,
we demonstrate the applicability of the framework with the
visualization of process models. hence, we conclude that the
framework enhances the overall interpretability of discovered
process models without compromising the results.
vii. r elated work
in this section, we discuss the work that is most relevant
to the proposed framework. for a complete overview of the
abstraction techniques for process mining, we refer to [3].
to reasonably group the concepts or instances ( events in
most work) together into high-level concepts or instances,
some techniques require various levels of domain knowledge
provided by the user. for example, [18] assumes that the
information of different levels of abstraction is provided as an
attribute in the data to discover hierarchical models. the same
assumption is applied in [19], which aims to predict the higher-level concepts of events using log with labeled events and does
not allow for automatically discovering hierarchical models.
the authors in [20] propose to compute an activity tree , which
contains the hierarchical information. nevertheless, among
three alternatives, i.e., domain knowledge provided, randomly
assigned, and Ô¨Çat activity trees, the best results still rely on
the domain knowledge provided.
other approaches do not require users to explicitly provide
the abstraction information. de leoni and d ¬®undar apply clus-
tering algorithms with the feature extracted using frequency
or duration encoding within a Ô¨Åxed time frame determined
by the user [21]. nguyen et al. imitate how a human analyst
applies a divide-and-conquer strategy to decompose a process
model by searching for the ‚Äúcutting points‚Äù based on graph
modularity [22]. the above techniques require a certain level
of parameter tuning; however, less knowledge is required
compared to the techniques using explicitly abstraction infor-
mation [18]‚Äì[20]. in both [23] and [24], a process model for
each higher-level transition are used for abstraction. while the
latter one does not require users to provide such models, both
techniques utilize alignment to extract an abstracted log, which
is computationally expensive.
similar to [18] and [20], the proposed framework supports
hierarchical event abstraction. however, instead of relying on
domain knowledge, we propose an instantiation to extract the
abstraction information. moreover, most, or, all, techniques
apply on events . in real-life event logs, there are different
status of an activity, e.g., start, complete, suspend. to the best
of our knowledge, the framework proposed in this paper isthe Ô¨Årst to be applied on activity instances instead of events,
which is generally more applicable to different event logs.
viii. d iscussion and limitations
this section discusses the framework and its limitations.
there are two key functions in the proposed framework,
the identiÔ¨Åcation of classes at different levels, i.e., ', and
the extraction of the corresponding instances, i.e., . the
instantiation assumes that each class at level i2nexists in
only one class at level i+1. however, in real life, a class may
exist in different ‚Äúparts‚Äù (higher-level classes) of a process.
therefore, it would be interesting to apply an instantiation
that allows for duplicated labels and explore its impact.
the instantiation of which splits a case based
on start and completion classes at the lower level
highly depends on the selection of such classes. con-
sider a log containing incomplete cases, for example,
l=ffa1;b2;d3;a4;c5g;fa6;b7;d8;c9g;fa10;b11ggfor a pro-
cess!(^(	(a);!(b;d));c). we selectfagas the start
classes andfb;cgas the completion classes of a class
c=fa;b;c;dg. for the Ô¨Årst case, we extract two instances
fa1;b2gandfa4;c5g, resulting from the selection of bin
completion classes. as shown with the example, the selection
of classes that does not represent the termination of a class
at the higher level can lead to inaccurate results. in addition,
we do not guarantee that all the instances at level i2nare
assigned to instances at level i+1. in the example, instance
d3is excluded in the instances at level i+1.
in the instantiation, three parameters, i.e., window size ,
similarity threshold , and the Ô¨Ånal level of abstraction , need
to be conÔ¨Ågured by the user. however, as shown in the
experiments, the quality of the Ô¨Çattened models depends
more on the similarity threshold and the discovery algorithms
applied. therefore, we may further automate the framework
by removing, i.e., setting the parameters to constants, other
parameters while guaranteeing not affecting the results.
ix. c onclusion
we proposed a framework for event abstraction based on
activity instances . the framework Ô¨Årst identiÔ¨Åes classes and
extracts instances for each abstracted class at every hierar-
chical abstraction level. the output, a log based on extracted
classes, is then applied as input for the next iteration. we
apply the earth mover‚Äôs distance for comparing the similarity
of classes and group the classes that are similar enough in the
instantiation. we propose two solutions for the extraction of
instances. first, an instance at the higher-level is the collection
of all the relevant instances in a case. the second solution cuts
a case based on the intuition that a (sub)process often starts
and completes with certain activities. the evaluation shows
the applicability of the framework without compromising
the quality of the process models compared to the models
discovered without applying abstraction. in certain settings, the
results with abstraction outperform the ones without applying
abstraction. meanwhile, we demonstrate that the framework
allows for applying different process mining techniques toprovide better results. as a next step, we aim to remove the
requirement that a class can only be assigned to one class
at the higher-level and allow for multiple higher-level class
containing the same class at the lower-level. also, we aim
to develop different strategies for the selection of start and
completion classes and evaluate the corresponding impact on
discovered process models.
references
[1] w. van der aalst, ‚Äúdata science in action,‚Äù in process mining , 2016.
[2] j. mendling, h. a. reijers, and j. cardoso, ‚Äúwhat makes process models
understandable?‚Äù in bpm , 2007.
[3] s. j. van zelst, f. mannhardt, m. de leoni, and a. koschmider, ‚Äúevent
abstraction in process mining: literature review and taxonomy,‚Äù granular
computing , vol. 6, no. 3, 2021.
[4] y . rubner, c. tomasi, and l. j. guibas, ‚Äúa metric for distributions with
applications to image databases,‚Äù in sixth international conference on
computer vision , 1998.
[5] s. leemans, a. f. syring, and w. van der aalst, ‚Äúearth movers‚Äô
stochastic conformance checking,‚Äù in bpm , 2019.
[6] f. mannhardt, ‚Äúsepsis cases - event log.‚Äù
[7] w. steeman. (2013) bpi challenge 2013, closed problems.
[8] s. leemans, d. fahland, and w. van der aalst, ‚Äúusing life cycle
information in process discovery,‚Äù in bpm , 2016.
[9] s. leemans, d. fahland, and w. van der aalst, ‚Äúdiscovering block-
structured process models from event logs-a constructive approach,‚Äù in
international conference on applications and theory of petri nets and
concurrency , 2013.
[10] s. leemans, d. fahland, and w. van der aalst, ‚Äúdiscovering block-
structured process models from event logs containing infrequent be-
haviour,‚Äù in bpm , 2013.
[11] s. leemans, d. fahland, and w. van der aalst, ‚Äúscalable process
discovery and conformance checking,‚Äù software & systems modeling ,
vol. 17, no. 2, 2018.
[12] a. weijters, w. van der aalst, and a. a. de medeiros, ‚Äúprocess mining
with the heuristics miner-algorithm,‚Äù technische universiteit eindhoven,
tech. rep. wp , vol. 166, 2006.
[13] j. peterson, ‚Äúpetri nets,‚Äù acm computing surveys , vol. 9, no. 3, 1977.
[14] a. berti and w. van der aalst, ‚Äúreviving token-based replay: increasing
speed while improving diagnostics.‚Äù in ataed@ petri nets/acsd ,
2019.
[15] j. munoz-gama and j. carmona, ‚Äúa fresh look at precision in process
conformance,‚Äù in bpm , 2010.
[16] f. r. blum, ‚Äúmetrics in process discovery,‚Äù technical report, tr/dcc.
1‚Äì21, tech. rep., 2015.
[17] h. a. reijers and j. mendling, ‚Äúa study into the factors that inÔ¨Çuence
the understandability of business process models,‚Äù ieee transactions on
systems, man, and cybernetics-part a: systems and humans , vol. 41,
no. 3, 2010.
[18] s. leemans, k. goel, and s. j. van zelst, ‚Äúusing multi-level information
in hierarchical process mining: balancing behavioural quality and model
complexity,‚Äù in 2nd icpm , 2020.
[19] n. tax, n. sidorova, r. haakma, and w. van der aalst, ‚Äúevent
abstraction for process mining using supervised learning techniques,‚Äù
inproceedings of sai intelligent systems conference , 2016.
[20] x. lu, a. gal, and h. a. reijers, ‚Äúdiscovering hierarchical processes
using Ô¨Çexible activity trees for event abstraction,‚Äù in 2nd icpm , 2020.
[21] m. de leoni and s. d ¬®undar, ‚Äúevent-log abstraction using batch session
identiÔ¨Åcation and clustering,‚Äù in proceedings of the 35th annual acm
symposium on applied computing , 2020.
[22] h. nguyen, m. dumas, a. h. ter hofstede, m. la rosa, and f. m.
maggi, ‚Äústage-based discovery of business process models from event
logs,‚Äù information systems , vol. 84, 2019.
[23] f. mannhardt, m. de leoni, h. a. reijers, w. van der aalst, and
p. j. toussaint, ‚Äúfrom low-level events to activities-a pattern-based
approach,‚Äù in bpm , 2016.
[24] f. mannhardt and n. tax, ‚Äúunsupervised event abstraction using pattern
abstraction and local process models,‚Äù arxiv preprint arxiv:1704.03520 ,
2017.