choreography conformance checking: an
approach based on bpel and petri nets
w.m.p. van der aalst1,2, m. dumas2, c. ouyang2, a. rozinat1, and h.m.w.
verbeek1
1department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
{w.m.p.v.d.aalst,a.rozinat,h.m.w.verbeek }@tm.tue.nl
2faculty of information technology, queensland university of technology,
gpo box 2434, brisbane qld 4001, australia
{c.ouyang,m.dumas }@qut.edu.au
abstract recently, languages such as bpel and cdl have been pro-
posed to describe the way services can interact from a behavioral per-
spective. the emergence of these languages heralds an era where richer
service descriptions, going beyond wsdl-like interfaces, will be avail-
able. however, what can these richer service descriptions serve for? this
paper investigates a possible usage of behavioral service descriptions,namely as input for conformance checking . conformance checking is the
act of verifying whether one or more parties stick to the agreed-upon be-
havior by observing the actual behavior, e.g., the exchange of messagesbetween all parties. this paper shows that it is possible to translate
bpel business protocols to petri nets and to relate soap messages to
transitions in the petri net. as a result, petri net-based conformancechecking techniques can be used to quantify ﬁtness (whether the ob-
served behavior is possible in the business protocol) and appropriateness
(whether the observed behavior “overﬁts” or “underﬁts” the businessprotocol). moreover, non-conformance can be visualized to pinpoint de-
viations. the approach has been implemented in the context of the prom
framework.
1 introduction
a service-oriented architecture (soa) is essentially a collection of services.
these services communicate with each other in some meaningful way. to coordi-
nate these services overlapping concepts such as choreography ,orchestration ,a n d
service composition have been developed. the term “choreography” is typically
used to emphasize the fact that the services are autonomous and share the co-
ordination of the overall process. the term “orchestration” typically implies the
existence of single coordinating force (the conductor) and the term “service com-position” is used to emphasize that larger services are assembled from smaller
services. there have been many debates on the diﬀerences between these terms.
for example, the diﬀerences between choreography and orchestration have beenexplained using traﬃc lights (orchestration) and roundabouts (choreography).
in our view these distinctions are less meaningful and, therefore, we prefer to fo-cus on concrete languages and choose to use only the term “choreography”. the
business process execution language for web services (bpel4ws or simply
bpel) has emerged as a standard for specifying and executing processes [21,15].bpel can be used to specify so-called abstract processes , i.e., a non-executable
process speciﬁcation describing the business protocol as seen from one of the
partners involved. the web services choreography description language (ws-
cdl) is another example of a standard allowing for the speciﬁcation of business
protocols, but now seen from a global viewpoint [40].
in this paper we focus on abstract bpel as a choreography language. how-
ever, the concepts are not limited to bpel. in fact, we advocate the use of more
declarative choreography languages as discussed in [4].
we assume that a language like bpel is used to describe the desired behav-
ior. although a bpel speciﬁcation could be used as an execution language for
a given (composite) service, the service and the services it interacts with do notneed to be implemented using bpel. they could use other languages and the
internal behavior of external services may be invisible. note that partners have
no control over each other’s services. moreover, partners will typically not ex-pose the internal structure and state of their services. this triggers the question
ofconformance : “do all parties involved operate as described?”. we will use the
term choreography conformance checking to refer to this question. to address
the question we assume the existence of both a process model (describing the
desired choreography) and an event log (describing the actual observed behav-
ior). as already indicated in [4,27,31,35] it seems possible to extract event logsin a soa by monitoring the exchange of messages or transaction logs.
choreography conformance checking beneﬁts from the coexistence of event
logs and process models and may be viewed from two angles. first of all, themodel may be assumed to be “correct” because it represents the way partners
should work, and the question is whether the events in the log are consistent
with the process model. for example, the log may contain “incorrect” event
sequences not possible according to the model. this may indicate violations of
choreography all parties previously agreed upon. second, the event log may beassumed to be “correct” because it is what really happened. in the latter case
the question is whether the choreography that has been agreed upon is no longer
valid and should be modiﬁed.
figure 1 describes the approach proposed in this paper. based on a process
model described in terms of abstract bpel, we automatically create a petri
net [22,23] description of the intended choreography. we use our translationdescribed in [51] and implemented in our tool bpel2pnml.
1we also describe
an approach to monitor soap messages and transform these into events logs.
the event logs are stored in the so-called mxml format [25]. by comparing anevent log and a petri net we enable conformance checking. to actually measure
1both documentation and software can be downloaded from the babel project pages
http://www.bpm.fit.qut.edu.au/projects/babel/tools/ .
2<receive  …
createinstance=”yes”>
<correlations/>
</receive>
<invoke  …
inputvariable = …
outputvariable = ...>
<correlations/>
</invoke>
<invoke  …inputvariable = … >
<correlations/>
</invoke>
<receive  …
variable = … >
<correlations/>
</receive>
(mt,pi)<reply  … >
variable = …
</receive>abstract bpel
soap messages
soap monitor/correlator
(mt,pi)
(mt,pi)
(mt,pi)(mt,pi)
(mt,pi)
...event log
a
egd
h i
jkml
cb
gf(mt,pi)
(mt,pi)
(mt,pi)petri net
conformance checking!information systemconformance?
figure 1. overview of the approach implemented.
3conformance, we have developed a tool called the conformance checker . this
tool has been developed in the context of the prom framework2. although prom
oﬀers a wide range of tools related to process mining (e.g., ltl checking, process
discovery, extracting other models from event logs, veriﬁcation, etc.) [10,12], we
focus on the conformance checker described in [54].
the most dominant requirement for conformance is ﬁtness . an event log and
petri net “ﬁt” if the petri net can generate each trace in the log. in other words:
the petri net describing the choreography should be able to “parse” every eventsequence observed by monitoring e.g. soap messages. in [54] it is shown that it
is possible to quantify ﬁtness, e.g., an event log and petri net may have a ﬁtness
of 0.66. unfortunately, a good ﬁtness does not imply conformance, e.g., it is easyto construct petri nets that are able to parse any event log. although such petri
nets have a ﬁtness of 1 they do not provide meaningful information. therefore,
we use a second dimension: appropriateness . appropriateness tries to capture the
idea of occam’s razor , i.e., “one should not increase, beyond what is necessary,
the number of entities required to explain anything”. the prom conformancechecker supports both the notion of ﬁtness and the notion of appropriateness.
the remainder of this paper is organized as follows. first, we elaborate on the
concept of choreography conformance checking. section 3 presents the notion ofconformance checking and introduces the functionality of the prom conformance
checker. then we discuss the mapping of bpel [51] onto wf-nets [1], a subclass
of petri nets. a running example is used to illustrate the mapping. moreover,two tools as discussed: a tool to automatically translate bpel onto petri nets
(bpel2pnml) and a tool to analyze and reduce the resulting net (wofbpel).
section 5 discusses the various ways in which it is possible to extract eventlogs from messages (e.g., using soap headers). section 6 describes a case study
demonstrating the feasibility of our approach and the tools we have developed.
for this case study we use oracle bpel as a process engine. related work isdiscussed in section 7. finally, section 8 concludes the paper.
2 conformance checking of choreographies
as indicated in the introduction, this paper focuses on choreography confor-mance checking using “soap-messages based event logs” and “abstract bpel
based petri nets”. however, before introducing the notion of conformance check-
ing and the mapping from bpel to petri nets, we consider choreography con-formance checking in a broader perspective. to do this we discuss four possible
settings for choreography conformance checking as shown in figure 2. each of the
four settings describes a soa where four services are interacting by exchangingmessages. each service contains multiple activities involved in some interaction
(e.g., an invoke ,receive orreply ). only the activities/messages indicated in
bold are visible.
figure 2(a) shows the setting where there is some global observer that can
monitor all messages. this could be realized by implementing some message
2both documentation and software can be downloaded from www.processmining.org .
4(mt,pi)
(mt,pi)(mt,pi)
(mt,pi)
(mt,pi)(mt,pi)
(a) global message observer(at,pi)
(b) global activity observer(at,pi)(at,pi)
(at,pi)
(at,pi) (at,pi)(at,pi) (at,pi)
(at,pi) (at,pi) (at,pi)(at,pi)
(at,pi)
(mt,pi)
(mt,pi)
(mt,pi)
(c) local message observer(at,pi)
(b) local activity observer(at,pi)(at,pi)
figure 2. four possible settings for choreography conformance checking: (a) relevant
messages exchanged between all services involved in a choreography are visible, (b)
relevant activities executed inside all services involved in a choreography are visible,
(c) relevant messages exchanged with a single service are visible, and (d) relevantactivities executed within a single service are visible. (mt = message type, at =
activity type, and pi = process instance).
5broker that connects all services. similarly (but less realistic), it could be pos-
sible to globally monitor the execution of events, cf. figure 2(b). note that inmany soa platforms (e.g., ibm’s websphere) it is possible to monitor activities.
figure 2(c) describes the setting where all messages exchanged with a speciﬁc
service are recorded. note that the observer does not need to view the processglobally, a local monitoring facility suﬃces. it is often also possible to monitor
activities from such a local perspective, cf. figure 2(d). in this paper, we will
focus on the setting illustrated by figure 2(c) .
for conformance checking,
3it is crucial that each event recorded in the log
can be linked to some process instance (i.e., case) and some model element (e.g.,
an activity in bpel terms or a transition in petri-net terms). this is reﬂected
in figure 2 by (mt,pi) (mtis the message type that can be linked to some
activity and pirefers to a speciﬁc process instance) and (at,pi) (atrefers
to some activity). this may seem trivial but in reality it is not. at any point
in time there may be an arbitrary number of process instances all exchanging
messages using ad-hoc means of identiﬁcation, cf. the correlation mechanism ofbpel. moreover, the same activity may appear multiple times in the process
model or multiple activities may potentially send or receive similar messages.
as indicated above, we focus on the setting illustrated by figure 2(c) and
assume that we are able to map messages onto events of the form (mt,pi) .
moreover, we assume that there is an abstract process speciﬁed in terms of
bpel [21,15]. note that a bpel speciﬁcation may be descriptive orprescrip-
tive. abstract bpel processes are of a descriptive nature since they do not
enforce the service to operate in a certain way. executable bpel processes areof a prescriptive nature since they are used by some process engine to enforce a
particular way of operating. the focus of this paper is on conformance checking
and therefore we only assume the existence of an abstract bpel process withoutmaking any assumptions on the implementation of the process logic in the ser-
vice. figure 3 illustrates the setting we are focusing on. there is some abstract
bpel process and observed messages can be linked to bpel activities such asreceive ,invoke ,a n d reply .
in an ideal situation the abstract bpel process and the observed messages
conform (a precise deﬁnition will be given in the next section). however, theremay also be discrepancies between the left and the right hand parts of figure 3.
there are two possible causes for non-conformance: (1) the service implements a
process diﬀerent from the speciﬁcation given by the abstract bpel process and
(2) the environment behaves diﬀerent from what could be expected based on
the speciﬁcation given by the abstract bpel process. in the remainder, we willshow that it is indeed possible to measure conformance and track down discrep-
ancies between the abstract bpel process and the observed message exchanges.
although, we have implemented this in a bpel setting, it is important to notethat also other (more declarative) languages could be used. the web services
choreography description language (ws-cdl) would be an obvious candidate
3in fact, for process mining [10,12] in general it is important that each event points
to some process instance and a model element.
6(mt,pi) <receive  …
createinstance=”yes”>
<correlations/>
</receive>
<invoke  …
inputvariable = …
outputvariable = ...>
<correlations/>
</invoke>(mt,pi)
(mt,pi)
<invoke  …
inputvariable = … >
<correlations/>
</invoke>(mt,pi)
(mt,pi) <receive  …
variable = … >
<correlations/>
</receive>
(mt,pi)<reply  … >
variable = …
</receive>
environmentabstract bpel
figure 3. the situation illustrated by figure 2(c) put into the context of bpel with
its basic activities receive (initial or not), invoke (synchronous or asynchronous), and
reply .
[40]. the process part of ws-cdl can be seen as a subset of bpel and there-
fore it would be easy to extend this work to ws-cdl. however, as indicated in
[4], we would prefer a more declarative language. since such a more declarative
standard is missing at this point in time, we focus on abstract bpel in thispaper.
3 conformance checking based on petri nets
the starting point for conformance checking is the presence of both an explicitprocess model, describing how some business process should be executed, and
some kind of event log, giving insight into how it was actually carried out.
clearly, it is interesting to know whether they conform to each other. in [53,54]
this question has been explored using petri nets to represent process models[22,23], and assuming some abstract event log where log events are only expected
to (i) refer to an activity from the business process (denoted as at/mt in ﬁgures
2 and 3), (ii) refer to a case (i.e., a process instance, cf. labelled pi in ﬁgures 2and 3), and (iii) be totally ordered.
we have identiﬁed two dimensions of conformance, ﬁtness and appropri-
ateness [53,54]. fitness relates to the question whether the process behavior
observed complies with the control ﬂow speciﬁed by the process model, whileappropriateness can be used to evaluate whether the model describes the ob-
served process in a suitable way (cf. occam’s razor as discussed in section 1).
7(a) simplified model of processing a liability claim
(b) event log l1 (c) event log l2 (d) event log l3
(e) “underfitting” 
process model(f) “overfitting” 
process modelno. of instances log traces
4070
245
56abdea
acdghfaacgdhfano. of instances log traces
1207
145
562328abdea
acdghfaacgdhfa
achdfaacdhfano. of instances log traces
24
7
15
618bde
aabhf
chf
adbe
acbgdfaa
abeda
100 % fitnessless than 
100 % fitnessmuch less 
than 100 % fitness
100 % fitness
but not sufficiently specific from behavioral  point of view100 % fitness
but not represented in 
structurally  suitable way
figure 4. two dimensions of conformance: ﬁtness and appropriateness.
to illustrate both dimensions of conformance we use the example process
shown in figure 4(a).4at ﬁrst there are two activities bearing the same label “set
checkpoint”. this can be thought of as an automatic backup action within the
context of a transactional system, i.e., activity a is carried out at the beginning
to deﬁne a rollback point enabling atomicity of the whole process, and at the end
to ensure durability of the results. then the actual business process is started
with creating alternative paths for low-value claims and high-value claims, i.e.,claims get registered diﬀerently ( borc) depending on their value. the policy of
the client is always checked ( d) but in the case of a high-value claim, additionally,
the consultation of an expert takes place ( g), and then the ﬁled liability claim
4for simplicity we use a simple example without any reference to soa. later we will
show examples involving multiple services.
8is being checked in more detail ( h). finally, the claim is completed according
to the former choice between band c(i.e., eorf).
figures 4(b)-(d) show three example logs for the process described in fig-
ure 4(a) at an aggregate level. this means that process instances exhibiting the
same event sequence are combined as a logical log trace while recording the
number of instances to weigh the importance of that trace. that is possiblesince only the control ﬂow perspective is considered here. in a diﬀerent setting
like, e.g., mining social networks [9], the resources performing an activity would
distinguish those instances from each other.
event log l1completely ﬁtsthe model in figure 4(a) as every log trace can
be associated with a valid path from start toend. in contrast, event log l2does
not match completely as the traces achdfa and acdhfa lack the execution
of activity g, while event log l3does not even contain one trace corresponding
to the speciﬁed behavior.
now consider the two process models shown in figure 4(e)-(f). although
event log l2ﬁts both models quantitatively, i.e., the event streams of the log
and the model can be matched perfectly, they do not seem to be appropriate
in describing the observed behavior. the ﬁrst one is much too generic (“under-
ﬁtting”) as it covers a lot of extra behavior, allowing for arbitrary sequences
containing the activities a,b,c,d,e,f,g,o r h, while the latter does not
allow for more sequences than those having been observed but only lists the
possible behavior instead of expressing it in a meaningful way (“overﬁtting”).
note that such underﬁtting and overﬁtting models could be constructed for anylog, e.g., also l1and l3in figure 4. therefore, these extremes do not oﬀer a
better understanding than can be obtained by just looking at the aggregated
log. so there is also a qualitative dimension and we claim that a “good” process
model should somehow be minimal in structure to clearly reﬂect the described
behavior (i.e., structural appropriateness ), and minimal in behavior to represent
as closely as possible what actually takes place (i.e., behavioral appropriateness ).
conformance checking aims at both quantifying the respective dimension of
conformance and locating the mismatch, if any. therefore, we have developedmetrics for measuring the ﬁtness, and the behavioral and structural appropriate-
ness of a given process model and event log [53,54]. but we also seek for suitable
visualizations of the results as this is crucial for giving useful feedback to theanalyst.
for example, we can quantify ﬁtness by replaying the log in the model. for
this, the replay of every logical log trace starts with marking the initial place
in the model and then the transitions that belong to the logged events in thetrace are ﬁred one after another. while doing so one counts the number of tokens
that had to be created artiﬁcially (i.e., the transition belonging to the logged
event was not enabled and therefore could not be successfully executed ) and the
number of tokens that had been left in the model, which indicates the process
not having properly completed . only if there were neither tokens left nor missing
the ﬁtness measure evaluates to 1, which indicates 100 % ﬁtness.
9b
a
cdstart c1 c2e
fc3
ac4 end
g hc5
c8
+2-2c6c7remained
enabled
failed 
execution
figure 5. example process model after replay of event log l2.
figure 5 shows that the places of missing and remaining tokens during log
replay can also be used to provide insight into the location of error. becauseof the remaining tokens (whose amount is indicated by a + sign) in place c6
transition ghas remained enabled, and as there were tokens missing (indicated
by a−sign) in place c7transition hhas failed seamless execution. this suggests
that the expert consultation (activity g) did not take place for all the treated
cases, and possible alignment actions would be to either enforce the speciﬁedprocess or to introduce the possibility to skip activity gin the model.
both dimensions of conformance, i.e., ﬁtness and appropriateness, have been
implemented in the prom conformance checker [53,54]. note that the checker
supports duplicate activities , e.g., in figure 4(a) there are two activities with
label a. this is important because multiple activities in a bpel speciﬁcation
can exchange messages of a given type and are therefore indistinguishable. sim-
ilarly, it is important that the conformance checker supports silent steps , i.e.,
activities that are not logged. note that the presence of silent activities makes
it is necessary to construct parts of the state space to ﬁnd the most likely path.
4 mapping bpel onto wf-nets
to provide tool support for conformance checking of bpel processes we relyon two tools recently developed by the authors of this paper: bpel2pnmland wofbpel. bpel2pnml translates bpel process deﬁnitions into petri
nets represented in the petri nets markup language (pnml). wofbpel, built
using woﬂan [59,61], applies static analysis and transformation techniques on theoutput produced by bpel2pnml. for the purpose of conformance checking,
wofbpel is used to: (i) simplify the petri net produced by bpel2pnml by
removing unnecessary silent transitions, and (ii) convert the petri net into aso-called workflow net (wf-net) which has certain properties that simplify
the analysis phase and is the input format required by the prom conformance
checker.
below, we discuss the mapping from bpel to wf-nets and illustrate it using
a bpel process deﬁnition of a supplier service that we will use as a running
example in the remainder of this paper.
104.1 the supplier service
figure 6 provides an overview of a “supplier service” using a visual notation
that directly reﬂects the syntax of bpel. this service provides a purchase order
and change order service for customers, where the purchase order that has beenplaced may be changed once.
  process “supplier”
  sequence “main”
  scope “cancellationscope”
catch fault “orderchange”(main activity ) (fault/event handlers )
invoke
“orderchangeresponse”
while pendingchangeditems >0
invoke
“orderchangeresponse”onevent “change”
throw fault
“orderchange”while pendingorderitems >0
invoke
“orderresponse”invoke
“orderresponse”receive
“order”
figure 6. an abstract view of the supplier process.
the supplier process is initiated upon receiving a purchase order that con-
tains one or several line items. the supplier may accept or reject any ordered
item, possibly suggesting alternative products, quantities or delivery dates in
the latter case. the supplier replies to the purchase order either with a singleresponse listing the outcome for all items, or with multiple responses correspond-
ing to subsets of the items. the rationale for having multiple responses is that
the supplier may be unable to determine outright if it can accept a line item. inthis case, the supplier sends a ﬁrst response listing the items of which the out-
comes have been determined. additional responses are then sent as information
becomes available. after receiving an order response, the customer may requestto change the previous purchase order because of some item(s) being rejected.
a change order is an updated purchase order that overrides the previous one.
similarly to the processing of a purchase order, the supplier may reply with asingle response or with multiple responses to a change order.
appendix a contains the deﬁnitions of the supplier service both as an ab-
stract and as an executable bpel process. an abstract process is deﬁned at
the level of abstraction required to capture public aspects of the service (i.e.,
message exchanges with the environment). in the working example, the abstractprocess speciﬁes that the service receives orders and change orders and sends or-
der responses and change order responses, and captures the control dependencies
between these messages. meanwhile an executable process represents a possible
11implementation of the abstract process. however, services are not always coded
as bpel executable processes. not untypically, services are coded in mainstreamprogramming language (e.g., java). if the supplier service is implemented as a
bpel executable process, it is possible to collect logs of the form (at, pi) in
the terminology of figure 2. this enables conformance checking based on theactivity-oriented logs as illustrated by ﬁgures 2(b) and 2(d). otherwise, confor-
mance checking in the style of ﬁgures 2(a) and 2(c) (i.e., based on messages) can
be performed by comparing a bpel abstract process describing the expectedbehavior of the supplier service with actual message logs of the form (mt, pi).
4.2 mapping bpel to petri nets
we ﬁrst map bpel processes to petri nets which can be then converted to wf-
nets. when using petri nets to capture formal semantics of bpel, we allow the
usage of both labeled and unlabeled transitions. the labeled transitions model
events and basic activities. the unlabeled transitions ( τ-transitions) represent
internal actions that cannot be observed by external users. this section presents
only selected parts of the mapping. a complete version of the formal speciﬁcation
of the mapping can be found in [51].
activities we start with the mapping of a basic activity (x) shown in figure 7,
which also illustrates our mapping approach for structured activities. the net is
divided into two parts: one (drawn in solid lines) models the normal processing
of x, the other (drawn using dashed lines) models the skipping of x.
rx
sx
skippedx
ycx
fxxto_skipx
"skip"y
x
figure 7. a basic activity.
in the normal processing part, the four places are used to capture four pos-
sible states for the execution of activity x: rxfor “ready” state, sxfor “started”
state, cxfor “completed” state, and fxfor “ﬁnished” state. the transition la-
beled xmodels the action to be performed. this is an abstract way of modeling
basic activities, where the core of each activity is considered as an atomic action.twoτ-transitions (drawn as solid bars) model internal actions for checking pre-
conditions or evaluating post-conditions for activities. the skip path is mainly
used to facilitate the mapping of control links. note that the to
skipand skipped
12places are respectively decorated by two patterns (a letter yand its upside-down
image) so that they can be graphically identiﬁed. in figure 7, hiding the subnetenclosed in the box labeled xyields an abstract graphic representation of the
mapping for activities. this will be used in the rest of the paper.
figure 8 depicts the mapping of structured activities. next to the mapping
of each activity is a bpel snippet of the activity. more τ-transitions (drawn as
hollow bars) are introduced for the mapping of routing constructs. in figure 8
and subsequent ﬁgures, the skip path of the mapping is not shown if it is not
used. a detailed description of the mapping [51] is outside the scope of this paper.however, to give some insight into the mapping, we describe the mappings of
while and scope activities in some detail.
( c )  switch
( f )  scope ( d )  pick( b )  flow ( a )  sequence
( e )  whilea
farx
brb
fb
cx
fxx
activity a
activity bname="x"><sequence
</sequence>
rx
fxsx
cxe1e2
ra
farb
fbx
ay
byy ye1
e2</onmessage>
</onalarm>
</pick><onmessage
<onalarm><pick
name="x">
activity a
activity b>z1
z2name="x"><switch
<case>
<condition>
</condition>
activity a    
</case><case>
<condition>
</condition>
activity b
</case>
</switch>rx
fxcxfara
fbrb"z "1sx
"~z1
v
2z "
abyyy yx
fqcqqr
sq
ara
faq
!to_continueq
to_stopq
snapshotq
no_snapshotqc
x:)name="q">
activity a<scope
</scope>fxrx
sx
cxara
fabrb
fbx
</flow>activity bactivity aname="x"><flows
z
</condition>
activity a<while
</while>name="x">sxrx
fxcxara
fa"~z" "z"x
<condition>x
ar
figure 8. structured activities.
awhile activity supports structured loops. in figure 8(e), activity x has a
sub-activity a that is performed multiple times as long as the while condition
(z) holds and the loop construct ends if the condition does not hold anymore
(∼z).
ascope provides event and exception handling. it has a main activity that
deﬁnes its normal behavior. to facilitate the mapping of exception handling,
we deﬁne four ﬂags for a scope, as shown in figure 8(f). these are: tocontinue ,
13indicating the execution of the scope is in progress and no exception has occurred;
tostop, signaling an error has occurred and all active activities nested in the
scope need to stop; snapshot , capturing the scope snapshot deﬁned in [15] which
refers to the preserved state of a successfully completed uncompensated scope;
and nosnapshot , indicating the absence of a scope snapshot.
event handlers a scope can provide event handlers that are responsible for
handling normal events (i.e., message or alarm events) that occur concurrently
when the scope is running. figure 9 depicts the mapping of a scope (q) with
an event handler (eh). the four ﬂags associated with the scope are omitted.
the subnet enclosed in the box labeled ehspeciﬁes the mapping of eh. as
soon as scope q starts, it is ready to invoke eh. event enormal isenabled and
may occur upon an environment or a system trigger. when enormal occurs, an
instance of eh is created, in which activity he (“handling event”) is executed.eh remains active as long as q is active. finally, event e
normalbecomes disabled
once the normal process (i.e., main activity a) of q is ﬁnished. however, if a
new instance of eh has already started before enormal is disabled, it is allowed
to complete. the completion of the scope as a whole is delayed until all active
instances of event handlers have completed.
enormal <onalarm  ><scope name="q">
<eventhandlers>
activity he
</onalarm>
</eventhandlers>
activity a
</scope>example bpel code 2:enormal <onmessage  ><scope name="q">
<eventhandlers>
</onmessage>
</eventhandlers>activity he
activity a
</scope>example bpel code 1:
cq
fqra
fa...
caaqr
sq
enormal
rhe
fheheto_invokeeh
/0/0/0/0/0/0
/1/1/1/1/1/1enabledehq
figure 9. an event handler.
fault handlers if a fault occurs during the normal process of a scope, it will
be caught by one of the fault handlers deﬁned for the scope, and the scope
switches from normal processing mode to fault handling mode. a scope in which
a fault has occurred is considered to have ended abnormally and thus cannot becompensated, no matter whether or not the fault can be handled successfully.
figure 10 depicts the mapping of a scope (q) with a fault handler (fh). the
subnet enclosed in the box labeled fhspeciﬁes the mapping of fh. it has a
14similar structure as the mapping of an event handler. nevertheless, there are
some subtle diﬀerences as explained next.
q<faulthandlers>
<catch faultname="fault">
activityhf<scope name="q">
</scope></catch>
activityafhinvokedfhto_invoke
"efault"q
q
fhhfa
a
a
qr
s
r
c
fqf
hf
hfr
f:)q
qto_continue
!c
x
no_snapshot snapsho tto_stopq
q</faulthandlers>
figure 10. a fault handler.
firstly, as compared to the normal events deﬁned within event handlers,
faults that may arise during a process execution can be considered as fault events .
transition “ efault” represents such fault event, and upon its occurrence, the status
of scope q changes from tocontinue totostop. all activities that are currently
active in q need to stop, and any other fault events that may occur are disabled.
secondly, the fault handler fh, once invoked, cannot start its activity hf
(“handling fault”) until the main activity (a) of scope q has terminated. place
invoked fhis used to capture an intermediate state after the occurrence of efault
but before the execution of hf. for the mapping of activity termination (which
is not shown in figure 10), we adopt an approach of conducting a dry run
of the activity without performing its concrete actions (i.e., the core action of
each basic activity) nor allowing it to process any normal event. as a result, an
activity being terminated will end up in the “ﬁnished” state. for example, in
figure 10, if activity a is required to terminate, place fawill get marked upon
its termination.
finally, if the fault has been handled successfully, evaluation of any post-
condition for scope q will be performed as normal. accordingly, in figure 10,place c
qwill get marked. however, the status of q will change from tostopto
nosnapshot to indicate that a fault has occurred during its performance.
example: mapping of the supplier process figure 11 depicts the mapping
of the supplier process shown in figure 6. for illustration purposes, some net de-tails (e.g., those associated to the process scope and the skip paths) are omitted.
the complete mapping of the supplier process, as obtained using bpel2pnml,
is shown in figure 12. below, we use figure 11 to illustrate the mapping.
15in figure 11, we instantiate the general mapping of a fault handler shown
in figure 10 for a fault generated by the throw activity (e.g., throwfault ). in
this case, the action of throwing a fault itself resembles the corresponding fault
event. also, the mapping in figure 11 ensures that, when the cancellationscope
is faulty, 1) any active instance of event handler will terminate before the faulthandling starts; 2) event change is disabled; and 3) for activity while1 , its sub-
activity orderresponse is dry-runned once.
4.3 from petri nets to wf-nets
the prom conformance checker takes a wf-net [1] and an mxml log [25]
as input. a wf-net is a petri net which models a workﬂow process deﬁnition.it has exactly one input place (called source place) and one output place (sink
place). a token in the source place corresponds to a case (i.e., process instance)
which needs to be handled, and a token in the sink place corresponds to a casewhich has been handled. also, in a wf-net there are no dangling tasks and/or
conditions. tasks are modeled by transitions and conditions by places. therefore,
every transition/place should be located on a path from the source place to the
sink place in a wf-net [1].
the petri net shown in figure 12 is not a wf-net. it contains unconnected
parts and additional source and sink places resulting from idle skip fragments
(e.g., the two places connected via a τ-transition located on the top right of
figure 12). in order to facilitate the mapping of control links and to be consistentin the way structured activities are mapped in bpel, we have assumed in our
mapping that any activity may be skipped. as a result, a skip path is generated
for every activity in bpel2pnml. however, not every activity can actually getskipped. a straightforward counter example is the root activity (i.e., the process
scope). thus, by removing these idle skip fragments, the above petri net can be
converted to a wf-net.
we use wofbpel to convert the petri nets returned by bpel2pnml to
wf-nets. wofbpel has originally been built to perform analysis on the petri
nets as output from bpel2pnml. since it uses woﬂan [59,61] and woﬂan canonly handle wf-nets, wofbpel has been provided with the functionality to
remove the idle skip fragments. in addition, wofbpel has also been provided
with behavior preserving reduction rules based the ones as given by murata [50],
and therefore can be used to reduce the size of a net as much as possible (by
removing transient states). note that there is a diﬀerence between the rules givenby murata and the rules used in wofbpel. the explanation for this diﬀerence
is that in our case the non-silent transitions (represented by labeled transitions)
should not be removed.
figure 13 visualizes the reduction rules used in wofbpel, where only silent
transitions ( τ-transitions) can be removed. the ﬁrst rule shows that a (silent)
transition connecting two places may be removed by merging the two places, pro-vided that tokens in the ﬁrst place can only move to the second place. the rules
are self-explanatory. however, when applying the rules one should clearly diﬀer-
entiate between silent and non-silent transitions. for example, in the fourth rule
16cancellationscope
throwfault[note]: the concrete action of ‘‘throwfault’’ is modelled by one transition, which is graphically represented
by two transitions to avoid arc crossing....
...
...ccs
f
mainf
fprocesscancellationscopec
:)!change
..
....
throwfault
tfftfrto_invokeeh
ehenabled...
...
.....
....
......
......
order
......
orderresponser
for
or
...
...orderchangeresponserocr
ocrfthrowfault x
invokedfhfh to_invoke
...while2r
...
...rocr
focr...
...
fwh2c
while2process
r
or
orderresponsewh1
or
fcsrs
or
orcancellationscoper
scs
while1fwhile1
cwh1frrr
mainprocess
o
o
fh
responseswh2
orderchange
figure 11. mapping of the supplier process shown in figure 6.
17at least one of the transitions should be silent, otherwise the rule should not be
applied (as indicated). note that in this rule the execution of yis inevitable once
xhas been executed. therefore, it is only possible to postpone its occurrence.
the reduction rules shown in figure 13 do not preserve the moment of choice
and therefore assume trace semantics rather than branching/weak bisimulation[34].
x
 xxy z
xy xyx=
or y=
if x=
then z=y 
else z=x
figure 13. behavior preserving reduction rules used in wofbpel.
based on the above, figure 14 depicts the wf-net resulting from the petri
net shown in figure 12. it has been automatically generated from the bpel
process shown in the appendix using bpel2pnml and wofbpel.
5 monitoring and correlating messages
in order to perform conformance checking, we assume that messages sent and
received by a service are logged. the resulting logs should be ordered chronologi-
cally and should contain for each message, an indication of whether the message
is inbound or outbound, as well as the message headers (e.g., http and/or
19τ
ττ τ τ ττorder
orderresponse
orderresponsechangeτ
τ ττ
exitτ
ττ
throwfault
ττ
ττ
τ
orderchangeresponse
orderchangeresponse
figure 14. the wf-net for the petri net shown in figure 12.
20soap headers). the message payload is not relevant as we focus on behavioral
rather than structural conformance.
given such a message log and a bpel abstract process deﬁnition that is
presupposed to correspond to the message log, we need to extract log tracessuch as those depicted in figures 4(b)-(d).
5the labels in these log traces should
correspond to labels in the petri net obtained from the bpel abstract process
deﬁnition. as suggested in figure 2, these labels must allow one to determinethe direction of messages (indicated by arrows in figure 2) and its message type
(designated as mt in figure 2). thus, for each message we must determine:
–its corresponding bpel abstract process instance (herewith called its service
instance ). this is required because the event log needs to be structured as
a set of log traces, each one corresponding to one execution of the process
capturing the expected behavior of the service.
–a label denoting the bpel communication action in the abstract process
deﬁnition to which the production or consumption of the message is at-tributed.
in the remainder of this section we discuss both issues in detail.
5.1 grouping messages into log traces
in order to apply the proposed conformance checking technique, messages need
to be grouped into log traces each representing one execution of the service, i.e.,
each message needs to be associated to a process instance (case). if the service is
implemented as an executable bpel process, this grouping of messages is trivial.
the executable process is executed by an engine that generates logs associatingeach communication action (and thus the message consumed or produced by
that action) to a process instance. all messages consumed or produced by a
given process instance can then be grouped into a log trace.
if no executable bpel process is available, we need to group messages into
log traces just by looking at their contents. current web service standards donot make a provision for messages to include a “service instance identiﬁer”, so
assuming the existence of such identiﬁer may be unrealistic in some situations.
6
however, we can use an alternative grouping mechanism that we term chained
correlation . the idea of chained correlation is that every message, except for
the ﬁrst message of a service instance, refers to at least one previous messagebelonging to the same service instance. in the context of contemporary web
5note that we will extract more information but this is the bare minimum for confor-
mance checking. the mxml format also allows for the logging of timestamps, data,resources, and transactional aspects.
6note that more monitoring approaches in the web-services context struggle with thesame problem. therefore, dedicated platforms have been developed to deal with thisproblem. for example the web services navigator [52] uses ibm’s data collector
logging the content and context of soap messages. the data collector inserts a
proprietary soap header element into messages that enables correlation.
21service standards and platforms this correlation information can be obtained in
at least two ways:
–when using soap in conjunction with ws-addressing, each message con-
tains an identiﬁer ( messageid header) and may refer to a previous message
through the relatesto header. if we assume that these addressing headers are
used to relate messages belonging to the same service instance in a chained
manner, it becomes possible to group a raw service log containing all the
messages sent or received by a service into log traces corresponding to ser-vice instances. this is the method used in our case study and more details
will be given in section 6. the method is applicable when using oracle
bpel as well as various other web service implementation and execution
environments.
–the second method is based on the identiﬁcation of properties that a message
has in common with another message belonging to the same service instance.in bpel, properties shared by messages belonging to the same service in-
stance are captured as correlation sets . a correlation set can be seen as a
function that maps a message to a value of some type. correlation sets are
associated with communication actions. when a message is received which
has the same value for a correlation set as the value of a message previouslysent by a running service instance, the message in question is associated with
this instance. this allows one to map messages to service instances, except
for those messages that initialize a correlation set, that is, those messagesthat start a new instance. assuming that in the bpel abstract process of a
service only the initial actions of the protocol initialize correlation sets, and
all other actions refer to the same correlation sets as the initial action, eachmessage produced or consumed by the service can be mapped to a service
instance as follows: the full message log is scanned in chronological order. a
message is either related to a new service instance if it corresponds to a com-munication action that initializes a correlation set, or related to a previously
identiﬁed service instance if the values of its correlation set match those of a
message sent by the previous service instance. this method can be appliedin the scenario of figure 2(a) where the message logs and an abstract bpel
process are available.
5.2 abstracting messages as labels
once the message log has been grouped into log traces corresponding to service
instances, we need to associate each message in a log trace with a transition label
used in the petri net obtained from the bpel abstract process deﬁnition. thesetransition labels represent communication actions seen at the level of abstraction
used for conformance checking.
bpel’s communication action types are: invoke ,reply,receive ,a n d onmes-
sage(oronevent in bpel 2.0). a receive or an onmessage action consumes one
message, a reply produces one message, while an invoke can either produce a
single message ( simple send ) or produce a message and consume another one
22in that order ( synchronous send-receive ). without loss of generality, we assume
that the bpel abstract process given to the conformance checker does not con-tain any synchronous send-receive. for the purposes of conformance checking, a
synchronous send-receive can be decomposed into a sequence activity containing
a simple send followed by a receive. also without loss of generality, we assimilatereply actions to send actions and onmessage handlers to receive actions, since
these elements have the same eﬀect in terms of message logs.
thus, for conformance checking purposes, we view communication actions in
a bpel abstract process as being labeled by a pair /angbracketleftd, mt /angbracketrightwhere d stands for
the direction (inbound or outbound) and mt for message type as in figure 2.
all non-communication actions are given τ-labels since their execution does not
manifest itself as message log entries. actions with τ-labels in the abstract pro-
cess then get translated to silent petri nets transitions.
under this labeling scheme, it is possible that two actions in a bpel process
get the same label. hence, the petri net generated from a bpel abstract process
may have multiple (non-silent) transitions with the same label. fortunately, thispossibility is supported by the conformance checking technique, e.g., the example
in figure 4(a) contains two actions with label a.
each communication action in a bpel process deﬁnition is linked to a wsdl
operation. a wsdl operation in turn is associated with binding information
that determines how messages related to that operation are encoded and ex-
changed in a given communication protocol (e.g., soap over http or xml
over http). the structure of an operation’s binding information varies depend-ing on the communication protocol, but in any case it provides a means to iden-
tify messages that pertain to that operation. in the case of soap over http,
the binding information associates the wsdl operation to a soap-action iden-
tiﬁer. this makes it possible to associate a message with a wsdl operation by
inspecting the soap-action ﬁeld in the http header of the message. in thecase of a communication protocol based on plain xml over http, the binding
information includes a mapping from each wsdl operation to a relative url
to be found in the http headers of every message pertaining to that operation.this makes it possible to associate a message to an operation by analyzing the
“request uri” in the message’s http header.
thus, every message produced or consumed by a service for which a bpel
abstract process is deﬁned can be mapped to a wsdl operation. with thisinformation and the message direction, it is possible to construct log traces such
that each entry in the trace can be matched to a communication action label
under the labeling scheme described above.
because we are able to map a bpel speciﬁcation onto a petri net (cf. sec-
tion 4) and we can associate messages to both process instances and activities
(cf. this section), we can apply the conformance checking techniques described
in section 3.
236 example
in this section we apply our ﬁndings to the example bpel process introduced
in section 4. the goal of this section is to demonstrate the applicability ofour approach and tools (bpel2pnml, wofbpel, and the prom conformance
checker). to generate soap messages we need to implement the process spec-
iﬁed in terms of abstract bpel. we could have used a conventional languageto do this. however, we chose not to do so and implemented the executable
supplier process using oracle bpel 10.1.2, i.e., the current bpel oﬀering of
oracle. after implementing the executable bpel process, we obtained diﬀerentlogs by monitoring the soap messages between two oracle bpel servers (one
for the supplier and one for the customer). note that we use the local message
observer setting for choreography conformance checking as shown in figure 2(c).
using these logs we will show that we can correlate the soap messages that
belong to the same process instance (as discussed in section 5). finally, we showthat we can successfully check the conformance of the abstract supplier bpel
process using the techniques described in section 3.
6.1 executable supplier bpel process
we have implemented the executable supplier bpel process in oracle bpel
process manager 10.1.2. figure 15 shows the process using jdeveloper. on the
far left, we see a number of partner links: taskmanagerservice, taskactionhan-
dler, taskroutingservice, identityservice, and client. the ﬁrst four partner links
are used for the user tasks handling the purchase order (or change order), the
remaining client service is used for the customer.
the pane in the middle contains the actual process, which consists of three
‘threads’. the leftmost thread handles a purchase order and its responses. the
rightmost thread handles the receipt of a change order: it generates a fault whichpreempts the leftmost thread and starts the middle thread. the middle thread
handles the responses to the change order.
after having deployed this process, we can initiate it from oracle’s bpel
console. using oracle’s bpel worklist, we can handle the purchase order and
send responses back to the customer. a change order can be initiated from the
bpel console, and the corresponding change order can be handled using thebpel worklist. as an example, figure 16 shows a work item corresponding to
the purchase order when two (out of ﬁve) line items are about to be accepted.
6.2 soap messages
soap messages are typically sent between two processes, which can both run
on the same server or on diﬀerent servers. for this reason, we also implemented
a simple customer executable bpel process. the customer process places anorder, waits for an orderresponse, then places a changeorder, waits for two
orderchangeresponses, and then exits. for sake of generality, we ran both pro-
cesses on two diﬀerent (oracle bpel 10.1.2) servers.
24figure 15. the supplier process using jdeveloper.
25figure 16. a work item in oracle bpel worklist.
unfortunately, we were unable to obtain the soap messages directly from
oracle bpel. no option existed to log all soap messages send and/or receivedto some ﬁle, and they were also not stored in the database underlying the oracle
bpel server. as a result, we had to use a tcp tunneling technique
7to obtain
the soap messages. with this technique, it is fairly easy to eavesdrop on aspeciﬁc combination of host and port. typically, incoming messages all go to the
same combination of host and port, but outgoing messages can be directed to a
multitude of combinations of hosts and ports. as a result, it is more convenientto eavesdrop on the incoming messages.
examples of the soap message logs from both servers are given in ap-
pendix b. the customer process was run on the server named ga2550, whereas
the supplier process was run on the server named ga2494.
6.3 message correlation
from the soap message logs (see appendix b), it is straightforward to generate
a log as shown in figure 17: the ﬁrst message (the order) contains a unique mes-
sage id ( bpel://localhost/default/customer ∼1.1/301-bpinv0-bpseq0.3-3), and
all other related messages relate to this message id.
7see http://www.oracle.com/technology/products/ias/bpel/htdocs/orabpel technotes.tn001.html
26both the wf-net corresponding to the abstract supplier process and the
log from figure 17 can be imported by the prom framework to check theirconformance.
8
6.4 conformance checking
table 1. desirable and undesirable scenarios for the supplier service execution.
log trace
(order, orderresponse)
(order, orderresponse, orderresponse, orderresponse)(order, orderresponse, change, orderchangeresponse)
(order, orderresponse, orderresponse, change, orderchangeresponse)
(order, orderresponse, change, orderchangeresponse, orderchangeresponse)
(order)
(order, orderresponse, change)
(orderresponse)(order, orderresponse, change, orderresponse, orderchangeresponse)
(order, change, orderchangeresponse)
(change)(order, orderresponse, change, orderchangeresponse, change)(order, orderresponse, change, change, orderchangeresponse)scenario
123
4
5
6
7
89
10
111213fitness
1.01.01.0
1.0
1.0
0.625
0.749
0.905
1.0
0.759
0.0
0.9140.971desirable
behaviorundesirable
behavior
having demonstrated that it is feasible to obtain such an event log from
real service executions we now use conformance checking techniques (see also
section 3) to validate the supplier service speciﬁcation for a number of interactionscenarios. table 1 shows ﬁve execution sequences which should be valid for the
supplier service as speciﬁed in section 4.1 and eight which should not.
scenarios 1–5r eﬂect message sequences which should be compliant with
the process speciﬁcation (note that scenario 5 corresponds to the example from
figure 17). they all start with an initiating order, followed by one or more
orderresponses , and potentially complete with a change request and one or
more orderchangeresponses .
scenarios 6 – 13 represent conceivable settings of misbehavior, whereas 6
– 9 correspond to possible violations by the supplier service and 10 – 13 con-
tain violations by the client or environment of the service. both scenario 6 and
7 show situations where the conversation has not been completed properly asafter having received the order request the service needs to send at least one
orderresponse (missing in scenario 6) and following a change request at least
one orderchangeresponse must be sent (missing in scenario 7). in scenario 8
the supplier service sends an orderresponse which is not correlated to a pre-
vious order, and in scenario 9 it still sends another orderresponse although a
8both the corresponding schema deﬁnition and the promimport framework, which
converts logs from existing (commercial) pais to the xml format used by prom,
can be downloaded from www.processmining.org .
27<?xml version="1.0" encoding="utf-8"?>
<workflowlog>
<source
program="oracle bpel, using tcp tunneling"
/>
<process
id="http://services.qut.com/supplier"description="supplier 1.1, using customer 1.1 as customer stub"
>
<processinstance
id="bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3"
description="instance 301"
>
<audittrailentry>
<workflowmodelelement>order</workflowmodelelement>
<eventtype>complete</eventtype>
<timestamp>2005-10-20t11:54:09-00:00</timestamp>
</audittrailentry><audittrailentry>
<workflowmodelelement>orderresponse</workflowmodelelement>
<eventtype>complete</eventtype><timestamp>2005-10-20t11:58:08-00:00</timestamp>
</audittrailentry>
<audittrailentry>
<workflowmodelelement>change</workflowmodelelement>
<eventtype>complete</eventtype>
<timestamp>2005-10-20t11:58:20-00:00</timestamp>
</audittrailentry>
<audittrailentry>
<workflowmodelelement>orderchangeresponse</workflowmodelelement><eventtype>complete</eventtype>
<timestamp>2005-10-20t11:58:35-00:00</timestamp>
</audittrailentry><audittrailentry>
<workflowmodelelement>orderchangeresponse</workflowmodelelement>
<eventtype>complete</eventtype><timestamp>2005-10-20t11:58:43-00:00</timestamp>
</audittrailentry>
</processinstance>
</process>
</workflowlog>
figure 17. an example soap-based log.
28change request has been received already (and thus only orderchangeresponses
should be sent). scenario 10 shows the situation where the environment invokesachange request although the ﬁrst orderresponse has not been sent by the ser-
vice yet. in scenario 11 a change request is invoked which is not even related to
a previous order. both scenario 12 and 13 show a situation in which a second
change is requested by the client, which is not allowed.
in order to verify the given scenarios with respect to the supplier service
speciﬁcation from section 4.1 we use the reduced petri net model generated
from the abstract bpel process, shown in figure 14. having imported it into
the prom framework, the conformance checker [53,54] is able to replay thelog containing the scenarios in the model. based on the number of missing and
remaining tokens the ﬁtness measurement is calculated indicating whether a
scenario corresponds to a valid execution sequence for that process. if not, thediagnostic visualization of missing and remaining tokens may help to locate the
problem.
figure 18. the conformance checker analyzing the scenarios from table 1.
consider for example figure 18, in which the conformance checker shows
a part of the model after the replay of scenario 8. in this situation a single
orderresponse is sent without having received any previous order. the place in
29the upper left corner which has no incoming arcs represents the start place of
the whole process (i.e., a token will be put there in order to start the replay ofthe scenario). following the control ﬂow of the model it can be observed that
theorder transition is supposed to ﬁre ﬁrst in order to produce a token in the
enlarged place on the right, which can be consumed by the orderresponse tran-
sition afterwards. however, since the log replay is carried out from a log-based
perspective the missing tokens (indicated by a −sign) are created artiﬁcially and
the task belonging to the observed message in the model (i.e., the orderresponse
transition) is executed immediately. the fact that it had been forced to do so is
recorded and the task is marked as having failed successful execution (i.e., it was
not enabled). furthermore, there are tokens remaining in the enlarged places inthe upper and the lower left corner (indicated by a + sign), which leads to the
order transition remaining enabled after replay has ﬁnished. remaining tasks
are visualized with the help of a shaded rectangle in the background and they
hint that their execution would have been expected.
now reconsider table 1 where the fitness column indicates for each scenario
whether it corresponds to a valid execution sequence for our supplier service (i.e.,
during replay there were neither tokens missing nor remaining and therefore ﬁt-ness = 1 .0) or not (i.e., ﬁtness <1.0). as it shows 100 % ﬁtness for scenario 1
– 5 we have proven the abstract bpel process being a valid speciﬁcation with
respect to the “well-behaving” conversation scenarios we thought of. however,it also allows for an execution sequence that we have classiﬁed as undesirable
behavior, namely scenario 9: although another orderresponse is sent after a
change request has been received already (and thus only orderchangeresponses
should be sent) the scenario turns out to comply with the given abstract bpel
process speciﬁcation. this is an interesting result as it makes us aware of the factthat—due to a number of intermediate states—the chosen fault/event handler
construct does not completely capture the intended constraint.
as mentioned in section 3, there is another dimension of conformance be-
sides ﬁtness we are interested in: appropriateness . appropriateness relates to the
question whether the model is a suitable representation for the process that has
been observed in the log. the conformance checker supports both a metric for
structural and for behavioral appropriateness (the deﬁnitions and further de-
tails are provided in [53,54]). as for the structural appropriateness, the reduced
petri net depicted in figure 14 has been measured to be 0 .127, which is a rela-
tively low value caused by the many silent transitions ( τ-transitions). however,
measuring the structural appropriateness of the non-reduced petri net results in
0.049, which is an even worse value reﬂecting the diﬃculty to understand such
a complicated model. the behavioral appropriateness for the desirable scenarios
1 – 5 has been measured to be 0 .767, which is a rather good value (for example,
the model in figure 4(e) has a behavioral appropriateness of 0 .0 with respect
to event log l2). but unlike the ﬁtness metric the implemented appropriateness
metrics do not indicate an optimal point (such as 1 .0 indicates a perfect ﬁtness)
and therefore can rather be used as a means to compare alternative process
30models. this does not apply here but to illustrate the usefulness of a behav-
ioral appropriateness analysis in general, we want to point out that an improvedmetric should have been able to directly detect the extra behavior covered by
scenario 9, and also to locate the corresponding parts in the model.
7 related work
since the early nineties, workﬂow technology has matured [33] and several text-
books have been published, e.g., [5,26]. petri nets have been used for the modelingof workﬂows [5,17,26] but also the orchestration of web services [47].
several attempts have been made to capture the behavior of bpel [14] in
some formal way. some advocate the use of ﬁnite state machines [30], othersprocess algebras [29], and yet others abstract state machines [28] or petri nets
[51,44,57,60]. (see [51] for a more detailed literature review.) for a detailed
analysis of bpel based on the workﬂow patterns [6] we refer to [62]. this paperuses the the translation presented in [51]. note that we have also developed an
approach to translate (colored) petri nets into bpel [7].
clearly, this paper builds on earlier work on process mining, i.e., the extrac-
tion of knowledge from event logs (e.g., process models [12,13,19,31,32,38] or
social networks [9]). for example, the well-known αalgorithm [12] can derive
a petri net from an event log. it is impossible to give a complete overview ofprocess mining here. therefore, we refer to a special issue of computers in in-
dustry on process mining [11] and a survey paper [10]. process mining can be
seen in the broader context of business (process) intelligence (bpi) and busi-ness activity monitoring (bam). in [36,37,55] a bpi toolset on top of hp’s
process manager is described. the bpi toolset includes a so-called “bpi pro-
cess mining engine”. in [49] zur muehlen describes the pisa tool which canbe used to extract performance metrics from workﬂow logs. similar diagnostics
are provided by the aris process performance manager (ppm) [39]. the latter
tool is commercially available and a customized version of ppm is the staﬀwareprocess monitor (spm) [58] which is tailored towards mining staﬀware logs.
in this paper we use the conformance checking techniques described in [53,54]
and implemented in our prom framework [24]. the work of cook et al. [20,18]is closely related to our work on conformance checking. in [20] the concept of
process validation is introduced. it assumes an event stream coming from the
model and an event stream coming from real-life observations, both streams arecompared. here the time-complexity is problematic as the state-space of the
model needs to be explored. in [18] the results are extended to include time
aspects. the notion of conformance has also been discussed in the context ofsecurity [8], business alignment [2], and genetic mining [48]. however, in each of
the papers mentioned only ﬁtness is considered and appropriateness is mostly
ignored. an exception is the preliminary work reported in [53,54]. therefore,
this style of conformance checking is used in this paper.
the need for monitoring web services has been raised by other researchers.
for example, several research groups have been experimenting with adding mon-
31itor facilities via soap monitors in axis http://ws.apache.org/axis/ . [41]
introduces an assertion language for expressing business rules and a frameworkto plan and monitor the execution of these rules. [16] uses a monitoring approach
based on bpel. monitors are deﬁned as additional services and linked to the
original service composition. another framework for monitoring the complianceof systems composed of web-services is proposed in [43]. this approach uses event
calculus to specify requirements. [42] is an approach based on ws-agreement
deﬁning the crona framework for the creation and monitoring of agreements.in [35,27], dustdar et al. discuss the concept of web services mining and en-
vision various levels (web service operations, interactions, and workﬂows) and
approaches. our approach ﬁts in their framework and shows that web servicesmining is indeed possible. in [52] a tool named the web service navigator is
presented to visualize the execution of web services based on soap messages.
the authors use message sequence diagrams and graph-based representations of
the system topology. our work diﬀers from these papers in two ways. first of
all, we use a process model to check conformance rather than a set of rules. typ-ically, it is easier to specify a process rather than a complete set of constraints.
moreover, it enables a more intuitive visualization of the problem areas. second,
we consider the problem of correlation (i.e., linking messages to a single processinstance) in more detail. it is surprising that most papers simply ignore this
problem.
this paper focuses on conformance by comparing the observed behavior
recorded in logs with some predeﬁned model. this could be termed “run-timeconformance”. however, it is also possible to address the issue of design-time con-
formance , i.e., comparing diﬀerent process models before enactment. for exam-
ple, one could compare a speciﬁcation in abstract bpel with an implementationusing executable bpel. similarly, one could check at design-time the compati-
bility of diﬀerent services. here one can use the inheritance notions [3] explored
in the context of workﬂow management and implemented in woﬂan [61]. axelmartens et al. [44,45,46,56] have explored questions related to design-time con-
formance and compatibility using a petri-net-based approach. for example, [45]
focuses on the problem of consistency between executable and abstract processesand [46] presents an approach where for a given composite service the required
other services are generated.
8 conclusion
in this paper we explored the feasibility of choreography conformance check-
ing. we started with an overview describing the various ways one could extractrun-time data in the context of services. for a particular language, i.e., abstract
bpel, we showed that it is possible to do conformance checking. speciﬁcations
in terms of abstract bpel can be mapped onto petri nets and the soap mes-sages exchanged between the various services can be mapped onto our mxml
format. this enables us to do conformance checking. given a set of messages
and an abstract bpel speciﬁcation we can measure ﬁtness and appropriate-
32ness. moreover, if the observed behavior does not match the speciﬁed behavior,
the deviations can be shown in both the log and the model. using a case studyutilizing oracle bpel as a process engine, we demonstrated that our approach
is indeed feasible using current technology. we have implemented three tools to
achieve all of this: (1) bpel2pnml (for the mapping from bpel to pnml),(2) wofbpel (for process veriﬁcation and cleaning up the automatically gener-
ated petri net), and (3) the prom conformance checker. this paper focused on
abstract bpel. however, note that other languages could also be supported byreplacing bpel2pnml by a component providing the mapping onto petri nets
for the selected alternative language.
in our conformance checking experiments we experienced that the use bpel
as a speciﬁcation language (abstract bpel) is problematic. bpel is essentially
an imperative programming language in which the basic communication primi-tives such as sending and receiving a message are mixed with a wide variety of
routing constructs. the same process can be represented in diﬀerent ways
9, but
in most cases the user is forced to over-specify the desired behavior. for example,it is not possible to specify that two activities exclude each other (this is diﬀerent
from a choice made at some point). similar problems apply to ws-cdl, which
fundamentally only diﬀers from bpel in that it views interactions from a global
perspective. as a result, these languages are unsuitable for describing processes
to be used as a starting point for conformance checking. indeed, conformancechecking is more useful when performed against speciﬁcations of what a service
must, can and cannot do, rather than against speciﬁc procedures for delivering
services which is what ws-cdl and bpel capture. a “true” choreography lan-guage should allow for the speciﬁcation of the “what” without having to state
the “how”. also, in such language, being able to express what cannot happen
is as important as being able to express what can happen, and both bpeland ws-cdl fail to capture “forbidden” scenarios: they focus exclusively on
possible scenarios. this is similar to the diﬀerence between a program and its
speciﬁcation. one can specify what an ordered sequence is by formulating a setof properties, without specifying an algorithm to sort a sequence.
future work will aim at the development of a better language for specifying
choreographies. moreover, we would like to apply our approach to more real-life
case studies. one of the problems we are facing is that at this point in time
only few organizations use bpel and can provide us with soap logs. clearly,conformance checking can be applied in many domains ranging from auditing
(cf. the sarbanes-oxley act) to software testing. therefore, we plan to do a wide
variety of applications and not limit ourselves to web services. another topic for
further research is the visualization of behavior/conformance, e.g., we would like
to combine the ideas presented in [52] with our more process-oriented approach.
9recall that bpel merges two styles of modeling, i.e., the block-structured style of
microsoft’s biztalk and the graph-oriented style of ibm’s mqseries workﬂow.
33references
1. w.m.p. van der aalst. the application of petri nets to workﬂow management.
the journal of circuits, systems and computers , 8(1):21–66, 1998.
2. w.m.p. van der aalst. business alignment: using process mining as a tool for
delta analysis. in j. grundspenkis and m. kirikova, editors, proceedings of the 5th
workshop on business process modeling, development and support (bpmds’04) ,
volume 2 of caise’04 workshops , pages 138–145. riga technical university, latvia,
2004.
3. w.m.p. van der aalst and t. basten. inheritance of workﬂows: an approach
to tackling problems related to change. theoretical computer science , 270(1-
2):125–203, 2002.
4. w.m.p. van der aalst, m. dumas, a.h.m. ter hofstede, n. russell, h.m.w. ver-
beek, and p. wohed. life after bpel? in m. bravetti, l. kloul, and g. zavattaro,editors, ws-fm 2005 , volume 3670 of lecture notes in computer science , pages
35–50. springer-verlag, berlin, 2005.
5. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
6. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
7. w.m.p. van der aalst, j.b. jørgensen, and k.b. lassen. let’s go all the way:
from requirements via colored workﬂow nets to a bpel implementation of a
new bank system paper. in r. meersman and z. tari et al., editors, on the move
to meaningful internet systems 2005: coopis, doa, and odbase: otm con-
federated international conferences, coopis, doa, and odbase 2005 , volume
3760 of lecture notes in computer science , pages 22–39. springer-verlag, berlin,
2005.
8. w.m.p. van der aalst and a.k.a. de medeiros. process mining and security:
detecting anomalous process executions and checking process conformance. in
n. busi, r. gorrieri, and f. martinelli, editors, second international workshop
on security issues with petri nets and other computational models (wisp 2004) ,
pages 69–84. star, servizio tipograﬁco area della ricerca, cnr pisa, italy, 2004.
9. w.m.p. van der aalst and m. song. mining social networks: uncovering interac-
tion patterns in business processes. in j. desel, b. pernici, and m. weske, editors,international conference on business process management (bpm 2004) ,v o l u m e
3080 of lecture notes in computer science , pages 244–260. springer-verlag, berlin,
2004.
10. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
11. w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining ,s p e c i a l
issue of computers in industry, volume 53, number 3. elsevier science publishers,
amsterdam, 2004.
12. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
13. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
3414. t. andrews, f. curbera, h. dholakia, y. goland, j. klein, f. leymann, k. liu,
d. roller, d. smith, s. thatte, i. trickovic, and s. weerawarana. business process
execution language for web services, version 1.1. standards proposal by beasystems, international business machines corporation, and microsoft corpora-
tion, 2003.
15. a. arkin, s. askary, b. bloch, f. curbera, y. goland, n. kartha, c.k. liu,
s. thatte, p. yendluri, and a. yiu. web services business process execution
language version 2.0. ws-bpel tc oasis, 2005.
16. l. baresi, c. ghezzi, and s. guinea. smart monitors for composed services. in
icsoc ’04: proceedings of the 2nd international conference on service oriented
computing , pages 193–202, new york, ny, usa, 2004. acm press.
17. p. chrzastowski-wachtel. a top-down petri net based approach for dynamic
workﬂow modeling. in w.m.p. van der aalst, a.h.m. ter hofstede, and m. weske,editors, international conference on business process management (bpm 2003) ,
volume 2678 of lecture notes in computer science , pages 336–353. springer-
verlag, berlin, 2003.
18. j.e. cook, c. he, and c. ma. measuring behavioral correspondence to a timed
concurrent model. in proceedings of the 2001 international conference on soft-
ware mainenance , pages 332–341, 2001.
19. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
20. j.e. cook and a.l. wolf. software process validation: quantitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147–176, 1999.
21. f. curbera, y. goland, j. klein, f. leymann, d. roller, s. thatte, and s. weer-
awarana. business process execution language for web services, version 1.1.standards proposal by bea systems, international business machines corpora-
tion, and microsoft corporation, 2003.
22. j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
23. j. desel, w. reisig, and g. rozenberg, editors. lectures on concurrency and petri
nets, volume 3098 of lecture notes in computer science . springer-verlag, berlin,
2004.
24. b. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters, and
w.m.p. van der aalst. the prom framework: a new era in process mining toolsupport. in g. ciardo and p. darondeau, editors, application and theory of petri
nets 2005 , volume 3536 of lecture notes in computer science , pages 444–454.
springer-verlag, berlin, 2005.
25. b.f. van dongen and w.m.p. van der aalst. a meta model for process mining
data. in j. casto and e. teniente, editors, proceedings of the caise’05 works hops
(emoi-interop workshop) , volume 2, pages 309–320. feup, porto, portugal,
2005.
26. m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.
27. s. dustdar, r. gombotz, and k. baina. web services interaction mining. technical
report tuv-1841-2004-16, information systems institute, vienna university of
technology, wien, austria, 2004.
3528. d. fahland and w. reisig. asm-based semantics for bpel: the negative control
ﬂow. in d. beauquier and e. b¨ orger and a. slissenko, editor, proc. 12th interna-
tional workshop on abstract state machines , pages 131–151, paris, france, march
2005.
29. a. ferrara. web services: a process algebra approach. in proceedings of the 2nd
international conference on service oriented computing , pages 242–251, new york,
ny, usa, 2004. acm press.
30. j.a. fisteus, l.s. fern´ andez, and c.d. kloos. formal veriﬁcation of bpel4ws
business collaborations. in k. bauknecht, m. bichler, and b. proll, editors, pro-
ceedings of the 5th international conference on electronic co mmerce and web
technologies (ec-web ’04) , volume 3182 of lecture notes in computer science ,
pages 79–94, zaragoza, spain, august 2004. springer-verlag, berlin.
31. w. gaaloul, s. bhiri, and c. godart. discovering workﬂow transactional be-
havior from event-based log. in r. meersman, z. tari, w.m.p. van der aalst,
c. bussler, and a. gal et al., editors, on the move to meaningful internet systems
2004: coopis, doa, and odbase: otm confederated international conferences,coopis, doa, and odbase 2004 , volume 3290 of lecture notes in computer sci-
ence, pages 3–18, 2004.
32. w. gaaloul and c. godart. mining workﬂow recovery from event based logs. in
w.m.p. van der aalst, b. benatallah, f. casati, and f. curbera, editors, business
process management (bpm 2005) , volume 3649, pages 169–185. springer-verlag,
berlin, 2005.
33. d. georgakopoulos, m. hornick, and a. sheth. an overview of workﬂow manage-
ment: from process modeling to workﬂow automation infrastructure. distributed
and parallel databases , 3:119–153, 1995.
34. r.j. van glabbeek and w.p. weijland. branching time and abstraction in bisim-
ulation semantics. journal of the acm , 43(3):555–600, 1996.
35. r. gombotz and s. dustdar. on web services mining. in m. castellanos and
t. weijters, editors, first international workshop on business process intelligence
(bpi’05) , pages 58–70, nancy, france, september 2005.
36. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321–343, 2004.
37. d. grigori, f. casati, u. dayal, and m.c. shan. improving business process qual-
ity through exception understanding, prediction, and prevention. in p. apers,
p. atzeni, s. ceri, s. paraboschi, k. ramamohanarao, and r. snodgrass, ed-
itors, proceedings of 27th international conference on very large data bases
(vldb’01) , pages 159–168. morgan kaufmann, 2001.
38. j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
39. ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
40. n. kavantzas, d. burdett, g. ritzinger, t. fletcher, and y. lafon. web services
choreography description language version 1.0(w3c working draft 17 december
2004). http://www.w3.org/tr/2004/wd-ws-cdl-10-20041217/, 2004.
41. a. lazovik, m. aiello, and m. papazoglou. associating assertions with business
processes and monitoring their execution. in icsoc ’04: proceedings of the 2nd
international conference on service oriented computing , pages 94–104, new york,
ny, usa, 2004. acm press.
3642. h. ludwig, a. dan, and r. kearney. crona: an architecture and library for
creation and monitoring of ws-agreements. in icsoc ’04: proceedings of the
2nd international conference on service oriented computing , pages 65–74, new
york, ny, usa, 2004. acm press.
43. k. mahbub and g. spanoudakis. a framework for requirents monitoring of ser-
vice based systems. in icsoc ’04: proceedings of the 2nd international con-
ference on service oriented computing , pages 84–93, new york, ny, usa, 2004.
acm press.
44. a. martens. analyzing web service based business processes. in m. cerioli, editor,
proceedings of the 8th international conference on fundamental approaches to
software engineering (fase 2005) , volume 3442 of lecture notes in computer
science , pages 19–33. springer-verlag, berlin, 2005.
45. a. martens. consistency between executable and abstract processes. in proceedings
of international ieee conference on e-technology, e-commerce, and e-services
(eee’05) , pages 60–67. ieee computer society press, 2005.
46. p. massuthe, w. reisig, and k. schmidt. an operating guideline approach to
the soa. in proceedings of the 2nd south-east european workshop on formal
methods 2005 (seefm05) , ohrid, republic of macedonia, 2005.
47. m. mecella, f. parisi-presicce, and b. pernici. modeling e-service orchestration
through petri nets. in proceedings of the third international workshop on tech-
nologies for e-services , volume 2644 of lecture notes in computer science ,p a g e s
38–47. springer-verlag, berlin, 2002.
48. a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. using ge-
netic algorithms to mine process models: representation, operators and results.
beta working paper series, wp 124, eindhoven university of technology, eind-
hoven, 2004.
49. m. zur m¨ uhlen and m. rosemann. workﬂow-based process monitoring and con-
trolling - technical and organizational issues. in r. sprague, editor, proceedings
of the 33rd hawaii international conference on system science (hicss-33) , pages
1–10. ieee computer society press, los alamitos, california, 2000.
50. t. murata. petri nets: properties, analysis and applications. proceedings of the
ieee, 77(4):541–580, april 1989.
51. c. ouyang, w.m.p. van der aalst, s. breutel, m. dumas, a.h.m. ter hofstede, and
h.m.w. verbeek. formal semantics and analysis of control flow in ws-bpel.
bpm center report bpm-05-15, bpmcenter.org, 2005.
52. w. de pauw, m. lei, e. pring, l. villard, m. arnold, and j.f. morar. web ser-
vices navigator: visualizing the execution of web services. ibm systems journal ,
44(4):821–845, 2005.
53. a. rozinat. conformance testing: measuring the alignment between event logs
and process models. master’s thesis, hasso-plattner-institute for software engi-
neering at university and eindhoven university of technology, eindhoven, thenetherlands, 2005.
54. a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in m. castellanos andt. weijters, editors, first international workshop on business process intelligence
(bpi’05) , pages 1–12, nancy, france, september 2005.
55. m. sayal, f. casati, u. dayal, and m.c. shan. business process cockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb’02) ,
pages 880–883. morgan kaufmann, 2002.
3756. b.h. schlingloﬀ, a. martens, and k. schmidt. modeling and model checking web
services. electronic notes in theoretical computer science: issue on logic and
communication in multi-agent systems , 126:3–26, mar 2005.
57. c. stahl. transformation von bpel4ws in petrinetze (in german). master’s
thesis, humboldt university, berlin, germany, 2004.
58. tibco. tibco staﬀware process monitor (spm). http://www.tibco.com, 2005.59. h.m.w. verbeek and w.m.p. van der aalst. woﬂan 2.0: a petri-net-based work-
ﬂow diagnosis tool. in m. nielsen and d. simpson, editors, application and
theory of petri nets 2000 , volume 1825 of lecture notes in computer science ,
pages 475–484. springer-verlag, berlin, 2000.
60. h.m.w. verbeek and w.m.p. van der aalst. analyzing bpel processes using petri
nets. in d. marinescu, editor, proceedings of the second international workshop
on applications of petri nets to coordination, workﬂow and business processmanagement , pages 59–78. florida international university, miami, florida, usa,
2005.
61. h.m.w. verbeek, t. basten, and w.m.p. van der aalst. diagnosing workﬂow
processes using woﬂan. the computer journal , 44(4):246–279, 2001.
62. p. wohed, w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. analysis of
web services composition languages: the case of bpel4ws. in i.y. song, s.w.
liddle, t.w. ling, and p. scheuermann, editors, 22nd international conference
on conceptual modeling (er 2003) , volume 2813 of lecture notes in computer
science , pages 200–215. springer-verlag, berlin, 2003.
a details of supplier bpel process
this appendix contains the wsdl ﬁle, the abstract bpel ﬁle, and the ex-
ecutable bpel ﬁle for the supplier process. to improve readability, we have
inserted line breaks.
a.1 wsdl
<?xml version="1.0" encoding="utf-8"?>
<definitions name="supplier"
targetnamespace="http://services.qut.com/supplier"xmlns="http://schemas.xmlsoap.org/wsdl/"
xmlns:client="http://services.qut.com/supplier"
xmlns:plnk="http://schemas.xmlsoap.org/ws/2003/05/partner-link/">
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type definition - list of services participating in this bpel process
the default output of the bpel designer uses strings as input and
output to the bpel process. but you can define or import any xmlschema type and us them as part of the message types.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<types>
<schema attributeformdefault="qualified"
elementformdefault="qualified"
targetnamespace="http://services.qut.com/supplier"
38xmlns="http://www.w3.org/2001/xmlschema">
<element name="supplierprocessrequest">
<complextype>
<sequence>
<element name="nofitems" type="integer"/>
</sequence>
</complextype>
</element>
<element name="supplierprocessresponse">
<complextype>
<sequence>
<element name="nofitems" type="integer"/>
</sequence>
</complextype>
</element>
</schema>
</types>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
message type definition - definition of the message types used aspart of the port type defintions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<message name="supplierrequestmessage">
<part name="payload" element="client:supplierprocessrequest"/>
</message>
<message name="supplierresponsemessage">
<part name="payload" element="client:supplierprocessresponse"/>
</message>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
port type definition - a port type groups a set of operations into
a logical service unit.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --><!-- porttype implemented by the supplier bpel process -->
<porttype name="servicept">
<operation name="order">
<input message="client:supplierrequestmessage"/>
</operation>
<operation name="change">
<input message="client:supplierrequestmessage"/>
</operation>
</porttype>
<!-- porttype implemented by the requester of supplier bpel process
for asynchronous callback purposes
-->
<porttype name="serviceptcallback">
<operation name="orderresponse">
39<input message="client:supplierresponsemessage"/>
</operation>
<operation name="orderchangeresponse">
<input message="client:supplierresponsemessage"/>
</operation>
</porttype>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
partner link type definition
the supplier partnerlinktype binds the provider and
requester porttype into an asynchronous conversation.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<plnk:partnerlinktype name="supplier">
<plnk:role name="supplierprovider">
<plnk:porttype name="client:servicept"/>
</plnk:role>
<plnk:role name="supplierrequester">
<plnk:porttype name="client:serviceptcallback"/>
</plnk:role>
</plnk:partnerlinktype>
</definitions>
a.2 abstract bpel
<!--
/////////////////////////////////////////////////////////////////////////
// oracle jdeveloper bpel designer//
// created: mon sep 19 11:39:21 cest 2005
// author: hverbeek// purpose: asynchronous bpel process
/////////////////////////////////////////////////////////////////////////
--><process
name="supplier"
targetnamespace="http://services.qut.com/supplier"xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:client="http://services.qut.com/supplier"
xmlns:ns1="http://www.w3.org/2001/xmlschema"xmlns:ns2="tns"
xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
>
<!--
list of services participating in this bpel process
--><partnerlinks>
<!--
the ’client’ role represents the requester of this service. it
40is used for callback. the location and correlation information
associated with the client role are automatically set using
ws-addressing.
-->
<partnerlink
name="client"partnerlinktype="client:supplier"
myrole="supplierprovider"
partnerrole="supplierrequester"
/>
</partnerlinks><!--
list of messages and xml documents used within this bpel process
--><variables>
<variable
name="inputvariable"messagetype="client:supplierrequestmessage"
/>
<variable
name="outputvariable"
messagetype="client:supplierresponsemessage"
/>
</variables>
<!--
orchestration logic
-->
<sequence
name="main"
>
<receive
name="order"partnerlink="client"
porttype="client:servicept"
operation="order"variable="inputvariable"
createinstance="yes"
/>
<invoke
name="orderresponse"
partnerlink="client"
porttype="client:serviceptcallback"
operation="orderresponse"inputvariable="outputvariable"
/>
<scope name="cancellationscope">
<faulthandlers>
<catch faultname="ns2:orderchange">
<sequence name="change">
<invoke
41name="orderchangeresponse"
partnerlink="client"
porttype="client:serviceptcallback"operation="orderchangeresponse"
inputvariable="outputvariable"
/><while>
<invoke
name="orderchangeresponse"
partnerlink="client"
porttype="client:serviceptcallback"operation="orderchangeresponse"
inputvariable="outputvariable"
/>
</while>
</sequence>
</catch>
</faulthandlers>
<eventhandlers>
<onmessage p
orttype="client:servicept"
operation="change"
variable="inputvariable"partnerlink="client"
>
<throw
name="throwfault"
faultname="ns2:orderchange"
/>
</onmessage>
</eventhandlers>
<while>
<invoke
name="orderresponse"
partnerlink="client"porttype="client:serviceptcallback"
operation="orderresponse"
inputvariable="outputvariable"/>
</while>
</scope>
</sequence>
</process>
a.3 executable bpel
<!--
//////////////////////////////////////////////////////////////////////////
///////////////////
// oracle jdeveloper bpel designer
42//
// created: mon sep 19 11:39:21 cest 2005
// author: hverbeek// purpose: asynchronous bpel process
//////////////////////////////////////////////////////////////////////////
///////////////////
-->
<process name="supplier"
targetnamespace="http://services.qut.com/supplier"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:xp20="http://www.oracle.com/xsl/transform/java/oracle.tip.pc.service
s.functions.xpath20"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:ldap="http://schemas.oracle.com/xpath/extension/ldap"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:client="http://services.qut.com/supplier"xmlns:ora="http://schemas.oracle.com/xpath/extension"
xmlns:identityservice="http://xmlns.oracle.com/pcbpel/identityservice/loca
l" xmlns:ns1="http://www.w3.org/2001/xmlschema"xmlns:taskmngr="http://xmlns.oracle.com/pcbpel/taskservice/taskmanager"
xmlns:taskroutingservice="http://xmlns.oracle.com/pcbpel/taskservice/taskr
outingservice" xmlns:ns2="tns"xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns:task="http://xmlns.oracle.com/pcbpel/taskservice/task"
xmlns:taskactionhandler="http://xmlns.oracle.com/pcbpel/taskservice/taskactionhandler"
xmlns:orcl="http://www.oracle.com/xsl/transform/java/oracle.tip.pc.service
s.functions.extfunc">
<!-- ================================================================= -
->
<!-- partnerlinks -
->
<!-- list of services participating in this bpel process -
->
<!-- ================================================================= -
->
<partnerlinks>
<!--
the ’client’ role represents the requester of this service. it is
used for callback. the location and correlation information associated
with the client role are automatically set using ws-addressing.
-->
<partnerlink name="client" partnerlinktype="client:supplier"
myrole="supplierprovider" partnerrole="supplierrequester"/>
<partnerlink myrole="taskmanagercallbacklistener"
name="taskmanagerservice" partnerrole="taskmanager"
partnerlinktype="taskmngr:taskmanager"/>
<partnerlink name="taskroutingservice"
partnerrole="taskroutingservice"
43partnerlinktype="taskroutingservice:taskroutingservice"/>
<partnerlink myrole="handletaskactionrequester"
name="taskactionhandler" partnerrole="handletaskactionprovider"partnerlinktype="taskactionhandler:taskactionhandler"/>
<partnerlink name="identityservice"
partnerrole="identityserviceprovider"partnerlinktype="identityservice:identityservice"/>
</partnerlinks>
<!-- ================================================================= -
->
<!-- variables -
->
<!-- list of messages and xml documents used within this bpel process -
->
<!-- ================================================================= -
->
<variables>
<!-- reference to the message passed as input during initiation -->
<!-- reference to the message that will be sent back to the
requester during callback-->
<variable name="inputvariable"
messagetype="client:supplierrequestmessage"/>
<variable name="outputvariable"
messagetype="client:supplierresponsemessage"/>
<variable name="nofitems" type="ns1:integer"/><variable name="checktaskvar" element="task:task"/>
<variable name="checkchangedordervar" element="task:task"/>
</variables><!-- ================================================================= -
->
<!-- orchestration logic -
->
<!-- set of activities coordinating the flow of messages across the -
->
<!-- services integrated within this business process -
->
<!-- ================================================================= -
->
<sequence name="main">
<!-- receive input from requestor.
note: this maps to operation defined in supplier.wsdl
-->
<!-- asynchronous callback to the requester.
note: the callback location and correlation id is transparently handled
using ws-addressing.-->
<receive name="order" partnerlink="client" porttype="client:servicept"
operation="order" variable="inputvariable" createinstance="yes"/>
<sequence name="initorder">
44<assign name="setnofitems">
<copy>
<from variable="inputvariable" part="payload"
query="/client:supplierprocessrequest/client:nofitems"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence>
<sequence name="preorderresponse">
<assign name="setoutput">
<copy>
<from variable="nofitems"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse/client:nofitems"/>
</copy>
</assign>
<scope name="checktask" variableaccessserializable="no"
xmlns:taskactionhandler="http://xmlns.oracle.com/pcbpel/taskservice/taskac
tionhandler" xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpel="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:taskmngr="http://xmlns.oracle.com/pcbpel/taskservice/taskmanager"xmlns:task="http://xmlns.oracle.com/pcbpel/taskservice/task"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:ora="http://schemas.oracle.com/xpath/extension"xmlns:wf="http://schemas.oracle.com/bpel/extension/workflow"
wf:key="checktaskvar;taskconfigchecktask.xml;simpleuseractivity;&lt;%conca
t(string(’check order: ’), string(bpws:getvariabledata(’nofitems’)),string(’ items to go’))%&gt;;bpws:getvariabledata(’outputvariable’,
’payload’, ’/client:supplierprocessresponse’);;;;;">
<variables>
<variable name="orabpmtaskmessage"
messagetype="taskmngr:taskmessage"/>
<variable name="orabpmtaskerroredfaultmessage"
messagetype="taskmngr:taskerroredmessage"/>
<variable name="orabpmtemporaryvariable" type="xsd:string"/>
</variables><correlationsets>
<correlationset name="orabpmtaskidcor"
properties="taskmngr:taskid"/>
</correlationsets>
<sequence>
<assign name="setuserdefinedattributes">
<copy>
<from expression="concat(string(’check order: ’),
string(bpws:getvariabledata(’nofitems’)), string(’ items to go’))"/>
<to variable="checktaskvar" query="/task:task/task:title"/>
</copy><copy>
45<from expression="bpws:getvariabledata(’outputvariable’,
’payload’, ’/client:supplierprocessresponse’)"/>
<to variable="checktaskvar"
query="/task:task/task:payload"/>
</copy>
<copy>
<from expression="string(’hverbeek’)"/>
<to variable="checktaskvar"
query="/task:task/task:assigneeusers[1]"/>
</copy>
<copy>
<from expression="concat(ora:getprocessurl(),
string(’/taskconfigchecktask.xml’))"/>
<to variable="checktaskvar"
query="/task:task/task:tasktype"/>
</copy>
</assign><assign name="setsystemdefinedattributes">
<copy>
<from expression="ora:getinstanceid()"/><to variable="checktaskvar"
query="/task:task/task:instanceid"/>
</copy><copy>
<from expression="ora:getprocessid()"/>
<to variable="checktaskvar"
query="/task:task/task:processname"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/>
<to variable="checktaskvar"
query="/task:task/task:processid"/>
</copy>
<copy>
<from expression="ora:getprocessversion()"/><to variable="checktaskvar"
query="/task:task/task:processversion"/>
</copy><copy>
<from expression="ora:getdomainid()"/>
<to variable="checktaskvar"
query="/task:task/task:domainid"/>
</copy><copy>
<from expression="ora:getprocessownerid()"/>
<to variable="checktaskvar"
query="/task:task/task:processowner"/>
</copy>
<copy>
<from expression="string(’single_approval’)"/>
46<to variable="checktaskvar"
query="/task:task/task:pattern"/>
</copy><copy>
<from expression="false()"/>
<to variable="checktaskvar"
query="/task:task/task:hassubtasks"/>
</copy>
<copy>
<from variable="checktaskvar"/>
<to variable="orabpmtaskmessage" part="payload"/>
</copy>
</assign>
<scope name="initiatetask">
<faulthandlers>
<catch faultname="taskmngr:taskerroredfault"
faultvariable="orabpmtaskerroredfaultmessage">
<assign name="readerroredtask">
<copy>
<from variable="orabpmtaskerroredfaultmessage"
part="payload"/>
<to variable="orabpmtaskmessage" part="payload"/>
</copy>
</assign>
</catch>
</faulthandlers><sequence>
<invoke name="initiatetask" partnerlink="taskmanagerservice"
porttype="taskmngr:taskmanager" operation="initiatetask"inputvariable="orabpmtaskmessage" outputvariable="orabpmtaskmessage"/>
</sequence>
</scope><sequence>
<invoke name="initiatetaskactionhandler"
partnerlink="taskactionhandler"porttype="taskactionhandler:taskactionhandler" operation="initiate"
inputvariable="orabpmtaskmessage">
<correlations>
<correlation set="orabpmtaskidcor" initiate="yes"
pattern="out"/>
</correlations>
</invoke>
<receive name="receiveupdatedtask"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandlercallback"
operation="ontaskcompleted" variable="orabpmtaskmessage"createinstance="no">
<correlations>
<correlation set="orabpmtaskidcor" initiate="no"/>
</correlations>
47</receive>
</sequence>
<assign name="readupdatedtask">
<copy>
<from variable="orabpmtaskmessage" part="payload"/>
<to variable="checktaskvar"/>
</copy>
</assign>
</sequence>
</scope>
<switch name="taskswitch"
xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:tt="http://xmlns.oracle.com/pcbpel/taskservice/tasktype"
xmlns:xsd="http://www.w3.org/2001/xmlschema">
<case condition="bpws:getvariabledata(’checktaskvar’,
’/task:task/task:state’) = ’completed’ and
bpws:getvariabledata(’checktaskvar’,
’/task:task/task:conclusion’) = ’accept’">
<bpelx:annotation>
<bpelx:pattern>task outcome is accept
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case><case condition="bpws:getvariabledata(’checktaskvar’,
’/task:task/task:state’) = ’completed’ and
bpws:getvariabledata(’checktaskvar’,’/task:task/task:conclusion’) = ’reject’">
<bpelx:annotation>
<bpelx:pattern>task outcome is reject
</bpelx:pattern>
</bpelx:annotation><sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
48</copy>
</assign>
</sequence>
</case>
<otherwise>
<bpelx:annotation>
<bpelx:pattern>task is expired, withdrawn or errored
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</otherwise>
</switch>
</sequence>
<invoke name="orderresponse" partnerlink="client"
porttype="client:serviceptcallback" operation="orderresponse"
inputvariable="outputvariable"/>
<sequence name="postorderresponse">
<assign name="decreasenofitems">
<copy>
<from expression="bpws:getvariabledata(’nofitems’) -
bpws:getvariabledata(’outputvariable’,’payload’,’/client:supplierprocessre
sponse/client:nofitems’)"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence><scope name="cancellationscope">
<faulthandlers>
<catch faultname="ns2:orderchange">
<sequence name="orderchangedsequence">
<sequence name="initchangeorder">
<assign name="setchangednofitems">
<copy>
<from variable="inputvariable" part="payload"
query="/client:supplierprocessrequest/client:nofitems"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence>
<sequence name="orderchangedresponsesequence">
<sequence name="prechangeorderresponse">
49<assign name="setchangedoutput">
<copy>
<from variable="nofitems"/><to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse/client:nofitems"/>
</copy>
</assign>
<scope name="checkchangedorder"
variableaccessserializable="no"
xmlns:taskactionhandler="http://xmlns.oracle.com/pcbpel/taskservice/taskac
tionhandler" xmlns:bpelx="http://schemas.oracle.com/bpel/extension"xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpel="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:taskmngr="http://xmlns.oracle.com/pcbpel/taskservice/taskmanager"
xmlns:task="http://xmlns.oracle.com/pcbpel/taskservice/task"
xmlns:xsd="http://www.w3.org/2001/xmlschema"xmlns:ora="http://schemas.oracle.com/xpath/extension"
xmlns:wf="http://schemas.oracle.com/bpel/extension/workflow"
wf:key="checkchangedordervar;taskconfigcheckchangedorder.xml;simpleuseractivity;&lt;%concat(string(’check changed order: ’),
string(bpws:getvariabledata(’nofitems’)), string(’ items to
go’))%&gt;;bpws:getvariabledata(’outputvariable’, ’payload’,’/client:supplierprocessresponse’);;;;;">
<variables>
<variable name="orabpmtaskmessage"
messagetype="taskmngr:taskmessage"/>
<variable name="orabpmtaskerroredfaultmessage"
messagetype="taskmngr:taskerroredmessage"/>
<variable name="orabpmtemporaryvariable"
type="xsd:string"/>
</variables><correlationsets>
<correlationset name="orabpmtaskidcor"
properties="taskmngr:taskid"/>
</correlationsets>
<sequence>
<assign name="setuserdefinedattributes">
<copy>
<from expression="concat(string(’check changed
order: ’), string(bpws:getvariabledata(’nofitems’)), string(’ items to
go’))"/>
<to variable="checkchangedordervar"
query="/task:task/task:title"/>
</copy>
<copy>
<from
expression="bpws:getvariabledata(’outputvariable’, ’payload’,
’/client:supplierprocessresponse’)"/>
<to variable="checkchangedordervar"
50query="/task:task/task:payload"/>
</copy>
<copy>
<from expression="string(’hverbeek’)"/>
<to variable="checkchangedordervar"
query="/task:task/task:assigneeusers[1]"/>
</copy>
<copy>
<from expression="concat(ora:getprocessurl(),
string(’/taskconfigcheckchangedorder.xml’))"/>
<to variable="checkchangedordervar"
query="/task:task/task:tasktype"/>
</copy>
</assign><assign name="setsystemdefinedattributes">
<copy>
<from expression="ora:getinstanceid()"/><to variable="checkchangedordervar"
query="/task:task/task:instanceid"/>
</copy><copy>
<from expression="ora:getprocessid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:processname"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:processid"/>
</copy>
<copy>
<from expression="ora:getprocessversion()"/><to variable="checkchangedordervar"
query="/task:task/task:processversion"/>
</copy><copy>
<from expression="ora:getdomainid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:domainid"/>
</copy>
<copy>
<from expression="ora:getprocessownerid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:processowner"/>
</copy>
<copy>
<from expression="string(’single_approval’)"/>
<to variable="checkchangedordervar"
query="/task:task/task:pattern"/>
</copy>
51<copy>
<from expression="false()"/>
<to variable="checkchangedordervar"
query="/task:task/task:hassubtasks"/>
</copy>
<copy>
<from variable="checkchangedordervar"/>
<to variable="orabpmtaskmessage" part="payload"/>
</copy>
</assign>
<scope name="initiatetask">
<faulthandlers>
<catch faultname="taskmngr:taskerroredfault"
faultvariable="orabpmtaskerroredfaultmessage">
<assign name="readerroredtask">
<copy>
<from
variable="orabpmtaskerroredfaultmessage" part="payload"/>
<to variable="orabpmtaskmessage"
part="payload"/>
</copy>
</assign>
</catch>
</faulthandlers>
<sequence>
<invoke name="initiatetask"
partnerlink="taskmanagerservice" porttype="taskmngr:taskmanager"
operation="initiatetask" inputvariable="orabpmtaskmessage"
outputvariable="orabpmtaskmessage"/>
</sequence>
</scope>
<sequence>
<invoke name="initiatetaskactionhandler"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandler" operation="initiate"inputvariable="orabpmtaskmessage">
<correlations>
<correlation set="orabpmtaskidcor"
initiate="yes" pattern="out"/>
</correlations>
</invoke>
<receive name="receiveupdatedtask"
partnerlink="taskactionhandler"porttype="taskactionhandler:taskactionhandlercallback"
operation="ontaskcompleted" variable="orabpmtaskmessage"
createinstance="no">
<correlations>
<correlation set="orabpmtaskidcor"
initiate="no"/>
</correlations>
52</receive>
</sequence>
<assign name="readupdatedtask">
<copy>
<from variable="orabpmtaskmessage"
part="payload"/>
<to variable="checkchangedordervar"/>
</copy>
</assign>
</sequence>
</scope><switch name="taskswitch"
xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:tt="http://xmlns.oracle.com/pcbpel/taskservice/tasktype"
xmlns:xsd="http://www.w3.org/2001/xmlschema">
<case
condition="bpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:state’) = ’completed’ andbpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:conclusion’) = ’accept’">
<bpelx:annotation>
<bpelx:pattern>task outcome is accept
</bpelx:pattern>
</bpelx:annotation><sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case>
<case
condition="bpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:state’) = ’completed’ and
bpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:conclusion’) = ’reject’">
<bpelx:annotation>
<bpelx:pattern>task outcome is reject
</bpelx:pattern>
</bpelx:annotation><sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
53query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case>
<otherwise>
<bpelx:annotation>
<bpelx:pattern>task is expired, withdrawn or errored
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</otherwise>
</switch>
</sequence>
<invoke name="orderchangeresponse" partnerlink="client"
porttype="client:serviceptcallback" operation="orderchangeresponse"
inputvariable="outputvariable"/>
<sequence name="postchangeorderresponse">
<assign name="decreasechangednofitems">
<copy>
<from expression="bpws:getvariabledata(’nofitems’) -
bpws:getvariabledata(’outputvariable’,’payload’,’/client:supplierprocessre
sponse/client:nofitems’)"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence>
</sequence>
<while name="remainingorderchangeditems"
condition="bpws:getvariabledata(’nofitems’) &gt; 0">
<sequence name="orderchangedresponsesequence">
<sequence name="prechangeorderresponse">
<assign name="setchangedoutput">
<copy>
<from variable="nofitems"/><to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse/client:nofitems"/>
</copy>
</assign>
54<scope name="checkchangedorder"
variableaccessserializable="no"
xmlns:taskactionhandler="http://xmlns.oracle.com/pcbpel/taskservice/taskactionhandler" xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:bpel="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:taskmngr="http://xmlns.oracle.com/pcbpel/taskservice/taskmanager"
xmlns:task="http://xmlns.oracle.com/pcbpel/taskservice/task"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:ora="http://schemas.oracle.com/xpath/extension"xmlns:wf="http://schemas.oracle.com/bpel/extension/workflow"
wf:key="checkchangedordervar;taskconfigcheckchangedorder.xml;simpleuseract
ivity;&lt;%concat(string(’check changed order: ’),string(bpws:getvariabledata(’nofitems’)), string(’ items to
go’))%&gt;;bpws:getvariabledata(’outputvariable’, ’payload’,
’/client:supplierprocessresponse’);;;;;">
<variables>
<variable name="orabpmtaskmessage"
messagetype="taskmngr:taskmessage"/>
<variable name="orabpmtaskerroredfaultmessage"
messagetype="taskmngr:taskerroredmessage"/>
<variable name="orabpmtemporaryvariable"
type="xsd:string"/>
</variables>
<correlationsets>
<correlationset name="orabpmtaskidcor"
properties="taskmngr:taskid"/>
</correlationsets><sequence>
<assign name="setuserdefinedattributes">
<copy>
<from expression="concat(string(’check changed
order: ’), string(bpws:getvariabledata(’nofitems’)), string(’ items to
go’))"/>
<to variable="checkchangedordervar"
query="/task:task/task:title"/>
</copy><copy>
<from
expression="bpws:getvariabledata(’outputvariable’, ’payload’,
’/client:supplierprocessresponse’)"/>
<to variable="checkchangedordervar"
query="/task:task/task:payload"/>
</copy>
<copy>
<from expression="string(’hverbeek’)"/>
<to variable="checkchangedordervar"
query="/task:task/task:assigneeusers[1]"/>
</copy>
55<copy>
<from expression="concat(ora:getprocessurl(),
string(’/taskconfigcheckchangedorder.xml’))"/>
<to variable="checkchangedordervar"
query="/task:task/task:tasktype"/>
</copy>
</assign>
<assign name="setsystemdefinedattributes">
<copy>
<from expression="ora:getinstanceid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:instanceid"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:processname"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/><to variable="checkchangedordervar"
query="/task:task/task:processid"/>
</copy><copy>
<from expression="ora:getprocessversion()"/>
<to variable="checkchangedordervar"
query="/task:task/task:processversion"/>
</copy>
<copy>
<from expression="ora:getdomainid()"/>
<to variable="checkchangedordervar"
query="/task:task/task:domainid"/>
</copy>
<copy>
<from expression="ora:getprocessownerid()"/><to variable="checkchangedordervar"
query="/task:task/task:processowner"/>
</copy><copy>
<from expression="string(’single_approval’)"/>
<to variable="checkchangedordervar"
query="/task:task/task:pattern"/>
</copy><copy>
<from expression="false()"/>
<to variable="checkchangedordervar"
query="/task:task/task:hassubtasks"/>
</copy>
<copy>
<from variable="checkchangedordervar"/>
56<to variable="orabpmtaskmessage"
part="payload"/>
</copy>
</assign>
<scope name="initiatetask">
<faulthandlers>
<catch faultname="taskmngr:taskerroredfault"
faultvariable="orabpmtaskerroredfaultmessage">
<assign name="readerroredtask">
<copy>
<from
variable="orabpmtaskerroredfaultmessage" part="payload"/>
<to variable="orabpmtaskmessage"
part="payload"/>
</copy>
</assign>
</catch>
</faulthandlers>
<sequence>
<invoke name="initiatetask"
partnerlink="taskmanagerservice" porttype="taskmngr:taskmanager"
operation="initiatetask" inputvariable="orabpmtaskmessage"
outputvariable="orabpmtaskmessage"/>
</sequence>
</scope>
<sequence>
<invoke name="initiatetaskactionhandler"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandler" operation="initiate"inputvariable="orabpmtaskmessage">
<correlations>
<correlation set="orabpmtaskidcor"
initiate="yes" pattern="out"/>
</correlations>
</invoke><receive name="receiveupdatedtask"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandlercallback"operation="ontaskcompleted" variable="orabpmtaskmessage"
createinstance="no">
<correlations>
<correlation set="orabpmtaskidcor"
initiate="no"/>
</correlations>
</receive>
</sequence><assign name="readupdatedtask">
<copy>
<from variable="orabpmtaskmessage"
part="payload"/>
57<to variable="checkchangedordervar"/>
</copy>
</assign>
</sequence>
</scope>
<switch name="taskswitch"
xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:tt="http://xmlns.oracle.com/pcbpel/taskservice/tasktype"
xmlns:xsd="http://www.w3.org/2001/xmlschema">
<case
condition="bpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:state’) = ’completed’ andbpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:conclusion’) = ’accept’">
<bpelx:annotation>
<bpelx:pattern>task outcome is accept
</bpelx:pattern>
</bpelx:annotation><sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case>
<case
condition="bpws:getvariabledata(’checkchangedordervar’,
’/task:task/task:state’) = ’completed’ and
bpws:getvariabledata(’checkchangedordervar’,’/task:task/task:conclusion’) = ’reject’">
<bpelx:annotation>
<bpelx:pattern>task outcome is reject
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
58</case>
<otherwise>
<bpelx:annotation>
<bpelx:pattern>task is expired, withdrawn or
errored
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checkchangedordervar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</otherwise>
</switch>
</sequence><invoke name="orderchangeresponse" partnerlink="client"
porttype="client:serviceptcallback" operation="orderchangeresponse"
inputvariable="outputvariable"/>
<sequence name="postchangeorderresponse">
<assign name="decreasechangednofitems">
<copy>
<from expression="bpws:getvariabledata(’nofitems’) -
bpws:getvariabledata(’outputvariable’,’payload’,’/client:supplierprocessre
sponse/client:nofitems’)"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence>
</sequence>
</while>
</sequence>
</catch>
</faulthandlers><eventhandlers>
<onmessage porttype="client:servicept" operation="change"
variable="inputvariable" partnerlink="client">
<throw name="throwfault" faultname="ns2:orderchange"/>
</onmessage>
</eventhandlers>
<sequence name="ordersequence">
<while name="remainingorderitems"
condition="bpws:getvariabledata(’nofitems’) &gt; 0">
<sequence name="orderresponsesequence">
<sequence name="preorderresponse">
<assign name="setoutput">
59<copy>
<from variable="nofitems"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse/client:nofitems"/>
</copy>
</assign><scope name="checktask" variableaccessserializable="no"
xmlns:taskactionhandler="http://xmlns.oracle.com/pcbpel/taskservice/taskac
tionhandler" xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"xmlns:bpel="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:taskmngr="http://xmlns.oracle.com/pcbpel/taskservice/taskmanager"
xmlns:task="http://xmlns.oracle.com/pcbpel/taskservice/task"xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:ora="http://schemas.oracle.com/xpath/extension"
xmlns:wf="http://schemas.oracle.com/bpel/extension/workflow"wf:key="checktaskvar;taskconfigchecktask.xml;simpleuseractivity;&lt;%conca
t(string(’check order: ’), string(bpws:getvariabledata(’nofitems’)),
string(’ items to go’))%&gt;;bpws:getvariabledata(’outputvariable’,’payload’, ’/client:supplierprocessresponse’);;;;;">
<variables>
<variable name="orabpmtaskmessage"
messagetype="taskmngr:taskmessage"/>
<variable name="orabpmtaskerroredfaultmessage"
messagetype="taskmngr:taskerroredmessage"/>
<variable name="orabpmtemporaryvariable"
type="xsd:string"/>
</variables><correlationsets>
<correlationset name="orabpmtaskidcor"
properties="taskmngr:taskid"/>
</correlationsets>
<sequence>
<assign name="setuserdefinedattributes">
<copy>
<from expression="concat(string(’check order: ’),
string(bpws:getvariabledata(’nofitems’)), string(’ items to go’))"/>
<to variable="checktaskvar"
query="/task:task/task:title"/>
</copy>
<copy>
<from
expression="bpws:getvariabledata(’outputvariable’, ’payload’,
’/client:supplierprocessresponse’)"/>
<to variable="checktaskvar"
query="/task:task/task:payload"/>
</copy>
<copy>
<from expression="string(’hverbeek’)"/>
60<to variable="checktaskvar"
query="/task:task/task:assigneeusers[1]"/>
</copy><copy>
<from expression="concat(ora:getprocessurl(),
string(’/taskconfigchecktask.xml’))"/>
<to variable="checktaskvar"
query="/task:task/task:tasktype"/>
</copy>
</assign>
<assign name="setsystemdefinedattributes">
<copy>
<from expression="ora:getinstanceid()"/>
<to variable="checktaskvar"
query="/task:task/task:instanceid"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/>
<to variable="checktaskvar"
query="/task:task/task:processname"/>
</copy>
<copy>
<from expression="ora:getprocessid()"/><to variable="checktaskvar"
query="/task:task/task:processid"/>
</copy><copy>
<from expression="ora:getprocessversion()"/>
<to variable="checktaskvar"
query="/task:task/task:processversion"/>
</copy>
<copy>
<from expression="ora:getdomainid()"/>
<to variable="checktaskvar"
query="/task:task/task:domainid"/>
</copy>
<copy>
<from expression="ora:getprocessownerid()"/><to variable="checktaskvar"
query="/task:task/task:processowner"/>
</copy>
<copy>
<from expression="string(’single_approval’)"/><to variable="checktaskvar"
query="/task:task/task:pattern"/>
</copy><copy>
<from expression="false()"/>
<to variable="checktaskvar"
query="/task:task/task:hassubtasks"/>
61</copy>
<copy>
<from variable="checktaskvar"/><to variable="orabpmtaskmessage" part="payload"/>
</copy>
</assign><scope name="initiatetask">
<faulthandlers>
<catch faultname="taskmngr:taskerroredfault"
faultvariable="orabpmtaskerroredfaultmessage">
<assign name="readerroredtask">
<copy>
<from variable="orabpmtaskerroredfaultmessage"
part="payload"/>
<to variable="orabpmtaskmessage"
part="payload"/>
</copy>
</assign>
</catch>
</faulthandlers><sequence>
<invoke name="initiatetask"
partnerlink="taskmanagerservice" porttype="taskmngr:taskmanager"operation="initiatetask" inputvariable="orabpmtaskmessage"
outputvariable="orabpmtaskmessage"/>
</sequence>
</scope>
<sequence>
<invoke name="initiatetaskactionhandler"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandler" operation="initiate"
inputvariable="orabpmtaskmessage">
<correlations>
<correlation set="orabpmtaskidcor" initiate="yes"
pattern="out"/>
</correlations>
</invoke>
<receive name="receiveupdatedtask"
partnerlink="taskactionhandler"
porttype="taskactionhandler:taskactionhandlercallback"
operation="ontaskcompleted" variable="orabpmtaskmessage"
createinstance="no">
<correlations>
<correlation set="orabpmtaskidcor" initiate="no"/>
</correlations>
</receive>
</sequence>
<assign name="readupdatedtask">
<copy>
<from variable="orabpmtaskmessage" part="payload"/>
62<to variable="checktaskvar"/>
</copy>
</assign>
</sequence>
</scope>
<switch name="taskswitch"
xmlns:bpelx="http://schemas.oracle.com/bpel/extension"
xmlns="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:bpws="http://schemas.xmlsoap.org/ws/2003/03/business-process/"
xmlns:tt="http://xmlns.oracle.com/pcbpel/taskservice/tasktype"
xmlns:xsd="http://www.w3.org/2001/xmlschema">
<case condition="bpws:getvariabledata(’checktaskvar’,
’/task:task/task:state’) = ’completed’ and
bpws:getvariabledata(’checktaskvar’,’/task:task/task:conclusion’) = ’accept’">
<bpelx:annotation>
<bpelx:pattern>task outcome is accept
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case>
<case condition="bpws:getvariabledata(’checktaskvar’,
’/task:task/task:state’) = ’completed’ andbpws:getvariabledata(’checktaskvar’,
’/task:task/task:conclusion’) = ’reject’">
<bpelx:annotation>
<bpelx:pattern>task outcome is reject
</bpelx:pattern>
</bpelx:annotation><sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</case><otherwise>
63<bpelx:annotation>
<bpelx:pattern>task is expired, withdrawn or errored
</bpelx:pattern>
</bpelx:annotation>
<sequence>
<assign name="copypayloadfromtask">
<copy>
<from variable="checktaskvar"
query="/task:task/task:payload"/>
<to variable="outputvariable" part="payload"
query="/client:supplierprocessresponse"/>
</copy>
</assign>
</sequence>
</otherwise>
</switch>
</sequence><invoke name="orderresponse" partnerlink="client"
porttype="client:serviceptcallback" operation="orderresponse"
inputvariable="outputvariable"/>
<sequence name="postorderresponse">
<assign name="decreasenofitems">
<copy>
<from expression="bpws:getvariabledata(’nofitems’) -
bpws:getvariabledata(’outputvariable’,’payload’,’/client:supplierprocessre
sponse/client:nofitems’)"/>
<to variable="nofitems"/>
</copy>
</assign>
</sequence>
</sequence>
</while>
</sequence>
</scope>
</sequence>
</process>
b actual soap message logs
this appendix contains two logs with soap messages. the ﬁrst log contains the two
messages received by the bpel server running the supplier process, whereas the second
log contains the three messages received by the bpel server running the customerprocess. first, however, we detail how we can link figure 17 to both logs. as figure 17
and both logs listed here are in xml format, we use xpath-like expressions (“//e”
means an e-element anywhere in the xml tree, and “e@a” means the a-attribute ofthe e-element).
//process@id value of //servicename@xmlns:snns
//process@description added manually
64//processinstance@id value of //messageid
//processinstance@description ”instance ” concatenated with value of //mes-
sageid@orabpel:rootid
//workﬂowmodelelement value of soapaction
//eventtype ”complete”
//timestamp (converted) timestamp of response (as the request does not contain
any timestamp)
consider for example the ﬁrst message in appendix b.1. the process identiﬁer is
http://services.qut.com/supplier , the process instance identiﬁer is bpel://localhost/
default/customer∼1.1/301-bpinv0-bpseq0.3-3 , the workﬂowmodelelement (i.e., the
identiﬁer pointing to the activity) is order , and the timestamp is 2005-10-20t11:54:
09-00:00 (thu, 20 oct 2005 11:54:09 gmt). this corresponds to the following event
in the event log:
...
<process
id="http://services.qut.com/supplier"
description="supplier 1.1, using customer 1.1 as customer stub"
>
...
<processinstance
id="bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3"description="instance 301"
>
...
<audittrailentry>
<workflowmodelelement>order</workflowmodelelement><eventtype>complete</eventtype>
<timestamp>2005-10-20t11:54:09-00:00</timestamp>
</audittrailentry>
...
to improve the readability of the logs, we have inserted line breaks.
b.1 from the customer process to the supplier process
==============
listen port: 1234
target host: ga2494
target port: 9700==== request ====
post /orabpel/default/supplier http/1.0
content-type: text/xml; charset=utf-8accept: application/soap+xml, application/dime, multipart/related, text/*
user-agent: axis/#axisversion#
host: ga2494:1234cache-control: no-cache
pragma: no-cache
soapaction: "order"
65content-length: 979
connection: close
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:header>
<messageid
xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"xmlns:orabpel="http://schemas.oracle.com/bpel"
orabpel:rootid="301" orabpel:parentid="301"
orabpel:priority="3"
>
bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3
</messageid><replyto
xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"
>
<address>
http://ga2550:9710/orabpel/default/customer/1.1/supplier/s
upplierrequester
</address>
<porttype
xmlns:ptns="http://services.qut.com/supplier"
>
ptns:serviceptcallback
</porttype><servicename
xmlns:snns="http://services.qut.com/supplier"
>
snns:serviceptcallbackservice
</servicename>
</replyto>
</soapenv:header>
<soapenv:body>
<supplierprocessrequest
xmlns="http://services.qut.com/supplier"
>
<nofitems>
5
</nofitems>
</supplierprocessrequest>
</soapenv:body>
</soapenv:envelope>==== response ====
http/1.1 200 ok
date: thu, 20 oct 2005 11:54:09 gmtserver: oracle application server containers for j2ee 10g (10.1.2.0.0)
66connection: close
content-type: text/xml; charset=utf-8
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:body/>
</soapenv:envelope>
==============
==============
listen port: 1234target host: ga2494
target port: 9700
==== request ====post /orabpel/default/supplier http/1.0
content-type: text/xml; charset=utf-8
accept: application/soap+xml, application/dime, multipart/related, text/*user-agent: axis/#axisversion#
host: ga2494:1234
cache-control: no-cachepragma: no-cache
soapaction: "change"
content-length: 507connection: close
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:header>
<relatesto
xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"
>
bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3
</relatesto>
</soapenv:header>
<soapenv:body>
<supplierprocessrequest
xmlns="http://services.qut.com/supplier"
>
<nofitems>
5
</nofitems>
</supplierprocessrequest>
</soapenv:body>
</soapenv:envelope>
67==== response ====
http/1.1 200 ok
date: thu, 20 oct 2005 11:58:20 gmtserver: oracle application server containers for j2ee 10g (10.1.2.0.0)
connection: close
content-type: text/xml; charset=utf-8
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:body/>
</soapenv:envelope>==============
b.2 from the supplier process to the client
==============listen port: 9710target host: ga2550
target port: 9700
==== request ====post /orabpel/default/customer/1.1/supplier/supplierrequester http/1.0
content-type: text/xml; charset=utf-8
accept: application/soap+xml, application/dime, multipart/related, text/*user-agent: axis/#axisversion#
host: ga2550:9710
cache-control: no-cachepragma: no-cache
soapaction: "orderresponse"
content-length: 509connection: close
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:header>
<relatesto
xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"
>
bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3
</relatesto>
</soapenv:header><soapenv:body>
<supplierprocessresponse
xmlns="http://services.qut.com/supplier"
68>
<nofitems>
1
</nofitems>
</supplierprocessresponse>
</soapenv:body>
</soapenv:envelope>
==== response ====
http/1.1 200 ok
date: thu, 20 oct 2005 11:58:08 gmt
server: oracle application server containers for j2ee 10g (10.1.2.0.0)connection: close
content-type: text/xml; charset=utf-8
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:body/>
</soapenv:envelope>
==============
==============
listen port: 9710
target host: ga2550target port: 9700
==== request ====
post /orabpel/default/customer/1.1/supplier/supplierrequester http/1.0content-type: text/xml; charset=utf-8
accept: application/soap+xml, application/dime, multipart/related, text/*
user-agent: axis/#axisversion#host: ga2550:9710
cache-control: no-cache
pragma: no-cachesoapaction: "orderchangeresponse"
content-length: 509
connection: close
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:header>
<relatesto
xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"
>
bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3
</relatesto>
69</soapenv:header>
<soapenv:body>
<supplierprocessresponse
xmlns="http://services.qut.com/supplier"
>
<nofitems>
2
</nofitems>
</supplierprocessresponse>
</soapenv:body>
</soapenv:envelope>==== response ====
http/1.1 200 ok
date: thu, 20 oct 2005 11:58:35 gmtserver: oracle application server containers for j2ee 10g (10.1.2.0.0)
connection: close
content-type: text/xml; charset=utf-8
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:body/>
</soapenv:envelope>
==============
==============
listen port: 9710target host: ga2550
target port: 9700
==== request ====post /orabpel/default/customer/1.1/supplier/supplierrequester http/1.0
content-type: text/xml; charset=utf-8
accept: application/soap+xml, application/dime, multipart/related, text/*user-agent: axis/#axisversion#
host: ga2550:9710
cache-control: no-cachepragma: no-cache
soapaction: "orderchangeresponse"
content-length: 509
connection: close
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:header>
<relatesto
70xmlns="http://schemas.xmlsoap.org/ws/2003/03/addressing"
>
bpel://localhost/default/customer~1.1/301-bpinv0-bpseq0.3-3
</relatesto>
</soapenv:header>
<soapenv:body>
<supplierprocessresponse
xmlns="http://services.qut.com/supplier"
>
<nofitems>
3
</nofitems>
</supplierprocessresponse>
</soapenv:body>
</soapenv:envelope>
==== response ====
http/1.1 200 okdate: thu, 20 oct 2005 11:58:43 gmt
server: oracle application server containers for j2ee 10g (10.1.2.0.0)
connection: closecontent-type: text/xml; charset=utf-8
<soapenv:envelope
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsd="http://www.w3.org/2001/xmlschema"
xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
>
<soapenv:body/>
</soapenv:envelope>==============
71