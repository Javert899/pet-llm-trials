fundamenta informaticae 168 (2019) 1‚Äì27 1
doi 10.3233/fi-2019-1800
ios press
lucent process models and translucent event logs
wil m.p. van der aalst
process and data science (pads)
rwth aachen university, germany
wvdaalst@pads.rwth-aachen.de
abstract. a process model is lucent if no two reachable states are enabling the same set of
activities. an event log is translucent if each event carries information about the set of activities
enabled when the event occurred (normally one only sees the activity performed). both lucency
and translucency focus on the set of enabled activities and are therefore related. surprisingly,
these notions have not been investigated before. this paper aims to (1) characterize process
models that are lucent, (2) provide a discovery approach to learn process models from translucent
event logs, and (3) relate lucency and translucency. lucency is deÔ¨Åned both in terms of automata
and petri nets. a marked petri net is lucent if there are no two different reachable markings
enabling the same set of transitions, i.e., states are fully characterized by the transitions they
enable. we will also provide a novel process discovery technique starting from a translucent
event log. it turns out that information about the set of activities is extremely valuable for process
discovery. we will provide sufÔ¨Åcient conditions to ensure that the discovered model is lucent and
show that a translucent event log sampled from a lucent process model can be used to rediscover
the original model. we anticipate new analysis techniques exploiting lucency. moreover, as
shown in this paper, translucent event logs provide valuable information that can be exploited by
a new breed to process mining techniques.
keywords: process mining, petri nets, lucent process models, translucent event logs
1. introduction
first, we informally introduce the lucency and translucency notions. then, we brieÔ¨Çy discuss related
work and provide an outline of the paper.
address for correspondence: process and data science (pads), rwth aachen university, germany2 w.m.p . van der aalst /lucent process models and translucent event logs
1.1. lucent process models
a process model is lucent if and only if there do not exist two states that enable the same set of
activities. consider, for example, the marked petri net an 1and automaton am 1in figure 1. both
describe the same process that can generate traces such as ha;b;c;ei,ha;c;b;ei,ha;b;c;d;c;b;ei, and
ha;c;b;d;b;c;d;c;b;e i. there are six reachable states (called markings in the context of petri net).
clearly, there are no two states enabling the same set of activities (represented by the Ô¨Åve transitions
in the petri net). for example, state s1inam 1(corresponding to marking [p2;p3]inan 1) enables
bandc(corresponding to transitions t2andt3inan 1) there is no other reachable state enabling the
activity setfb;cg. therefore, both an 1andam 1are lucent.
p1ap2b
cd
p3ep4
p5p6 t1
t3t2
t4
t5an1 am 1
s0 d
s1sfs2
s3s4
figure 1. an accepting petri net an 1= (n1;[p1];[p6])and accepting automaton am 1. both are lucent.
now consider the marked petri net an 2and automaton am 2in figure 2. these are not lucent.
for example, state s1inam 2(corresponding to marking [p2;p5]inan 2) enablesc. however, also
states2(corresponding to marking [p2;p6]) enablesc.
p7an 2 am 2
p1
ba
cdf
ep2 p3 p4
p6p5
gt1
t2t3t4
t5t7t6
s0sf s1
s2s3
s4s5
figure 2. another accepting petri net an 2= (n2;[p1];[p7])and accepting automaton am 2. both are not
lucent because there are two markings/states enabling the same set of activities fcg.
lucency is a general notion that is independent of the modeling language used. here, we only
consider automata and petri nets. however, most process modeling languages (statecharts, activity
diagrams, epcs, bpmn, process calculi, etc.) have a state notion where one can reason about the
set of enabled activities (also called actions of labels) when the model is in a particular state. luceny
triggers interesting questions such as: how to exploit lucency during analysis? and how to check
lucency efÔ¨Åciently? it also triggers the question: what is the class of petri nets for which each marking
is uniquely identiÔ¨Åed by the set of enabled transitions? a lucent marked petri net cannot have two
different reachable markings that enable the same set of transitions.w.m.p . van der aalst /lucent process models and translucent event logs 3
table 1. a fragment of an event log corresponding to an 1andam 1in figure 1.
event case activity time enabled
e1 1a 09:22fag
e2 1b 09:34fb;cg
e3 2a 09:45fag
e4 2c 10:12fb;cg
e5 1c 10:17fcg
e6 1e 11:06fd;eg
e7 2b 11:22fbg
e8 3a 11:55fagevent case activity time enabled
e9 3c 12:13fb;cg
e10 2d 12:18fd;eg
e11 2b 13:32fb;cg
e12 2c 13:43fcg
e13 3b 13:52fbg
e14 2e 14:17fd;eg
e15 3e 14:20fd;eg
:::::::::::::::
table 2. an event log corresponding to an 2andam 2in figure 2.
event case activity time enabled
e1 1a 11:07fa;bg
e2 1c 11:34fcg
e3 2b 11:45fa;bg
e4 2c 12:12fcg
e5 2e 12:17feg
e6 1d 13:06fdg
e7 1g 13:22ff;gg
e8 2f 13:55ff;ggevent case activity time enabled
e9 2a 14:13fa;bg
e10 3b 14:18fa;bg
e11 3c 15:32fcg
e12 2c 15:43fcg
e13 2d 15:52fdg
e14 2g 16:17ff;gg
e15 3e 16:20feg
e16 3g 16:25ff;gg
in [1] it was shown that perpetual marked free-choice nets are always lucent. these nets are live
and bounded and also have a so-called regeneration marking . a regeneration marking serves as a
‚Äúregeneration point‚Äù, i.e., a state where all tokens mark a single cluster.
1.2. translucent event logs
an event log is translucent if each event carries information about the set of activities possible. in tra-
ditional event logs, each event has at least three attributes: case (the process instance to which the event
belongs, e.g., an order, customer, or patient), activity (the action performed, e.g., ‚Äúregister request‚Äù or
‚Äúmake payment‚Äù), and time (the time at which the event occurred, e.g., 2019-01-29t19:20+01:00). in
a translucent event log, each event has an additional attribute listing the set of activities enabled.
consider for example table 1 showing an event log generated from the process described in fig-
ure 1. each row corresponds to an event. the last column shows the set of activities enabled. consider
for example event e4which represents the occurrence of activity cfor case 2 at time 10:12. when e4
occurred activities bandcwere enabled. note that table 1 is consistent with both an 1andam 1in
figure 1. case 1 corresponds to the trace ha;b;c;ei. we can also list all activities and make the one
selected bold:ha;bc;c;dei. cases 2 and 3 can also be represented in this way: ha;bc;b;de;bc;c;dei
andha;bc;b;dei.
table 2 shows an event log generated from the process described in figure 2. the three cases can
be compactly represented using the notation introduced before: hab;c;d;fgi,hab;c;e;fg;ab;c;d;fgi,
andhab;c;e;fgi.
this paper presents a discovery algorithm tailored toward translucent event logs. based on table 1,
our algorithm is able to rediscover both an 1andam 1in figure 1 (modulo the renaming of states4 w.m.p . van der aalst /lucent process models and translucent event logs
and places). the information in table 2 is not sufÔ¨Åcient to discover the models in figure 2. our
discovery algorithm will provide an underÔ¨Åtting process model because it is unable to distinguish the
two states enabling c. this illustrates that lucency and translucency are related. therefore, this paper
investigates this relationship in detail.
1.3. related work
this paper extends the work presented [1] which only considers lucency in a petri net setting.1this
was the Ô¨Årst paper that deÔ¨Åned and characterized lucency. the results for perpetual marked free-choice
nets presented later, build on ‚Äústructure theory‚Äù, a branch in petri nets [2, 3, 4, 5, 6] that asks what
behavioral properties can be derived from its structural properties [7, 8, 9]. many different subclasses
have been studied. examples include state machines, marked graphs, free-choice nets, asymmetric
choice nets, and nets without tp and pt handles. structure theory also studies local structures such as
traps and siphons that may reveal information about the behavior of the petri net and includes linear
algebraic characterizations of behavior involving the matrix equation or invariants [8, 9, 3].
free-choice nets are well studied [10, 8, 11, 12]. the deÔ¨Ånite book on the structure theory of
free-choice nets is [9]. also, see [8] for pointers to literature. therefore, it is surprising that the
question whether markings are uniquely identiÔ¨Åed by the set of enabled transitions (i.e., lucency) has
not been explored in literature. lucency is unrelated to the so-called ‚Äúfrozen tokens‚Äù [13]. a petri
net has a frozen token if there exists an inÔ¨Ånite occurrence sequence never using the token. it is
possible to construct live and bounded free-choice nets that are lucent while having frozen tokens.
conversely, there are live and bounded free-choice nets that do not have frozen tokens and are not
lucent. most related to the results presented in this paper is the work on the so-called blocking theorem
[14, 15]. blocking markings are reachable markings which enable transitions from only a single
cluster. removing the cluster yields a dead marking. the blocking theorem states that in a bounded
and live free-choice net each cluster has a unique blocking marking.
in [1], we did not cover the notion of translucency, but mentioned that lucency is interesting from
a process mining point of view. the Ô¨Åeld of process mining [16] studies problems such a process
discovery (learning process models from event logs) [17, 18, 19, 20, 21, 22, 23] and conformance
checking (analyzing discrepancies between observed and modeled behavior) [24, 25]. unlike tradi-
tional synthesis approaches [26, 27, 28], the input (event log) is known to be a sample of the possible
behavior (like in data mining and machine learning). as far as we know, there are no process mining
techniques based on translucent event logs. therefore, it is impossible to compare our process dis-
covery algorithm to existing approaches not using enabling information. for an overview of process
mining techniques, we refer to [16].
1.4. outline
the remainder of this paper is organized as follows. section 2 introduces preliminaries (automata,
petri nets, soundness, subclasses, clusters, components, short-circuiting, etc.) and known results (e.g.,
1the paper won the best paper award at petri nets 2018 and the author was invited to provide this substantially extended
version.w.m.p . van der aalst /lucent process models and translucent event logs 5
the blocking theorem). accepting petri nets with a predeÔ¨Åned initial and Ô¨Ånal marking are related to
accepting automata. section 3 deÔ¨Ånes lucency as a (desirable) behavioral property for both marked
petri nets and automata. translucent event logs are introduced in section 4. in section 5, we present
a novel discovery algorithm and show the value of translucency. the section also explores the re-
lation between lucency and translucency. section 6 discusses techniques to discover petri nets from
translucent event data. section 7 concludes the paper.
2. preliminaries
this section introduces basic concepts related to petri nets, subclasses of nets (e.g., free-choice nets
and workÔ¨Çow nets), and blocking markings.
2.1. multisets, sequences, and functions
p(a) =fxjxagis the powerset ofa, i.e., all subsets of a.b(a)is the set of all multisets over
some seta. for some multiset b2b(a),b(a)denotes the number of times element a2aappears in
b. some examples: b1= [ ] ,b2= [x;x;y ],b3= [x;y;z ],b4= [x;x;y;x;y;z ], andb5= [x3;y2;z]
are multisets over a=fx;y;zg.b1is the empty multiset, b2andb3both consist of three elements,
andb4=b5, i.e., the ordering of elements is irrelevant and a more compact notation may be used for
repeating elements. the standard set operators can be extended to multisets, e.g., x2b2,b2]b3=b4,
b5nb2=b3,jb5j= 6, etc.fa2bgdenotes the set with all elements afor whichb(a)1.bb0if
b(a)b0(a)for alla2a. hence,b3b4andb26b3(becauseb2has twox‚Äôs).b<b0ifbb0and
b6=b0. hence,b3<b 4andb46<b 5(becauseb4=b5).
=ha1;a2;:::;ani2xdenotes a sequence overxof lengthjj=n.i=aifor1ijj.
hiis the empty sequence. sequences can be concatenated using ‚Äú ‚Äù, e.g.,ha;bihb;ai=ha;b;b;ai.
it is also possible to project sequences: ha;b;b;a;c;difa;cg=ha;a;ci.
deÔ¨Ånition 2.1. (functions applied to sets, sequences, and multisets)
letf2x!y,z2 p(x),2x, andb2 b(x).f(z) =ff(x)jx2zg,f() =
hf(1);f(2);:::;f (jj)i,f(b) = [f(x)jx2b], i.e., the multiset where element f(x)appearsp
y2bjf(x)=f(y)b(y)times. iffis a partial function, i.e., f2x6!y, we drop the elements not in
dom(f).
hence, functions can be applied to sets, sequences, and multisets. for example, consider the function
fwithdom(f) =fa;bgandf(a) =xandf(b) =y.f(fa;b;c;dg) =fx;yg,f(ha;b;c;d;b;ai)
=hx;y;y;xi, andf([a2;b2;c;d]) = [x2;y2]. functions can also be applied to nested structures like
multisets of sequences, e.g., f([ha;b;c;d;b;ai2;hc;b;ai3]) = [hx;y;y;xi2;hy;xi3].
2.2. automata
we use automata to describe behavior and use accepting automata when we are interested in the traces
that lead from the initial state to the Ô¨Ånal state (see Ô¨Ågures 1 and 2 for two example automata).6 w.m.p . van der aalst /lucent process models and translucent event logs
deÔ¨Ånition 2.2. (automaton)
anautomaton is formally represented by the four-tuple am = (s;a;;s 0).sis a non-empty set
of states,ais a non-empty alphabet (also referred to as actions or activities), sas
is the transition relation, and s02sis the initial state. an accepting automaton is a Ô¨Åve-tuple
am = (s;a;;s 0;sf)adding a Ô¨Ånal state sf. an (accepting) automaton is deterministic if for any
f(s1;a;s 2);(s1;a;s 3)g:s2=s3. an (accepting) automaton is Ô¨Ånite ifsis Ô¨Ånite.
in the remainder, we will refer to aas the universe of activities andaa as a concrete set
of activities. note that in the context of automata, terms like label andaction are more common.
however, since we relate process models to event logs, we use the term activity .
deÔ¨Ånition 2.3. (enabling, path, and reachability)
letam be an (accepting) automaton with states s, alphabeta, and transition relation sas.
activitya2aisenabled in states2s, denoted as (am;s)[ai, if there exists a state s02ssuch
that(s;a;s0)2.en(am;s) =fa2aj(am;s)[aigis the set of enabled activities in s.
s(;)   !ams0withs;s02s,2s, and2adenotes that there is an n0such that
jj=jj+ 1 =n+ 1 such that1=s,n+1=s0, and for all 1in:(si;ai;si+1)2.
when am is clear from the context, we simply write s(;)   !s0.(;)is called a path leading
from statesto states0.(am;s)[i(am;s0)if any only if there is a such thats(;)   !ams0.
r(am;s) =fs02sj9(;)s(;)   !ams0gis the set of all states reachable from state s.
s0
s1 s2
sfam 3
s0
s1
sfam 4
s0
s1 s2
sfam 5
figure 3. three accepting automata am 3,am 4, and am 5(the initial state is s0and the Ô¨Ånal state is sf).
figure 3 shows three accepting automata. en(am 3;s0)) = en(am 4;s0)) = en(am 5;s0)) =
fa;b;cg.r(am 3;s0) =r(am 5;s0) =fs0;s1;s2;sfg.r(am 4;s0) =fs0;s1;sfg.
in this paper, we assume that automata only contain reachable states, i.e., s=r(am;s0). how-
ever, we sometimes need a stronger property: soundness .
deÔ¨Ånition 2.4. (sound accepting automaton)
letam= (s;a;;s 0;sf)be an accepting automaton. am issound if each state s2sis reachable
(i.e.,s=r(am;s0)), each activity a2acan occur (i.e., there exists s2r(am;s0)such that
a2en(am;s)), the Ô¨Ånal state is reachable from any reachable state (i.e., for any s2r(am;s0):
sf2r(am;s)), and the Ô¨Ånal state is dead (i.e., en(am;sf) =;).w.m.p . van der aalst /lucent process models and translucent event logs 7
the three automata in figure 3 are sound. in the remainder, we focus on sound accepting automata.
a non-sound automaton can be made sound by removing states and activities not on a path from s0to
sfand adding a ‚Äústop‚Äù activity.
deÔ¨Ånition 2.5. (complete paths)
letam = (s;a;;s 0;sf)be an accepting automaton. (;)2sais acomplete path if
s0(;)   !amsf.(am) =f(;)2sajs0(;)   !amsfgis the set of all complete paths.
complete paths start in the initial state s0and end in the Ô¨Ånal state sf. consider am 3,am 4, and
am 5in figure 3. (am 3) =f(hs0;s1;sfi;ha;bi);(hs0;s2;sfi;hb;ai);(hs0;sfi;hci)g.(am 4)
and(am 5)are inÔ¨Ånite due to the loops involving activity c. some examples of complete paths:
(hs0;s1;sfi;ha;ai)2(am 4),(hs0;s0;s1;s1;sfi;hc;a;c;ai)2(am 4), and (hs0;s2;s2;s2;sfi;
hb;c;c;bi)2(am 5). a set or multiset of complete paths is transition-complete if all transitions
(s;a;s0)2occur at least once.
deÔ¨Ånition 2.6. (transition-complete)
letam = (s;a;;s 0;sf)be an accepting automaton and x(am)a set of complete paths.
xistransition-complete if=f(s;a;s0)j9(;)2x91ijj(s;a;s0) = (i;i;i+1)g. multiset
x2b((am))istransition-complete if the corresponding set f2xgis transition-complete.
x=f(hs0;s0;s1;s1;sfi;hc;a;c;ai);(hs0;s1;sfi;hb;bi)g (am 4)is transition-complete for
am 4.y=f(hs0;s1;sfi;ha;bi);(hs0;sfi;hci)g (am 3)is not transition-complete for am 3
since (s0;b;s 2)and(s2;a;sf)are not covered.
later we will use the following two standard equivalence notions (isomorphic and bisimilar).
deÔ¨Ånition 2.7. (isomorphic and bisimilar)
letam 1= (s1;a1;1;s1
0;s1
f)andam 2= (s2;a2;2;s2
0;s2
f)be two accepting automata. am 1
andam 2areisomorphic if there is a bijective mapping h2s1!s2such thath(s1
0) =s2
0,
h(s1
f) =s2
fand(s;a;s0)21if and only if (h(s);a;h(s0))22.am 1andam 2arebisimilar if
there is a relation rs1s2such that (1) (s1
0;s2
0)2r, (2)(s1
f;s2
f)2r, (3) for any (s1;a;s0
1)21
ands22s2such that (s1;s2)2r, there is an s0
22s2such that (s0
1;s0
2)2rand(s2;a;s0
2)22,
and (4) for any (s2;a;s0
2)22ands12s1such that (s1;s2)2r, there is an s0
12s1such that
(s0
1;s0
2)2rand(s1;a;s0
1)21.
when two accepting automata are isomorphic, they are also bisimilar. the reverse does not hold, e.g.,
am 4andam 5in figure 3 are bisimilar but not isomorphic.
2.3. petri nets
next to automata, we use petri nets and introduce a few basic concepts and standard notations.
deÔ¨Ånition 2.8. (petri net)
a petri net is a tuple n= (p;t;f )withpthe non-empty set of places, tthe non-empty set of
transitions such that p\t=;, andf(pt)[(tp)the Ô¨Çow relation such that the graph
(p[t;f)is connected.8 w.m.p . van der aalst /lucent process models and translucent event logs
deÔ¨Ånition 2.9. (marking)
letn= (p;t;f )be a petri net. a marking mis a multiset of places, i.e., m2b(p).(n;m )is a
marked net.
for a subset of places xp:mx= [p2mjp2x]is the marking projected on this subset.
a petri net n= (p;t;f )deÔ¨Ånes a directed graph with nodes p[tand edgesf. for any
x2p[t,x=fyj(y;x)2fgdenotes the set of input nodes and x=fyj(x;y)2fgdenotes
the set of output nodes. the notation can be generalized to sets: x=fyj9x2x(y;x)2fgand
x=fyj9x2x(x;y)2fgfor anyxp[t. we add the net nas superscript when confusion
is possible:n. apath in a petri net n= (p;t;f )is a sequence of nodes =hx1;x2;:::;xnisuch
that(xi;xi+1)2ffor1i<n . hence,xi=xi 1for1<inandxi=xi+1for1i<n .
is an elementary path ifxi6=xjfor1i<jn.
a transition t2tisenabled in markingmof netn, denoted as (n;m )[ti, if each of its input
placestcontains at least one token. en(n;m ) =ft2tj(n;m )[tigis the set of enabled
transitions.
an enabled transition tmay Ô¨Åre, i.e., one token is removed from each of the input places tand
one token is produced for each of the output places t. formally:m0= (mnt)]tis the marking
resulting from Ô¨Åring enabled transition tin markingmof petri net n.(n;m )[ti(n;m0)denotes
thattis enabled in mand Ô¨Åringtresults in marking m0.
let=ht1;t2;:::;tni 2tbe a sequence of transitions. (n;m )[i(n;m0)denotes that
there is a set of markings m1;m 2;:::;mn+1(n0) such thatm1=m,mn+1=m0, and
(n;mi)[tii(n;mi+1)for1in. a marking m0isreachable frommif there exists a Ô¨Åring
sequencesuch that (n;m )[i(n;m0).r(n;m ) =fm02b(p)j92t(n;m )[i(n;m0)gis
the set of all reachable markings.
figure 1 shows a marked petri net having 6 places and 5 transitions. transitions t2andt3are en-
abled in marking m= [p2;p3].r(n;[p1]) =f[p1];[p2;p3];[p3;p4];[p2;p5];[p4;p5];[p6]g. the Ô¨År-
ing sequenceht1;t2;t3;t4ileads from marking [p1]to marking [p2;p3], i.e., (n;[p1])[ht1;t2;t3;t4ii
(n;[p2;p3]).
2.4. accepting and/or labeled petri nets
the counterpart of an accepting automaton is an accepting petri net having a predeÔ¨Åned Ô¨Ånal marking .
deÔ¨Ånition 2.10. (accepting petri net)
anaccepting petri net an = (n;m;mf)is a petri net n= (p;t;f )with an initial mark-
ingm2 b(p)and a Ô¨Ånal marking mf2 b(p).an accepts=ha1;a2;:::;ani 2tif
(an;m)[i(an;mf).
figures 1 and 2 show two accepting petri nets an 1andan 2. the tokens indicate the initial
markings ( [p1]in both models). the places involved in the Ô¨Ånal marking have a double border, i.e.,
[p6]is the Ô¨Ånal marking of an 1and[p7]is the Ô¨Ånal marking of an 2.
when analyzing accepting petri nets we often ‚Äúshort-circuit‚Äù the model to make it cyclic, i.e.,
when reaching the Ô¨Ånal marking the net can return to the initial state. figure 4 shows how accepting
petri net an 3is short-circuited resulting in an 3which includes transition t.w.m.p . van der aalst /lucent process models and translucent event logs 9
t1
t2t3
t4
t5
t6t7p7 p1
p2p3
p4
p5
p6p8t8t*t0
p9p0
p10
figure 4. the petri net without transition tis an accepting petri net an 3= (n3;[p0];[p10]) with initial
marking [p0]and Ô¨Ånal marking [p10]. the short-circuited net an 3= (n3;[p0])adds transition tto make the
net cyclic.
deÔ¨Ånition 2.11. (short-circuited net)
letan= (n;m;mf)be an accepting petri net. the corresponding short-circuited marked petri net
isan= (n;m )withn= (p;t[ftg;f[(ftgfp2mg)[(fp2mfgftg)andt62t.
in a similar way, we can short-circuit the two accepting petri nets an 1andan 2in Ô¨Ågures 1
and 2 and obtain an 1andan 2. in these examples, the initial and Ô¨Ånal markings have only one
token. however, the deÔ¨Ånition allows for any initial and Ô¨Ånal marking. hence, this extends the notion
of short-circuiting used in the context of workÔ¨Çow nets [29, 30]. just like for workÔ¨Çow nets and
accepting automata, we deÔ¨Åne a soundness notion for accepting petri nets.
deÔ¨Ånition 2.12. (sound accepting petri net)
letan= (n;m;mf)be an accepting petri net. an issound if (1) for each t2t, there exists a
m02r(n;m )such thatt2en(n;m0), (2) for allm02r(n;m ),mf2r(n;m0), (3) for all
m02r(n;m ),m06> mf, (4) for allp2p,m(p)1andmf(p)1, and (5) for all p2mf,
p=;.
the Ô¨Årst requirement states that there should be no dead transitions. the second requirement ensures
that it is always possible to reach the Ô¨Ånal marking. the third requirement ensures that there are
no markings ‚Äúdominating‚Äù mf. the fourth requirement states that the initial and Ô¨Ånal markings are
‚Äúsafe‚Äù (at most one token in a place), the Ô¨Åfth requirement states that places in the Ô¨Ånal marking have
no output arcs (to ensure that the Ô¨Ånal marking is dead). the three accepting petri nets an 1,an 2,
andan 3shown thus far, are all sound.
transitions can be labeled. figures 1 and 2 already showed transition labels fa;b;:::gnext to the
transition identiÔ¨Åers ft1;t2;:::g. for example, l(t1) =a,l(t2) =b, etc.
deÔ¨Ånition 2.13. (labeling function)
letn= (p;t;f )be a petri net and aa set of activities. labeling function l2t!ais a mapping10 w.m.p . van der aalst /lucent process models and translucent event logs
relating each transition to an activity. nlis the corresponding labeled petri net. anlis a labeled
accepting petri net.
note that labeling function ldoes not need to be injective, i.e., there can be multiple transitions mapped
onto the same activity. using deÔ¨Ånition 2.1, we can apply function lto sets, multisets, and sequences
of transitions. for x=ft1;t2;:::;tng,l(x) =fl(t1);l(t2);:::;l (tn)g. for=ht1;t2;:::;tni,
l() =hl(t1);l(t2);:::;l (tn)i. we extend this also to sets and multisets of sequences. for yt,
l(y) =fl()j2yg. forz2b(t),l(z) = [l()j2z]. this provides a general way to
convert transition names into activity names in different contexts, e.g., en(nl;m) =enl(n;m ) =
l(en(n;m )).
figures 1 and 2 already illustrated that accepting petri nets can be transformed into accepting
automata. the corresponds to the standard notion of a reachability graph .
deÔ¨Ånition 2.14. (mapping petri nets onto automata)
a marked petri net (n;m )deÔ¨Ånes an automaton aut(n;m ) = (s;a;;s 0)withs=r(n;m ),
a=t,=f(s;a;s0)2sasj(n;s)[ai(n;s0)g, ands0=m. a accepting petri net
(n;m;mf)deÔ¨Ånes an accepting automaton aut(n;m;mf) = (s;a;;s 0;sf)with additionally
sf=mf. if there is a labeling function l2t!a, then aut(nl;m) =autl(n;m ) = (s;a;;s 0)
withs=r(n;m ),a=l(t),=f(s;l(t);s0)2sasj(n;s)[ti(n;s0)g, ands0=m.
aut(nl;m;mf) =autl(n;m;mf) = (s;a;;s 0;sf)addssf.
the accepting petri nets in Ô¨Ågures 1 and 2 are sound. therefore, the corresponding automata depicted
are also sound. it is easy to verify that this is always the case.
observation 2.15. let(n;m )marked petri net and aut(n;m )the corresponding accepting au-
tomaton. if (n;m )is sound (deÔ¨Ånition 2.12), then aut(n;m )is sound (deÔ¨Ånition 2.4).
the concept of lucency deÔ¨Åned later is related to the notion of a blocking marking . to explain this
notion we need to introduce the notion of a cluster and free-choice nets.
thecluster of nodex, denoted [x]cis the smallest set such that (1) x2[x]c, (2) ifp2[x]c\p,
thenp[x]c, and (3) ift2[x]c\t, thent[x]c.[n]c=f[x]cjx2p[tgis the set of clusters
ofn.
n= (p;t;f )is afree-choice net if for any for any t1;t22t:t1=t2ort1\t2=;.
free-choice nets are probably the best studied subclass of petri nets [10, 9, 8, 11, 12].
in a blocking marking, the transitions in a particular cluster are enabled while all transitions outside
the cluster are disabled. formally, a blocking marking for cluster cis a marking mb2r(n;m )
such that en(n;mb) =t(c), i.e., all transitions in the cluster are enabled, but no other transitions.
in [31] genrich and thiagarajan showed that unique blocking markings exist for all clusters in
live and safe marked graphs. this was generalized by gaujal, haar, and mairesse in [14] where they
showed that blocking markings exist and are unique in live and bounded free-choice nets. note that in
a free-choice net all transitions in the cluster are enabled simultaneously (or all are disabled). there is
one unique marking in which precisely one cluster is enabled. moreover, one can reach this marking
without Ô¨Åring transitions from the cluster that needs to become enabled. a simpliÔ¨Åed proof was given
in [15] and another proof sketch can be found in [8].w.m.p . van der aalst /lucent process models and translucent event logs 11
3. lucent process models
this paper focuses on process models whose states are uniquely identiÔ¨Åed based on the activities they
enable. hence, there cannot be two different states enabling the same set of activities. such process
models are called lucent .
deÔ¨Ånition 3.1. (lucent automata)
letam = (s;a;;s 0)be an automaton. am islucent if and only if for any s1;s22r(am;s0):
en(am;s1) =en(am;s2)impliess1=s2.
automaton am 1in figure 1 is lucent. automaton am 2in figure 2 is not lucent because en(am 2,
s1) =en(am 2;s2) =fcg. automaton am 3in figure 3 is lucent, but the other two automata am 4
andam 5are not (there are multiple states enabling a,b, andc).
theorem 3.2. (bisimilar lucent automata are isomorphic)
letam 1= (s1;a1;1;s1
0)andam 2= (s2;a2;2;s2
0)be two bisimilar sound lucent accepting
automata. am 1andam 2are isomorphic.
proof:
assume there is a relation rs1s2such that (1) (s1
0;s2
0)2r, (2)(s1
f;s2
f)2r, (3) for any
(s1;a;s0
1)21ands22s2such that (s1;s2)2r, there is an s0
22s2such that (s0
1;s0
2)2r
and(s2;a;s0
2)22, and (4) for any (s2;a;s0
2)22ands12s1such that (s1;s2)2r, there is an
s0
12s1such that (s0
1;s0
2)2rand(s1;a;s0
1)21. it sufÔ¨Åces to show that ris bijective.
note that due to bismilarity, for any (s1;s2)2r:faj9s0
1(s1;a;s0
1)21g=faj9s0
2(s2;a;s0
2)2
2g. hence, (s1;s2)2rimplies en(am 1;s1) =en(am 2;s2). if(s1;s2)2rand(s1;s3)2r,
thenen(am 1;s1) =en(am 2;s2) =en(am 2;s3). hence,s2=s3due to lucency. if (s1;s2)2r
and(s3;s2)2r, then en(am 1;s1) =en(am 1;s3) =en(am 2;s2)ands1=s3due to lucency.
hence,ris functional and injective. due to soundness all states are reachable and it is easy to see
thatris also total and surjective, thus proving that am 1andam 2are isomorphic. u t
lucency is a general property and can also be formulated in the context of (labeled) petri nets. given
a marked petri net we would like to know whether each reachable marking has a unique ‚Äúfootprint‚Äù in
terms of the transitions it enables. if this is the case, then the petri net is lucent .
deÔ¨Ånition 3.3. (lucent petri nets)
let(n;m )be a marked petri net. (n;m )islucent if and only if for any m1;m 22r(n;m ):
en(n;m 1) =en(n;m 2)impliesm1=m2. given a labeling function l2t!a, labeled petri
net(nl;m)is lucent if and only if for any m1;m 22r(n;m ):enl(n;m 1) =enl(n;m 2)implies
m1=m2.
petri net (n1;[p1])in figure 1 is lucent. petri net (n2;[p1])in figure 2 is not lucent (two enabling
justc). both (n3;[p0])(withoutt) and (n3;[p0])(the short-circuited net with t) in figure 4 are
lucent.
every marked petri net (labeled or not) deÔ¨Ånes a corresponding automaton (deÔ¨Ånition 2.14). from
the deÔ¨Ånitions, we can derive that a petri net is lucent if and only if its corresponding automaton is
lucent.12 w.m.p . van der aalst /lucent process models and translucent event logs
observation 3.4. the unlabeled marked petri net (n;m )is lucent if and only if aut(n;m )is lucent.
the labeled marked petri net (nl;m)is lucent if and only if aut(nl;m)is lucent.
it is not easy to characterize the class of lucent petri nets. however, it is easy to show that un-
bounded petri nets or petri net with non-unique blocking markings are not lucent.
lemma 3.5. let(n;m )be a lucent unlabeled marked petri net. (n;m )is bounded and each cluster
has at most one blocking marking.
proof:
assume that (n;m )is both lucent and unbounded. we will show that this leads to a contradiction.
since (n;m )is unbounded, we can Ô¨Ånd markings m1andm2and sequences 0andsuch that
(n;m )[0i(n;m 1)[i(n;m 2)andm2is strictly larger than m1. this implies that we can repeat-
edly execute getting increasingly larger markings: (n;m 2)[i(n;m 3)[i(n;m 4)[i(n;m 5):::.
at some stage, say at mk, the set of places that is marked stabilizes. however, the number of
tokens in some places continues to increase in mk+1,mk+2, etc. hence, we Ô¨Ånd markings that
enable the same set of transitions but that are not the same. for example, mk+16=mk+2and
en(n;mk+1) =en(n;mk+2). hence, the net cannot be lucent.
take any cluster cand assume that (n;m )has two different reachable blocking markings m1
andm2. this means that en(n;m 1) =en(n;m 2) =c\t. hence, (n;m )could not be lucent,
yielding again a contradiction. u t
lemma 3.5 shows that unbounded petri nets cannot be lucent. moreover, it is easy to construct non-
free-choice petri nets that are not lucent. see, for example, figure 2 where the token in p5orp6is
invisible when t3is enabled. another example is shown in figure 5.
t1t2
t3t4p1
p2p4 p3
p5
figure 5. a non-free-choice petri net that is not lucent. cluster fp1;t1ghas two reachable blocking markings
m1= [p1;p3]andm2= [p1;p4]. also clusterfp5;t4ghas two reachable blocking markings m3= [p3;p5]
andm4= [p4;p5]. note that markings m1andm2and markings m3andm4enable the same sets of transi-
tions.
the examples in the introduction suggest that lucency depends on the petri net being free-choice.
however, this is not the case. it is easy to construct a non-free-choice petri net that is lucent (e.g., add
unique self-loop transitions to make places visible). there are also free-choice petri nets that are not
lucent. when multiple transitions have the same label, different markings may enable the same set
of activities. however, even when the petri net is free-choice and unlabeled (i.e., the transitions are
distinguishable), it may still no be lucent. figure 6 shows such a non-lucent free-choice net.w.m.p . van der aalst /lucent process models and translucent event logs 13
t2
t6p1
t5t3
t8 t7p2
p8p3 p6p5
p4 p7t1 t4
figure 6. a live and safe free-choice net that is not lucent because reachable markings [p3;p7;p8]and
[p3;p5;p7]both enable t1andt4.
t1p1
t2
p2p3
t3
p4p5
t4
p6
figure 7. a live and safe marked graph that is not perpetual. note that the net is a marked graph (all places have
one input and one output arc). the model is not lucent since there are two reachable markings m1= [p1;p3;p6]
andm2= [p1;p4;p6]that both enable t1andt4.
hence, just requiring that the petri net is free-choice is not enough. figure 7 even shows a marked
graph (i.e., all places have one input and one output arc) that is not lucent.
in [1] it was shown that perpetual marked free-choice nets are lucent. these nets are live, bounded,
and have a regeneration cluster, i.e., the initial marking is a home marking and marks a single cluster.
the petri net in figure 7 does not have such a regeneration cluster.
4. translucent event logs
intuitively, it seems that lucent process models are more easy to discover. when the process has many
states that are different, but that enable the same set of activities, then it is not easy to learn these
‚Äúhidden‚Äù states. however, even when the underlying process model is lucent, traditional event logs do
not reveal this. if we remove the ‚Äúenabled‚Äù column in table 1, we cannot know that ccan be followed
byd(this never happens in e1). however, when looking at events e5ande6and taking the ‚Äúenabled‚Äù
column into account, we know that activity cin case 1 could have been followed by activity d.
in this paper, we consider event logs that also reveal the enabled set of activities and connect this
to the notion of lucency. event logs where every event lists the set of enabled activities is called a
translucent event log . this section introduces such logs. later, we will provide a discovery algorithm
and relate translucency of event logs to lucency of process models. however, we Ô¨Årst deÔ¨Åne classical
event logs and introduce some notations.14 w.m.p . van der aalst /lucent process models and translucent event logs
deÔ¨Ånition 4.1. (event log)
cis the universe of case identiÔ¨Åers, ais the universe of activity names, and tis the universe of
timestamps. an event log is a non-empty set of events esuch that for any e2e:case(e)2c,
act(e)2a,time(e)2t. there could be additional optional attributes, e.g., x(e)is thexattribute
ofe(e.g., cost, resource, etc.). for simplicity, we assume that events in eare totally ordered such that
e1<e 2impliestime(e1)time(e2).
tables 1 and 2 show two event logs. for example, in table 1, case(e1) = 1 ,act(e1) =a, and
time(e1) =09:22.
deÔ¨Ånition 4.2. (notation)
letebe an event log.
case(e) =fcase(e)je2egc andact(e) =fact(e)je2ega .
forc2case(e),e;c=he1;e2;:::;enisuch thatfe1;e2;:::;eng=fe2ejcase(e) =cg
ande1< e 2< ::: < e n.e;c
i=eiis thei-th event of case cineandjcj=nis number of
events related to c.
e=fe2ej9c2case (e)e=e;c
jcjgis the set of end events .
function nexte2(ene)!egives the next event in the same case (not deÔ¨Åned for end
events). hence, nexte(e;c
i) =e;c
i+1forc2case(e)and1i<jcj.
x(e;c) =hx(e1);x(e2);:::;x(en)iprojectse;c=he1;e2;:::;enionto the correspond-
ing attribute for a given case c, e.g.,act(e;c)is the sequence of activities executed for c.
le
act= [act(e;c)jc2case(e)]2b(act(e))is the simple event log of e.
lete1=fe1;e2;:::;e 15gbe the event log shown in table 1 (ignoring the ‚Äúenabled‚Äù column).
case(e1) =f1;2;3g,act(e1) =fa;b;c;d;eg, ande1=fe6;e14;e15g.e1;1=he1;e2;e5;e6i.
nexte1(e1) =e2,nexte1(e2) =e5, etc.le1
act= [ha;b;c;ei;ha;c;b;d;b;c;ei;ha;c;b;ei].
a translucent event log also provides an additional attribute en(e)indicating the set of enabled
activities when event eoccurred. many information systems provide such information implicitly when
providing users with a set of possible actions. in a workÔ¨Çow management (wfm) or business process
management (bpm) system such information is directly available (the so-called ‚Äúworklists‚Äù are based
on this). we also anticipate that en(e)can be predicted based on historic information. for now, we
simply assume this information to be present. we realize that this is a strong assumption, but we will
show that having this information simpliÔ¨Åes discovery dramatically.
deÔ¨Ånition 4.3. (translucent event log)
a translucent event log is an event log esuch that for any e2e:en(e)a such thatact(e)2
en(e). the additional attribute en(e)denotes the set of enabled activities when eoccurred. a
translucent event log eisrooted if and only if there is an ae
inita such that for all c2case(e):
en(e;c
1) =ae
init, i.e., all cases start with the same set of enabled activities. a translucent event log
eiscomplete if for anye12eanda2en(e1)there existse22ewithen(e1) =en(e2)and
a=act(e2).
in table 1 also en(e)is given for all e2e1=fe1;e2;:::;e 15g, e.g.,en(e2) =fb;cg(see the
‚Äúenabled‚Äù column). the event logs in tables 1 and 2 are both rooted and complete.w.m.p . van der aalst /lucent process models and translucent event logs 15
if a translucent event log is not rooted, it can be turned into a rooted translucent event log by
adding an additional start event to each case. for each case c, add an event ec
0such thatcase(ec
0) =c,
en(ec
0) =fig,act(ec
0) =i, andtime(ec
0) =time(e;c
1). as a result: ae
init=fig. in the
remainder, we assume that all translucent event logs are rooted.
one could go one step further and deÔ¨Åne the notion of ‚Äúsuper-translucent event logs‚Äù that directly
deÔ¨Åne the state in which the event occurs. note that for event logs generated from lucent process
models, translucent event logs are ‚Äúsuper-translucent‚Äù because the set of enabled activities identiÔ¨Åes a
unique state. however, in real-life applications, one cannot inspect the internal state. however, many
systems expose the set of enabled activities (e.g., the worklist in a workÔ¨Çow management system or
the user interface of an interactive tool).
5. discovering lucent process models from translucent event logs
we now provide a discovery algorithm for translucent event logs. it exploits the additional enabling
information provided. after introducing the technique, we discuss its properties.
5.1. basic discovery algorithm
if we assume that the process model is lucent and the event log is translucent, process discovery
becomes trivial. the state in which an event eoccurs is determined by en(e). this immediately
yields a process discovery algorithm that transforms a rooted translucent event log into an accepting
automaton.
deÔ¨Ånition 5.1. (discovery algorithm)
letebe a rooted translucent event log. disc(e) = (s;a;;s 0;sf)is an accepting automaton such
that:s=fen(e)je2eg[f;g ,a=fact(e)je2eg,s0=ae
init,sf=;,=f(s1;a;s 2)2
sasj9e2enes1=en(e)^a=act(e)^s2=en(nexte(e))g[f (s;a;;)2sasj
9e2es=en(e)^a=act(e)g.
the discovery algorithm adds a Ô¨Ånal state ;to the set of states. all other states are linked to the sets of
enabled activities of events. the last event of each case corresponds to a transition (s;a;;)2where
ais the activity and sis the set of enabled activities of this event. the log needs to be rooted to pick
the initial state.
the algorithm is easy to implement. it is even possible to use the existing ‚Äùmine transition sys-
tem‚Äù plug-in provided in prom (based on [17]) with the proper conÔ¨Åguration and some preprocessing.
figure 8 shows four accepting automata generated by prom: automata (a) and (c) were obtained using
our simple discovery algorithm (deÔ¨Ånition 5.1). automaton (a), based on event log e1in table 1, is
identical to am 1in figure 1. automaton (c), based on event log e2in table 2, differs from am 2
in figure 2 because am 2is not lucent. in the discovered automaton the states s1ands2inam 2are
merged, because both enable the same set of activities fcg. we also tried to apply the ‚Äùmine tran-
sition system‚Äù plug-in without using en(e)(i.e., assuming that e1ande2are conventional event
logs). automata (b) and (d) show the results using a horizon of 1 (i.e., the state is determined by the
last activity). the two accepting automata are able to reproduce the e1ande2, but are very different16 w.m.p . van der aalst /lucent process models and translucent event logs
from am 1andam 2. note that automaton (b) does not allow for the traces like ha;b;c;d;b;c;ei
(possible in the original model), but allows for traces like ha;b;d;b;d;b;d;ei(not possible in the orig-
inal model). other conÔ¨Ågurations of the ‚Äùmine transition system‚Äù plug-in (see [17] for the different
abstractions possible) result in similar problems.
(a) (c) (d) (b)
figure 8. four accepting automata created using prom: automaton (a) was obtained by applying our discovery
algorithm to the event log e1in table 1, automaton (b) was obtained by applying the ‚Äùmine transition system‚Äù
plug-in to the same event log without using the set of enabled activities, automaton (c) was obtained by applying
our discovery algorithm to the event log e2in table 2, and automaton (d) was obtained without exploiting the
set of enabled activities. the initial and Ô¨Ånal states are highlighted for clarity.
these examples demonstrate that the enabling information in translucent event logs is highly valu-
able. when the underlying process is lucent, simple algorithms can already provide powerful correct-
ness guarantees. since the event log can always be replayed on the models created using deÔ¨Ånition 5.1,
we can easily add frequency and performance information.
deÔ¨Ånition 5.2. (annotated discovered automaton)
letebe a rooted translucent event log and disc(e) = (s;a;;s 0;sf)the discovered automaton.
(disc(e);fs;fa)is an annotated discovered automaton adding two collections of functions fs
s!randfs(sas)!rwithfsfreq;stsum;stavggfsandfafreq;atsum;atavgg
fasuch that:
sfreq(s) =jfe2ejs=en(e)gjifs2snf;g andsfreq(;) =jcase(e)j.
afreq ((s1;a;s 2)) =jevents ((s1;a;s 2))jwith events ((s1;a;s 2)) =fe2enejs1=
en(e)^a=act(e)^s2=en(nexte(e))g [ fe2ejs1=en(e)^a=
act(e)^s2=;g, for(s1;a;s 2)2.
time(e) =time(nexte(e)) time(e)ife2eneandtime(e) = 0 ife2e.
stsum (s) =p
(s1;a;s2)2js1=sp
e2events ((s1;a;s2))time(e), fors2s.
atsum ((s1;a;s 2)) =p
e2events ((s1;a;s2))time(e), for(s1;a;s 2)2.
stavg (s) =stsum (s)=sfreq(s), fors2s.
atavg ((s1;a;s 2)) =atsum ((s1;a;s 2))=afreq ((s1;a;s 2)), for(s1;a;s 2)2.w.m.p . van der aalst /lucent process models and translucent event logs 17
as deÔ¨Ånition 5.2 shows, we can compute frequencies and durations for both states and transitions.
sfreq(s)is the number of times a state swas visited and afreq ((s1;a;s 2))is the number of times
activityaoccurred in state s1leading tos2.stavg (s)is the average time spent in state sand
atavg ((s1;a;s 2))is the average time to transition from s1tos2by performing a. we can use existing
plug-ins provided in prom to show such replay results. for example, figure 9 shows the ‚Äùanalyze
transition system‚Äù plug-in providing detailed statistics for states and transitions using the model our
discovery algorithm produced for the event log in table 1.
(c)
(a)
(b)
figure 9. the accepting automaton can be used for subsequent analysis in prom, e.g., (a) coloring states and
transitions based on sojourn times ( stavg (s))) and delays ( atavg ((s1;a;s 2))), (b) providing detailed replay
statistics, and (c) converting the accepting automaton into an accepting petri net using state-based regions [17,
27, 22].
5.2. properties
the discovery algorithm described in deÔ¨Ånition 5.1 provides several guarantees. for example, the
process model can reproduce the event log used to learn it.
theorem 5.3. (discovered model can reproduce event log)
letebe a rooted translucent event log and disc(e)the corresponding accepting automaton. disc(e)
can reproduce the event log, i.e., f2le
actgfj(;)2(disc(e))g.
proof:
let2le
actand0=e;c=he1;e2;:::;enibe a corresponding sequence of events such that
=en(0)(there is at least one such case c). let=en(0)h;i.(;)provides the corresponding
path in the automaton starting in s0and ending in sf. hence, (;)2(disc(e)).u t
the outgoing arcs of state sin the discovered automaton have activity labels from s(saand is
only empty when it is the Ô¨Ånal state). in case of a complete log, there is at least one arc for each a2s.18 w.m.p . van der aalst /lucent process models and translucent event logs
lemma 5.4. letebe a rooted translucent event log and disc(e) = (s;a;;s 0;sf)the correspond-
ing accepting automaton. for any s2s:en(disc(e);s) =fact(e)je2e^en(e) =sgs.
moreover, if eis complete, then en(disc(e);s) =sfor alls2s.
proof:
clearly, en(disc(e);;) =;, because of the way is constructed (;has only ingoing arcs). hence,
both statements hold if s=;. assume that s6=;, then there is a non-empty set of events es=fe2
ejen(e) =sgresponsible for the outgoing arcs fact(e)je2esgs. ifeis complete, all arcs
are present. u t
if the log is complete, then the discovered model is lucent and sound.
theorem 5.5. (discovered model is lucent and sound when log is complete)
for any rooted complete translucent event log e,disc(e)is a lucent and sound accepting automaton.
proof:
by construction am=disc(e) = (s;a;;s 0;sf)is an accepting automaton.
sinceeis complete, s=en(am;s)for anys2s(see lemma 5.4). hence, for any s1;s22s:
en(am;s1) =en(am;s2)impliess1=s2, i.e., disc(e)is a lucent.
next, we prove soundness. for each state s2snf;g there is an event e2esuch thats=en(e).
consider the corresponding trace cto whichebelongs. this trace deÔ¨Ånes a path starting in s0, visiting
sand ending in;. similarly, a path can be constructed for each activity a2a. hence, (1) all states
are reachable, (2) all activities can occur, and (3) it is always possible to reach the Ô¨Ånal state, and (4)
the Ô¨Ånal state is dead ( ;has only incoming transitions). u t
thematching notion will be used to relate complete paths of the model to cases in the event log.
deÔ¨Ånition 5.6. (matching)
letam = (s;a;;s 0;sf)be an accepting automaton, x2b((am))a multiset of complete
paths, andea translucent event log. eweakly matches x, notationewx, if there exists a mapping
h2s!p (a), such that [(h();)j(;)2x] = [(en(e;c)h;i;act(e;c))jc2case(e)].
for a given h, we writeeh
wx.estrongly matches x, notationex, ifeh
wxwith
h(s) =en(am;s)fors2s.
we are able to rediscover a sound lucent accepting automaton based on a translucent event log that
‚Äúcovers‚Äù all transitions in the automaton (i.e., there exists a transition-complete multiset of complete
paths strongly-matching the event log).
theorem 5.7. (rediscovery of a sound lucent accepting automaton)
letam be a sound lucent accepting automaton and ea translucent event log such that there exists a
strongly-matching transition-complete multiset of complete paths. am anddisc(e)are isomorphic.w.m.p . van der aalst /lucent process models and translucent event logs 19
proof:
letxbe the required strongly-matching transition-complete multiset of complete paths, i.e., x2
b((am)),xis transition-complete, and ex.am = (s;a;;s 0;sf)is the sound lucent
accepting automaton that needs to be rediscovered using e. rename the states in ssuch thats2
sis mapped onto s0=en(am;s). the resulting automaton is am0= (s0;a0;0;s0
0;s0
f)with
s0=fen(am;s)js2sg,a0=a,0=f(en(am;s1);a;en(am;s2))j(s1;a;s 2)2g,
s0
0=en(am;s0),s0
f=en(am;s0) =;. since am is lucent, am andam0are isomorphic (both
are identical modulo the renaming of states), because there are no two states enabling the same set of
activities (the mapping s0=en(am;s)is a bijection). let x0be the same as xmodulo the renaming
of states. let disc(e) = (s00;a00;00;s00
0;s00
f).
eis complete because ex0andx0is a transition-complete multiset of complete paths. hence,
according to lemma 5.4, en(disc(e);s) =sfor alls2s00. it is easy to see that s00=s0,a00=a0,
00=0,s00
0=s0
0, ands00
f=s0
f. therefore, disc(e) =am0and thus isomorphic with am.u t
consider the sound lucent accepting automaton am 1in figure 1 and the translucent event log e1
in table 1. x= [(hs0;s1;s2;s4;sfi;ha;b;c;ei);(hs0;s1;s3;s4;s1;s2;s4;sfi;ha;c;b;d;b;c;ei);
(hs0;s1;s3;s4;sfi;ha;c;b;ei)]is a strongly-matching transition-complete multiset of complete paths.
hence, am 1anddisc(e1)are guaranteed to be isomorphic. figure 1 (showing am 1) and figure 8(a)
(showing disc(e1)) illustrate that this is indeed the case.
theorem 5.7 shows that any event log that covers all the transitions in the unknown lucent model
can be used to rediscover the model (up to isomorphism). moreover, if the model is not lucent and
only a weakly matching event log is used as input, we still Ô¨Ånd a model covering all behavior in the
original model.
theorem 5.8. (reproducing the behavior of a non-lucent automaton)
letam be a sound (possibly non-lucent) accepting automaton and ea translucent event log such that
there exists a weakly-matching transition-complete multiset of complete paths. disc(e)is guaranteed
to be lucent and sound accepting automaton able to reproduce the behavior of am, i.e.,fj(;)2
(am)gfj(;)2(disc(e))g.
proof:
compared to theorem 5.7 there are two differences: am may not be lucent and the event log only
needs to be weakly-matching. let xbe the corresponding weakly-matching transition-complete
multiset of complete paths, i.e., x2 b((am)),xis transition-complete, and ewx. let
h2s!p (a)be the corresponding mapping, i.e., eh
wx. moreover, am = (s;a;;s 0;sf)
anddisc(e) = (s0;a0;0;s0
0;s0
f).
first, we prove that fj(;)2(am)gfj(;)2(disc(e))gby showing that for any
(;)2(am),(h();)2(disc(e)). this follows from s0
0=h(s0)(all complete paths start in
s0and correspond to initial events having en(e) =h(s0)),s0
f=h(sf) =;(all complete paths end
in a state mapped onto ;due toeh
wx), and for any (s1;a;s 2)2, also (h(s1);a;h(s2))20(x
is transition-complete and eh
wx).20 w.m.p . van der aalst /lucent process models and translucent event logs
remains to prove that disc(e)is a lucent and sound. eis rooted because am has one initial
states0that is mapped onto s0
0=h(s0). hence, all cases start with an event having en(e) =s0
0.
eis complete because xis transition-complete, eh
wx, and states can only be merged (not split).
therefore, we can apply theorem 5.5 showing that disc(e)is a lucent and sound. u t
consider the sound non-lucent accepting automaton am 2in fig. 2 and the translucent event log e2in
table 2.x=[(hs0;s1;s3;s5;sfi;ha;c;d;gi);(hs0;s2;s4;s5;s0;s1;s3;s5;sfi;hb;c;e;f;a;c;d;gi);
(hs0;s2;s4;s5;sfi;hb;c;e;gi)]is a transition-complete multiset of complete paths. e2h
wxfor
h(s0) =fa;bg,h(s1) =fcg,h(s2) =fcg,h(s3) =fdg,h(s4) =feg,h(s5) =ff;gg, and
h(sf) =;. therefore, disc(e2)should be able to reproduce the behavior of am 2. the discovered
model disc(e2)in figure8(c) shows that this is indeed the case.
let us now consider the scenario where en(e)is not recorded correctly, i.e., the logging mecha-
nism changes the set of enabled activities into a different set. we call such event logs inexact translu-
cent event logs.
deÔ¨Ånition 5.9. (inexact translucent event logs)
a translucent event log eis inexact when the en(e)does not reÔ¨Çect the real set of enabled activities.
for anye2e:en(e)a is the reported set of enabled activities and real(e)a is the real
set of enabled activities. both include the activity that occurred, i.e., act(e)2en(e)\real(e)
for anye2e.erealis the translucent event log where en(e)is replaced by the value real(e).
inexact translucent event log eis called stable if there is a function fuzz2p(a)!p(a)such that
en(e) =fuzz(real(e))for anye2e. inexact translucent event log eisweakly-stable if there is
a function fuzz2(p(a)a)!p (a)such thaten(e) =fuzz(real(e);act(e))for anye2e.
inexact translucent event log eovershoots ifreal(e)en(e)for alle2e. inexact translucent
event logeundershoots ifen(e)real(e)for alle2e.
when an inexact translucent event log is unstable (i.e., en(e)may have a random value unrelated
to the actual state of the system), then the additional enabling information is useless. however, the
knowledge that the event log is (weakly) stable, overshooting, or undershooting, may be exploited
during discovery.
it is interesting to consider different types of weakly-stable inexact translucent event logs charac-
terized by a function fuzz2(p(a)a)!p (a). for example, fuzz(s;a) =fag(state is fully
determined by the next activity, i.e., undershooting) and fuzz(s;a) =a(resulting in a ‚ÄúÔ¨Çower model‚Äù
allowing for any behavior involving the activities a, i.e., overshooting). it is possible to formulate
additional properties depending on the type of inexactness (undershooting, overshooting, etc.) and the
level of completeness. since this is beyond the scope of this paper, we only provide the following
corollary and show that in general weak stability is not enough.
corollary 5.10. (handling inexact stable translucent event logs)
letam be a sound accepting automaton and ean inexact stable translucent event log such that
forerealthere exists a weakly-matching transition-complete multiset of complete paths. disc(e)is
guaranteed to be a lucent and sound accepting automaton able to reproduce the behavior of am.w.m.p . van der aalst /lucent process models and translucent event logs 21
proof:
we need to show that fj(;)2(am)gfj(;)2(disc(e))g. letxbe the correspond-
ing weakly-matching transition-complete multiset of complete paths for ereal. leth2s!p(a)be
such thaterealh
wx. sinceeis stable, there is a function fuzz such thaten(e) =fuzz(real(e))
for anye2e. we can compose handfuzz into a function gsuch thatg(s) =fuzz(h(s)). it is easy
to verify that eg
wx. hence, we can apply theorem 5.8. u t
corollary 5.10 does not hold for weakly-stable logs due to the fact that fuzz may be diverging, i.e.,
there may be a state sand activities aandbsuch that fuzz(s;a)6=fuzz(s;b). consider, for example
am 1in figure 1 and e1in table 1, in conjunction with the function fuzz(s;x) =fxg. the resulting
discovered model does not allow activity cto followed by activity d. this problem can only be
addressed by using a stronger completeness notation than transition-completeness (e.g., completeness
with respect to two subsequent transitions).
6. discovering petri nets
the basic algorithm described in deÔ¨Ånition 5.1 produces an accepting automaton and not an accepting
petri net. however, whenever activities do not happen in a Ô¨Åxed other, automata tend to be too complex
or underÔ¨Åtting. therefore, we discuss the need for discovering petri nets (either directly or indirectly).
6.1. concurrency matters
consider the event log shown in figure 10(a). the event log contains information about 1000 cases
and each case has 5 events. figure 10(b) shows the so-called directly follows graph produced by disco,
i.e., the process mining tool from fluxicon ( www.fluxicon.com ). figure 10(c) shows the same model
discovered by celonis ( www.celonis.com ). the directly follows graphs produced by these and many
other commercial systems can be very misleading. the state of the process is determined by the last
activity. as a result, concurrent activities automatically result in loops. note that in the event log each
activity occurs precisely once for each case. however, the directly follows graphs in figure 10 do no
capture this and allow for behaviors very different from what was discovered.
process discovery techniques that discover petri nets from event logs will discover concurrency
and do not introduce loops. figure 11(a) shows the model that will be discovered by techniques like
the inductive mining approaches [20, 21], the -algorithm [18], and the ilp miner [23]. clearly, such
models are desirable.
although the petri net in figure 11(a) can be discovered using classical event logs, let us assume
that we have a translucent log. e= [hs;pcg;cg;g;vi402;hs;cpg;pg;g;vi314;hs;pgc;gc;c;vi250;
hs;cgp;gp;p;vi20;hs;gpc;pc;c;vi10;hs;gcp;cp;p;vi4]describes the translucent event log using the
shorthand notation introduced in section 1.2. figure 11(b) shows the automaton am =disc(e)
using the discovery algorithm from deÔ¨Ånition 5.1. clearly, the discovered automaton captures the
process correctly. however, since it shows all interleavings explicitly, the model is not as compact and
less readable.
as mentioned, the petri net in figure 11(a) could have been discovered from a non-translucent
event log. however, as shown before the additional enabling information can be exploited.22 w.m.p . van der aalst /lucent process models and translucent event logs
(a) event log with 1000 cases and 5000 events
(b) process model discovered by disco (c) process model discovered by celonis
(d) process model discovered by prom
402 traces
40.20%  of the logsend request pay ticket confirm  receipt get ticket visit concert
314 traces
31.40%  of the logsend request confirm  receipt pay ticket get ticket visit concert
250 traces
25.00%  of the logsend request pay ticket get ticket confirm  receipt visit concert
20 traces
2.00%  of the logsend request confirm  receipt get ticket pay ticket visit concert
10 traces
1.00%  of the logsend request get ticket pay ticket confirm  receipt visit concert
4 traces
0.40%  of the logsend request get ticket confirm  receipt pay ticket visit concert
figure 10. an event log and the models discovered by disco, celonis, and prom.w.m.p . van der aalst /lucent process models and translucent event logs 23
p1sp2p
gc
p4vp5
p7p8 t1
t4t2
t5 s pcg p3 p6 t3 pg
pccg
p
cg
v
(a) petri net discovered from event log (b) automaton discovered from event log
figure 11. process models discovered from the event log e= [hs;pcg;cg;g;vi402;hs;cpg;pg;g;vi314;
hs;pgc;gc;c;vi250;hs;cgp;gp;p;vi20;hs;gpc;pc;c;vi10;hs;gcp;cp;p;vi4].
6.2. indirect techniques
a straightforward approach to obtain a petri net from the automaton am=disc(e)discovered using
deÔ¨Ånition 5.1 is to use region theory [32]. state-based regions were introduced by ehrenfeucht and
rozenberg in 1989 [26] and generalized by cortadella et al. [27] and badouel, bernardinello, and
darondeau [32]. in [17] it was shown how an event log can be converted into different automata using
a range of abstractions (step 1) and how these automata can be converted into petri nets to uncover
concurrency (step 2). the work presented in this paper can be used to reÔ¨Åne the two-step approach
in [17].
as demonstrated in [28, 27], after some preprocessing, any automaton can be converted into a
labeled petri net that is bisimilar. this may require label splitting when the automaton does not satisfy
the basic synthesis conditions [28, 27]. figure 9 already showed the conversion of the automaton
discovered using deÔ¨Ånition 5.1 into a bisimilar petri net using prom.
s pcg pg
pccg
p
cg
vs pcg pg
pccg
p
cg
v s pcg pg
pccg
p
cg
v
figure 12. the six minimal regions discovered from the automaton in figure 11(b). these regions correspond
to the places of the petri net in figure 11(a).
figure 12 shows the regions in the automaton discovered for the translucent log e= [hs;pcg;cg;
g;vi402;hs;cpg;pg;g;vi314;hs;pgc;gc;c;vi250;hs;cgp;gp;p;vi20;hs;gpc;pc;c;vi10;hs;gcp;cp,
p;vi4].24 w.m.p . van der aalst /lucent process models and translucent event logs
recall that theorem 3.2 showed that any two bisimilar sound lucent accepting automata are iso-
morphic. this makes lucency an interesting property in the context of net synthesis (e.g., its relation
to state separation and forward closure).
6.3. direct techniques
next to the indirect techniques using the discovery algorithm from deÔ¨Ånition 5.1, we also envision
a range of new discovery techniques directly using translucent event logs to uncover concurrency. it
is fairly straightforward to improve existing discovery algorithms using the additional enabling in-
formation in translucent event logs. to illustrate this consider the -algorithm [18] which is based
on learning relations such as a!b(causality),ajjb(concurrency), and a#b(choice). in [18] the
algorithm was shown to be correct for a subclass of lucent petri nets. in [1] it was shown that all perpet-
ual marked free-choice nets are lucent. the class of nets for which the -algorithm was proven to be
correct (theorem 4.10 in [18]) is actually subclass of perpetual marked free-choice nets. using the en-
abling information attached to events it is possible to improve the quality of the relations ( a!b,ajjb,
anda#b) and add new ones. consider, for example, the event log [ha;bc;c;dei;ha;bc;b;de;bc;c;dei;
ha;bc;b;dei]using the shorthand notation used in section 1.2. although cwas never directly followed
bydthe patternh:::c;de:::ishows that this is possible. the pattern h:::bc;c:::ishows thatcwas
not disabled by doing b, i.e., both are concurrent. the -algorithm cannot distinguish between concur-
rency and the alternation of two activities aandb(e.g., loops of length 2). however, by using enabling
information we can distinguish between a!b!aandajjb. these simple examples show how the
-algorithm can exploit translucency.
another opportunity to employ enabling information is provided by the inductive mining ap-
proaches [20, 21]. these recursively partition the set of activities and logs based on Ô¨Ånding so-called
‚Äúcuts‚Äù in directly-follows graphs. using enabling information one can Ô¨Ånd better cuts, even when the
event log is incomplete. also, discovery techniques using language-based regions can be easily ex-
tended to exploit translucency [19, 23]. for example, in the ilp miner [23] one can add an additional
inequality per activity in the enabling set of an event. this will help to avoid overÔ¨Åtting models (a
common problem when applying regions).
in case the event log is not translucent, the assumption of lucency still provides a new angle on
process discovery, putting more emphasis on Ô¨Ånding states. to illustrate this consider a conventional
event log where each event in the event log is characterized by e= (pref;a; post)whereprefis the
preÔ¨Åx (activities that happened before e),ais the activity executed, and postis the postÔ¨Åx (activities
that happened after e). the result of applying a process discovery algorithm can be seen as a function
state ()which maps any event eonto a state state (e), i.e., the state in which eoccurred (see [24, 17]
for explanations). hence, events e1ande2satisfying state (e1) =state (e2)occurred in the same
state and can be viewed as ‚Äúequivalent‚Äù. this way discovery is reduced to Ô¨Ånding an equivalence
relation on the set of events in the log. given such an equivalence relation one can use a variant of
the discovery algorithm described in deÔ¨Ånition 5.1. viewing process discovery as ‚ÄúÔ¨Ånding an equiv-
alence relation on events‚Äù provides an original angle on this challenging and highly relevant learning
task.w.m.p . van der aalst /lucent process models and translucent event logs 25
7. conclusion and implications
lucency of process models and translucency of event logs were introduced as two new notions related
to explicit ‚Äúenabling information‚Äù. in a lucent process model, there cannot be two states enabling
the same set of activities. in a translucent event log, each event carries information about the set of
activities enabled when it occurred. this paper explored these notions and related them.
we provided a novel discovery algorithm for translucent event logs. using the additional enabling
information, our algorithm can easily outperform traditional algorithms, especially when models are
large and event logs are incomplete (i.e., only a small fraction of the set of possible traces is observed).
however, the main point is not to present a particular algorithm. instead, we want to stress the value
of additional enabling information. in many information systems, the system‚Äôs interface reveals the
set of possible activities. consider, for example, the worklists provided by wfm/bpm systems or the
buttons on a user interface. hence, it is not unrealistic to obtain translucent event logs. even when
event logs are semi-translucent (i.e., the reported set of enabled activities is too large or too small),
the information may be valuable. moreover, a range of heuristics is possible to enhance enabling
information and add it to events.
the discovery algorithm for translucent event logs can also be extended with frequency-based
Ô¨Åltering (this is fairly straightforward, cf. deÔ¨Ånition 5.2). as described in section 6, we also envision
a range of discovery techniques based on existing approaches while exploiting translucency.
as demonstrated, lucency and translucency strengthen each other. given a rooted complete translu-
cent event log, our discovery algorithm returns a lucent process model able to reproduce the event log
(theorem 5.3 and theorem 5.5). it is also relatively easy to rediscover lucent process models using
translucent event logs (theorem 5.7). moreover, the ability to link the enabling of activities to states
(i.e., lucency) is also useful when dealing with conventional event logs. process mining studies the
more general relationship between modeled behavior and observed behavior [16]. having process
models where multiple states enable the same set of activities complicates most of the process mining
tasks. for example, petri nets where different transitions have the same activity label are notoriously
difÔ¨Åcult to reconstruct based on event data. in general, the search space can be reduced considerably
by assuming lucent process models. hence, these novel insights may lead to new process mining
algorithms or help to prove the correctness and/or guarantees of existing algorithms.
acknowledgements
we thank the alexander von humboldt (avh) stiftung for supporting our research.
references
[1] van der aalst w. markings in perpetual free-choice nets are fully characterized by their enabled
transitions. in: khomenko v , roux o (eds.), applications and theory of petri nets 2018, volume 10877
oflecture notes in computer science . springer-verlag, berlin, 2018 pp. 315‚Äì336. doi:10.1007/978-3-
319-91268-4 16.
[2] van der aalst w, stahl c. modeling business processes: a petri net oriented approach. mit press,
cambridge, ma, 2011. url https://www.jstor.org/stable/j.ctt5vjqff .26 w.m.p . van der aalst /lucent process models and translucent event logs
[3] murata t. petri nets: properties, analysis and applications. proceedings of the ieee , 1989. 77(4):541‚Äì
580. doi:10.1109/5.24143.
[4] reisig w. petri nets: modeling techniques, analysis, methods, case studies. springer-verlag, berlin,
2013. doi:10.1007/978-3-642-33278-4.
[5] reisig w, rozenberg g (eds.). lectures on petri nets i: basic models, volume 1491 of lecture notes in
computer science . springer-verlag, berlin, 1998. doi:10.1007/3-540-65306-6.
[6] reisig w, rozenberg g (eds.). lectures on petri nets ii: applications, volume 1492 of lecture notes in
computer science . springer-verlag, berlin, 1998. doi:10.1007/3-540-65307-4.
[7] best e. structure theory of petri nets: the free choice hiatus. in: brauer w, reisig w, rozenberg g
(eds.), advances in petri nets 1986 part i: petri nets, central models and their properties, volume 254 of
lecture notes in computer science . springer-verlag, berlin, 1987 pp. 168‚Äì206. doi:10.1007/978-3-540-
47919-2 8.
[8] best e, wimmel h. structure theory of petri nets. in: jensen k, van der aalst w, balbo g, koutny
m, wolf k (eds.), transactions on petri nets and other models of concurrency (topnoc vii), volume
7480 of lecture notes in computer science . springer-verlag, berlin, 2013 pp. 162‚Äì224. doi:10.1007/978-
3-642-38143-0 5.
[9] desel j, esparza j. free choice petri nets, volume 40 of cambridge tracts in theoretical computer
science . cambridge university press, cambridge, uk, 1995. isbn:0-521-46519-2.
[10] best e, desel j, esparza j. traps characterize home states in free-choice systems. theoretical computer
science , 1992. 101:161‚Äì176. doi:10.1016/0304-3975(92)90048-k.
[11] esparza j. reachability in live and safe free-choice petri nets is np-complete. theoretical computer
science , 1998. 198(1-2):211‚Äì224. url https://doi.org/10.1016/s0304-3975(97)00235-1 .
[12] thiagarajan p, v oss k. a fresh look at free choice nets. information and control , 1984. 61(2):85‚Äì113.
url https://doi.org/10.1016/s0019-9958(84)80052-2 .
[13] wehler j. free-choice petri nets without frozen tokens, and bipolar synchronization systems. funda-
menta informaticae , 2010. 98(2-3):283‚Äì320. doi:10.3233/fi-2010-228.
[14] gaujal b, haar s, mairesse j. blocking a transition in a free choice net and what it tells about its
throughput. journal of computer and system science , 2003. 66(3):515‚Äì548. url https://doi.org/
10.1016/s0022-0000(03)00039-4 .
[15] wehler j. simpliÔ¨Åed proof of the blocking theorem for free-choice petri nets. journal of computer and
system science , 2010. 76(7):532‚Äì537. url https://doi.org/10.1016/j.jcss.2009.10.001 .
[16] van der aalst w. process mining: data science in action. springer-verlag, berlin, 2016. doi:10.1007/978-
3-662-49851-4.
[17] van der aalst w, rubin v , verbeek h, van dongen b, kindler e, g ¬®unther c. process mining: a two-
step approach to balance between underÔ¨Åtting and overÔ¨Åtting. software and systems modeling , 2010.
9(1):87‚Äì111. doi:10.1007/s10270-008-0106-z.
[18] van der aalst w, weijters a, maruster l. workÔ¨Çow mining: discovering process models from event
logs. ieee transactions on knowledge and data engineering , 2004. 16(9):1128‚Äì1142. doi:10.1109/
tkde.2004.47.w.m.p . van der aalst /lucent process models and translucent event logs 27
[19] bergenthum r, desel j, lorenz r, mauser s. process mining based on regions of languages. in:
alonso g, dadam p, rosemann m (eds.), international conference on business process management
(bpm 2007), volume 4714 of lecture notes in computer science . springer-verlag, berlin, 2007 pp. 375‚Äì
383. doi:10.1007/978-3-540-75183-0 27.
[20] leemans s, fahland d, van der aalst w. discovering block-structured process models from event
logs containing infrequent behaviour. in: lohmann n, song m, wohed p (eds.), business process
management workshops, international workshop on business process intelligence (bpi 2013), volume
171 of lecture notes in business information processing . springer-verlag, berlin, 2014 pp. 66‚Äì78.
doi:10.1007/978-3-319-06257-0 6.
[21] leemans s, fahland d, van der aalst w. scalable process discovery and conformance checking. soft-
ware and systems modeling , 2018. 17(2):599‚Äì631. doi:10.1007/s10270-016-0545-x.
[22] sol ¬¥e m, carmona j. process mining from a basis of state regions. in: applications and theory of petri
nets (petri nets 2010), volume 6128 of lecture notes in computer science . springer-verlag, berlin, 2010
pp. 226‚Äì245. doi:10.1007/978-3-642-13675-7 14.
[23] van der werf j, van dongen b, hurkens c, serebrenik a. process discovery using integer linear pro-
gramming. fundamenta informaticae , 2010. 94:387‚Äì412. doi:10.3233/fi-2009-136.
[24] van der aalst w, adriansyah a, van dongen b. replaying history on process models for conformance
checking and performance analysis. wires data mining and knowledge discovery , 2012. 2(2):182‚Äì
192. url https://doi.org/10.1002/widm.1045 .
[25] carmona j, van dongen b, solti a, weidlich m. conformance checking: relating processes and models.
springer-verlag, berlin, 2018. doi:10.1007/978-3-319-99414-7.
[26] ehrenfeucht a, rozenberg g. partial (set) 2-structures - part 1 and part 2. acta informatica , 1989.
27(4):315‚Äì368.
[27] cortadella j, kishinevsky m, lavagno l, yakovlev a. deriving petri nets from finite transition systems.
ieee transactions on computers , 1998. 47(8):859‚Äì882. doi:10.1109/12.707587.
[28] carmona j. the label splitting problem. in: jensen k, van der aalst w, marsan ma, franceschinis
g, kleijn j, kristensen l (eds.), transactions on petri nets and other models of concurrency (top-
noc vi), volume 7400 of lecture notes in computer science . springer-verlag, berlin, 2012 pp. 1‚Äì23.
doi:10.1007/978-3-642-35179-2 1.
[29] van der aalst w. the application of petri nets to workÔ¨Çow management. the journal of circuits,
systems and computers , 1998. 8(1):21‚Äì66. url https://doi.org/10.1142/s0218126698000043 .
[30] van der aalst w, van hee k, ter hofstede a, sidorova n, verbeek h, v oorhoeve m, wynn m. sound-
ness of workÔ¨Çow nets: classiÔ¨Åcation, decidability, and analysis. formal aspects of computing , 2011.
23(3):333‚Äì363. doi:10.1007/s00165-010-0161-4.
[31] genrich hj, thiagarajan ps. a theory of bipolar synchronization schemes. theoretical computer
science , 1984. 30(3):241‚Äì318. url https://doi.org/10.1016/0304-3975(84)90137-3 ¬ø
[32] badouel e, bernardinello l, darondeau p. petri net synthesis. texts in theoretical computer science.
an eatcs series. springer-verlag, berlin, 2015. doi:10.1007/978-3-662-47967-4.