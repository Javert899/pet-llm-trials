decomposing petri nets for process mining
{a generic approach{
wil m.p. van der aalst1;2
1architecture of information systems, eindhoven university of technology,
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fw.m.p.v.d.aalst g@tue.nl
2international laboratory of process-aware information systems, national
research university higher school of economics (hse),
33 kirpichnaya str., moscow, russia.
abstract. the practical relevance of process mining is increasing as
more and more event data become available. process mining techniques
aim to discover, monitor and improve real processes by extracting knowl-
edge from event logs. the two most prominent process mining tasks are:
(i)process discovery : learning a process model from example behavior
recorded in an event log, and (ii) conformance checking : diagnosing and
quantifying discrepancies between observed behavior and modeled be-
havior. the increasing volume of event data provides both opportunities
and challenges for process mining. existing process mining techniques
have problems dealing with large event logs referring to many dierent
activities. therefore, we propose a generic approach to decompose pro-
cess mining problems . the decomposition approach is generic and can
be combined with dierent existing process discovery and conformance
checking techniques. it is possible to split computationally challenging
process mining problems into many smaller problems that can be an-
alyzed easily and whose results can be combined into solutions for the
original problems.
1 introduction
process mining aims to discover, monitor and improve real processes by extract-
ing knowledge from event logs readily available in today's information systems
[1]. starting point for any process mining task is an event log . each event in
such a log refers to an activity (i.e., a well-dened step in some process) and is
related to a particular case (i.e., a process instance ). the events belonging to a
case are ordered and can be seen as one \run" of the process. it is important to
note that an event log contains only example behavior , i.e., we cannot assume
that all possible runs have been observed. in fact, an event log often contains
only a fraction of the possible behavior [1].
the growing interest in process mining is illustrated by the process mining
manifesto [41] recently released by the ieee task force on process mining .
this manifesto is supported by 53 organizations and 77 process mining experts2 wil van der aalst
contributed to it. the active contributions from end-users, tool vendors, consul-
tants, analysts, and researchers illustrate the signicance of process mining as a
bridge between data mining and business process modeling.
process 
mining
data-oriented analysis  (data mining, 
machine learning, business intelligence)process model analysis  
(simulation, verification, etc.)performance-oriented questions, 
problems and solutionscompliance-oriented questions, 
problems and solutions
fig. 1. process mining combines process model analysis with data analysis to answer
performance and compliance related questions (left-hand-side). process models can be
seen as the \glasses" required to be able to \see" event data (right-hand-side).
figure 1 positions process mining. traditional data-oriented analysis ap-
proaches such as data mining [38] and machine learning [49] do not consider
processes, i.e., analysis focuses on particular decisions or patterns rather than
the end-to-end processes. in contrast, business process management (bpm) and
workow management (wfm) approaches focus on the analysis and improve-
ment of end-to-end processes using knowledge from information technology and
knowledge from management sciences [34, 65]. process models play a central role
in bpm/wfm. examples of process model analysis approaches are simulation
(for \what if" analysis) and verication (to nd design errors). as shown in
figure 1, process mining combines both worlds to answer both performance and
compliance related questions. the desire to link data and process is reected
by terms such as business process intelligence (bpi) [36, 26]. however, only re-
cently techniques and software have become available to systematically relate
process models and event data [1].
industry reports such as [46] and scientic studies [40] describe the incred-
ible growth of data. the term \big data" illustrates the spectacular growth of
data and the potential economic value of such data in dierent industry sectors.
most of the data that are generated refer to events , e.g., transactions in some
nancial system and actions of some automated system (e.g., x-ray machines,
luggage-handling systems, or sensor networks). the incredible growth of event
data provides new opportunities for process analysis. as more and more actions
of people, organizations, and devices are recorded, there are ample opportunities
to analyze processes based on the footprints they leave in event logs. in fact, wedecomposing petri nets for process mining 3
believe that the analysis of purely hand-made process models will become less
important given the omnipresence of event data.
the incredible growth of event data is also posing new challenges [58]. as
event logs grow, process mining techniques need to become more ecient and
highly scalable. moreover, torrents of event data need to be distributed over mul-
tiple databases and large process mining problems need to be distributed over
a network of computers (e.g., grids). consider for example philips healthcare, a
provider of medical systems that are often connected to the internet to enable
logging, maintenance, and remote diagnostics. more than 1500 cardio vascular
(cv) systems (i.e., x-ray machines) are remotely monitored by philips. on av-
erage each cv system produces 15,000 events per day, resulting in 22.5 million
events per day for just their cv systems. the events are stored for many years
and have many attributes. the error logs of asml's lithography systems have
similar characteristics and also contain about 15,000 events per machine per day.
these numbers illustrate the fact that today's organizations are already storing
terabytes of event data. process mining techniques aiming at very precise re-
sults (e.g., guarantees with respect to the accuracy of the model or diagnostics),
quickly become intractable when dealing with such real-life event logs.
earlier applications of process mining in organizations such as philips and
asml, show that there are various challenges with respect to performance (re-
sponse times), capacity (storage space), and interpretation (discovered process
models may be composed of thousands of activities). in this paper, we present
a general approach to decompose existing process discovery and conformance
checking problems.
petri nets are often used in the context of process mining. various algorithms
employ petri nets as the internal representation used for process mining. exam-
ples are the region-based process discovery techniques [8, 16, 59, 24, 64], the al-
gorithm [9], and various conformance checking techniques [10, 50, 51, 57]. other
techniques use alternative internal representations (c-nets, heuristic nets, etc.)
that can easily be converted to (labeled) petri nets [1].
the process mining spectrum is quite broad and includes techniques like
process discovery, conformance checking, model repair, role discovery, bottle-
neck analysis, predicting the remaining ow time, and recommending next steps.
in this paper, we focus on distributing the following two main process mining
problems:
{process discovery problem : given an event log consisting of a collection of
traces (i.e., sequences of events), construct a petri net that \adequately"
describes the observed behavior.
{conformance checking problem : given an event log and a petri net, diagnose
the dierences between the observed behavior (i.e., traces in the event log)
and the modeled behavior (i.e., ring sequences of the petri net).
both problems are formulated in terms of petri nets. however, other process
notations could be used, e.g., bpmn models, bpel specications, uml activity
diagrams, statecharts, c-nets, and heuristic nets [7]. in fact, also dierent types
of petri nets can be employed, e.g., safe petri nets, labeled petri nets, free-choice4 wil van der aalst
petri nets, etc. therefore, we would like to stress that the results presented
in this paper are as general as possible and do not depend on specic petri-
net properties. our approach is able to decompose any process composed using
the most frequently used workow patterns [7] without assuming a particular
notation.
process discovery and conformance checking are related problems. this be-
comes evident when considering genetic process discovery techniques [48, 19]. in
each generation of models generated by the genetic algorithm, the conformance
of every individual model in the population needs to be assessed (the so-called
tness evaluation). models that t well with the event log are used to create the
next generation of candidate models. poorly tting models are discarded. the
performance of genetic process discovery techniques will only be acceptable if
dozens of conformance checks can be done per second (on the whole event log).
this illustrates the need for ecient process mining techniques.
dozens of process discovery [1, 8, 9, 14, 33, 16, 23, 24, 27, 35, 48, 59, 63, 64] and
conformance checking [5, 10, 11, 13, 21, 28, 35, 50, 51, 57, 62] approaches have been
proposed in literature. despite the growing maturity of these approaches, the
quality and eciency of existing techniques leave much to be desired. state-of-
the-art techniques still have problems dealing with large and/or complex event
logs and process models. therefore, we propose a generic divide and conquer
approach for process mining :
{for conformance checking , we decompose the process model into smaller
partly overlapping model fragments. if the decomposition is done properly,
then any trace that ts into the overall model also ts all of the smaller model
fragments and vice versa. hence, metrics such as the fraction of tting cases
can be computed by only analyzing the smaller model fragments.
{to decompose process discovery , we split the set of activities into a collec-
tion of partly overlapping activity sets. for each activity set, we project the
log onto the relevant events and discover a model fragment. the dierent
fragments are glued together to create an overall process model. again it is
guaranteed that all traces in the event log that t into the overall model also
t into the model fragments and vice versa.
hence, we can decompose the two types of process mining tasks in a generic
manner. the approach presented in this paper is generic because: (1) it does not
assume a particular conformance checking or discovery algorithm, (2) dierent
decompositions can be used, all resulting in valid results, and (c) the class of
processes is not limited to particular types of petri nets (e.g., free-choice nets or
workow nets). for example, the approach can be applied to a range of process
discovery algorithms using dierent types of decompositions.
our generic approach can also be used to distribute process mining problems
over a network of computers (e.g., a grid or cloud infrastructure). the results
in this paper can be viewed as a generalization of our earlier approach based on
\passages" [2]. however, in this paper we do not use the notion of passages and
many of the restrictions imposed in [2] no longer apply.decomposing petri nets for process mining 5
the remainder of this paper is organized as follows. section 2 introduces
various preliminaries (petri nets, event logs, etc.). section 3 discusses quality
criteria for process mining and introduces the notion of alignments to compute
the level of conformance. section 4 denes various decomposition notions, e.g.,
valid decompositions of an overall model into model fragments. the section
denes the requirements ensuring that conformance checking can be decomposed.
section 5 shows that also process discovery problems can be decomposed. the
decomposition approach is independent of the underlying discovery technique
and is proven to be correct. section 6 provides pointers to concrete instantiations
of the approach using the process mining framework prom . related work is
discussed in section 7. section 8 concludes the paper.
2 preliminaries: petri nets and event logs
this section introduces basic concepts related to petri nets and event logs.
2.1 multisets, functions, and sequences
multisets are used to represent the state of a petri net and to describe event
logs where the same trace may appear multiple times.
b(a) is the set of all multisets over some set a. for some multiset b2b(a),
b(a) denotes the number of times element a2aappears in b. some examples:
b1= [ ],b2= [x;x;y ],b3= [x;y;z ],b4= [x;x;y;x;y;z ],b5= [x3;y2;z] are
multisets over a=fx;y;zg.b1is the empty multiset, b2andb3both consist
of three elements, and b4=b5, i.e., the ordering of elements is irrelevant and a
more compact notation may be used for repeating elements.
the standard set operators can be extended to multisets, e.g., x2b2,b2]b3=
b4,b5nb2=b3,jb5j= 6, etc.fa2bgdenotes the set with all elements afor
whichb(a)1. [f(a)ja2b] denotes the multiset where element f(a) appearsp
x2bjf(x)=f(a)b(x) times.
a relationrxyis a set of pairs. 1(r) =fxj(x;y)2rgis the domain
ofr,2(r) =fyj(x;y)2rgis the range of r, and!(r) =1(r)[2(r) are
the elements of r. for example, !(f(a;b);(b;c)g) =fa;b;cg.
f2x6!yis a partial function with domain dom(f)xand range
rng(f) =ff(x)jx2xgy.f2x!yis a total function, i.e., dom(f) =x.
a partial function f2x6!yis injective if f(x1) =f(x2) impliesx1=x2for
allx1;x22dom(f).
denition 1 (function projection). letf2x6!ybe a (partial) function
andqx.fqis the function projected on q: dom (fq) =dom(f)\qand
fq(x) =f(x)forx2dom(fq).
the projection can also be used for bags, e.g., [ x3;y;z2]fx;yg= [x3;y].
=ha1;a2;:::;ani2xdenotes a sequence over xof lengthn.hiis the
empty sequence. sequences are used to represent paths in a graph and traces
in an event log. 11is the concatenation of two sequences and qis the
projection of onq.6 wil van der aalst
denition 2 (sequence projection). letxbe a set and qxone of its
subsets.q2x!qis a projection function and is dened recursively: (1)
hiq=hiand (2) for 2xandx2x:
(hxi)q=(
q ifx62q
hxiqifx2q
sohy;z;yifx;yg=hy;yi. functions can also be applied to sequences: if dom(f) =
fx;yg, thenf(hy;z;yi) =hf(y);f(y)i.
denition 3 (applying functions to sequences). letf2x6!ybe a
partial function. fcan be applied to sequences of xusing the following recursive
denition (1) f(hi) =hiand (2) for 2xandx2x:
f(hxi) =(
f() ifx62dom(f)
hf(x)if()ifx2dom(f)
summation is dened over multisets and sequences, e.g.,p
x2ha;a;b;a;bif(x) =p
x2[a3;b2]f(x) = 3f(a) + 2f(b).
2.2 petri nets
we use petri nets to formalize our main ideas and to demonstrate their correct-
ness. however, as mentioned in section 1 the results presented in the paper can
be adapted for various other process modeling notations (bpmn models, bpel
specications, uml activity diagrams, statecharts, c-nets, heuristic nets, etc.).
by using petri nets we minimize the notational overhead allowing us the focus
on the key ideas.
denition 4 (petri net). a petri net is a tuple n= (p;t;f )withpthe set
of places,tthe set of transitions, p\t=;, andf(pt)[(tp)the
ow relation.
figure 2 shows a petri net n= (p;t;f ) withp=fstart;c1;:::;c 9;endg,
t=ft1;t2;:::;t 11g, andf=f(start;t1);(t1;c1);(t1;c2);:::; (t11;end)g. the
state of a petri net, called marking , is a multiset of places indicating how many
tokens each place contains. [ start ] is the initial marking shown in figure 2.
another potential marking is [ c110;c25;c45]. this is the state with ten tokens in
c1, ve tokens in c2, and ve tokens in c4.
denition 5 (marking). letn= (p;t;f )be a petri net. a marking mis
a multiset of places, i.e., m2b(p).
a petri net n= (p;t;f ) denes a directed graph with nodes p[tand edges
f. for anyx2p[t,nx=fyj(y;x)2fgdenotes the set of input nodes and
xn=fyj(x;y)2fgdenotes the set of output nodes we drop the superscript
nif it is clear from the context.decomposing petri nets for process mining 7
a
start
a = register request
b = examine file
c = check ticket
d = decide
e = reinitiate request 
f = send acceptance letter
g = pay compensation
h = send rejection letterb
cdg
h
eendc1
c2c3
c4c5t1f
t2
t3
t4t5
t6t7t8
t9
t10t11
c6c7 c8
c9
fig. 2. a labeled petri net.
a transition t2tisenabled in marking mof netn, denoted as ( n;m )[ti,
if each of its input places tcontains at least one token. consider the petri net
nin figure 2 with m= [c3;c4]: (n;m )[t5ibecause both input places of t5 are
marked.
an enabled transition tmay re, i.e., one token is removed from each of the
input placestand one token is produced for each of the output places t. for-
mally:m0= (mnt)]tis the marking resulting from ring enabled transition
tin marking mof petri net n. (n;m )[ti(n;m0) denotes that tis enabled in
mand ringtresults in marking m0. for example, ( n;[start ])[t1i(n;[c1;c2])
and (n;[c3;c4])[t5i(n;[c5]) for the net in figure 2.
let=ht1;t2;:::;tni2tbe a sequence of transitions. ( n;m )[i(n;m0)
denotes that there is a set of markings m0;m1;:::;mnsuch thatm0=m,
mn=m0, and (n;mi)[ti+1i(n;mi+1) for 0i < n . a marking m0isreach-
able frommif there exists a such that ( n;m )[i(n;m0). for example,
(n;[start ])[i(n;[end]) with=ht1;t3;t4;t5;t10ifor the net in figure 2.
denition 6 (labeled petri net). a labeled petri net n= (p;t;f;l )is
a petri net (p;t;f )with labeling function l2t6! uawhereuais some
universe of activity labels. let v=ha1;a2;:::;ani 2 uabe a sequence of
activities. (n;m )[vb(n;m0)if and only if there is a sequence 2tsuch
that(n;m )[i(n;m0)andl() =v(cf. denition 3).
ift62dom(l), it is called invisible. an occurrence of visible transition t2dom(l)
corresponds to observable activity l(t). the petri net in figure 2 is labeled.
the labeling function is dened as follows: dom(l) =ft1;t3;t4;t5;t6;t8;t9;
t10g,l(t1) =a(ais a shorthand for \register request"), l(t3) =b(\examine8 wil van der aalst
le"),l(t4) =c(\check ticket"), l(t5) =d(\decide"), l(t6) =e(\reinitiate re-
quest"),l(t8) =f(\send acceptance letter"), l(t9) =g(\pay compensation"),
andl(t10) =h(\send rejection letter"). unlabeled transitions correspond to
so-called \silent actions", i.e., transitions t2,t7, andt11 are unobservable.
given the petri net nin figure 2: ( n;[start ])[vb(n;[end]) forv=
ha;c;d;f;gibecause (n;[start ])[i(n;[end]) with=ht1;t2;t4;t5;t7;t8;t9;t11i
andl() =v.
in the context of process mining, we always consider processes that start in
an initial state and end in a well-dened end state. for example, given the net
in figure 2 we are interested in so-called complete ring sequences starting in
minit= [start ] and ending in mnal= [end]. therefore, we dene the notion of
asystem net .
denition 7 (system net). a system net is a triplet sn = (n;m init;mnal)
wheren= (p;t;f;l )is a labeled petri net, minit2b(p)is the initial marking,
andmnal2b(p)is the nal marking. usnis the universe of system nets .
denition 8 (system net notations). let sn = (n;m init;mnal)2usn
be a system net with n= (p;t;f;l ).
{tv(sn) =dom(l)is the set of visible transitions in sn ,
{av(sn) =rng(l)is the set of corresponding observable activities in sn ,
{tu
v(sn) =ft2tv(sn)j8t02tv(sn)l(t) =l(t0))t=t0gis the set of
unique visible transitions in sn (i.e., there are no other transitions having
the same visible label), and
{au
v(sn) =fl(t)jt2tu
v(sn)gis the set of corresponding unique observable
activities in sn .
given a system net, (sn) is the set of all possible visible traces, i.e., complete
ring sequences starting in minitand ending in mnalprojected onto the set of
observable activities.
denition 9 (traces). let sn = (n;m init;mnal)2u snbe a system net.
(sn) =fvj(n;m init)[vb(n;m nal)gis the set of visible traces starting
inminitand ending in mnal.f(sn) =fj(n;m init)[i(n;m nal)gis the
corresponding set of complete ring sequences.
for figure 2: (sn) =fha;c;d;f;gi;ha;c;b;d;f;gi;ha;c;d;hi;ha;b;c;d;e;c;d;hi;
:::gandf(sn) =fht1;t2;t4;t5;t7;t8;t9;t11i;ht1;t3;t4;t5;t10i;:::g. because
of the loop involving transition t6 there are innitely many visible traces and
complete ring sequences.
in this paper, we need to compose and decompose process models. therefore,
we dene the union of two system nets.
denition 10 (union of nets). let sn1= (n1;m1
init;m1
nal)2u snwith
n1= (p1;t1;f1;l1)and sn2= (n2;m2
init;m2
nal)2usnwithn2= (p2;t2;
f2;l2)be two system nets.decomposing petri nets for process mining 9
{l32(t1[t2)6!uawith dom (l3) = dom(l1)[dom(l2),l3(t) =l1(t)if
t2dom(l1), andl3(t) =l2(t)ift2dom(l2)ndom(l1)is the union of l1and
l2,
{n1[n2= (p1[p2;t1[t2;f1[f2;l3)is the union of n1andn2, and
{sn1[sn2= (n1[n2;m1
init]m2
init;m1
nal]m2
nal)is the union of system
nets sn1and sn2.
2.3 event log
as indicated earlier, event logs serve as the starting point for process mining. an
event log is a multiset of traces . each trace describes the life-cycle of a particular
case (i.e., a process instance ) in terms of the activities executed.
denition 11 (trace, event log). letauabe a set of activities. a trace
2ais a sequence of activities. l2b(a)is an event log, i.e., a multiset of
traces.
an event log is a multiset of traces because there can be multiple cases having
the same trace. in this simple denition of an event log, an event refers to just an
activity . often event logs store additional information about events. for example,
many process mining techniques use extra information such as the resource (i.e.,
person or device) executing or initiating the activity, the timestamp of the event,
ordata elements recorded with the event (e.g., the size of an order). in this paper,
we abstract from such information. however, the results presented can easily be
extended to event logs containing additional information.
an example log is l1= [ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5].l1
contains information about 20 cases, e.g., 10 cases followed trace ha;c;d;f;gi.
there are 105 + 54 + 59 = 115 events in total.
the projection function x(cf. denition 2) is generalized to event logs,
i.e., for some event log l2b(a) and setxa:lx= [xj2l]. for
example,l1fa;g;hg= [ha;gi15;ha;hi5]. we will refer to these projected event
logs as sublogs .
3 conformance checking
conformance checking techniques investigate how well an event log l2b(a)
and a system net sn= (n;m init;mnal) t together. note that snmay have
been discovered through process mining or may have been made by hand. in any
case, it is interesting to compare the observed example behavior in lwith the
potential behavior of sn.
conformance checking can be done for various reasons. first of all, it may
be used to audit processes to see whether reality conforms to some normative or
descriptive model [6]. deviations may point to fraud, ineciencies, and poorly
designed or outdated procedures. second, conformance checking can be used
to evaluate the performance of a process discovery technique. in fact, genetic10 wil van der aalst
process mining algorithms use conformance checking to select the candidate
models used to create the next generation of models [48].
there are four quality dimensions for comparing model and log: (1) tness ,
(2)simplicity , (3) precision , and (4) generalization [1]. a model with good tness
allows for most of the behavior seen in the event log. a model has a perfect
tness if all traces in the log can be replayed by the model from beginning to
end. the simplest model that can explain the behavior seen in the log is the
best model. this principle is known as occam's razor. fitness and simplicity
alone are not sucient to judge the quality of a discovered process model. for
example, it is very easy to construct an extremely simple petri net (\ower
model") that is able to replay all traces in an event log (but also any other
event log referring to the same set of activities). similarly, it is undesirable to
have a model that only allows for the exact behavior seen in the event log.
remember that the log contains only example behavior and that many traces
that are possible may not have been seen yet. a model is precise if it does not
allow for \too much" behavior. clearly, the \ower model" lacks precision. a
model that is not precise is \undertting". undertting is the problem that the
model over-generalizes the example behavior in the log (i.e., the model allows
for behaviors very dierent from what was seen in the log). at the same time,
the model should generalize and not restrict behavior to just the examples seen
in the log. a model that does not generalize is \overtting". overtting is the
problem that a very specic model is generated whereas it is obvious that the
log only holds example behavior (i.e., the model explains the particular sample
log, but there is a high probability that the model is unable to explain the next
batch of cases).
in the remainder, we will focus on tness. however, the ideas are applicable
to the other quality dimensions [5].
denition 12 (perfectly fitting log). letl2b(a)be an event log with
auaand let sn = (n;m init;mnal)2u snbe a system net. lis perfectly
tting sn if and only if f2lg(sn).
consider two event logs l1= [ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5]
andl2= [ha;c;d;fi10;ha;c;d;c;hi5;ha;b;d;e;c;d;g;f;h i5] and the system net
snof the petri net depicted in figure 2. clearly, l1is perfectly tting sn
whereasl2is not. there are various ways to quantify tness [1, 5, 10, 35, 48, 50,
51, 57].
to measure tness, one needs to align traces in the event log to traces of the
process model. consider the following three alignments for the traces in l1:
1=acdfg
acdfg
t1t4t2t5t7t8t9t112=acdh
acdh
t1t4t2t5t10
3=abcdecdgf
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11decomposing petri nets for process mining 11
the top row of each alignment corresponds to \moves in the log" and the bot-
tom two rows correspond to \moves in the model". moves in the model are
represented by the transition and its label. this is needed because there could
be multiple transitions with the same label. if a move in the model cannot be
mimicked by a move in the log, then a \ " (\no move") appears in the top
row. for example, in the third position of 1the log cannot mimic the invisible
transitiont2. theabovet2 indicates that t262dom(l). in the remainder, we
writel(t) =ift62dom(l). note that all \no moves" (i.e., the seven symbols)
in1 3are \caused" by invisible transitions.
some example alignments for l2and sn:
4=acdf
acdfg
t1t4t2t5t7t8t9t115=acdch
acdh
t1t4t2t5t10
6=abdecdgfh
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
alignment 4shows a \" (\no move") in the top row that does not cor-
respond to an invisible transition. the model makes a gmove (occurrence of
transitiont9) that is not in the log. alignment 6has a similar move in the
third position: the model makes a cmove (occurrence of transition t4) that is
not in the log. if a move in the log cannot be mimicked by a move in the model,
then a \" (\no move") appears in the bottom row. for example, in 5thec
move in the log is not mimicked by a move in the model and in 6thehmove
in the log is not mimicked by a move in the model. note that the \no moves"
not corresponding to invisible transitions point to deviations between model and
log.
amove is a pair (x;(y;t)) where the rst element refers to the log and the
second element refers to the model. for example, ( a;(a;t1)) means that both
log and model make an \ amove" and the move in the model is caused by the
occurrence of transition t1. (;(g;t9)) means that the occurrence of transition
t9 with label gis not mimicked by corresponding move of the log. ( c;) means
that the log makes an \ cmove" not followed by the model.
denition 13 (legal moves). letl2b(a)be an event log and let sn =
(n;m init;mnal)2usnbe a system net with n= (p;t;f;l ).alm=f(x;(x;t))j
x2a^t2t^l(t) =xg[f(;(x;t))jt2t^l(t) =xg[f(x;)jx2ag
is the set of legal moves .
an alignment is a sequence of legal moves such that after removing all sym-
bols, the top row corresponds to a trace in the log and the bottom row cor-
responds to a ring sequence starting in minitand ending mnal. hence, the
middle row corresponds to a visible path when ignoring the steps.
denition 14 (alignment). letl2lbe a log trace and m2f(sn)
a complete ring sequence of system net sn . an alignment oflandmis12 wil van der aalst
a sequence 2almsuch that the projection on the rst element (ignoring
) yieldsland the projection on the last element (ignoring and transition
labels) yields m.
1{3are examples of alignments for the traces in l1and their corresponding r-
ing sequences in the system net of figure 2. 4{6are examples of alignments for
the traces in l2and complete ring sequences of the same system net. the pro-
jection of6on the rst element (ignoring ) yieldsl=ha;b;d;e;c;d;g;f;h i
which is indeed a trace in l2. the projection of 6on the last element (ignor-
ingand transition labels) yields m=ht1;t3;t4;t5;t6;t4;t2;t5;t7;t9;t8;t11i
which is indeed a complete ring sequence. the projection of 6on the middle el-
ement (i.e., transition labels while ignoring and) yieldsha;b;c;d;e;c;d;g;f i
which is indeed a visible trace of the system net of figure 2.
given a log trace and a process model there may be many (if not innitely
many) alignments. consider the following two alignments for ha;c;d;fi2l2:
4=acdf
acdfg
t1t4t2t5t7t8t9t110
4=acdf
acbdh
t1t4t3t5t7t10
4seems to be better alignment than 0
4because it has only one deviation (move
in model only; (;(g;t9))) whereas 0
4has three deviations: ( ;(b;t3)), (f;),
and (;(h;t11)). to select the most appropriate one we associate costs to un-
desirable moves and select an alignment with the lowest total costs. to quantify
the costs of misalignments we introduce a cost function .
denition 15 (cost of alignment). cost function 2alm!i nassigns
costs to legal moves. the cost of an alignment 2almis the sum of all costs:
() =p
(x;y)2(x;y).
moves where log and model agree have no costs, i.e., (x;(x;t)) = 0 for all
x2a. moves in model only have no costs if the transition is invisible, i.e.,
(;(;t)) = 0 ifl(t) =.(;(x;t))>0 is the cost when the model makes
an \xmove" without a corresponding move of the log (assuming l(t) =x6=).
(x;)>0 is the cost for an \ xmove" in just the log. these costs may depend
on the nature of the activity, e.g., skipping a payment may be more severe
than sending too many letters. however, in this paper we often use a standard
cost function sthat assigns unit costs: (x;(x;t)) = 0,(;(;t)) = 0, and
s(;(x;t)) =s(x;) = 1 for all x2a. for example, s(1) =s(2) =
s(3) = 0,s(4) = 1,s(5) = 1, and s(6) = 2 (simply count the number
ofsymbols not corresponding to invisible transitions). now we can compare
the two alignments for ha;c;d;fi2l2:s(4) = 1 ands(0
4) = 3. hence, we
conclude that 4is \better" than 0
4.
denition 16 (optimal alignment). letl2b(a)be an event log with
auaand let sn2usnbe a system net with (sn)6=;.
{forl2l, we dene:  l;sn=f2almj 9m2f(sn)is an
aligment of landmg.decomposing petri nets for process mining 13
{an alignment 2 l;snisoptimal for tracel2land system net sn if
for any02 l;m:(0)().
{sn2a!almis a deterministic mapping that assigns any log trace l
to an optimal alignment, i.e., sn(l)2 l;snandsn(l)is optimal.
{costs (l;sn;) =p
l2l(sn(l))are the misalignment costs of the whole
event log.
1 6is are optimal alignments for the corresponding six possible traces in event
logsl1andl2.0
4is not an optimal alignment for ha;c;d;fi.costs (l1;sn;s) =
10s(1)+5s(2)+5s(3) = 100+50+50 = 0. hence, l1is perfectly
tting system net sn.costs (l2;sn;s) = 10s(4)+5s(5)+5s(6) =
101 + 51 + 52 = 25.
it is possible to convert misalignment costs into a tness value between 0
(poor tness, i.e., maximal costs) and 1 (perfect tness, zero costs). we refer to
[5, 10] for details. misalignment costs can be related to denition 12, because
only perfectly tting traces have costs 0 (assuming (sn)6=;).
lemma 1 (perfectly fitting log). event loglis perfectly tting system net
sn if and only if costs (l;sn;) = 0 .
once an optimal alignment has been established for every trace in the event
log, these alignments can also be used as a basis to quantify other conformance
notations such as precision and generalization [5]. for example, precision can
be computed by counting \escaping edges" as shown in [50, 51]. recent results
show that such computations should be based on alignments [12]. the same
holds for generalization [5]. therefore, we focus on alignments when decomposing
conformance checking tasks.
4 decomposing conformance checking
conformance checking can be time consuming as potentially many dierent
traces need to be aligned with a model that may allow for an exponential (or
even innite) number of traces. event logs may contain millions of events. find-
ing the best alignment may require solving many optimization problems [10] or
repeated state-space explorations [57]. in worst case a state-space exploration of
the model is needed per event. when using genetic process mining, one needs to
check the tness of every individual model in every generation [48]. as a result,
thousands or even millions of conformance checks need to be done. for each
conformance check, the whole event log needs to be traversed. given these chal-
lenges, we are interested in reducing the time needed for conformance checking
by decomposing the associated petri net and event log. in this section, we show
that it is possible to decompose conformance checking problems.
to decompose conformance checking problems we split a process model into
model fragments. in terms of petri nets: the overall system net snis decomposed
into a collection of subnets fsn1;sn2;:::; snngsuch that the union of these
subnets yields the original system net. a decomposition is valid if the subnets14 wil van der aalst
\agree" on the original labeling function (i.e., the same transition always has
the same label), each place resides in just one subnet, and also each invisible
transition resides in just one subnet. moreover, if there are multiple transitions
with the same label, they should reside in the same subnet. only unique visible
transitions (i.e., tu
v(sn), cf. denition 8) can be shared among dierent subnets.
denition 17 (valid decomposition). let sn2usnbe a system net with
labeling function l.d=fsn1;sn2;:::; snngu snis a valid decomposition
if and only if
{sni= (ni;mi
init;mi
nal)is a system net with ni= (pi;ti;fi;li)for all
1in,
{li=ltifor all 1in,
{pi\pj=;for1i<jn,
{ti\tjtu
v(sn)and rng (li)\rng(lj)au
v(sn)for1i<jn, and
{sn=s
1insni.
d(sn)is the set of all valid decompositions of sn .
letsn= (n;m init;mnal) withn= (p;t;f;l ) be a system net with valid de-
composition d=fsn1;sn2;:::; snng2d (sn). we can observe the following
properties:
{each place appears in precisely one of the subnets, i.e., for any p2p:
jf1injp2pigj= 1,
{each invisible transition appears in precisely one of the subnets, i.e., for any
t2tntv(sn):jf1injt2tigj= 1,
{visible transitions that do not have a unique label (i.e., there are multiple
transitions with the same label) appear in precisely one of the subnets, i.e.,
for anyt2tv(sn)ntu
v(sn):jf1injt2tigj= 1,
{visible transitions having a unique label may appear in multiple subnets, i.e.,
for anyt2tu
v(sn):jf1injt2tigj 1, and
{each edge appears in precisely one of the subnets, i.e., for any ( x;y)2f:
jf1inj(x;y)2figj= 1.
every system net has a trivial decomposition consisting of only one subnet, i.e.,
fsng2d (sn). however, we are interested in a maximal decomposition where
the individual subnets are as small as possible. figure 3 shows the maximal
decomposition for the system net shown in figure 2.
in the remainder, we assume that there are no isolated nodes in the original
system net. hence, for all sn= (n;m init;mnal)2usnwithn= (p;t;f;l ),
we assume that !(f) =p[t. this is not a restriction: isolated places do not
inuence the behavior and can be removed, and for any transition twithout
input and output places we can add an initially marked self-loop place pt. the
self-loop place ptdoes not restrict the behavior of t. by removing isolated nodes,
we can simplify the construction of the maximal decomposition which is based
on partitioning the edges in the original system net.
denition 18 (maximal decomposition). let sn2usnbe a system net.
the maximal decomposition dmax(sn)is computed as follows:
{for any (x;y)2f:[ [(x;y)] ]fis the smallest set such thatdecomposing petri nets for process mining 15
a
startt1sn1
a
c
ec2t1
t4
t6sn3ab
d
ec1 c3
t1t2
t3
t5
t6sn2
dg
h
ec5f
t5
t6t7t8
t9
t10c6c7sn5
cd
c4
t4t5sn4g
hendf
t8
t9
t10t11c8
c9
sn6
fig. 3. maximal decomposition of the system net shown in figure 2 with minit= [start ]
andmnal= [end]. the initial and nal markings are as follows: m1
init= [start ] and
mi
init= [ ] for 2i6,mi
nal= [ ] for 1i5, andm6
nal= [end].
(x;y)2[ [(x;y)] ], and
(x0;y0)2[ [(x;y)] ]if(x0;y0)2fandfx0;y0g\(!([ [(x;y)] ])ntv(sn))6=;.
{for anyxf:lx=fl(t)jt2!(x)\tv(sn)g.
{for any (x;y)2f:hh(x;y)iifis the smallest set such that
[ [(x;y)] ]hh(x;y)ii, and
[ [(x0;y0)] ]hh(x;y)iiif(x0;y0)2fand(l[ [(x0;y0)] ]\lhh(x;y)ii)6au
v(sn).
{p(x;y)=!(hh(x;y)ii)\pare the places of the subnet dened by edges hh(x;y)ii.
{t(x;y)=!(hh(x;y)ii)\tare the transitions of the subnet dened by edges
hh(x;y)ii.
{dmax(sn) =f((p(x;y);t(x;y);hh(x;y)ii;lt(x;y));minitp(x;y);mnalp(x;y))j
(x;y)2fgis the maximal decomposition of sn .
the construction of the maximal decomposition is based on partitioning the
edges. each edge will end up in precisely one subnet. [ [( x;y)] ] are all edges that
are \connected" to ( x;y) via an undirected path involving places and invisi-
ble transitions. consider for example [ [( t1;c2)] ] =f(t1;c2);(c2;t4);(t6;c2)gin
figure 2. (c2;t4) and (t6;c2) are added to [ [( t1;c2)] ] because c2 is not a visible
transition. ( t6;c1) and (c5;t6) are not added to [ [( t1;c2)] ] because t6 is a visible
transition. after partitioning the edges into sets of connected edges, the sets
that share non-unique observable activities are merged. in figure 2 all visible
transitions have a unique label, hence hh(x;y)ii= [ [(x;y)] ] for all edges ( x;y)2f.
based on the new partitioning of the edges, subnets are created. consider for
examplehh(t1;c2)ii=f(t1;c2);(c2;t4);(t6;c2)g, the corresponding subnet sn3
is shown in figure 3. the six subnets sn1;sn2;:::sn6in figure 3 form the
maximal decomposition of the system net in figure 2.
to illustrate the dierence between [ [( x;y)] ] andhh(x;y)iilet us consider the
system net in figure 2 where t4 is relabeled from ctob, i.e., there are two16 wil van der aalst
a
b
ec2t1
t4
t6ab
d
ec1 c3
t1t2
t3
t5
t6
bd
c4
t4t5sn7
ab
bd
ec1
c2c3
c4t1t2
t3
t4t5
t6
fig. 4. sincebis a non-unique visible activity (transitions t3 andt4 have label b), three
subnets need to be merged.
visible transitions having the same label: l(t3) =l(t4) =b. let us call this
modied system net snmod. note that tv(snmod) =tv(sn) andtu
v(snmod) =
tv(sn)nft3;t4g, i.e., transitions t3 andt4 are still labeled but no longer unique.
nowhh(t1;c1)ii= [ [(t1;c1)] ][[ [(t1;c2)] ][[ [(t4;c4)] ]. in other words sn2,sn3and
sn4need to be merged into sn7as shown in figure 4. hence, the maximal
decomposition of the modied system net snmodconsists of four rather than
six subnets: dmax(snmod) =fsn1;sn7;sn5;sn6g.
a straightforward algorithm to construct a maximal decomposition is quadratic
in the number of edges. hence, the complexity of partitioning is negligible to the
complexity of the process mining problems that are being decomposed. recall
that most algorithms are linear in the size of the event log and exponential in
the number of unique activities. a maximal decomposition is valid as is demon-
strated next. however, please bear in mind that various valid decompositions
can be used as the main results of the paper do not depend on particular de-
composition technique.
theorem 1 (maximal decomposition is valid). let sn2usnbe a system
net.dmax(sn)is a valid decomposition, i.e., dmax(sn)2d(sn).
proof. letdmax(sn) =fsn1;sn2;:::; snng. clearly, all subnets sniare
system nets that agree on a common labeling function: li=ltifor all 1
in. every edge ( x;y) in snis in precisely one subnet because of the way
[ [(x;y)] ] andhh(x;y)iiare constructed. moreover, we assumed that there are no
isolated nodes (can be removed through preprocessing). therefore, also all nodes
(places and transitions) and edges are included in at least one subnet. hence,
sn=s
1insni. remains to show that pi\pj=;andti\tjtu
v(sn)
for 1i<jn. the construction of [ [( x;y)] ] ensures that places and the edges
connecting places end up in the same unique subnet. if p2p,p2!([ [(x;y)] ])
andp2!([ [(x0;y0)] ]), then [ [( x;y)] ] = [ [(x0;y0)] ]. the same holds for invisibledecomposing petri nets for process mining 17
transitions. transitions having a visible label that is not unique need to end
up in the same subnet. this is ensured by the construction of hh(x;y)iiwhich
merges subnets having shared visible transitions that are not unique. hence,
ti\tjtu
v(sn) ifi6=j. u t
after showing that we can decompose a system net into smaller subnets, we show
that conformance checking can be done by locally inspecting the subnets using
correspondingly projected event logs. to illustrate this, consider the following
alignment for trace ha;b;c;d;e;c;d;g;f iand the system net in figure 2:
3=123456789101112
abcdecdgf
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
for convenience, the moves have been numbered. now consider the following six
alignments:
1
3=1
a
a
t12
3=124578
abded
abded
t1t3t5t6t2t53
3=1356
acec
acec
t1t4t6t4
4
3=3468
cdcd
cdcd
t4t5t4t55
3=45891011
dedgf
dedgf
t5t6t5t7t9t86
3=101112
gf
gf
t9t8t11
each alignment corresponds to one of the six subnets sn1;sn2;:::sn6in fig-
ure 3. the numbers are used to relate the dierent alignments. for example 6
3
is an alignment for trace ha;b;c;d;e;c;d;g;f iand subnets sn6in figure 3. as
the numbers 10, 11 and 12 indicate, 6
3corresponds to the last three moves of
3.
to create sublogs for the dierent model fragments, we use the projec-
tion function introduced before. consider for example the overall log l1=
[ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5].l1
1=l1fag= [hai20],l2
1=
l1fa;b;d;eg= [ha;di15;ha;b;d;e;di5],l3
1=l1fa;c;eg= [ha;ci15;ha;c;e;ci5], etc.
are the sublogs corresponding to the subnets in figure 3.
the following theorem shows that any trace that ts the overall process model
can be decomposed into smaller traces that t the individual model fragments.
moreover, if the smaller traces t the individual model fragments, then they can
be composed into an overall trace that ts into the overall process model. this
result is the basis for decomposing process mining problems.
theorem 2 (conformance checking can be decomposed). letl2
b(a)be an event log with auaand let sn2u snbe a system net with
av(sn) =a. for any valid decomposition d=fsn1;sn2;:::; snng2d (sn):
lis perfectly tting system net sn if and only if for all 1in:lav(sni)is
perfectly tting sni.18 wil van der aalst
proof. let sn= (n;m init;mnal) be a system net with n= (p;t;f;l ).
letd=fsn1;sn2;:::; snngbe a valid decomposition of snwith sni=
(ni;mi
init;mi
nal),ni= (pi;ti;fi;li), andai=av(sni) for alli.
()) letv2lbe such that there is a 2twith (n;m init)[i(n;m nal) and
l() =v(i.e.,vts into the overall system net). for all 1 in, we need to
prove that there is a iwith (ni;mi
init)[ii(ni;mi
nal) such that l(i) =vai.
this follows trivially because snican mimic any move of snwith respect to
transitions ti: just takei=ti.
(() letv2lbe such that for each 1 inthere is aiwith (ni;mi
init)
[ii(ni;mi
nal) andl(i) =vai. we need to prove that there is a 2tsuch
that (n;m init)[i(n;m nal) andl() =v. the dierent isequences can be
stitched together into an overall because the dierent subnets only interface
viaunique visible transitions and sn=s
1insni. transitions in one subnet
can only inuence other subnets through unique visible transitions and these
can only move synchronously as dened by v2l. u t
theorem 2 shows that any trace in the log ts the overall model if and only if
it ts each of the subnets.
let us consider an example where not all visible transitions are unique. let
snmodbe again the modied system net obtained by relabeling t4 fromctob
in figure 2. 0
3is an alignment for trace ha;b;b;d;e;b;d;g;f iandsnmodand7
3
is the corresponding alignment for sn7shown in figure 4.
0
3=123456789101112
abbdebdgf
abbdebdgf
t1t3t4t5t6t4t2t5t7t9t8t117
3=12345678
abbdebd
abbdebd
t1t3t4t5t6t4t2t5
because0
3is an alignment with costs 0, the decomposition of 0
3into1
3,
5
3,6
3, and7
3yields four alignments with costs 0 for the four subnets in
dmax(snmod) =fsn1;sn5;sn6;sn7g. moreover, 1
3,5
3,6
3, and7
3can be
stitched back into 0
3provided that the four alignments are perfectly tting their
part of the overall model.
let us now consider trace ha;b;d;e;c;d;g;f;h iwhich is not perfectly tting
the system net in figure 2. an optimal alignment is:
6=12345678910111213
abdecdgfh
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
the alignment shows the two problems: the model needs to execute cwhereas
this event is not in the event log (position 3) and the event log contains g,f,
andhwhereas the model needs to choose between either gandforh(position
13). the cost of this optimal alignment is 2. optimal alignment 6for the overalldecomposing petri nets for process mining 19
model can be decomposed into alignments 1
6 6
6for the six subnets:
1
6=1
a
a
t12
6=124578
abded
abded
t1t3t5t6t2t53
6=1356
aec
acec
t1t4t6t4
4
6=3468
dcd
cdcd
t4t5t4t55
6=4589101113
dedgfh
dedgf
t5t6t5t7t9t86
6=10111213
gfh
gf
t9t8t11
alignments 1
6and2
6have costs 0. alignments 3
6and4
6have costs 1 (move in
model involving c). alignments 5
6and6
6have costs 1 (move in log involving h).
if we would add up all costs, we would get costs 4 whereas the costs of optimal
alignment6is 2. however, we would like to compute an upper bound for the
degree of tness in a distributed manner. therefore, we introduce an adapted
cost function q.
denition 19 (adapted cost function). letd=fsn1;sn2;:::; snng2
d(sn)be a valid decomposition of some system net sn and 2alm!i n
a cost function (cf. denition 15). cq(a;(a;t)) =cq(;(a;t)) =cq(a;) =
jf1inja2aigjcounts the number of subnets having aas an observable
activity. the adapted cost function qis dened as follows: q(x;y) =(x;y)
cq(x;y)
for(x;y)2almandcq(x;y)6= 0.
an observable activity may appear in multiple subnets. therefore, we divide its
costs by the number of subnets in which it appears: q(x;y) =(x;y)
cq(x;y). this way
we avoid counting misalignments of the same activity multiple times. for our
example,cq(;(c;t4)) =jf3;4gj= 2 andcq(h;) =jf5;6gj= 2. assuming
the standard cost function sthis implies q(;(c;t4)) =1
2andq(h;) =1
2.
hence the aggregated costs of 1
6 6
6is 2, i.e., identical to the costs of the overall
optimal alignment.
theorem 3 (lower bound for misalignment costs). letl2b(a)be
an event log with aua, sn2u snbe a system net, and a cost function.
for any valid decomposition d=fsn1;sn2;:::; snng2d (sn):
costs (l;sn;)x
1incosts (lav(sni);sni;q)
proof. for anyv2lthere is an optimal alignment ofvand snsuch that
the projection on the last element yields a 2twith (n;m init)[i(n;m nal)
andl() =v. as shown in the proof of theorem 2 there is a iwith (ni;mi
init)
[ii(ni;mi
nal) such that l(i) =vaifor any 1in. in a similar fashion, 
can be decomposed in 1;2;:::;nwhereiis an alignment of iandsni. the
sum of the costs associated with these local alignments 1;2;:::;nis exactly20 wil van der aalst
the same as the overal alignment . however, there may be local improvements
lowering the sum of the costs associated with these local alignments. hence,
costs (l;sn;)p
1incosts (lav(sni);sni;q). u t
the sum of the costs associated to all selected optimal local alignments (using
q) can never exceed the cost of an optimal overall alignment using . hence,
it can be used as an optimistic estimate, i.e., computing an upper bound for
the overall tness and a lower bound for the overall costs. more important,
the tness values of the dierent subnets provide valuable local diagnostics.
the subnets with the highest costs are the most problematic parts of the model.
the alignments for these \problem spots" help to understand the main problems
without having to look at very long overall alignments.
theorem 3 uses a rather sophisticated denition of tness. we can also simply
count the fraction of tting traces . in this case the problem can be decomposed
easily using the notion of valid decomposition.
theorem 4 (fraction of perfectly fitting traces). letl2 b(a)be
an event log with auaand let sn2u snbe a system net. for any valid
decomposition d=fsn1;sn2;:::; snng2d (sn):
j[2lj2(sn)]j
jlj=j[2lj81inav(sni)2(sni)]j
jlj
proof. follows from the construction used in theorem 2. a trace is tting the
overall model if and only if it ts all subnets. u t
as theorem 4 suggests, traces in the event log can be marked as tting or non-
tting per subnet . these results can be merged easily and used to compute the
fraction of traces tting the overall model . note that theorem 4 holds for any
decomposition of sn, including the maximal decomposition dmax(sn).
although the results presented only address the notion of tness, it should
be noted that alignments are the starting point for many other types of anal-
ysis. for example, precision can be computed by counting so-called \escaping
edges" (sequences of steps allowed by the model but never happening in the
event log) [50, 51]. this can be done at the level of subnets even though there is
not a straightforward manner to compute the overall precision level. note that
relatively many escaping edges in a subnet suggest \undertting" of that part of
model. as shown in [12], alignments should be the basis for precision analysis.
therefore, the construction used in theorems 2 and 3 can be used as a basis for
computing precision. a similar approach can be used for generalization: many
unique paths in a subnet may indicate \overtting" of that part of the model
[5].
the alignments can be used beyond conformance checking. an alignment i
(see proof of theorem 3) relates observed events to occurrences of transitions
in multiple subnets. if the event log contains timestamps , such alignments can
be used to compute times in-between transition occurrences (waiting times, re-
sponse times, service times, etc.) as shown in [1]. this way bottlenecks can bedecomposing petri nets for process mining 21
identied. if the event log contains additional data (e.g., size of order, age of
patient, or type of customer), then these local alignments can be used for deci-
sion mining [56]. for any decision point in a subnet (place with multiple output
edges), one can create a decision tree based on the data available prior to the
choice. note that bottleneck analysis and decision point analysis provide local
diagnostics and can be added to the overall model without any problems. more-
over, note that in our decomposition approach a place is always in precisely one
subnet (together with its surrounding transitions). this allows us to analyze
these aspects locally.
assuming a process model having a decomposition consisting of many sub-
nets, the time needed for conformance checking can be reduced signicantly . there
are two reasons for this. first of all, as our theorems show, larger problems can
be decomposed into sets of independent smaller problems. therefore, confor-
mance checking can be distributed over multiple computers. second, due to the
exponential nature of most conformance checking techniques, the time needed
to solve \many smaller problems" is less than the time needed to solve \one big
problem". existing conformance checking approaches use state-space analysis
(e.g., in [57] the shortest path enabling a transition is computed) or optimiza-
tion over all possible alignments (e.g., in [10] the aalgorithm is used to nd
the best alignment). these techniques do notscale linearly in the number of
activities. therefore, decomposition is useful even if the checks per subnet are
done on a single computer. moreover, decomposing conformance checking is not
just interesting from a performance point of view: decompositions can also be
used to pinpoint the most problematic parts of the process (also in terms of
performance) and provide localized diagnostics.
5 decomposing process discovery
process discovery, i.e., discovering a process model from event data, is highly
related to conformance checking. this can be observed when considering genetic
process mining algorithms that basically \guess" models and recombine parts
of models that have good tness to discover even better models [48, 20]. the
tness computation in genetic process mining is in essence a conformance check.
genetic process mining algorithms can be decomposed in various ways [3, 19].
however, in this paper we only consider the kind of decomposition described
in the previous section. moreover, we describe an approach that is not tailored
towards a particular discovery algorithm. we aim to distribute any process dis-
covery algorithm by (1) decomposing the overall event log into smaller sublogs,
(2) discovering a model fragment for each sublog, and (3) merging the discovered
models into one overall process model.
since we focus on decomposing existing process discovery algorithms and do
not propose a new algorithm, we use the following abstract denition of a process
mining algorithm.
denition 20 (discovery algorithm). a discovery algorithm is a function
disc2b(u
a)!u snthat maps any event log l2b(a)withauaonto22 wil van der aalst
system net sn with av(sn) =fa2j2lgand an injective labeling function
l(i.e.,tv(sn) =tu
v(sn)).
in section 7 we discuss related work and mention some of the many available pro-
cess discovery algorithms [8, 9, 14, 16, 23, 24, 27, 35, 48, 59, 63, 64]. we assume the
result to be presented as a system net. this implies that for algorithms not based
on petri nets an extra conversion step is needed. however, as mentioned before,
our approach is not specic for petri nets. we require that the labeling function
of the generated system net is injective. hence, the discovered system net cannot
have duplicate activities, i.e., multiple transitions referring to the same activity.
we make this assumption because it is not possible to compose model fragments
with overlapping activities corresponding to dierent transitions: overlapping ac-
tivities should be unique (cf. denition 17) otherwise theorem 2 does not hold.
note that very few process discovery algorithms allow for duplicate activities
[39, 47]. therefore, this is a reasonable assumption. however, it is possible that
the system net has many silent transitions, i.e., transitions tsuch thatl(t) =.
in principle, theorem 2 also allows for duplicate activities within one fragment,
but for simplicity we do not consider this case here. an example of a discovery
algorithm is the algorithm [9] which we will refer to as disc().
given an event log lcontaining events referring to a set of activities a, we de-
compose discovery by distributing the activities over multiple sets a1;a2;:::;an.
the same activity may appear in multiple sets as long as a=a1[a2[:::[an.
for each activity set ai, we discover a system net sniby applying a discovery
algorithm to sublog lai, i.e., the overall event log projected onto a subset of
activities. subsequently, the discovered system nets are massaged to avoid name
clashes and to make sure that transitions with a visible label are merged prop-
erly. by combining the resulting system nets we obtain an overall system net
sn=sn1[sn2[:::[snndescribing the behavior in the overall event log l.
denition 21 (decomposing discovery). letl2b(a)be an event log
witha=fa2j2lg  ua. for any collection of activity sets c=
fa1;a2;:::;angsuch thata=scand discovery algorithm disc 2b(u
a)!
usn, we dene:
{sni=disc(lai)for1in, i.e., a subnet is discovered per sublog,
{for all 1in: system net sniis identical to system net sniafter
renaming places and transitions to avoid name clashes. concretely, place
p2piis renamed to pi, transition t2tintv(sn)is renamed to ti, and
transitiont2tv(sn)is renamed to l(t).
{distr disc(l;c;disc) =fsn1;sn2;:::; snng.
to illustrate the idea consider the following event log:
lo= [ha;b;c;d;hi30;
ha;c;b;d;e;b;c;d;j;g;f;k i28;
ha;c;b;d;e;c;b;d;h i28;ha;c;b;d;e;c;b;d;j;f;g;k i27;
ha;b;c;d;e;c;i;d;j;g;f;k i26;
ha;b;c;d;e;i;c;d;h i26;decomposing petri nets for process mining 23
ha;i;c;d;e;c;b;d;j;g;f;k i25;
ha;i;c;d;j;f;g;ki24;
ha;c;b;d;e;b;c;d;h i24;
ha;b;c;d;e;b;c;d;j;g;f;k i24;
ha;c;b;d;e;c;i;d;h i22;
ha;b;c;d;e;c;i;d;h i22;
ha;c;i;d;j;f;g;ki21;
ha;c;i;d;j;g;f;ki20;
ha;c;i;d;e;b;c;d;h i18;
ha;c;i;d;e;c;i;d;h i17;
ha;i;c;d;hi17;
ha;c;b;d;j;g;f;ki17;
ha;c;b;d;hi15;
ha;i;c;d;e;i;c;d;j;f;g;k i14;
ha;c;i;d;e;c;b;d;h i14;
ha;c;i;d;e;c;b;d;j;f;g;k i12;
ha;b;c;d;e;i;c;d;j;f;g;k i12;
ha;b;c;d;e;c;b;d;h i11;
ha;c;b;d;j;f;g;ki10;
ha;i;c;d;j;g;f;ki9;
ha;i;c;d;e;b;c;d;h i9;
ha;i;c;d;e;c;b;d;h i9;
ha;i;c;d;e;c;b;d;j;f;g;k i8;
ha;c;b;d;e;b;c;d;j;f;g;k i8;
ha;b;c;d;e;b;c;d;h i7;
ha;c;b;d;e;i;c;d;j;g;f;k i7;
ha;i;c;d;e;c;i;d;j;g;f;k i6;
ha;c;i;d;hi6;ha;c;b;d;e;i;c;d;h i6;
ha;i;c;d;e;b;c;d;j;g;f;k i6;
ha;b;c;d;j;f;g;ki5;
ha;i;c;d;e;i;c;d;h i5;
ha;i;c;d;e;c;i;d;h i4;
ha;c;i;d;e;i;c;d;h i4;
ha;b;c;d;e;c;i;d;j;f;g;k i4;
ha;b;c;d;e;c;b;d;j;g;f;k i4;
ha;b;c;d;j;g;f;ki3;
ha;c;i;d;e;b;c;d;j;f;g;k i3;
ha;b;c;d;e;b;c;d;j;f;g;k i3;
ha;i;c;d;e;b;c;d;j;f;g;k i3;
ha;b;c;d;e;c;b;d;j;f;g;k i3;
ha;c;i;d;e;i;c;d;j;f;g;k i2;
ha;c;i;d;e;i;c;d;e;b;c;d;e;b;c;d;j;g;
f;ki2;
ha;b;c;d;e;i;c;d;j;g;f;k i2;
ha;c;b;d;e;c;i;d;j;g;f;k i2;
ha;c;i;d;e;c;i;d;j;f;g;k i2;
ha;c;b;d;e;b;c;d;e;c;b;d;j;g;f;k i2;
ha;c;i;d;e;c;b;d;j;g;f;k i2;
ha;c;b;d;e;i;c;d;j;f;g;k i2;
ha;c;i;d;e;i;c;d;e;i;c;d;j;g;f;k i1;
ha;c;b;d;e;c;i;d;j;f;g;k i1;
ha;i;c;d;e;c;i;d;e;c;i;d;e;i;c;d;e;i;
c;d;j;g;f;ki1;
ha;i;c;d;e;c;i;d;j;f;g;k i1;
ha;c;i;d;e;c;i;d;j;g;f;k i1].
event logloconsists of traces that originate from a process similar to fig-
ure 2, but with the three invisible transitions ( t2,t7, andt11) made visible. the
corresponding new activities are i,j, andk. since we are interested in process
discovery, we assume we do not know this and try to rediscover the original
process model by analyzing event log lo. note that a=fa2j2log=
fa;b;c;d;e;f;g;h;i;j;k g.
let us decompose ainto four subsets: a1=fa;b;d;e;ig,a2=fa;c;d;eg,
a3=fd;e;h;jg, anda4=ff;g;h;j;kg. these sets are deliberately partly
overlapping and each set contains causally related activities. as discussed later,
there are dierent strategies to decompose a, but for the moment we assume
these subsets to be given. we would like to apply the algorithm to the corre-
sponding four sublogs because it is well-known, simple, and deterministic. how-
ever, thealgorithm cannot deal with the situation where initial and nal
activities also appear in the middle of the event log. for example, consider the
second trace in loprojected onto a2:ha;c;d;e;c;di. in this trace dappears
in the middle and at the end and the algorithm would produce nonsense.
therefore, we extend each trace in the event log with an articial initial event24 wil van der aalst
>and an articial nal event ?. the resulting log is: l0
o= [h>ih?i j
2lo] = [h>;a;b;c;d;h;?i30;h>;a;c;b;d;e;b;c;d;j;g;f;k; ?i28;h>;a;c;b;d;
e;c;b;d;h;?i28;h>;a;c;b;d;e;c;b;d;j;f;g;k; ?i27;h>;a;b;c;d;e;c;i;d;j;g;f;k;
?i26;:::]. the adapted four activity sets are a1=f>;a;b;d;e;i;?g,a2=
f>;a;c;d;e;?g,a3=f>;d;e;h;j;?g, anda4=f>;f;g;h;j;k;?g. each sublog
is extended with these articial events: l1=l0
of>;a;b;d;e;i;?g,l2=l0
of>;a;c;d;e;?g,
l3=l0
of>;d;e;h;j;?g, andl4=l0
of>;f;g;h;j;k;?g.
after creating the four sublogs l1,l2,l3, andl4we can discover the four
corresponding system nets. the four process models in figure 5 were constructed
by applying the algorithm to the four sublogs. we used the extended version
of thealgorithm as implemented in prom , i.e., unlike the classical eight-line
algorithm [9], loops of length 2 are handled properly. actually, the models shown
in figure 5 were generated using prom . in the diagrams we deliberately do not
show place and transition names as these are renamed anyway. the places are
shaded using a particular pattern to be able to trace their origin when merging
the four fragments (cf. figure 6). note that the addition of the articial events
had the desired eect: each subnet starts with a transition labeled >and ends
with a transition labeled ?. note that l1is perfectly tting sn1,l2is perfectly
tting sn2, etc.
composing the four fragments shown in figure 5 results in the overall system
net shown in figure 6. at a rst glance this model may seem overly complicated.
there are four initially marked source places ( p1,p2,p3, andp4), four sink places
(p22,p23,p24, andp25), and many other redundant places. consider for example
p6 which contains a token if and only if p5 contains a token while having identical
connections. hence, p6 can be removed while keeping p5. alsop2,p3, andp4
can be removed while keeping p1. etc. these simplications do not change the
behavior.
in general a place is redundant (also called \implicit") if its removal does
not change the behavior. a place is structurally redundant [17] if this can be
decided on the structure of the net. by removing structurally redundant places
and the articially inserted >and?transitions, we obtain the system net shown
in figure 7. this model adequately captures the behavior seen in the original
event logl. in fact,lois perfectly tting the overall system shown in figure 7.
this illustrates that discovery can indeed be decomposed into smaller problems.
the quality of the system net obtained by merging the process models dis-
covered for the sublogs highly depends on the way the activities are decomposed
and the characteristics of the discovery algorithm disc(). however, as the follow-
ing theorem shows, the system nets discovered for the sublogs are always a valid
decomposition of the overall model.
theorem 5 (discovery can be decomposed). letl2b(a)be an event
log witha=fa2j2lgua,c=fa1;a2;:::;angwitha=sc,
and disc2b(u
a)!u sna discovery algorithm. let distr disc(l;c;disc) =
fsn1;sn2;:::; snngand sn =s
1insni. sn2usnandfsn1;sn2;:::;
snngis a valid decomposition of sn , i.e., distr disc(l;c;disc)2d(sn).decomposing petri nets for process mining 25
ai
b
ed
start end
a c
ed
start end
dj
h
estart end
j
start end gf
ksn1
sn2
sn3
sn4
h
fig. 5. system nets sn1=disc(l1),sn2=disc(l2),sn3=disc(l3), and
sn4=disc(l4) discovered for respectively l1= [h>;a;b;d;?i30;h>;a;b;d;e;b;d;
?i28;h>;a;b;d;e;b;d;?i28;h>;a;b;d;e;b;d;?i27;h>;a;b;d;e;i;d;?i26;:::],l2= [h>;
a;c;d;?i30;h>;a;c;d;e;c;d;?i28;h>;a;c;d;e;c;d;?i28;h>;a;c;d;e;c;d;?i27;h>;a;c;
d;e;c;d;?i26;:::],l3= [h>;d;h;?i30;h>;d;e;d;j;?i28;h>;d;e;d;h;?i28;h>;d;e;d;
j;?i27;h>;d;e;d;j;?i26;:::], andl4= [h>;h;?i30;h>;j;g;f;k;?i28;h>;h;?i28;h>;
j;f;g;k;?i27;h>;j;g;f;k;?i26;:::] using the algorithm. each net corresponds to
a fragment of the overall process model and mi
init= [start ] andmi
nal= [end] for
i2f1;2;3;4g.26 wil van der aalst
ai
b
cdg
h
ej f
k
t1 t2t3
t4
t5t6
t7
t8t9
t10
t11t12
t13p5p1
p2
p3
p4p6{1,2,3,4}{1,2}{1}
{1}
{2}{1,2,3}
{1,2,3}p7
p8p9
p10
p11
p12{3,4}
{3,4}p13
p14
p15
p16
p17p18
p19
p20p21p22
p23
p24
p25{4}
{4} {4}
{1,2,3,4}
fig. 6. the system net sn=s
1i4sniwithminit= [p1;p2;p3;p4] andmi
nal=
[p22;p23;p24;p25]. sncontains many redundant places but these can be removed
easily.
a
starti
b
cd g
h
eendjf
k
fig. 7. the discovered system net snobtained after removing redundant places and
the articially inserted >and?transitions. ( minit= [start ] andmnal= [end].) event
loglois perfectly tting sn.
proof. we need to show that sni= (ni;mi
init;mi
nal) is a system net with
ni= (pi;ti;fi;li) andli=ltifor all 1in,pi\pj=;andti\tj
tu
v(sn) for 1i < jn, and sn=s
1insni. these properties follow
directly from the denition of distr disc(l;c;disc) and the fact that each subnet
has an injective labeling function li. u t
the construction described in denition 21 yields a net snwith valid de-
composition distr disc(l;c;disc) =fsn1;sn2;:::; snng. this implies that we
can apply theorem 2 (conformance checking can be decomposed), theorem 3
(lower bound for misalignment costs), and theorem 4 (fraction of perfectly
fitting traces).
corollary 1. letl2b(a)be an event log with a=fa2j2lg,c=
fa1;a2;:::;angwitha=sc, and disc2b(u
a)!u sna discovery algorithm.
let distr disc(l;c;disc) =fsn1;sn2;:::; snngand sn =s
1insni.
{lis perfectly tting system net sn if and only if for all 1in:lav(sni)
is perfectly tting sni,decomposing petri nets for process mining 27
{costs (l;sn;)p
1incosts (lav(sni);sni;q)for any cost function ,
and
{j[2lj2(sn)]j
jlj=j[2lj81inav(sni)2(sni)]j
jlj.
as the corollary points out: if the discovery algorithm disc() is able to create a
perfectly tting model for each sublog, then the overall model is also perfectly
tting. moreover, if the discovery algorithm has problems nding a perfectly
tting model for a particular sublog, then the overall model will also exhibit
these problems. for example, the fraction of traces tting the overall model
equals the fraction of traces tting all individual models.
as indicated before, the quality of the resulting overall model heavily depends
on the discovery algorithm used to discover a model for every sublog. in section 3
we elaborated on the four quality dimensions for comparing model and log:
(1) tness, (2) simplicity, (3) precision, and (4) generalization [1]. if disc() has
problems dealing with noisy or incomplete event logs and produces system nets
that are unable to replay large parts of the event log, then the overall model
will suer from similar problems. an event log is noisy if it contains exceptional
and very rare behavior. an event log is incomplete if only a fraction of the
possible behavior has been observed. if the discovery algorithm disc() tends
to produce overtting, undertting, or overly complex models for the sublogs,
then the overall model will most likely also be overtting, undertting, or overly
complex. recall that the aim of this paper is to provide a generic approach
to decompose process mining problems, and not to address the limitations of
specic discovery algorithms described in literature [8, 9, 14, 16, 23, 24, 27, 35, 48,
59, 63, 64].
the quality of the resulting overall model also heavily depends on the way
the set of activities ais decomposed into activity sets c=fa1;a2;:::;ang
witha=sc. a very na ve approach would be to split each activity into a
separate activity set: c=ffagja2ag. the resulting model fragments would
be completely disconnected and the composed system net would most likely be
undertting. this problem is illustrated by figure 8. the other extreme would
bec=fag, i.e., there is just one sublog being the original event log.
a b c d e f g h i j k
fig. 8. a possible system net discovered when activity sets are singletons: c=ffagj
a2ag. the models discovered for subnets are disconnected because each activity
appears in only one sublog.
there are various ways to decompose activity sets. for example, one can
mine for frequent item sets to nd activities that often happen together. an-
other, probably better performing, approach is to rst create a causal graph28 wil van der aalst
(a;r) whereais the set of activities and raais a relation on a. the in-
terpretation of ( a1;a2)2ris that there is \causal relation" between a1anda2.
most process mining algorithms already build such a graph in a preprocessing
step. for example, the algorithm [9], the heuristic miner [63], and the fuzzy
miner [37] scan the event log to see how many times a1is followed by a2. if this
occurs above a certain threshold, then it is assumed that ( a1;a2)2r. even for
large logs it is relatively easy to construct a casual graph (linear in the size of
the event log). moreover, counting the frequencies used to determine a casual
graph can be distributed easily by partitioning the cases in the log. also sam-
pling (determining the graph based on representative examples) may be used to
further reduce computation time.
given a causal graph, we can view the decomposition as a graph partitioning
problem [32, 42{44]. there are various approaches to partition the graph such
that certain constraints are satised while optimizing particular metrics. for
example, in [44] a vertex-cut based graph partitioning algorithm is proposed
ensuring the balance of the resulting partitions while simultaneously minimizing
the number of vertices that are cut (and thus replicated).
some of the notions in graph partitioning are related to \cohesion and cou-
pling" in software development [30]. cohesion is the degree to which the elements
of a module belong together. coupling is the degree to which each module relies
on the other modules. typically, one aims at \high cohesion" and \low cou-
pling". in terms of our problem this means that we would like to have activity
sets that consist of closely related activities whereas the overlap between the
dierent activity sets is as small as possible while still respecting the causalities.
the causal graph or corresponding petri net can be decomposed using the so-
called rened process structure tree (rpst) [54, 60] as shown in [53, 52]. the
rpst allows for the construction of a hierarchy of sese (single-exit-single-
entry) components. slicing the sese at the desired level of granularity corre-
sponds to a decomposition of the graph [52] that can be used for process mining.
the notion of \passages" dened in [2, 4] provides an alternative approach to
decompose such a graph. a passage is a pair of two non-empty sets of activities
(x;y ) such that the set of direct successors of xisyand the set of direct
predecessors of yisx. as shown in [2], any petri net can be partitioned using
passages such that all edges sharing a source vertex or sink vertex are in the
same set. this is done to ensure that splits and joins are not decomposed. note
that passages do not necessarily aim at high cohesion and low coupling.
in this paper, we do not investigate the dierent ways of decomposing ac-
tivity sets. we just show that for any decomposition, we can distribute process
discovery and conformance checking while ensuring correctness in the sense of
theorems 2, 3 and 4 and corollary 1.
6 instantiating the approach
this paper provides a generic approach, i.e., the goal is not to decompose one
particular process mining algorithm, but to decompose a large class of existingdecomposing petri nets for process mining 29
process discovery and conformance checking techniques. hence, the generic ap-
proach needs to be instantiated by selecting a particular decomposition approach
and an existing process mining technique.
sn
system net
l
event logdecomposition 
techniqueconformance
checking 
technique
sn1
system net
l1
event logconformance 
checksn2
system net
l2
event logconformance 
checksnn
system net
ln
event logconformance 
check
conformance diagnosticsdecompose 
model
decompose 
event loge.g., maximal decomposition, passage-based 
decomposition, or sese/rpst-based decompositione.g., a* based alignments, token-based replay, or 
simple replay until first deviation
fig. 9. overview of decomposed conformance checking showing the congurable ele-
ments of the approach: (a) the decomposition technique used to split the overall model
and event log, and (b) the conformance checking technique used to analyze the indi-
vidual models and sublogs.
figure 9 shows the congurable elements of our generic decomposed confor-
mance checking approach. there are various ways to create a valid decomposi-
tion (cf. denition 17). the maximal decomposition presented in denition 18 is
just an example. next to the maximal decomposition, we have experimented with
passage-based decomposition [2, 61] and sese/rpst-based decompositions [53,
52] as described before. for the actual conformance checking of the individual
process fragments we have been using the cost-based approach [5, 10] described
in section 3. however, in principle other techniques such as the ones described in
[21, 28, 35, 57, 62] can be used. most of these techniques have been implemented
inprom . figure 10(a-b) shows two screenshots while using the passage-based
approach for conformance checking. in case of using sese/rpst-based decom-
positions, prom provides a hierarchy of results following the iterative decom-
position of sese-components. the parts of the model with most conformance
problems are highlighted [52].30 wil van der aalst
(a) dialog for selecting the costs of particular deviation; the 
same cost are automatically applied to all process fragments 
(in this case based on passages) (b) conformance diagnostics for one of the 11 passages: every tab shows 
either the process model fragment or the diagnostics
(c) dialog for selecting the technique to discover causalities 
and the actual discovery algorithm applied to each sublog 
(in this case based on passages)(d) overall process model discovered after merging the models 
discovered per sublog
fig. 10. illustration of some of the prom plug-ins using the general results presented
in this paper.
figure 10(c) shows the selection of the technique to create a causal graph
(as mentioned in section 5) and the selection of the actual discovery algorithm
applied to each sublog. the result is shown in figure 10(d). in this particular
prom plug-in passages [2] are used to decompose the event log. however, as
mentioned before, this is just one example. figure 11 shows the congurable
elements of our generic decomposed process discovery approach. the overall
approach allows for the selection of a decomposition technique to create the
activity sets and the selection of a process discovery technique to nd model
fragments. for example, the passage-based prom plug-in figure 10(c) lists four
discovery algorithms (e.g., the miner and two language-based region miners).
for some initial experimental results using passage-based decomposition we
refer to [61]. these experiments show that the actual speed-up varies greatly
depending on the decomposition used. indeed it becomes possible to check the
conformance of models that could not be checked before. for example, in [61]
it is shown that using the right decomposition the business process intelligence
challenge (bpic'12) event log can be checked. however, there are two important
observations. in spaghetti-like models the largest passage typically consumes
most computation time. hence, it is important to try and balance the sizes of
the dierent process fragments and not only use passage-based decompositions.decomposing petri nets for process mining 31
sn
system netl
event logdecomposition 
techniqueprocess 
discovery
technique
sn1
system netl1
event log
discovery
sn2
system netl2
event log
snn
system netln
event log
compose 
modeldecompose 
event log
discovery discoverye.g., causal graph based on frequencies is 
decomposed using passages or sese/rpste.g., language/state-based region discovery, 
variants of alpha algorithm, genetic process mining
fig. 11. overview of decomposed process discovery showing the congurable elements
of the approach: (a) the decomposition technique used to create the activity sets to
create sublogs and (b) the process discovery technique used to infer models from sublogs.
due to overhead, the decomposed approach may even take longer if an unsuitable
decomposition is used. moreover, the alignment-based approach [5, 10] used to
check the tness of process fragments may take longer if complex fragments
have substantially more freedom because they are not longer embedded in a
restrictive context. this is particular to the alignment-based approach that uses
several optimizations to exclude paths that do not reach the nal marking.
for experimental conformance checking results based on hierarchies of sese
(single-exit-single-entry) components computed using the rened process struc-
ture tree (rpst) [54, 60] we refer to [53, 52]. also here we nd several cases
where it is possible to provide meaningful diagnostics where the overal alignment-
based approach is unable to compute tness values. section 6 of [52] describes
three models having hundreds of activities that could not be analyzed using con-
ventional techniques, but that could be analyzed after decomposition. however,
also here we would like to emphasize that results vary. for good-tting event
logs the speedup is negligible. moreover, using a very ne-grained decomposi-
tion may result in optimistic tness values (at the event level) as discussed in
the context of theorem 3.
clearly, more experimentation is needed. however, as shown in this section,
several instantiations of the approach have been implemented and the initial
results are encouraging. although theorems 2, 3 and 4 and corollary 1 are
highly generic, the actual performance gains depend on the actual process mining
algorithm that is decomposed and the decomposition selected.32 wil van der aalst
7 related work
for an introduction to process mining we refer to [1]. for an overview of best
practices and challenges, we refer to the process mining manifesto [41]. the goal
of this paper is to decompose challenging process discovery and conformance
checking problems into smaller problems [3]. therefore, we rst review some of
the techniques available for process discovery and conformance checking.
process discovery, i.e., discovering a process model from a multiset of exam-
ple traces, is a very challenging problem and various discovery techniques have
been proposed [8, 9, 14, 16, 23, 24, 27, 35, 48, 59, 63, 64]. many of these techniques
use petri nets during the discovery process and/or to represent the discovered
model. it is impossible to provide an complete overview of all techniques here.
very dierent approaches are used, e.g., heuristics [27, 63], inductive logic pro-
gramming [35], state-based regions [8, 24, 59], language-based regions [16, 64],
and genetic algorithms [48]. classical synthesis techniques based on regions [29]
cannot be applied directly because the event log contains only example behavior.
for state-based regions one rst needs to create an automaton as described in [8].
moreover, when constructing the regions, one should avoid overtting. language-
based regions seem good candidates for discovering transition-bordered petri
nets for subnets [16, 64]. unfortunately, these techniques still have problems
dealing with infrequent/incomplete behavior.
as mentioned before, there are four competing quality criteria when compar-
ing modeled behavior and recorded behavior: tness, simplicity, precision, and
generalization [1]. in this paper, we focused on tness, but also precision and
generalization can also be investigated per subnet. various conformance check-
ing techniques have been proposed in recent years [5, 10, 11, 13, 21, 28, 35, 50, 51,
57, 62]. conformance checking can be used to evaluate the quality of discovered
processes but can also be used for auditing purposes [6]. most of the techniques
mentioned can be combined with our decomposition approach. the most chal-
lenging part is to aggregate the metrics per model fragment and sublog into met-
rics for the overall model and log. we consider the approach described in [10] to
be most promising as it constructs an optimal alignment given an arbitrary cost
function. this alignment can be used for computing precision and generalization
[5, 51]. however, the approach can be rather time consuming. therefore, the
eciency gains obtained through decomposition can be considerable for larger
processes with many activities and possible subnets.
little work has been done on the decomposition and distribution of pro-
cess mining problems [3]. in [55] mapreduce is used to scale event correlation
as a preprocessing step for process mining. in [19] an approach is described
to distribute genetic process mining over multiple computers. in this approach
candidate models are distributed and in a similar fashion also the log can be
distributed. however, individual models are not partitioned over multiple nodes.
therefore, the approach in this paper is complementary. moreover, unlike [19],
the decomposition approach in this paper is not restricted to genetic process
mining.decomposing petri nets for process mining 33
more related are the divide-and-conquer techniques presented in [25]. in [25]
it is shown that region-based synthesis can be done at the level of synchronized
state machine components (smcs). also a heuristic is given to partition the
causal dependency graph into overlapping sets of events that are used to con-
struct sets of smcs. in this paper we provide a dierent (more local) partitioning
of the problem and, unlike [25] which focuses specically on state-based region
mining, we decouple the decomposition approach from the actual conformance
checking and process discovery approaches.
also related is the work on conformance checking of proclets [31]. proclets
can be used to dene so-called artifact centric processes, i.e., processes that are
not monolithic but that are composed of smaller interacting processes (called
proclets). in [31] it is shown that conformance checking can be done per proclet
by projecting the event log onto a single proclet while considering interface
transitions in the surrounding proclets.
several approaches have been proposed to distribute the verication of petri
net properties, e.g., by partitioning the state space using a hash function [18] or
by modularizing the state space using localized strongly connected components
[45]. these techniques do not consider event logs and cannot be applied to process
mining.
most data mining techniques can be distributed [22], e.g., distributed classi-
cation, distributed clustering, and distributed association rule mining [15]. these
techniques often partition the input data and cannot be used for the discovery
of petri nets.
this paper generalizes the results presented in [2, 52, 53, 61] to arbitrary petri
net decompositions. in [2, 61] it is shown that so-called \passages" [4] can be
used to decompose both process discovery and conformance checking problems.
in [53, 52] it is shown that so-called sese (single-exit-single-entry) components
obtained through the rened process structure tree (rpst) [54, 60] can be used
to decompose conformance checking problems. these papers use a particular
particular decomposition structure. however, as shown in this paper, there are
many ways to decompose process mining problems. moreover, this can be done
for any net structure and any collection of partly overlapping activity sets.
8 conclusion
the practical relevance of process mining increases as more event data becomes
available. more and more events are being recorded and already today's event
logs provide massive amounts of process related data. however, as event logs
and processes become larger, many computational challenges emerge. most al-
gorithms are linear in the size of the event log and exponential in the number
of dierent activities [3]. therefore, we aim at decomposing large process min-
ing problems into collections of smaller process mining problems focusing on
restricted sets of activities.
forconformance checking we decompose the process model into smaller frag-
ments and split the event log into sublogs. as shown in this paper, conformance34 wil van der aalst
can be analyzed per fragment and sublog. in fact, a trace in the log can be
replayed by the overall model if and only if it can be replayed by each of the
fragments. we have shown how to compute a maximal decomposition , i.e., how
to split the overall model and log into fragments and sublogs that are as small
as possible.
for process discovery we developed a similar approach and have formally
proven its correctness. given a decomposition into activity sets, we can discover
a process model per sublog. these models can be stitched together to form an
overall model. we would like to stress that we do not propose a new process
discovery algorithm: instead, we show that any process discovery algorithm can
be decomposed.
our future work aims at investigating more metrics for conformance checking.
in this paper we focused on the most dominant conformance notion: tness.
however, using the notion of alignments we would also like to explore other
conformance notions related to precision and generalization. for discovery we
now rely on an a priori decomposition of all activities into overlapping activity
sets. we already discussed how to nd such activity sets based on partitioning the
causal graph learned over the model. however, this needs to be investigated in
detail also using large scale experimentation. if the activity sets are overlapping
too much, the performance gain is minimal. if the activity sets have too little
overlap, the resulting model will most likely be undertting.
although there are many open questions, this paper lays the foundation for
decomposing process mining problems. in general it is much more ecient to
solve many smaller problems rather than one big problem. (recall that most
algorithms are linear in the size of the event log and exponential in the number
of dierent activities.) moreover, using parallel computing, these decomposed
problems can be solved concurrently. obviously, this is very attractive given
modern computing infrastructures.
acknowledgements
this work was supported by the basic research program of the national re-
search university higher school of economics (hse) in moscow.
references
1. w.m.p. van der aalst. process mining: discovery, conformance and enhancement
of business processes . springer-verlag, berlin, 2011.
2. w.m.p. van der aalst. decomposing process mining problems using passages. in
s. haddad and l. pomello, editors, applications and theory of petri nets 2012 ,
volume 7347 of lecture notes in computer science , pages 72{91. springer-verlag,
berlin, 2012.
3. w.m.p. van der aalst. distributed process discovery and conformance checking.
in j. de lara and a. zisman, editors, international conference on fundamental
approaches to software engineering (fase 2012) , volume 7212 of lecture notes
in computer science , pages 1{25. springer-verlag, berlin, 2012.decomposing petri nets for process mining 35
4. w.m.p. van der aalst. passages in graphs. bpm center report bpm-12-19,
bpmcenter.org, 2012.
5. w.m.p. van der aalst, a. adriansyah, and b. van dongen. replaying history
on process models for conformance checking and performance analysis. wires
data mining and knowledge discovery , 2(2):182{192, 2012.
6. w.m.p. van der aalst, k.m. van hee, j.m. van der werf, and m. verdonk. audit-
ing 2.0: using process mining to support tomorrow's auditor. ieee computer ,
43(3):90{93, 2010.
7. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workow patterns. distributed and parallel databases , 14(1):5{51, 2003.
8. w.m.p. van der aalst, v. rubin, h.m.w. verbeek, b.f. van dongen, e. kindler,
and c.w. g unther. process mining: a two-step approach to balance between
undertting and overtting. software and systems modeling , 9(1):87{111, 2010.
9. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
10. a. adriansyah, b. van dongen, and w.m.p. van der aalst. conformance checking
using cost-based fitness analysis. in c.h. chi and p. johnson, editors, ieee
international enterprise computing conference (edoc 2011) , pages 55{64. ieee
computer society, 2011.
11. a. adriansyah, b.f. van dongen, and w.m.p. van der aalst. towards robust con-
formance checking. in m. zur muehlen and j. su, editors, bpm 2010 workshops,
proceedings of the sixth workshop on business process intelligence (bpi2010) ,
volume 66 of lecture notes in business information processing , pages 122{133.
springer-verlag, berlin, 2011.
12. a. adriansyah, j. munoz-gama, j. carmona, b.f. van dongen, and w.m.p. van
der aalst. alignment based precision checking. in b. weber, d.r. ferreira, and
b. van dongen, editors, workshop on business process intelligence (bpi 2012) ,
tallinn, estonia, 2012.
13. a. adriansyah, n. sidorova, and b.f. van dongen. cost-based fitness in confor-
mance checking. in international conference on application of concurrency to
system design (acsd 2011) , pages 57{66. ieee computer society, 2011.
14. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ow logs. in sixth international conference on extending database technology ,
volume 1377 of lecture notes in computer science , pages 469{483. springer-
verlag, berlin, 1998.
15. r. agrawal and j.c. shafer. parallel mining of association rules. ieee trans-
actions on knowledge and data engineering , 8(6):962{969, 1996.
16. r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on
regions of languages. in g. alonso, p. dadam, and m. rosemann, editors, inter-
national conference on business process management (bpm 2007) , volume 4714
oflecture notes in computer science , pages 375{383. springer-verlag, berlin,
2007.
17. g. berthelot. transformations and decompositions of nets. in w. brauer,
w. reisig, and g. rozenberg, editors, advances in petri nets 1986 part i: petri
nets, central models and their properties , volume 254 of lecture notes in computer
science , pages 360{376. springer-verlag, berlin, 1987.
18. m.c. boukala and l. petrucci. towards distributed verication of petri nets prop-
erties. in proceedings of the international workshop on verication and evalua-
tion of computer and communication systems (vecos'07) , pages 15{26. british
computer society, 2007.36 wil van der aalst
19. c. bratosin, n. sidorova, and w.m.p. van der aalst. distributed genetic process
mining. in h. ishibuchi, editor, ieee world congress on computational intelli-
gence (wcci 2010) , pages 1951{1958, barcelona, spain, july 2010. ieee.
20. j.c.a.m. buijs, b.f. van dongen, and w.m.p. van der aalst. on the role of fit-
ness, precision, generalization and simplicity in process discovery. in r. meers-
man, s. rinderle, p. dadam, and x. zhou, editors, otm federated conferences,
20th international conference on cooperative information systems (coopis 2012) ,
volume 7565 of lecture notes in computer science , pages 305{322. springer-
verlag, berlin, 2012.
21. t. calders, c. guenther, m. pechenizkiy, and a. rozinat. using minimum de-
scription length for process mining. in acm symposium on applied computing
(sac 2009) , pages 1451{1455. acm press, 2009.
22. m. cannataro, a. congiusta, a. pugliese, d. talia, and p. truno. distributed
data mining on grids: services, tools, and applications. ieee transactions on
systems, man, and cybernetics, part b , 34(6):2451{2465, 2004.
23. j. carmona and j. cortadella. process mining meets abstract interpretation. in
j.l. balcazar, editor, ecml/pkdd 210 , volume 6321 of lecture notes in articial
intelligence , pages 184{199. springer-verlag, berlin, 2010.
24. j. carmona, j. cortadella, and m. kishinevsky. a region-based algorithm
for discovering petri nets from event logs. in business process management
(bpm2008) , pages 358{373, 2008.
25. j. carmona, j. cortadella, and m. kishinevsky. divide-and-conquer strategies for
process mining. in u. dayal, j. eder, j. koehler, and h. reijers, editors, business
process management (bpm 2009) , volume 5701 of lecture notes in computer
science , pages 327{343. springer-verlag, berlin, 2009.
26. m. castellanos, f. casati, u. dayal, and m.c. shan. a comprehensive and auto-
mated approach to intelligent business processes execution analysis. distributed
and parallel databases , 16(3):239{273, 2009.
27. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
28. j.e. cook and a.l. wolf. software process validation: quantitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147{176, 1999.
29. p. darondeau. unbounded petri net synthesis. in j. desel, w. reisig, and
g. rozenberg, editors, lectures on concurrency and petri nets , volume 3098 of
lecture notes in computer science , pages 413{438. springer-verlag, berlin, 2004.
30. h. dhama. quantitative models of cohesion and coupling in software. journal
of systems and software , 29(1):65{74, 1995.
31. d. fahland, m. de leoni, b.f. van dongen, and w.m.p. van der aalst. con-
formance checking of interacting processes with overlapping instances. in
s. rinderle, f. toumani, and k. wolf, editors, business process management
(bpm 2011) , volume 6896 of lecture notes in computer science , pages 345{361.
springer-verlag, berlin, 2011.
32. u. feige, m. hajiaghayi, and j. lee. improved approximation algorithms for
minimum-weight vertex separators. in proceedings of the thirty-seventh annual
acm symposium on theory of computing , pages 563{572. acm, new york, 2005.
33. w. gaaloul, k. gaaloul, s. bhiri, a. haller, and m. hauswirth. log-based transac-
tional workow mining. distributed and parallel databases , 25(3):193{240, 2009.decomposing petri nets for process mining 37
34. d. georgakopoulos, m. hornick, and a. sheth. an overview of workow manage-
ment: from process modeling to workow automation infrastructure. distributed
and parallel databases , 3:119{153, 1995.
35. s. goedertier, d. martens, j. vanthienen, and b. baesens. robust process dis-
covery with articial negative events. journal of machine learning research ,
10:1305{1340, 2009.
36. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321{343, 2004.
37. c.w. g unther and w.m.p. van der aalst. fuzzy mining: adaptive process sim-
plication based on multi-perspective metrics. in g. alonso, p. dadam, and
m. rosemann, editors, international conference on business process management
(bpm 2007) , volume 4714 of lecture notes in computer science , pages 328{343.
springer-verlag, berlin, 2007.
38. d. hand, h. mannila, and p. smyth. principles of data mining . mit press,
cambridge, ma, 2001.
39. j. herbst. ein induktiver ansatz zur akquisition und adaption von workow-
modellen . phd thesis, universit at ulm, november 2001.
40. m. hilbert and p. lopez. the world's technological capacity to store, commu-
nicate, and compute information. science , 332(6025):60{65, 2011.
41. ieee task force on process mining. process mining manifesto. in f. daniel,
k. barkaoui, and s. dustdar, editors, business process management workshops ,
volume 99 of lecture notes in business information processing , pages 169{194.
springer-verlag, berlin, 2012.
42. g. karpis and v. kumar. a fast and high quality multilevel scheme for parti-
tioning irregular graphs. siam journal on scientic computing , 20(1):359{392,
1998.
43. b.w. kernighan and s. lin. an ecient heuristic procedure for partitioning
graphs. the bell systems technical journal , 49(2), 1970.
44. m. kim and k. candan. sbv-cut: vertex-cut based graph partitioning using
structural balance vertices. data and knowledge engineering , 72:285{303, 2012.
45. c. lakos and l. petrucci. modular analysis of systems composed of semi-
autonomous subsystems. in application of concurrency to system design
(acsd2004) , pages 185{194. ieee computer society, 2004.
46. j. manyika, m. chui, b. brown, j. bughin, r. dobbs, c. roxburgh, and a. by-
ers. big data: the next frontier for innovation, competition, and productivity.
mckinsey global institute, 2011.
47. a.k. alves de medeiros. genetic process mining . phd thesis, eindhoven university
of technology, 2006.
48. a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245{304, 2007.
49. t.m. mitchell. machine learning . mcgraw-hill, new york, 1997.
50. j. munoz-gama and j. carmona. a fresh look at precision in process confor-
mance. in r. hull, j. mendling, and s. tai, editors, business process management
(bpm 2010) , volume 6336 of lecture notes in computer science , pages 211{226.
springer-verlag, berlin, 2010.
51. j. munoz-gama and j. carmona. enhancing precision in process conformance:
stability, condence and severity. in n. chawla, i. king, and a. sperduti, editors,
ieee symposium on computational intelligence and data mining (cidm 2011) ,
pages 184{191, paris, france, april 2011. ieee.38 wil van der aalst
52. j. munoz-gama, j. carmona, and w.m.p. van der aalst. conformance check-
ing in the large: partitioning and topology. bpm center report bpm-13-10,
bpmcenter.org, 2013.
53. j. munoz-gama, j. carmona, and w.m.p. van der aalst. hierarchical confor-
mance checking of process models based on event logs. in j. desel and j.m.
colom, editors, applications and theory of petri nets 2013 , lecture notes in
computer science, springer-verlag, berlin, 2013.
54. a. polyvyanyy, j. vanhatalo, and h. v olzer. simplied computation and gen-
eralization of the rened process structure tree. in m. bravetti and t. bultan,
editors, ws-fm 2010 , volume 6551 of lecture notes in computer science , pages
25{41. springer-verlag, berlin, 2011.
55. h. reguieg, f. toumani, h. motahari nezhad, and b. benatallah. using mapre-
duce to scale events correlation discovery for business processes mining. in
a. barros, a. gal, and e. kindler, editors, international conference on business
process management (bpm 2012) , volume 7481 of lecture notes in computer
science , pages 279{284. springer-verlag, berlin, 2012.
56. a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. fiadeiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420{425. springer-verlag, berlin, 2006.
57. a. rozinat and w.m.p. van der aalst. conformance checking of processes based
on monitoring real behavior. information systems , 33(1):64{95, 2008.
58. a. sheth. a new landscape for distributed and parallel data management. dis-
tributed and parallel databases , 30(2):101{103, 2012.
59. m. sole and j. carmona. process mining from a basis of regions. in j. lilius and
w. penczek, editors, applications and theory of petri nets 2010 , volume 6128 of
lecture notes in computer science , pages 226{245. springer-verlag, berlin, 2010.
60. j. vanhatalo, h. v olzer, and j. koehler. the rened process structure tree. data
and knowledge engineering , 68(9):793{818, 2009.
61. h.m.w. verbeek and w.m.p. van der aalst. decomposing replay problems: a
case study. bpm center report bpm-13-09, bpmcenter.org, 2013.
62. j. de weerdt, m. de backer, j. vanthienen, and b. baesens. a robust f-measure
for evaluating discovered process models. in n. chawla, i. king, and a. sperduti,
editors, ieee symposium on computational intelligence and data mining (cidm
2011) , pages 148{155, paris, france, april 2011. ieee.
63. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151{162, 2003.
64. j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. fundamenta informaticae ,
94:387{412, 2010.
65. m. weske. business process management: concepts, languages, architectures .
springer-verlag, berlin, 2007.