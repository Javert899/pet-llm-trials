process mining with the heuristicsminer
algorithm
a.j.m.m. weijters, w.m.p. van der aalst, and a.k. alves de medeiros
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fw.m.p.v.d.aalst,a.k.medeiros,a.j.m.m.weijters g@tm.tue.nl
abstract. the basic idea of process mining is to extract knowledge
from event logs recorded by an information system. until recently, the
information in these event logs was rarely used to analyze the underly-
ing processes. process mining aims at improving this by providing tech-
niques and tools for discovering process, organizational, social, and per-
formance information from event logs. fuelled by the omnipresence of
event logs in transactional information systems (cf. wfm, erp, crm,
scm, and b2b systems), process mining has become a vivid research
area [1, 2]. in this paper we introduce the challenging process mining
domain and discuss a heuristics driven process mining algorithm; the
so-called \heuristicsminer" in detail. heuristicsminer is a practical ap-
plicable mining algorithm that can deal with noise, and can be used to
express the main behavior (i.e. not all details and exceptions) registered
in an event log. in the experimental section of this paper we introduce
benchmark material (12.000 di®erent event logs) and measurements by
which the performance of process mining algorithms can be measured.
keywords : knowledge discovering, process mining, process mining benchmark, busi-
ness process intelligence.
1 process mining
within organizations there has been a shift from data orientation to process
orientation. by process we mean the way an organization arranges there work
and recourses, for instance the order in which tasks are performed and which
group of people are allowed to perform speci¯c tasks. sometimes, organizations
have very explicit process descriptions of the way the work is organized and
this description is supported by a process aware information system like, for
instance, a work°ow management system (wfm). but even if there are explicit
descriptions of the way the work should be done, the practical way of working
can di®er considerably from the prescribed way of working. other times, there
is no, or only a very immature process description available. however, in many
situations it is possible to gather information about the processes as they take
place. for instance, in many hospitals, information about the di®erent treatments
of a patient are registered (date, time, treatment, medical sta®) for, reasons like¯nancial administration. however, this kind of information in combination with
some mining techniques can also be used to get more insight in the health care
process [6]. any information system using transactional systems such as erp,
crm, or work°ow management systems will o®er this information in some form.
note that we do not assume the presence of a work°ow management system.
the only assumption we make, is that it is possible to construct event logs
with event data. these event logs are used to construct a process speci¯cation,
which adequately models the behavior registered. we use the term process mining
for the method of distilling a structured process description from a set of real
executions.
as mentioned, the goal of process mining is to extract information about
processes from transaction logs [1]. we assume that it is possible to record events
such that (i) each event refers to an activity (i.e., a well-de¯ned step in the
process), (ii) each event refers to a case (i.e., a process instance), (iii) each
event can have a performer also referred to as originator (the person executing
or initiating the activity), and (iv) events have a time stamp and are totally
ordered. table 1 shows an example of a log involving 19 events, 5 activities, and
6 originators. in addition to the information shown in this table, some event
logs contain more information on the case itself, i.e., data elements referring to
properties of the case (i.e. in an hospital information system, age, sex, diagnose,
etc. of a patient).
event logs such as the one shown in table 1 are used as the starting point for
mining. we distinguish three di®erent perspectives: (1) the process perspective,
(2) the organizational perspective and (3) the case perspective. the process per-
spective focuses on the control-°ow, i.e., the ordering of activities. the goal of
mining this perspective is to ¯nd a good characterization of all possible paths,
expressed in terms of, for instance, a petri net [9]. the organizational perspective
focuses on the originator ¯eld, i.e., which performers are involved in performing
the activities and how they are related. the goal is to either structure the or-
ganization by classifying people in terms of roles and organizational units or to
show relations between individual performers (i.e., build a social network [10]).
thecase perspective focuses on properties of cases. cases can be characterized
by their path in the process or by the originators working on a case. however,
cases can also be characterized by the values of the corresponding data elements.
for example, if a case represents a speci¯c treatment of patients in a hospital it
me be interesting to know the di®erences in throughput times between smokers
and non-smokers.
to illustrate the ¯rst perspective consider figure 1. the log shown in table 1
contains information about ¯ve cases (i.e., process instances). the log shows that
for four cases (1, 2, 3, and 4) the activities a, b, c, and d have been executed.
for the ¯fth case only three activities have been executed: activities a, e, and
d. each case starts with the execution of a and ends with the execution of d.
if activity b is executed, then also activity c is executed. however, for some
cases activity c is executed before activity b. based on the information shown
in table 1 and by making some assumptions about the completeness of the log
2case id activity id originator time stamp
case 1 activity a john 9-3-2004:15.01
case 2 activity a john 9-3-2004:15.12
case 3 activity a sue 9-3-2004:16.03
case 3 activity b carol 9-3-2004:16.07
case 1 activity b mike 9-3-2004:18.25
case 1 activity c john 10-3-2004:9.23
case 2 activity c mike 10-3-2004:10.34
case 4 activity a sue 10-3-2004:10.35
case 2 activity b john 10-3-2004:12.34
case 2 activity d pete 10-3-2004:12.50
case 5 activity a sue 10-3-2004:13.05
case 4 activity c carol 11-3-2004:10.12
case 1 activity d pete 11-3-2004:10.14
case 3 activity c sue 11-3-2004:10.44
case 3 activity d pete 11-3-2004:11.03
case 4 activity b sue 11-3-2004:11.18
case 5 activity e clare 11-3-2004:12.22
case 5 activity d clare 11-3-2004:14.34
case 4 activity d pete 11-3-2004:15.56
table 1. an event log.
aand
-splitb
cand
-join
d
e
(a) the control-flow structure expressed in terms of a petri net.
(b) the organizational structure expressed in
terms of an activity-role-performer diagram.john sue mike carol pete clarerole x role y role zjohn sue
mike
carol peteclare
(c) a sociogram based on transfer of work.
fig. 1. some mining results for the process perspective (a) and organizational (b and
c) perspective based on the event log shown in table 1.
3(i.e., assuming that the cases are representative and a su±cient large subset of
possible behaviors has been observed), we can deduce the process model shown in
figure 1(a). the model is represented in terms of a petri net. the petri net starts
with activity a and ¯nishes with activity d. these activities are represented by
transitions. after executing a there is a choice between either executing b and
c concurrently (i.e., in parallel or in any order) or just executing activity e. to
execute b and c in parallel two non-observable activities (and-split and and-
join) have been added. these activities have been added for routing purposes
only and are not present in the event log. note that for this example we assume
that two activities are concurrent if they appear in any order.
figure 1(a) does not show any information about the organization, i.e., it does
not use any information concerning the people executing activities. information
about performers of activities however, is included in table 1. for example, from
the log we can deduce that (i) activity a is executed by either john or sue, (ii)
activity b is executed by john, sue, mike or carol, (iii) c is executed by john,
sue, mike or carol, (iv) d is executed by pete or clare, and (v) e is executed by
clare. we could indicate this information in figure 1(a). the information could
also be used to \guess" or \discover" organizational structures. for example, a
guess could be that there are three roles: x, y, and z. for the execution of a role
x is required and john and sue have this role. for the execution of b and c role
y is required and john, sue, mike and carol have this role. for the execution
of d and e role z is required and pete and clare have this role. for ¯ve cases
these choices may seem arbitrary but for larger data sets such inferences capture
the dominant roles in an organization. the resulting \activity-role-performer
diagram" is shown in figure 1(b). the three \discovered" roles link activities
to performers. figure 1(c) shows another view on the organization based on
the transfer of work from one individual to another, i.e., not focussing on the
relation between the process and individuals but on relations among individuals
(or groups of individuals). consider for example table 1. although carol and
mike can execute the same activities (b and c), mike is always working with
john (cases 1 and 2) and carol is always working with sue (cases 3 and 4).
probably carol and mike have the same role but based on the small sample
shown in table 1 it seems that john isn't working with carol and sue isn't
working with carol.1these examples show that the event log can be used to
derive relations between performers of activities, thus resulting in a sociogram.
for example, it is possible to generate a sociogram based on the transfers of work
from one individual to another as is shown in figure 1(c). each node represents
one of the six performers and each arc represents that there has been a transfer
of work from one individual to another. the de¯nition of \transfer of work from
r1 to r2" is based on whether, in the same case, an activity executed by r1 is
directly followed by an activity executed by r2. for example, both in case 1 and
2 there is a transfer from john to mike. figure 1(c) does not show frequencies.
however, for analysis purposes these frequencies can added. the arc from john
1clearly the number of events in table 1 is too small to establish these assumptions
accurately. however, real event logs will contain thousands or more events.
4to mike would then have weight 2. typically, we do not use absolute frequencies
but weighted frequencies to get relative values between 0 and 1. figure 1(c) shows
that work is transferred to pete but not vice versa. mike only interacts with john
and carol only interacts with sue. clare is the only person transferring work to
herself.
focusing on the third perspective (i.e. the case perspective) is more inter-
esting when also data elements are logged but these are not listed in table 1.
the case perspective looks at the case as a whole and tries to establish rela-
tions between the various properties of a case. note that some of the properties
may refer to the activities being executed, the performers working on the case,
and the values of various data elements linked to the case. using traditional
data mining algorithms it would for example be possible to search for rules that
predict the handling time of cases.
orthogonal to the three perspectives (process, organization, and case), the
result of a mining e®ort may refer to logical issues and/or performance issues.
for example, process mining can focus on the logical structure of the process
model (e.g., the petri net shown in figure 1(a)) or on performance issues such
as °ow time. for mining the organizational perspective, the emphasis can be on
the roles or the social network (cf. figure 1(b) and (c)) or on the utilization
of performers or execution frequencies. to address the three perspectives and
the logical and performance issues a set of plug-ins has been developed for the
promframework [5] these plug-ins share a common xml format. for more
details about the promframework, its plug-ins, and the common xml-format,
we refer to www.processmining.org.
in this paper we focus on the process perspective. in fact, we consider a spe-
ci¯c algorithm: the heuristicsminer-algorithm. in the next section (section 2)
we present the details of the heuristicsminer-algorithm. section 3 is the exper-
imental section in which we describe the benchmark material (12.000 di®erent
event logs), process and event log characteristics, and measurements by which
the performance of process mining algorithms can be measured.
2 process mining with the heuristicsminer algorithm
the heuristicsminer plug-in mines the control-°ow perspective of a process
model. to do so, it only considers the order of the events within a case. in
other words, the order of events among cases isn't important. for instance for
the log in tabletablog only the ¯elds case id, time stamp and activity are con-
sidered during the mining. the timestamp of an activity is used to calculate
these ordening. in table 1 it is important that for case 1 activity a is followed
by b within the context of case 1 and not that activity a of case 1 is followed
by activity a of case 2. therefore, we de¯ne an event log as follows. let tbe a
set of activities. ¾2t¤is an event trace , i.e., an arbitrary sequence of activity
identi¯ers. wµt¤is an event log , i.e., a multiset (bag) of event traces. note
that since wis a multiset, every event trace can appear more than once in a
log. in practical mining tools frequencies become important. if we use this nota-
5tion to describe the log shown in table 1 we obtain the multiset w= [abcd;
abcd; acbd; acbd; aed ].
to ¯nd a process model on the basis of an event log, the log should be
analyzed for causal dependencies, e.g., if an activity is always followed by another
activity it is likely that there is a dependency relation between both activities.
to analyze these relations we introduce the following notations. let wbe an
event log over t, i.e., wµt¤. let a; b2t:
1.a >wbi® there is a trace ¾=t1t2t3: : : tnandi2 f1; : : : ; n ¡1gsuch that
¾2wandti=aandti+1=b,
2.a!wbi®a >wbandb6>wa,
3.a#wbi®a6>wbandb6>wa, and
4.akwbi®a >wbandb >wa,
5.a >> wbi® there is a trace ¾=t1t2t3: : : tnandi2 f1; : : : ; n ¡2gsuch that
¾2wandti=aandti+1=bandti+ 2 = a,
6.a >>> wbi® there is a trace ¾=t1t2t3: : : tnandi < j andi; j2 f1; : : : ; n g
such that ¾2wandti=aandtj=b.
consider the event log w=fabcd; abcd; acbd; acbd; aed g(i.e.,
the log shown in table 1). the ¯rst relation >wdescribes which activities ap-
peared in sequence (one directly following the other). clearly, a > wb,a > wc,
a > we,b > wc,b > wd,c > wb,c > wd, and e > wd. relation !w
can be computed from >wand is referred to as the (direct) dependecy relation
derived from event log w.a!wb,a!wc,a!we,b!wd,c!wd,
ande!wd. note that b6!wcbecause c > wb. relation kwsuggests
concurrent behavior, i.e., potential parallelism. for log wactivities bandc
seem to be in parallel, i.e., bkwcandckwb. if two activities can follow each
other directly in any order, then all possible interleavings are present2and
therefore they are likely to be in parallel. relation # wgives pairs of transitions
that never follow each other directly. this means that there are no direct depen-
decy relations and parallelism is unlikely. in a formal mining approach (i.e. the
®algorithm [3] these three basic relations (i.e., a!wb,a#wb, orakwb)
are directly used for the construction of a petri net. an advantage of the for-
mal approach is that we can characterize the class of nets that can be mined
correctly. it turns out that assuming a weak notion of completeness (i.e., if one
activity can be followed by another this should happen at least once in the log),
any so-called swf-net without short loops and implicit places can be mined
correctly. swf-nets are petri nets with a single source and sink place satisfying
some additional syntactical requirements such as the free-choice property. in this
paper, we will not elaborate on formal characterizations of the class of processes
that can be successfully mined. for the details we refer to [3].
the formal approach presupposes perfect information: (i) the log must be
complete (i.e., if an activity can follow another activity directly, the log should
contain an example of this behavior) and (ii) there is no noise in the log (i.e.,
2if, for instance 10 activities are in parallel this can be a practical problem (10!
possible patrons).
6everything that is registered in the log is correct). furthermore, the ®-algorithm
does not consider the frequency of traces in the log. however, in practical situ-
ations logs are rarely complete and/or noise free. especially the di®erentiation
between errors, low frequent activities, low frequent activity sequences, and ex-
ceptions is problematic. therefore, in practice, it becomes more di±cult to decide
if between two activities (say a and b), one of the three derived relations (i.e.,
a!wb,a#wb, orakwb) holds. for instance, the dependency relation as
used in the ®-algorithm ( a!wb) only holds if and only if in the log there is
a trace in which a is directly followed by b (i.e., the relation a > wbholds)
and there is no trace in which b is directly followed by a (i.e., not b > wa).
however, in a noisy situation one erroneous example can completely mess up the
derivation of a right conclusion. even if we have thousands of log traces in which
a is directly followed by b, then one b > waexample based on an incorrect
registration, will prevent a correct conclusion. as noted before, frequency infor-
mation isn't used in the formal approach. for this reason in the heuristicsminer
we use techniques which are less sensitive to noise and the incompleteness of logs.
the main idea is to take the frequency of the following relations into account
while inferring the derived ones (i.e., a!wb,a#wb, orakwb)
2.1 step 1: mining of the dependency graph
the starting point of the heuristicsminer is the construction of a so called de-
pendency graph . a frequency based metric is used to indicate how certain we are
that there is truly a dependency relation between two events a and b (notation
a)wb). the calculated )wvalues between the events of an event log are
used in a heuristic search for the correct dependency relations.
letwbe an event log over t, and a; b2t. then ja >wbjis the number of
times a >wboccurs in w, and
a)wb=µja >wbj ¡ jb >waj
ja >wbj+jb >waj+ 1¶
(1)
first, remark that the value of a)wbis always between -1 and 1. some
simple examples demonstrate the rationale behind this de¯nition. if we use this
de¯nition in the situation that, in 5 traces, activity a is directly followed by
activity b but the other way around never occurs, the value of a)wb= 5=6 =
0:833 indicating that we are not completely sure of the dependency relation (only
5 observations possibly caused by noise). however if there are 50 traces in which
a is directly followed by b but the other way around never occurs, the value of
a)wb= 50=51 = 0 :980 indicates that we are pretty sure of the dependency
relation. if there are 50 traces in which activity a is directly followed by b and
noise caused b to follow a once, the value of a)wbis 49=52 = 0 :94 indicating
that we are pretty sure of a dependency relation.
a high a)wbvalue strongly suggests that there is a dependency relation
between activity a and b. but what is a high value, what is a good threshold
to take the decision that b truly depends on a (i.e. a!wbholds)? the
7threshold appears sensitive for the amount of noise, the degree of concurrency
in the underlying process, and the frequency of the involved activities.
however, for many dependency relations it seems unnecessary to use always
a threshold value. after all, we know that each non-initial activity must have
at least one other activity that is its cause, and each non-¯nal activity must
have at least one dependent activity. using this information in the so called all-
activities-connected heuristic , we can take the best candidate (with the highest
a)wbscore). this simple heuristic helps us enormously in ¯nding reliable
causality relations even if the event log contains noise. as an example we have
applied the heuristic to an event log from the petri net of figure 1 but with
noise in it. thirty event traces are used (nine for each of the three possible
traces and three incorrect traces: abced, aecbd, ad) resulting in the event
logw= [abcd9; acbd;aed9; abced; aecbd; ad ]. we ¯rst calculate
the)-values for all possible activity combinations. the result is displayed in
the matrix below.
)wa b c d e
a 0.0 0.909 0.900 0.500 0.909
b 0.0 0.0 0.0 0.909 0.0
c 0.0 0.0 0.0 0.900 0.0
d-0.500 -0.909 -0.909 0.0-0.909
e 0.0 0.0 0.0 0.909 0.0
we now apply the all-activities-connected heuristic on this matrix. we can rec-
ognize the initial activity a, it is the activity without a positive value in the
a-column. for the dependent activity of a we search for the highest value in
row a of the matrix. both b and e are high (0.909). we arbitrarily choose b.
if we use the matrix to search for the cause for b (the highest value of the b
column) we will again ¯nd a as the cause for b. d is the depending activity
of b (d is the highest value of the b row). the result of applying the same
procedure on activity b, c, and e is presented in figure 2; remark that only
the causal relations are depicted in a so called dependency graph . the numbers
in the activity boxes indicate the frequency of the activity, the numbers on the
arcs indicate the reliability of each causal relation and the numbers on the nodes
the frequencies. in spite of the noise, the causal relations are correctly mined.
in this example we know the process model that is used for generating the
event log and we know the traces with noise (i.e. abced, aecbd, ad). how-
ever, in a practical situation we never know if for instance the trace ad is really
noise or if it is a low frequent pattern. to handle this, three threshold parame-
ters are available in the heuristicsminer: (i) the dependency threshold , (ii) the
positive observations threshold , (iii) the relative to best threshold . with these
threshold we can indicate that we will also accept dependency relations between
activities that have (i) a dependency measure above the value of the depen-
dency threshold, and (ii) have a frequency higher than the value of the positive
observations threshold, and (iii) have a dependency measure for which the dif-
ference with the "best" dependency measure is lower than the value of relative
8a
30
b
200,909/20
c
200,900/20
e
110,909/11
d
300,909/20 0,900/20 0,909/11fig. 2. a dependency graph resulting from applying the heuristic approach to a noisy
log from the petri-net of figure 1.
to best threshold. in our example the following parameter setting will result in
a dependency graph in which also the low frequent behavior ad is modelled:
dependency threshold = 0.45, positive observations threshold = 1, relative to
best threshold = 0.4 in practical situations (with event logs with thousands of
traces, low frequent traces and some noise) these parameters are very useful to
get insight in the main behavior and/or the details of processes.
however, the basic algorithm as presented above is far from complete. it
can't handle short loops , the type of the dependency relations (and/xor-
split/join) isn't represented in the dependency graph, there are problems with
non-observable activities , and it can't handle long distance dependencies .
short loops in a process, it may be possible to execute the same activity
multiple times. if this happens, this typically refers to a loop in the corresponding
model. long distance loops (e.g. ...abcabcabc...) are no problem for the
heuristicsminer presented so far (the values of a)wb,b)wc, and c)w
aare useful to indicate dependency relations). however, for length-one loops
(i.e. traces like acb, accb, acccb, ... are possible) and loops of length two
(i.e. traces like acdb, acdcdb, acdcdcdb, ... are possible) the value of
c)wcandc)wdis always very low. however, it appears very simple to
de¯ne the dependency measure for loops of length one and length two. let w
be an event log over t, and a; b2t. then ja >wajis the number of times
a >waoccurs in w, andja >> wajis the number of times a >> wboccurs in
w.
a)wa=µja >waj
ja >waj+ 1¶
(2)
a)2wb=µja >> wbj+jb >> waj
ja >> wbj+jb >> waj+ 1¶
(3)
9during the construction of the dependency graph loops of length one are treated
in the same way as other activities (they need an external cause and a dependent
activity). loops of length-two need a special treatment while applying the all-
activities-connected heuristic. they form a pair and as a pair they need only one
cause and one depending activity.3
2.2 and/xor-split/join and non-observable tasks
the process model for the event log w= [abcd ,abcd ,acbd ,acbd ,
aed ] shown in figure 1(a) is a petri net. activities are represented by tran-
sitions. after executing of the ¯rst task a, there is a choice between either
executing b and c concurrently (i.e., in parallel or in any order) or just exe-
cuting activity e. to execute b and c in parallel two non-observable activities
(and-split and and-join) have been added. mining of these non-observable
activities is di±cult, because they are not present in the event log. to avoid
the explicit modelling of invisible activities, in the heuristicsminer we don't use
petri nets for the representation of process models, but so called causal ma-
trix. the translation of a petri net to a causal matrix is straightforward [8]. as
an example we show the translation of the petri net of figure 1 to the causal
matrix representation.
activity input output
a ; (b_e)^(c_e)
b a d
c a d
d (b_e)^(c_e) ;
e a d
table 2. the translation of the petri net of figure 1(a) to a causal matrix.
each activity has an input and output expression. because a is the start
activity the input expression is empty and activity a is enabled. after the ¯ring
of a the output ( b_e)^(c_e) is activated (i.e. ( b_e) is activated and
(c_e) is activated). we now look if activity b is enabled. because the input
expression of b is only a, we have to look if all b's are active in the output
expression of a. this is the case. but because the _in (b_e) is an exclusive
or, the ( b_e) isn't longer activated but the ( c_e) expression still is. we
3a length-one loop c in combination with a concurrent process a can easily produce
patterns like cac. to prevent the heuristicsminer for this trap a length-two depen-
dency relation ( a)2wc) between a and c only holds if a and c are not length
one loops. in short, we ¯rst calculate equation (2) and then (3). this way we capture
all tasks in a length-one loop construct before searching for length-two loops.
10now look if activity e is enabled. because the input expression of e is only
a, we have to look if all e's are active in the output expression of a. this is
the not case because ( b_e) is no more activated. however, activity b is still
enabled (all relevant expressions are still activated). this is exactly the behavior
we like to model. for more details about the semantics of causal matrices we
refer to [7]. the same paper gives detailed information about the translation of
a causal matrix to a petri net. this translation is a little more complex because
appropriate hidden activities must be introduced. we will now concentrate on
the heuristics for mining the correct logical expressions.
the underlying idea is relative simple. let we start with a simple example.
the dependency graph of (figure 2) already gives the information that activities
b,c and e are in the output expression of activity a (as sown in table 2). if two
activities (e.g. b and e) are in the and-relation, the pattern ...be... can appear
in the event log. if two activities (e.g. b and c) are in the xor relation the
pattern ...bc... isn't possible. the following measurement is de¯ned to express
the above formulated idea. let wbe an event log over t,a; b; c2t, and b and
c are in depending relation with a. then
a)wb^c=µjb >wcj+jc >wbj
ja >wbj+ja >wcj+ 1¶
(4)
theja >wbj+ja >wcjindicates the number of positive observations and
jb >wcj+jc >wbjindicates the number of times b and c appear directly after
each other. given the event log with noise (i.e. w= [abcd9,acbd9,aed9,
abced ,aecbd ,aed ]) the value of a)wb^c= (10+10/10+9+1) =
1.0 indicating that b and c are in a and-relation. the value of a)wb^e
= (0/10+11+1) = 0.00 and the value of a)wc^e= (1+1/9+11+1) =
0.09 indicating that b,e and c,e are both in a xor-relation. during all our
experiments a default value of 0.1 for the a)wb^c-parameter is used. given the
input and output set of each activity in the dependency graph in combination
with the a)wb^cmeasure the construction of the and/xor-split/joins is
straight forward. as an illustration we follow the construction of the output-
expression of activity a (e.g. aoutput ). because there are dependency relations
from a to b,c, and e the basic material is the set fb; c; e g. we will start with
the ¯rst element in bce (e.g. aoutput = ((b)). the next element is c. the value
ofa)wb^c= 1.00 (e.g. b and c are in a and-relation, and the new value of
aoutput = ((b)^(c)). in the next step we use the values of a)wb^e= 0:00
anda)wc^e= 0:09. if both values were above the ^-threshold value of 0.1
then the new aoutput -expression would be (( b)^(c)^(e)). but both calculated
values are below the ^-threshold resulting in aoutput = ((b_e)^(c_e)).4the
result of applying the heuristicsminer as de¯ned so far on the example event log
with noise will result in the heuristicnet as presented in table 2.
4if we start the procedure above with activity e the result would be (( e_b)^c).
therefore an extra loop is performed in which we check for all of the _-groups if this
group can be extended with any of the available activities.
112.3 step 3: mining long distance dependencies
b
de
c fa g
fig. 3. a process model with a non-free-choice construct.
in some process models the choice between two activities isn't determined
inside some node in the process model but may depend on choices made in
other parts of the process model. figure 3 shows a long distance dependency
construct. after executing activity d there is a choice between activity e and
activity f. however, the choice between e and f is \controlled" by the earlier
choice between b and c. clearly, such non-local behavior is di±cult to mine for
mining approaches primarily based on binary information ( a >wb). only a few
process mining algorithms [4, 11] are able to mine them successfully. mining an
event log generated by the process model of figure 3 with the heuristicsminer as
presented so far, will result in a dependency graph without the b to e and c to f
connection. however, the a >>> wb-relation as given in section 2 will strongly
indicate that b is always followed by e and c by f. (e.g. if jbjis the frequency of
activity b, then b)l
we=jb >>> wej=jbj+1 value close to 1.0). but many
high)l
w-values are already sound with process model. for instance, if we look
in the process model of figure 3 then the value of a)l
wdwill be close to 1.0
but no extra dependency relation is necessary. we can check this by looking at
the process model mined so far and test out if it is possible to go from a to the
end activity (g) without visiting activity d. only if this is possible the process
model is updated with the extra dependency relation from a to d and the logical
input and output expressions of the causal matrix are updated in line with this
new connection. the pseudo code for the \long-distance-dependency-heuristic"
is given in the appendix (table 4).
3 experimental results
in this experimental section we will introduce our benchmark material, some rele-
vant measurements for this material, measurements by which the performance of
process mining algorithms can be assessed, and ¯nally the performance measure-
ments of the heuristicsminer for the benchmark material. but, as an intermezzo
we will ¯rst illustrate the heuristicsminer on low frequent behavior and noise.
123.1 an illustration
as a ¯rst illustration the process model in figure 4 is used for generating event
logs. all examples in an event log are, in principle, positive examples; nega-
tive examples are not available or it isn't clear which traces are wrong. this
starting-point is an extra handicap during mining; specially the combination of
low frequent patterns and noise is problematic. the loop from activity j to c and
the direct connection from activity d to k are used to exemplify the behavior of
the heuristicsminer algorithm in case of exceptions (low frequent behavior) and
noise. one noise free event log with 1000 random traces is generated. remark
that activities d1, d2 and d3 are not present in the event log (i.e. they are
invisible tasks). one other event log with 1000 traces is generated where 5% of
traces contains noise. to incorporate noise in our event logs we de¯ne ¯ve di®er-
ent types of noise generating operations: (i) delete the head of a trace, (ii) delete
the tail of a trace, (iii) delete a part of the body, (iv) remove one event, and ¯-
nally (v) interchange two random chosen events. during the deletion-operations
at least one event, and no more than one third of the trace is deleted. to incor-
porate 5% noise the traces of a noise free event log are randomly selected and
then one of the ¯ve above described noise generating operations is applied (each
noise generation operation with an equal probability of 1/5).
ak
dd2
d3id1
b
eh
gj c
fexceptionexception
fig. 4. the process model used for generating event logs (with and without noise).
using the default parameter setting of the heuristicsminer (relative to best
threshold=0.05, positive observations=3, dependency threshold=0.9 and and-
threshold=0.1) mining of the noise free example results in the dependency graph
of figure 5. to save space, the logical behavior of the splits and joins is depicted
in the dependency graph (using the & and _symbols). remark that only the
main behavior (not the low frequent behavior) is re°ected in the graph.
if we change the parameter setting a bit so that less reliable dependency
measures are also accepted, for instance, using relative to best threshold = 0.05,
13a
1000b
1000
c
1025d
497
e
5030.99/1000f
477
g
503h
980
i
2047j
1025k
1000
0.99/1000
0.99/1025
0.99/10220.99/10250.99/477
0.99/10000.99/1000
0.99/1000
0.99/5330.99/477
0.99/980
0.99/1000&v
&vfig. 5. the result of heuristicsminer with default parameter setting and without noise
(relative to best threshold=0.05, positive observations=3, dependency threshold=0.9
and and-threshold=0.1). note that the two low frequent dependency relations from
(from d to k and from j to c) are not in the model.
positive observations = 3, dependency threshold=0.9 and and-threshold = 0.1,
the model depicted in figure 6 is mined. note that this model also contains the
low frequent dependency relations that are not in the model in figure 5.
a
1000b
1000
c
1025d
497
e
5030.99/1000f
477
g
503h
980
i
2047j
1025k
1000
0.99/1000
0.99/1025
0.99/10220.99/10250.99/477
0.99/10000.99/1000
0.99/1000
0.99/5330.99/477
0.99/980
0.99/1000&v
&
0.90/250.86/20
fig. 6. the result of heuristicsminer with updated parameter setting and without
noise (relative to best threshold = 0.20, dependency threshold = 0.85, without noise).
note that low-frequent dependency relations (from d to k and from j to c) are catched
with this setting, but were not when using the default parameters (i.e. figure 5).
14the two low frequent dependency relations are now correctly mined. looking
at the numbers in 6 shows that the ¯rst relation from j to c is only used 25
times (i.e. that the pattern j...c appears 25 times in the event log). because
there is concurrency, the situation in which j is directly followed by c only can
be lower. the frequency for the d...k pattern is even lower, 20 times. if we use
the default parameter setting to mine the event log with 5% noise the mined
process model is exactly the same model as the model in figure 5 (only the the
dependency values between activities are in general a little bit lower). if we mine
the event log with noise in combination with a parameter setting such that also
less reliable dependency measures are accepted (i.e. the setting used above: rel-
ative to best threshold=0.20, dependency threshold=0.8) the two low frequent
dependency relations are correctly mined. however, also an extra dependency
relation (value 0.8, frequency 7) between a and i is found. because we know
the correct model, it is simple to choose the parameter setting in such a way
that exactly the correct model is mined (e.g. relative to best threshold=0.20,
dependency threshold=0.85). however, in a realistic setting one doesn't know if
registered behavior in the event log is low frequent behavior or noise. the pa-
rameters of the heuristicsminer can be use to catch only high frequent behavior
or also low frequent behavior. but mining for also the low frequent behavior has
always the risk to catch also noise.
some remarks about the parameters of the heuristicsminer seems relevant.
first, during the construction of the basic process model the all-activities-con-
nected heuristic is used. during applying this heuristic the values of the di®erent
parameters are ignored; simply one ingoing and outgoing connection with the
highest dependency value is accepted. for instance, in the b1 petri net (figure
7 of the appendix) all the connections of the net are accepted on the basis of
the all-activities-connected heuristic. if we know that we have a noise free log,
we can simply use an extraordinary intolerant parameter setting (e.g. positive
observations threshold = 1000, dependency threshold = 1.0, and relative to best
threshold = 0.00); with this setting, the constructed b1-model will always have
exactly the right connections5. the main function of the parameters is the ex-
tension of the model on the basis of low frequent behavior. extra connections are
only accepted if (i) the positive observations are above the threshold and if (ii)
the dependency value is above the threshold and if (iii) the di®erence between
the new dependency value and the ¯rst accepted one is less than the relative to
best threshold. finally, there is a strong correlation between the positive obser-
vation threshold and the dependency threshold. for instance, choosing a depen-
dency threshold of 0.9 means that we need more than 10 positive observation of
a directly followed b to accept an dependency between a and b. after all, if
ja > wbj= 10 and there is no noise, then a)wb=ja > wbj ¡ jb > waj
/ja > wbj+jb > waj+ 1 = 10/10+1 = 0.909. that means that our default
positive observation threshold of 3 is a relative low. changing only the value of
5this does not hold for the other models in the appendix b2, b3, and b4; if we only
use the all-activities-connected heuristic, some connections are missing.
15the positive observation threshold to a higher value but equal or lower than 10
will never result in the mining of the (extra) connections.
in above experimental setting - where we know the process model used for
generating event logs - we can easily check to what degree mined models are
comparable with the original models. however, in a practical setting it is only
possible to search for an optimal process model in the sense that is in accor-
dance with the information in the event log . testing if all traces can be parsed
correctly by the mined process model is one possibility to check the quality of
a model. the parsingmeasure (pm) is de¯ned as the number of correct parsed
traces divided by the number of traces in the event log. the pm-values for the
four mined models discussed above (i.e. (i) default parameters, without noise;
(ii) updated parameters without noise; (iii) default parameters, with noise; (iv)
updated parameters with noise) are given in the pm-column of table 3. the
values (0.96, 1.00, 0.91 and 0.95) seems in accordance with the discussed mining
results. for instance, the pm-value (0.96) of mining with default parameters
and a noise free event log does not model the low frequent behavior in 45 traces
(from d to k and from j to c), resulting in a pm of 0.96.
experiment pmcpm
(i) no noise, default parameters 0.960.997
(ii) no noise, updated parameters 1.001.000
(iii) 5% noise, default parameters 0.910.990
(iv) 5% noise, updated parameters 0.950.995
table 3. mining performance results for the four experiments in the illustrative exam-
ple (e.i. (i) default parameters, without noise; (ii) updated parameters without noise;
(iii) default parameters, with noise; (iv) updated parameters with noise). pm is the
naive parsing measure; after an error the parsing stops. cpm is the continuous parsing
measure; after an error the error is recorded and the parsing goes on.
however, this pm ¯tness measure seems to naive. first of all, if for one
process model the parsing get stuck at many places of a trace and in an other
process model there is only one error at the end of the trace we prefer the
second model. the continuesparsingmeasure (cpm) is a quality measure that
takes this element into account. during the calculation of the cpm we don't
stop the parsing of a trace if an error occurs. instead the error is recorded
and the parsing goes on. that means that this quality measure is based on
the number of successfully parsed events instead of the number of parsed traces
(1000). moreover, we like proper completion of the parsing process (i.e. if the
end event is parsed there are no hanging active logical expressions in the process
model). both, missing active expressions during parsing and hanging activated
expressions after parsing have a negative in°uence on the quality of the process
model. the following measurement is de¯ned to express the above formulated
16idee. let wbe an event log with eevents, mis the total number of missing
activated input expressions , and rthe number of remaining activated output
expressions. then the cpm is
cpm =1
2(e¡m)
e+1
2(e¡r)
e(5)
the cpm-values for the four mined models discussed above are given in the
cpm-column of table 3. all cpm-values are close to one indicating that in all
the process models most activities are correctly modelled (i.e. dependencies and
logical expressions are correct).
up to here an illustration of the process mining performance of the heuristic-
sminer on an example. in contrast with the machine learning research domain,
general used process mining benchmarking material is missing. for that reason
we started a collection of four sets of event logs for benchmarking process dis-
covery algorithms. in the next section (section 3.2) we ¯rst describe the four
benchmark sets and their characteristics. in section 3.3 we explain our mining
performance measurements. finally, the performance results for the heuristic-
sminer are given (section 3.4).
3.2 benchmark material
starting point for the benchmark material are the petri nets as given in the
appendix. petri net b1 (cf. figure 7) contains 16 activities and and/xor-
split/joins, but no loops. petri net b2 (cf. figure 8) is an extension of net b1
with di®erent types of loops (i.e. a long loop, a length two loop and recursion).
petri net b3 (figure 9) is an extension of b2 with extra parallel behavior in eight
extra activities. in the event logs of petri net b2 and b3 there are non-observable
(or dummy) tasks (dum1, dum2, and dum3). they are registered in the event
logs of the b2 (dum1) and b3 (dum1, dum2, and dum3) material. in the b4
experiments the non-observable (or dummy) tasks are not registered in the log.
mining of the event logs without information about non-observable activities is
more di±cult then mining with this information. besides the di®erences in the
petri net models the following variations are used.
the amount of imbalance in execution priorities
in the petri net used for generating the benchmark material each activity has
an execution priority between 0 and 2. if during the generation of an event-trace
more than one activity is enabled, the priority value is used to calculate the
chance that a speci¯c activity is chosen. suppose that in the petri net b1 (cf.
figure 7), the priority of activity bis 0.5 and the priority of activity cis 1.5.
then, after executing activity a(i.e. an and-split) the chance that the next
activity is bis 25% and the chance that the next activity is cis 75% (i.e.
there is a higher chance for the a,c,b,... pattern as for the a,b,c,..). suppose
that in the same petri net b1, the priority of activity fis 0.5 and the priority
of activity gis 1.5. than, after executing activity c(i.e. an xor-split) the
chance for the f; i; m track is 25% and the chance for the g; j-track is 75%.
17our hypothesis is that extreme imbalance will negatively a®ect the rediscovery
process; low frequent, but possible behaviors is not or hardly registered in the log.
completeness of the event log
the quality of mining results are strongly a®ected by the completeness of the
event log. only if a representative and a su±cient large subset of possible be-
haviors is registered in the log, successful mining is possible. it is clear that an
extensive log with extreme imbalances can be incomplete. in the formal approach
in [3], we characterize the class of nets that can be mined correctly. it turns out
that assuming a weak notion of completeness (i.e., if one activity can be followed
by another this should happen at least once in the log), any so-called swf-net
without short loops and implicit places can be mined correctly. notwithstanding
in the heuristicsminer a stronger completeness notation is needed6we will use
this weak completeness notation to indicate the completeness of an event log.
for instance, in the petri net b2 181 directly following relations are possible
(183 after adding an arti¯cial begin- and end-task). it may be that in a small
or very imbalanced event log only 172 di®erent following relations are registered
in the event log. it is clear that both the size of an event log and the imbalance
can in°uence the completeness of the log.
noise
as stated before, we distinguish ¯ve di®erent types noise generating operations:
(i) delete the head of a event sequence, (ii) delete the tail of a sequence, (iii)
delete a part of the body (iv) remove one randomly chosen event, and (v) inter-
change two randomly chosen events. for each type of petri net, we distinguish
six di®erent amounts of imbalance: 01, 02, 05, 10, 20, 50. in the 01 situation the
priority value of an activity has a value between 0.01=0+0.01 and 1.99=2-0.01
(i.e. a very high imbalance). in the 50 situation the priority value of an activitie
has a value between 0.50 and 1.50 (i.e. a low imbalance). for each imbalance
value 10 di®erent imbalance distributions are randomly generated and for each
imbalanced petri net 10 event logs with 1000 traces are generated. for each
petri net this will result in 600 di®erent noise free event logs. we will use the
notation b1p05 0901x00 to indicate an event log based on petri-net b1 with
an imbalance of 0.05 to 1.95 (p05) and random event log number 9 (09). the
x00 indicates that there is no noise in the event log. starting with this noise
free material we generated event logs with a mix7of the ¯ve di®erent noise
types (each noise type has an equal chance to appear) and with six di®erent
6a stronger completeness notation is needed because we use thresholds. for instance
by using a positive observation threshold of 3 at least three observations are needed.
a second reason is the use of measurements not only based on the directly following
relation (i.e. a >> wbanda >>> wbde¯nition 2).
7event logs with only a speci¯c noise type (i.e (h(head), t(tail), w(waist),
o(one), i(interchange), m(mix)) are available. starting with the noise free log
b1p05 0901x00 we will use the event log name b1p0509i05 to indicate 5% noise
interchange noise (i05). in this paper only the experimental results for the mixed
noise are reported.
18noise-levels (1%, 2%, 5%, 10%, 20% and 50% noise). for each noise free event
log this results in 6 new event logs with noise. starting with the noise free log
b1p0509x00 we will use the event log name b1p05 0901m05 to indicate 5%
noise mixed noise (m05). the event log b1 is the event log with 1000 traces of
the original petri net with the same structure but without imbalance.
before we present the mining results of the heuristicsminer on the described
benchmark material we discuss the di®erent measurements we have used to get
an impression of the process mining performance of one mining experiment.
3.3 event log and performance measurements
in a typical process mining experiment without noise an event log (e.g. b1p05 09-
01x00) is used as mining material. after mining the discovered model the same
event log (i.e. b1p05 0901x00) is ¯rst parsed by the mined model and then
the b1 event log (i.e. a complete event log from the original, balanced petri
net). table 3.3 shows the di®erent measurements as registered for one mining
experiment.
we can distinguish four groups of properties/measurements: (i) properties
of the event log, (ii) properties of the mined model, (iii) results of parsing the
mined event log, (iv) results of parsing an balanced-version of the mined event
log. both, a > b (130) and a > b¸b¸are event log measurements that indicate
the weak completeness of the log. a > b (130) = 124 indicates that 124 from the
possible 130 direct following relations (i.e. a >wb) are really one or more times
registered in the event log and a > b ¸3 = 116 indicates that 116 from them
appears more than three times. it is very well possible to calculate more and
other event log properties like the standard deviation from the di®erent activity
frequency. a closer look at the mining results shows that the mined model has
one extra connection (i.e. #conn (20) = 21 and not 20) from activity o to b.
this seems strange, but a closer inspection of the event log b1p05 0901x00
displays 601 registrations of event o directly followed by b and 18 registrations
the other way around. strong imbalance in the original petri net b1p0 09 seems
the cause for this unexpected behavior: the chance of activity b appears very
low 0.11 on a scale of 0.05 to 1.95. the time the heuristicminer require for the
construction of the process model is 7 mili seconds (mining time = 0:07) if we
use the mined model to parse the mined event log (i.e. (iii) results of parsing
the mined event log), the extra connection creates errors: only 399 out of 1000
traces (#correctt1 = 399) are completely correct parsed (i.e. no missing or left
activities). the performance on an event level appears better: 14764 out of 15365
events are correctly parsed. there are only missing activations (#missinga1 =
601), no left activations (#lefta1 = 0). the resulting cpm-¯tness value for
mined event log is 0.980 (¯tness1 = 0.980). the lowest part of table 4 displays
the parsing results for the traces in the event log b1 (i.e. a balanced version
of petri net b1). it is surprising that the results on this event log are slightly
better: 983 correct parsed traces (#correctt1= 399), only 62 missing activities
(#missinga2 = 62), and a cpm-¯tness very close to one (¯tness2 = 0.998).
19item example clari¯cation
event log properties
event log b1p05 0901x00mined event log,
imbalance p05 (between 0.05 and 1.95) no noise
(a > b )¸3116 116 from the 124 direct following relations
(i.e.a >wb) appear three times or more
(a > b ) (130) 124 124 from the 130 possible direct following relations
(i.e.a >wb) are really in the event log
results of mining event log b1p05 0901x00
#conn (20) 21 the number of mined connections
(20 for the original b1 model)
correct 0 1 model is correct, 0 the model has errors
mining time 0.08 sec time needed to construct the process model
results of parsing log b1p05 0901x00 with the mined model
#correcte1 14764 number of correct parsed events
#e1 15365 number of events
#correctt1 399 number of correct parsed traces
#t1 1000 number of traces (1000 for all experiments)
#missinga1 601 number of missing activations
#lefta1 0 left activations
¯tness1 0.980 ¯tness of the mined event log
parsing time 0.08 sec time needed to parse the event log
results of parsing b1 with the mined model
#correcte2 15451 number of correct parsed events of b1
#e2 15513 number of events in log b1
#correctt2 938 number of correct parsed traces
#t2 1000 number of traces (1000 for all experiments)
#missinga2 62 number of missing activations
#lefta2 0 left activations
¯tness2 0.998 ¯tness of the b1 event log
parsing time 0.08 time needed to parse the extra event log
table 4. example of the registered data during mining of one noise free event log.
203.4 heuristicsminer benchmark results
below we present the heuristicsminer process mining benchmark results on the
material as described in subsection 3.2. we ¯rst focus on the in°uence of the
amount of incompleteness in the event logs. after that the focus is on the in°u-
ence of the amount of noise.
tables 5, 6, 7, and 8 display the mining performance results for 2400 event
logs; 600 for every petri net (b1, b2, b3 and b4) and with di®erent imbalances
(p01, p02, p05, p10, p20, p50), but all noise free. the imbalance strongly in°u-
ence the completeness of the event logs. to save space only the most informative
measurements of the measurements discussed above are displayed in the tables.
for instance, there is a strong relation between the number of correct parsed
event, missing and left activities and the ¯tness measurement. for this reason
only the ¯tness is reported. because the time needed for the mining of the event
logs and for parsing an event log is about the same ( ¼0.10 seconds) for all logs
in the same benchmark set, this information is also not presented in the tables.
however, a short general remark about the memory and time complexity of
the heuristicsminer algorithm seems relevant. given an event log w, with kdif-
ferent events and ttraces, the ¯rst step in the mining algorithm is the calculation
of the values of basic relations (i.e. ja >wbj,ja >> wbj, andja >>> wbj). the
traces can be loaded trace by trace, and the information is stored in three k£k
arrays. the time complexity of this part of the algorithm is linear to the number
of traces and k2to the number of di®erent activities. after the calculation of
the values of the basic relations, only these values are used for the construction
of theprocess model. this time complexity of this part of the algorithm is again
k2. the heuristicsminer is implemented java in the prom framework [5] and in
a stand alone version in delphi. using the delphi implementation on a standard
notebook (dell latitude d800) the mining of an event log from b1, b2, b3 en b4
benchmark sets takes in average respectively 0.08, 0.14, 0.16, and 0.12 seconds.
parsing of an event log takes in average respectively 0.08, 0.12, 0.12, and 0.12
seconds.
b1 material: average results (6 x 10 x 10 experiments)
measure p01 p02 p05 p10 p20 p50
a > b ¸3 119.3 117.0 121.2 124.3 126.1 128.9
a > b (max 130) 125.7 125.4 127.1 128.2 128.8 129.8
avg. connections (20) 20.5 20.8 20.4 20 20 20
#correct models 55 60 62100 100 100
avg. ¯tness .986 .984 .992 1.0 1.0 1.0
avg. ¯tness b1 .991 .990 .996 1.0 1.0 1.0
avg. missing 273 285 119 0 0 0
avg. left 10 29 0 0 0 0
table 5. process mining performance results for the 6 x 10 x 10 b1 experiments
(imbalance and incompleteness).
21table 5 shows the performance results for the 6 x 100 b1 experiments. it
is clear that the imbalance in°uence the completeness of the event log (line
a > b in the table). a weak imbalance (p50) results in practically complete
event logs, a strong imbalance in a more incomplete event log (i.e. in average
125.7 di®erent direct succeed pairs, and 119.3 pairs with a frequency of 3 or
higher). it is clear that there is a high correlation between the completeness of
the event log and the quality of the mined process models. all p50, p20, and
p10 models are always correctly mined. for the p01, p02, and p03 models half
of the models are exactly the original model. it seems that the mining error in
the other models is one extra connection (average connections 20.5, 20.8, and
20.4) resulting in some missing activations (average missing 273, 285, 119) and
only a few left activations (average left 10, 29, and 0). the results for the b2,
b3 and b4 models (table 6, 7, and 8) are more or less analog in the sense that a
weaker imbalance results in more complete event logs and better mining results.
more speci¯c observations are discussed below.
b2 material: average results (6 x 10 x 10 experiments)
measure p01 p02 p05 p10 p20 p50
a > b ¸3 162.7 160.2 173.5 166.6 173.1 177.8
a > b (max 183) 173.1 172.4 178.9 176.5 178.9 181.9
avg. connections (27) 27.1 26.9 27.1 26.9 27 27
#correct models 43 34 79 84 96100
avg. ¯tness1 .990 .981 .993 .997 1.0 1.0
avg. ¯tnessb2 .985 .980 .994 .997 1.0 1.0
avg. missing 7311012 262 157 19 0
avg. left 94 94 61 28 2 0
table 6. process mining performance results for the 6 x 10 x 10 b2 experiments
(imbalance and incompleteness).
it is clear that the mining results for the b2 experiments (table 6) are slightly
weaker that the b1 results (table 5). however, in many mining experiments the
exact original model was mined. all mined models can practically mine all events
in the traces resulting in a b1 ¯tness close to one (0.985, 0.980, 0.994, 0.997,
1.0, and 1.0). remark that the average ¯tness of the p01 models on the mining
material (avg. ¯tness1 = 0.990) is higher than the ¯tness on the test material
(avg. ¯tnessb1 = 0.985). it seems that there is a light tendency to (over)¯t the
learning material. again, there are some missing activations and only a few left
one.
model b3 is an extension of b2. however, the mining performance results
for the b3 experiments (table 7) are comparable with b2 results (table 6). all
mined models can practically mine all events in the event-traces resulting in a b1
¯tness close to one (0.980, 0.976, 0.976, 0.992, 0.998, and 1.0). all experiments
but p50, seem to have a slight tendency to (over)¯t the learning material: the
22b3 material: average results (6 x 10 x 10 experiments)
measure p01 p02 p05 p10 p20 p50
a > b ¸3 273.2 247.7 273.6 289.2 304.9 316.0
a > b (max 339) 303.0 286.6 308.3 313.6 321.0 327.9
avg. connections 37.3 37.1 37.3 36.8 37.0 37.0
#correct models 31 24 31 57 91 100
avg. ¯tness1 .984 .978 .979 .993 .999 1.0
avg. ¯tnessb3 .980 .976 .976 .992 .998 1.0
avg. missing 9541212 1280 86 86 0
avg. left 179 167 107 10 10 0
table 7. process mining performance results for the 6 x 10 x 10 b3 experiments
(imbalance and incompleteness).
average ¯tness of the mined models on the mining material (avg. ¯tness1) is
higher that the ¯tness on the test material (¯tnessb1). again, there are some
missing activations and only a few left one. apart from that it is surprising that
average completeness of the p02 material is relatively low ( a > b = 286.6). also
the average ¯tness1 and ¯tnessb3 of the mined models is low (0.978 and 0.976)
indicating that there is a high correlation between the completeness of a event
log on the mining results.
b4 material: average results (6 x 100 experiments)
measure p01 p02 p05 p10 p20 p50
a > b¸3 232.8 214.3 233.0 246.3 257.4 265.9
a > b (max 274) 253.7 243.7 258.4 262.8 267.5 271.2
avg. connections (34) 34.1 34.0 34.1 33.8 34.0 34.0
#correct models 610 20 39 62 94
avg. ¯tness1 0.952 0.950 0.968 0.980 0.987 0.998
avg. ¯tnessb4 0.949 0.952 0.961 0.980 0.988 0.999
avg. missing 2284 2214 1851 938 539 60
avg. left 365 306 196 124 60 9
table 8. process mining performance results for the 6 x 100 b4 experiments (imbalance
and incompleteness).
in the event log of the b4 experiments (table 8) the hidden activities (dum1,
dum2, and dum3) are removed out of the b3 event logs. mining the b4 material
seems more di±cult then mining of the b3 material (table 7). this is in line with
¯tness results of the b3 and b4 experiments (0.980 vs. 0.949, 0.976 vs. 0.952,
0.976 vs. 0.961, 0.992 vs. 0.980, 0.998 vs. 0.988, and 1.0 vs. 0.999). however,
specially for the experiments with only a weak imbalance the di®erences are
minimal. because the b4 material is the b3 material with the hidden activities
23removed, the average completeness of the p02 material is relatively low ( a > b
= 243.7). however, the drop in the average ¯tness1 and ¯tnessb4 of the p02
experiments isn't so distinctly as in the b3 experiments. so far the mining results
of event logs without noise.
tables 9, 10, 11, and 13 displays the mining performance results for 4 x 3600
= 14400 event logs; 6 x 6 x 10 x 10 = 3600 for every petri net (b1, b2, b3
and b4), 10 x 10 event logs with di®erent imbalances (p01, p02, p05, p10, p20,
p50), and with di®erent noise levels (1%, 2%, 5%, 10%, 20%, and 50% noise). the
presence of noise is re°ected in the average amount of available direct succeed
relations (the a > b -line in the tables). remark that the number of di®erent a > b
relations in a event log with noise can be higher than the maximum number of
di®erent a > b patterns in a noise free event log. the general observation is
that 1%, 2%, 5%, and 10% hardly in°uence the mining performance results (the
average number of correct mined models, average ¯tness measurements, and
the average missing and left activations). for instance, in the b1 experiments
(table 9) with a high imbalance (the p01 column) the sum of the correct mined
models drops from 55 (no noise, table 5) to respectively 55 (1% noise), 54 (2%
noise), 55 (5% noise), 57 (10% noise), 48 (20% noise), and 36 (50% noise). the
¯tness for the b1 materials (¯tness3) drops from 0.991 (no noise, table 5) to
respectively 0.991 (1% noise), 0.991 (2%), 0.990 (5%), 0.989 (10%), 0.986 (20%),
and 0.974 (50% noise). the missing/left activations are respectively 273/10 (0%
noise, table 5), 277/10 (1%), 277/18 (2%), 291/18 (5%), 302/39 (10%), 330/99
(20%), and 751/53 (50% noise). in all four tables (9, 10, 11, 13) the in°uence of
1% to 20% noise is slight; with 50% the decrease in mining performance is more
distinctly, but the heuristicsminer is still able to construct a process model with
a relatively high ¯tness on learning and test material.
4 conclusion
in this paper, we ¯rst introduced the challenging problem of process mining. we
distinguish three di®erent perspectives: (1) the process perspective, (2) the or-
ganizational perspective and (3) the case perspective. we focused on the process
perspective. hereafter, we presented the details of the three steps of the heuris-
ticsminer algorithm: step (1) the construction of the dependency graph, step (2)
for each activity, the construction the input- and output expressions and step
(3) the search for long distance dependency relations. simultaneously we intro-
duced a new process modelling language (e.g. causal matrices) and we illustrate
the advantages of causal matrices during the mining of hidden activities. in the
experimental session we showed how the heuristicsminer can deal with noise and
low frequent behavior. in practical situation (i.e. with event log with thousands
of traces, low frequent behavior and some noise) the heuristicsminer can focus
on all behavior in the event log, or only the main behavior.
in this paper we ¯rst introduced the challenging process mining domain.
hereafter, we presented the details of the three steps of the heuristicsminer
algorithm: step (1) the construction of the dependency graph, step (2) for each
24b1 material: average results (6 x 6 x 10 x 10 experiments)
noise level 1% p01 p02 p05 p10 p20 p50
avg of a > b¸3 119.4 117.1 121.3 124.5 126.3 129.0
avg of a > b (max 130) 135.1 135.1 136.3 137.1 138.2 137.8
avg of conn 20.5 20.8 20.4 20.0 20.0 20.0
sum of correct 55 60 61100 100 100
avg of ¯tness 0.985 0.983 0.991 0.999 0.999 0.999
avg of ¯tness2 0.986 0.984 0.992 1.000 1.000 1.000
avg of ¯tness3 0.991 0.989 0.996 1.000 1.000 1.000
avg of missing3 277.3 292.6 124.5 0.0 0.0 0.0
avg of left3 9.934.5 0.0 0.0 0.0 0.0
noise level 2% p01 p02 p05 p10 p20 p50
avg of a > b¸3 119.9 117.6 121.8 125.0 126.6 129.4
avg of a > b (max 130) 142.1 141.7 144.0 145.0 145.2 146.5
avg of conn 20.5 20.8 20.4 20.0 20.0 20.0
sum of correct 54 60 61100 100 100
avg of ¯tness 0.984 0.982 0.990 0.998 0.998 0.998
avg of ¯tness2 0.986 0.984 0.992 1.000 1.000 1.000
avg of ¯tness3 0.991 0.989 0.996 1.000 1.000 1.000
avg of missing3 276.7 288.4 120.0 0.0 0.0 0.0
avg of left3 18.0 37.5 0.0 0.0 0.0 0.0
noise level 5% p01 p02 p05 p10 p20 p50
avg of a > b¸3 122.9 121.1 125.1 127.7 129.7 132.1
avg of a > b (max 130) 159.2 161.2 160.2 161.7 162.7 164.6
avg of conn 20.5 20.8 20.4 20.0 20.0 20.0
sum of correct 55 60 62100 100 100
avg of ¯tness 0.980 0.980 0.987 0.994 0.994 0.994
avg of ¯tness2 0.986 0.985 0.992 1.000 1.000 1.000
avg of ¯tness3 0.990 0.989 0.996 1.000 1.000 1.000
avg of missing3 291.1 276.0 119.4 0.0 0.0 0.0
avg of left3 18.0 57.6 0.0 0.0 0.0 0.0
noise level 10% p01 p02 p05 p10 p20 p50
avg of a > b¸3 131.3 128.7 132.8 135.1 136.6 139.2
avg of a > b (max 130) 179.6 177.8 180.3 181.9 182.5 183.0
avg of conn 20.5 20.8 20.4 20.0 20.0 20.0
sum of correct 57 61 60100 100 100
avg of ¯tness 0.975 0.973 0.981 0.989 0.989 0.989
avg of ¯tness2 0.986 0.984 0.992 1.000 1.000 1.000
avg of ¯tness3 0.989 0.986 0.996 1.000 1.000 1.000
sum of correct 57 61 60100 100 100
avg of missing3 301.7 340.3 125.1 0.0 0.0 0.0
avg of left3 39.3 83.6 0.0 0.0 0.0 0.0
noise level 20% p01 p02 p05 p10 p20 p50
avg of a > b¸3 144.7 142.8 145.5 149.2 151.0 153.1
avg of a > b (max 130) 201.8 202.0 203.6 206.2 206.4 208.1
avg of conn 20.7 20.9 20.6 20.2 20.1 20.1
sum of correct 49 58 62 98100 100
avg of ¯tness 0.965 0.963 0.970 0.977 0.977 0.977
avg of ¯tness2 0.986 0.985 0.991 1.000 1.000 1.000
avg of ¯tness3 0.986 0.984 0.996 1.000 1.000 1.000
avg of missing3 330.0 347.4 109.7 10.4 0.0 0.0
avg of left3 99.6133.8 19.2 0.0 0.0 0.0
noise level 50% p01 p02 p05 p10 p20 p50
avg of a > b¸3 178.7 175.1 179.4 184.0 184.7 186.9
avg of a > b (max 130) 232.9 231.5 233.3 235.6 236.2 237.8
avg of conn 27.4 27.6 27.4 26.4 26.6 26.7
sum of correct 36 40 45 69 73 61
avg of ¯tness 0.927 0.930 0.937 0.941 0.942 0.938
avg of ¯tness2 0.974 0.975 0.982 0.990 0.991 0.987
avg of ¯tness3 0.974 0.970 0.984 0.990 0.990 0.987
avg of missing3 750.9 718.7 415.5 290.4 280.0 360.0
avg of left3 53.0209.0 81.6 30.8 15.1 40.5
table 9. performance results for the 6 x 6 x 10 x 10 b1 experiments (imbalance,
incompleteness and noise).25b2 material: average results (6 x 6 x 10 x 10 experiments)
noise level 1% p01 p02 p05 p10 p20 p50
avg of a > b¸3 162.8 160.1 173.5 166.7 173.2 177.9
avg of a > b (max 183) 181.2 182.6 187.6 186.2 188.4 191.2
avg of conn 27.1 26.9 27.1 26.9 27.0 27.0
sum of correct 43 34 79 84 96100
avg of ¯tness 0.990 0.981 0.993 0.997 0.999 0.999
avg of ¯tness2 0.990 0.981 0.993 0.997 1.000 1.000
avg of ¯tness3 0.985 0.980 0.994 0.997 1.000 1.000
avg of missing3 728.2 1000.8 262.3 157.2 19.0 0.0
avg of left3 95.1 93.9 61.2 28.4 2.2 0.0
noise level 2% p01 p02 p05 p10 p20 p50
avg of a > b¸3 163.0 160.3 173.7 167.0 173.5 178.1
avg of a > b (max 183) 190.3 190.5 196.1 194.1 196.5 198.0
avg of conn 27.1 26.9 27.1 26.9 27.0 27.0
sum of correct 43.0 34.0 79.0 84.0 96.0100.0
avg of ¯tness 1 1 1 1 1 1
avg of ¯tness2 0.990 0.982 0.993 0.997 1.000 1.000
avg of ¯tness3 0.985 0.981 0.994 0.997 1.000 1.000
avg of missing3 736.780 981.530 262.280 157.150 18.990 0.000
avg of left3 93.7 97.3 61.2 28.4 2.2 0.0
noise level 5% p01 p02 p05 p10 p20 p50
avg of a > b¸3 165.4 162.9 176.0 169.3 175.5 180.3
avg of a > b (max 183) 208.4 209.9 215.5 213.2 215.5 217.6
avg of conn 27.1 26.9 27.0 26.9 27.0 27.0
sum of correct 42 35 78 84 96100
avg of ¯tness 0.986 0.979 0.991 0.994 0.997 0.997
avg of ¯tness2 0.989 0.981 0.993 0.997 1.000 1.000
avg of ¯tness3 0.984 0.981 0.994 0.997 1.000 1.000
avg of missing3 804.1 986.6 251.1 157.2 19.0 0.0
avg of left3 103.0 96.7 63.4 28.4 2.2 0.0
noise level 10% p01 p02 p05 p10 p20 p50
avg of a > b¸3 172.8 171.4 183.3 176.5 182.7 186.9
avg of a > b (max 183) 230.0 230.6 236.8 234.6 237.9 239.6
avg of conn 27.1 26.8 27.0 26.9 27.0 27.0
sum of correct 42 31 78 81 96100
avg of ¯tness 0.983 0.978 0.988 0.991 0.993 0.994
avg of ¯tness2 0.989 0.982 0.994 0.997 1.000 1.000
avg of ¯tness3 0.984 0.980 0.995 0.996 1.000 1.000
avg of missing3 809.1 973.5 241.1 167.4 19.0 0.0
avg of left3 107.5 117.4 63.4 29.8 2.2 0.0
noise level 20% p01 p02 p05 p10 p20 p50
avg of a > b¸3 187.9 189.1 199.0 192.2 198.3 202.3
avg of a > b (max 183) 256.3 255.5 264.1 261.7 266.1 269.1
avg of conn 27.3 26.9 27.0 26.9 27.0 27.0
sum of correct 44 31 80 80 94 99
avg of ¯tness 0.978 0.972 0.983 0.985 0.986 0.988
avg of ¯tness2 0.989 0.981 0.994 0.998 1.000 1.000
avg of ¯tness3 0.984 0.980 0.995 0.996 0.999 1.000
avg of missing3 769.5 1018.6 219.1 163.9 32.5 2.2
avg of left3 115.5 118.2 59.3 34.9 2.2 2.2
noise level 50% p01 p02 p05 p10 p20 p50
avg of a > b¸3 221.6 222.6 235.6 228.3 235.5 238.5
avg of a > b (max 183) 294.7 286.4 301.4 299.0 306.0 308.2
avg of conn 31.2 29.4 29.8 30.6 30.4 30.2
sum of correct 39 29 78 73 95 94
avg of ¯tness 0.965 0.961 0.969 0.968 0.970 0.970
avg of ¯tness2 0.990 0.980 0.994 0.996 1.000 0.999
avg of ¯tness3 0.982 0.976 0.995 0.995 0.999 0.999
avg of missing3 874.6 1155.3 209.8 244.4 31.2 45.7
avg of left3 116.2 194.7 80.2 56.1 4.4 7.5
table 10. performance results for the 6 x 6 x 10 x 10 b2 experiments (imbalance,
incompleteness and noise).26b3 material: average results (6 x 6 x 10 x 10 experiments)
noise level 1% p01 p02 p05 p10 p20 p50
average of a > b¸3 273.3 247.8 273.6 289.3 304.9 316.1
average of a > b (max 339) 311.8 296.4 317.5 322.5 330.1 337.3
average of conn 37.2 37.1 37.3 36.8 37.0 37.0
sum of correct 31 24 31 55 91100
average of ¯tness 0.983 0.978 0.978 0.992 0.998 0.999
average of ¯tness2 0.984 0.978 0.979 0.992 0.999 1.000
average of ¯tness3 0.980 0.976 0.976 0.991 0.998 1.000
average of missing3 964.2 1211.5 1263.1 424.4 86.4 0.0
average of left3 178.9 166.5 99.3 79.6 9.7 0.0
noise level 2% p01 p02 p05 p10 p20 p50
average of a > b¸3 273.6 248.0 273.7 289.5 305.2 316.3
average of a > b (max 339) 320.9 303.7 326.0 331.4 338.6 344.6
average of conn 37.2 37.1 37.2 36.8 37.0 37.0
sum of correct 31 24 32 57 90100
average of ¯tness 0.950 0.950 0.966 0.979 0.985 0.997
average of ¯tness2 0.984 0.978 0.979 0.993 0.999 1.000
average of ¯tness3 0.980 0.975 0.976 0.992 0.998 1.000
average of missing3 948.7 1229.0 1237.4 399.8 87.8 0.0
average of left3 184.0 168.0 99.9 77.8 11.0 0.0
noise level 5% p01 p02 p05 p10 p20 p50
average of a > b¸3 275.7 250.2 275.6 291.7 307.0 317.9
average of a > b (max 339) 341.0 324.2 345.5 351.1 358.8 364.9
average of conn 37.2 37.1 37.3 36.8 37.0 37.0
sum of correct 30 24 31 56 89100
average of ¯tness 0.982 0.975 0.976 0.990 0.996 0.997
average of ¯tness2 0.984 0.978 0.979 0.993 0.999 1.000
average of ¯tness3 0.980 0.975 0.976 0.992 0.998 1.000
average of missing3 945.5 1251.6 1276.2 401.1 89.1 0.0
average of left3 184.4 169.1 99.6 79.2 12.3 0.0
noise level 10% p01 p02 p05 p10 p20 p50
average of a > b¸3 283.3 257.2 282.1 297.0 313.6 324.2
average of a > b (max 339) 366.2 349.5 369.1 374.4 383.9 389.9
average of conn 37.2 37.1 37.2 36.8 37.0 37.0
sum of correct 29 25 32 55 90 98
average of ¯tness 0.978 0.973 0.974 0.985 0.992 0.994
average of ¯tness2 0.983 0.978 0.980 0.991 0.998 1.000
average of ¯tness3 0.979 0.976 0.976 0.990 0.998 1.000
average of missing3 993.0 1212.9 1229.1 495.5 109.7 2.7
average of left3 185.5 171.9 104.3 83.3 10.6 2.7
noise level 20% p01 p02 p05 p10 p20 p50
average of a > b¸3 299.0 272.7 297.3 312.7 328.5 338.8
average of a > b (max 339) 397.7 380.7 404.6 407.7 414.5 423.9
average of conn 37.1 37.1 37.2 36.8 37.0 37.0
sum of correct 30 23 28 54 88100
average of ¯tness 0.972 0.966 0.966 0.979 0.986 0.988
average of ¯tness2 0.983 0.977 0.978 0.991 0.998 1.000
average of ¯tness3 0.977 0.974 0.975 0.990 0.998 1.000
average of missing3 1107.4 1289.6 1327.6 486.7 102.1 0.0
average of left3 199.4 178.2 103.7 86.9 12.8 0.0
noise level 50% p01 p02 p05 p10 p20 p50
average of a > b¸3 335.3 310.6 335.2 349.3 366.2 377.4
average of a > b (max 339) 448.0 429.7 455.4 460.2 467.8 474.3
average of conn 40.1 39.8 39.4 38.8 39.1 38.7
sum of correct 17 12 25 47 63 87
average of ¯tness 0.953 0.954 0.947 0.960 0.964 0.970
average of ¯tness2 0.980 0.981 0.977 0.990 0.994 0.999
average of ¯tness3 0.972 0.975 0.973 0.989 0.994 0.999
average of missing3 1377.3 1182.3 1375.0 525.5 313.2 68.0
average of left3 185.5 250.7 138.9 112.7 37.1 7.5
table 11. performance results for the 6 x 6 x 10 x 10 b3 experiments (imbalance,
incompleteness and noise).27b4 material: average results (6 x 6 x 10 x 10 experiments)
noise level 1% p01 p02 p05 p10 p20 p50
average of a > b¸3 232.9 214.4 233.1 246.4 257.4 266.0
average of a > b (max 274) 262.4 252.6 267.1 271.7 275.7 279.5
average of conn 34.1 34.0 34.1 33.8 34.0 34.0
sum of correct 6 10 20 40 62 94
average of ¯tness 0.951 0.951 0.967 0.980 0.986 0.998
average of ¯tness2 0.952 0.952 0.968 0.980 0.987 0.998
average of ¯tness3 0.949 0.953 0.961 0.980 0.988 0.999
average of missing3 2303.0 2126.6 1849.5 910.8 539.5 60.4
average of left3 364.8 304.6 197.5 124.5 59.6 9.4
noise level 2% p01 p02 p05 p10 p20 p50
average of a > b¸3 233.1 214.8 233.3 246.6 257.6 266.3
average of a > b (max 274) 271.0 260.0 275.0 279.5 284.2 287.7
average of conn 34.1 34.0 34.1 33.8 34.0 34.0
sum of correct 6.0 9.0 20.0 37.0 61.0 93.0
average of ¯tness 1 1 1 1 1 1
average of ¯tness2 0.952 0.951 0.967 0.980 0.987 0.998
average of ¯tness3 0.949 0.952 0.960 0.980 0.989 0.998
average of missing3 2316.2 2170.9 1890.4 930.2 534.4 70.4
average of left3 345.1 305.2 196.1 126.5 59.5 11.0
noise level 5% p01 p02 p05 p10 p20 p50
average of a > b¸3 236.0 217.3 236.0 248.8 259.6 268.2
average of a > b (max 274) 289.3 279.5 293.5 296.1 301.3 305.4
average of conn 34.1 34.0 34.1 33.8 34.0 34.0
sum of correct 6 9 18 38 61 90
average of ¯tness 0.949 0.947 0.961 0.976 0.983 0.994
average of ¯tness2 0.952 0.950 0.964 0.979 0.986 0.998
average of ¯tness3 0.948 0.951 0.957 0.979 0.988 0.998
average of missing3 2329.8 2215.1 2022.4 954.5 573.8 82.0
average of left3 354.0 315.7 194.9 126.2 66.4 18.9
noise level 10% p01 p02 p05 p10 p20 p50
average of a > b¸3 243.4 224.8 242.2 256.0 266.3 274.7
average of a > b= 130 310.6 300.3 313.8 318.0 322.8 326.5
average of conn 34.1 34.0 34.0 33.8 34.0 34.0
sum of correct 5 8 19 39 56 93
average of ¯tness 0.946 0.943 0.961 0.973 0.978 0.991
average of ¯tness2 0.953 0.949 0.967 0.980 0.985 0.998
average of ¯tness3 0.949 0.952 0.960 0.980 0.986 0.998
average of missing3 2280.8 2200.0 1874.1 939.9 630.6 70.6
average of left3 372.3 313.6 210.8 126.5 74.5 11.0
noise level 20% p01 p02 p05 p10 p20 p50
average of a > b¸3 258.4 239.8 257.6 270.4 281.8 290.1
average of a > b (max 274) 336.1 324.3 340.4 343.0 349.2 351.9
average of conn 34.0 34.0 34.0 33.8 34.0 34.0
sum of correct 4 7 15 33 56 84
average of ¯tness 0.942 0.938 0.952 0.964 0.972 0.982
average of ¯tness2 0.955 0.950 0.966 0.978 0.986 0.996
average of ¯tness3 0.948 0.951 0.959 0.977 0.987 0.996
average of missing3 2306.8 2205.3 1929.3 1041.9 587.2 161.6
average of left3 387.9 339.0 219.9 147.6 70.7 33.1
noise level 50% p01 p02 p05 p10 p20 p50
average of a > b¸3 291.9 272.9 291.8 303.5 315.2 322.9
average of a > b (max 274) 377.2 364.1 380.1 381.5 388.2 389.4
average of conn 37.8 37.3 37.0 36.9 36.9 36.7
sum of correct 3 1 18 29 41 78
average of ¯tness 0.927 0.922 0.932 0.945 0.953 0.964
average of ¯tness2 0.956 0.951 0.963 0.978 0.986 0.997
average of ¯tness3 0.946 0.949 0.956 0.977 0.986 0.996
average of missing3 2449.3 2283.8 2025.0 1056.5 593.5 142.8
average of left3 382.9 353.4 245.6 139.0 120.5 41.9
table 12. performance results for the 6 x 6 x 10 x 10 b4 experiments (imbalance,
incompleteness and noise).28activity, the construction the input- and output expressions and step (3) the
search for long distance dependency relations. simultaneously we introduced a
new process modelling language (e.g. causal matrices) and we illustrate the
advantages of causal matrices during the mining of hidden activities. in the
experimental session we ¯rst illustrate how the heuristicsminer can deal with
noise and low frequent behavior. in practical situation (i.e. with event log with
thousands of traces, low frequent behavior and some noise) the heuristicsminer
can focus on all behavior in the event log, or only the main behavior. after that,
we introduced material (12.000 di®erent event logs) and measurements by which
the performance of process mining algorithms can be measured. finally, the
benchmark material and the measurements are used for measuring the mining
performance of the heuristicsminer. the most striking results is the robustness
of the heuristicsminer for noise.
although our approach is based on causal matrices, it can be applied to
other models with executable semantics, e.g., formalizations of petri nets, epcs,
bpmn, or uml activity diagrams. in our future work, we would like to extend
the benchmark with more realistic material (i.e. from real processes) so that
it becomes possible to benchmark also the other process mining perspectives:
the organizational, social, performance, and the case perspective. besides this,
research for better process performance measurements remains challenging (ref
xxx bpm 06). an other priority is to apply process mining in a wide variety of
practical situations.
references
1.w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. work°ow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
2.w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining , special
issue of computers in industry, volume 53, number 3. elsevier science publishers,
amsterdam, 2004.
3.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
4.a.k. alves de medeiros. genetic process mining . phd thesis, eindhoven, univer-
sity of technology, eindhoven, the netherlands, 2006.
5.b. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters, and
w.m.p. van der aalst. the prom framework: a new era in process mining tool
support. in g. ciardo and p. darondeau, editors, application and theory of petri
nets 2005 , volume 3536 of lecture notes in computer science , pages 444{454.
springer-verlag, berlin, 2005.
6.l. maruster, w.m.p. van der aalst, a.j.m.m. weijters, a. van den bosch, and
w. daelemans. automated discovery of work°ow models from hospital data.
in c. dousson, f. hä oppner, and r. quiniou, editors, proceedings of the ecai
workshop on knowledge discovery and spatial data , pages 32{36, 2002.
7.a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. using ge-
netic algorithms to mine process models: representation, operators and results.
29beta working paper series, wp 124, eindhoven university of technology, eind-
hoven, 2004.
8.a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic pro-
cess mining: a basic approach and its challenges. in c. bussler et al., editor,
bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 203{215. springer-verlag, berlin,
2006.
9.w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
10.j. scott. social network analysis . sage, newbury park ca, 1992.
11.l. wen, j. wang, and j.sun. detecting implicit dependencies between tasks from
event logs. in x. zhou, j. li, h.t. shen, m. kitsuregawa, and y. zhang, editors,
proc. of the apweb conference , volume 3841 of lncs , pages 591{603. springer
verlag, 2006.
30appendix
a
p1 p2
b
p3 p4c
p5
d
p6e
p9f
p7 g
p11 h
p8i
p10
j
p14k
p12l
p13m
n
p15o
p16
p
pepb
fig. 7. petri net b1 with 16 tasks, without loops.a
p1 p2
b
p3 p4c
p5
d
p6 e
p9f
p7g
p11
h
p8i
p10 j
p14k
p12l
p13m
n
p15o
p16
p
peq
r
dum1pbfig. 8. petri net b2. it is an extension of net b1 with di®erent types of loops (i.e. a
long loop, a length two loop and recursion.a
p1 p2
b
p3 p4c
p5
d
p6 e
p9f
p7g
p11
h
p8i
p10 j
p14k
p12l
p13m
n
p15o
p16
p
peq
rs
p19t
p20
u
p21v
p22
w
p23x
p24
dum1dum2
p17 p18
dum3pbfig. 9. petri net b3 (and b4) is an extension of b2 with extra parallel behavior. in the
event logs of the b3 experiments the non-observable tasks (dum1, dum2, and dum3)
are recorded in the event log, in the b4 experiments this tasks are not registered in the
log.procedure longdistancedependency;
var i,j: integer;
score, hnc: real;
begin
for i:=n_events downto 1 do
begin
for j:=n_events downto 1 do
begin
longdistancedependecy := (|event[i]>>>event[j]|/
|event[i]|+1) - (|||event[i]| - |event[j]|||/|event[i]|);
if (|event[i]>>>event[j]|>=absusethres) and (longdistancedependecy>=absthres)) then
begin
if escapetoendpossible(event[i],event[j],[]) then
addconnection(event[i],event[j]);
end;
end;
end;
end;
function escapetoendpossiblef(event[x], event[y]: activityt; visiteds: intsett): boolean;
var i,j: integer;
max, min, minhulp: real;
begin
if ((x in visiteds) or (x==y) or (event[y]==endactivity)) then
begin
escapetoendpossiblef:=false; exit;
end;
with event[x] do
begin
if (card(outorcluster[1], n_events) = 0) then
// x is eee event
begin
escapetoendpossiblef := true; exit;
end;
// iteration over the or-subsets
for i:=1 to n_output_clusters do
begin
// test if output set i has at least one eee-escape!
outorescapepossible := false;
for j:=1 to n_events do
begin
if (j in outorcluster[i]) then
begin
if escapetoendpossiblef(event[j], event[y], visiteds + [event[x]]) then
orsetescapepossible := true;
end;
end;
// if there is not a eee-escape for i
if (not orsetescapepossible) then
begin
escapetoendpossiblef:=false; exit;
end;
end;
// for all i-or sets escaping is possible
escapetoendpossiblef:=true;
end; // endwith
end;
table 13. pseudo code for the \long-distance-dependency-heuristic".