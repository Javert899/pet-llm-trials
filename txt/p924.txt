interest-driven discovery of local process
models
niek tax1, benjamin dalmas2, natalia sidorova1, wil m.p. van der aalst1, and
sylvie norre2
1eindhoven university of technology, department of mathematics and computer
science, p.o. box 513, 5600mb eindhoven, the netherlands
{n.tax,n.sidorova,w.m.p.v.d.aalst}@tue.nl
2clermont-auvergne university, limos cnrs umr 6158, aubi ere, france
{benjamin.dalmas,sylvie.norre}@isima.fr
abstract. local process models (lpm) describe structured fragments
of process behavior occurring in the context of less structured business
processes. traditional lpm discovery aims to generate a collection of
process models that describe highly frequent behavior, but these models do
not always provide useful answers for questions posed by process analysts
aiming at business process improvement. we propose a framework for
goal-driven lpm discovery , based on utility functions and constraints. we
describe four scopes on which these utility functions and constrains can
be dened, and show that utility functions and constraints on dierent
scopes can be combined to form composite utility functions/constraints.
finally, we demonstrate the applicability of our approach by presenting
several actionable business insights discovered with lpm discovery on
two real life data sets.
keywords: process discovery, pattern mining, goal-driven data mining
1 introduction
process mining [ 1] has emerged as a new discipline aiming at the improvement of
business processes through the analysis of event data recorded by information sys-
tems. such event logs capture the dierent steps (events) that are recorded for each
instance of the process (case), and record for each of those steps what was done,
by whom, for whom, where, when, etc. process discovery, one of the main tasks in
the process mining eld, is concerned with the discovery of an interpretable model
from this event log such that this model accurately describes the process. the pro-
cess models obtained give insight in what is happening in the process, and can be
used as a starting point for dierent types of further analysis, e.g. bottleneck analy-
sis [14], and checking compliance with rules and regulations [ 18]. many algorithms
have been proposed for process discovery, e.g., [3,13,11,12,5] (see section 2).
one type of process discovery is local process model (lpm) discovery [ 22,21],
which is concerned with the discovery of a ranking of process models, where
each individual lpm describes only a subset of the process activities. each lpmarxiv:1703.07116v1  [cs.db]  21 mar 20172
create purchase
ordersend order
record
receipt
(a)
change
price
change
vendorcancel
order (b)
fig. 1. (a)a frequent local process model with low utility, and (b)a non-frequent
local process model with high utility.
describes one frequent pattern in a process model notation (e.g. petri net [ 15],
bpmn [ 16], or uml activity diagram [ 7]). this gives an lpm the full expressive
power of the respective process model notation and allows it to represent more
complex non-binary relations that cannot be expressed in declarative process mod-
els. lpms aim to describe frequent local pieces of behavior, therefore, lpms can
be seen as a special form of frequent pattern mining [6] where each pattern is a pro-
cess model. however, lpms are not limited to subsequences [ 20] or episodes [ 10].
a recent trend in the frequent pattern mining eld is to incorporate utility into
the pattern selection framework, such that not just the most frequent patterns
are discovered, but instead patterns are discovered that address typical business
concerns, such as the patterns that represent high nancial costs. shen et al. [ 19]
were the rst to introduce utility-based itemset mining. since then, utility-based
pattern mining has spread to dierent types of pattern mining, including sequen-
tial pattern mining [ 23]. utility-based pattern mining techniques assume that
the value of each data point with respect to a certain business question is known
and then discover the optimal patterns in terms of the value that they represent.
imagine a purchase-to-pay process and as a process analyst we are interested
in where in the process the employees of the company spend most of their time.
figure 1 shows two lpms that could be discovered from such an event log. figure
1a is a process fragment that describes the creation of a purchase order, which
is followed by both the sending of the order and the recording of the receipt
in an arbitrary order. this process fragment is frequent, as they are required
steps for each order. figure 1b describes a process fragment where the order is
canceled after the price or the vendor of the order is changed. even though the
process fragment of figure 1b is likely to be infrequent, it will take considerable
resources of the department as canceling an order is an undesired action and
considerable time will be spend trying to prevent it. existing support-based
lpm discovery [ 22] would not be able to discover figure 1b because of its low
frequency, motivating the need for utility-based lpm discovery.
in this paper we propose a framework to discover lpms based on their utility
in the context of a particular business question. furthermore, we give an ex-
tensive overview of utility functions and their relevance in a bpm context. the
techniques described in this paper have been implemented in the prom process
mining framework [4] as part of the localprocessmodeldiscovery1package.
1https://svn.win.tue.nl/trac/prom/browser/packages/
localprocessmodeldiscovery3
algorithm formal/informal global/local
declare miner[13] formal global
language-based regions [3] formal global
inductive miner [11] formal global
lpm discovery [22] formal local
fuzzy miner [5] informal global
episode miner [10] informal local
table 1. a classication of process discovery methods.
this paper is organized as follows. section 2 describes related work. section
3 introduces the basic concepts used in this paper. section 4 introduces utility
functions and constraints in the context of lpms. in section 5 we demonstrate
utility-based lpm discovery on two real-life event logs and show that we can
obtain actionable insights. we conclude the paper in section 6.
2 related work
in this section we discuss two areas of related work. first we discuss existing
work in process discovery and position local process model (lpm) discovery
in the process discovery landscape. secondly, we discuss related work from the
pattern mining eld.
2.1 process discovery
process discovery techniques can be classied in several dimensions. some process
discovery techniques discover formal process models , where the behavior allowed by
the model is formally dened, while others discover informal process models with
unclear semantics. orthogonally, process discovery algorithms can be classied
inend-to-end (global) techniques that produce models that describe the logged
process executions fully from start to end, and pattern-based (local) techniques
that produce models that describe the behavior of the log only partially. table 1
provides a classication of some existing process discovery techniques, and shows
that lpm discovery is the only technique available which provides models that
are both formal and local.
2.2 interest-driven pattern mining
lpms are able to express a richer set of relations (e.g. loops, xor-constructs,
concurrency) than sequential pattern mining techniques, which are limited to the
sequential constructs. the mining of patterns driven by the interest of an analyst
is known in the pattern mining eld as high-utility pattern mining. several
high-utility sequential pattern mining algorithms have been proposed [ 23,9,24].
sequential pattern mining techniques take as input a sequence database , a concept
which is closely related to event logs in process mining. sequence databases consist
of sequences of tasks (called items ). some pattern mining techniques additionally
assume the timestamp of each item to be logged. sequence databases are not4
as rich as events logs found in process mining, where many data attributes are
logged both for events and cases.
a second approach to interest-driven pattern mining pattern is constraint-
based sequential pattern mining. in contrast to high-utility pattern mining,
which gives preference to more useful patterns, constraint-based pattern mining
completely removes non-useful ones. pei et al. [ 17] provides a categorization of
pattern constraints, consisting of four types of constraints on the ordering of
items in the pattern and two types of constraints on the timestamps of the items
in the log that are instances of a pattern. this richer notion of an event log allows
us to dene utility and constraints in a more exible way (e.g. using event or case
properties) compared to high-utility pattern mining techniques which dene utility
as mapping from an item type to utility and constraint-based pattern mining
which limit the utility denition to ordering information and the time domain.
3 basic denitions
in this section we introduce notations related to event logs, petri nets, and local
process models (lpms), which are used in later sections of this paper.
3.1 events, traces, and event logs
for a given set a,adenotes the set of all sequences over aand=ha1;a2;:::;ani
is a sequence of length n, where(i) =ai.hiis the empty sequence and 12is
the concatenation of sequences 1and2.ais the projection of ona, e.g.
ha;b;c;a;b;cifa;cg=ha;c;a;ci.
letebe the event universe, i.e., the set of all possible event identiers. we
assume that events are characterized by various properties, e.g., an event has a
timestamp, corresponds to an activity, is performed by a particular resource, etc.
we do not impose a specic set of properties, however, we assume that two of
these properties are the activity and timestamp of an event, i.e., there is a function
activity :e!a that assigns to each event an activity from a nite set of process
activitiesa, and a function time:e!t that maps each event to the time do-
maint. in general, we write p(e) to obtain the value of any property pof evente.
anevent log is a set of events, each linked to one trace and globally unique,
i.e., the same event cannot occur twice in a log. a trace in a log represents the
execution of one case. a trace is a nite non-empty sequence of events 2e
such that each event appears only once and time is non-decreasing, i.e., for
1i<jjj:(i)6=(j) andtime((i))time((j)).cis the set of all possible
traces. an event log is a set of traces lcsuch that each event appears at most
once in the entire log.
given a trace and a property, we often need to compute a sequence consisting
of the value of this property for each event in the trace. to this end, we lift the
functionpthat maps an event to the value of its property p, in such a way that
we can apply it to sequences of events (traces).5
process case
activity activity 
instanceevent
event
attributeposit ion
transaction 
type
11
11
1
11 resource
t
e any datacase
attribute
1case id
description
any data
timestamp
connector1m
t
e
a
mmtttt
t
t
e
at
e
a
t
et
e
t
e
t
e
t
e
fig. 2. basic logging concepts conceptualized in a class diagram.
a partial function f2a9ywith domain dom(f) can be lifted to sequences
overausing the following recursive denition: (1) f(hi) =hi; (2) for any 2a
andx2a:
f(hxi) =
f() if x=2dom(f);
f()hf(x)iifx2dom(f):
activity () transforms a trace to a sequence of its activities. for example, for
trace=he1;e2iwithactivity (e1)=aandactivity (e2)=b:activity ()=ha;bi.
traces themselves can also have properties, e.g., a case represented by trace
2lcan be associated with a branch of the company where the process was exe-
cuted. we write p() to obtain the value of any property pof a case represented
by trace.
the class diagram in figure 2 is obtained from [ 1] and it conceptualizes basic
logging concepts in process mining. for now, ignore the annotations on the right
side of the classes ( t,e,a,m ). a process model consists of a set of process activities
and a connector connects elements of the process models to those activities.
3.2 petri nets
a process model notation that is frequently used in the process mining area is
the petri net.
denition 1 (labeled petri net). alabeled petri net n=hp;t;f; m;`i
is a tuple where pis a nite set of places, tis a nite set of transitions such
thatp\t=;,f(pt)[(tp)is a set of directed arcs, called the ow
relation,mis a nite set of labels representing activities, and `:t9mis
a labeling function that assigns a label to transitions. unlabeled transitions, i.e.,
t2twitht62dom(l), are referred to as -transitions, or invisible transitions.
for a node n2p[twe usenandnto denote the set of input and output
nodes ofn, dened asn=fn0j(n0;n)2fgandn=fn0j(n;n0)2fg.6
ab
c
(a)event id activity time cost
1 a 26-3-2017 13:00 e100
2 b 26-3-2017 13:25 e500
3 x 26-3-2017 13:27 e60
4 b 26-3-2017 13:30 e400
5 c 26-3-2017 13:35 e100
6 c 26-3-2017 13:42 e500
7 a 26-3-2017 15:26 e300
8 b 26-3-2017 15:27 e50
9 c 26-3-2017 15:47 e100
10 b 26-3-2017 16:10 e250
11 b 26-3-2017 16:52 e300
12 x 26-3-2017 16:59 e10
(b)
σ {a,b,c} = ʪ",b,b,c,c,a,b,c,b,b ǻ
γ1λ2 γ2λ3 
гσ,lpm = ʪ",b,b,c,a,b,c,b,b ǻλ1 σ = ʪ",b,x,b,c,c,a,b,c,b,b,x ǻ
(c)
fig. 3. (a)example accepting petri net apn 1.(b)traceof an event log l.(c)
segmentation of onapn 1.
a state of a petri net is dened by its markingm2npbeing a multiset of
places. a marking is graphically denoted by putting m(p) tokens on each place
p2p. state changes occur through transition rings. a transition tis enabled
(can re) in a given marking mif each input place p2tcontains at least one
token. once a transition res, one token is removed from each input place of t
and one token is added to each output place of t, leading to a new marking m0
dened asm0=m t+t. a ring of a transition tleading from marking m
to marking m0is denoted as mt !m0.m1 !m2indicates that m2can be
reached from m1through a ring sequence 2t.
often it is useful to consider a petri net in combination with an initial marking
and a set of possible nal markings. this allows us to dene the language accepted
by the petri net and to check whether some behavior is part of the behavior of
the petri net (can be replayed on it).
denition 2 (accepting petri net). anaccepting petri net is a triple
apn =(n;m 0;mf), wherenis a labeled petri net, m02npis its initial mark-
ing, and mfnpis its set of possible nal markings, such that 8m1;m22mfm1*m2.
a sequence 2tis called a trace of an accepting petri net apn ifm0 !mf
for some nal marking mf2mf. the language l(apn )ofapn is the set of
all label sequences belonging to its traces, i.e., if is a trace, then l()2l(apn ).
figure 3a shows an example of an accepting petri net. circles represent places
and rectangles represent transitions. invisible transitions ( ) are depicted as
black rectangles. places that belong to the initial marking contain a token
and places belonging to a nal marking contain a bottom right label fiwith
ia nal marking identier, or are simply marked as in case of a single
nal marking. the language of this accepting petri net, with m=fa;b;cg
isfha;b;ci;ha;c;bi;ha;b;b;ci;ha;b;c;bi;ha;b;b;b;ci;:::g. we refer
the interested reader to [15] for a more thorough introduction of petri nets.
3.3 local process models
lpms [ 22] are process models that describe the behavior seen in the event log
only partially, focusing on frequently observed behavior. typically, lpms describe7
the behavior of only up to 5 activities. lpms can be represented in any process
modeling notation, such as bpmn [ 16], uml [ 7], or epc [ 8]. here we use petri
nets to represents lpms. a technique to generate a ranked collection of lpms
through iterative expansion of candidate process models is proposed in [ 22]. the
search space of process models is xed, depending on the event log. we dene
lpms (l) as the set of possible lpms that can be constructed for given event log
l. we refer the reader to [ 22] for a detailed description of search space lpms (l).
to evaluate a given lpm on a given event log l, its traces 2lare rst
projected on the set of activities min the lpm, i.e., 0=m. the projected
trace0is then segmented into -segments that t the behavior of the lpm and -
segments that do not t the behavior of the lpm, i.e., 0=1122nnn+1
such thati2l(lpm ) andi62l(lpm ). we dene  ;lpm to be a function that
projects trace on the lpm activities and obtains its subsequences that t the
lpm, i.e., ;lpm =12:::n.
let our lpm under evaluation be the petri net of figure 3a and let figure
3b be our trace , withactivity () =ha;b;x;b;c;c;a;b;c;b;b;x i. pro-
jection on the activities of the lpm gives activity ()fa;b;cg=ha;b;b;c;c;
a;b;c;b;bi. figure 3c shows the segmentation the projected traces on the
lpm, leading to activity ( ;lpm ) =ha;b;b;c;a;b;c;b;b i. the segmenta-
tion starts with an empty non-tting segment 1, followed by tting segment
1=ha;b;b;ci, which completes one run through the model from initial to
nal marking. the second event cincannot be replayed on lpm , since it
only allows for one cand1already contains a c. this results in a non-tting
segment2=hci.2=ha;b;c;b;biagain represents a run through the model
from initial to nal marking, and 3=hdidoes not t the lpm. we lift segmen-
tation function  to event logs,  l;lpm =f ;lpmj2lg. an alignment-based
[2] implementation of such a segmentation function  is proposed in [22].
we dene activities (a;l)=jfe2j2l^activity (e)=agjas a function that
maps each activity in event log lto its occurrence frequency. activities (l)
represents the multiset with the frequencies of all activities that occur in l.
events (l) =fe2j2lgis the set of events of l. note that functions activities
and events can also be applied to  l;lpm , which is itself an event log.
4 local process model constraints and utility functions
the discovery of local process models (lpms) can be steered towards the
business needs of the process analyst by using a combination of constraints and
utility functions . constraints can for example be used to nd fragments of process
behavior that lead to a loan application getting declined, or to nd fragments
that only describe loan applications above e15 k and never those below. utility
functions can be used to discover lpms that give insight in which fragments of
process behavior are associated with high nancial costs or long time delays.
constraints are requirements that the lpm has to satisfy, therefore, we dene
constraints as functions that result in 1 when the requirement holds and is 0 when
it does not hold. in a general sense they are dened as a function c:x!f0;1g
wherexis the scope on which the function operates. we distinguish four dierent8
scopes on which xcan be dened: trace-level (t), event-level (e), activity-level
(a), and model-level (m). the class diagram in figure 2 contains annotations
which indicate which classes are included in each of the scopes.
utility functions indicate to what degree an lpm is expected to be interesting
and helpful to answer the business question of the process analyst at hand, and
are dened as functions f:x!r. like constraints, utility functions can be
dened on the four scopes indicated in the class diagram of figure 2.
multiple utility functions and constraints can be combined to form one
composite function that describes the total utility of an lpm given log l. given
constraints c1;c2;:::;cnand utility functions f1;f2;:::;fk, the composite utility
uis dened as:
u(l;lpm ) =qn
i=1ci(l;lpm )pk
j=1fj(l;lpm ).
an lpm needs to satisfy all constraints ciin order to have a utility larger
than zero, i.e.,9ci(l;lpm )=0 =)u(l;lpm )=0. where the original lpm
discovery method [ 22] selects and ranks lpms based on support, utility allows for
goal-oriented selection and ranking, i.e., lpms are ranked based on their utility.
utility functions and constrains of the trace, activity, and event-level scopes are
all dened on a combination of an lpm and the event log. they dene the utility
of an lpm based on a function of log land its fragments that t lpm , given by
 l;lpm . the trace, event, and activity-level scopes dier in the perspectives on
land l;lpm on which they operate. the model-level scope is dened solely on
the lpm itself, and ignores the log argument l. which concrete utility/constraint
functions should be used depends on the business question of the process analyst.
figure 4 shows the arguments of utility and constraint functions on the four scopes.
in the sections that follow we discuss denitions and properties of constraints
and utility functions on each of these scopes and discuss several of their use cases.
4.1 trace-level constraints and utility functions
trace-level utility functions are the most general class of utility functions that
are dened on the event log. trace-level utility functions calculate the utility of
an lpm by aggregating the utility over the trace-fragments that t the lpm
behavior and allow the utility of tting trace fragment to depend on the events
in the trace fragment, their event properties, and properties of the case itself.
trace level-utility can for example be used to discover lpms that describe the
events that explain a high share of the total nancial cost associated to a case,
or a high share of the total running time of a case.
f(l;lpm )
c(l;lpm )
generic function
fm(lpm )
fm(lpm )
model-levelmodel-based
ft(l; l;lpm )
ct(l; l;lpm )
trace-level
fa(activities (l);activities ( l;lpm ))
ca(activities (l);activities ( l;lpm ))
activity-level
f(events (l);events ( l;lpm ))
c(events (l);events ( l;lpm ))
event-levelalignment-based
fig. 4. a tree of function specications on dierent scopes.9
a trace-level utility function is a function ft(l; l;lpm) that indicates the
utility of the tting trace fragments in  l;lpm. consider the lpm of figure 3a,
the example log consisting of one trace in figure 3b, and the segmentation
ofon the lpm of figure 3c. assume that has a case property total cost
which indicates the total cost of the trace. an example of a trace-level util-
ity function is ft
1(l; l;lpm )=p
02 l;lpmp
e20cost(e)
totalcost(0)which discovers
lpms that explain a large share of the total trace costs. another example is
a functionft
2(l; l;lpm )=p
02 l;lpm1
time(0(j0j)) time(0(1)), which results in
lpms where the behavior described typically occurs in short time intervals.
trace-level constraints put requirements on the tting trace segments  l;lpm.
all trace-level utility functions can be transformed into trace-level constraints by
adding thresholds for a minimal or maximal value of the function.
4.2 event-level constraints and utility functions
event-level utility functions and constraints can be used when the business
question of the process stakeholder concerns certain event properties, but does
not concern the trace-context of those events. such utility functions can e.g.
be used to discover lpms that describe process behavior fragments with high
nancial cost. constraints on this level can e.g. be used to limit lpms that solely
describe events that are executed by certain resources, or, in certain time periods.
the trace-level scope is more expressive than the event-level scope, allowing the
analyst to formulate more complex utility functions and constraints, but at the
same time, it makes it harder to formulate such functions compared to the more
restricted event-level scope.
an event-level utility function is a function f(events (l);events ( l;lpm))
that indicates the utility of the tting events in  l;lpm. for the lpm, trace, and
segmentation of figure 3, an example event-level utility function is f
1(events (l);
events ( l;lpm))=p
e2events ( l;lpm)cost(e) which discovers lpms with high
costs. note that litself is also in the domain, allowing us to formulate a utility
function that optimizes the share of utility explained per activity f
2(events (l);
events ( l;lpm))=p
a2lp
e2events ( l;lpm)cost(e)(activity (e)=a)
p
e2events (l)cost(e)(activity (e)=a).
an event level constraint is a function c(events (l);events ( l;lpm)) and
puts constraints on the events in events ( l;lpm). an example is c
1(events (l);
events ( l;lpm)) =f
1(events (l);events ( l;lpm))500, results in lpms with a
total value of at least e500, orc
2(events (l);events ( l;lpm)) =8e2 l;lpmcost(e)
100, which results in lpms that never represent events with a value of less
thane100. note that c
2does not hold for our example trace and lpm, where
the event with id 8 ts the lpm but only has value e50. therefore, this lpm
will not be found by the lpm discovery technique when we use constraint c
2.
4.3 activity-level constraints and utility functions
activity-level utility functions and constraints dene the utility of an lpm based
on the frequency of occurrence of each activity in log land in l;lpm . activity-
level utility functions can for example be used by the process analyst to specify10
that he is more interested in some activities of high impact (e.g., lawsuits, secu-
rity breaches, etc.) than in others, resulting in lpms that describe the frequent
behavior before and after such events. with activity-level constraints the process
analyst can set a hard constraint on activity occurrences. the stakeholder/analyst
can specify a function fa
1(activities (l);activities ( l;lpm)), which indicates how
interested he is in each activity. note that a utility function with equal im-
portance assigned to all activities, i.e., fa(activities (l);activities ( l;lpm)) =
jactivities ( l;lpm)j, results in support-based lpm discovery as described in [ 22].
such utility functions can for example be used to get insight in the relations
with other activities of some particular high-impact activities that the process
analyst is interested in. note that the occurrence of such activities in the log can
be infrequent, in which case traditional lpm discovery without the use of utility
functions and constraints is unlikely to return lpms that concern those activities.
adding a transition representing a zero-utility activity to an lpm can never
increase its total utility, therefore, activity-level utility functions that assign zero
value to some activities speed up discovery by limiting the lpm search space
lpms (l), because lpms with zero-utility activities do not have to be evaluated.
4.4 model-level utility constraints and utility functions
model-level utility functions and constrains can be used when a process analyst
has preference or requirements for specic structural properties of the lpm.
they have the form fm(lpm ) andcm(lpm ), i.e., they are independent of the
log and dependent only on the lpm itself. when a process analyst for example
wants to analyze the behavior that leads to the execution of a certain activity a
which he is interested in, he can use a model-level constraint that enforces that
all elements ofl(lpm ) end with a.
generally we are interested in models that somehow represent the event log.
therefore, model-level utility functions and constraints are often not very useful on
their own, but they become useful when combining them with utility functions and
constraints on the event log, i.e., on the activity-level, event-level, or trace-level.
 l;lpm does not need to be calculated to determine whether a model-level
constraint is satised, because model-level constraints are dened solely on the
model. therefore, model-level constraints can also be used to speed up lpm
discovery by limiting the search space of models lpms (l) to its subspace for
which the model-level constraints hold.
4.5 composite utility functions
utility functions and constraints on the dierent levels can be combined into one
single utility function. in the beginning of this section we dened the utility of a
lpm for a given event log in the following way:
u(l;lpm ) =qn
i=1ci(l;lpm )pk
j=1fj(l;lpm )
the individual constraints ciand the individual utility functions fican be dened
on any of the levels discussed in the previous sections to form one composite,
possibly multi-level, utility function. the total utility uis dened as an unweighted11
sum over the individual utility functions fi. note that this still allows the process
analyst to give priority to one utility function over another, as weights can be
included as a part of the utility function itself by multiplying the utility function
with a constant.
the presented framework of utility functions and constraints generalizes
the method described in [ 22] and all lpm quality metrics presented there are
instantiations of utility functions. an example is the support metric, which is an
activity-level utility function. the minimum threshold for support as proposed
in [22] is an example of an activity-level constraint. another quality metric
introduced in [ 22] isdeterminism , which is inversely proportional to the average
number of enabled transitions in lpm during replay of the aligned event log.
determinism is an example of a composite utility function, consisting of a model-
level and a trace-level component.
note that the trace-level and event-level utility functions are not limited to
continuous-valued properties. many event logs contain ordinal event properties,
such as risk, or, impact , which can take values such as low,medium , or high.
event-level utility functions can be applied to such event properties by specifying
a mapping from the possible ordinal values to continuous values.
5 case studies
in this section we describe two case studies on real life event logs. the rst log
originates from an it service desk of a large dutch nancial institution. the
second log originates from the trac ne handling process by the italian police.
5.1 it service desk
the it service desk event log2is an event log that was made publicly available as
part of the business process intelligence challenge 2014 . the data set contains
incident events which represent disruptions of it-services within a large nancial
institution. each incident event is associated with one or more interactions , which
represent the calls and e-mails to the service desk agents that are related to this
incident. when an incident occurs, it is assigned to an operator, who either solves
the issue, or reassigns it to a colleague having more knowledge. for each incident
event several properties are recorded, amongst others:
service component wbs this is a number that identies the service com-
ponent involved in the incident.
conguration item this contains the type (i.e., laptop, server, software ap-
plication, etc.) of the service component that the incident concerns. each
service component wbs belongs to one conguration item .
impact the impact of the service disruption to the customers as assessed by
the operator. this property takes integer values from 1 to 5.
closure code a code which classies the cause of the service disruption, e.g.,
user error, software error, hardware error.
2http://dx.doi.org/10.4121/uuid:c3e5d162-0cfd-4bb0-bd82-af5268819c3512
no error - works as designed | wbs000073:
utility: 4/4                                            frequency: 4/4user manual not used | wbs000073:
utility: 7/7                                          frequency: 5/6software application | wbs000073:
utility: 1164/1262                            frequency: 1/89
no error - works as designed | wbs000095:
utility: 14/17                                     frequency: 12/15data | wbs000095:
utility: 428/431                          frequency: 399/402user error | wbs000095:
utility: 62/63                                  frequency: 60/61
fig. 5. two lpms discovered from the bpi'14 event log when using event property
number of interactions as utility function.
causedby incidents of a service component have another service component as
root cause of the service disruption. this eld contains the service component
wbs number of the root cause service component.
number of interactions the number of calls to the it service desk that are
related to this incident.
number of reassignments the number of times that this incident was reas-
signed from one it service desk operator to another.
we group together events by their service component wbs number, creating
one case per service component consisting of incidents that these service compo-
nents are involved in. we set the activity label of each incident event to a combina-
tion of the closure code and the causedby attribute separated by the pipe character
(j). the resulting event log contains 313 traces, 25,262 events and 944 activities.
assume now that we are a process analyst concerned with the business ques-
tion: \which process fragments are related to high numbers of e-mails and phone
calls to the it service desk?". to answer this question we formulate utility func-
tionf(events (l);events ( l;lpm)) =p
e2events ( l;lpm)number ofinteractions (e).
figure 5 shows the two lpms with the highest utility that we discovered from
the it service desk event log using this utility function.
the total utility of the top lpm of figure 5 is 1175, indicating that the
behavior of this lpm explains 1175 calls and e-mails to the it service desk.
the lpm shows that in total 1262 calls and e-mails to the it service desk were
associated with incidents with closure code software application that were caused
bywbs000073 , 1164 of which were associated with such an incident that ts the
lpm. only one single incident with this closure code and causedby number out
of the total 89 in the log t the lpm behavior, however, this single incident had
high impact as it caused 1164 of the 1262 interactions. finally, the lpm ends with
an incident with closure code no error - works as designed . this indicates that
this software application contains a feature that is working properly according to
the it service desk (\works as designed"), while bank employees perceive it as
a problem, resulting in a lot of trac to the it service desk. because only one
single software application jwbs000073 incident ts the behavior of this lpm,
one could say that it describes an anomaly rather than a pattern. note that the
discovery of such anomaly-type lpms is a result of the way we dened our utility
function, which allows for highly skewed distribution of utility over events.13
the second lpm shows a similar pattern, but it concerns incidents caused by
server based software application wbs000095 . this lpm has a total utility of
504, meaning that it describes in total 504 calls and e-mails to the it service
desk. the model shows that 60 out of 61 user errors are eventually followed by
an incident with closure code no error - works as designed . these 60 incidents
together generate 62 interactions with the it service desk. note that 399 data
incidents related to this software application, causing 428 interactions with the
service desk, also resulted in an incident with this closure code.
in the two lpms we see that two service components ( wbs000073 and
wbs000095 ) are the main cause of call and e-mails to the it service desk. fur-
thermore, for both service components, the lpms end in no error - works as
designed events, which could indicate that such problems could be prevented.
5.2 trac fines
the road trac ne management event log3is an event log where each case
refers to a trac ne. each case starts with a create ne event, which has a
property amount that species the amount of the ne. payment events have a
paymentamount property, which indicates how much has been paid. payment of
the total ne amount can be spread out over multiple payments. some nes are
paid directly to the police ocer when the ne is given, and some are sent by
mail, in which case there is a send ne event. send ne events have a property
expense , which contains an additional administrative cost which adds to the total
amount that has to be paid. when a ne is not paid in time, an add penalty
event occurs which has an amount property that updates the ne amount set
in the create ne event. if a ne is still not paid after the added penalty it is
send for credit collection . furthermore, a ne can be appealed at the prefecture
and, at a later stage, can be appealed in court. in total the trac nes event log
contains 150,370 traces, 561,470 events, and 11 activities.
assume we are a process analyst concerned with the business question: \which
process fragments describe nes where the remaining amount to be paid is high?".
figure 6 shows the top three lpms that we discovered from the trac ne log
using a trace-level utility function that denes utility as the remaining amount
that is still to be paid at the time of the event. this utility function has a trace-
level scope, as it is calculated from the latest seen amount in the case (either from
acreate ne oradd penalty event) plus the expense fee if there is a send ne event
minus the paymentamount values of all payment events seen in the trace so far.
the rst lpm in figure 6 shows that in total e5.83 million has been created
in nes, out of which e5.60 million was either send to credit collection or
payments have been received for them. the remaining e200 thousand correspond
to recent nes that have not yet been paid but are not yet due to be sent for
credit collection. the total amount of payments received after a create ne event
ise731 thousand, which is surprisingly low comparable to the total of e5.83
million. noteworthy is that nes representing a total value of e6.43 million are
3http://dx.doi.org/10.4121/uuid:270fd440-1057-4fb9-89a9-b699b47990f514
create fine
€5.60 m / €5.83 msend for credit collection
€6.32 m / €6.43 m
payment
€731 k / €731 k
(1) total utility= e12.6 million
insert date appeal to prefecture
€378 k / € 384 k
send for credit collection
€6.39 m / €6.43 msend appeal to prefecture
€570 k / € 570 kcreate fine
€3.15 m / € 5.83 m
(2) total utility= e10.5 million
create fine
€2.93 m / €5.83 m receive result appeal from prefecture
€125 k / €138 ksend for credit collection
€6.39 m / €6.43m
notify result appeal to offender
€128 k / €129 k
(3) total utility= e9.6 million
fig. 6. the top three lpms in terms of total utility as discovered from the trac ne
log, using remaining amount to pay as utility.
send to credit collection, which is even more than the nes representing a value
ofe5.83 million that were created in the rst place. that the total value of nes
at credit collection is higher than the total value of nes that were handed out is
because of added penalties and, to a lesser degree, added expenses. finally, nes
representing a value of e6.32 million that were sent to credit collection out of
the total e6.43 million value of nes that were sent to credit collection t the
control ow pattern of the lpm, i.e., they occur after a create ne and are in an
xor-construct with payment events. since we know that all traces start with
acreate ne event, the only possible explanation left is that nes representing
a value of e6.32 million that were sent to credit collection have not received a
single payment before being send to credit collection, while for the remaining
nes representing a value of e110 thousand that were sent to credit collection at
least one partial payment of the ne was already received.
the second lpm in figure 6 shows that nes representing a value of e3.15
out of the total value of nes of e5.83 million was either sent to credit collection
or appealed at the prefecture. the appeal procedure starts with an insert data
appeal to prefecture event which is later followed by a send appeal to prefecture
event. the lpm shows that for the appealed nes, the total value is e378
thousand at the time of insert date appeal to the prefecture , but added penalties
for late paying raise the total appealed amount to e570 thousand at the time that
the appeal is actually send to prefecture. this means appealed nes on average
multiply 1.5x in value during the appeal procedure as a result of penalties being
added for the payment term being overdue. finally, the numbers in the send for
credit collection transition show that only a very small portion of the total value
of nes that were sent to credit collection were followed by an appeal procedure.
the third lpm in figure 6 shows a pattern similar to the second lpm, with
the dierence that it now describes two later steps in the appeal to prefecture
procedure. at the receive result appeal from prefecture step there is a total15
value of e138 thousand. this is considerably lower than the nes representing
values of e378 thousand and e570 thousand respectively that we found for the
earlier steps of the appeal procedure. this shows that there are appealed nes
representing a value of e570 thousand - e138 thousand = e432 thousand which
did not receive the appeal results. these appeals were either withdrawn before
the verdicts on these appeals were made, or these appeals are still waiting for
a verdict. furthermore, nes representing a value of e125 thousand out of the
total value of e138 thousand of nes at receive result appeal from prefecture t
the control ow of the pattern, indicating that nes representing a value of e13
thousand which received a result for appeal were either not (yet) notied, or they
have been sent for credit collection prior to the appeal.
6 conclusions & future work
this paper presents a framework of utility functions and constraints for local
process models (lpms) that allows for combinations of utility functions and
constraints on dierent scopes: on the activity, event, trace, and model level. we
formalize utility functions on each of the levels and provide examples of how they
can be used. finally, we show on real-life event logs that the utility functions
and constraints can be used to discover insightful lpms that cannot be obtained
using existing support-based lpm discovery.
when a model e.g. allows for one execution of activity awhile multiple
executions of aare observed in the log, dierent alignments are possible depending
on the choice of afor the synchronous move and the ones for log moves. however,
these events do not necessarily have equal utility. thus, the utility of the lpm
depends on the alignment returned by the alignment algorithm. as future work,
we plan to make alignments utility-aware, so that the optimal alignment leads to
the highest lpm utility.
references
1.van der aalst, w.m.p.: process mining: data science in action. springer-verlag
berlin heidelberg (2016)
2.adriansyah, a., van dongen, b.f., van der aalst, w.m.p.: conformance checking
using cost-based tness analysis. in: proceedings of the 15th ieee enterprise
distributed object computing conference. pp. 55{64. ieee (2011)
3.bergenthum, r., desel, j., lorenz, r., mauser, s.: process mining based on regions
of languages. in: international conference on business process management. pp.
375{383. springer (2007)
4.van dongen, b.f., de medeiros, a.k.a., verbeek, h.m.w., weijters, a.j.m.m.,
van der aalst, w.m.p.: the prom framework: a new era in process mining tool
support. in: international conference on application and theory of petri nets. pp.
444{454. springer berlin heidelberg (2005)
5.g unther, c.w., van der aalst, w.m.p.: fuzzy mining{adaptive process simplica-
tion based on multi-perspective metrics. in: international conference on business
process management. pp. 328{343. springer (2007)16
6.han, j., cheng, h., xin, d., yan, x.: frequent pattern mining: current status and
future directions. data mining and knowledge discovery 15(1), 55{86 (2007)
7.international organization for standardization: iso/iec 19505-1:2012 - information
technology - object management group unied modeling language (omg uml)
- part 1: infrastructure (2012)
8.keller, g., scheer, a.w., n uttgens, m.: semantische prozemodellierung auf der
grundlage" ereignisgesteuerter prozeketten". inst. f ur wirtschaftsinformatik
(1992)
9.lan, g.c., hong, t.p., tseng, v.s., wang, s.l.: applying the maximum utility
measure in high utility sequential pattern mining. expert systems with applications
41(11), 5071{5081 (2014)
10.leemans, m., van der aalst, w.m.p.: discovery of frequent episodes in event logs.
in: international symposium on data-driven process discovery and analysis. pp.
1{31. springer (2014)
11.leemans, s.j.j., fahland, d., van der aalst, w.m.p.: discovering block-structured
process models from event logs containing infrequent behaviour. in: international
conference on business process management. pp. 66{78. springer (2013)
12.liesaputra, v., yongchareon, s., chaisiri, s.: ecient process model discovery
using maximal pattern mining. in: international conference on business process
management. pp. 441{456. springer (2015)
13.maggi, f.m., mooij, a.j., van der aalst, w.m.p.: user-guided discovery of declara-
tive process models. in: proceedings of the ieee symposium on computational
intelligence and data mining. pp. 192{199. ieee (2011)
14.m aru ster, l., van beest, n.r.t.p.: redesigning business processes: a methodology
based on simulation and process mining techniques. knowledge and information
systems 21(3), 267 (2009)
15.murata, t.: petri nets: properties, analysis and applications. proceedings of the
ieee 77(4), 541{580 (1989)
16.object management group: notation (bpmn) version 2.0. omg specication
(2011)
17.pei, j., han, j., wang, w.: constraint-based sequential pattern mining: the pattern-
growth methods. journal of intelligent information systems 28(2), 133{160 (2007)
18.ramezani, e., fahland, d., van der aalst, w.m.p.: where did i misbehave? diag-
nostic information in compliance checking. in: international conference on business
process management. pp. 262{278. springer (2012)
19.shen, y.d., zhang, z., yang, q.: objective-oriented utility-based association mining.
in: proceedings of the ieee international conference on data mining. pp. 426{433.
ieee (2003)
20.srikant, r., agrawal, r.: mining sequential patterns: generalizations and per-
formance improvements. in: international conference on extending database
technology. pp. 1{17. springer (1996)
21.tax, n., sidorova, n., van der aalst, w.m.p., haakma, r.: heuristic approaches for
generating local process models through log projections. in: 2016 ieee symposium
on computational intelligence and data mining. pp. 1{8. ieee (2016)
22.tax, n., sidorova, n., haakma, r., van der aalst, w.m.p.: mining local process
models. journal of innovation in digital ecosystems 3(2), 183{196 (2016)
23.yin, j., zheng, z., cao, l.: uspan: an ecient algorithm for mining high utility
sequential patterns. in: proceedings of the 18th acm sigkdd international
conference on knowledge discovery and data mining. pp. 660{668. acm (2012)
24.yin, j., zheng, z., cao, l., song, y., wei, w.: eciently mining top-k high utility
sequential patterns. in: proceedings of the ieee 13th international conference on
data mining. pp. 1259{1264. ieee (2013)