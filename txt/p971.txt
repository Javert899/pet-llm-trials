computing
doi 10.1007/s00607-017-0582-5
discovering workﬂow nets using integer linear
programming
s. j. van zelst1·b. f. van dongen1·
w. m. p. van der aalst1·h. m. w. verbeek1
received: 19 july 2016 / accepted: 25 october 2017
© the author(s) 2017. this article is an open access publication
abstract process mining is concerned with the analysis, understanding and improve-
ment of business processes. process discovery, i.e. discovering a process model based
on an event log, is considered the most challenging process mining task. state-of-
the-art process discovery algorithms only discover local control ﬂow patterns and are
unable to discover complex, non-local patterns. region theory based techniques, i.e.
an established class of process discovery techniques, do allow for discovering such
patterns. however, applying region theory directly results in complex, overﬁtting mod-
els, which is less desirable. moreover, region theory does not cope with guarantees
provided by state-of-the-art process discovery algorithms, both w.r.t. structural and
behavioural properties of the discovered process models. in this paper we present an
ilp-based process discovery approach, based on region theory, that guarantees to dis-
cover relaxed sound workﬂow nets. moreover, we devise a ﬁltering algorithm, based
on the internal working of the ilp-formulation, that is able to cope with the presence of
infrequent, exceptional behaviour. we have extensively evaluated the technique using
different event logs with different levels of exceptional behaviour. our experiments
show that the presented approach allows us to leverage the inherent shortcomings
of existing region-based approaches. the techniques presented are implemented and
b s. j. van zelst
s.j.v.zelst@tue.nl
b. f. van dongen
b.f.v.dongen@tue.nl
w. m. p . van der aalst
w.m.p.v.d.aalst@tue.nl
h. m. w. v erbeek
h.m.w.verbeek@tue.nl
1department of mathematics and computer science, eindhoven university of technology,
p .o. box 513, 5600 mb eindhoven, the netherlands
123s. j. van zelst et al.
readily available in the hybridilpminer package in the open-source process mining
tool-kits prom ( http://promtools.org ) and rapidprom ( http://rapidprom.org ).
keywords process mining ·process discovery ·region theory ·integer linear
programming
mathematics subject classiﬁcation 97r50 ·90c05
1 introduction
the execution of business processes within a company generates traces of event data
in its supporting information system. the goal of process mining [28]i st ot u r nt h i s
data, recorded in event logs , into actionable knowledge. three core branches form
the basis of process mining: process discovery ,conformance checking and process
enhancement . in process discovery, this paper’s focus, the goal is to construct a process
model based on an event log. in conformance checking the goal is to assess whether
a given process model and event log conform with respect to each other in terms ofdescribed behaviour. in process enhancement the goal is to improve processes models,
primarily, though not exhaustively, using the two aforementioned ﬁelds.
several different process models exist that (largely) describe the behaviour in an
event log. hence, we need means to rank and compare these different process models.
in process mining we typically judge the quality of process models based on four
essential quality dimensions: replay-ﬁtness ,precision ,generalization and simplic-
ity[7,28,33]. replay-ﬁtness describes the fraction of behaviour in the event log that is
also described by the model. precision describes the fraction of behaviour described
by the model that is also present in the event log. generalization indicates a model’sability to account for behaviour not part of the event log, e.g. in case of parallelism, it
is often impossible to observe all possible behaviour in the event log. simplicity refers
to a model’s interpretability by a human analyst. a process discovery result ideally
strikes an adequate balance between these four quality dimensions.
state-of-the-art process discovery algorithms guarantee that their discovered pro-
cess models have both structural and behavioural properties [ 6,16]. these guarantees
have a positive impact on the aforementioned quality dimensions. as a consequence,
the techniques are unable to ﬁnd complex, non-local control ﬂow patterns [ 29]. in [ 34]
an integer linear programming (ilp) [ 24] based process discovery algorithm is pro-
posed that is able to ﬁnd such patterns. however, the algorithm does not provide the
same guarantees as most state-of-the-art process discovery algorithms. moreover, thealgorithm only works well under the assumption that the event log only holds frequent
behaviour that ﬁts nicely into some underlying process model.
real event logs typically include low-frequent exceptional behaviour, e.g. caused
by people deviating from the normative process or cases that require special treatment.
because of this, applying ilp-based process discovery as-is on real data often yields,
despite its potential, unsatisfactory results. in this paper we present a revised ilp-based process discovery algorithm that solves the inherent shortcomings of current
ilp-based approaches. our contribution is summarized as follows: (1) we show that
our approach is able discover relaxed sound workﬂow nets , and (2) we present an
123discovering workﬂow nets using integer linear programming
effective, integrated, ﬁltering algorithm that results in process models that abstract
from infrequent and/or exceptional behaviour.
the proposed algorithm is implemented in the process mining framework
prom [39](hybridilpminer package) and available in rapidprom [5,26]. we have
compared our technique with two state-of-the-art ﬁltering techniques [ 9,15]. we addi-
tionally validated the applicability of our approach on two real life event logs [ 11,19].
our experiments conﬁrm the effectiveness of the proposed approach, both in terms of
resulting model quality and computational complexity.
the remainder of this paper is organized as follows. in sect. 2, we discuss related
work. in sect. 3, we present background concepts. in sect. 4, we show how to discover
relaxed sound workﬂow nets. in sect. 5, we present an integrated ﬁltering algorithm
that eliminates infrequent behaviour. in sect. 6, we evaluate the proposed approach.
sect. 7concludes the paper.
2 related work
in this section we predominantly focus on the application of region theory , i.e. the
theoretical foundation of ilp-based process discovery, in process discovery. we addi-
tionally discuss ﬁltering techniques designed for process discovery.
2.1 process discovery
the state-of-the-art process discovery algorithm, i.e. the inductive miner [ 16], discov-
ers process models by applying a divide-and-conquer approach. the algorithm splits
the event log into smaller parts and, recursively, ﬁnds models for these sub-logs whichare later combined. the resulting models are hierarchically structured sound workﬂow
nets [ 27]. a limitation of the approach is its inability to discover complex non-local
control ﬂow patterns. the discovery approach presented in [ 6], i.e. the evolutionary
tree miner, is able to ﬁnd similar process models as the inductive miner. the algo-
rithm opts an evolutionary computational approach and is therefore non-deterministicand does not guarantee termination. like the inductive miner, it is not able to discover
complex non-local control ﬂow patterns. for an overview of other process discovery
algorithms we refer to [ 12,28,35].
several process discovery techniques are proposed based on region theory, i.e. a
solution to the petri net synthesis problem [ 23]. region theory comes in two forms, i.e.
state-based region theory [ 4,13,14] using transition systems as an input and language-
based region theory [ 1,2,10,17,18] using languages as an input. the main difference
between the synthesis problem and process discovery is related to generalization of
the discovered models. process models found by classical region theory approacheshave perfect replay-ﬁtness and maximal precision. process discovery on the other
hand aims at extracting a generalizing process model, i.e. precision, and in some cases
replay-ﬁtness, need not be maximized.
in [31] a process discovery approach is presented that transforms an event log into
a transition system, after which state-based region theory is applied. constructing the
transition system is strongly parametrized, i.e. using different parameters yields dif-
123s. j. van zelst et al.
ferent process discovery results. in [ 25] a similar approach is presented. the main
contribution is a complexity reduction w.r.t. conventional region-based techniques.
in [3] a process discovery approach is presented based on language-based region the-
ory. the method ﬁnds a minimal linear basis of a polyhedral cone of integer points,
based on the event log. it guarantees perfect replay-ﬁtness, whereas it does not max-
imize precision. the worst-case time complexity of the approach is exponential inthe size of the event log. in [ 8] a process discovery algorithm is proposed based on
the concept of numerical abstract domains. based on the event log’s preﬁx-closure,
a convex polyhedron is approximated by means of calculating a convex hull. theconvex hull is used to compute causalities in the input event log by deducing a set of
linear inequalities which represent places. in [ 34] a ﬁrst design of a process discovery
ilp-formulation is presented. an objective function is presented, which is generalized
in [37], that allows for expressing a preference for ﬁnding certain petri net places. the
work also presents means to formulate ilp constraints that help ﬁnding more advancedpetri net-types, e.g. petri nets with reset- and inhibitor arcs.
all aforementioned techniques leverage the strict implications of region theory
w.r.t. process discovery, i.e. precision maximization, poor generalization and poorsimplicity, to some extent. however, the techniques still perform suboptimal. since the
techniques guarantee perfect replay-ﬁtness, they tend to fail if exceptional behaviour
is present in the event log, i.e. they produce models that are incorporating infrequentbehaviour (outliers).
2.2 filtering infrequent behaviour
little work has been done regarding ﬁltering of infrequent behaviour in context of
process mining. the majority of work concerns unpublished/undocumented ad-hoc
ﬁltering implementations in the prom framework [ 39].
in [9] an event log ﬁltering technique is presented that ﬁlters on event level . events
within the event log are removed in case they do not ﬁt an underlying, event log based,
automaton. the technique can be used as a pre-processing step prior to invoking
any discovery algorithm. in [ 15] the inductive miner [ 16] is extended with ﬁltering
capabilities to handle infrequent behaviour. the technique is tailored towards the
internal working of the inductive miner algorithm and considers three different typesof ﬁlters. moreover, the technique exploits the inductive nature of the underlying
algorithm, i.e. ﬁlters are applied on multiple levels.
3 background
in this section we present basic notational conventions, event logs and workﬂow nets.
moreover, we present a process discovery ilp-formulation based on [ 34,37].
3.1 bags, sequences and vectors
x={e1,e2,..., en}denotes a set. p(x)denotes the power set of x.ndenotes
the set of positive integers including 0 whereas n+excludes 0.rdenotes the set of
123discovering workﬂow nets using integer linear programming
real numbers. a bag (multiset) over xis a function b:x→ nwhich we write as
[ev1
1,ev2
2,..., evnn], where for 1 ≤i≤nwe have ei∈x,vi∈n+and b(ei)=vi.
if for some element e,b(e)=1, we omit its superscript. an empty bag is denoted
as∅. element inclusion applies to bags: if e∈xand b(e)> 0 then also e∈b. set
operations, i.e. /unionmulti,\,∩, extend to bags. the set of all bags over xis denoted b(x).
asequence σof length krelates positions to elements e∈x, i.e. σ:
{1,2,..., k}→ x. an empty sequence is denoted as /epsilon1. we write every non-
empty sequence as /angbracketlefte1,e2,..., ek/angbracketright. the set of all possible sequences over a set x
is denoted as x∗. we write concatenation of sequences σ1andσ2asσ1·σ2,e . g .
/angbracketlefta,b/angbracketright·/angbracketleftc,d/angbracketright=/angbracketleft a,b,c,d/angbracketright.l e t y⊆x, we deﬁne ↓y:x∗→y∗recursively with
↓y(/epsilon1)=/epsilon1and↓y(/angbracketleftx/angbracketright·σ)=/angbracketleftx/angbracketright· ↓ y(σ) ifx∈yand↓y(σ) otherwise. we write
σ↓yfor↓y(σ).
given y∈x∗,t h e preﬁx-closure ofyis:y={σ1∈x∗|∃σ2∈x∗(σ1·σ2∈y)}.
we extend the notion of a preﬁx-closure on bags of sequences. let y⊆x∗and by:
y→ nwe deﬁne by:y→ n, such that: by(σ)=by(σ)+/summationtext
σ·/angbracketlefte/angbracketright∈yby(σ·/angbracketlefte/angbracketright).
for example, b2=[ /angbracketleft a,b/angbracketright5,/angbracketlefta,c/angbracketright3]yields b2=[/epsilon18,/angbracketlefta/angbracketright8,/angbracketlefta,b/angbracketright5,/angbracketlefta,c/angbracketright3].
given set xand a range of values r⊆ r. v ectors are denoted as z∈r|x|,
where z(e)∈rand e∈x. we assume vectors to be column vectors . for vector
multiplication we assume that vectors agree on their indices. throughout the paperwe assume a total ordering on sets of the same domain .g i v e n x={e
1,e2,..., en}
andz1,z2∈r|x|we have z/intercal
1z2=/summationtextn
i=1z1(ei)z2(ei).aparikh vector prepresents
the number of occurrences of an element within a sequence, i.e. p:x∗→ n|x|with
p(σ)=(#e1(σ), #e2(σ),... , #en(σ)) where # ei(σ)=| {i/prime∈{1,2,...,|σ|} |σ(i/prime)=
ei}|.
3.2 event logs and workﬂow nets
in process discovery, event logs, which describe the actual execution of activities in
context of a business process, are the main source of input. an example event log
is presented in table 1. consider all activities related to case-id 1 . john registers a
request , after which lucy examines it thoroughly . pete checks the ticket after which
rob decides toreject the request . the execution of an activity in context of a business
process is referred to as an event . a sequence of events, e.g. the sequence of events
related to case 1,i sr e f e r r e dt oa sa trace .
let adenote the universe of all possible activities. an event log lis a bag of
sequences over a, i.e., l∈b(a∗). typically, there exists al⊂ aof activ-
ities that are actually present in l. in some cases we refer to an event log as
l∈b(a∗
l). a sequence σ∈lrepresents a trace. we write case 1as trace
/angbracketleft“register request”,“examine thoroughly”, “check ticket”, “decide”, “reject request” /angbracketright.
in the remainder of the paper, we use simple characters for activity names, e.g. we
write case 1as/angbracketlefta,b,d,e,h/angbracketright.
the goal within process discovery is to discover a process model based on an event
log. in this paper we consider workﬂow nets (wf-nets) [27], based on petri nets [22],
to describe process models. we ﬁrst introduce petri nets and their execution semantics,
after which we deﬁne workﬂow nets.
123s. j. van zelst et al.
table 1 fragment of a ﬁctional event log [ 28] (a row corresponds to an event)
case-id activity resource time-stamp
…… … …
1 register request ( a) john 2015-05-08:08.45
1 examine thoroughly ( b) lucy 2015-05-08:09.13
2 register request ( a) john 2015-05-08:09.14
2 check ticket ( d) pete 2015-05-08:10.11
1 check ticket ( d) pete 2015-05-08:10.28
2 examine causally ( b) rob 2015-05-08:10.43
1 decide ( e) rob 2015-05-08:11.14
1 reject request ( h) rob 2015-05-08:11.35
…… … …
fig. 1 example wf-net w1, adopted from [ 28]
a petri net is a bipartite graph consisting of a set of vertices called places and a
set of vertices called transitions . arcs connect places with transitions and vice versa.
additionally, transitions have a (possibly unobservable) label which describes theactivity that the transition represents. a petri net is a quadruple n=(p,t,f,λ),
where pis a set of places and tis a set of transitions with p∩t=∅ .fdenotes
the ﬂow relation of n, i.e., f⊆(p×t)∪(t×p).λdenotes the label function,
i.e. given a set of labels /lambda1and a symbol τ/∈/lambda1, it is deﬁned as λ:t→/lambda1∪{τ}.
for a node x∈p∪t, the pre-set of xinnis deﬁned as •x={y|(y,x)∈f}and
x•={ y|(x,y)∈
f}denotes the post-set of x. graphically we represent places as
circles and transitions as boxes . for every (x,y)∈fwe draw an arcfrom xtoy.a n
example petri net (which is also a wf-net) is depicted in fig. 1. observe that we have
•d={c2},d•={ c4}andλ(d)=“check ticket”. the petri net does not contain any
silent transition.
the execution semantics of petri nets are based on the concept of markings .am a r k -
ingmis a bag of tokens, i.e. m∈b(p). graphically, a place p’s marking is visualized
123discovering workﬂow nets using integer linear programming
by drawing m(p)number of dots inside place p, e.g. place “start” in fig. 1.amarked
petri net is a 2-tuple (n,m), where mrepresents n’s marking. we let midenote n’s
initial marking . transition t∈tisenabled in marking mif∀p∈•t(m(p)> 0).
enabled transition tin marking m,m a y ﬁre, which results in new marking m/prime.i ftﬁres,
denoted as (n,m)t−→(n,m/prime), then for each p∈pwe have m/prime(p)=m(p)−1
ifp∈•t\t•,m/prime(p)=m(p)+1i f p∈t•\• t, and, m/prime(p)=m(p)oth-
erwise, e.g. in fig. 1we have (w1,[start])a−→(w1,[c1,c2]). given sequence
σ=/angbracketleftt1,t2,..., tn/angbracketright∈ t∗,σis aﬁring sequence of(n,m), written as (n,m)σ−→→
(n,m/prime)if and only if for n=|σ|there exist markings m1,m2,..., mn−1such
that(n,m)t1−→(n,m1),(n,m1)t2−→(n,m2) ,...,( n,mn−1)tn−→(n,m/prime).w e
write(n,m)σ−→→∗ if there exists a marking m/primes.t.(n,m)σ−→→(n,m/prime). we write
(n,m)/squiggleright(n,m/prime)if there exists σ∈t∗s.t.(n,m)σ−→→(n,m/prime).
wf-nets extend petri nets and require the existence of a unique source- and sink
place which describe the start, respectively end, of a case. moreover, each element
within the wf-net needs to be on a path from the source to the sink place.
deﬁnition 1 (workﬂow net [27]) let n=(p,t,f,λ) be a petri net. let pi,po∈p
with pi/negationslash=po.l e t/lambda1⊂abe a set of activities, let τ/∈/lambda1and let λ:t→/lambda1∪{τ}.
tuple w=(p,t,f,pi,po,λ) is a workﬂow net (wf-net) if and only if:
1.•pi=∅
2.po•=∅
3. each element x∈p∪tis on a path from pitopo.
the execution semantics deﬁned for petri nets can directly be applied on the ele-
ments p,tand fofw=(p,t,f,pi,po,λ). notation-wise we substitute wfor
its underlying net structure n=(p,t,f),e . g .(w,m)/squiggleright(w,m/prime). in context of
wf-nets, we assume mi=[pi]and mf=[po]unless mentioned otherwise.
several behavioural quality metrics, that do not need any form of domain knowl-
edge, exist for wf-nets. several notions of soundness of wf-nets are deﬁned [ 32]. for
example, classical sound wf-nets are guaranteed to be free of livelocks, deadlocks,
and other anomalies that can be detected automatically. in this paper we consider the
weaker notion of relaxed soundness . relaxed soundness requires that each transition
is at some point enabled, and, after ﬁring such transition we are able to eventuallyreach the ﬁnal marking.
deﬁnition 2 (relaxed soundness [32]) let w=(p,t,f,p
i,po,λ) be a wf-net.
wis relaxed sound if and only if: ∀t∈t(∃m,m/prime∈b(p)((w,[pi])/squiggleright(w,m)∧
(w,m)t−→(w,m/prime)∧(w,m/prime)/squiggleright(w,[po]))).
reconsider w1(fig. 1) and assume we are given an event log with one trace:
/angbracketlefta,b,d,e,h/angbracketright. it is quite easy to see that w1is relaxed sound. moreover, replay-ﬁtness
is perfect, i.e. /angbracketlefta,b,d,e,h/angbracketrightis in the wf-net’s labelled execution language. precision
is not perfect as the wf-net can produce a lot more traces than just /angbracketlefta,b,d,e,h/angbracketright.
123s. j. van zelst et al.
3.3 discovering petri net places using integer linear programming
in [34] an integer linear programming (ilp)-formulation [ 24] is presented which
allows for ﬁnding places of a petri net. a solution to the ilp-formulation corresponds
to a region , which in turn corresponds to a petri net place. the premise of a region is
the fact that its corresponding place, given the preﬁx-closure of an event log, does notblock the execution of any sequence within the preﬁx-closure. we represent a region
as an assignment of binary decision variables describing the incoming and outgoing
arcs of its corresponding place, as well as its marking.
given an event log lover set of activities a
l, a region is a triple r=(m,x,y),
with m∈{0,1}andx,y∈{0,1}|al|, that adheres to:
∀σ=σ/prime·/angbracketlefta/angbracketright∈l(m+p(σ/prime)/intercalx−p(σ)/intercaly≥0) (3.1)
ar e g i o n ris translated to a petri net place pas follows. given a petri net structure
that has a unique transition ta∈twithλ(ta)=a.i f ,x(a)=1, we add tato•p.
symmetrically, if y(a)=1, we add tatop•. finally, if m=1, place pis initially
marked. since translating a region to a place is deterministic, we are also able to
translate a place to a region, e.g. place c2in fig. 1corresponds to a region with
x(a)=1,x(f)=1,y(d)=1 and all other variables set to zero.
prior to presenting the basic ilp-formulation for ﬁnding regions, we formulate
regions in terms of matrices, which we use in the ilp-formulation.
deﬁnition 3 (region (matrix form) ) given an event log lover a set of activities al,
letm∈{0,1}and let x,y∈{0,1}|al|.l e t mandm/primebe two |l\{/epsilon1}| × | al|matrices
with m(σ,a)=p(σ)( a)andm/prime(σ,a)=p(σ/prime)(a)(where σ=σ/prime·/angbracketlefta/prime/angbracketright∈l). tuple
r=(m,x,y)is a region if and only if:
m1+m/primex−my≥0 (3.2)
we additionally deﬁne matrix mlwhich is an |l|×| al|matrix with ml(σ,a)=
p(σ)( a)forσ∈l, i.e., mlis the equivalent of mfor all traces in the event log.
we deﬁne a general process discovery ilp-formulation that guarantees to ﬁnd a non-
trivial region, i.e. regions unequal to (0,0,0)and(1,1,1), with the property that its
corresponding place is always empty after replaying each trace within the event log.
deﬁnition 4 (process discovery ilp-formulation [34]) given an event log lover
a set of activities aland corresponding matrices m,m/primeandml.l e t cm∈rand
cx,cy∈r|al|. the process discovery ilp-formulation, ilp l, is deﬁned as:
minimize z=cmm+cx/intercalx+cy/intercaly objective function
suchthat m1+m/primex−my≥0 theory of regions
and m1+ml(x−y)=0 corresp. place is empty after each trace
1/intercalx+1/intercaly≥1 at least one arc connected
0≤x≤1 i.e.x∈{0,1}|a|
0≤y≤1 i.e.y∈{0,1}|a|
0≤m≤1 i.e. m∈{0,1}
123discovering workﬂow nets using integer linear programming
deﬁnition 4allows us to ﬁnd a region that minimizes objective function z=cmm+
cx/intercalx+cy/intercaly. multiple instantiations of z, i.e. in terms of objective coefﬁcients c m,cx
andcy, are possible. in [ 34] an objective function is proposed that minimizes 1-values
inxand maximizes 1-values in y, i.e. in the region’s corresponding place the number of
incoming arcs is minimized whereas the number of outgoing arcs is maximized. in [ 37]
the aforementioned objective function is extended such that it minimizes the time atoken resides in the corresponding place. both objective functions are expressible
as a more general function which favours minimal regions [37], i.e. regions that are
not expressible as a non-negative linear combination of two other regions. this isinteresting since non-minimal regions correspond to implicit places [ 34]. in this paper
we simply assume that one uses such an objective function.
4 discovering relaxed sound workﬂow nets
using the basic formulation with some objective function instantiation only yields one,optimal, result. however, we are interested in ﬁnding multiple places that together form
a workﬂow net. in [ 34] multiple approaches are presented to ﬁnd multiple, different
petri net places. here we adopt, and generalize, the causal approach .
4.1 discovering multiple places based on causal relations
one of the most suitable techniques to ﬁnd multiple regions in a controlled, structured
manner, is by exploiting causal relations present within an event log. a causal relation
between activities aand bimplies that activity acauses b, i.e. bis likely to follow
(somewhere) after activity a. several approaches exist to compute causalities [ 35]. for
example, in [ 30] a causal relation a→
lbfrom activity ato activity bis deﬁned to hold
if, within some event log l, we ﬁnd traces of the form /angbracketleft..., a,b,.../angbracketrightthough we do not
ﬁnd traces of the form /angbracketleft..., b,a,.../angbracketright.i n[ 40,41] this relation was further developed
to take frequencies into account as well. given these multiple deﬁnitions, we assume
the existence of a causal relation oracle which, given an event log, produces a set of
pairs(a,b)indicating that activity ahas a causal relation with (to) activity b.
deﬁnition 5 (causal relation oracle ) a causal relation oracle γcmaps a bag of traces
to a set of activity pairs, i.e. γc:b(a∗)→ p(a×a).
a causal oracle only considers activities present in an event log, i.e. γc(l)∈
p(al×al). it deﬁnes a directed graph with alas vertices and each pair (a,b)∈
γc(l)as an arc between aandb. later we exploit the graph-based view, for now we
refer to γc(l)as a collection of pairs. when adopting a causal ilp process discovery
strategy, we try to ﬁnd net places that represent a causality found in the event log.
given an event log l, for each pair (a,b)∈γc(l)we enrich the constraint body with
three constraints: (1) m=0, (2) x(a)=1 and (3) y(b)=1. the three constraints
ensure that if we ﬁnd a solution to the ilp , it corresponds to a place which is not
marked and connects transition ato transition b. given pair (a,b)∈γc(l)we denote
the corresponding extended causality based ilp-formulation as ilp(l,a→b).
123s. j. van zelst et al.
after solving ilp(l,a→b)for each (a,b)∈γc(l), we end up with a set of regions
that we are able to transform into places in a resulting petri net. since we enforce
m=0 for each causality, none of these places is initially marked. moreover, due
to constraints based on m1+ml(x−y)=0, the resulting place is empty after
replaying each trace in the input event log within the net. since we additionally enforce
x(a)=1 and y(b)=1, if we ﬁnd a solution to the ilp , the corresponding place has
both input and output arcs and is not eligible for being a source/sink place. hence,
the approach as-is does not allow us to ﬁnd wf-nets. in the next section we show
that a simple pre-processing step performed on the event log, together with speciﬁcinstances of γ
c(l), allows us to discover wf-nets which are relaxed sound.
4.2 discovering workﬂow nets
consider example event log l1=[ /angbracketleft a,b,d,e,g/angbracketright10,/angbracketlefta,c,d,e,f,d,b,e,g/angbracketright12,/angbracketlefta,d,
c,e,h/angbracketright9,/angbracketlefta,b,d,e,f,c,d,e,g/angbracketright11,/angbracketlefta,d,c,e,f,b,d,e,h/angbracketright13]. observe that for each
traceσinl1we have (w1,[start])σ−→→(w1,[end]).l e t af⊆aldenote the set of
ﬁnal activities , i.e. activities afs.t. there exists a trace of the form /angbracketleft..., af/angbracketrightin the event
log. for example, for l1,af={g,h}. after solving each ilp l,a→binstance based
onγc(l)and adding corresponding places, we know that when we exactly replay any
trace from l1, after ﬁring gorh, the net is empty. since gandhnever co-occur in a
trace, it is trivial to add a sink place po, s.t. after replaying each trace in l1,pois the
only place marked, i.e. •po={f,g}and po•=∅ (place “end” in fig. 1). in general,
such decision is not trivial. however, a trivial case for adding a sink pois the case
when there is only one end activity that uniquely occurs once, at the end of each trace,
i.e.af={af}and there exists no trace of the form /angbracketleft..., af,..., af/angbracketright. in such case
we have •po={af},po•=∅ .
a similar rationale holds for adding a source place. we deﬁne a set asthat denotes
the set of start activities , i.e. activities ass.t. there exists a trace of the form /angbracketleftas,.../angbracketright
in the event log. for each activity asinaswe know that for some traces in the event
log, these are the ﬁrst ones to be executed. thus, we know that the source place pi
must connect, in some way, to the elements of as. like in the case of ﬁnal transitions,
creating a source place is trivial when as={as}and there exists no trace of the form
/angbracketleftas,..., as,.../angbracketright, i.e. the start activity uniquely occurs once at the beginning of each
trace. in such case we create place piwith•pi=∅,pi•={ as}.
in order to be able to ﬁnd a source and a sink place, it sufﬁces to guarantee that
sets asand afare of size one and their elements always occur uniquely at the start,
respectively, end of a trace. we formalize this idea through the notion of unique
start/end event logs , after which we show that transforming an arbitrary event log to
such unique start/end event log is trivial.
deﬁnition 6 (unique start/end event log )l e t lbe an event log over a set of activities
al.lis aunique start/end event log (use-log) if there exist as,af∈als.t.as/negationslash=
af,∀σ∈l(σ(1)=as∧∀i∈{2,3,...,|σ|}(σ(i)/negationslash=as))and∀σ∈l(σ(|σ|)=
af∧∀i∈{1,2,...,|σ|−1}(σ(i)/negationslash=af)).
123discovering workﬂow nets using integer linear programming
since the set of activities alis ﬁnite, it is trivial to transform any event log to
a use-log. assume we have an event log lover althat is not a use-log. we
generate two “fresh” activities as,af∈as.t.as,af/∈aland create a new event
logl/primeover al∪{as,af}, by adding /angbracketleftas/angbracketright·σ·/angbracketleftaf/angbracketrighttol/primefor each σ∈l.w el e t
π:b(a∗)→ b(a∗)denote such use-transformation. we omit asand affrom
the domain of πand assume that given some use-transformation the two symbols
are known.
clearly, after applying a use-transformation, ﬁnding a unique source and sink
place is trivial. it also provides an additional advantage considering the ability to ﬁndwf-nets. in fact, an ilp instance ilp
(l,a→b)always has a solution if lis a use-log.
we provide a proof of this property in lemma 1, after which we present an algorithm
that, given speciﬁc instantiations of γc, discovers wf-nets.
lemma 1 (a use-log based causality has a solution) let l be an event log over a set
of activities a l. letπ:b(a∗)→ b(a∗)denote a use-transformation function
and let a s,afdenote the start and end activities. for every (a,b)∈γc(π(l))with
a/negationslash=afand b /negationslash=as,ilp(π(l),a→b)has a solution.
proof see [ 38]. /intersectionsq/unionsq
in algorithm 1we present an ilp-based process discovery approach that uses
a use-log internally in order to ﬁnd multiple petri net places. for every (a,b)∈
γc(π(l))with a/negationslash=afand b/negationslash=asit solves ilp(π(l),a→b). moreover, it ﬁnds a
unique source and sink place.
the algorithm constructs an initially empty petri net n=(p,t,f). subsequently
for each a∈al∪{as,af}a transition tais added to t. for each causal pair in the use-
variant of input event log l, a place p(a,b)is discovered by solving ilp(π(l),a→b)
after which pand fare updated accordingly. the algorithm adds an initial place pi
and connects it to tasand similarly creates sink place powhich is connected to taf.
for transition tarelated to a∈al,w eh a v e λ(ta)=a, whereas λ(tas)=λ(taf)=τ.
the algorithm is guaranteed to always ﬁnd a solution to ilp(π(l),a→b), hence for
each causal relation a place is found. additionally, a unique source and sink place
are constructed. however, the algorithm does not guarantee that we ﬁnd a connectedcomponent, i.e. requirement 3 of deﬁnition 1. in fact, the nature of γ
cdetermines
whether or not we discover a wf-net. in theorem 1we characterize this nature and
prove, by exploiting lemma 1, that we are able to discover wf-nets.
theorem 1 (there exist sufﬁcient conditions for ﬁnding wf-nets) let l be an
event log over a set of activities a l. let π:b(a∗)→ b(a∗)denote a
use-transformation function. let a s,afdenote the unique start- and end activ-
ity of π(l). letγc:b(a∗)→ p(a×a)be a causal oracle and consider
γc(π(l))as a directed graph. if each a ∈alis on a path from a sto a fin
γc(π(l)), and there is no path from a sto itself, nor a path from a fto itself, then
ilp-based process discovery (l,γc)returns a wf-net.
proof see [ 38]. /intersectionsq/unionsq
theorem 1proves that if we use a causal structure that, when interpreting it as
a graph, has the property that each a∈alis on a path from astoaf, the result
123s. j. van zelst et al.
algorithm 1: ilp-based process discovery
input :l∈b(a∗
l), γc:b(a∗)→ p(a×a)
output :w=(p,t,f,pi,po,λ )
begin
1 p,t,f←∅ ;
2 letas,af/∈al;
3 t←{ ta|a∈al∪{as,af}};
4 foreach (a,b)∈γc(π(l))do
5 ifa/negationslash=af∧b/negationslash=asthen
6 (m,x,y)←solution to ilp(π(l),a→b);
7 letp(a,b)/∈p;
8 p←p∪p(a,b);
9 foreach a/prime∈al∪{as,af}do
10 ifx(a/prime)=1then
11 f←f∪{(ta/prime,p(a,b)};
12 ify(a/prime)=1then
13 f←f∪{(p(a,b),ta/prime)};
14 letpi,po/∈p;
15 p←p∪{pi,po};
16 f←f∪{(pi,tas)};
17 f←f∪{(taf,po)};
18 letλ:t→a∪{τ};
19 foreach a∈aldo
20 λ(ta)←a;
21 λ(tas), λ( taf)←τ;
22 return (p,t,f,pi,po,λ );
ofilp-based process discovery (l,γc)is a wf-net. although this seems
a rather strict property of the causal structure, there exists a speciﬁc causal graph
deﬁnition that guarantees this property [ 40]. hence we are able to use this deﬁnition
as an instantiation for γc.
theorem 1does not provide any behavioural guarantees, i.e. a wf-net is a purely
graph-theoretical property. recall that the premise of a region is that it does not block
the execution of any sequence within the preﬁx-closure of an event log. intuitively we
deduce that we are therefore able to ﬁre each transition in the wf-net at least once.moreover, since we know that a
fis the ﬁnal transition of each sequence in π(l), and
after ﬁring the transition each place based on any ilp(π(l),a→b)is empty, we know
that we are able to mark po. these two observations hint on the fact that the wf-net
isrelaxed sound , which we prove in theorem 2
theorem 2 let l be an event log over a set of activities a l. letπ:b(a∗)→
b(a∗)denote a use-transformation function and let a s,afdenote the unique start-
and end activity of π(l). letγc:b(a∗)→ p(a×a)be a causal oracle. let
w=(p,t,f,pi,po,λ)=ilp-based process discovery (a,l,γc).i f
w is a wf-net, then w is relaxed sound.
proof see [ 38]. /intersectionsq/unionsq
we have shown that with a few pre- and post-processing steps and a speciﬁc class
of causal structures we are able to guarantee to ﬁnd wf-nets that are relaxed sound.
123discovering workﬂow nets using integer linear programming
these results are interesting since several process mining techniques require wf-
nets as an input. the ilp problems solved still require their solutions to allow for
all possible behaviour in the event log. as a result, the algorithm incorporates allinfrequent exceptional behaviour and still results in over-ﬁtting complex wf-nets.
hence, in the upcoming section we show how to efﬁciently prune the ilp constraint
body to identify and eliminate infrequent exceptional behaviour.
5 dealing with infrequent behaviour
in this section we present an efﬁcient pruning technique that identiﬁes and eliminatesconstraints related to infrequent exceptional behaviour. we ﬁrst present the impact ofinfrequent exceptional behaviour after which we present the pruning technique.
5.1 the impact of infrequent exceptional behaviour
in this section we highlight the main cause of ilp-based discovery’s inability to handle
infrequent behaviour and we devise a ﬁltering mechanism that exploits the nature of
the underlying body of constraints.
let us again consider example event log l
1, i.e., l1=[ /angbracketleft a,b,d,e,g/angbracketright10,/angbracketlefta,c,d,e,
f,d,b,e,g/angbracketright12,/angbracketlefta,d,c,e,h/angbracketright9,/angbracketlefta,b,d,e,f,c,d,e,g/angbracketright11,/angbracketlefta,d,c,e,f,b,d,e,h/angbracketright13].
using an implementation of algorithm 1in prom [ 39], with a suitable causal structure
γc, we ﬁnd the wf-net depicted in fig. 2a. the wf-net describes the same behaviour
as the model presented in fig. 1and has perfect replay-ﬁtness w.r.t. l1. however, if
we create event log l/prime
1by simply adding one instance of the trace /angbracketlefta,b,c,d,e,g/angbracketright,w e
obtain the result depicted in fig. 2b. due to one exceptional trace, the model allows us,
after executing aorf, to execute an arbitrary number of b- and c-labelled transitions.
this is undesirable since precision of the resulting process model drops signiﬁcantly.
thus, the addition of one exceptional trace results in a less comprehensible wf-net
and reduces the precision of the resulting wf-net.
when analysing the two models we observe that they share some equal places, e.g.
both models have a place p({a,f},{d})with•p({a,f},{d})={a,f}and p({a,f},{d})•=
{d}. however, the two places p({a,f},{b,c})with•p({a,f},{b,c})={ a,f}and
p({a,f},{b,c})•={ b,c}and p({b,c},{e})with•p({b,c},{e})={b,c}and p({b,c},{e})•={ e}
in fig. 2a, are not present in fig. 2b. these are “replaced” by the less desirable places
containing self-loops in fig. 2b. this is caused by the fact that the constraint body of
the ilp’s based on event log l/prime
1contain all constraints present in the ones related to
l1, combined with the additional constraints depicted in table 2.
for place p({a,f},{b,c})in fig. 2a we deﬁne a corresponding tuple r=(m,x,y)with
x(a)=1,x(f)=1,y(b)=1 and y(c)=1 (all other variables 0). the additional
constraints in table 2all evaluate to −1f o r r, e.g. constraint m+x(as)+x(a)+
x(b)−y(as)−y(a)−y(b)−y(c)evaluates to 0 +0+1+0−0−0−1−1=− 1.
in case of place p({b,c},{e})we observe that the corresponding tuple r=(m,x,y)with
x(b)=1,x(c)=1 and y(e)=1, yields a value of 1 for all constraints generated
by trace /angbracketlefta,b,c,d,e,g/angbracketright. for the constraints having a “ ≥0 right hand side” this is
valid, however, for constraint m+x(as)+x(a)+x(b)+x(c)+x(d)+x(e)+x(g)+
123s. j. van zelst et al.
g
h
fe c
db
a(a)
hg
e
cbda
f(b)
fig. 2 results of applying algorithm 1(hybridilpminer package in the prom framework [ 39]) based
onl1and l/prime
1.aresult based on event log l1.bresult based on event log l/prime
1
table 2 some of the newly added constraints based on trace /angbracketlefta,b,c,d,e,g/angbracketrightin event log l/prime
1, starting from
preﬁx /angbracketlefta,b,c/angbracketrightwhich is not present in l1
m+x(as)+x(a)+x(b)−y(as)−y(a)−y(b)−y(c)≥0
m+x(as)+x(a)+x(b)+x(c)−y(as)−y(a)−y(b)−y(c)−y(d)≥0
...
m+x(as)+x(a)+x(b)+x(c)+x(d)+x(e)+x(g)−y(as)−y(a)−y(b)−y(c)−y(d)−y(e)−
y(g)−y(af)≥0
m+x(as)+x(a)+x(b)+x(c)+x(d)+x(e)+x(g)+x(af)−y(as)−y(a)−y(b)−y(c)−y(d)−
y(e)−y(g)−y(af)=0
x(af)−y(as)−y(a)−y(b)−y(c)−y(d)−y(e)−y(g)−y(af)=0 this is not
valid.
the example shows that the addition of /angbracketlefta,b,c,d,e,g/angbracketrightyields constraints that
invalidate places p({a,f},{b,c})and p({b,c},{e}). as a result the wf-net based on event
logl/prime
1contains places with self-loops on both band cwhich greatly reduces its
precision and simplicity. due to the relative infrequency of trace /angbracketlefta,b,c,d,e,g/angbracketrightit
is arguably acceptable to trade-off the perfect replay-ﬁtness guarantee of ilp-based
123discovering workﬂow nets using integer linear programming
process discovery and return the wf-net of fig. 2a, given l/prime
1. hence, we need ﬁltering
techniques and/or trace clustering techniques in order to remove exceptional behaviour.
however, apart from simple pre-processing, we aim at adapting the ilp-based processdiscovery approach itself to be able to cope with infrequent behaviour.
by manipulating the constraint body such that it no longer allows for all behaviour
present in the input event log, we are able to deal with infrequent behaviour withinevent logs. given the problems that arise because of the presence of exceptional traces,
a natural next step is to leave out the constraints related to the problematic traces. an
advantage of ﬁltering the constraint body is the fact that the constraints are based onthe preﬁx-closure of the event log. thus, even if all traces are unique yet they do share
preﬁxes, we are able to ﬁlter. additionally, leaving out constraints decreases the size
of the ilp’s constraint body, which has a potential positive effect on the time needed
to solve an ilp . we devise a graph-based ﬁltering technique, i.e., sequence encoding
ﬁltering , that allows us to prune constraints based on trace frequency information.
5.2 sequence encoding graphs
as a ﬁrst step towards sequence encoding ﬁltering we deﬁne the relationship between
sequences and constraints. we do this in terms of sequence encodings . a sequence
encoding is a vector-based representation of a sequence in terms of region theory, i.e.
representing the sequence’s corresponding constraint.
deﬁnition 7 (sequence encoding ) given a set of activities a={a
1,a2,..., an}.
φ:a∗→ n2|a|+1denotes the sequence encoding function mapping every σ∈a∗to
a2·|a|+1-sized vector. we deﬁne φas:
φ(σ/prime·/angbracketlefta/angbracketright)=⎛
⎝1
p(σ/prime)
−p(σ/prime·/angbracketlefta/angbracketright)⎞
⎠φ(/epsilon1)=⎛
⎜⎜⎜⎝1
0
...
0⎞
⎟⎟⎟⎠
as an example of a sequence encoding vector consider sequence /angbracketlefta
s,a,b/angbracketrightorigi-
nating from π(l/prime
1),f o rw h i c hw eh a v e φ(/angbracketleftas,a,b/angbracketright)/intercal=(1,1,1,0,0,0,0,0,0,0,0,
−1,−1,−1,0,0,0,0,0,0,0). sequence encoding vectors directly correspond to
region theory based constraints, e.g. if we are given m∈{0,1}andx,y∈{0,1}|a|
and create a vector rwhere r(1)=m,r(2)=x(as),r(3)=x(a),… , r(10)=
x(h),r(11)=x(af),r(12)=y(as),… , r(21)=y(af), then φ(/angbracketleftas,a,b/angbracketright)/intercalr=
m+x(as)+x(a)−y(as)−y(a)−y(b). as a compact notation for σ=σ/prime·/angbracketlefta/angbracketright
we write φ(σ) as a pair of the bag representation of the parikh vector of σ/primeand
a, i.e.φ(/angbracketleftas,a,b/angbracketright)is written as ([as,a],b)whereas φ(/angbracketleftas,a,b,c/angbracketright)is written as
([as,a,b],c).f o rφ(/epsilon1)we write ([],⊥).
consider the preﬁx-closure of π(l/prime
1)which generates the linear inequalities
presented in table 3. the table shows each sequence present in π(l/prime
1)accompa-
nied by its φ-value and the number of occurrences of the sequence in π(l/prime
1),e . g .
π(l/prime
1)(/angbracketleftas,a/angbracketright)=56. observe that there is a relation between the occurrence of a
123s. j. van zelst et al.table 3 schematic overview of sequence encodings based on π(l/prime
1)
σ∈π(l/prime
1) φ(σ)/intercal,i . e .(m,x(as),x(a) ,..., y(h),y(af)) φ(σ) (shorthand) π(l/prime
1)(σ)
/epsilon1( 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)( [],⊥) 56
/angbracketleftas/angbracketright (1,0,0,0,0,0,0,0,0,0,0,−1,0,0,0,0,0,0,0,0,0)( [],as) 56
/angbracketleftas,a/angbracketright (1,1,0,0,0,0,0,0,0,0,0,−1,−1,0,0,0,0,0,0,0,0)( [as],a) 56
/angbracketleftas,a,b/angbracketright (1,1,1,0,0,0,0,0,0,0,0,−1,−1,−1,0,0,0,0,0,0,0)( [as,a],b) 22
/angbracketleftas,a,c/angbracketright (1,1,1,0,0,0,0,0,0,0,0,−1,−1,0,−1,0,0,0,0,0,0)( [as,a],c) 12
/angbracketleftas,a,d/angbracketright (1,1,1,0,0,0,0,0,0,0,0,−1,−1,0,0,−1,0,0,0,0,0)( [as,a],d) 22
/angbracketleftas,a,b,c/angbracketright (1,1,1,1,0,0,0,0,0,0,0,−1,−1,−1,−1,0,0,0,0,0,0)( [as,a,b],c) 1
/angbracketleftas,a,b,d/angbracketright (1,1,1,1,0,0,0,0,0,0,0,−1,−1,−1,0,−1,0,0,0,0,0)( [as,a,b],d) 21
/angbracketleftas,a,c,d/angbracketright (1,1,1,0,1,0,0,0,0,0,0,−1,−1,0,−1,−1,0,0,0,0,0)( [as,a,c],b) 12
/angbracketleftas,a,d,c/angbracketright (1,1,1,0,0,1,0,0,0,0,0,−1,−1,0,−1,−1,0,0,0,0,0)( [as,a,d],c) 22
/angbracketleftas,a,b,c,d/angbracketright (1,1,1,1,1,0,0,0,0,0,0,−1,−1,−1,−1,−1,0,0,0,0,0)( [as,a,b,c],d) 1
/angbracketleftas,a,b,d,e/angbracketright (1,1,1,1,0,1,0,0,0,0,0,−1,−1,−1,0,−1,−1,0,0,0,0)( [as,a,b,d],e) 21
/angbracketleftas,a,c,d,e/angbracketright (1,1,1,0,1,1,0,0,0,0,0,−1,−1,0,−1,−1,−1,0,0,0,0)( [as,a,c,d],e) 12
/angbracketleftas,a,d,c,e/angbracketright (1,1,1,0,1,1,0,0,0,0,0,−1,−1,0,−1,−1,−1,0,0,0,0)( [as,a,c,d],e) 22
/angbracketleftas,a,b,c,d,e/angbracketright (1,1,1,1,1,1,0,0,0,0,0,−1,−1,−1,−1,−1,−1,0,0,0,0)( [as,a,b,c,d],e) 1
/angbracketleftas,a,b,d,e,f/angbracketright (1,1,1,1,0,1,1,0,0,0,0,−1,−1,−1,0,−1,−1,−1,0,0,0)( [as,a,b,d,e],f) 11
/angbracketleftas,a,b,d,e,g/angbracketright (1,1,1,1,0,1,1,0,0,0,0,−1,−1,−1,0,−1,−1,0,−1,0,0)( [as,a,b,d,e],g) 10
/angbracketleftas,a,c,d,e,f/angbracketright (1,1,1,0,1,1,1,0,0,0,0,−1,−1,0,−1,−1,−1,−1,0,0,0)( [as,a,c,d,e],f) 12
/angbracketleftas,a,d,c,e,f/angbracketright (1,1,1,0,1,1,1,0,0,0,0,−1,−1,0,−1,−1,−1,−1,0,0,0)( [as,a,c,d,e],f) 13
/angbracketleftas,a,d,c,e,h/angbracketright (1,1,1,0,1,1,1,0,0,0,0,−1,−1,0,−1,−1,−1,0,0,−1,0)( [as,a,c,d,e],h) 9
/angbracketleftas,a,b,c,d,e,g/angbracketright (1,1,1,1,1,1,1,0,0,0,0,−1,−1,−1,−1,−1,−1,0,−1,0,0)( [as,a,b,c,d,e],g) 1
123discovering workﬂow nets using integer linear programmingtable 3 continued
σ∈π(l/prime
1) φ(σ)/intercal,i . e .(m,x(as),x(a) ,..., y(h),y(af)) φ(σ) (shorthand) π(l/prime
1)(σ)
/angbracketleftas,a,b,d,e,f,c/angbracketright (1,1,1,1,0,1,1,1,0,0,0,−1,−1,−1,−1,−1,−1,−1,0,0,0)( [as,a,b,d,e,f],c) 11
/angbracketleftas,a,b,d,e,g,af/angbracketright (1,1,1,1,0,1,1,0,1,0,0,−1,−1,−1,0,−1,−1,0,−1,0,−1)( [as,a,b,d,e,g],af) 10
/angbracketleftas,a,c,d,e,f,d/angbracketright (1,1,1,0,1,1,1,1,0,0,0,−1,−1,0,−1,−2,−1,−1,0,0,0)( [as,a,c,d,e,f],d) 12
/angbracketleftas,a,d,c,e,f,b/angbracketright (1,1,1,0,1,1,1,1,0,0,0,−1,−1,−1,−1,−1,−1,−1,0,0,0)( [as,a,c,d,e,f],b) 13
/angbracketleftas,a,d,c,e,h,af/angbracketright (1,1,1,0,1,1,1,0,0,1,0,−1,−1,0,−1,−1,−1,0,0,−1,−1)( [as,a,c,d,e,h],af) 9
/angbracketleftas,a,b,c,d,e,g,af/angbracketright (1,1,1,1,1,1,1,0,1,0,0,−1,−1,−1,−1,−1,−1,0,−1,0,−1)( [as,a,b,c,d,e,g],af) 1
/angbracketleftas,a,b,d,e,f,c,d/angbracketright (1,1,1,1,1,1,1,1,0,0,0,−1,−1,−1,−1,−2,−1,−1,0,0,0)( [as,a,b,c,d,e,f],d) 11
/angbracketleftas,a,c,d,e,f,d,b/angbracketright (1,1,1,0,1,2,1,1,0,0,0,−1,−1,−1,−1,−2,−1,−1,0,0,0)( [as,a,c,d2,e,f],b) 12
/angbracketleftas,a,d,c,e,f,b,d/angbracketright (1,1,1,1,1,1,1,1,0,0,0,−1,−1,−1,−1,−2,−1,−1,0,0,0)( [as,a,b,c,d,e,f],d) 13
/angbracketleftas,a,b,d,e,f,c,d,e/angbracketright (1,1,1,1,1,2,1,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,0,0,0)( [as,a,b,c,d2,e,f],e) 11
/angbracketleftas,a,c,d,e,f,d,b,e/angbracketright (1,1,1,1,1,2,1,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,0,0,0)( [as,a,b,c,d2,e,f],e) 12
/angbracketleftas,a,d,c,e,f,b,d,e/angbracketright (1,1,1,1,1,2,1,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,0,0,0)( [as,a,b,c,d2,e,f],e) 13
/angbracketleftas,a,b,d,e,f,c,d,e,g/angbracketright (1,1,1,1,1,2,2,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,−1,0,0)( [as,a,b,c,d2,e2,f],g) 11
/angbracketleftas,a,c,d,e,f,d,b,e,g/angbracketright (1,1,1,1,1,2,2,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,−1,0,0)( [as,a,b,c,d2,e2,f],g) 12
/angbracketleftas,a,d,c,e,f,b,d,e,h/angbracketright (1,1,1,1,1,2,2,1,0,0,0,−1,−1,−1,−1,−2,−2,−1,0,−1,0)( [as,a,b,c,d2,e2,f],h) 13
/angbracketleftas,a,b,d,e,f,c,d,e,g,af/angbracketright (1,1,1,1,1,2,2,1,1,0,0,−1,−1,−1,−1,−2,−2,−1,−1,0,−1)( [as,a,b,c,d2,e2,f,g],af) 11
/angbracketleftas,a,c,d,e,f,d,b,e,g,af/angbracketright (1,1,1,1,1,2,2,1,1,0,0,−1,−1,−1,−1,−2,−2,−1,−1,0,−1)( [as,a,b,c,d2,e2,f,g],af) 12
/angbracketleftas,a,d,c,e,f,b,d,e,h,af/angbracketright (1,1,1,1,1,2,2,1,0,1,0,−1,−1,−1,−1,−2,−2,−1,0,−1,−1)( [as,a,b,c,d2,e2,f,h],af) 13
123s. j. van zelst et al.
fig. 3 an example sequence encoding graph g/prime
1, based on example event log l/prime
1
sequence and its corresponding postﬁxes, i.e. after the 56 times that sequence /angbracketleftas,a/angbracketright
occurred, /angbracketleftas,a,b/angbracketrightoccurred 22 times, /angbracketleftas,a,c/angbracketrightoccurred 12 times and /angbracketleftas,a,d/angbracketright
occurred 22 times (note: 56 =22+12+22). due to coupling of sequences to con-
straints, i.e. by means of sequence encoding, we can now apply the aforementioned
reasoning to constraints as well. the frequencies in π(l/prime
1)allow us to decide whether
the presence of a certain constraint is in line with predominant behaviour in the event
log. for example, in table 3,φ(/angbracketleftas,a,b,c/angbracketright)relates to infrequent behaviour as it
appears only once.
to apply ﬁltering, we construct a weighted directed graph in which each sequence
encoding acts as a vertex. we connect two vertices by means of an arc if the source
constraint corresponds to a sequence that is a preﬁx of a sequence corresponding to
the target constraint, i.e., we connect φ(/angbracketleftas,a/angbracketright)toφ(/angbracketleftas,a,b/angbracketright)as/angbracketleftas,a/angbracketrightis a preﬁx
of/angbracketleftas,a,b/angbracketright. the arc weight corresponds to trace frequency in the input event log.
deﬁnition 8 (sequence encoding graph ) given event log lover set of activities al.
a sequence encoding graph is a directed graph g=(v,e,ψ) where v={φ(σ)|
σ∈l},e⊆v×vs.t.(φ(σ/prime),φ(σ))∈e⇔∃ a∈a(σ/prime·/angbracketlefta/angbracketright=σ)andψ:e→ n
where:
ψ(v 1,v2)=/summationdisplay
σ∈l
φ(σ)=v2l(σ)−/summationdisplay
σ/prime∈l
σ/prime·/angbracketlefta/angbracketright∈l
φ(σ/prime·/angbracketlefta/angbracketright)=v2
φ(σ/prime)/negationslash=v1l(σ/prime)
consider the sequence encoding graph in fig. 3, based on π(l/prime
1), as an example. by
deﬁnition, ([],⊥)is the root node of the graph and connects to all one-sized sequences.
123discovering workﬂow nets using integer linear programming
within the graph we observe the relation among different constraints, combined with
their absolute frequencies based on l/prime
1.
5.3 filtering
given a sequence encoding graph we are able to ﬁlter out constraints. in algorithm 2
we devise a simple breadth-ﬁrst traversal algorithm, i.e. sequence encoding
filtering—breadth first search (sef-bfs ), that traverses the sequence
encoding graph and concurrently constructs a set of ilp constraints. the algorithm
needs a function as an input that is able to determine, given a vertex in the sequence
encoding graph, what portion of adjacent vertices remains in the graph and which areremoved.
deﬁnition 9 (sequence encoding ﬁlter ) given event log lover set of activities a
l
and a corresponding sequence encoding graph g=(v,e,ψ) . a sequence encoding
ﬁlter is a function κ:v→ p(v).
note that κis an abstract function and might be parametrized. as an example consider
κα
max which we deﬁne as:
κα
max(v)=/braceleftbigg
v/prime|(v,v/prime)∈e∧ψ(v,v/prime)≥(1−α)·max
v/prime/prime∈vψ(v,v/prime/prime)/bracerightbigg
,α∈[0,1]
other instantiations of κare possible as well and hence κis a parameter of the general
approach. it is however desirable that κ(v)⊆{v/prime|(v,v/prime)∈e}, i.e. it only considers
vertices reached by vby means of an arc. given an instantiation of κ, it is straight-
forward to construct a ﬁltering algorithm based on breadth-ﬁrst graph traversal, i.e.
sef-bfs .
algorithm 2: sef-bfs
input :g=(v,e,ψ),κ :v→ p(v)
output :c⊆v
begin
1 c←∅
2 letqbe a fifo queue
3 q.enqueue (([],⊥))
4 while q/negationslash=∅ do
5 v←q.dequeue ()
6 forv/prime∈κ(v) do
7 c←c∪{v/prime}
8 q.enqueue (v/prime)
9 return c
the algorithm inherits its worst-case complexity of breadth ﬁrst search, multiplied
by the worst-case complexity of κ. thus, in case κ’s worst-case complexity is o(1)
then we have o(|v|+|e|)for the sef-bfs -algorithm. it is trivial to prove, by means
of induction on the length of a sequence encoding’s corresponding sequence, that a
sequence encoding graph is acyclic. hence, termination is guaranteed.
123s. j. van zelst et al.
as an example of executing the sef-bfs algorithm, reconsider fig. 3. assume
we use κ0.75
max.v e r t e x ([],⊥)is initially present in qand will be analysed. since ([],as)
is the only child of ([],⊥), it is added to q.v e r t e x ([],⊥)is removed from the queue
and is never inserted in the queue again due to the acyclic property of the graph.
similarly, since ([as],a)is the only child of ([],as)it is added to q. all children of
([as],a), i.e.([as,a],b),([as,a],c)and([as,a],d), are added to the queue since the
maximum corresponding arc value is 22, and, (1−0.75)∗22=5.5, which is smaller
than the lowest arc value 12. when analysing ([as,a],b)we observe a maximum
outgoing arc with value 21 to vertex ([as,a,b],d)which is enqueued in q. since
(1−0.25)∗21=5.25, the algorithm does not enqueue ([as,a,b],c). note that
the whole path of vertices from ([as,a,b],c)to([as,a,b,c,d,e,g],af)is never
analysed and is stripped from the constraint body, i.e. they are never inserted in c.
when applying ilp-based process discovery based on event log l/prime
1with sequence
encoding ﬁltering and κ0.75
max, we obtain the wf-net depicted in fig. 2a. as explained,
the ﬁlter leaves out all constraints related to vertices on the path from ([as,a,b],c)
to([as,a,b,c,d,e,g],af). hence, we ﬁnd a similar model to the model found on
event log l1and are able to ﬁlter out infrequent exceptional behaviour.
6 evaluation
algorithm 1and sequence encoding ﬁltering are implemented in the hybridilp-
miner package ( http://svn.win.tue.nl/repos/prom/packages/hybridilpminer/ ) which
is available in the prom framework [ 39](http://www.promtools.org ) and the rapid-
prom framework [ 26].1using this implementation we validated the approach. in
an artiﬁcial setting we evaluated the quality of models discovered and the efﬁciencyof applying sequence encoding ﬁltering. we also compare sequence encoding to the
imi [ 15] algorithm and automaton-based ﬁltering [ 9]. finally, we assess the perfor-
mance of sequence encoding ﬁltering on real event data [ 11,19].
6.1 model quality
the event logs used in the empirical evaluation of model quality are artiﬁcially gen-
erated event logs and originate from a study related to the impact of exceptional
behaviour to rule-based approaches in process discovery [ 20]. three event logs where
generated out of three different process models, i.e. the ground truth event logs . these
event logs do not consist of any exceptional behaviour, i.e. every trace ﬁts the originat-
ing model. the ground truth event logs are called a12f0n00 ,a22f0n00 anda32f0n00 .
the two digits behind the acharacter indicate the number of activities present in the
event log, i.e. a12f0n00 contains 12 different activities. from each ground truth event
log, by means of trace manipulation, four other event logs are created that do contain
1experiments are performed with source code available at: https://github.com/rapidprom/rapidprom-
source/tree/2017_computing_ilp_1 . experiments are conducted on machines with 8 intel xeon cpu e5-
2407 v2 @ 2.40 ghz processors and 64 gb ram. raw experiment results are available at: https://github.
com/s-j-v-zelst/research/releases/download/2017_computing/experiments.tar.gz .
123discovering workﬂow nets using integer linear programming
(a) (b) (c)
fig. 4 replay-ﬁtness measurements based on a22f0nxx .asequence encoding. bimi [ 15].cilp with
automaton filter [ 9]
exceptional behaviour. manipulation concerns tail/head of trace removal, random part
of the trace body removal and interchanging two randomly chosen events [ 20]. the
percentages of trace manipulation are 5, 10, 20 and 50%. the manipulation percentage
is incorporated in the last two digits of the event log’s name, i.e. the 5% manipula-tion version of the a22f0n00 event log is called a22f0n05 . in this section we only
study results of the experiments using the a22f0nxx event logs, in [ 38] we report on
a12f0nxx anda32f0nxx as well.
the existence of ground truth event logs, free of exceptional behaviour, is of utmost
importance for evaluation. we need to be able to distinguish normal from exceptional
behaviour in an unambiguous manner . within evaluation, these event logs, combined
with the quality dimension precision, allow us to judge how well a technique is able
to ﬁlter out exceptional behaviour. recall that precision is deﬁned as the number of
traces producible by the process model that are also present in the event log. thus if alltraces producible by a process model are present in an event log, precision is maximal,
i.e. the precision value is 1. if the model allows for traces that are not present in the
event log, precision is lower than 1.
if exceptional behaviour is present in an event log, the conventional ilp-based pro-
cess discovery algorithm produces a wf-net that allows for all exceptional behaviour.
as a result, the algorithm is unable to ﬁnd any meaningful patterns within the event log.
this typically leads to places with a lot of self-loops. the acceptance of exceptional
behaviour by the wf-net, combined with the inability to ﬁnd meaningful patternsyields a low level of precision, when using the ground truth log as a basis for precision
computation. on the other hand, if we discover models using an algorithm that is
more able to handle the presence of exceptional behaviour, we expect the algorithm toallow for less exceptional behaviour and ﬁnd more meaningful patterns. thus, w.r.t.
the ground truth model, we expect higher precision values.
to evaluate the sequence encoding ﬁltering approach, we have applied the
ilp-based process discovery algorithm with sequence encoding ﬁltering using
κ
α
max andα=0,0.05,0.1,..., 0.95,1. moreover, we performed similar experi-
ments for imi [ 15](http://svn.win.tue.nl/repos/prom/packages/inductiveminer/ ) and
automaton based event log ﬁltering [ 9](http://svn.win.tue.nl/repos/prom/packages/
noisefiltering/ ) combined with ilp-based discovery. we measured precision [ 21] and
replay-ﬁtness [ 33] based on the ground truth event logs . the replay-ﬁtness results of
the experiments are presented in fig. 4. precision results are presented in fig. 5.i n
the charts we plot replay-ﬁtness/precision against the noise level and ﬁlter threshold.
we additionally use a colour scheme to highlight the differences in value.
123s. j. van zelst et al.
(a) (b) (c)
fig. 5 precision measurements based on a22f0nxx .asequence encoding. bimi [ 15].cilp with automa-
ton filter [ 9]
for the sequence encoding ﬁlter (figs. 4a,5a) we observe that replay-ﬁtness is
often 1, except for very rigorous levels of ﬁltering, i.e. α=0 and α=0.05. when
applying it as rigorous as possible, i.e. α=0, we observe relatively stable replay-
ﬁtness values of around 0 .6, for different levels of noise. the discovered model at
0% noise level has a precision value of 1. this implies that the ﬁlter, in the case of
0% noise, removes behaviour that is present in the ground-truth event log. precisiondrops to around 0.7 for increasing levels of noise. the relative stable levels of replay-
ﬁtness and precision for increasing levels of noise when using using α=0 suggest
that the ﬁlter only incorporates a few branches of most frequent behaviour, which isthe same throughout different levels of noise. since the precision values are lower
than 1, combined with the fact that parallelism exists in the original model, it seems
that the most frequent branches do incorporate some form of parallelism that generatebehaviour not observed in the event log.
for the 5 and 10% noise levels we observe that threshold values in between 0 and
0.6 achieve acceptable levels of precision. these values are slightly lower than theprecision values related to 0% noise, which implies that the ﬁlter in these cases is
not able to remove all noise. the rapid trend towards precision values close to 0 for
threshold levels above 0.6 suggests that the ﬁlter does not remove any or very little
noise. for larger levels of noise we observe a steeper drop in precision. only very low
threshold levels (up to 0.2) achieve precision values around 0.3. the results suggestthat these levels of noise introduce levels of variety in the data that no longer allow
the sequence encoding ﬁlter to identify (in)frequent behaviour. hence, even for low
threshold values the ﬁlter still incorporates noise into the resulting process models.
for imi (figs. 4b,5b) we observe similar behaviour (note that the ﬁlter threshold
works inverted w.r.t. sequence encoding ﬁltering, i.e. a value of 1 implies most rigorous
ﬁltering). however, replay-ﬁtness drops a little earlier compared to sequence encodingﬁltering. the drop in precision of sequence encoding ﬁltering is smoother than the
drop in precision of imi, i.e. there exist some spikes within the graph. hence, the
applying ﬁltering within imi seems to be less deterministic.
finally, automaton based ﬁltering (figs. 4c,5c) rapidly drops to replay-ﬁtness
values of 0. upon inspection it turns out the ﬁlter returns empty event logs for the
corresponding threshold and noise levels. hence, the ﬁlter seems to be very sensitivearound a threshold value in-between 0 and 0 .2. the precision results for the automaton
based ﬁlter (fig. 5c) are as expected. with a low threshold value we have very low
precision, except when we have a 0% noise level. towards a threshold level of 0.2,
123discovering workﬂow nets using integer linear programming
precision increases after which it maximizes out to a value of 1. this is in line with
the replay-ﬁtness measurements.
we conclude that the sequence encoding ﬁlter and imi lead to comparable results.
however, the sequence encoding ﬁlter provides more expected results, i.e. imi behaves
somewhat less deterministic. the automaton based ﬁlter does provide good results,
however, sensibility of the ﬁlter threshold is much higher compared to sequence encod-ing ﬁltering and imi.
6.2 computation time
using sequence encoding ﬁltering, we leave out constraints refer to exceptional
behaviour. hence, we reduce the size of the core ilp constraint body and thus expecta decrease in computation time when applying rigorous ﬁltering, i.e. κ
α
max withα
towards 0. using rapidminer we repeated similar experiments to the experiments
performed for model quality, and measured cpu-execution time for the three tech-
niques. however, we only use threshold values 0, 0.25, 0.75 and 1.
in fig. 6we present the average cpu-execution time, based on 50 experiment rep-
etitions, needed to obtain a process model from an event log. for each level of noise
we depict computation time for different ﬁlter threshold settings. for imi, we mea-
sured the inductive miner algorithm with integrated ﬁltering. for sequence encodingand automaton ﬁltering, we measure the time needed to ﬁlter, discover a causal graph
and solve underlying ilp problems. observe that for imi and the automaton-based
ﬁlter, ﬁltering most rigorously is performed with threshold levels of 1, as opposed tosequence encoding ﬁltering which ﬁlters most rigorously at threshold 0.
fig. 6 cpu-execution time (ms) for a22f0nxx event logs (logarithmic scale) for different levels of noise.
the percentage of noise is depicted on top of each bar chart
123s. j. van zelst et al.
we observe that imi is fastest in most cases. computation time slightly increases
when the amount of noise increases within the event logs. for sequence encoding
ﬁltering we observe that lower threshold values lead to faster computation times. thisis as expected since a low threshold value removes more constraints from the ilp
constraint body than a high threshold value. the automaton-based ﬁlter is slowest
in all cases. the amount of noise seems to have little impact on the computationtime of the automaton-based ﬁlter, it seems to be predominantly depending on the
ﬁlter threshold. from fig. 6we conclude that imi in general out-performs sequence
encoding in terms of computation time. however, sequence encoding, in turn out-performs automaton-based ﬁltering.
6.3 application to real-life event logs
we tested the applicability of sequence encoding ﬁltering using real-life event logs. we
used an event log related to a road ﬁnes administration process [ 11] and one regarding
the treatment of patients suspected to have sepsis [ 19].
the results are presented in fig. 7. in case of the road fines event log (ﬁgures
on the left-hand side of fig. 7) we observe that replay-ﬁtness is around 0.46 whereas
precision is around 0.4 for α-values from 0 to 0.5. the number of arcs for the models
of these α-values remains constant (as well as the number of places and the number
of transitions) suggesting that the models found are the same. after this the replay-
ﬁtness increases further to around 0.8 and reaches 1 for an α-level of 1. interestingly,
precision shows a little increase around α-levels between 0.5 and 0.75 after which it
drops slightly below its initial value. in this case, an α-level in-between 0.5 and 0.75
seems most appropriate in terms of replay-ﬁtness, precision and simplicity.
in case of the sepsis event log (ﬁgures on the left-hand side of fig. 7) we observe
that replay-ﬁtness and precision are roughly behaving as each-other’s inverse, i.e.
replay-ﬁtness increases whereas precision decreases for increasing α-levels. we more-
over observe that the number of arcs within the process models is steadily increasing
for increasing α-levels. in this case, an α-level in-between 0.1 and 0.4 seems most
appropriate in terms of replay-ﬁtness, precision and simplicity.
finally, for each experiment we measured the associated computation time of solv-
ing all ilp problems. in case of the road fines event log, solving all ilp problems
(a) (b) (c) ( d)
fig. 7 a fitness and precision. bnumber of arcs. cfitness and precision. dnumber of arcs. replay-
ﬁtness, precision and complexity based on the road fines log [ 11]( f i g . 7a, b) and the sepsis log [ 19]
(fig. 7c, d)
123discovering workﬂow nets using integer linear programming
takes roughly 5 s. in case of the sepsis event log, obtaining a model ilp problems
takes less than 1 s.
as our experiments show, there is no speciﬁc threshold most suitable for sequence
encoding, i.e. this greatly depends on the event log. we do however observe that
using lower threshold values, e.g. 0–0.4, leads to less complex models. we therefore,
in practical settings, advise to use a lower threshold value ﬁrst, which also reducescomputation time due to a smaller constraint body size, and based on the obtained
result increase or decrease the threshold value if necessary.
7 conclusion
the work presented in this paper is motivated by the observation that existing region-
based process discovery techniques are useful, as they are able to ﬁnd non-localcomplex control ﬂow patterns. however, the techniques do not provide any struc-
tural guarantees w.r.t. the resulting process models, and, they are unable to cope with
infrequent, exceptional behaviour in event logs.
the approach presented in this paper extends techniques presented in [ 34,36,37].
we have proven that our approach is able to discover relaxed sound workﬂow nets,
i.e. we are now able to guarantee structural properties of the resulting process model.
additionally, we presented the sequence encoding ﬁltering technique which enables
us to apply ﬁltering exceptional behaviour within the ilp-based process discoveryalgorithm. our experiments conﬁrm that the technique enables us to ﬁnd meaning-
ful petri net structures in data consisting of exceptional behaviour, using ilp-based
process discovery as an underlying technique. sequence encoding ﬁltering provesto be comparable to the imi [ 15] approach, i.e. an integrated ﬁlter of the inductive
miner [ 16], in terms of ﬁltering behaviour. moreover, it is considerably faster than the
general purpose ﬁltering approach of [ 9] and less sensible to variations in the ﬁlter
threshold.
8 future work
an interesting direction for future work concerns combining ilp-based process dis-
covery techniques with other process discovery techniques. the inductive miner
discovers sound workﬂow nets, however, these models lack the ability to expresscomplex control ﬂow patterns such as a milestone pattern. some of these patterns are
however reconstructible using ilp-based process discovery. hence, it is interesting to
combine these approaches with possibly synergetic effects w.r.t. the process miningquality dimensions.
another interesting approach is the development of more advanced general purpose
ﬁltering techniques. most discovery algorithms assume the input event logs to be free ofnoise, infrequent and/or exceptional behaviour. real-life event logs however typically
contain a lot of such behaviour. surprisingly, little research is performed towards
ﬁltering techniques that greatly enhance process discovery results, independent of the
discovery algorithm used.
123s. j. van zelst et al.
open access this article is distributed under the terms of the creative commons attribution 4.0 interna-
tional license ( http://creativecommons.org/licenses/by/4.0/ ), which permits unrestricted use, distribution,
and reproduction in any medium, provided you give appropriate credit to the original author(s) and the
source, provide a link to the creative commons license, and indicate if changes were made.
references
1. badouel e, bernardinello l, darondeau p (1995) polynomial algorithms for the synthesis of bounded
nets. in: mosses pd, nielsen m, schwartzbach mi (eds) tapsoft’95: theory and practice of software
development, 6th international joint conference caap/fase, aarhus, denmark, may 22–26, 1995,proceedings. lecture notes in computer science, vol 915, pp 364–378. springer, berlin
2. bergenthum r, desel j, lorenz r, mauser s (2008) synthesis of petri nets from ﬁnite partial languages.
fundam inf 88(4):437–468
3. bergenthum r, desel j, lorenz r, mauser s (2007) process mining based on regions of languages. in:
alonso g, dadam p , rosemann m (eds) 5th international conference on business process management,bpm 2007, brisbane, australia, september 24–28, 2007, proceedings. lecture notes in computer
science, 4714, pp 375–383. springer
4. bernardinello l (1993) synthesis of net systems. in: marsan ma (ed) 14th international conference on
application and theory of petri nets 1993, chicago, il, usa, june 21-25, 1993, proceedings. lecture
notes in computer science, vol 691, pp 89–105. springer
5. bolt a, de leoni m, van der aalst wmp (2016) scientiﬁc workﬂows for process mining: building
blocks, scenarios, and implementation. sttt 18(6):607–628
6. buijs jcam, van dongen bf, van der aalst wmp (2012) a genetic algorithm for discovering pro-
cess trees. in: proceedings of the ieee congress on evolutionary computation, cec 2012, brisbane,
australia, june 10–15, 2012, pp 1–8. ieee
7. buijs jcam, van dongen bf, van der aalst wmp (2012) on the role of ﬁtness, precision, generalization
and simplicity in process discovery. in: meersman r, panetto h, dillon ts, rinderle-ma s, dadam
p , zhou x, pearson s, ferscha a, bergamaschi s, crux if (eds) on the move to meaningful internetsystems: otm 2012, confederated international conferences: coopis, doa-svi, and odbase 2012,
rome, italy, september 10–14, 2012. proceedings, part i. lecture notes in computer science, vol 7565,
pp 305–322. springer
8. carmona j, cortadella j (2014) process discovery algorithms using numerical abstract domains. ieee
trans knowl data eng 26(12):3064–3076
9. conforti r, la rosa m, ter hofstede ahm (2017) filtering out infrequent behavior from business
process event logs. ieee trans knowl data eng 29(2):300–314
10. darondeau p (1998) deriving unbounded petri nets from formal languages. in: sangiorgi d, de simone
r (eds) 9th international conference on concur ’98: concurrency theory, nice, france, september
8–11, 1998, proceedings. lecture notes in computer science, vol 1466, pp 533–548. springer
11. de leoni m, mannhardt f (2015) road trafﬁc ﬁne management process. https://doi.org/10.4121/uuid:
270fd440-1057-4fb9-89a9-b699b47990f5
12. de weerdt j, de backer m, v anthienen j, baesens b (2012) a multi-dimensional quality assessment
of state-of-the-art process discovery algorithms using real-life event logs. inf syst 37(7):654–676
13. ehrenfeucht a, rozenberg g (1990) partial (set) 2-structures. part i: basic notions and the representa-
tion problem. acta inf 27(4):315–342
14. ehrenfeucht a, rozenberg g (1990) partial (set) 2-structures. part ii: state spaces of concurrent systems.
acta inf 27(4):343–368
15. leemans sjj, fahland d, van der aalst wmp (2013) discovering block-structured process models
from event logs containing infrequent behaviour. in: lohmann n, song m, wohed p (eds) business
process management workshops—bpm 2013 international workshops, beijing, china, august 26,
2013, revised papers. lecture notes in business information processing , vol 171, pp 66–78. springer
16. leemans sjj, fahland d, van der aalst wmp (2013) discovering block-structured process models
from event logs—a constructive approach. in: colom jm, desel j (eds) application and theory of petri
nets and concurrency—34th international conference, petri nets 2013, milan, italy, june 24–28, 2013.
proceedings. lecture notes in computer science, vol 7927, pp 311–329. springer
17. lorenz r, juh g (2006) towards synthesis of petri nets from scenarios. in: donatelli s, thiagarajan
ps (eds) petri nets and other models of concurrency—ica tpn 2006, 27th international conference
123discovering workﬂow nets using integer linear programming
on applications and theory of petri nets and other models of concurrency, turku, finland, june 26–30,
2006, proceedings. lecture notes in computer science, vol 4024, pp 302–321. springer
18. lorenz r, mauser s, juh g (2007) how to synthesize nets from languages—a survey. in: henderson
sg, biller b, hsieh mh, shortle j, tew jd, barton rr (eds) proceedings of the winter simulation
conference, wsc 2007, washington, dc, usa, december 9–12, 2007, pp 637–647. wsc
19. mannhardt f (2016) sepsis cases—event log. https://doi.org/10.4121/uuid:915d2bfb-7e84-49ad-
a286-dc35f063a460
20. maruster l, weijters ajmm, van der aalst wmp , van den bosch a (2006) a rule-based approach
for process discovery: dealing with noise and imbalance in process logs. data min knowl discov
13(1):67–87
21. munoz-gama j (2016) conformance checking and diagnosis in process mining—comparing observed
and modeled processes. lecture notes in business information processing , vol 270. springer
22. murata t (1989) petri nets: properties, analysis and applications. proc ieee 77(4):541–580
23. reisig w (2013) the synthesis problem. trans petri nets other models concurr 7:300–313
24. schrijver a (1999) theory of linear and integer programming. wiley-interscience series in discrete
mathematics and optimization. wiley, london
25. solé m, carmona j (2010) process mining from a basis of state regions. in: lilius j, penczek w (eds)
applications and theory of petri nets, 31st international conference, petri nets 2010, braga, portugal,
june 21–25, 2010, proceedings. lecture notes in computer science, vol 6128, pp 226–245. springer
26. van der aalst wmp , bolt a, van zelst sj (2017) rapidprom: mine your processes and not just your
data. corr abs/1703.03740
27. van der aalst wmp (1998) the application of petri nets to workﬂow management. j circuits syst
comput 8(1):21–66
28. van der aalst wmp (2016) process mining—data science in action, 2nd edn. springer, berlin
29. van der aalst wmp , ter hofstede ahm, kiepuszewski b, barros ap (2003) workﬂow patterns. distrib
parallel datab 14(1):5–51
30. van der aalst wmp , weijters ajmm, maruster l (2004) workﬂow mining: discovering process models
from event logs. ieee trans knowl data eng 16(9):1128–1142
31. van der aalst wmp , rubin v , v erbeek hmw, van dongen bf, kindler e, günther cw (2010) process
mining: a two-step approach to balance between underﬁtting and overﬁtting. softw syst model 9(1):87–111
32. van der aalst wmp , van hee km, ter hofstede ahm, sidorova n, v erbeek hmw, v oorhoeve m,
wynn mt (2011) soundness of workﬂow nets: classiﬁcation, decidability, and analysis. formal aspcomput 23(3):333–363
33. van der aalst wmp , adriansyah a, van dongen bf (2012) replaying history on process models for
conformance checking and performance analysis. wiley interdiscipl rew data min knowl discov
2(2):182–192
34. van der werf jmem, van dongen bf, hurkens caj, serebrenik a (2009) process discovery using
integer linear programming. fundam info 94(3–4):387–412
35. van dongen bf, de medeiros aka, wen l (2009) process mining: overview and outlook of petri net
discovery algorithms. trans petri nets other models concurr 2:225–242
36. van zelst sj, van dongen bf, van der aalst wmp (2015) avoiding over-ﬁtting in ilp-based process
discovery. in: motahari-nezhad hr, recker j, weidlich m (eds) business process management—13thinternational conference, bpm 2015, innsbruck, austria, august 31–september 3, 2015, proceedings.
lecture notes in computer science, vol 9253, pp 163–171. springer
37. van zelst sj, van dongen bf, van der aalst wmp (2015) ilp-based process discovery using hybrid
regions. in: van der aalst wmp , bergenthum r, carmona j (eds) proceedings of the a taed 2015
workshop, satellite event of petri nets/acsd 2015, brussels, belgium, june 22–23, 2015. ceurworkshop proceedings, vol 1371 pp 47–61. ceur-ws.org
38. van zelst sj, van dongen bf, van der aalst wmp , v erbeek hmw (2017) discovering relaxed sound
workﬂow nets using integer linear programming. corr abs/1703.06733
39. v erbeek hmw, buijs jcam, van dongen bf, van der aalst wmp (2010) xes, xesame, and prom 6.
in: soffer p , proper e (eds) information systems evolution—caise forum 2010, hammamet, tunisia,
june 7–9, 2010, selected extended papers. lecture notes in business information processing , vol 72,
pp 60–75. springer
123s. j. van zelst et al.
40. weijters ajmm, ribeiro jts (2011) flexible heuristics miner (fhm). in: proceedings of the ieee
symposium on computational intelligence and data mining, cidm 2011, part of the ieee symposiumseries on computational intelligence 2011, april 11–15, 2011, paris, france, pp 310–317
41. weijters ajmm, van der aalst wmp (2003) rediscovering workﬂow models from event-based data
using little thumb. integr comput-aided eng 10(2):151–162
123