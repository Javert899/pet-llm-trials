data-aware process oriented query
language
eduardo gonzalez lopez de murillas, hajo a. reijers,
a n dw i lm .p .v a nd e ra a l s t
abstract the size of execution data available for process mining analysis grows
several orders of magnitude every couple of years. extracting and selecting the
relevant data to enable process mining remains a challenging and time-consuming
task. in fact, it is the biggest handicap when applying process mining and other
forms of process-centric analysis. this work presents a new query language,
dapoq-lang, which overcomes some of the limitations identiﬁed in the ﬁeld of
process querying and ﬁts within the process querying framework. the language
is based on the openslex meta model, which combines both data and process
perspectives. it provides simple constructs to intuitively formulate questions. the
syntax and semantics have been formalized and an implementation of the language
is provided, along with examples of queries to be applied to different aspects of the
process analysis.
1 introduction
one of the main goals of process mining techniques is to obtain insights into the
behavior of systems, companies, business processes, or any kind of workﬂow under
study. obviously, it is important to perform the analysis on the right data. data
extraction and preparation are among the ﬁrst steps to take and, in many cases, up
to 80% of the time and effort, and 50% of the cost is spent during these phases [ 12].
e. g. l. de murillas ( /envelopeback)
department of mathematics and computer science, eindhoven university of technology,
eindhoven, the netherlands
h. a. reijers
department of information and computing sciences, utrecht university, utrecht, the
netherlands
e-mail: h.a.reijers@uu.nl
w. m. p. van der aalst
department of computer science, rwth aachen university, aachen, germany
e-mail: wvdaalst@pads.rwth-aachen.de
© springer nature switzerland ag 2022
a. polyvyanyy (ed.), process querying methods ,
https://doi.org/10.1007/978-3-030-92875-9_34950 e. g. l. de murillas et al.
being able to extract and query some sp eciﬁc subset of the data becomes crucial
when dealing with complex and heterogeneous datasets. in addition, the use ofquerying tools allows one to ﬁnd speciﬁc cas es or exceptional behavior. whatever
the goal, analysts often ﬁnd themselves in the situation in which they need to developad hoc software to deal with speciﬁc datasets, given that existing tools might bedifﬁcult to use, too general, or just not suitable for process analysis.
different approaches exist to support the querying of process data . some of them
belong to the ﬁeld of business process man agement (bpm). in this ﬁeld, events are
the main source of information. they represent transactions or activities that wereexecuted at a certain moment in time in the environment under study. queryingthis kind of data allows us to obtain valuable information about the behavior andexecution of processes. there are other approaches originating from the ﬁeld of dataprovenance, which are mainly concerned with recording and observing the originsof data. this ﬁeld is closely related to scientiﬁc workﬂows in which the traceabilityof the origin of experimental results beco mes crucial to guarantee correctness and
reproducibility. in the literature, we ﬁnd many languages to query process data.however, none of these approaches succeeds at combining process and data aspectsin an integrated way. an additional challenge to overcome is the development of aquery mechanism that allows to exploit this combination, while being intuitive ande a s yt ou s e .
in order to make the querying of process event data easier and more efﬁcient, we
propose the data-aware process oriented query language (dapoq-lang). thisquery language, ﬁrst introduced in [ 3], exploits both process and data perspectives.
the aim of dapoq-lang is not to theoretically enable new types of computations,but to ease the task of writing queries in the speciﬁc domain of process mining.therefore, our focus is on the ease of use. we propose the following example toshow the ease of use of dapoq-lang. let us consider a generic question that couldb ea s k e db ya na n a l y s tw h e nc a r r y i n g out a process mining project:
gq: in which cases, there was (a) an event that happened between time t1 and t2, (b) that
performed a modiﬁcation in a version of class c, (c) in which the value of ﬁeld f changedfrom x to y?
this query involves several types of elements: cases, events, object versions, and
attributes. we instantiate this query with some speciﬁc values for t1 = “1986/09/1700:00”, t2 = “2016/ 11/30 19:44”, c = “customer”, f = “address”, x =
“fifth avenue”, and y = “sunset boulevard”. query 1presents the corresponding
dapoq-lang query. this example shows how compact a dapoq-lang query canbe. the speciﬁcs of this query will be explained in the coming sections.
the rest of this chapter is organized as follows. section 2introduces some
background information, which is needed to understand the speciﬁcs of ourquery language. section 3presents the query language, focusing on the syntax
and semantics. section 4provides information about the implementation and its
evaluation. section 5presents possible use cases. section 6positions dapoq-lang
in the process querying framework [ 10]. section 7concludes the chapter.data-aware process oriented query language 51
query 1 dapoq-lang query to retrieve cases with an event happening between two dates that
changed the address of a customer from “fifth avenue” to “sunset boulevard”.
1 def p1=createperiod ("1986/09/17
 00:00" ,"2016/11/30
 19:44" ,"yyyy/mm/dd
 hh:mm
/arrowhookleft→")
2
3 casesof (
4 eventsof (
5 versionsof (
6 allclasses () .where {name =="customer" }
7) . where {
8 changed ([at:"address" ,from :"fifth
 avenue" ,to:"sunset
 boulevard" ]) }
9) . where
10 {
11 def p2=createperiod (it. timestamp )
12 during (p 2,p 1)
13 }
14 )
2 preliminaries
to enable our approach to data querying, we need to have access to data storage,
and the information should comply with a certain structure. an appropriate structure
has been previously deﬁned as a meta model [ 4] and implemented in a queryable
ﬁle format called openslex. the meta model captures all the necessary aspects
to enable data querying with our language. this section describes the structure of
openslex and provides the necessary background to understand the details of
dapoq-lang.
standards of reference, like xes [ 5], are focused on the process view (events,
traces, and logs) of systems. openslex supports all concepts present in xes but,
in addition, considers the data elements (data model, objects, and versions) as an
integral part of its structure. this makes it more suitable for database environments
where only a small part of the informatio n is process-oriented (i.e., events) with
respect to the rest of data objects of different classes that may be seen as an
augmented view on the process information. the openslex format is supported
by a meta model (fig. 1) that considers data models andprocesses as the entities at
the highest abstraction level. these entities deﬁne the structure of more granular
elements like logs,cases ,a n d activity instances with respect to processes and
objects with respect to classes in the data model. each of these elements at the
intermediate level of abstraction can be broken apart into more granular pieces.
this way, cases are formed by events ,a n d objects can be related to several object
versions .b o t h events andobject versions represent different states of a higher level
abstraction ( cases orobjects ) at different points in time. a detailed er diagram
of the openslex format can be found online.1the format makes use of an sql
1https://github.com /edugonza/openslex/blob/ma ster/doc/meta-model.png .52 e. g. l. de murillas et al.
fig. 1 er diagram of the openslex meta model. the entities have been grouped into sectors,
delimited by the dashed linesdata-aware process oriented query language 53
schema to store all the information, and a java api2is available for its integration
in other tools. the use of openslex in several environments, e.g., database redo
logs and erp databases, is evaluated in [ 4], focusing on the data extraction and
transformation phase. to provide the necessary background for the understanding
of this work, a simpliﬁed version of the meta model is formally presented below.
every database system contains information structured with respect to a data model.
deﬁnition 1provides a formalization of a data model in the current context.
deﬁnition 1 (data model) a data model is a tuple dm =(cl,at,
classofattribute ,rs,sourceclass ,targetclass ), such that
–clis a set of class names.
–atis a set of attribute names.
–classofattribute ∈at→clis a function that maps each attribute to a class.
– rs is a set of relationship names.
–sourceclass ∈rs→clis a function mapping each relationship to its source
class.
–targetclass ∈rs→clis a function mapping each relationship to its target
class.
data models contain classes (i.e., table s), which contain attribute names (i.e.,
columns). classes are related by means of relationships (i.e., foreign keys). deﬁ-
nition 2formalizes each of the entities of the openslex meta model, as can be
observed in fig. 1, and shows connections between them.
deﬁnition 2 (connected meta model) letvbe some universe of values and
tsa universe of timestamps. a connected meta model is deﬁned as a tuple
cmm =(dm,oc,classofobject ,ovc,objectofversion ,ec,eventtoovlabel ,
ic,eventai ,pmc,activityofai ,processoflog )such that
–dm=(cl,at,classofattribute ,rs,sourceclass ,targetclass )is a data model.
–ocis a collection of objects.
–classofobject ∈oc→ cl is a function that maps each object to its
corresponding class.
–ovc=(ov,attvalue ,starttimestamp ,endtimestamp ,rel)is a version collec-
tion, where ovis a set of object versions, attvalue ∈(at×ov)/negationslash→vis a map-
ping of pairs of object version and attribute to a value, starttimestamp ∈ov→
tsis a mapping between object versions and start timestamps, endtimestamp ∈
ov→tsis a mapping between object versions and end timestamps, and
rel⊆(rs×ov×ov)is a set of triples relating pairs of object versions through
a speciﬁc relationship.
–objectofversion ∈ov→ocis a function that maps each object version to an
object.
–ec=(ev,evat,eventtimestamp ,eventlifecycle ,eventresource ,
eventattributevalue )is an event collection, where evis a set of events, evat
2https://github.com /edugonza/openslex .54 e. g. l. de murillas et al.
is a set of event attribute names, eventtimestamp ∈ev→tsmaps events to
timestamps, eventlifecycle ∈ev→{ start,complete ,...}maps events to life
cycle attributes, eventresource ∈ev→vmaps events to resource attributes,
andeventattributevalue ∈(ev×evat)/negationslash→vmaps pairs of event and attribute
name to values.
–eventtoovlabel ∈(ev×ov)/negationslash→vis a function that maps pairs of an event
and an object version to a label. the exist ence of a label associated with an event
and an object version, i.e., (ev,ov) ∈dom( eventtoovlabel ), means that both
event and object version are linked. the label deﬁnes the nature of the link, e.g.,
“insert”, “update”, “delete”, etc.
–ic=(ai,cs,lg,aisofcase ,casesoflog ,csat,caseattributevalue ,lgat,
logattributevalue )is an instance collection, where aiis a set of activity instances,
csis a set of cases, lgis a set of logs, aisofcase ∈cs→ p(ai)is a mapping
between cases and sets of activity instances,3casesoflog ∈lg→ p(cs)is a
mapping between logs and sets of cases, csat is a set of case attribute names,
caseattributevalue ∈(cs×csat)/negationslash→vmaps pairs of case and attribute name
to values, lgat is a set of log attribute names, and logattributevalue ∈(lg×
lgat)/negationslash→vmaps pairs of log and attribute name to values.
–eventai ∈ev→aiis a function that maps each event to an activity instance.
–pmc=(pm,ac,actofproc )is a process model collection, where pmis a set of
processes, acis a set of activities, and actofproc ∈pm→ p(ac)is a mapping
between processes and sets of activities.
–activityofai ∈ai→acis a function that maps each activity instance to an
activity.
–processoflog ∈lg→pmis a function that maps each log to a process.
a connected meta model (cmm) provides the functions that make it possible to
connect all the entities in the meta model. this is important in order to correlate
elements, e.g., events that modiﬁed the same object. however, some constraints
must be fulﬁlled for a meta model to be considered a valid connected meta model
(e.g., versions of the same object do not overlap in time). the details about such
constraints are out of the scope of this work, but their description can be found in [ 4].
dapoq-lang queries are executed on data structures that fulﬁll the constraints
set on the deﬁnition of a connected meta model. according to our meta model
description, events can be linked to object versions , which are related to each other
by means of relations .t h e s e relations are instances of data model relationships .i n
database environments, this would be the equivalent to using foreign keys to relate
table rows and knowing which events rel ate to each row. for the purpose of this
work, we assume that pairwise correlations between events, by means of related
object versions, are readily available in the input connected meta model.
3p(x) is the powerset of x, i.e.,y∈p(x) ify⊆x.data-aware process oriented query language 55
3 dapoq-lang
dapoq-lang is a data-aware process oriented query language that allows the
user to query data and process information stored in a structure compatible with theopenslex meta model [ 4]. as described in sect. 2, openslex combines database
elements (data models, objects, and obj ect versions) with common process mining
data (events, logs, and processes), considering them as ﬁrst-class citizens. dapoq-lang considers the same ﬁrst-class citizens as openslex, which makes it possibleto write queries in the process mining domain enriched with data aspects with lowercomplexity than in other general purpose query languages like sql.
intuitively, we could think that considering all the elements of the openslex
meta model as ﬁrst-class citizens would introduce a lot of complexity in our lan-guage. however, these elements have been organized in a type hierarchy as subtypesof higher level superclasses (fig. 2). it can be seen that mmelement (meta model
element) is an abstract class at the highest level superclass . next, we distinguish two
subtypes of elements: (1) stored elements ( storedelement ), i.e., elements that can be
found directly stored in an openslex stru cture, such as activities, events, objects,
and logs and (2) computed elements ( computedelements ), i.e., elements that are
computed based on the rest, temporal periods of cases and temporal periods ofevents. we will exploit this hierarchy to design a simple language, providing many
basic functions that can operate on any mmelement , and some speciﬁc functions
that focus on speciﬁc subtypes. given a connected meta model cmm (deﬁnition 2),
we deﬁne the concept of mmelement in dapoq-lang as the union of all its
terminal subtypes: mmelement =ac∪lg∪ev∪rel∪oc∪at∪cl∪per∪
pm∪cs∪ai∪ov∪rs∪dm. some of the functions that we deﬁne operate on sets
of elements ( p(mmelement )). however, as a constraint of our query language, we
require that the elements of those sets belong to the same subtype (i.e., a set of class
elements, or a set of version elements, or a set of event elements, etc.). therefore,
we deﬁne the set mmsets as the set of all possible subsets of each element type in a
fig. 2 dapoq-lang type hierarchy. arrows indicate subtype relations56 e. g. l. de murillas et al.
meta model mm:
mmsets =p(ac)∪p(lg)∪p(ev ) ∪p(rel)∪p(oc)∪p(at )∪p(cl)∪
p(per)∪p(pm)∪p(cs)∪p(ai)∪p(ov)∪p(rs)∪p(dm)
(1)
the output of any query will be an element set es∈mmsets , i.e., a set of
elements of the same type. the following subsections describe the syntax andsemantics of dapoq-lang in detail.
3.1 syntax
the language has been designed with the aim to ﬁnd a balance between simplicityand expressive power. to do so, we exploited the speciﬁcs of the underlying metamodel deﬁning a total of 57 basic functions, as organized in 5 well-deﬁned blocks,that can be applied in the context of a given meta model mm. the functions
proposed in sects. 3.1.1 –3.1.5 will be used to deﬁne syntax and semantics of
dapoq-lang in sects. 3.1and3.2.
3.1.1 terminal meta model elements
we deﬁne a set of 13 basic terminal functions. each of them maps to the set of all
elements of the corresponding type (fig. 2) in the openslex meta model structure
(deﬁnition 2). given a connected meta model, we deﬁne the following:
1.alldatamodels : the set of all data models, i.e., dm.
2.allclasses : the set of all classes, i.e., cl.
3.allattributes : the set of all class attributes, i.e., at.
4.allrelationships : the set of all class relationships, i.e., rs.
5.allobjects : the set of all objects, i.e., oc.
6.allversions : the set of all object versions, i.e., ov.
7.allrelations : the set of all relations, i.e., rel .
8.allevents :t h es e to fa l le v e n t s ,i . e . , ev.
9.allactivityinstances : the set of all activity instances, i.e., ai.
10.allcases : the set of all cases, i.e., cs.
11.alllogs : the set of all logs, i.e., lg.
12.allactivities : the set of all activities, i.e., ac.
13.allprocesses : the set of all processes, i.e., pm.data-aware process oriented query language 57
3.1.2 elements related to elements
the following 14 functions take as an input a set of elements of the same type and
return a set of elements related to them of the type corresponding to the return typeof the function, e.g., a call to eventsof (es),b e i n g es∈p(lg)will return the set
of events that are related to the logs in the set es. thanks to the subtype hierarchy,
in most of the cases, we can reuse the same function call for input sets of any type,which leads to a more compact syntax. in the cases when an input of any type wouldnot make sense, we can still restrict the input type to a particular kind, as is the casewith the function versionsrelatedto , which only accepts sets of object versions as
input.
14.datamodelsof ∈mmsets → p(dm): returns the set of data models related to
the input.
15.classesof ∈mmsets → p(cl): returns the set of classes related to the input.
16.attributesof ∈mmsets → p(a): returns the set of attributes related to the
input.
17.relationshipsof ∈mmsets → p(rs): returns the set of relationships related
to the input.
18.objectsof ∈mmsets → p(o): returns the set of objects related to the input.
19.versionsof ∈mmsets → p(ov): returns the set of object versions related to
the input.
20.relationsof ∈mmsets → p(rel): returns the set of relations related to the
input.
21.eventsof ∈mmsets → p(e): returns the set of events related to the input.
22.activityinstancesof ∈mmsets → p(ai): returns the set of activity instances
related to the input.
23.activitiesof ∈mmsets → p(ac): returns the set of activities related to the
input.
24.casesof ∈mmsets → p(cs): returns the set of cases related to the input.
25.logsof ∈mmsets → p(lg): returns the set of logs related to the input.
26.processesof ∈mmsets → p(pm): returns the set of processes related to the
input.
27.versionsrelatedto ∈p(ov ) → p(ov): returns the set of object versions
directly related (distance 1) to the input object versions through any kind ofrelationship.
3.1.3 computation of temporal values
some elements in our meta model contain temporal properties (e.g., events have
timestamps, object versions have life spans, etc.) which allows making temporalcomputations with them. to do so, we provide the following 8 functions to computetime periods (with a start and an end), as well as durations. durations ( dur )a r e
special in the sense that they can be cons idered as a scalar and are not part of the58 e. g. l. de murillas et al.
table 1 relations in allen’s interval algebra
relation
 name
 illustration
 interpretation
x<y
 before
 x
x takes place before y
y>x
 after
 y
xmy
 meets
 x
x meets y ( istands for inverse )
ymix
 meetsinv
 y
xoy
 overlaps
 x
x overlaps with y
yoix
 overlapsinv
 y
xsy
 starts
 x
xs t a r t syysix
 startsinv
 y
xdy
 during
 x
x during yydix
 duringinv
 y
xfy
 ﬁnishes
 x
xﬁ n i s h e syyﬁx
 ﬁnishesinv
 y
x=y
 matches
x
x is equal to y
y
mmelement subtype hierarchy. durations can only be used to be compared with
other durations.
28.periodsof ∈mmsets → p(per): returns the computed periods for each of
the elements of the input set.
29.globalperiodof ∈mmsets →per : returns a global period for all the elements
in the input set, i.e., the period from the earliest to the latest timestamp.
30.createperiod ∈ts×ts→per : returns a period for the speciﬁed start and end
timestamps.
31.getduration ∈per→dur : returns the duration of a period in milliseconds.
32.duration .ofseconds ∈n→dur : returns the duration of the speciﬁed
seconds.4
33.dduration .ofminutes ∈n→dur : returns the duration of the speciﬁed
minutes.
34.duration .ofhours ∈n→dur : returns the duration of the speciﬁed hours.
35.duration .ofdays ∈n→dur : returns the duration of the speciﬁed days.
3.1.4 temporal interval algebra
allen’s interval algebra, described in [ 1], introduces a calculus for temporal
reasoning that deﬁnes possible relations between time intervals. it provides the
tools to reason about the temporal descriptions of events in the broadest sense.
table 1shows the 13 base relations between two intervals. these temporal relations
4nis the set of natural numbers.data-aware process oriented query language 59
are used in our approach to reason about data elements for which we can compute
a temporal interval.
we have introduced the functions to compute and create periods of time. the
following 13 functions cover all the interval operators, described by allen’s interval
algebra, that we can use to compare periods. take (a,b) to be a pair of periods for
which:
36.before ∈per×per→b:before (a,b)iffatakes place before b.5
37.after∈per×per→b:after(a,b)iffatakes place after b.
38.meets ∈per×per→b:meets(a,b)iff the end of ais equal to the start of b.
39.meetsinv ∈per×per→b:meetsinv (a,b)iff the start ais equal to the end
ofb.
40.overlaps ∈per×per→b:overlaps (a,b)iff the end of ahappens during b.
41.overlapsinv ∈per×per→b:overlapsinv (a,b)iff the start of ahappens
during b.
42.starts ∈per×per→b:starts(a,b)iff both start at the same time, but ais
shorter.
43.startsinv ∈per×per→b:startsinv (a,b)iff both start at the same time, but
ais longer.
44.during ∈per×per→b:during (a,b)iffastarts after bstarted and ends
before bends.
45.duringinv ∈per×per→b:duringinv (a,b)iffastarts before bstarts and
ends after bends.
46.ﬁnishes ∈per×per→b:ﬁnishes (a,b)iff both end at the same time, but a
is shorter.
47.ﬁnishesinv ∈per×per→b:ﬁnishesinv (a,b)iff both end at the same time,
butais longer.
48.matches ∈per×per→b:matches (a,b)iff both have the same start and
end.
3.1.5 operators on attributes of elements
events, object versions, cases, and logs of the openslex meta model can be
enriched with attribute values. the following functions allow the user to obtain their
values:
49.eventhasattribute ∈evat ×ev→b:true iff the event contains a value for a
certain attribute name.
50.versionhasattribute ∈at×ov→b:true iff the object version contains a
value for a certain attribute name.
51.casehasattribute ∈csat ×cs→b:true iff the case contains a value for a
certain attribute name.
5bis the set of boolean values.60 e. g. l. de murillas et al.
52.loghasattribute ∈lgat ×lg→b:true iff the log contains a value for a
certain attribute name.
53.getattributeevent ∈evat ×ev/negationslash→v: returns the value for an attribute of an
event.
54.getattributeversion ∈at×ov/negationslash→v: returns the value for an attribute of an
object version.
55.getattributecase ∈csat ×cs/negationslash→v: returns the value for an attribute of a
case.
56.getattributelog ∈lgat ×lg/negationslash→v: returns the value for an attribute of a log.
57.versionchange ∈at×v×v×ov→b:true iff the value for an attribute
linked to an object version changed from a certain value (in the previous objectversion) to another (in the provided object version).
by deﬁnition, getattribute* functions (items 53 to 56) are deﬁned for combina-
tions of elements and attributes for which the corresponding *hasattribute function
(items 49 to 52) evaluates to true.
3.1.6 abstract syntax
the abstract syntax of dapoq-lang is deﬁned using the notation proposed
in [8]. in dapoq-lang, a query is a sequence of assignments combined with an
elementset :
query/definess:assignments ;es:elementset
assignments /definesassignment
∗
the result of a query is an elementset , i.e., the set of elements (of the same type)
from the queried openslex dataset that satisﬁes certain criteria. an assignment
assigns an elementset to a variable. then, any reference to such variable, via its
identiﬁer, will be replaced by the corresponding elementset .
assignment /definesv:varname ;es:elementset
varname /definesidentiﬁer
anelementset can be deﬁned over other elementsets byconstruction or
application . it can also be deﬁned by means o f a variable identiﬁer, i.e., an
elementsetvar , by a call to a terminal element function with an elementsetterminaldata-aware process oriented query language 61
(sect. 3.1.1 ), by computation or creation of periods , or by ﬁltering elements of the
previous options with a filteredelementset .
elementset /definesconstruction |application |period |elementsetvar |
elementsetterminal |filteredelementset
elementsetvar /definesidentiﬁer
anelementsetterminal is the elementset resulting from a call to the correspond-
ing terminal element function (e.g., allevents).
elementsetterminal /definesalldatamodels |allclasses |allattributes |
allrelationships |allobjects |allversions |
allrelations |allactivityinstances |allevents |
allcases |alllogs |allactivities |allprocesses
anelementset can be composed from other elementsets by applying set
operations such as union ,exclusion ,a n d intersection .
construction /defineses1,es 2:elementset ;o:set_op
set_op/definesunion |excluding |intersection
also, an elementset can be constructed by means of a call to one of the
elementof_op functions, which includes the functions described in sect. 3.1.2
that return sets of elements related to other elements, and the periodsof function
described in sect. 3.1.3 that computes the periods of elements.
application /defineses:elementset ;o:elementof _op
elementof _op/definesdatamodelsof |classesof |attributesof |relationshipsof |
objectsof |versionsof |relationsof |eventsof |
activityinstancesof |casesof |activitiesof |logsof |
processesof |periodsof |versionsrelatedto
anelementset can be built by means of ﬁltering, discarding elements of
another elementset according to certain criteria. th ese criteria are expressed as a
predicateblock , which will be evaluated for each member of the input elementset .
depending on the result of evaluating the predicateblock , each element will be
ﬁltered out or included in the new elementset .
filteredelementset /defineses:elementset ;pb:predicateblock62 e. g. l. de murillas et al.
apredicateblock is a sequence of assignments combined with a predicate .s u c h
predicate can be recursively deﬁned as a binary ( and,or) or unary ( not) combination
of other predicates .
predicateblock /definess:assignments ;p:predicate
predicate /definesattributepredicate |un_predicate |bin_predicate |
temporalpredicate
bin_predicate /definesp1,p2:predicate ;o:binlogical _op
un_predicate /definesp:predicate ;o:unlogical _op
binlogical _op/definesand|or
unlogical _op/definesnot
also, a predicate can be deﬁned as an attributepredicate , which either refers
toattributeexists function that checks the existence of an attribute for a certain
element, an operation on attribute values (e.g., to compare attributes to substrings,constants, or other attributes), or an attributechange predicate, making use of the
functions speciﬁed in sect. 3.1.5 .
attributepredicate /definesattributeexists |attributev aluepred |attributechange
attributeexists /definesat:attributename
attributevaluepred /definesat1,at2:attribute ;o:value _op
attributechange /definesat:attributename ;from,to:value
attributename /definesidentiﬁer
value _op/defines== | >=| <=| >|<|startswith |endswith |contains
attribute /definesattributename |value
value/definesliteral
finally, a predicate can be deﬁned as a temporalpredicate , i.e., a boolean
operation comparing periods or durations. period comparisons based on allen’s
interval algebra are supported by the functions deﬁned in sect. 3.1.4 .duration
comparisons are done on simple scalars (e.g., ==, >,<,≥,a n d≤). a period can
be either created from some provided timestamps with the function createperiod or
computed as the global period of an element or a set of elements with the functionglobalperiodof .a l s o ,a period can be constructed referring to a variable containing
another period by means of an identiﬁer. durations can be obtained from existingdata-aware process oriented query language 63
periods (with the function durationof ) or created from speciﬁc durations in seconds,
minutes, hours, or days with the functions deﬁned in sect. 3.1.3 .
temporalpredicate /definesper1,per2:period ;o:period _op|
dur1,dur2:duration ;o:numerical _comp _op
period/definesperiodcreation |periodvar
periodcreation /definests1,ts2:timestamp ;o:createperiod |
es:elementset ;o:globalperiodof
periodvar /definesidentiﬁer
period _op/definesbefore |after|meets |meetsinv |overlaps |
overlapsinv |starts|startsinv |during |
duringinv |ﬁnishes |ﬁnishesinv |matches
duration /definesp:period ;o:getduration |v:value;o:durationof
durationof /definesduration .ofseconds |duration .ofminutes |
duration .ofhours |duration .ofdays
numerical _comp _op/defines== | >=|<=|>|<
figure 3shows the syntax tree of query 1according to the presented abstract
syntax. it also contains elements of the proposed concrete syntax, presented in detailin sect. 5
, to demonstrate the mapping to real dapoq-lang queries.
3.2 semantics
in this section, we make use of denotational semantics, as proposed in [ 8], to
describe the meaning of dapoq-lang queries. we deﬁne function mtto describe
the meaning of the nonterminal term t(e.g.,mquery describes the meaning of the
nonterminal query ). first, we introduce a notation of overriding union that will be
used in further discussions.
deﬁnition 3 (overriding union) the overriding union of f:x→ybyg:x→
yis denoted as f⊕g:x→ysuch that dom(f ⊕g)=dom(f) ∪dom(g) and
f⊕g(x)=/braceleftbigg
g(x) ifx∈dom(g)
f(x) ifx∈dom(f) \dom(g).64 e. g. l. de murillas et al.
query
assignments
assignment
v
varname
p1es
elementset
period
periodcreation
ts1
timestamp
“1986/09/17
00:00”ts2
timestamp
“2016/11/30
19:44”o
createperiodelementset
application
es
elementset
filtered
elementset
application
es
elementset
filtered
elementset
es
elementset
application
filtered
elementset
es
elementset
elementset
terminal
allclassespb
predicateblock
assignments predicate
attributepredicate
attributevaluepred
at1
attribute
attribute
name
nameat2
attribute
value
“customer”o
value op
==o
elementof op
versionsofpb
predicateblock
assignments predicate
attribute
predicate
attribute
change
at
attribute
name
“address”from
value
“fifth
avenue”to
value
“sunset
boulevard”o
elementof op
eventsofpb
predicateblock
s
assignments
assignment
v
varname
p2es
elementset
period
periodcreation
ts1
timestamp
it.timestampo
createperiodp:predicate
temporalpredicate
per1
period
periodvar
p2per2
period
periodvar
p1o
period op
duringo
elementof op
casesof
fig. 3 syntax tree of dapoq-lang query 1
in the previous section, we have introduced the use of variables in the language.
these variables must be translated into a value in mmsets (eq. 1) during the
execution of our queries. a binding assigns a set of elements to a variable name:
binding/definesvarname →mmsets
queries are computed based on a dataset complying with the structure of the
openslex meta model. such a meta model can be seen as a tuple of sets ofelements of each of the basic types:
metamodel /defines(ac,lg,ev,rel,oc,at,cl,per,
pm,cs,ai,ov,rs,dm)data-aware process oriented query language 65
the meaning function of a query takes a query and a meta model dataset as an
input and returns a set of elements that satisfy the query:
mquery:query ×metamodel →mmsets
this function is deﬁned as
mquery [q:query,mm:metamodel ]/definesmelementset (q.es, mm,m assignments (q.s, mm,∅))
the evaluation of the query meaning function mquery depends on the evaluation
of the assignments and the element set invo lved. evaluating the assignments means
resolving their corresponding element sets and remembering the variables to whichthey were assigned.
m
assignments :assignments ×metamodel ×binding →binding
a sequence of assignments resolves to a binding, which links sets of elements
to variable names. assignments that happe n later in the order of declaration take
precedence over earlier ones when they share the variable name.
massignments [s:assignments ,mm:metamodel ,b:binding ]/defines
if¬(s.tail).empty then
massignments (s.tail,mm,b⊕massignment (s.first ,mm,b ) )
elseb
the result of an assignment is a binding, linking a set of elements to a variable
name.
massignment :assignment ×metamodel ×binding →binding
massignment [a:assignment ,mm:metamodel ,b:binding ]/defines
{(a.v, melementset (a.es,mm,b ) )}
anelementset within the context of a meta model and a binding returns a set of
elements of the same type that satisfy the restrictions imposed by the elementset .
melementset :elementset ×metamodel ×binding →mmsets
anelementset can be resolved as a construction of other elementsets with the
well-known set operations of union, exclusion, and intersection. it can be the resultof evaluating an application function, returning elements related to other elements,
the result of the creation of periods , or the value of a variable previously declared66 e. g. l. de murillas et al.
(elementsetvar ). also, it can be the result of a terminal elementset ,e . g . ,t h es e t
of all the events ( allevents ). finally, an elementset can be the result of ﬁltering
another elementset according to predicateblock ,w h i c hi sa predicate preceded
by a sequence of assignments .t h e s e assignments are only valid within the scope
of the predicateblock and are not propagated outside of it (i.e., if a variable is
reassigned, it will maintain its original value outside of the predicateblock ). the
resulting filteredelementset will contain only the elements of the input elementset
for which the evaluation of the provided predicate istrue.
melementset [es:elementset ,mm:metamodel ,b:binding ]/defines
caseesof
construction ⇒
casees.o of
union ⇒melementset (es.es1,mm,b )∪melementset (es.es2,mm,b )
excluding ⇒melementset (es.es1,mm,b )\melementset (es.es2,mm,b )
intersection ⇒melementset (es.es1,mm,b )∩melementset (es.es2,mm,b )
end
application ⇒es.o( melementset (es.es,mm,b ) )
period ⇒mperiod(es,mm,b )
elementsetvar ⇒⎧
⎨
⎩b(es)ifes∈dom(b)
∅ otherwise
elementsetterminal ⇒esmm
filteredelementset ⇒{e∈melementset (es.es,mm,b )|
mpredicate (es.pb.p,mm,massignments (es.pb.s,mm,b⊕(it, e)))}
end
apredicate is evaluated as a boolean, with respect to a metamodel and a
binding :
mpredicate :predicate ×metamodel ×binding →b
the meaning function of predicate evaluates to a boolean value, which can be
recursively constructed combining binary ( and,or)o ru n a r y( not) predicates. also,
apredicate can be deﬁned as an attributepredicate that evaluates the existence
of attributes, comparisons of attribute val ues, or attribute value changes. finally,
apredicate can be deﬁned as a temporalpredicate , which can compare durations or
periods by means of allen’s interval algebra operators.data-aware process oriented query language 67
mpredicate [p:predicate ,mm:metamodel ,b:binding ]/defines
casepof
attributepredicate ⇒
casepof
attributeexists ⇒ ifb(it)∈ev:eventhasattribute (p.at,b(it))
elifb(it)∈ov:versionhasattribute (p.at,b(it))
elifb(it)∈cs:casehasattribute (p.at,b(it))
elifb(it)∈lg:loghasattribute (p.at,b(it))
else:∅
attributevaluepred ⇒
p.o(mattribute (p.at1,b(it),mm),mattribute (p.at2,b(it),mm))
attributechange ⇒
ifb(it)∈mm.ovthen:versionchange (p.at,p.from,p.to,b(it))else:∅
end
un_predicate ⇒¬ mpredicate (p.p, mm,b )
bin_predicate ⇒
casep.oof
and⇒mpredicate (p.p 1,mm,b )∧mpredicate (p.p 2,mm,b )
or⇒mpredicate (p.p 1,mm,b )∨mpredicate (p.p 2,mm,b )
end
temporalpredicate ⇒
casep.oof
period _op⇒p.o(mperiod(p.per1,mm,b ) , mperiod(p.per2,mm,b ) )
duration _op⇒p.o(mduration (p.dur1,mm,b ) , mduration (p.dur2,mm,b ) )
end
end
aperiod for a given meta model dataset and a binding returns an instance of
per , i.e., a single period element:
mperiod:period ×metamodel ×binding →per68 e. g. l. de murillas et al.
the meaning function of period will return a period element that can be created
(periodcreation ) or assigned from a variable name containing a period ( periodvar ).
in the case of a periodcreation , a period can be created for the speciﬁed start and
end timestamps using the createperiod function or it can be computed as the global
period of another set of periods ( globalperiodof ).
mperiod[p:period ,mm:metamodel ,b:binding ]/defines
casepof
periodcreation ⇒
casep.oof
createperiod ⇒p.o(p.ts1,p.ts2)
globalperiodof ⇒p.omm(melementset (p.es,mm,b ) )
end
periodvar ⇒/braceleftbigg
b(p) ifp∈dom(b)
∅ otherwise
end
aduration is a value representing the length of a period, and it is computed
within the context of a meta model dataset and a binding:
mduration :duration ×metamodel ×binding →dur
aduration can be evaluated based on the duration of a period ( getduration )o r
a duration speciﬁed in scalar units ( durationof ).
mduration [d:duration ,mm:metamodel ,b:binding ]/defines
cased.oof
durationof ⇒d.o(d.v)
getduration ⇒d.o(mperiod(d.p, mm,b ) )
end
finally, an attribute is a value assigned to an element in the context of a meta
model:
mattribute :attribute ×element ×metamodel →value
in order to evaluate the value of an attribute , we can refer to the attributename ,
in which case the value will be obtained in different ways depending on the typedata-aware process oriented query language 69
of element (event, object version, case, or log). also, an attribute can be explicitly
deﬁned by its value .
mattribute [at:attribute ,e:element ,mm:metamodel ]/defines
caseatof
attributename ⇒
caseeof
event ⇒ifeventhasattribute (at,e ) then:getattributeevent (at,e ) else:∅
version ⇒ifversionhasattribute (at,e ) then:getattributeversion (at,e )
else:∅
case⇒ifcasehasattribute (at,e ) then:getattributecase (at,e ) else:∅
log⇒ifloghasattribute (at,e ) then:getattributelog (at,e ) else:∅
end
value ⇒at
end
this concludes the formal deﬁnition of dapoq-lang in terms of syntax and
semantics at an abstract level. the coming sections provide some details about the
concrete syntax, implementation, and its performance.
4 implementation and evaluation
dapoq-lang6has been implemented as a domain speciﬁc language (dsl) on
top of groovy7, a dynamic language for the java platform. this means that, on top
of all the functions and operators provided by dapoq-lang, any syntax allowed by
groovy or java can be used within dapoq-lang queries . dapoq-lang heavily
relies on a java implementation of the openslex8meta model using sqlite9as
a storage and querying engine. however, dapoq-lang abstracts from the speciﬁc
storage choice, which allows it to run on any sql database and not just sqlite.
the platform padas10(process aware data suite) integrates dapoq-lang and
6https://github.com /edugonza/dapoq-lang/ .
7http://groovy-lang.org/ .
8https://github.com /edugonza/openslex/ .
9https://www.sqlite.org .
10https://github.c om/edugonza/padas/ .70 e. g. l. de murillas et al.
table 2 characteristics of the three datasets employed in the evaluation
dataset
 # objects
 # versions
 #e v e n t s
 # cases
 # logs
 # activities
a
 6740
 8424
 8512
 108,751
 34
 14
b
 7,339,985
 7,340,650
 26,106
 82,113
 10,622
 172
c
 162,287
 277,094
 277,094
 569,026
 29
 62
openslex in a user-friendly environment to process the data and run queries. the
current implementation relies on the sqlite library to store the data and execute
certain subqueries. therefore, it is to be expected that dapoq-lang introduces
certain overhead, given that data retrieval and object creation on the client side
consume extra time and memory compared to an equivalent sql query. in order
to assess the impact of dapoq-lang on query performance, we run a benchmark
of pairs of equivalent queries, as expressed in dapoq-lang and sql, on the
same database. the queries are organized in 3 categories and run on the 3 datasets
described in [ 4]: a (event data obtained from the redo logs of a simulated ticket
selling platform), b (event records from a ﬁnancial organization), and c (erp event
data from a sample sap system) (table 2).
the dapoq-lang queries of each pair were run with two different conﬁgura-
tions: memory-based and disk-based caching. memory-based caching uses the heap
to store all the elements retrieved from the database during the execution of the
query. this is good for speed when dealing with small or medium size datasets but
represents a big limitation to deal with big datasets given the impact on memory
use and garbage collection overhead. disk-based caching makes use of mapdb,11
a disk-based implementation of java hash maps, to serialize and store on disk all
the elements retrieved from the database. this signiﬁcantly reduces the memory
consumption and allows handling much larger datasets, which comes at the cost
of speed given the overhead introduced by serialization and disk i/o operations.
figure 4shows the results of the benchmark, with one plot per query type, one box
per query engine (sql, dapoq-lang, an d dapoq-lang with disk caching), for
the three datasets. as expected, we obser ve that the performance of dapoq-lang
queries is, in general, poorer than that of the equivalent sql queries, especially
when it comes to queries regarding the order of activities. this is due to the overhead
on transmission and processing of data and the fact that many ﬁltering operations
are performed on the client instead of the server side. obviously, there is a trade-
off between ease of use and performance. nevertheless, performance was never
the main motivation for the development of dapoq-lang, but ease of use and
speed of query writing. in future versions, further efforts will be made to improve
performance and to provide more comprehensive benchmarks.
11http://www.mapdb.org .data-aware process oriented query language 71
attribute & periods filters activity ordering elementsof
abc abc abc1 sec10 sec100 sec
datasetexecution time (seconds)
engines: dapoq−lang (memory based caching) dapoq−lang (disk based caching) sql
fig. 4 benchmark of queries run with dapoq-lang, dapoq-lang with disk-based caching,
and sql on an sqlite backend. note that the vertical axis is logarithmic
5 application and use cases
the purpose of this section is to demonstrate the applicability of our approach and
tools. first, we explore the professional proﬁles, in the context of process mining,to which this language is directed to, and we identify the most common data aspectsto query given each proﬁle. then, we provide some use cases of dapoq-lang withexamples of relevant queries for each data aspect. finally, we compare dapoq-lang to sql by means of an example. the example highlights the expressivenessand compactness of our query language.
5.1 business questions in process mining
process mining is a broad ﬁeld, with many techniques available tailored toward avariety of analysis questions. “process miners” (analysts or users carrying out aprocess mining project) are often inter ested in discovering process models from
event data. sometimes these models are p rovided beforehand and the focus is on
conformance between the models and events. it can be the case that assessing theperformance of speciﬁc activities is critical. also, ﬁnding bottlenecks in the processcan be of interest for the analysts. in some contexts, where existing regulations andguidelines impose restrictions on what is allowed and what is not in the executionof a process, compliance checking becomes a priority. in the literature, we can ﬁndexamples of frequently posed questions for speciﬁc domains, like healthcare [ 7], in
which root cause analysis becomes relevan t in order to trace back data related to a
problematic case. all these perspectives pose different challenges to process miners,who need to “dig” into the data to ﬁnd answers to relevant questions.
previous works [ 6,9] identiﬁed professional roles and proﬁles in the area of
business process management by analy zing job advertisem ents and creating a72 e. g. l. de murillas et al.
classiﬁcation based on the competencies. we make use of this classiﬁcation to point
out the corresponding data aspects relevant for each proﬁle. table 3presents, in the
two leftmost columns, the classiﬁcation of the roles, as proposed by the authors ofstudies [ 6,9]. in the column main focus , we propose, based on the role description,
the sub-disciplines of process mining and data engineering that become relevantfor each job proﬁle (i.e., discovery, comp liance checking, conformance checking,
performance analysis, root cause analysis, i ntegration, and data integrity). the rest
of the columns indicate whether certain event data aspects become particularly
interesting to be queried for each professiona l role, considering the role description
and the main focus. we have grouped these event data aspects into two big categoriesthat reﬂect the expected output of the queries: (a) specialized sublogs are event
logs that contain only event data that reﬂects certain desired properties (e.g.,temporal constraints, activity occurrence constraints), and (b) metrics, artifacts,
and provenance are the resulting values of the computation of certain event data
properties (e.g., performance metrics).
we see that there is a clear distinction b etween roles interested in performance
and root cause analysis, in contrast to those mainly interested in compliance.the former will need to obtain performance metrics from the data, e.g., average
case duration, or most time-consuming tasks. also, they are interested in ﬁndingdata related to problematic cases, e.g., obtaining all the products purchased in anunpaid order ( dependency relations ), or ﬁnding out providers of a defective batch of
products ( data lineage ). however, those with a focus on compliance typically need
to answer questions related to temporal constraints (e.g., if cases of a particular type
of client are resolved within the agreed slas), activity occurrence constraints (e.g.,
whether a purchase was always paid), and order of actions (e.g., if an invoice is
created before a delivery is dispatched).
as the roles get more concerned with the technical aspects of it systems, more
focus is put on performance and data proper ties. especially, for technical architects,
data integrity is crucial, since they are the ones in charge of integrating bothapplications and data storage systems. being able to ﬁlter information based on data
properties and ﬁnd irregular data changes is important to verify a correct integration
of different infrastructures.
now that we have identiﬁed data aspects o f interest, in what follows we present
a set of example dapoq-lang queries. the aim of these examples is twofold: toserve as a template to write queries and to demonstrate that the features of dapoq-lang indeed cover all the aspects described in table 3.
5.2 exporting logs
one of the main purposes when querying process execution data is to export it as a
compatible event log format. dapoq-la ng provides u tilities to export l ogs, cases,
and events as xes event logs, which can be further analyzed using process miningdata-aware process oriented query language 73table 3 types of bpm professionals, according to [ 9], and relation to querying in process mining
specialized sublogs
 metrics, artifacts, and provenance
temporal
 activity
 order of
 data
 data
 data
 dependency
 performance
role [ 9]
 description [ 9]
 main focus
 constraints
 occurrence
 actions
 properties
 changes
 lineage
 relations
 metrics
business
process
analyst
elicits, analyzes, documents, and
communicates user requirements and
designs according to business
processes and it systems; acts as a
liaison between business and it
discovery,
compliance,
and confor-
mance
/check
 /check
 /check
 /check
 /check
business
process
compliance
manager
analyses regulatory requirements and
ensures compliance of business
processes and it systems
compliance
and confor-
mance
/check
 /check
 /check
 /check
 /check
business
process
manager, sales
and marketing
designs sales processes and analyses
requirements for related it systems;
supports and executes sales and
marketing processes
compliance
 /check
 /check
 /check
 /check
 /check
business
process
improvement
manager
analyses, measures, and continuously
improves business process, e.g.,
through application of lean or six
sigma management techniques
performance,
confor-
mance and
root cause
analysis
/check
 /check
 /check
 /check
 /check
/check
/check
 /check
erp solution
architect
implements business processes in erp
systems
performance,
confor-
mance and
root cause
analysis
/check
 /check
 /check
 /check
 /check
/check
/check
 /check
it-business
strategy
manager
aligns business and it strategies;
monitors technological innovations
and identiﬁes business opportunities
performance
and confor-
mance
/check
 /check
 /check
 /check
 /check
 /check
technical
architect
develops and integrates hardware and
software infrastructures
integration
and data
integrity
/check
 /check
/check
/check
 /check
74 e. g. l. de murillas et al.
platforms such as prom12or rapidprom.13the following queries show the way to
export xes logs for different types of data. these functions can be applied to all
the query types deﬁned under the specialized sublogs category (table 3)i no r d e r
to extract the corresponding xes event log. when a set of logs is retrieved, an
independent xes log is generated for each of them.
query 2 export all the logs with a speciﬁc name. the result can be one or many logs being
exported according to the xes format.
1 exportxlogsof (alllogs () .where {n a m e =="log01" })
when the input of exportxlogsof is a set of cases, one single xes log is
exported.
query 3 export in a single xes log all the cases of different logs.
1 exportxlogsof (casesof (alllogs () .where {n a m e . contains ("1" )} ) )
in the case of a set of events, a single xes log with a single trace is exported
(query 4).
query 4 export in a single xes log all the events of different logs.
1 exportxlogsof (eventsof (alllogs () .where {n a m e . contains ("1" )} ) )
a special situation is when we want to export a set of logs or cases while ﬁltering
out events that do not comply with some criteria. in that case, we call exportxlogsof
with a second argument representing the set of events that can be exported (query 5).
any event belonging to the log to be exported not contained in this set of events will
be excluded from the ﬁnal xes log.
query 5 export one or many xes logs excluding all the events that do not belong to a speciﬁc
subset.
1 exportxlogsof (alllogs () , eventsof (allclasses () .where {n a m e =="booking" }) )
5.3 specialized sublogs
so far, we have seen how to export logs as they are stored in the dataset under
analysis. however, it is very common to focus on speciﬁc aspects of the data
depending on the questions to answer. this means that we need to create specialized
sublogs according to certain criteria. this section presents examples of queries to
12http://www.promtools.org .
13http://www.rapidprom.org/ .data-aware process oriented query language 75
create specialized sublogs that comply with certain constraints in terms of temporal
properties ,activity occurrence ,order of action ,data properties ,o rdata changes .
temporal constraints a way to create specialized sublogs is to ﬁlter event data
based on temporal constraints. the creation and computation of periods makes it
possible to select only data relevan t during a certain time span. query 6returns
events that happened during period pand that belong to the log “log01”.
query 6 temporal constraints. retrieve all the events of “log01” that happened during a certain
period of time.
1 def evlog01 =eventsof (alllogs () .where {n a m e =="log01" })
2 def p=createperiod ("2014/11/27
 15:57" ,"2014/11/27
 16:00" ,"yyyy/mm/dd
 hh:mm
/arrowhookleft→")
3
4 eventsof (p) . intersection (evlog01)
query 7focuses on the duration of cases ra ther than on the speciﬁc time when
they happened. only cases of log “log01” with a duration longer than 11 minutes
will be returned.
query 7 temporal constraints. retrieve cases of “log01” with a duration longer than 11 minutes.
the variable “it” is used to iterate over all values of “c” within the “where” closure
1 def c=casesof (alllogs () .where {n a m e =="log01" })
2
3c . where {globalperiodof (it).getduration ()>d u r a t i o n .ofminutes (11) }
activity occurrence another way to select data is based on activity occurrence.
the following query shows an example of how to retrieve cases in which two
speciﬁc activities were performed regardless of the order. first, cases that include
the ﬁrst activity are retrieved ( casesa ). then, cases that include the second activity
are retrieved ( casesb ). finally, the intersection of both sets of cases is returned.
query 8 activity occurrence. retrieve cases where activities that contain the words “insert”
or “update” and “customer” happened in the same case.
1 def acta =allactivities () .where {
2n a m e . contains ("insert" )&& name . contains ("customer" )}
3
4 def actb =allactivities () .where {
5n a m e . contains ("update" )&& name . contains ("customer" )}
6
7 def casesa =casesof ( acta )
8 def casesb =casesof ( actb)
9
10 casesa . intersection ( casesb)
order of actions this time we are interested in cases in which the relevant
activities happened in a speciﬁc order. the following query, an extended version
of query 8, selects the cases that include both activities. yet, before storing the
intersection of cases containing events of the activities in the set acta with cases76 e. g. l. de murillas et al.
containing events of the activities in the set actb in a variable (line 13), the query
performs a ﬁlter based on the order of these two activities. to do so, for each case,
the set of events is retrieved (line 15). next, the events of the ﬁrst and second
activities are selected (lines 16 and 17). finally, the periods of both events are
compared (line 18), evaluating the condition to the value true for each case in which
all the events of activity ahappened before the events of activity b. only the cases
for which the condition block (lines 14 to 18) evaluated to true are stored in the
variable casesab and returned.
query 9 order of actions. retrieve cases where activities that contain the words “insert” and
“customer” happen before activities that contain the words “update” and “customer”.
1 def acta =allactivities () .where {
2n a m e . contains ("insert" )&& name . contains ("customer" )}
3
4 def actb =allactivities () .where {
5n a m e . contains ("update" )&& name . contains ("customer" )}
6
7 def casesa =casesof ( acta )
8 def casesb =casesof ( actb)
9
10 def eventsa =eventsof ( acta )
11 def eventsb =eventsof (actb)
12
13 def casesab =casesa . intersection (casesb)
14 . where {
15 def ev=eventsof (it)
16 def eva =ev . intersection ( eventsa)
17 def evb =ev . intersection ( eventsb )
18 before (globalperiodof (e v a) , globalperiodof (e v b))
19 }
data properties some elements in our openslex da taset contain attributes that
can be queried. these elements are object versions, events, cases, and logs. the
following query shows how to ﬁlter events based on their attributes. first, the query
compares the value of the attribute resource to a constant. also, it checks if the
attribute address contains a certain substring. finally, it veriﬁes that the event
contains the attribute concert_date . only events that satisfy the ﬁrst and either
the second or the third will be returned as a result of the query.
query 10 data properties. retrieve events of resource “sample” that either have an attribute
address which value contains “35” or have a concert_date attribute.
1 allevents () .where {
2 resource =="sampledb" && (at. addre . contains ("35") ||h a s ( a t . concert_date ) ) }
data changes an important feature of our query language is the function named
changed . this function determines if the value of an attribute for a certain object
version changed. the function has the attribute name as a required parameter ( at:)
and two optional parameters ( from: ,a n d to:). query 11returns all the events related
to object versions for which the value of the attribute “booking_id” changed.
no restrictions are set on the speciﬁc values. therefore, the call to changed will bedata-aware process oriented query language 77
evaluated to true for an object version only if the value of the attribute in preceding
version was different from the value in the current one.
query 11 data changes. retrieve events that affected versions where the value of “book-
ing_id” changed.
1 eventsof (allversions () .where {changed ([at:"booking_id" ]) })
query 12shows a similar example. this time we want to obtain the events related
to object versions for which the attribute “scheduled_date” changed from
“11-jun-82” to a different one.
query 12 data changes. retrieve events that affected versions where the value of “sched-
uled_date” changed from “11-jun-82” to a different value.
1 eventsof (allversions () .where {changed ([at:"scheduled_date" ,from :"11-jun
/arrowhookleft→-82" ]) })
query 13instead retrieves the events related to object versions for which the
attribute “scheduled_date” changed to “22-may-73” from a different one.
query 13 data changes. retrieve events that affected versions where the value of “sched-
uled_date” changed to “22-may-73” from a different value.
1 eventsof (allversions () .where {changed ([at:"scheduled_date" ,to:"22-may-73"
/arrowhookleft→ ]) })
finally, query 14imposes a stricter restriction, retrieving only the events related
to object versions for which the attribute “scheduled_date” changed from
“24-mar-98” to “22-may-73”.
query 14 data changes. retrieve events that affected versions where the value of “sched-
uled_date” changed from “24-mar-98” to “22-may-73”.
1 eventsof (allversions () .where {
2 changed ([at:"scheduled_date" ,from :"24-mar-98" ,to:"22-may-73" ]) })
5.4 metrics, artifacts, and provenance
in the previous section, we have seen examples of how to obtain specialized sublogs
given certain criteria. however, we do not always want to obtain events, cases, or
logs as the result of our queries. in certain situations, the interest is in data objects,
and their relations to other elements of the dataset, e.g., objects of a certain type,
artifacts that coexisted during a given period, or data linked to other elements. also,
one can be interested in obtaining performan ce metrics based on existing execution
data. all these elements cannot be exported as an event log, since they do not always
represent event data. however, they can be linked to related events or traces. this78 e. g. l. de murillas et al.
section shows example queries that exploit these relations and provide results that
cannot be obtained as plain event logs.
data lineage data lineage focuses on the lifecycle of data, its origins, and where it
is used over time. dapoq-lang supports data lineage mainly with the elementsof
functions listed in sect. 3.1.2 . these functions return elements of a certain type
linked or related to input elements of another type. as an example, we may have
an interest in obtaining all the products in the database affected by a catalog update
process during a certain period in which prices were wrongly set. the following
query ﬁnds the cases in log “log01” whose life span overlaps with a certain period
and returns the object versions related to them.
query 15 data lineage. retrieves versions of objects affected by any case in “log01” whose life
span overlapped with a certain period of time. the date format is speciﬁed.
1 def p1=createperiod ("2014/11/27
 15:56" ,"2014/11/27
 16:30" ,"yyyy/mm/dd
 hh:mm
/arrowhookleft→")
2
3 versionsof (
4 casesof (alllogs () .where {name =="log01" })
5. where {
6 overlaps (globalperiodof (it), p 1 )
7}
8)
dependency relations an important feature of the language is the ability to query
existing relations between elements of different types, as well as within object
versions of different classes. query 15showed an example of relations between
elements of different types (logs to cases , cases to versions). the following query
shows an example of a query on object versions related to other object versions.
first, two different classes of data objects are obtained (lines 1 and 2). then, the
versions of the class “ticket” are retrieved (line 3). finally, the object versions
related to object versions belonging to class “booking” are obtained (lines 5 and
6), and only the ones belonging to class “ticket” are selected (line 7).
query 16 dependency relations. retrieve versions of ticket objects that are related to versions of
booking objects.
1 def ticketclass =allclasses () .where {n a m e =="ticket" }
2 def bookingclass =allclasses () .where {n a m e =="booking" }
3 def ticketversions =versionsof ( ticketclass )
4
5 versionsrelatedto (
6 versionsof ( bookingclass)
7) . intersection ( ticketversions )
performance metrics as has been previously discussed, measuring performance
and obtaining metrics for speciﬁc cases or activities are very common and relevant
questions for many professional roles. dapoq-lang supports this aspect by
computing periods and durations to measure performance. the resulting periods
can be used to compute performance sta tistics such as average execution time ordata-aware process oriented query language 79
maximum waiting time. the following query shows how to compute periods for a
subset of the events in the dataset.
query 17 performance metrics. retrieve periods of events belonging to activities that contain the
words “update” and “concert” in their name.
1 def actupdateconcert =allactivities () .where {
2n a m e . contains ("update" )&& name . contains ("concert" )
3}
4
5 periodsof (eventsof ( actupdateconcert ) )
query 18demonstrates how to ﬁlter out periods based on their duration. cases
with events executed by a certain resour ce are selected and their periods are
computed. next, only periods with a duration longer than 11 min are returned.
query 18 performance metrics. retrieve periods of a duration longer than 11 minutes computed
on cases which had at least one event executed by the resource “sampledb”.
1 def c=casesof (allevents () .where { resource =="sampledb" })
2
3 periodsof (c). where {it.getduration ()>d u r a t i o n .ofminutes (11) }
5.5 dapoq-lang vs. sql
so far, we have seen several examples of “toy” queries to demonstrate the use of
the functions and operators provided by dapoq-lang. obviously, any dapoq-
lang query can be computed with other turing-complete languages. when it comes
to data querying on databases, sql is the undisputed reference. it is the common
language to interact with most of the relational database implementations available
today. it is a widespread language, known by many professionals from different
ﬁelds. even without considering scripting languages like pl/sql and just with
ctes (common table expressions) and windowing, sql has been proven to be
turing-complete [ 2]. therefore, the aim of dapoq-lang is not to enable new types
of computations, but to ease the task of writing queries in the speciﬁc domain of
process mining.
let us consider again the generic question (gq) presented in sect. 1:
gq: in which cases, there was (a) an event that happened between time t1 and t2, (b) that
performed a modiﬁcation in a version of class c, (c) in which the value of ﬁeld f changed
from x to y?
this question involves several types of elements: cases, events, object ver-
sions, and attributes. we instantiate this query with some speciﬁc values for
t1 = “1986/09/17 00:00”, t2 = “2016/11/30 19:44”, c = “customer”, f =
“address”, x = “fifth avenue”, and y = “sunset boulevard”. assuming that
our database already complies with the structure proposed by the openslex meta
model, we can write the following sql query to answer the question:80 e. g. l. de murillas et al.
query 19 standard sql query executed on the openslex dataset in [ 4] and equivalent to the
dapoq-lang query 1
1 select d i s t i n c t c. id as"id" ,c a t . n a m e ,c a t v . value , c a t v. type
2from
3 "case" as c
4 join activity_instance_to_case as aitc on a i t c. case_id = c. id
5 join activity_instance as aion a i.id = a i t c. activity_instance_id
6 join event as eon e. activity_instance_id = a i. id
7 join event_to_object_version as etov on e t o v. event_id = e. id
8 join object_version as ovon e t o v. object_version_id = o v. id
9 join object as oon o v. object_id = o. id
10 join class as clon o. class_id = c l. id and cl . name = "customer"
11 join attribute_name as at on at .n a m e = "address"
12 join attribute_value as avon a v. attribute_name_id = at.i d and
1 3 a v. object_version_id = o v. id
14 left join case_attribute_value as catv on c a t v. case_id = c. id
15 left join case_attribute_name as cat on c a t. id = c a t v. case_attribute_name_id
16 where
17 e . timestamp >"527292000000" and
18 e . timestamp <"1480531444303" and
19 av. value l i k e "sunset
 boulevard" and
20 exists
21 (
22 select ovp . i d
23 from
2 4 object_version as ovp ,
2 5 attribute_value as avp
26 where
2 7 a v p. attribute_name_id = at.i d and
2 8 a v p. object_version_id = o v p. id and
2 9 o v p. object_id = o v. object_id and
30 avp . value l i k e "fifth
 avenue" and
31 ovp . i d in
32 (
33 select ovpp . i d
34 from object_version as ovpp
35 where
3 6 o v p p. end_timestamp < = o v. start_timestamp and
3 7 o v p p. end_timestamp >= 0 and
3 8 o v p p. object_id = o v. object_id and
39 ovpp . i d ! = ov . i d
40 order by o v p p. end_timestamp desc limit 1
41 )
42 )
the logic is the following. two subqueries are nested in order to retrieve (a)
object versions preceding another object version (lines 33–40) and object versions
that contain the attribute that changed (lines 22–41). parts of the query focus on
checking the value of the attributes (lines 27–30), the timestamp of the events (lines
17–18), and the class of the object versions (line 10). the rest of the query is
concerned with joining rows of different tables by means of foreign keys.
the equivalent dapoq-lang query, previously presented in query 1, removes
most of the clutter and boilerplate code in order to join tables together and lets
the user focus on the deﬁnition of the constraints. the query is built up with an
assignment and several nested queries. first, a period of time is deﬁned (line 1).
then, object versions of a certain class are retrieved (lines 5–6) and ﬁltered based
on the changes of one of the attributes (line 7). next, the events related to such
object versions are obtained (lines 4–8) and ﬁltered based on the time when they
occurred (lines 8–12). finally, the cases of these events are returned (lines 3–13).data-aware process oriented query language 81
table 4 event log obtained from the execution of query 1
#
 case
 activity name
 timestamp
 class
 address
1
 1
 insert customer
 2014-11-27 15:57:13
 customer
 fifth avenue
2
 1
 update customer
 2014-11-27 16:05:01
 customer
 sunset boulevard
3
 2
 insert customer
 2014-11-27 15:58:14
 customer
 fifth avenue
4
 2
 update customer
 2014-11-27 16:05:37
 customer
 sunset boulevard
5
 3
 insert customer
 2014-11-27 15:59:16
 customer
 fifth avenue
6
 3
 update customer
 2014-11-27 16:05:54
 customer
 sunset boulevard
7
 4
 insert customer
 2014-11-27 16:01:03
 customer
 fifth avenue
8
 4
 update customer
 2014-11-27 16:07:02
 customer
 sunset boulevard
table 4shows the event log obtained from the execution of this query, where we can
observe that insertions of new customers are followed by updates that modify the
address attribute.
in essence, the advantage of dapoq-lang over sql is on the ease of use in the
domain of process mining. the fact that we can assume how logs, cases, events, and
objects are linked allows us to focus on the important parts of the query. also, pro-
viding functions that implement the most frequent operations on data (such as period
and duration computation) makes writing queries faster and less prone to errors.
6 dapoq-lang and the process querying framework
the process querying framework (pqf) provides a comprehensive overview
of the aspects involved in the process querying cycle. this framework partly
originates from a collection of functiona l and non-functional requirements for
process querying in the process management ﬁeld. the requirements, based on
crud operations (create, read, update, and delete), focus on the relevant bpm
use cases presented in [ 11]. as has been shown in sect. 5, our query language fulﬁlls
or supports, to some extent, the tasks involved in the requirements regarding “check
conformance using event data” and “analyze performance using event data.” in this
section, we instantiate dapoq-lang in the pqf.
the ﬁrst part of pqf is named “ model, simulate, record, and correlate .”
dapoq-lang does not aim to support any of the aspects covered by this part of
the framework. however, the openslex meta model, and more speciﬁcally its
implementation, enables the recording andcorrelation of behavioral and historical
data in a structured way, i.e., create and update operations. this feature enables the
construction of a dataset ready to be queried (i.e., read operations) by dapoq-
lang’s query engine. therefo re, dapoq-lang addresses event log andcorrelated
data querying with the intent of retrieving information previously recorded in an
openslex-compliant storage.82 e. g. l. de murillas et al.
with respect to the “ prepare ” part of the pqf, dapoq-lang’s support is
twofold: (1) it proposes the openslex meta model to structure behavioral andobject data in a format that enables indexing and makes the querying process
easier to carry out from the usability point of view. also, it speeds up queryexecution providing the most frequently requested information in a preprocessedformat. (2) the underlying openslex implementation makes use of caching to
speed up response time and make efﬁcient use of memory. two strategies aresupported: (a) in-memory caching, which b eneﬁts speed but suffers when dealing
with large datasets, and (b) disk-based caching, which makes it possible to handle
larger datasets that would not ﬁt in memory but introduces an overhead due to theserialization and disk-writing steps.
as dapoq-lang is a query language with an existing implementation, it covers
the “ execute ” part of the pqf. the nested nature of the expressions in dapoq-
lang enables the ﬁltering of the data, executing parts of the query only on the
relevant elements. the implementation includes several optimizations , like pre-
fetching of attributes as a way to save time in the ﬁltering step of the queryexecution. the execution of a query in dapoq-lang yields results in the formof a set of elements, obtained from the original dataset, representing the subset ofthe original data that satisﬁes the expressed constraints.
finally, the “ interpret ” part of the framework is supported by dapoq-lang
in two ways: (1) enabling the inspection of data using explorative queries and
(2) exporting the result of queries to xlog, which makes it possible to applyany existing process mining technique that requires an event log as input, whilebeneﬁting from the capabilities of dapoq-lang to build relevant sublogs for thequery at hand.
7 conclusion
in the ﬁeld of process mining, the need for better querying mechanisms has
been identiﬁed. this work proposes a method to combine both process and dataperspectives in the scope of process querying, helping with the task of obtaininginsights about processes. to do so, dapoq-lang, a data-aware process orientedquery language, has been developed, which allows the analyst to select relevantparts of the data in a simple way to, among other things, generate specializedevent logs to answer meaningful business questions. we have formally describedthe syntax and semantics of the language. we presented its application by meansof simple use cases and query examples in order to show its usefulness andsimplicity. in addition, we provide an efﬁcient implementation that enables not onlythe execution but also the fast developmen t of queries. this work shows that it is
feasible to develop a query language that satisﬁes the needs of process analysts,while balancing these with demands for simplicity and ease of use. finally, wepositioned dapoq-lang within the process querying framework [ 10]. dapoq-
lang presents certain limitations in terms o f performance, expressiveness, and easedata-aware process oriented query language 83
of use. as future work, efforts will be made on (a) expanding the language with new
functionalities and constructs relevant in the process mining context, (b) improvingthe query planning and execution steps in order to achieve better performance, and(c) carrying out empirical evaluations w ith users in order to objectively assess the
suitability of the language with in the process mining domain.
references
1. allen, j.f.: maintaining knowledge about temporal intervals. commun. acm 26(11), 832–843
(1983). https://doi.org/10.1145/182.358434
2. gierth, a., fetter, d.: cyclic tag system. in: postgresql wiki (2011). https://www.webcitation.
org/6db5tyvpi
3. gonzález lópez de murillas, e., reijers, h.a., van der aalst, w.m.p .: everything you always
wanted to know about your process, but did not know how to ask. in: dumas, m., fantinato,m. (eds.) business process management workshops, pp. 296–309. springer internationalpublishing, cham (2017)
4. gonzález lópez de murillas, e., reijers, h.a., van der aalst, w.m.p .: connecting databases
with process mining: a meta model and toolset. softw. syst. model. (2018). https://doi.org/10.
1007/s10270-018-0664-7
5. ieee standard for extensible event stream (xes) for achieving interoperability in event
logs and event streams (2016). https://doi.org/10.1109/ieeestd.2016.7740858
6. lederer antonucci, y ., goeke, r.j.: identiﬁ cation of appropriate re sponsib ilities and positions
for business process management success: seeking a valid and reliable framework. bus.process manag. j. 17(1), 127–146 (2011)
7. mans, r.s., van der aalst, w.m., v anwersch, r.j., moleman, a.j.: process mining in
healthcare: data challenges when answering frequently posed questions. in: process supportand knowledge representation in health care, pp. 140–153. springer (2013)
8. meyer, b.: introduction to the theory of programming languages. prentice-hall, upper
saddle river, nj, usa (1990)
9. müller, o., schmiedel, t., gorbacheva, e., vom brocke, j.: towards a typology of business pro-
cess management professionals: identifying patterns of competences through latent semanticanalysis. enterprise is 10(1), 50–80 (2016). https://doi.org/10.1080/17517575.2014.923514
10. polyvyanyy, a., ouyang, c., barros, a., van der aalst, w.m.: process querying: enabling
business intelligence thr ough query-based process ana lytics. decis. support syst. 100, 41–
56 (2017). https://doi.org/10.1016/j.dss.2017.04.011 .http://www.sciencedirect.com/science/
article /pii/s 0167923617300787 . smart business process management
11. van der aalst, w.m.: business process management: a comprehensive survey. isrn softw.
eng. 2013 (2013)
12. watson, h.j., wixom, b.h.: the current state of business intelligence. computer 40(9), 96–99
(2007). https://doi.org/10.1109/mc.2007.331