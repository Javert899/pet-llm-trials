declarative speciﬁcation and veriﬁcation of service
choreographies
marco montali, maja pesic, wil m. p. van der aalst, federico chesani,
paola mello and sergio storari
service oriented computing, an emerging paradigm for architecting and implementing business col-
laborations within and across organizational boundaries, is currently of interest to both software
vendors and scientists. while the technologies for implementing and interconnecting basic ser-
vices are reaching a good level of maturity, modeling service interaction from a global viewpoint,
i.e., representing service choreographies, is still an open challenge. the main problem is that,
although declarativeness has been identiﬁed as a key feature, several proposed approaches specify
choreographies by focusing on procedural aspects, leading to over-constrained and over-speciﬁed
models.
to overcome these limits, we propose to adopt decserflow, a truly declarative language, to
model choreographies. thanks to its declarative nature, decserflow semantics can be given in
terms of logic-based languages. in particular, we present how decserflow can be mapped onto
linear temporal logic and onto abductive logic programming . we show how the mappings onto
both formalisms can be concretely exploited to address the enactment of decserflow models, to
enrich its expressiveness and to perform a variety of diﬀerent veriﬁcation tasks. we illustrate the
advantages of using a declarative language in conjunction with logic-based semantics by applying
our approach to a running example.
categories and subject descriptors: d.1.7 [ programming techniques ]: visual programming;
h.3.5 [ information storage and retrieval ]: online information services— web-based services ;
i.2.4 [ artiﬁcial intelligence ]: knowledge representation formalisms and methods - tempo-
ral logic, rule-based representations; i.2.3 [ artiﬁcial intelligence ]: deduction and theorem
proving— logic programming, inference engines
general terms: languages, management, veriﬁcation
additional key words and phrases: service choreographies, declarative approaches, linear tem-
poral logic, abductive logic programming, conformance checking, interoperability, reasoning
authors’ present address:
wil m. p. van der aalst - department of mathematics and computer science, p.o. box 513,
nl-5600 mb, eindhoven, the netherlands, e-mail: w.m.p.v.d.aalst@tue.nl.
federico chesani, marco montali and paola mello - deis, university of bologna, v.le
risorgimento 2, 40136 bologna (bo), italy, e-mail: {marco.montali, federico.chesani,
paola.mello }@unibo.it.
maja pesic - department of technology management, eindhoven university of technology, p.o.
box 513, nl-5600 mb, eindhoven, the netherlands, e-mail: m.pesic@tm.tue.nl.
sergio storari - dept. of engineering, university of ferrara, via saragat 1, 44100 ferrara (fe),
italy, email: strsrg@unife.it.
permission to make digital/hard copy of all or part of this material without fee for personal
or classroom use provided that the copies are not made or distributed for proﬁt or commercial
advantage, the acm copyright/server notice, the title of the publication, and its date appear, and
notice is given that copying is by permission of the acm, inc. to copy otherwise, to republish,
to post on servers, or to redistribute to lists requires prior speciﬁc permission and/or a fee.
c/circlecopyrt2009 acm 0000-0000/2009/0000-0001 $5.00
acm transactions on the web, vol. v, no. n, may 2009, pages 1–0 ??.2· montali, pesic, van der aalst, chesani, mello, storari
1. introduction
service oriented computing, an emerging paradigm for architecting and implement-
ing business collaborations within and across organizational boundaries, is currently
of interest to both software vendors and scientists [van der aalst et al. 2003]. in its
web implementation, the functionality provided by business applications is encapsu-
lated within web services: software compo nents described at a semantic level, which
can be invoked by application programs or by other services through a stack of inter-
net standards including http, xml, soap [box et al. 2000], wsdl [christensen
et al. 2001] and uddi [belwood et al. 2000]. once deployed, web services provided
by various organizations can be inter-connected in order to implement business col-
laborations, leading to composite web services where participating services interact
in a choreography.
let us for example consider a b2b setting, in which diﬀerent organizations share
their own services to mutually beneﬁt from each other, trying to reach complex
strategic goals, impossible to be pursued autonomously. in this context, it is often
impossible to make the assumption that one of the involved organizations will take
the lead during the interaction, acting as an orchestrator. as clearly pointed out
in the ws-cdl 1.0 speciﬁcation [kavantzas et al. 2004] “in real-world scenarios,
corporate entities are often unwilling to delegate control of their business processes
to their integration partners. choreography oﬀers a means by which the rules of
participation within a collaboration can be clearly deﬁned and agreed to, jointly.
each entity may then implement its portion of the choreography as determined by
the common or global view.”
in a b2b setting, the birth of a service choreography is often determined by
putting together external norms/regulations and internal policies, requirements,
best practises, business goals of each participating organization. all these diﬀerent
contributions have the eﬀect of constraining the possible allowed interactions, and
they will therefore be referred to as constraints throughout the paper. the obtained
global model should suitably mediate between compliance andﬂexibility : on the one
hand, all interacting services must respect the agreed constraints; on the other hand,
each party should be able to execute the business processes which cover its part of
the choreography as free as possible, preserving interoperability and replaceability
of services. in other words, we claim that a service choreography should play the
role of a public global contract which focuses on the rules of engagement required
to make all the interacting parties collaborate correctly, without stating how such
a collaboration is concretely carried out. this kind of knowledge is inherently
declarative .
as pointed out in [barros et al. 2005; van der aalst et al. 2005], while the tech-
nologies for implementing and interconnecting basic services are reaching a good
level of maturity, modeling service interaction from a global viewpoint, i.e., rep-
resenting service choreographies, is st ill an open challenge: the leading current
proposals for modeling service interaction, such as ws-bpel [andrews et al. 2003]
and ws-cdl [kavantzas et al. 2004], fail to tackle a suitable balance between
compliance and ﬂexibility. the main problem is that, although declarativeness has
been identiﬁed as a key feature, current mainstream approaches propose languages
and methodologies which model choreographies by focusing on procedural aspects,
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 3
e.g. by specifying control and message ﬂo w of the interacting services. this leads
to loose the declarative nature of the knowledge involved in the choreography deﬁ-
nition, forcing the modeler to capture it at a procedural level.
to overcome these limits, we propose a fr amework for dealing with service chore-
ographies at the declarative level. in particular, we adopt decserflow [van der
aalst and pesic 2006] as a truly declarative language for the graphical speciﬁcation
of service ﬂows, and present a mapping from the decserflow graphical constructs
to two underlying logic-based languages, enabling the possibility of reasoning upon
the developed models. decserflow adopts a more general and high-level view of
services speciﬁcation, by directly deﬁning them through a set of policies or business
rules referred to as constraints . hence, it does not give a complete and procedu-
ral speciﬁcation of what is allowed in ser vices, but concentrates on what is the
(minimal) set of constraints to be fulﬁlled in order to successfully accomplish the
interaction (i.e., what is forbidden and mandatory in services).
it is the declarative nature of decserflow which opens the possibility of providing
suitable underlying semantics in terms of logic-based languages. in particular, we
present how decserflow can be mapped ont o linear temporal logic (ltl) [clarke
et al. 1999] and onto the sciff framework [alberti et al. 2008]. the ltl mapping
of decserflow currently focuses only on t he process perspective of services (i.e.,
on activities executed in services), while sciff is able to consider activities, data
elements and time. we discuss how the m appings onto both formalisms can be
concretely exploited to address the enac tment of decserflow models, to enrich its
expressiveness and to perform a variety of diﬀerent veriﬁcation tasks, as shown in
table i.
ltl
 sciff
enactment
 x
conformance checking
 x
 x
interoperability
 x
 x
conﬂicts and dead activities detection
 x
 x
mining
 x
support of activities-data and quantitative time constraints
 x
table i. decserflow veriﬁcations and extensions-support through ltl and sciff.
ltl is a special type of logic that, in addition to classical logical operators,
uses several temporal operators. mappi ng to ltl enables decserflow to exploit
automata generated form ltl expressions [gerth et al. 1996; giannakopoulou and
havelund 2001] for execution of individual services and veriﬁcation of participating
services and whole compositions. the lt l representation of decserflow models
also enables a posteriori veriﬁcation of properties and checking of service interaction
(i.e. conformance checking) in the ltl checker [van der aalst et al. 2005] plug-in
of the process mining prom framework [van der aalst et al. 2007].
sciff is a framework based on abductive logic programming (alp) [kakas
et al. 1993], originally developed within the socs eu project1for the speciﬁcation
1societies of computees (socs): a computational logic model for the description, analysis and
veriﬁcation of global and open societies of heterogeneous computees. ist-2001-32530. home page:
acm transactions on the web, vol. v, no. n, may 2009.4· montali, pesic, van der aalst, chesani, mello, storari
and veriﬁcation of global interaction protocols in open multi-agent systems (mas),
which share many aspects with the service-oriented computing setting [baldoni
et al. 2005a]. similarly to the case of service choreographies and decserflow, the
need for modeling global interaction prot ocols by respecting the autonomy and het-
erogeneity of interacting agents has motivated the shift from mentalistic approaches
to declarative and social-based ones [singh 2000]. the sciff framework belongs to
the latter family: it envisages a powerful logic-based language for specifying social
interaction, and is equipped with a proof procedure capable to check at run-time
or a posteriori whether a set of interacting entities is behaving in a conformant
manner w.r.t. a given speciﬁcation. thanks to the mapping from decserflow to
sciff proposed in this work, we achieve two complementary advantages. on the
one hand, the mapping extends the applicability of sciff outside of the mas
setting, opening the possibility of exploiting its veriﬁcation capabilities in the soc
context and by non-expert users: they have not to deal directly with the com-
plexity of the sciff syntax, but can instead work at the intuitive graphical level
of decserflow, automatically obtaining the corresponding sciff speciﬁcation.
on the other hand, decserflow can beneﬁt o f the expressiveness and veriﬁcation
capabilities of sciff, addressing conformance checking and static veriﬁcation of
decserflow choreographies , enabling mining of decserflow models from service
execution traces, and enrich ing the language with data-related aspects and quanti-
tative time constraints. even if the main focus of a choreography is on the involved
activities and their ﬂow dependencies, adding data and quantitative time-related
aspects enables to model a wider range of situations, such as desired deadlines, con-
straints which span over multiple choreography instances, content-based decisions
points, interactions in which multiple concrete services play the same role (e.g.,
bidders in an auction). the possibility of addressing such kind of speciﬁcations
does not depend on decserflow (which can be extended for the purpose), but is
instead aﬀected by the underlying chosen formalization.
we illustrate the advantages of using a declarative language in conjunction with
logic-based semantics by applying our approach to a motivating choreography ex-
ample.
the remainder of this paper is organized as follows. section 2 motivates why
the challenging issue of modeling service choreographies should be faced by adopt-
ing a declarative approach. section 3 describes the decserflow language together
with its mapping onto ltl. the sciff language is pres ented in section 4, and
in section 5 the mapping of decserflow concepts onto sciff is shown. section 6
describes then how ltl and sciff can be used for enactment and various veri-
ﬁcation tasks of decserflow models. a discussion, focused on the usability of the
whole framework for what concerns features of the language as well as performances
and scalability of the veriﬁcation techniques and current available tools, follows in
section 7. related work is presented in s ection 8, while section 9 concludes the
paper sketching ongoing and future works. to make this article as concise as pos-
sible, the complete descrip tion of all the core decserflow constraints and of the
corresponding mapping onto ltl and sciff is described in appendix a.
http://lia.deis.unibo.it/research/socs/ .
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 5
2. motivation
to illustrate the diﬃculty of handling even simple choreography constraints with
classical procedural approaches, let us consider a fragment of a purchase choreogra-
phy, regulating the seller’s decision about the conﬁrmation or rejection of an order.
the seller could freely decide whether to conﬁrm or refuse customer’s order, but
must obey to the following constraints:
—if the warehouse cannot ship the order, then the seller must refuse it;
—the seller can accept the order only if the warehouse has prev iously accepted its
shipment;
—both the seller and the warehouse canno t accept and reject the same order, i.e.,
answers are mutually exclusive.
by considering these global rules, many diﬀerent compliant interactions can be
established by a concrete seller and a c oncrete warehouse . for example, when
and how the warehouse is contacted is not speciﬁed, and there could be diﬀerent
choreography executions in which the warehouse is not contacted at all: an execu-
tion in which the seller autonomously decides to reject the order, without asking
warehouse’s opinion, is foreseen by the choreography. this execution trace clearly
attests that many diﬀerent compliant ways to interact are not explicitly mentioned
in the choreography, but are instead implicitly supported. we argue that this is
due to the fact that choreography rules constitute a form of declarative knowledge,
which states what is forbidden and mandatory in services without giving details
about how to carry out the interaction.
when the user tries to model this kind of knowledge using a classical procedural
speciﬁcation language such as ws-bpel or wscdl, she is forced to explicitly enu-
merate all the implicitly supported executions, and to introduce further unnecessary
details. consider for example the bpmn [white 2006] collaborative diagrams as a
modeling language to capture the above described choreography fragment.
figure 1 compares the adoption of bpmn collaborative diagrams versus the use
of a declarative constraint-based language such as decserflow when modeling the
choreography fragment described above. while decserflow (figure 1(a)) is able
to capture the choreography in a compact and easily understandable way, bpmn
(figures 1(b) and 1(c)) experiences diﬃc ulties when trying to suitably mediate
between compliance and ﬂexibility: unnecessary activities are introduced (such as
the “contact warehouse” activity) and s ome acceptable execution traces are not
supported. for example, both the bpmn diagrams shown in figures 1(b) and 1(c)
do not support the possibility that the warehouse refuses the shipment after the
refusal of the seller; even if the refusal of the warehouse seems to be, in this case,
insigniﬁcant, it could be involved in other constraints of the choreography, and
should therefore be supported. adding this behaviour would require to complicate
the model, replicating execution paths and activities, and introducing ambiguous
decision points. and obviously, this issue would be even more hard to handle when
the modeled fragment has to be composed with other constraints to capture the
whole choreography.
these diﬃculties arise when the modeler tries to interconnect the choreography
activities by means of control and message ﬂows. in particular, a non-exhaustive
acm transactions on the web, vol. v, no. n, may 2009.6· montali, pesic, van der aalst, chesani, mello, storari
1) the seller can confirm the order only if the 
warehouse has previously confirmed the shipment
2) if the warehouse is unable to execute the shipment, 
then the seller should refuse (or have refused) the order4)
confirmation 
and refusal 
are mutually 
exclusive3) 
confirmation 
and refusal 
are mutually 
exclusive
(a)
sellerwarehouse
accept
orderrefuse 
ordercontact
warehouse
refuse 
shipmentconrm 
shipment...
(b)
sellerwarehouse
accept
ordercancel 
requestcontact
warehouse
refuse 
shipment
conrm 
shipmentcancel
requestrefuse 
order...
(c)
fig. 1. declarative vs. procedural style of modeling a simple choreography.
list of issues for which procedural languages do not provide a suitable support are:
how to deal with negative information su ch as “the seller cannot accept and reject
the same order”? how to deal with non-ordered constraints, such as the one stating
that “if the warehouse refuses the order , then the seller must also refuse (or have
refused) it”? who is in charge to contact the warehouse? and when?
the diﬃculy of providing an answer to these question by adopting a procedural
style of modeling is threefold:
—lack of proper abstractions . activities can be inter-connected only by means of
positive temporally-ordered relationships (sequence patterns, mixed with con-
structs aimed at splitting/merging the control or the message ﬂow). modeling
other kind of constraints forces the user to complicate the model. for example,
capturing temporally-unord ered relationships leads ei ther to choose one ordering
and impose it in the model, compromising ﬂexibility, or to explicitly capture all
the possible orderings, introducing ambiguous decision points to combine them.
—closed nature . procedural models makes the implicit assumption that “all that is
not explicitly modeled is forbidden”, and must therefore enumerate all the allowed
executions. therefore, when a negative r equirement (such as forbidding a certain
activity or stating that two activities must never co-exist in the same execution)
must be considered, it is not possible to make it explicit in the model; instead,
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 7
it is responsability of the user to check whether the produced model implicitly
entails the negative requirement or not. this is a diﬃcult task, especially when
the complexity of the model increases.
—premature commitment . since procedural approaches have a close nature and
do not provide proper abstractions, they force the modeler to prematurely take
decisions and make assumptions about the interaction. for example, even if the
considered choreography fragment doe s not specify how and when the warehouse
must be contacted, this choice must indeed be taken during the modeling phase.
the combination of these drawbacks has the eﬀect that choreographies become
over-speciﬁed andover-constrained : unnecessary activities and constraints are in-
troduced, and acceptable i nteractions are dropped out. as a consequence, while
compliance is respected, ﬂexibility becomes sacriﬁced: potential partners are dis-
carded, fruiful interactions are rejected and, at last, the choreography becomes un-
usable. when the modeler tries to get back ﬂexibility by relaxing the imposed con-
straints and reducing premature commitm ents, the lack of proper abstraction and
the closed nature of procedural approaches lead to further stress over-speciﬁcation:
the resulting choreography tends to become a tangled, unintellegible spaghetti-like
model, and, at the same time, the risk of supporting undesirable behaviors increases.
3. decserflow: a truly declarative service flow language
web service composition implies collaboration of independent interacting parties,
i.e., services. on the one hand, composition choreography reﬂects a common agree-
ment of various parties and must be applicable to various demands of interacting
parties. on the other hand, interacting parties are required to follow core rules that
maintain the integrity of the choreography. figure 2(a) shows that a choreogra-
phy prevents some unwanted (i.e., forbidden) scenarios, and parties can collaborate
only in scenarios allowed in the choreography. traditional modelling languages
(e.g., petri nets [reisig and rozenberg 1998] and ws-bpel [andrews et al. 2003])
are of imperative nature because they speci fy a scheduling procedure of activities
in the ﬂow. all possible interactions are speciﬁed in detail in such a model (as
shown in figure 2(b)) and unpredicted or exceptional interactions are not possible
between the parties. therefore, specify ing service ﬂows with an imperative lan-
guage limits the number of parties that are able to fulﬁll the model requirements.
instead of specifying a detailed ﬂow pro cedure, decserflow speciﬁes a minimal
set of rules that should be followed by the interacting parties. figure 2(c) shows
that, by explicitly specifying the rules, a declarative decserflow model implicitly
deﬁnes the ﬂow as all scenarios that do not violate the rules. clearly, the more
rules a decserflow model has, the less possibilities there are in the ﬂow. because
rules constrain the model, we refer to rules as to constraints .
decserflow process models can play two roles in the context of web services:
—decserflow can be used as a global choreography model [zaha et al. 2006], i.e.
interactions are described from the viewp oint of an external observer who oversees
all interactions between all services. i t is not necessary that a global model is
executable, but it can be used for describing the rules of engagement for making
all the interacting parties collaborate correct ly, and for veriﬁcation purposes (such
acm transactions on the web, vol. v, no. n, may 2009.8· montali, pesic, van der aalst, chesani, mello, storari
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x  
(a) forbidden and al-
lowed in service ﬂows.x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
imperative
model
(b) traditional impera-
tive model.x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
x x x x x x x x x x x x x x 
decserflow
(c) decserflow declara-
tive model.x x x 
x x x 
forbidden
behaviour
allowed
behaviour
possible
behaviour
fig. 2. decserflow as a declarative language.
as conformance checking and interoperability). here decserflow is competing
with languages such as the web services choreography description language
(ws-cdl) [kavantzas et al. 2004].
—decserflow can be used as a local model [zaha et al. 2006], to specify, implement,
or conﬁgure a particular service. here d ecserflow is competing with languages
such as ws-bpel [andrews et al. 2003].
the remainder of this section is organi zed as follows. in section 3.1 we present a
running example of a photo service. section 3.2 describes the building blocks of the
decserflow language. section 3.3 describes the global choreography (section 3.3.1)
and a local service model (sectio n 3.3.2) in terms of decserflow.
3.1 running example: photo shop
in this paper we use an illustrative example to describe how decserflow and its
underlying mappings can be suitably used for specifying and verifying choreogra-
phies. the example is concerned with a photo shop. due to the high competition
and booming of internet technologies, it is common that shops for development
and printing of photographs (and accompan ying services) employ web services for
remote placing orders. customers (indi vidual or other shops) can use a simple
service to place orders without having to personally come to the shop. table ii
shows the description of the interactio n between two services: (1) customer and
(2) photo shop. the customer service employs an on-line photo ordering service,
while the photo shop service prints and delivers ordered products.
table ii. photo shop example
both the customer and the shop are responsible for executing an order and they
have the following options:
customer. the customer can enter order data, such as name, address, credit
card number and preferred way of delivery, via activity “register”. activities
“photo” and “poster” can be used to order photographs and posters (respec-
tively) by uploading ﬁles and selecting wanted formats. customer can also
order photo albums by executing activity “album”. activities “receive” and
“pay” are used when receiving and paying ordered products, respectively.
photo shop. the shop records order data via activity “open order”. activity
“print” is used to print ordered photos and posters. the shop delivers products
and charges the customer for the service via activities “deliver” and “charge”.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 9
instead of following an explicitly speciﬁed order of service activities (from ta-
ble ii), the two parties obey to several constraints that deﬁne the global level of
service interaction (choreography), as presented in table iii:
table iii. global choreography constraints
g1. the shop will not “open order” before the customer executes activity “reg-
ister”. when the customer executes activity “register”, the shop will update
its data via activity “open order”. this rule ensures that the shop has the right
order data.
g2. after the customer orders photos and posters (via activities “photo” and
“poster”), the shop prints ordered products via activity “print”.
g3. each ordered product (“photo”, “poster” or “album”) has to be delivered
via activity “deliver”. the shop will not “deliver” before at least one product
is ordered.
g4. customer can receive products only after the shop executes “deliver”.
g5. customer can “pay” before (e.g., credit card) or after (e.g., when picking
up) the shop executes its activity “charge”.
each of the parties can employ a local ser vice model by their own preference, as
long as these models comply with the agreed choreography, i.e., with the agreed
global constraints g1,g2,g3,g4andg5presented in table iii. for example, the
photo shop can implement its local process b y the constraints presented in table iv
or it can even employ a procedural process model.
table iv. local photo shop constraints
l1. shop local service will start with activity “open order” .
l2. each printed (activity “print”) item will be delivered (activity “deliver”).
l3. the shop will “charge” administrative ﬁxed costs even for empty orders.
3.2 decserflow constraint templates
a decserflow model consists of activities a nd constraints that represent rules to
be followed while activities are executed. a constraint represents a relation be-
tween activities. for example, constraint g3represents a relation between activities
“photo”, “poster” and “album” on one side and activity “deliver” on the other side.
this type of rule is called “succession” and it speciﬁes that some activity “a” has
to be followed by some activity “b” and activity “b” cannot be executed before
activity “a”. constraint g2between activities “photo” and “poster” on one side
and activity “print” on the other side is also a “succession”. one can imagine that
one type of constraint can occur in various models between various activities. to
support reusability of types of constraints, decserflow language consists of a set of
constraint templates . a constraint template repres ents a type of relation between
activities that can be reused in various mo dels to create constraints between ac-
tivities. each template has a unique name and consists of: (1) a linear temporal
logic (ltl) formula that speciﬁes the semantics and (2) a graphical representa-
tion. ltl is a special type of logic that, in addition to classical logical operators,
acm transactions on the web, vol. v, no. n, may 2009.10· montali, pesic, van der aalst, chesani, mello, storari
uses several temporal operators: always ( 2), eventually ( 3), until ( /unionsq) and next
time ( /circlecopyrt) [clarke et al. 1999]. when adding a constraint to a model, one works
with graphical representation of the template and the underlying ltl formula re-
mains hidden. because of this, ltl expertise is not required for the development of
decserflow models. currently, there ar e more than twenty decserflow templates
[van der aalst and pesic 2006], and templates can easily be added, removed or
changed in decserflow. some of these templates are shown in table v.
name
 ltl expression
 graphical
existence (a)
 3(a)
a1..*
existence
 (a)
 3(a∧/circlecopyrt(existence (a)))
2..*
a
existence
 (a)
 3(a∧/circlecopyrt(existence (a)))
3..*
a
absence
 (a)
 ¬existence (a)
0..1
a
absence
 (a)
 ¬existence (a)
0..2
a
exactly
 (a)
 existence (a)∧absence (a)
1
a
exactly
 (a)
 existence (a)∧absence (a)
2
a
response (a, b)
 2(a⇒3(b))
ab
precedence (a, b)
 3(b)⇒((¬b)/unionsqa)
ab
succession (a, b)
 response (a, b)∧precedence (a, b)
ab
neg
response (a, b)
 2(a⇒¬(3(b)))
ab
responded
 existence (a, b)
 (3a)⇒(3b)
ab
alternate
 response (a, b)
response (a, b)
∧2(a⇒/circlecopyrt(precedence (b, a))
ab
chain
 response (a, b)
 2(a⇒/circlecopyrt(b))
ab
table v. some decserflow templates.
table v shows some of the decserflow templates involving one or two activi-
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 11
ties. note that it is also possible to make decserflow templates for three or more
activities. some templates specify the minimal number of execution of an activity.
for example, templates “e xistence” and “existence
 3” specify that activity “a” has
to be executed at least once and three time s, and are graphically represented with
“1..*” and “3..*” above the activity, respectively. there are also templates that
specify the maximal number of execution s of an activity. templates “absence
 2”
and “absence
 3” specify that activity “a” can be executed at most once or two times
and are graphically represented with “0..1” and “0..2” above the activity, respec-
tively. it is also possible to specify the exact number of executions of an activity,
e.g., exactly once or two times with templates “exactly
 1” or “exactly
 2”. the “re-
sponse” template speciﬁes that if “a” is executed then “b” has to be executed after
“a”, and is denoted with a special line between “a” and “b”. according to the
“precedence” template, “b” can be execute d only after “a”. th e “succession” tem-
plate is a conjunction of templates “respon se” and “precedence”. it is also possible
to specify that “b” cannot be execu ted after “a” with template “neg
 response”.
the template “responded
 existence” speciﬁes that if “a” is executed then also “b”
has to be executed before or after “a”, thus without specifying in which order. the
“alternate
 response” formula takes the order of activities into account: in addition
to the semantics of the “response” template, it imposes interposition, i.e., at least
one target activity has to be executed bet ween each two executions of the source
activity. finally, “chain
 response” speciﬁes the most strict ordering relations by
requiring that the target activity must be executed immediately next to the source
one. for a complete description of all d ecserflow constraints, see appendix a.
it is worth noting that constraints are interpreted within a given case (or chore-
ography instance). as a consequence, negative relationships, such as the absence or
the negation response constraints, forbi d the presence of a certain activity within
the same case in which the constraint has been triggered: other cases are not af-
fected.
finally, note that ltl is not the only language that can be used for the speciﬁ-
cation the semantics of decserflow templates. other declarative languages can be
also used. indeed, in this pap er we show that declarative sciff is also suitable
for specifying the semantics of decserfl ow templates. moreover, other types of
logic can also be used. for example, computation tree logic (ctl) is another
logic that can be used in decserflow. although ltl and ctl are similar lan-
guages, each of them has some advantages over the other. for example, there are
some relationships that can be speciﬁed only in ltl or in ctl, but not in both
languages [holzmann 2003]. however, so far, the debate about which of these two
languages is more expressive remains unsolved [holzmann 2003]. finally, we chose
ltl for the speciﬁcation of decserflow mo dels because we were inspired by the so
called ltl checker plug-in in the process mining tool prom, which can be used for
veriﬁcation of past executions against properties speciﬁed in ltl (the ltl checker
is described in more detail in section 6.1.3 of this paper).
3.3 decserflow models
decserflow models consists of activities and constraints. constraints represent
relationships between activities and are created from decserfl ow templates. dec-
serflow models can be used both for global models of choreographies and local
acm transactions on the web, vol. v, no. n, may 2009.12· montali, pesic, van der aalst, chesani, mello, storari
models of services. in this section we present two decserflow models: one for the
global choreography model and one for the local model of the photo shop service.
3.3.1 global choreography model. figure 3 shows a global decserflow model
with agreed upon choreography constraints g1,g2,g3,g4andg5(cf. table iii)
between a customer and the shop2. each constraint in this model originates from a
template: the constraint inherits its name, semantics and graphical representation
from its template. however, a constraint assigns “real” activities from a model to
template’s parameters. for example, the “ precedence” constraint replaces parame-
ter “a” from the “precedence” template with activity “deliver” and parameter “b”
with activity “receive”.
seller customer
poster albumprint
deliver
receive
pay chargeregister open ordersuccession
succession
succession
precedence
responded existencephotog1
g3g2
g4
g5
fig. 3. global choreography decserflow model
constraint “succession” between activities “register” and “open order” ( g1) spec-
iﬁes that each alternation of customer data will be registered in the shop and the
shop cannot open orders before the custom er executes activity “register”. when
this constraint is created, the activities “register” and “open order” replace param-
eters “a” and “b” in the template formula presented in table v:
succession (register, open order )
=response (register,open order )∧precedence (register,open order )
=(2(register ⇒3(open order )))∧(3(open order )⇒((¬open order )/unionsqregister ))
note that this constraint ( and its template) allows multiple executions of activi-
ties “register” and “open order” and also (multiple) executions of other activities
between them. for example, this model allo ws a scenario where t he user ﬁrst “reg-
isters” data and then soon executes this activity again to alter data, while the shop
2note that, for the purpose of the example, orders of diﬀerent items (photos, albums and posters)
have been represented as diﬀerent activities.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 13
executes activity “open order” only once af ter the second execution of the activity
“register”.
template “succession” is also used for the to constraints representing rules g2and
g3. unlike the previous constraint (g1) that utilizes only one activity (i.e., “regis-
ter”) as the ﬁrst parameter (i.e, “a”) in the template, g2andg3use two and three
activities, respectively. this means that g2andg3branch parameter “a” of the
succession on more activities. when a parameter is branched on several activities,
then it is replaced by disjunction of these act ivities in the constraint formula. there-
fore, formula for the “succession” constraint between activities “photo”, “poster”
and “print” ( g2) is:
succession (photo ∨poster, print )
=response (photo ∨poster, print )∧precedence (photo ∨poster, print )
= ((3print )⇒((¬print )/unionsq(photo ∨poster )))∧2((photo ∨poster )⇒(3print ))
this constraint speciﬁes that shop cannot execute activity “print” before the cus-
tomer executes activity “photo” or activity “poster” and that after every time ac-
tivities “photo” or “poster” a re executed, shop eventually executes activity “print”.
this constraint allows, for example, situations where photos are ordered and printed
and then posters are ordered and printed. it also allows situations where both pho-
tos and posters are ﬁrst ordered and th en they are printed at the same time.
similarly, the “succession” constraint between activities “photo”, “poster”, “al-
bum” and “deliver” ( g3) speciﬁes that each execution of activities “photo”, “poster”
or “album” is eventually followed by at least one execution of activity “deliver”.
also, activity “deliver” can be executed only after at least one of the activities
“photo”, “poster” or “album” was executed. with this constraint, the shop can
ﬁrst collect orders for photos, posters and albums and then deliver them at once.
however, it is also possible to immediately deliver each of the orders as soon as it
is placed.
the “precedence” constraint between ac tivities “receive” and “deliver” ( g4) pre-
vents the execution of activity “receive” bef ore the execution of activity “deliver”.
in other words, customer can execute acti vity “receive” only after the ﬁrst exe-
cution of activity “deliver”. an example of a scenario allowed by this constraint
is when two packages were sent in one delivery and the customer receives them
separately (e.g., one get lost in the postal system and arrives three days later).
the last constraint is the “responded exi stence” constraint between activities
“charge” and “pay”. it makes sure that customer executes activity “pay” when
the shop executes activity “charge” ( g5). it is possible that the payment is done
before activity “charge” takes place, e.g. , if the customer payed with a credit card
immediately after ordering, and the shop executed activity “charge” only after all
products were delivered.
note that, although this is not the case with model in figure 3, decserflow
constraints can be conditional. conditions on constraints are logical expressions
involving instance data elements. for example, a constrain can be valid (interacting
parties should fulﬁll the constraint) only if “ price > 1000”. because data are not
directly involved in constraints (like, e.g., activities are) but only in conditions,
ltl representation of decserflow covers on ly partially the perspective of instance
acm transactions on the web, vol. v, no. n, may 2009.14· montali, pesic, van der aalst, chesani, mello, storari
data.
the decserflow model in figure 3 shows global constraints as rules that all
parties have to follow in the choreography regardless their local service models.
because of the declarative nature of decser flow constraints, it is possible to em-
ploy various local models for both parties as long as they comply to such a global
choreography model.
3.3.2 local shop model. besides for speciﬁcation of global choreography mod-
els, decserflow can be used to specify local models of services. because of the
declarative nature of decserflow, servi ce models become ﬂexible and able to en-
gage in a variety of choreographies. figure 4 depicts two examples of possible local
models for the photo shop service.
printdeliverresponseopen orderinit
charge1..*l1
l2l3
(a) decserflow - ﬁxed costs.printdeliverresponseopen orderinit
chargeresponded
existence
(b) decserflow - deliveries.
fig. 4. two examples of local shop models
figure 4(a) shows a decserflow model for the photo shop service based on the
local constraints as presented in table iv. constraint “init” implements rule l1and
speciﬁes that each service execution has to s tart with activity “register”, but this
activity can be executed multiple times at later stages of the execution. rule l2is
represented using a “response” constrain t that makes sure that all printed products
are eventually delivered. it might be that all products are printed ﬁrst in several
stages (several executions of activity “pr int”) and then delivered at once. it is also
possible that products are delivered imme diately after they are printed, without
waiting for other products to be printed (e.g., some products are delivered to home
address via mail and a large poster has to be picked up personally in the shop).
finally, constraint “1..*” makes sure that the shop will execute activity “charge”
at least once, even if no delivery has been made and only ﬁxed administrative costs
are charged ( l3). activity “charge” can be executed multiple times in the shop
process if necessary to charge part by part of the order (e.g., one part from the
credit cart for photos and other in the shop when the large poster is picked up).
the local shop model presented in figure 4(a) is compliant with the global chore-
ography model in figure 3. moreover, because of the declarative nature of the
global model, this model is ﬂexible enough to allow for many other local models of
involved parties. for example, figure 4(b) shows a decserflow model of another
shop which does not charge ﬁxed costs for em pty services (but only deliveries). this
local model can also join the choreography in figure 3.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 15
4. the sciff framework
sciff [alberti et al. 2008] is a logic-based framework aimed at specifying global
interaction protocols (e.g. a service choreography) in a declarative fashion as well
as providing support for performing diﬀerent veriﬁcation tasks.
sciff tackles interaction by adopting a social approach, as it is called in the
mas community [singh 2000]. interaction is speciﬁed in a declarative manner by
only constraining the external observable behaviour of interacting entities, with-
out stating any assumption on their internal architecture and, thus, supporting
heterogeneity. moreover, as in decserflow the adopted perspective is open, i.e. in-
teracting entities can freely behave where not explicitly constrained.
the fundamental concepts used by sciff to specify such interaction are (i)ob-
servable and relevant events which occur at execution time, (ii)expectations about
further events and courses of interaction and (iii) (social) integrity constraints
which allow the user to constrain the global interaction.
4.1 events, happened events and expected events
deciding what has to be considered an event strictly depends on the application
domain. furthermore, even if the application domain is ﬁxed, there could be several
diﬀerent notions of events, because of the assumed perspective, the granularity, and
so on.
the sciff language completely abstracts from the problem of deciding “what
is an event”, and rather lets the develop ers decide which are the important events
for modeling the domain, at the desired level. for example, in a business context,
an event could be the fact that some atomic activity has been performed
performed (activity ,originator ,inputdata ,outputdata )
happened events are represented as an atom
h(event, t ime )
where event is a term and t ime is an integer, representing the discrete time
point at which the event happened. hap is the set of all the events that happened
during the execution. together, these ev ents form a log (or execution trace).
beside the explicit representation of “what” happened and “when”, it is possible
to explicitly represent also “what” is exp ected, and “when” it is expected to happen.
the notion of expectation is used to represent the (un)desired course of interaction,
and plays a key role when deﬁning interaction protocols, choreographies, and more
in general any dynamically evolving process: it is quite natural, in fact, to think
of such processes in terms of rules of the form “if a happened, then b is expected
(not) to happen” .
in agreement with decserflow, sciff pays particular attention to the openness
of interaction; this means that the prohibition of a certain event should be explicitly
expressed in the model and this is the reason why sciff supports also the concept
of negative expectation (i.e. of what is expected not to happen).
positive expectations about events come with form
e(event, t ime )
acm transactions on the web, vol. v, no. n, may 2009.16· montali, pesic, van der aalst, chesani, mello, storari
where event andt ime can be variables, or they could be grounded to a particular
term/value. constraints can be speciﬁed over each variable; for example t ime > 10
states that the expectation is about an event to happen at a time greater than 10
(hence the event is expected to happen after the time instant 10).
conversely, negative expectations about events come with form
en(event, t ime )
generally speaking, quantiﬁcation of the variables inside happened events and
positive/negative expectations follows th eir intuitive meaning: an happened event
represents a “class” of possible occurring ev ents, and therefore v ariables used in a
happened event are universally quantiﬁed. for example,
h(performed (deliver, originator ),td)∧td>10
matches with anyexecution of the activity “deliver ” at a time greater than 10 time
units, performed by a whatsoever originator . positive expectations are existen-
tially quantiﬁed: an expectation is fuﬁlled when one single matching event indeed
happens; hence, specifying
e(performed (deliver, originator ),td)∧td>10
means that there should exists an originator which performs activity “deliver” at
atime greater than 10. finally, negative expectations are universally quantiﬁed,
since they specify what is forbidden and when;
en(performed (deliver, originator ),td)∧td>10
means that nobody can perform the activity “deliver” at any time greater than 10.
for a complete description of variables quantiﬁcation, the interested reader may
refer to [alberti et al. 2008].
4.2 social integrity constraints
social integrity constraints (ics) are rules used to relate happened events and ex-
pectations. they allow the user to constrain global interaction, given some previous
situation that can be represente d in terms of happened events.
they are represented as forward rules of the form body →head , where body
can contain literals and (conjunctions of happened and expected) events, and head
can contain (disjunctions of) conjunctions of expectations.
in table vi we show the deﬁnition of a subset of the grammar (for a complete de-
scription, see [alberti et al. 2008]), where atom andt erm have the usual meaning
in logic programming [lloyd 1987] and constraint is interpreted as in constraint
logic programming (clp) [jaﬀar and maher 1994].
clp constraints and prolog predicates can be used to impose conditions or re-
strictions on each variable that occurs in happened events and expectations. for
example, time conditions might deﬁne orderings between messages, or enforce dead-
lines.
deﬁnition of such predicates and of all “static” background knowledge about
interaction (i.e., information independent from speciﬁc executions) is formalized
inside a knowledge base kb, which completes the deﬁnition of integrity constraints.
here we could specify roles descriptions, lis t of participants, conditions on data, etc.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 17
extliteral ::= literal |exp |constraint
exp ::= e(event, t ime )|en(event, t ime )
hevent ::= h(event, t ime )
event ::= t erm
ics::= [ ic]⋆
ic ::= body →head
body ::= ( hevent |exp|true)[∧bodyliteral ]⋆
bodyliteral ::= hevent |extliteral
head ::= headdisjunct [∨headdisjunct ]⋆|false
headdisjunct ::= extliteral [∧extliteral ]⋆
kb ::= [ clause ]⋆
clause ::= chead ←cbody
chead ::= atom
cbody ::= extliteral [∧extliteral ]⋆|true
table vi. syntax of integrity constraints ( ics) and the knowledge base ( kb)
kbis expressed in the form of clauses (a logic program); clauses may contain in
their body expectations about the behaviour of participants, deﬁned literals, and
constraints (see table vi).
example 4.1. a rule like
“if a premium customer pays for an it em by credit card, then the seller
should answer within 10 minutes by d elivering a corresponding receipt,
or by communicating a payment failure.”
can be translated in a straightforward manner, e.g. in the corresponding rule (sup-
posing that times are expressed in minutes):
h(pay(customer,seller, item, credit
 card),tp)
∧premium
 customer (customer, seller )
→e(deliver (seller, customer, receipt (item, info )),td)∧td>t p∧td<t p+ 10
∨e(tell(seller, customer, failure, reason ),tf)∧tf>t p∧tf<t p+ 10 .(1)
where premium
 customer (customer, seller )is used to represent whether customer
is actually a premium one.
to express mutual exclusion between delivery and failure communication, we
could also add a rule like
h(deliver (seller, customer, receipt (item,info )),td)
→en(tell(seller, customer, failure, reason ),tf).(2)
and viceversa3.
in the following, we show that decserflow can be suitably mapped onto a sciff
speciﬁcation (see section 5), and we exploit its operational counterpart (in terms
of the sciff proof procedure) to perform diﬀer ent veriﬁcation tasks (see section
6.2).
3note that such rules model the “not coexistence” formula in decserflow.
acm transactions on the web, vol. v, no. n, may 2009.18· montali, pesic, van der aalst, chesani, mello, storari
5. mapping decserflow onto the sciff framework
all the diﬀerent decserflow formulas can be intuitively mapped onto sciff in-
tegrity constraints. more speciﬁcally, we now introduce the mapping of basic
decserflow formulas, and then discuss how the expressive power of the sciff
language could be used to extend decserfl ow with explicit temporal constraints,
such as delays and deadlines, by maintaining a complete valid underlying seman-
tics in sciff. finally, we summarize how a sp eciﬁc decserflow diagram could be
mapped onto sciff, by directly combining the formalization of template formulas
with a speciﬁc knowledge representing the diagram.
5.1 formalization of activities
as pointed out in section 4.1, sciff completely abstracts from what has to be
considered as an observable and relevant event inside the application domain.
to formalize decserflow, we adopt an atomic model for activities, mapping a
whatsoever activity execution to an event of the form performed (activity ). thus,
notation h(performed (buy
item),18) means that the buy
item activity has been
executed at time 18. if also the originator and input/output data have to be
considered, we could simply extend the representation as follows:
performed (activity, originator, inputdata, outputdata )
it is worth noting that, in principle, a non atomic model of activities could be
seamlessly supported, by mapping the start and completion of each activity to
events.
5.2 mapping of decserflow constraints
table vii introduces the mapping of some decserflow formulas onto sciff.
let us consider ﬁrst unary formulas. the “absence
 n” formula leads to the gen-
eration of a negative expectation about the execution of the involved activity, after
ndiﬀerent executions of the same activi ty have already occurred. instead, the
“existence
 n” one states that ndiﬀerent execution of the activity are expected
to happen. since sciff adopts an explicit notion of time, the diﬀerence between
expectations about the same activity is modeled as a diﬀerence between the corre-
sponding execution times.
thesciff representations of the “absence” and the “existence
 n” formulas do
not have any triggering condition (i.e. their body do not contain happened events):
the involved expectations are always hypothesized and should always be fulﬁlled,
independently from the course of interaction.
the same holds for the decserflow “substitution” formula, which speciﬁes that
at least one of the involved activities should be executed. the substitution between
“a” and “b” is mapped onto sciff as follows:
true→e(performed (a),ta)∨e(performed (b),tb).
to express that “a” is exp ected to be executed exactly ntimes, it is possible
to combine together the “absence
 n” and the “existence
 n” formulas about “a”.
the former is indeed satisﬁed when nexecutions of “a” happened; but these n
happened events trigger the latter, which forbids further executions of “a”.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 19
name
 integrity constraint
 graphical
existence (a)
 true →e(performed (a),t)
a1..*
existence
 n(a)
true
→n^
i=1“
e(performed (a),ti)∧ti>t i−1”
n..*
a
absence (a)
 true →en(performed (a),t)
0
a
absence
 n+(a)
n^
i=1“
h(performed (a),ti)∧ti>t i−1”
→en(performed (a),t)∧t > t n
0..n
a
exactly
 n(a)
 existencen (a)∧absencen +(a)
n
a
response (a, b)
h(performed (a),ta)
→e(performed (b),tb)∧tb>t a.
ab
precedence (a, b)
h(performed (b),tb)
→e(performed (a),ta)∧ta<t b.
ab
succession (a, b)
 response (a, b)∧precedence (a, b)
ab
neg
response (a, b)
h(performed (a),ta)
→en(performed (b),tb)∧tb>t a.
ab
responded
 existence (a, b)
h(performed (a),ta)
→e(performed (b),tb).
ab
alternate
 response (a, b)
response (a, b)∧
h(performed (a),ta)
∧h(performed (a),ta2)∧ta2>t a
→e(performed (b),tb)
∧tb>t a∧tb<t a2.
ab
chain
 response (a, b)
h(performed (a),ta)
→e(performed (b),tb)∧tb>t a
∧en(performed (x),tx)
∧tx>t a∧tx<t b.
ab
table vii. mapping of some decserflow formulas onto sciff.
the mapping of relation formulas has a more ﬁxed structure. the body of each
integrity constraint is constituted in this case by the happened event which corre-
sponds to the formula’s source; in fact, each decserflow relation is triggered when
its source activity is performed.
while the ltl formalization implicitly models concepts like before and after
by exploiting temporal modalities, sciff speciﬁes them by explicitly constraining
time variables, i.e. by adopting a point algebra [vilain et al. 1990] and exploiting the
underlying clp solver; hence, to formalize the “response” formula sciff states
that if the source activity “a” happens at time “ ta”, then the target activity b
is expected to happen at a time “ tb>t a”. the “precedence” version of each
acm transactions on the web, vol. v, no. n, may 2009.20· montali, pesic, van der aalst, chesani, mello, storari
decserflow relation is ther efore formalized in the same way as the “response” one,
except from the fact that temporal constraints are inverted.
formalization of “alternate” formulas imposes, in addition to normal “response”/
“precedence” behaviour, the i nterposition between activities; closely following the
natural language description, interposition is expressed by stating that between
two executions of the source activity the target activity must be performed at least
once.
the “chain
 response” formula is instead formalized by applying the “response”
rule and by forbidding allevents between the execution of source and target activ-
ities. in this way, we map the concept of next state in ltl with the one of ﬁrst
next time at which some new activity is performed (and, in the “chain
 response”
case, such a new activity must be the target one). this is a proper formalization
when execution times may be explicitly constrained, and this is one of the added
feature that sciff provides to decser flow (see section 5.4).
finally, it is worth noting that mapping of negation formulas resembles very
closely the one of relation formulas. the main obvious diﬀerence is that while
relation formulas speciﬁes what should be done, negation formulas speciﬁes what is
forbidden, hence their formalization substitutes the concept of positive expectation
with the the one of negative expectation.
5.3 branching formulas
for the sake of simplicity, in the previous section we have limited our mapping to
binary relation and negation formulas. however, sciff is able to capture also
branching formulas, i.e. relation and negation formulas which envisage more than
two activities. as sketched in section 3.2, the presence of nsource or target activi-
ties is interpreted by decserflow in a disjunctive manner. more speciﬁcally, when
nsource activities “ a1”,...,“an” are used, then the formula should be satisﬁed
whenever “ a1” or “ a2” or . . . or “ an” is executed; hence, modeling a formula with
disjunctive sources is a short-cut for applying the formula on each source activity.
the intended meaning can then be easily captured by replicating the sciff for-
malization for each single sour ce activity. the presence of ntarget activities means
instead that the formula is satisﬁable in diﬀerent ways, i.e. it is true whenever it is
satisﬁed at least by one of the target activities. hence, the formalization of a for-
mula with disjunctive targets can be expressed by considering disjunction of target
expectations (together with the corresponding temporal constraints) as rule’s head.
table 5.3 shows how such a formalization is applied to the case of a branching
“responded existence” formula. it4tackles also the situation, not envisaged by core
decserflow formulas, of a branching “re sponded existence” wh ere target/source
multiplicity is interpreted in a conjuncti ve manner. such an interpretation behaves
in the opposite way w.r.t. the disjunctive one. a formula with conjunct targets
is fulﬁlled when it is true for all target activities, and hence it can be formalized
by replicating the corresponding integrity constraint for each activity. a more
complex case is the one in which the formula has conjunct source activities: it
should trigger only when all such activities are executed. sciff is directly able to
represent this feature: the corresponding rule will have as body the conjunction of
4but the same holds also for the other relation and negation formulas.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 21
name representationequivalent
representationformalization
responded
 existence
(a1∨a2,b)a2ba1a2ba1h(performed (a1),ta)
→e(performed (b),tb).
h(performed (a2),ta)
→e(performed (b),tb).
responded
 existence
(a, b 1∨b2)b2ab1 h(performed (a1),ta)
→e(performed (b1),tb1)
∨e(performed (b2),tb2).
responded
 existence
(a, b 1∧b2)b2ab1b2ab1h(performed (a),ta)
→e(performed (b1),tb).
h(performed (a),ta)
→e(performed (b2),tb).
responded
 existence
(a1∧a2,b)a2ba1 h(performed (a1),ta2)
∧h(performed (a2),ta2)
→e(performed (b),tb).
table viii. formalization of a branching “responded existence” formula in sciff.
the involved happened events.
5.4 extending decserflow with quantitative temporal constraints
another interesting feature, due to sciff reasoning capabilities on content data
(and therefore also on execution times), is the possibility to extend the basic decser-
flow relation formulas (and the simple negation formulas, i.e. “negation response”
and “negation precedence”) wit h quantitative information over times, e.g. to ex-
press delays and deadlines. such an information is used to reduce the validity of
formula’s target time (or, in the negative case, to delimit the forbidding of the
target), by deﬁning either a lower or an upper bound on it.
let us modify, for example, the photo choreography shown in figure 3 by spec-
ifying also that “at most 24 hours can elapse between the order of a product and
the corresponding delivery”. by assuming that times are expressed in hours, such
a statement could be represented by augm enting the “succession” formula between
the three kinds of order and the “deliver” activity with the knowledge about the
deadline: the delivery time should be aft er the order one, but also less than the
order one plus 24 hours (and vice versa). this could be seamlessly modeled in
sciff by extending the formalization of the “succession” formula as follows (for
simplicity, in the formalization we consider only activities “photo” and “deliver”):
h(performed (photo ),tp)→e(performed (deliver ),td)
∧td>t p∧td<t p+ 24 . (3)
h(performed (deliver ),td)→e(performed (photo ),tp)
∧tp<t d∧tp>t d−24. (4)
to graphically show these temporal extensions, a possible choice is to annotate
the diﬀerent decserflow co nstraints with a time interval marked oﬀ by two non
negative instants ( tminandtmax) which could be considered both in an exclusive
acm transactions on the web, vol. v, no. n, may 2009.22· montali, pesic, van der aalst, chesani, mello, storari
or inclusive manner. as usually, parentheses ( ( ...) ) are used to indicate exclusion
and square brackets ( [ ...] ) to indicate inclusion. the i nterval is treated as relative
w.r.t. the time at which the source happens, and is translated backward or forward
w.r.t. it depending on the nature of the formula (i.e. whether it is a “response” or
“precedence” one).
posteralbumprintdeliver
receivepaychargeregisteropen ordersuccession
succession
succession
precedence
responded existencephoto
(0,24)
fig. 5. modiﬁcation of the decserflow running example by adding a temporal deadline.
for example, let us consider again the mo diﬁed running example, denoting with
toandtdthe execution times of one of the order activities and “deliver” respec-
tively. as shown in figure 5, the annotation of the succession formula to reﬂect
the declared deadline should be (0 ,24), since tdhas to belong to the time interval
(tp,tp+ 24) and, conversely, toto the interval ( td−24,td).
this intended meaning is clariﬁed in figure 6, which summarizes how temporal
annotations could be used to model diﬀerent kind of quantitative temporal relation-
ships in case of simple relation formulas, namely “responded existence”, “response”
and “precedence”.
quantitative temporal constraints should not be interpreted as a way to force
the emission of a message from a certain service; indeed, when the focus is on
the choreography the concrete interacti ng services execute in an autonomous way,
and cannot be controlled. instead, temporal constraints should be considered as
a mean to specify further requirements on t he interacting service, contributing to
the deﬁnition of the qos that must be guaranteed during the interaction: com-
pliant executions must not only respect th e modeled constraints, but also satisfy
all the temporal requirements. for exam ple, the deadline of 24 hours introduced
in figure 5 could represent a qos requirement of the customer, who considers as
good candidates to interact with only photo services able to deliver within a max-
imum timespan. this information can be used either to statically select “good”
photo services, i.e., photo services whose b ehavioural interface respects (promises
to respect) the desired temporal constraint, and to check at run-time if the real be-
haviour eﬀectively satisﬁes it. identifying a violation may be useful in this setting
to alert the customer that the photo service is breaking the choreographic contract.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 23
afterafter(n)
ta+na performed at time ta
before(n)
ta-nbeforebetween(n 1,n2)
ta+n1 ta+n2
ta-n2 ta-n1between(n 1,n2)anytime
equals(n)
ta+nequals(n)
ta-na b
a b
a b
a b
a b(n,-)
a b
(n,-)a b
(n1,n2)
a b(n1,n2)
[n,n]
[n,n]
a bvalidity of tb
fig. 6. temporal constraints templates and their corresponding representation on simple formulas.
5.5 cross-ﬂow constraints
similarly to the approach presented in the previous section aimed at extending
decserflow speciﬁcations w.r.t. the tem poral dimension, also other kinds of data
may be modeled and constrained by sciff. for example, rule 1 (page 17) shows
how sender, receiver and content data of a message can be seamlessly introduced
and used. however, introducing data and their corresponding constraints at the
graphical level of decserflow is a compl ex task, mainly because the right balance
between expressiveness and usability must be found. even if the introduction of
data and data-related conditions into the decserflow notation has not been yet
investigated, in this section we brieﬂy sketch how the possibility of dealing with
data, provided by sciff, could be exploited to model a wider range of constraints.
in particular, let us review the concept o f negative relationship in decserflow.
negative relationships deal with the forbidding of an activity under certain cir-
cumstances. for example, the “negation r esponse” between two activities “a” and
“b” states that if “a” is executed, then “b ” cannot be executed afterwards. the
forbidding of “b” is limited to the case inside which “a” has been executed: each
choreography instance follows its own evolution, independentely from the other
cases. however, there could be situations in which it would be desirable that con-
straints span across multiple cases. an example of a cross-ﬂow constraint woule
be that if the seller detect that a certain customer cis behaving in a fraudolent
way, then it will never deliver anything to cin the future, even in new instances
of execution.
sciff is able to easily capture this requirement. a possible solution would be
acm transactions on the web, vol. v, no. n, may 2009.24· montali, pesic, van der aalst, chesani, mello, storari
associate each activity to a case identiﬁer , modeled as a special datum. by default,
constraints operate within the same instance, and therefore a “normal” negation
response would be modeled as follows:
h(performed (a, case ),ta)→en(performed (b, case ),tb)∧tb>t a.
here, the same case variable is shared by the events associated to “a” and “b”,
and therefore if “a” is executed inside case c1, then the forbidding of “b” will be
imposed only on the same c1.
cross-ﬂow constraints could be therefore modeled by simply introducing two
diﬀerent case variables. for example, to model that “when a seller sdetect that a
customer cis behaving in a fraudolent way, it will never deliver goods to c” the
following (extended) negation response could be adopted:
h(performed (fraud
 detected (c), s, case ),tf)
→en(performed (deliver (s, c, g ), case 2),td)∧td>t a.
since two diﬀerent variables case andcase 2are used, when a fraud is detected
the forbidding is imposed on any case ( case included): negativ e expectation are
universally quantiﬁed. contrarywise, the same customer cis involved in the body
and in the head of the rule, and therefore the forbidding is imposed only on that
c, without aﬀecting the interaction between sand other customers.
5.6 explicit and implicit formalization of decserflow templates
we have shown the mapping of core decserflow templates to sciff integrity
constraints. obviously, for a given model these diﬀerent rules will be grounded
on each speciﬁc instance, substituting invo lved activities with the concrete names.
in this respect, for each relationships of the model the formalization will explicitly
contain a corresponding set of rules. howev er, it is possible to generalize the for-
malization of decserflow formulas by direct ly representing templates. in this way,
speciﬁc concrete rules are implictly model : the translation of a speciﬁc decserflow
diagram simply reduces to compile a knowledge base with a list of facts representing
the diﬀerent modeled formulas.
the general formalization is realized by adding as a ﬁrst conjunct in the bodies
of rules a predicate which represents the corresponding relationship. this predicate
will match, for a given knowledge base, with all the facts representing instances of
such relationship.
to deﬁne relation and negation templates, we therefore adopt the following pat-
tern:
formula
 t ype (source, t arget )
∧body →head.(5)
it is worth noting that in the ﬁrst line of all integrity constraints of this kind,
variables (i.e. activities) are universally quantiﬁed. this ensures that, when con-
sidering a speciﬁc diagram, each rule will be replicated for all concrete (ground)
activities subject to the formula addressed by the rule.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 25
an example which clariﬁes this approach in case of the “response” template
follows.
example 5.1. let us consider the general speciﬁcation of the “response” rela-
tion, which is formalized as follows:
response (a, b)
∧h(performed (a),ta)→e(performed (b),tb)∧tb>t a.(6)
this rule may be read as follows: “for each a, for each band for each ta, if
aandbare subject to a “response” formula and ais executed at time ta, then
there should exist a tbafter taat which bis expected to be performed”.
let us now consider the simple following knowledge base:
response(ask_for_payment, pay).
response(receive_spam, delete_spam).
during execution, sciff will ﬁnd two diﬀerent matches for the “response” for-
mula, automatically grounding the above integrity constraint on each concrete re-
lationship:
h(performed (ask
for
payment ),ta)→e(performed (pay),tb)∧tb>t a.
h(performed (receive
 spam ),ta)→e(performed (delete
 spam ),tb)∧tb>t a.
5.7 implicit and explicit mapping of the running example onto sciff
by using this kind of “implicit” formalization we have now the possibility to com-
pletely separate the formalization of t he general decserflow templates and the
formalization of a speciﬁc model. in part icular, decserflow can be mapped onto
an abductive logic program whose integrity constraints are the ones which implic-
itly formalize template formulas, and whose knowledge base is used to capture the
general background knowledge of decser flow concepts. for example, in such a
knowledge base we will ﬁnd that the “succession” formula is deﬁned in terms of the
“response” and the “precedence” ones:
response (a, b)←succession (a, b).
precedence (a, b)←succession (a, b).
then, as already pointed out in example 5.1, formalizing a particular decserflow
diagram just implies to (i)compile another knowledge base which maps the speciﬁc
diagram structure enumerating all its constraints as facts, and (ii)use it together
with the general speciﬁcation.
tables ix and x show how the running example depicted in figure 3 can be
mapped onto sciff by respectively adopting explicit rules grounded on the exam-
ple or by exploiting the possibility to use the general mapping and simply formalize
the speciﬁc diagram as a list of facts. it is worth noting that, exactly as shown in
example 5.1, matching the general implicit decserflow integrity constraints with
the knowledge base of table x will have the eﬀect of obtaining the rules shown in
table ix.
acm transactions on the web, vol. v, no. n, may 2009.26· montali, pesic, van der aalst, chesani, mello, storari
g1a h(performed (register ),tr)→e(performed (open
 order ),to)∧to>t r.
bh(performed (open
 order ),to)→e(performed (register ),tr)∧tr<t o.
g2a h(performed (photo ),tph)→e(performed (print ),tpr)∧tpr>t ph.
b h(performed (poster ),tpo)→e(performed (print ),tpr)∧tpr>t po.
c h(performed (print ),tpr)→e(performed (photo ),tph)∨tph<t pr
∨e(performed (poster ),tpo)∨tpo<t pr.
g3a h(performed (photo ),tp)→e(performed (deliver ),td)∧td>t p.
b h(performed (poster ),tp)→e(performed (deliver ),td)∧td>t p.
c h(performed (album ),ta)→e(performed (deliver ),td)∧td>t a.
d h(performed (deliver ),td)→e(performed (photo ),tph)∧tph<t d
∨e(performed (poster ),tpo)∧tpo<t d
∨e(performed (album ),ta)∧ta<t d.
g4 h(performed (receive ),tr)→e(performed (deliver ),td)∧td<t r.
g5 h(performed (charge ),tc)→e(performed (pay),tp).
table ix. explicit sciff mapping of the decserflow running example.
g1succession (register,open
 order ).
g2succession ([photo, poster ], print ).
g3succession ([photo, poster, album ], deliver ).
g4precedence (deliver, receive ).
g5responded
 existence (charge, pay ).
table x. mapping the decserflow running example to a simple knowledge base.
6. enactment, verification and dynamic change of decserflow
models
the ltl and sciff notations of decserflow enab les various veriﬁcation tech-
niques and even enactment of decserflow models. through the combination of
decserflow as a modeling language and the two underlying semantics with their
corresponding veriﬁcation techniques, we aim to realize a comprehensive framework
for the speciﬁcation, enactment, and veriﬁcation of service choreographies (see fig-
ure 7). declare [pesic et al. 2007]5is a tool that can be used to develop and
execute models speciﬁed in decserflow or any other ltl based language. al-
though it is not implemented as a web service application, declare can be used
to experiment with templates and models in order to better understand templates
and the execution semantics of decserfl ow models. declare uses the approach
described in this section for the execution, dynamic change and veriﬁcation of dec-
serflow models.
5declare can be downloaded from http://declare.sf.net .
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 27
formal
choreography
speci cationdecserflowsciffgraphical
choreography
speci cationmapping
vericationsltlmapping
mining properties
vericationconformance
vericationenactmentinteroperability
verication
enablesenable
fig. 7. general schema of a framework for the speciﬁcation and veriﬁcation of service choreogra-
phies, and its possible realization by the conjunct use of decserflow, ltl and sciff.
6.1 ltl enactment and veriﬁcation
the ltl mapping of decserflow enables the computer-supported execution of local
models of participating services, veriﬁcation of models, monitoring (conformance-
checking) of service execution and veriﬁcation of composition interoperability (i.e.,
can diﬀerent models be combi ned into one composition).
6.1.1 supporting execution of decserflow models. while interacting within a
global choreography, each service should align its execution with its local model
and the global choreography model. with respect to decserflow, this means that
a completed interaction must satisfy the l ocal model of interacting services and the
global choreography model. a decserflow model is satisﬁed if it is executed in
such a way that all its constraints are satisﬁed at the end of the execution. some
application can regulate a correct execution of decserflow models thanks to (1) the
constraint semantics expressed with ltl formulas and (2) the possibility to gener-
ate an automaton that represents all executions that satisfy an ltl formula. the
desire to generate automata for ltl formulas and to deﬁne algorithms for this pur-
pose originates in the ﬁeld of model checking [clarke et al. 1999; gerth et al. 1996;
giannakopoulou and havelund 2001]. in this ﬁeld, systems can be checked against
certain properties speciﬁed in ltl using the generated automata. the computer-
supported regulation of a co rrect execution of decserfl ow relies on the automaton
generated from ltl speciﬁcations of constraints in the model (i.e., one automaton
is generated for a formula representing a conjunction of all constraints ) [van der
aalst and pesic 2006]. because it is generated for the conjunction of all constraints
form a decserflow model, such an automato n represents exactly all correct exe-
cutions of the model (i.e., all executions that satisfy all constraints) [clarke et al.
1999; gerth et al. 1996; giannakopoulou and havelund 2001]. in other words,
using this automaton, it is possible to, during execution, (1) monitor the current
state of the execution by monitoring the current state of the automaton, and (2)
precisely identify which activities can be executed next given the current state of
the automaton. consi der, for example, the “preceden ce” decserflow template. if
a decserflow model contains a “precedence” constraint between two activities “de-
acm transactions on the web, vol. v, no. n, may 2009.28· montali, pesic, van der aalst, chesani, mello, storari
liver” and “receive” (e.g., fig ure 3), then the automaton created for this model will
allow execution of “receive” only after “de liver” is executed, as shown in figure 8.
the theory on automata and their generation from ltl formulas is out of scope
of this paper and we refer the interested reader to [clarke et al. 1999; gerth et al.
1996; giannakopoulou and havelund 2001].
s1 s0!receive true
deliver
fig. 8. automaton for the ltl notation of constraint “precedence(deliver,receive)”.
note that it is possible that a constraint (and a model) is temporarily violated at
some points of execution and satisﬁed at the end of execution. for example, the “re-
sponded existence” template and a (local or global) model containing a “responded
existence” constraint between activities “charge” and “pay” (e.g., figure 3). this
constraint speciﬁes that, if “charge” is executed, then “pay” must also be executed
before or after “charge”. as long as none of these two actives is executed, the
constraint and the model are satisﬁed. a t the moment when “charge” is executed
for the ﬁrst time, the constraint and the model become temporarily violated. this
is only a temporary violation because it is still possible to satisfy this constraint
and the model in the future, by executing activity “pay”. indeed, this execution
can be considered to be a correct execution only after activity “pay” is executed,
because only then the “responded existence” and the model become satisﬁed. the
automata generated from ltl speciﬁcations of each constraint and the conjunc-
tion of all constraints in the model can be used to monitor states of constraints
and the model. for example, figure 9 shows the automaton created for constraint
“responded existence(charge,pay)”. thi s automaton can indeed be used to monitor
the state of this constraint: executing activity “charge” brings the automaton to a
non-accepting (denoted by a single border) state “s1”, and only e xecuting activity
“pay” again brings the automaton to the accepting (denoted by a double border)
state “s2”.
s1
s0!charge /\ !pay!pay
charge
s2true
paypay
fig. 9. automaton for the ltl notation of constraint “responded existence(charge,pay)”.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 29
the automata generated for each constraint and the conjunction of all constraints
in a model can be used to: (1) make sure tha t interacting activities execute only
activities that eventually lead to the satisfaction of their local models and the global
choreography model, and (2) provide feedback about the current state of the inter-
action with respect to the satisfaction of local models and the global choreography
model and the satisfaction of each constraint from these models (state of one con-
straint can be monitored using the automaton generated for the ltl notation of
that particular constraint).
note that the word “execution” should not understood literarily when it comes
to web services because it is not possible t o enforce a certain execution of a service.
instead, the method described in this s ection could be used as a guideline towards
a deadlock-free execution. the automa ta generated from a conjunction of ltl
speciﬁcations of constraints ensures that deadlocks do not occur. on the one hand,
if activities of services are executed in a way allowed by the automata, a deadlock
will not occur. on the other hand, it the a utomaton is not in a n accepting state,
interaction constraints are not satisﬁed and the interaction cannot yet be success-
fully completed. note that, enforcing an execution becomes even more unrealistic
when it comes to timed constraints, i.e., co nstraints with deadlines. for example,
it is not possible to enforce that a ser vice executes a task within ﬁve days.
6.1.2 verifying local and global decserflow models. the risk of introducing
errors in decserflow models is high beca use it is hard to maintain an overall un-
derstanding of many diﬀerent constraint s. two types of errors can occur in decser-
flow models due to an unwanted combination of constraints: dead activities and
conﬂicts .
figure 10(a) shows a composition of one global and two local models (customer
and shop) for the photo shop example. in this case, the customer does not change
the global choreography cons traints. due to two “succession” constraints in the
global model, each ordered photo and poster will be printed in the shop and de-
livered. however, the shop developed use s a local model that contains a “not co-
existence” constraint specifying that activities “print” and “deliver” exclude each
other. this means that the shop either prints or delivers within one order, but
never both. therefore, if activities “ photo” or “poster” are executed the chore-
ography cannot be successfully executed b ecause it will not be possible to satisfy
the three constraints (i.e., two “succession ” constraints and the “not co-existence”
constraint). theref ore, it will never be possible to execute activities “photo” and
“poster” in the customer service, i.e., these are dead activities . moreover, activity
“print” is also a dead activity since it should be executed after activities “photo”
or “poster”, which are dead activities.
while it is still possible to execute choreography presented in figure 10(a) (with
ordering albums or empty orders as only possibilities), the example presented in
figure 10(b) is not executable at all, i.e., it contains a conﬂict ; this means that
the decserflow model is inconsistent . as described before, the local shop model
handles only album orders (i.e., preventing executions of dead activities “photo”
and “poster”) in the global choreography model. the local customer model in fig-
ure 10(b) imposes execution of activity “photo” via constraint “1..*” which makes
it impossible for this customer and shop to interact in this global choreography
acm transactions on the web, vol. v, no. n, may 2009.30· montali, pesic, van der aalst, chesani, mello, storari
posteralbumprint
deliver
receivepaychargeregisteropen ordersuccession
succession
succession
precedence
responded existencenot co- existence 
photo
local 
shop
(a) dead activities in a decserflow composi-
tion (“photo”, “poster” and “print”).
posteralbumprint
deliver
receivepaycharge1..*registeropen ordersuccession
succession
succession
precedence
responded existencephoto
not co- existence local 
shopreal 
customer
(b) conﬂict in a decserflow composition.
fig. 10. veriﬁcation of decserflow models.
model. the conﬂict in the model in figure 10(b) is caused by the combination
of four constraints: the “1..*” constraint, the two “succession” constraints and the
“not co-existence” constraint.
6.1.2.1 detecting dead activities and conﬂicts. errors such as the ones just
described can easily be detected in decs erflow models using the automata gen-
erated[clarke et al. 1999; gerth et al. 1996; giannakopoulou and havelund 2001]
from constraints (cf. section 6.1.1). to verify a combination of several models (i.e.,
global model and two local models), an automaton is created for a conjunction of all
constraints in all models. the generated automata allow for all possible execution
traces of the decserflow mo del at hand. models are executed by triggering ac-
tivities via automaton transition, where each transition triggers none, one or more
activities. a dead activity is an activity that never appears in any of the execution
traces, i.e., there is no transition in the automaton that allows this activity. a
conﬂict is detected when the automata doe s not parse any trace, i.e., the automata
does not contain any state or transition.
decserflow models can be veriﬁed against dead activities and conﬂicts in the de-
clare tool. for a full veriﬁcation support, declare not only detects errors,
but also reports the smallest subset of constraints that causes the error. the achieve
this, the tool veriﬁes the conjunctions of smaller groups of constraints by searching
through the power set of constraints. figure 11 shows the veriﬁcation report gen-
erated by declare for model in figure 10(a): activities “photo”, “poster” and
“print” are dead due to the combination of three constraints.
fig. 11. declare reports the three dead activities of model depicted in figure 10(a).
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 31
local
alocal
bglobal
(a) local error.local
alocal
b
global
(b) global error.local
alocal
b
global
(c) local model not compatible with global one.local
aglobal
local
b
(d) composition of local models not compatible
with global one.
fig. 12. implications of errors in decserflow models.
6.1.2.2 interoperability veriﬁcation. errors discovered in veriﬁcation can imply
four types of problems in interoperability of service compositions, as illustrated
by figure 12. first, local service models can be veriﬁed (cf. figure 12(a)). for
example, if a conﬂict is found, the local model has to be ﬁxed before being employed
in any choreography, i.e., the local model cannot be employed in any choreography.
second, a global choreography model may contain errors. global models with
conﬂicts cannot be enacted by a set of parties (regardless of the local models), as
shown in figure 12(b). third, an error can be discovered in the composition of a
local model of one party and the global choreography model (cf. figure 12(c)). in
this case, the party is not compatible with the global choreography rules. finally,
figure 12(d) shows that an error can be di scovered in the ser vice composition,
i.e., local models are not compatible with each other with respect to the global
model. for example, if this is a conﬂict error, then the two parties cannot join the
choreography. note that the model presented in figure 12(b) is an example of a
composition where the book shop and the print shop are not compatible with the
global choreography model (cf. figure 12(d)).
6.1.3 monitoring decserflow services. besides for execution and veriﬁcation of
models and choreographes, decserflow can be used for service monitoring (i.e, for
conformance checking of completed service executions) using the prom (process
mining) framework [van der aalst et al. 2007; van der aalst et al. 2005]. the
prom framework is an open-source infras tructure for process mining techniques.
one of the more than 150 plug-ins oﬀered by prom is the so-called ltl checker
[van der aalst et al. 2005]. for each process instance, ltl checker determines
whether an ltl expression holds or not, i.e., given an ltl expression all process
instances are partitioned on two classes: compliant and non-compliant. because
each decserflow constraint is represented by an ltl expression, it is possible to
use the prom ltl checker to assess conformance of a decserflow model in the
context of a real log.
6.1.4 dynamic change of decserflow models. decserflow mode ls can be changed
dynamically, i.e., while they are being executed, by adding and removing activities
and constraints. note that it is not allowed to remove an activity that is involved
in a constraint. this problem can be solved in two ways: (1) removing such an
activity is rejected, or (2) the activity a nd all related constraints are removed. in
acm transactions on the web, vol. v, no. n, may 2009.32· montali, pesic, van der aalst, chesani, mello, storari
this way, we prevent situations where a model contains a constraints involving an
activity that is not in the model. when it comes to continuing the execution after
a dynamic change, decserflow uses the fo llowing procedure. first, the automa-
ton is created from a conjunction of all constraints in the new model and attempt
is made to ‘replay’ the current execution trace (i.e., a list of all executed activ-
ities)on this automaton. if this attempt succeeds, the execution continues using
the new automata. if the attempt fails, this means that the current execution
trace contradicts to the new model. in this case the dynamic change is rejected
and the execution resumes with the old model. note that the automata generated
for decserflow constraints allow for execution of activities that are not involved
in constraints. consider, for example, the automaton for constraint “responded
existence(charge,pay)” shown in figure 9. although this constraint involves only
activities “charge” and “pay”, it allows execution of other activities. for example,
transitions “ /negationslashpay” and “ /negationslashcharge ∧/negationslashpay” allow execution of other activities. this
is a useful feature when it comes to dynamic change for two reasons. first, it is
possible to remove an activity even after it has been executed, because it will be
possible to ‘replay’ the removed activity on the automaton. second, adding a new
activity means that, from that moment, it becomes possible to execute it in the
automaton.
6.2 sciff veriﬁcation
beside the possibility of extending the decserflow notation with data-related and
quantitative temporal constraints, mapping decserflow to sciff enables con-
formance checking, both at run-time or a posteriori, of service execution w.r.t. a
decserflow diagram (maintaining a complete support even when considering its
extensions), and mining of decserflow models starting from a set of execution
traces, previously labeled as compliant or not. furthermore, sciff has been ex-
tended to deal also with static veriﬁcations (interoperability, discovery of conﬂicts
and dead activities).
6.2.1 abductive declarative and operational semantics of the sciff framework.
within the logic programming setting, a typical approach is to deﬁne both a declar-
ative and operational semantics for logic programs (in our speciﬁc case, for sciff
interaction speciﬁcations). roughly speaking, declarative semantics aims at deﬁn-
ing the “meaning” of what is speciﬁed, wh ereas operational semantics describes
a general-purpose algorithm capable of con cretely exploit the speciﬁcation. the
main advantages of such an approach are that speciﬁcations are interpreted in a
clear and intuitive way, and that it is possible to prove soundness and completeness
of the operational semantics w.r.t. the declarative one, ensuring that its behaviour
really respect the intended meaning.
in the sciff framework, declarative semanti cs of interaction speciﬁcations is
given in terms of an abductive logic program (alp), whereas the corresponding
operational semantics is given in terms of an abductive proof procedure [alberti
et al. 2008], thought for performing diﬀerent veriﬁcation tasks.
in general, an alp [kakas et al. 1993] is a triple /angbracketleftp, a, ic /angbracketright, where pis a logic
program, ais a set of predicates named abducibles , and icis a set of integrity
constraints. roughly speaking, the role of pis to deﬁne predicates, the role of a
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 33
is to ﬁll-in the parts of pwhich are unknown, and the role if icis to control the
ways elements of aare hypothesised, or “abduced”.
insciff, similarly to the general alp setting, an interaction speciﬁcation sis
deﬁned by the triple:
s ≡ /angbracketleftkb,e,ics/angbracketright
where:
—kbis the social knowledge base , suitable for specifying the static knowledge on
interacting entities;
—eis the set of abducible predicates , namely positive expectations (functor e) and
negative expectations (functor en);
—icsis the set of social integrity constraints , used to specify the rules of inter-
action.
reasoning in abductive logic programming is usually goal-directed (being ga
goal), and it accounts to ﬁnd an abductive explanation ∆ built from predicates in
asuch that p∪∆|=gandp∪∆|=ic. in the past, a number of
proof-procedures have been proposed to compute ∆ ([kakas and mancarella 1990;
fung and kowalski 1997; denecker and schreye 1998], etc.). in sciff, the major
diﬀerence is that not only the logic program has to be taken into account, but also
the (dynamic) set of occuring happened ev ents (which increm entally compose the
execution trace). further more, when modeling decs erflow constraints in sciff
the goal is not directly exploited; actually, we could consider as goal the conjunc-
tion of “existence
 n”, “exactly
 n”, “absence” and “mutual substitution” formulas
inside the model: they directly impose ex pectations about (not) performing cer-
tain activities indepentendly from executions (indeed, their formalization consists
in rules with a true body).
the idea we exploited in the sciff framework is to adopt abduction to dy-
namically generate the expectations. expectations are deﬁned as abducibles, and
they are hypothesised by the sciff abductive proof procedure [alberti et al. 2008],
i.e. the proof procedure makes hypotheses about the expected peers behaviour. the
set of abduced expectations must satisfy the integrity constraints which formalize
the choreography.
6.2.2 conformance checking with sciff. as sketched in the previous section,
the main and original aim of the sciff framework was not only to provide a
suitable and rich language for describing global interactions, but also to equip such
a language with diﬀerent veriﬁcation capabilities.
the major innovation of sciff’s declarative semantics w.r.t. classical abductive
frameworks is the concept of fulﬁllment , which deﬁnes in an intuitive way the rela-
tionship between happened even ts and expectations and makes sciff suitable for
veriﬁcation. in particular, sciff is thought to realize the conformance checking
task, namely to verify whether a set of inte racting entities behave accordingly to
the speciﬁcation.
the basic intuitive idea of conformance in sciff, which is indeed supported both
by a declarative and operational semantics , is to take into account the hypothesized
acm transactions on the web, vol. v, no. n, may 2009.34· montali, pesic, van der aalst, chesani, mello, storari
expectations and link them with the actu al peers behaviour, to check whether
happened events really adhere to expectatio ns. in particular, a positive expectation
requires a corresponding matching happen ed event, whereas a negative expectation
forbid the presence of a matching occurred event. when this is the case, we say
that the expectation is fulﬁlled .
example 6.1. let us consider the “time-extended” succession formula between
“photo” and “deliver” activities shown in figure 5, whose sciff (explicit) formal-
ization is described by integrity constraints (3)and (4).
let us also consider the following execution trace:
h(performed (photo ),16).
h(performed (photo ),19).
h(performed (deliver ),30).
each of the ﬁrst two happened events matches with the body of (3), leading to
generate two expectations about the execution of the “deliver” activity, whereas the
third happened event triggers the “pr ecedence” part of the “succession” formula,
generating a backward expectation about a previous execution of activity “photo”:
exp ={e(performed (deliver ),td)∧td>16∧td<40,
e(performed (deliver ),td/prime)∧td/prime>19∧td/prime<43,
e(performed (photo ),tp)∧tp<30∧tp>6}
all the three expectations actually have a matching happened event in the execution
trace, which is therefore evaluated as conformant. in particular, the sciff proof
procedure will ﬁnd two diﬀerent solutions for fulﬁlling the expectations: one with
td/30,td/prime/30,tp/16and one with the same uniﬁcation for tdandtd/primebut having
tp/19. indeed, there are two diﬀerent executions of activity “photo” capable to
satisfy the third expectation.
let us now consider the same execution trace but containing the execution of
“deliver” at time 42. in this case, the history is evaluated as non conformant:
deadline about the delivery is not respected for the ﬁrst execution of activity “photo”,
and the ﬁrst expectation does not have any corresponding happened event.
the formal deﬁnition of fulﬁllment follows the above described intuition.
deﬁnition 6.2fulﬁllment .given an execution trace hap , a set of expectations
exp isfulﬁlled byhap if and only if for all (ground) terms p:
∀e(p)∈exp ⇒h(p)∈hap ∀en(p)∈exp ⇒h(p)/negationslash∈hap (7)
otherwise, exp isviolated byhap .
starting from the concept of fulﬁllment, it is now possible to give a formal deﬁ-
nition of conformance6.
deﬁnition 6.3conformance .given an execution trace hap and an interaction
speciﬁcation s,hap is conformant to sif and only if there exists an e-consistent
6for the sake of simplicity, we have omitted the goal, which is considered to be true.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 35
7abductive explanation exp such that deﬁnition 6.2 holds.
intuitively, conformance ensures that all positive expectations have indeed a cor-
responding happened event, and that no forbidden event occurs.
the conformance checking task is concretely performed by the sciff proof pro-
cedure, which has been proven sound and com plete w.r.t. its declarative semantics
[alberti et al. 2008]. the proof procedure is a transition system which extends the
well known iff proof-procedure [fung and kowalski 1997], by dealing with conﬁr-
mation of hypothesized expectations and w ith dynamic occurring happened events.
the latter feature makes sciff able to monitor the behaviour of interacting enti-
ties both a posteriori, by analyzing a complete execution trace of the interaction,
or at run-time, by considering occurred events as soon as they happen and waiting
if expectations ca n be still conﬁrmed.
the proof procedure has been wrapped into the socs-si [alberti et al. 2006]
tool, which is capable to accept diﬀerent e vent sources and to visualize step-by-
step the status of the proof, showing pending, fulﬁlled and violated expectations.
socs-si typically works in a run-time setting: it is able to dynamically acquire
happened events and, by exploiting the proof procedure, to raise violations as soon
as they happen. figure 13 shows a screenshot of the tool, dealing with the violation
of example 6.1.
fig. 13. screenshot of the socs-si tool
furthermore, sciff is being embedded into a prom plug-in called sciff-
checker, to the aim of classifying p rocess instance w.r.t. declarative sciff rules,
in the style of ltl checker.
7a set of expectations exp is e-consistent if and only if no event is expected to happen and not
to happen at the same time, i.e. if, for each (ground) term p:
{e(p),en(p)}/negationslash⊆exp
acm transactions on the web, vol. v, no. n, may 2009.36· montali, pesic, van der aalst, chesani, mello, storari
6.2.3 interoperability and detection of conﬂicts and dead activities in sciff.
the sciff proof procedure has been extende d to deal also with veriﬁcation of
properties (g- sciff [alberti et al. 2005]); the term “property” means in this con-
text a speciﬁc domain dependent property. the basic underlying idea of g- sciff
is to consider the desired property as the initial goal, and to apply fulﬁllment of
a positive expectation (see deﬁnition 6.2) by checking whether it already has a
matching happened event and, if it is not t he case, by “hypothesizing” it. hence,
it operates by simulating a sequence of intensional happened events which fulﬁll
the positive expectations and by checking that negative expectations are not vio-
lated. simulated events are intensional in the sense that they are partially speciﬁed
(i.e., they may contain variables). if the given property can be actually satisﬁed,
g-sciff also returns as proof a partially speciﬁed execution trace capable to fulﬁll
both the integrity constraints and the property.
the problem of detecting a conﬂict in a d ecserflow model can be then treated
as the problem of ﬁnding a successfull g- sciff derivation for the goal true, by
considering the integrity constraints which formalize the model. if it is not the
case, then there does not exist any possible execution trace for such a model, and
therefore it is a conﬂicting one.
example 6.4. let us consider the decserflow model of figure 10(b). its corre-
sponding (explicit) sciff formalization is given by the integrity constraints shown
in table ix, together with the following rules (for the sake of simplicity, we omit
the “init” constraint):
true →e(performed (photo ),tph). (8)
h(performed (print ),tp)→en(performed (deliver ),td). (9)
h(performed (deliver ),td)→en(performed (print ),tp). (10)
rule 8 is used to model the “existence” of at least one “photo” activity, whereas
rules 9 and 10 impose the “not coexistence” between “print” and “deliver”.
to verify if the model contains conﬂicts, we simply invoke g- sciff and check
if such a proof fails. the proof procedure starts by applying rule 8 (since its body
is true), generating an expectation abouth the execution of activity “photo” (at
any time). such an expectation becomes an happened event, which triggers in-
tegrity constraints g2aandg3a, generating two forward expectations about activ-
ities “print” and “deliver”. g- sciff selects now the expectation about printing
the photo, transforming it to an happened event. such an event matches with the
antecedent of rules g2cand (9). let us consider now the latter rule, which leads
to generate a negative expectation about the delivery; by explicitly showing only the
pending expectations (i.e., expectations wich still do not have a matching happened
event) the status of the proof is the following:
hap ={h(performed (photo ),tph),h(performed (print ),tp)∧tp>t ph}
exp ={e(performed (deliver ),td)∧td>t ph,en(performed (deliver ),td/prime)}
the set exp is not e-consistent: after time tph, the “deliver” activity is expected
to happen and not to happen at the same time. as a consequence, it is impossible
to fulﬁll the delivery expectation, and no successfull proof can be found by g- sciff.
this attests that actually a conﬂict is present in the model.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 37
detecting dead activities is a very simila r task. to verify whether an activity is
dead or not, it is suﬃcient to run g- sciff by giving as goal the execution of the
activity, at any time. failure of the proof means that it is impossible to perform
the activity under study, namely that it is actually a dead activity. from the
decserflow point of view, giving as goal the execution of an activity at any time
can be modeled by attaching to the activity a “1..*” cardinality constraint. hence,
proving that an activity is dead is the same as proving that the decserflow model,
augmented with such an existen ce formula, contains conﬂicts.
as an example, let us consider the decserflow diagram of figure 10(a) and the
task of verifying that activity “photo” is dead. by adding the “1..*” cardinality
constraint on the “photo” activity, we obtain (except for the “init” constraint on
activity “open order”) the model of figure 10(b), which has been proven to contain
conﬂicts in example 6.4; therefore, “photo” is a dead activity.
algorithm 1 summarizes how the discovery of dead activities can be addressed
by g- sciff.
input :sm,sciff formalization of the decserflow model m
output :d, the set of dead activities
d ← ∅ ;
foreach activity a∈m do
s/prime
m←s m∪existence (a);
ifcall(g- sciff( s/prime
m)) fails then
d ← d ∪ a;
end
end
algorithm 1 : detection of dead activities with g- sciff.
let us ﬁnally deal with the interoperability problem. there are many diﬀerent
deﬁnitions of interoperability [chopra and singh 2006; baldon i et al. 2006], which
mainly diﬀer by the “degree of similarity” they require between the local and the
global models. decserflow leads to the deﬁnition of a very weak interoperability:
as described in section 6.1.2 a local model is considered interoperable w.r.t. a global
one if the composition of the two models adm its at least one execution trace, i.e. if
the composition is conﬂicts free. it is clea r that such a veriﬁcation does not ensure
that the two models completely overlap, nor that if a local model is interoperable
w.r.t. a global model it will correctly co mply with any other local model which has
been proven interoperable (see figure 12). adopting a proof-theoretic approach
like the one of sciff leads to face this kind of weak interoperability by simply
composing the formalizations of models under study (i.e., adopting the “implicit”
approach, by joining the knowledge bases of each speciﬁc model) and using g- sciff
for testing conﬂict freeness on the composite model.
6.2.4 mining of decserflow speciﬁcations by using sciff as an intermediate
language. an important advantage of adopting a logic programming representation
(like sciff), relies in the possibility to apply on it all the algorithms and tech-
niques developed within the logic programming setting. more speciﬁcally, it makes
possible to apply inductive logic programming (ilp) [muggleton and de raedt
acm transactions on the web, vol. v, no. n, may 2009.38· montali, pesic, van der aalst, chesani, mello, storari
compliant
instances
decminersciff speci cationdecserflow 
modelmapping
sciff
checker
non compliant
instances
execution
traces
fig. 14. the “mining-checking” cycle, in which sciff is used as the source/target language and
decserflow as the representation notation.
1994] techniques for learning declarative models from examples and background
knowledge.
such a possibility has been concretely exploited by adapting the system icl
[de raedt and van laer 1995] to the problem of learning sciff constraints. in
[lamma et al. 2007], the authors cast the problem of mining declarative speciﬁca-
tions of processes as a learning from interpretation problem. in particular, they
consider the discriminant problem that is solved by icl, which starts by consider-
ing a set of positive and negative interpretations and aims to learn a clausal theory
that discriminates the two. in their case they assume to have a set of compliant and
non-compliant process ex ecution traces and ﬁnd a sciff theory that accurately
classiﬁes a new trace of the process as compliant or not.
this learning process has been extended in [lamma et al. 2007] to learn decser-
flow models. here, the mapping of decserflow onto sciff presented in this work
is exploited in the opposite way: some of the learned integrity constraints can be
in fact considered as the sciff representation of decserflow formulas, especially
if the language bias of the learning algorithm is opportunely tuned. in this context,
sciff is therefore used as an intermediat e language for learning decserflow mod-
els starting from a set of execution traces , previously labeled as compliant or not.
a tool called decminer is actually being implemented inside the prom framework
to cover all the phases of such a mining process.
6.2.5 the “mining-checking” cycle. having shown the feasibility of using the
sciff language as the core element of both a framework for conformance checking
and an algorithm to mine declarative process models, we may put together the two
settings to realize a “mining-checking” cycle, shown in figure 14.
from one side we may start from a set of positive and negative execution traces
and apply decminer to mine a sciff theory; such a theo ry can then be partially
rendered in a graphical way by applying the inverse mapping onto decserflow, and
used in conjunct with the sciff proof procedure to classi fy new execution traces.
from the other side, the modeler may design a decserflow diagram for classifying
a set of process execution traces; the actual classiﬁcation can be performed by
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 39
automatically mapping the diagram onto sciff and checking conformance of the
diﬀerent logs. the classiﬁed logs may be ﬁnally used as input of decminer, to
induce a new sciff theory (and thus a new decserflow model); if the language
bias is opportunely tuned, such a model could be noticeably diﬀerent from the
initial one, hence expressing the same classiﬁcation criterion by shifting the point
of view.
7. the framework in use
having introduced the main components of the service choreograpies framework
sketched in figure 7, an important issue is to evaluate its usability, for what con-
cerns both the decserflow language itse lf and performances of the veriﬁcation
tasks. we will try to brieﬂy assess the usability of the language by considering
the cognitive dimensions framework [green 1989], and then evaluate veriﬁcation
techniques by means of some benchmarks and summarizing current available tools.
7.1 usability of the language
cognitive dimensions [green 1989] are a useful tool to subjectively assess the us-
ability of languages and notations in an easy-to-comprehend way. they have been
applied to a broad range of programming languages and environments/editors, also
visual [green and petre 1996]. although a deep and extensive analysis of decser-
flow from the end-users viewpoint has n ot yet been carried out, we will try to
brieﬂy review its usability in terms of some cognitive dimensions (whose deﬁnition
is brieﬂy listed in table xi8).
closeness of mapping closeness of representation to domain
abstraction types and availability of abstraction mechanisms
consistency similar semantics are expressed in similar syntactic forms
hidden dependencies important links between entities are not visible
premature commitment constraints on the order of doing things
progressive evaluation work-to-date can be checked at any time
table xi. some cognitive dimensions.
the main strength of decserflow relies on the closeness of mapping between
the notation and the problem of capture choreography constraints: it provides
various expressive abstractions to constrain activities execution in many diﬀerent
ways, overcoming both over-constraining and over-speciﬁcation issues. decserflow
diagrams can range from classical procedural models (by only using the chain suc-
cession formula, which is the decserflow coun terpart of the sequence relationship
in procedural languages) to purely declarat ive/loosely-coupled ones (e.g. by impos-
ing constraints such as the responded presence, or by modeling the forbidding of
activities with negation formulas). such a ﬂexibility can be summarized by stating
that decserflow follows an open approach: interacting ser vices can freely behave
8seehttp://www.cl.cam.ac.uk/ ~afb21/cognitivedimensions/cdtutorial.pdf .
acm transactions on the web, vol. v, no. n, may 2009.40· montali, pesic, van der aalst, chesani, mello, storari
where not explicitly constrained9. in our view, such an approach is of key impor-
tance when modeling service choreographi es, which are open in nature: they should
impose only the strictly necessary rules of collaboration, allowing as much as pos-
sible diﬀerent concrete services to interoperate. this is a fundamental requirement
for satisfying the re-usability principle of service oriented architecture.
decserflow not only provides a plethora of diﬀerent abstractions: it is also ab-
straction tolerant , supporting the modeler in the deﬁnition of new constraint tem-
plates.
another valuable feature of decserflow is the consistency of its core formulas:
they have a representation which coherently combine only the few basic intuitive
concepts shown in table xii. for example , the representation of “succession”
relationships can be easily inferred: both semantics and representation of this kind
of formula is determined by combining/overlapping the semantics/representation
of the corresponding “response” and “precedence” ones.
concept
 notation
unary formula
 cardinality constraints a l´ a uml
relationship source
 •
negation
 /bardbl
temporal ordering
 !
normal
 −
relationship’s strength
 alternate
 =
chain
 ≡
succession representation
 response + precedence formulas, e.g.:
abab
table xii. basic decserflow graphical elements and their corresponding meaning.
even though decserflow combines simple concepts, rendered in a consistent way,
when the complexity of models increases their readability would quickly be com-
promised. the semantics of a decserflow model is determined as the conjunction
of its formulas: the user is driven to adopt a non-structured approach to modeling,
avoiding premature commitments ; but unfortunately, from the other side the overall
meaning tends to become unclear: because o f the interplay between the diﬀerent
formulas, many hidden dependencies among activities are implicitly introduced.
to better clarify the problem, let us co nsider the simple example of figure 15.
suppose that activity “a” is executed; this leads to forbid further executions of
“a” (due to the absence formula attached to it), but implicitly also to forbid the
execution of both “b” and “c”. actually, either by executing “b” or “c” activity “a”
should be eventually executed afterward s, but this would be impossible, because
it cannot be performed anymore. this situ ation arises from the interplay between
the “absence
 2” and “response” formulas, which introduces an hidden “negation
response” in the diagram (hidden relationships are shown in figure 15 as dashed
9note that, indeed, the “chain succession” expresses a “closed” relationship, because it completely
ﬁxes the sequencing of involved activities.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 41a bc0..1fig. 15. hidden dependencies in a simple decserflow model.
connections). in complex cas es, such an interplay could lead to produce diagrams
containing dead activities or even inconsistent models.
anyway, the possibility of mapping decserflow onto diﬀerent logic-based lan-
guages shown in this article comes in supp ort: decserflow mo dels can be veriﬁed
at any time to ensure consistency and disco ver dead activities, satisfying the im-
portant cognitive dimension of progressive evaluation . not only, the modeler can
also exploit the enactment tool in order to simulate interactions and see how the
state of the diﬀerent formulas evolves when executing activities.
as shown in figure 16, the enactment of the simple decserflow diagram shown
in figure 15 leads to blocking the execution of all activities after having performed
“a” once, giving an explicit feedback about the hidden dependencies of the model.
(a) initial state.
 (b) after having performed activity “a”.
fig. 16. enactment of the simple example shown in figure 15.
7.2 quantitative evaluation of the proposed techniques
in order to assess the usability of the framework, a key point is to evaluate perfor-
mances and scalability of the presented techniques. the performance issues related
to the ltl-based notation are presented in section 7.2.1, while section 7.2.2 dis-
cusses the performance of the sciff notation. we will mainly focus on static
veriﬁcation, i.e. conﬂict detection and discovery of dead activities (which are the
most expensive one for both approaches)10.
7.2.1 performance of the ltl-based notation of decserflow. when it comes
to the ltl-based notation of decserflow , performance is an issue related to the
complexity of models with a large number of constraints. due to the use of ltl
for constraint speciﬁcation, performanc e dramatically decrea ses when the number
and complexity of constraints in decserflow models rises.
10note that, for the sake of eﬃciency and in order to avoid some trivial loops, some of the sciff
rules are, in this case, transformed onto an equivalent representation, which simply leads to an
a-priori pruning of some useless choice-points
acm transactions on the web, vol. v, no. n, may 2009.42· montali, pesic, van der aalst, chesani, mello, storari
as described in section 6.1, an automaton is generated for a conjunction of
formulas of all constraints (i.e., the so-called “conjunction formula”) in an decser-
flow model. because this automaton repres ents exactly all correct executions of the
model, the automaton is used for the computer-supported execution and fully auto-
mated veriﬁcation of decserflow models based on ltl (cf. sections 6.1.1 and 6.1.2).
since the automata generated for an ltl formula is exponential in the size of the
formula [clarke et al. 1999; gerth et al. 1996; giannakopoulou and havelund 2001;
latvala 2003; demri and schnoebelen 1998; demri et al. 2006; flum and grohe
2006], the time needed for generating these automata becomes very long for big
lt formulas. this can cause various problems in the context of decserflow. for
example, generating such automaton for a decserflow model with many complex
constraints may be extremely slow.
there are two possible causes of this problem. first, the more constraints there
are in a model, the larger the “conjunction” formula for the model will be. sec-
ond, as shown in appendix a.2, various decserflow templates have diﬀerent ltl
formulas. for example, the ltl formula for the “succession” template is signiﬁ-
cantly more demanding from a computational point of view than the formula for
the “existence” template (both formalizations are presented in table v).
consider, for example, the global choreography model presented in figure 3 on
page 12. loading a new instance of this model in declare takes approximately
17 minutes on a computer with a pentium 4 processor of 3ghz and 1.49gb of
ram using microsoft windows xp profe ssional version 2002. if the“succession”
constraint between activities “album”, “photo”, “poster” and “deliver” is removed
from the original decserflow model, then generating the automaton for the “con-
junction” formula in declare on the same computer takes approximately 30
seconds . obviously, the size of the ltl formula for this triple-branched “succes-
sion” constraint dramatically increases the time to construct the automaton for
the “conjunction formula”. naturally, decserflow models with only few simple
constraints perform much better. for example, creating an automaton for the con-
junction of all constraints for the two local models shown in ﬁgures 4(a) and 4(b) on
page 14 takes approximately 200 milliseconds and100 milliseconds , respectively.
the eﬃciency problem described above ca n occur at several points. first, when
initiating a computer-supported execution of a decserflow model ( cf. section 6.1.1),
an automaton is generated for the “conjunction formula”, which can cause the ini-
tiation to take a long time. second, the same automaton is created during veriﬁca-
tion of single decserflow models and during interoperability veriﬁcation in order
to identify possible errors (cf. section 6.1 .2), which may cause t he error detection
to last too long. moreover, during veriﬁcation an automaton is generated for com-
binations of constraints in order to identify the cause of error, which can cause the
veriﬁcation to be even more time-consuming.
existence of errors (i.e., dead activities or conﬂicts) in a decserflow model can
signiﬁcantly decrease the time needed for the generation of the automaton for the
“conjunction” of all constraints because t he automaton then “represents” a model
with less possibilities (i.e., less possible executions). consider, for example, the
decserflow model for the global choreography shown in figure 3, for which it takes
approximately 17 minutes to create the automaton. when errors are introduced
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 43
in this model (e.g., dead activities shown in figures 10(a) and a conﬂict shown
in figure 10(b) on page 30), the performance increases. indeed, the automaton
for the “conjunction” formula is created within approximately 14 seconds and100
milliseconds for the two decserflow models shown in ﬁgures 10(a) and 10(b) on
page 30, respectively.
note that the ltl checker [van der aalst et al. 2005] (cf. section 6.1.3) does not
use the automata for conformance checki ng of a decserflow model in the context
of a real log, and, therefore, does not enc ounter the above described performance
problem.
7.2.2 performance of the sciff notation of decserflow. sciff and model
checking face the static veriﬁcation pr oblem in a complementary way: with ltl
the veriﬁcation consists in ﬁrst building a-priori the automaton of the entire dec-
serflow model, and then checking the reachability of a termination state on such
an automaton; sciff instead adopts a generative approach, i.e. it directly employs
model’s constraints trying to dynamically build a proof in a depth-ﬁrst way. such a
proof consists in an execution trace which satisﬁes all constraints (this ensure that
at least one possibility to execute the model actually exists). as a consequence,
also advantages and lacks are complementary:
—sciff scales very well in the number of constraints in the model, whereas ltl
suﬀers of the state-explosion problem. furthermore, sciff uses for veriﬁcation
only the strictly necessary rules. actually, consistency veriﬁcation typically de-
pends on the presence of existence (“existence
 n” and “exactly
 n” in particular)
and “mutual substitution” formulas, b ecause they directly impose the necessary
execution of some activities, triggering in turn consistency on relationships at-
tached to such activities, and so on. while ltl builds the whole automaton
without taking into account such a peculiar feature, sciff starts by considering
just these kind of formulas (figure 17 sketches how sciff deals with inconsis-
tency of the model shown in figure 10(b)). the extreme case is the one in which
a model does not contain any “existence” nor “mutual substitution” formula,
like in the running example shown in figure 3: sciff immediately evaluates
it as conﬂicts free, independently of its s ize, because the void execution trace is
accepted.
—from the other side, a distinguishing feature of ltl is its capability of handling
“inﬁnite” systems, namely models which contain loops11; being sciff a gen-
erative approach, it is instead not able to treat looping models, because it loops
as well. a naive solution to this problem is to change sciff’s search strategy
in the space of execution tr aces, by e.g. adopting a bounded iterative deepening
approach. obviously, a bounded search strategy would undermine completeness;
as a consequence, we will study the insertion of loops-detection algorithms in the
proof procedure (note that this problem h as been deeply investigated in the ﬁeld
of logic programming [shen et al. 2003]). it is worth noting that such a problem
only aﬀects sciff when used in a generative m anner: when performing con-
formance veriﬁcation of execution traces , reasoning is actua lly driven by events
11such kind of decserflow models are evaluated as inconsistent, because they do not eventually
terminate (and this would be inconvenient for a choreography or a process model).
acm transactions on the web, vol. v, no. n, may 2009.44· montali, pesic, van der aalst, chesani, mello, storari
poster albumprint
deliver
receivepaycharge1..*registeropen ordersuccession
succession
succession
precedence
responded existencenot co- existence photo
fig. 17. consistency veriﬁcation of the diagram shown in figure 10(b) with sciff: only the
subset of formulas “triggered” by the existence of activity “photo” is used; presence of conﬂicts is
detected in 350 milliseconds .
formulas/activities
 time (sec.)
1
 3
 0.00
2
 7
 0.01
3
 15
 0.01
4
 31
 0.02
5
 63
 0.04
6
 127
 0.10
7
 255
 0.34
8
 511
 1.04
9
 1023
 3.64
10
 2047
 14.01
11
 4095
 56.85
12
 8191
 249.77
13
 16383
 1100.26
14
 32767
 6194.99
a1
a3a2
1..*a5a4
a7a6benchmark with 7 activities/formulas
fig. 18. results of the branching response inconsistency benchmark.
contained in the log, and therefore sciff will not loop.
to study the scalability of sciff when discovering conﬂicts/dead activities, we
have tested it on some simple yet relevant benchmarks, which involve diﬀerent
formulas. all benchmarks deal with inco nsistent models, to the aim of testing
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 45
time (sec.)
k
 n=1
 n=2
 n=3
1
0.00
 0.01
 0.02
2
0.00
 0.02
 0.10
3
0.00
 0.03
 0.35
4
0.00
 0.05
 1.12
5
0.00
 0.1
 3.17
6
0.00
 0.16
 7.96
7
0.00
 0.28
 17.54
8
0.01
 0.45
 40.03
9
0.00
 0.74
 76.65
10
 0.01
 1.11
 140.95
11
 0.00
 1.74
 279.48
12
 0.00
 2.58
 460.38
13
 0.01
 3.76
 754.50
time (sec.)
k
 n=1
 n=2
 n=3
14
 0.01
 5.47
 1263.34
15
 0.01
 7.65
 2184.68
16
 0.01
 10.62
 3010.70
17
 0.01
 14.53
 >1h
18
 0.01
 19.58
 >1h
19
 0.01
 26.16
 >1h
20
 0.01
 34.73
 >1h
21
 0.01
 45.28
 >1h
22
 0.02
 58.43
 >1h
23
 0.02
 75.37
 >1h
24
 0.02
 93.94
 >1h
25
 0.02
 116.44
 >1h
26
 0.02
 140.60
 >1h
a1n..*...ak0..n-1a2
fig. 19. results of the alternate response inconsistency benchmark.
sciff in the worst case: to prove that a model contains a conﬂict, sciff has to
explore the entire search space. experiments have been performed on a macbook
intel coreduo 2 ghz machine.
the ﬁrst benchmark aims to evaluate the scalability of the approach when “branch-
ing responses” are used, i.e. diﬀerent alt ernatives are present in the model. the
structure of the model is the following (figure 18 graphically shows the benchmark
in case of 7 activities). one activity, namely a1, is expected to be executed at least
once. after a1, either one between two activities should be executed, and so on.
“branching responses” follow one another until a “frontier” is reached; all the activ-
ities belonging to this “frontier” have an outgoing “ne gation precedence” formula
w.r.t. a1, and therefore no path can be execu ted without leading to a conﬂict.
figure 18 summarizes sciff’s behaviour when the number of activities (which
is the same as the number of formul as, except from the “existence
 1” on the ﬁrst
activity) increases. such experiments attests that sciff scales very well: it is
able to detect inconsistency of a model containing 4095 formulas in less than one
minute.
the two next benchmarks aim at evaluate sciff’s behaviour respectively in case
of “alternate” and “chain response” formulas, especially when they are combined
with existence formulas which impose more executions of the same activity. the
acm transactions on the web, vol. v, no. n, may 2009.46· montali, pesic, van der aalst, chesani, mello, storari
normal
time (sec.)
k
 n=1
 n=2
 n=3
1
0.00
 0.01
 0.03
2
0.00
 0.02
 0.35
3
0.00
 0.09
 4.04
4
0.00
 0.34
 27.12
5
0.01
 1.13
 134.77
6
0.00
 3.02
 616.94
7
0.00
 7.63
 2733.64
8
0.00
 17.10
 >1h
9
0.01
 37.09
 >1h
10
 0.01
 71.73
 >1h
11
 0.01
 137.03
 >1h
12
 0.00
 256.48
 >1h
13
 0.01
 756.34
 >1h
14
 0.01
 1460.47
 >1h
15
 0.01
 2332.65
 >1h
simplified
time (sec.)
k
 n=1
 n=2
 n=3
1
0.00
 0.01
 0.04
2
0.00
 0.02
 0.07
3
0.00
 0.03
 0.15
4
0.00
 0.05
 0.24
5
0.10
 0.07
 0.39
6
0.00
 0.09
 0.60
7
0.01
 0.13
 0.89
8
0.00
 0.17
 1.27
9
0.01
 0.21
 1.81
10
 0.01
 0.28
 2.38
11
 0.00
 0.33
 3.18
12
 0.00
 0.41
 4.25
13
 0.00
 0.53
 5.55
14
 0.01
 0.65
 7.24
15
 0.00
 0.78
 9.36
fig. 20. results of the chain response inconsistency benchmark.
second (third resp.) benchmark impose at least nexecutions of an activity, which
is source of a sequence of kactivities connected by “al ternate” (“chain” resp.)
“response” formulas; the last activity of the sequence is subject to an absence
formula which imposes at most n−1 executions (the model is therefore inconsistent,
because also such last activity should be performed at least ntimes).
actually, discovering conﬂicts in alternate/chain response formulas when only one
execution of the source activity is imposed reduces to the case of simple responses.
this is attested also by sciff: both for “alternate” (fig. 19) and “chain response”
(ﬁg. 20) formulas, when n= 1 it answers almost immediately. when nincreases,
veriﬁcation becomes more diﬃcult; for “alternate responses” (but similarly also
for “chain” formulas), this is due to the fact that more executions of the source
activity trigger the interposition part of the formula, imposing and propagating a
huge amount of temporal constrains.
finally, note that performances in case of “chain” formulas are slower because
its formalization in sciff, which contains a time-constrained forbidding of all
events, is rather diﬃcult to be handled (s ee section 5). if we restrict ourselves
to the basic decserflow core formulas, for performing consistency veriﬁcation we
can adopt, without loosing generality, a simpliﬁed version of “chain response”,
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 47
which states that the target should happen at the immediate next integer w.r.t. the
source execution time12. by adopting such a simpliﬁcation, a dramatic speed-up
of veriﬁcation times is experienced (s ee figure 20 to have an overview about a
comparison between the two formalizations).
summarizing, sciff is able to verify in acceptable times even complex dec-
serflow models. its performances beco me slower when the model contains both
existence formulas with an high repeatition value and many “strict” relationships
(such as “chain responses”). however, it is rather uncommon to ﬁnd choreography
models in which a certain activity is a-priori constrained by an existence formula
to be executed many times; furthermore, w hen the modeler adopts many diﬀerent
strict relationships in the same diagram, she is breaking decserflow philosophy,
which is to develop loosely-coupled choreographies: the right choice would probably
be to adopt a more classical procedural language (like e.g. bpmn).
the interested reader is referred to [montali et al. 2008] for further experimen-
tations/benchmarks, together with a comparison with explicit and symbolic model
checking. the results obtained in [montali et al. 2008] conﬁrm that sciff is
clearly superior to explicit model checking when statically verifying decserflow
models, and that it outperforms symbolic model checking in many cases. also in
these benchmarks, the global trend is that sciff scales very well in the number of
constraints, while experiences more diﬃcul ties when existence formulas with high
repeatition values are introduced in the m odel. however, establishing a precise re-
lationship between the size of a decserflow model and the performance of sciff
is not a trivial task: as we have seen in the presented benchmarks, the performance
is aﬀected not only by the number of constraints, but also by the interplay between
such constraints. for example, sciff answers immediately when testing conﬂict-
freedom on models containing no existence constraint, independently from the size
of the model.
sciff veriﬁcation times are even faster when performing conformance checking
of execution traces; just to give an intuiti on about performances, we have exploited
it to analyze real execution traces of a c linical screening process [chesani et al.
2007]: a sciff speciﬁcation containing 12 rules (with branches and constrains on
both execution times and content data) has been tested on 1950 execution traces,
ranging from 1 to 18 events, i n approximately 12 minutes.
finally, the interested reader is referred to [lamma et al. 2007; chesani et al.
2009] for a preliminary quantitative evaluation related to mining decserflow spec-
iﬁcation from labeled execution traces, using sciff as an intermediate format.
7.3 tool support
as far as now, diﬀerent tools can be exploit ed to verify decserflow models; some of
them are well-established and some others are still under testing. one of our main
ongoing objectives is to integrate such tools in order to cover all the diﬀerent parts
of the framework for the speciﬁcation and veriﬁcation of service choreographies
depicted in figure 7.
some of the tools have been developed as part of prom. prom is an open source
12when times are not quantitatively constrained, we can map the concept of “next state” to the
one of “next integer”.
acm transactions on the web, vol. v, no. n, may 2009.48· montali, pesic, van der aalst, chesani, mello, storari
framework (under the common public license, cpl) for process mining, avail-
able at http://www.processmining.org ; it is plug-able, i.e., people can plug-in
new pieces of functionality. beside a plethora of mining techniques, prom oﬀers a
wide range of plug-ins related to model transformations and model analysis (e.g.,
veriﬁcation of soundness, analysis of deadlocks, invariants, reductions, etc.).
figure 21 sketches current availables to ols together with their relationships. a
brief description of them follows.
socs-sisciff proof procedurepromdeclare
ltl
sciff
speci cationmaps to
maps toltl checker
decminersciff checker
interactiondecserflow
extended
fig. 21. tools for the speciﬁcation and veriﬁcation of decserflow models.
7.3.1 declare. declare [pesic et al. 2007] is the main tool for editing
and enacting decserflow models. it is mainly composed by two parts: an editor,
supporting the user both in the development of new graphical models as well as in
the deﬁnition of new declarative constraints (by specifying their graphical appealing
and the underlying ltl formalization); an enactment module, capable to concretely
execute decserflow models giving a step-by -step feedback about constraints state.
the editor also provides support for checking the correctness of designed models, by
identifying conﬂicts and discovering dead activities. declare can be downloaded
from http://is.tm.tue.nl/staff/mpesic/declare.htm .
7.3.2 ltl checker. the ltl checker [van der aalst et al. 2005] is a prom plug-
in for performing process analysis by exploiting ltl. it oﬀers an environment to
provide parameters for predeﬁned param eterized ltl expressions and check these
expressions (as properties related to act ivities, data, human resources and time)
with respect to some event log in mxml [van dongen and van der aalst 2005] for-
mat. currently, we do not yet provide a d irect connection bet ween the decserflow
editor (tool declare) and the prom ltl checker. although it is possible to ex-
port decserflow templates, constraints and models to ltl checker and check con-
formance in prom, it is not yet possible to visualize violations on the decserflow ed-
itor in declare. such a connection is matter of ongoing work. the ltl checker
can be downloaded together with prom from http://www.processmining.org .
7.3.3 sciff proof procedure. thesciff proof procedure, downloadable from
http://lia.deis.unibo.it/research/sciff/ , is a chr-based implementation
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 49
[alberti et al. 2005] of sciff’s operational semantics13. its main application
is to verify conformance of a set of happened events w.r.t. a sciff interaction
speciﬁcation, by checking whether positive (negative resp.) expectations indeed
have (not have resp.) a corresponding matching happened event. by setting some
options, sciff can also be conﬁgured to work in a generative manner, which
is the basis for performing conﬂicts detect ion and discovery of dead activities in
decserflow models. an additional module containing useful predicates for ver-
ifying decserflow models, as well as the complete set of sciff projects which
have been used to quantitatively evaluate the framework, can be downloaded from
http://lia.deis.unibo.it/research/climb/ . we are currently developing a
graphical editor which supports extended decserflow models (i.e., models con-
taining complex branching and time-annotated relationships) and automatically
translates them onto sciff speciﬁcations.
7.3.4 socs-si. socs-si [alberti et al. 2006] wraps the sciff proof procedure
into a java-based tool, to the aim of exploiting conformance veriﬁcation at run-time.
in particular, it can be interfaced with diﬀerent event sources and supports a step-
by-step visualization of the proof status, showing pending, fulﬁlled and violated
expectations (see figure 6.1). violations are raised as soon as they happen, because
temporal aspects (deadlines in particular) are taken into account. to download the
software, visit http://www.lia.deis.unibo.it/research/socs_si/ .
7.3.5 sciff-checker. conformance veriﬁcation of pa st execution traces w.r.t. a
sciff speciﬁcation has been integrated inside prom as an analysis plug-in, which
resembles the ltl checker. in this application, called sciff-checker [chesani
et al. 2008], all the peculiar features of the sciff language are extensively ap-
plied to classify execution logs by considering not only causal relationships among
activities, but also their execution times, originators and involved content data.
the tool provides diﬀerent template rul es (included the decserflow ones) whose
activity types, originators and execution times can be constrained and specialized
by the user through a gui. results obtained by applying classiﬁcation can be then
directly exploited by the decminer plug-in, supporting the “mining-checking” cycle
sketched in section 6.2.5. sciff-checker can be downloaded as part of the latest
version of prom.
7.3.6 decminer. decminer is a prom plug-in which implements the mining al-
gorithm described in [lamma et al. 2007]. its purpose is to mine a declarative
constraint-based speciﬁcation startin g from a set of mxml execution traces pre-
viously labeled as conformant or not. such a speciﬁcation is composed by sciff
rules. because the structure of rules which can be mined by the algorithm can be
conﬁgured by the user, decminer restricts to sciff rules that map decserflow
formulas. as a consequence, it is also able to apply the mapping presented in this
work in the opposite way, automatically obtaining a graphical decserflow model
as result of the mining process. the plug-in can be downloaded as part of the
latest version of prom. the interested reader is referred to [chesani et al. 2009] for
13the proof procedure has been implemented in sicstus prolog, available from http://www.sics.
se/sicstus/ .
acm transactions on the web, vol. v, no. n, may 2009.50· montali, pesic, van der aalst, chesani, mello, storari
a description of the plug-in and its experimentation.
8. related work
in this work we propose a declarative decserflow language for the speciﬁcation of
service ﬂows. compared to the related research in the area, the most important
added value of decserflow is in the comprehensiveness : to our knowledge decser-
flow is the only language which, besides for (1) the declarative modelling of service
interaction protocols, can be used for (2) design-time veriﬁcation (i.e., detection of
contradictory constraints), (2) checking interoperability of services, (3) preventing
deadlocks, (4) monitoring service executi ons and (5) learning service models from
past executions. many other approaches deal with each of these areas, but, to our
knowledge, the work presented in this paper is the only one that tackles all of them.
in the remainder of this section we will descri be the most interesting related works:
each paragraph describes th e related work in one area and explains the added value
of decserflow.
process modelling, enactment and veriﬁcation is the focus in the ﬁeld of work-
ﬂow technology [georgakopoulos et al. 1995]. most process modelling languages
(e.g., petri nets, bpmn [white 2006], ws-bpel [andrews et al. 2003]) are highly
procedural. petri nets have been used for the modelling of workﬂows [van der aalst
and van hee 2002; chrzastowski-wachtel 2003; dumas et al. 2005] but also for the
orchestration of web services [mecella et al. 2002]. another example of procedu-
ral languages for modelling and veriﬁcation of web services are message sequence
charts (mscs), which explicitly specify the ordering of message exchange between
services [foster et al. 2003] . the procedural nature of such modelling languages is
an obstacle in developing choreographies of autonomous web services because pos-
sible orderings of message exchange between services must be explicitly included in
the model [zaha et al. 2006]. the declarative ﬂavor of decserflow is more suitable
for modelling interactions of autonomous services because the possible execution
orderings of activities are implicitly derived from constraints, as all orderings that
satisfy these constraints. furthermore, it is worth noting that even if process mod-
eling languages such as ws-bpel and bpmn provide support for data, such a
perspective is often lost when they are translated to an underlying formal lan-
guage. the mapping of decserflow to sciff presented in this work enables the
possibility of maintaining data-related and quantitative time aspects also at the
formal level. even if the central focus is usually on the activities and their ﬂow
dependencies, such additional perspectives are very important in settings like ser-
vice discovery and contracting. for example, quantitative time constraints could
be exploited by the user to express that she is looking for an e-shop able to deliver
the ordered items within a maximum time span; since sciff provides support for
reasoning about quantitative time constraints, such a requirement can be used to
select only the services whose behavioral i nterface respect it. the interested reader
may refer to [alberti et al. 2007; alberti et al. 2009] for the application of sciff
in the context of service discovery and contracting.
beside decserflow, many other declarative languages, where possible orderings
are implicitly derived from a set of constraints (i.e., rules), have been proposed in
order to solve this problem. in [zaha et al. 2006], zaha et al. propose a declar-
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 51
ative language called let’s dance for modeling interactions of web services. this
language uses computation tree logic (ctl) for ﬂexible modeling of message ex-
change between services. a straight-forward graphical notation is used to represent
patterns in message exchange, while π-calculus [milner et al. 1992] captures the ex-
ecution semantics [decker et al. 2006]. a restricted version of ltl is used in [hall´ e
and villemaire 2009] and translated into x query for monitoring of web services.
ltl is also used in [deutsch et al. 2006] for veriﬁcation of correctness properties
of service compositions. the spin model checker [holzmann 2003] is used in [fu
et al. 2005] to verify ltl properties of service conversations. decserflow is also
a declarative language, which uses ltl and sciff mapping for formal speciﬁca-
tion of service interactions. moreover, to the best of our knowledge, decserflow
is the only declarative language for modelling and monitoring of web services that
also enables veriﬁcation, interoperability check, model learning and deadlock-free
execution.
the importance of monitoring web servi ces has been raised by many researchers.
moreover, monitoring is addressed with several approaches: business rules [lazovik
et al. 2004], ws-bpel [baresi et al. 2004], event calculus [mahbub and spanoudakis
2004], ws-agreement [ludwig et al. 2004], etc. advanced conformance checking
techniques described in [rozinat and van der aalst 2006] are used in [van der
aalst et al. 2005] and implemented in the prom framework [van der aalst et al.
2007]; this approach has been applied to soap messages generated from oracle
bpel. the work presented in this paper diﬀerers from these approaches because
it presents one declarative language that can be used for monitoring, modelling,
design-time veriﬁcation, deadlock-free execution, interoperability check and model
learning. in [rouached et al. 2006] the authors use an extension of the event
calculus (ec) of kowalski and sergot ([kowalski and sergot 1986]) to declaratively
model event based requirements speciﬁcations. the choice of ec is motivated by
both practical and formal needs, that are shared by the sciff approach. in
particular, in contrast to pure state-transition representations, both the ec and
sciff representations include an explicit time structure and are very close to
most event-based speci ﬁcations. however, sciff deals with explicit time by using
suitable clp constraints on ﬁnite domains, while they use a temporal formalism
based on event calculus. we plan to deeply investigate the relations between
sciff and ec, and possibly to integrate the approaches in future work.
besides for monitoring of web services (“run-time conformance checking”), we
also propose decserflow for design-time conformance , i.e., detecting errors in mod-
els before enactment. both mappings o f decserflow enable a simple mechanism
that checks at design-time the correcteness of a model and the compatibility of
diﬀerent services. inheritance notions [van der aalst and basten 2002] are ex-
plored in the context of workﬂow management and implemented in woﬂan [verbeek
et al. 2001]. petri nets are used for design -time conformance an d compatibility in
[martens 2005a; 2005b; massuthe et al. 2005; schlingloﬀ et al. 2005]. for example,
[martens 2005b] focuses on the problem of consistency between executable and ab-
stract processes while [massuthe et al. 2005] presents an approach where for a given
composite service the required other servi ces are generated. also related is [foster
et al. 2003], were message sequence charts (mscs) are compiled into the “finite
acm transactions on the web, vol. v, no. n, may 2009.52· montali, pesic, van der aalst, chesani, mello, storari
state process” notation to describe and rea son about web service compositions. to
the best of our knowledge, the work presented in this article is the ﬁrst attempt
to automatically verify declarative service models. automatic service composition
has been addressed in owl-s [owl services coalition 2003] which looks how
atomic services interact with the real world, the roman model approach [berardi
et al. 2005] that uses ﬁnite state machines, and mealy machine [bultan et al. 2003]
that focuses on message exchange between services. compatibility of synchronous
communication via message exchange in web services is investigated in [bordeaux
et al. 2004; beyer et al. 2005; benatallah et al. 2006; ponnekanti and fox 2004],
while decserflow allows as ynchronous communication and focuses on the process
perspective, rather than message exchan ge. decserflow contributes to this area
are with the veriﬁcation techniques described in section 6, which make it possible
to easily discover errors and incompatibility in declarative models . however, while
the cited approaches focus on automatic composition of services (i.e., automatic
choreography generation from participating services), decserflow assumes that all
relevant process models of the composition are available and then veriﬁes their
interoperability.
in the research literature it is possible to ﬁnd several deﬁnitions of interoperabil-
ity, and there is not a complete agreement abo ut its exactly meaning. for example,
in [baldoni et al. 2005b] the authors state that interoperability aims to check if a
service, described by its behavioural int erface, can play a given role within a chore-
ography. in their approach however, both choreography and behavioural interface
are described from a procedural viewpoin t, and a complete speciﬁcation of all the
allowed interactions is given. sciff has been used to address this type of inter-
operability in [alberti et al. 2006]. a diﬀerent notion of interoperability is given in
[chopra and singh 2006], where the authors represent global choreographies and
local services in terms of state transition systems (and their conjunction as the
product of the two transition systems). they deﬁne a notion of interoperability as
a set of feature that the resulting transition system should guarantee. although
their idea of interoperability is in some sense “broader” that the one given in [bal-
doni et al. 2005b; alberti et al. 2006], it is still related to the procedural aspects
of the interaction between the services. the interoperability notion discussed in
this work instead is more related to assuring that declarative constraints speciﬁed
in terms of decserflow are indeed satisﬁed , given the decserflow representation
of both a global choreography and of a se rvice. decserflow in fact focus on the
declarative aspects and features of a global choreographies, leaving the interaction
unconstrained as much as possible.
another issue tackled in this work is the problem of mining decserflow models
starting from a set of service execution traces. process mining [van der aalst
and weijters 2004; van der aalst et al. 2003] extracts knowledge from event logs
(e.g., process models [van der aalst et al. 2004; agrawal et al. 1998; cook and wolf
1998; gaaloul et al. 2004; gaaloul and godart 2005; herbst 2000] or social networks
[van der aalst and song 2004]). in particular, agrawal et al. [1998] introduced the
idea of applying process mining to workﬂow management. the authors propose
an approach for inducing a process representation in the form of a directed graph
encoding the precedence relationships. van der aalst et al. [2004] presents the α-
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 53
algorithm for mining petri nets from data and identiﬁes for which class of models the
approach is guaranteed to work. the α-algorithm is based on the discovery of binary
relations in the log, such as the “follows” relation. in [van dongen and van der aalst
2004] the authors describe an algorithm which derives causal dependencies between
activities and use them for constructing instance graphs, presented in terms of
event-driven process chains (epcs). a recent work of greco et al. [2006] describe
a mining technique where a process model is induced in the form of a disjunction
of special graphs called workﬂow schemas. the sciff-based approach sketched
in section 6.2.4 diﬀers from all of these works. first, sciff uses a declarative
representation, which can be rendered as a decserflow diagram by applying an
inverse mapping. moreover, sciff learns from both compliant and non compliant
traces (rather than from compliant traces only), and is able to model and reason
upon data, by exploiting either the underlying constraints solver or the prolog
inference engine. various levels of web se rvices mining (web service operations,
interactions, and workﬂows) are proposed in [gombotz and dustdar 2005; dustdar
et al. 2004]. our approach ﬁts in their framework and shows that web-services
mining is indeed possible.
as pointed out in [baldoni et al. 2005a], service oriented architectures and multi
agent systems share many issues and features, and the problem of representing
global interactions and of verifying th em has been tackled also in the mas ﬁeld.
in particular, it is possible to ﬁnd in the literature two complementary approaches,
as in the case of choreographies: approaches with aim to exactly specify how the
interaction protocol shoul d be executed by the interacting agents (such as for ex-
ample auml [bauer et al. 2001]), and approaches which consider mas as open
societies and model interaction protocols by declaratively constraining the possi-
ble interactions. for example, in [fornara and colombetti 2002] the semantics of
communicative acts is deﬁned by means of transitions on a ﬁnite state automaton
which describes the concept of commitment; in [yolum and singh 2002], the au-
thors adopts a variant of event calculus to commitment-based protocols, where
commitments evolve in relation to events and ﬂuents and the semantics of mes-
sages is given in terms of predicates on such events and ﬂuents (to describe how
messages aﬀect commitments). recently, si ngh et al. have applied the concept of
commitment-based protocols in the conte xt of the service oriented architecture
and business process management, by addr essing the problem of business process
adaptability [desai et al. 2006] and of pro tocols compositio n [mallya et al. 2005].
sciff was originally thought for dealing with social interaction in open mas, and
the mapping proposed in this work further attests that the mas and soc settings
are closely related and ca n beneﬁt from each other.
9. conclusions and future works
in this work, we have made a ﬁrst step towards a framework capable to tackle
both speciﬁcation and veriﬁcation of service choreographies. by claiming that a
choreography is inherently declarative, we have presented the decserflow graphi-
cal language for modeling service choreographies. decserflow adopts an open and
declarative approach, specifying choreographies by means of the minimal set of con-
straints which should be satisﬁed by the interacting entities to correctly collaborate.
acm transactions on the web, vol. v, no. n, may 2009.54· montali, pesic, van der aalst, chesani, mello, storari
thus, the approach respects the autonomous nature of participating services and
does not lead to over-specifying nor over-constraining them.
furthermore, we have concretely show n how the decserflow concepts can be
mapped onto diﬀerent underlying logic-based formalisms, namely ltl and sciff
(a framework based on abductive logic programming). after having introduced the
complete mapping onto both settings, we have described how the related model-
checking and proof-theoretic techniques can be fruitfully applied in order to enact
decserflow models and to perform a variety of diﬀerent veriﬁcation tasks, such as
conformance checking, static veriﬁcation of conﬂicts and dead activities, interoper-
ability between global and local models, mining of decserflow models from a set
of compliant and non compliant histories.
we have also motivated the feasibility of the approach by brieﬂy reviewing the
decserflow language in terms of some cognitive dimensions, and by quantitatively
evaluating performances and scalability of the veriﬁcation techniques (especially
for what concerns static veriﬁcation, which is the most diﬃcult one for sciff).
obviously, the empirical evaluation by using the cognitive dimensions is only a ﬁrst
step towards the assessment of decserflow’s usability; we will therefore extend such
an evaluation by conducting a comprehensive user study covering both the use of
decserflow to specify choreographies and the exploitation of the toolset to validate
them.
the possibility of carrying out a suitable user study is conditioned by the presence
of a stable prototypical implementation integrating the various related tool (and re-
lying on prom and declare as glue environments). for the time being, the two
underlying decserflow formalisms are used independently; we are currently inves-
tigating their relationships, to the aim of really exploiting their advantages and of
realizing a uniﬁed framework for choreographies speciﬁcation and veriﬁcation. such
an investigation will also be helpful to understand some theoretical relationships
between ltl and sciff.
even if decserflow is proposed as comple mentary w.r.t. classical procedural ap-
proaches, an interesting open issue concerns how these diﬀerent approaches could
beneﬁt from each other. relevant research issues arise when trying to shift from one
proposal to another. from one side (from procedural languages to decserflow),
such a shift would enable the possibility to abstract procedural models by focusing
on their core constraints and, even more important, to make the diﬀerent veriﬁ-
cation techniques described in this paper applicable also to procedural models14.
from the other side (from decserflow to pr ocedural languages), decserflow mod-
els could be used as core of a top-down methodology aimed at deriving executable
procedural speciﬁcations from declarative constraints; this methodology could be
applied, for instance, to derive skeletons of ws-bpel behavioural interfaces start-
ing from a declarative choreography speci ﬁed in decserflow. another choice would
be to opt for an integration between declarative and procedural approaches, to the
aim of obtaining semi-open speciﬁcation which suitably mediate between the two.
a ﬁrst investigation in this direction has been made in [pesic 2008], where a lay-
14a possible solution to this problem could be to simulate and collect in a mxml log diﬀerent
positive and negative executions of the procedural model, and then try to mine a decserflow
model from the generated traces.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 55
ered approach is proposed, in which non-atomic activities belonging to a declarative
model can be speciﬁed in terms of a yawl15process and vice-versa. an hybrid
approach, in which declarative and procedural speciﬁcations co-exist at the same
level, will be matter of future research. it is worth noting that, in this case, the
integration poses foundational issues, because a clear semantics must be deﬁned
to specify how a closed approach and an open approach (equipped with negative
constraints) aﬀect each other, how possible conﬂicts should be resolved, and so on.
other ongoing works concern the extension of the decserflow expressiveness.
currently, decserflow templates can relate only to service activities while sciff
and the prom ltl checker deal also with conformance checking against proper-
ties related to activities, time and data. this limitation of decserflow can be
eliminated by extending the l anguage with such concepts.
extension with time perspective would enable decserflow to oﬀer templates
that involve deadlines. for example, as in troduced in section 5 .4, the “response”
template can be extended to specify the rul e that activity “b” has to be executed no
later that 5 days after activity “a”. to be able to support the semantics of deadlines,
ltl can be replaced by the real-time temporal logic - a logic that can be translated
into timed automata [bouajjani et al. 1996]. further on, timed automata can be
used for execution and veriﬁcation of mode ls containing time perspective. thanks
to the possibility of exploiting the underlying clp solver to adopt a temporal point
algebra, sciff is instead directly able to capture such an extension. an ongoing
issue concerns the use of sciff as an enactment module for extended models; the
basic idea is to exploit the detection of dead activities but by considering also a
partial execution trace (which represents the already executed activities inside the
process instance): in this way, sciff can be used to discover, step-by-step, which
activities cannot be executed without undermining model’s consistency.
data elements would enrich decserflow and allow for specifying more complex
templates. consider, for example, the photo service described in section 3. al-
though it is generally possible to deliver ordered products to a home address or
to the shop, one can imagine that large format posters can only be picked up per-
sonally. in this case, a special constraint would specify that if the size of a poster
is “large” then type of delivery cannot be “home”. however, incorporating data
perspective in decserflow is a complex ta sk. data elements introduce many issues
that need to be solved: are templates divided into ones that involve activities and
ones that involve data, or can templates be mixed (one template involving activities
and data)? how do we deal with the data scope (e.g., data has certain value before,
after or between events, etc.)? another co mplex issue is to ﬁnd the right graphical
representation of such templates dealing with data.
investigating the possibility to extend decserflow with time and data will add
much to the semantics of decserflow and make better use of sciff and its ca-
pability to express both perspectives. by adopting the implicit decserflow for-
malization shown in section 5.6, information about content data and the involved
knowledge could be seamlessly expressed inside the speciﬁc knowledge base of the
formalized model.
finally, an extended formalization capable to deal also with non-atomic activities
15http://www.yawl-system.com/newyawl
acm transactions on the web, vol. v, no. n, may 2009.56· montali, pesic, van der aalst, chesani, mello, storari
and more complex relationships, taking in to account also excep tions and compen-
sation issues, will be matter of future works.
acknowledgment
this work has been partially supported by the prin 2005 project “speciﬁcation
and veriﬁcation of agent interaction protocols” and by the firb project “to-
cai.it”. we would like to thank marco gavanelli, evelina lamma, marco alberti,
paolo torroni, fabrizio riguzzi and all colleagues that took part to the socs
project. we also thank the anonymous reviewers for their valuable suggestions and
helpful comments which helped to improve this work.
references
agrawal, r. ,gunopulos, d. ,and leymann, f. 1998. mining process models from workﬂow
logs. in sixth international conference on extending database technology . 469–483.
alberti, m. ,cattafi, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,montali, m. ,
and torroni, p. 2009. integrating abductive logic programming and description logics in a
dynamic contracting architecture. in proceedings of the ieee 7th international conference on
web services (icws 2009) .
alberti, m. ,chesani, f. ,gavanelli, m. ,and lamma, e. 2005. the chr-based implementation
of a system for generation and conﬁrmation of hypotheses. in 19th workshop on (constraint)
logic programming, ulm, germany, february 21-23, 2005 , a. wolf, t. w. fr¨ uhwirth, and
m. meister, eds. ulmer informatik-berichte, vol. 2005-01. universit¨ at ulm, germany, 111–122.
alberti, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,montali, m. ,and torroni,
p.2007. web service contracting: speciﬁcation and reasoning with sciff. in proceedings of
the 4th european semantic web conference (eswc’07) , e. franconi, m. kifer, and w. may,
eds. lecture notes in artiﬁcial intelligence, vol. 4519. springer verlag, 68–83.
alberti, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,and torroni, p. 2005.
security protocols veriﬁcation in abductive logic programming: a case study. in proc. of
esaw’05 . lncs, vol. 3963. springer, 106–124.
alberti, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,and torroni, p. 2006.
compliance veriﬁcation of agent interaction: a logic-based software tool. applied artiﬁcial
intelligence 20, 2-4, 133–157.
alberti, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,and torroni, p. 2008.
veriﬁable agent interaction in abductive logic programming: the sciff framework. acm
transactions on computational logic 9, 4, 1–43.
alberti, m. ,gavanelli, m. ,lamma, e. ,chesani, f. ,mello, p. ,and montali, m. 2006. an
abductive framework for a-priori veriﬁcation of web services. in proceedings of the 8th inter-
national acm sigplan conference on principles and practice of declarative programming,
july 10-12, 2006, venice, italy , a. bossi and m. j. maher, eds. acm, 39–50.
andrews, t. ,curbera, f. ,dholakia, h. ,goland, y. ,klein, j. ,leymann, f. ,liu, k. ,
roller, d. ,smith, d. ,thatte, s. ,trickovic, i. ,and weerawarana, s. 2003. business
process execution language for web services, version 1.1. standards proposal by bea sys-
tems, international business machines corporation, and microsoft corporation.
baldoni, m. ,baroglio, c. ,martelli, a. ,and patti, v. 2006. a priori conformance veriﬁca-
tion for guaranteeing interoperability in open environments. in service-oriented computing -
icsoc 2006, 4th international conference, chicago, il, usa, december 4-7, 2006, pro ceed-
ings, a. dan and w. lamersdorf, eds. lecture notes in computer science, vol. 4294. springer,
339–351.
baldoni, m. ,baroglio, c. ,martelli, a. ,patti, v. ,and schifanella, c. 2005a. verifying
the conformance of web services to global interaction protocols: a ﬁrst step. in international
workshop on web services and formal methods, ws-fm 2005, versailles, france, septem-
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 57
ber 1-3, 2005, pro ceedings , m. bravetti, l. kloul, and g. zavattaro, eds. lecture notes in
computer science, vol. 3670. springer, 257–271.
baldoni, m. ,baroglio, c. ,martelli, a. ,patti, v. ,and schifanella, c. 2005b. verifying the
conformance of web services to global interaction protocols: a ﬁrst step. in epew/ws-fm,
m. bravetti, l. kloul, and g. zavattaro, eds. formal techniques for computer systems and
business processes, european performance engineering workshop, epew 2005 and inter-
national workshop on web services and formal methods, ws-fm 2005, versailles, france,
september 1-3, 2005, pro ceedings 3670 .
baresi, l. ,ghezzi, c. ,and guinea, s. 2004. smart monitors for composed services. in icsoc
’04: proceedings of the 2nd international conference on service oriented computing . acm
press, new york, ny, usa, 193–202.
barros, a. ,dumas, m. ,and oaks, p. 2005. a critical overview of the web services choreography
description language (ws-cdl). bptrends .
bauer, b. ,m¨uller, j. p. ,and odell, j. 2001. agent uml: a formalism for specifying multiagent
software systems. in first international workshop, aose 2000 on agent-oriented software
engineering . springer-verlag, 91–103.
belwood, t. ,cl´ement, l. ,ehnebuske, d. ,hately, a. ,hondo, m. ,husband, y. l. ,
januszewski, k. ,lee, s. ,mckee, b. ,munter, j. ,and von riegen, c. 2000. uddi version
3.0. http://uddi.org/pubs/uddi
 v3.htm.
benatallah, b. ,casati, f. ,and toumani, f. 2006. representing, analysing and managing web
service protocols. data knowl. eng. 58, 3, 327–357.
berardi, d. ,calvanese, d. ,giacomo, g. d. ,lenzerini, m. ,and mecella, m. 2005. auto-
matic service composition based on behavioral descriptions. international journal of cooper-
ative information systems 14, 4, 333–376.
beyer, d. ,chakrabarti, a. ,and henzinger, t. 2005. web service interfaces. in proceedings
of the 14th international conference on world wide web . 148–159.
bordeaux, l. ,sala¨un, g. ,berardi, d. ,and mecella, m. 2004. when are two web services
compatible? in proceedings of the 5th international workshop on technologies for e-services
(tes 2004) , m. shan, u. dayal, and m. hsu, eds. 15–28.
bouajjani, a. ,lakhnech, y. ,and yovine, s. 1996. model-checking for extended timed tem-
poral logics. in ftrtft ’96: proceedings of the 4th international symposium on formal
techniques in real-time and fault-tolerant systems . springer-verlag, london, uk, 306–326.
box, d. ,ehnebuske, d. ,kakivaya, g. ,layman, a. ,mendelsohn, n. ,nielsen, h. ,
thatte, s. ,and winer, d. 2000. simple object access protocol (soap) 1.1.
http://www.w3.org/tr/soap.
bultan, t. ,fu, x. ,hull, r. ,and su, j. 2003. conversation speciﬁcation: a new approach to de-
sign and analysis of e-service composition. in www ’03: proceedings of the 12th international
conference on world wide web . acm press, new york, ny, usa, 403–410.
chesani, f. ,lamma, e. ,mello, p. ,montali, m. ,riguzzi, f. ,and storari, s. 2009. exploiting
inductive logic programming techniques for declarative process mining. lncs transactions on
petri nets and other models of concurrency (topnoc), special issue on concurrency in
process-aware information systems .
chesani, f. ,mello, p. ,montali, m. ,riguzzi, f. ,sebastianis, m. ,and storari, s. 2008.
checking compliance of execution traces to business rules: an approach based on logic program-
ming. in 4th workshop on business process intelligence (bpi 2008) , m. castellanos, a. k. a.
de medeiros, j. mendling, and b. weber, eds. lnbip. springer verlag. to appear.
chesani, f. ,montali, m. ,mello, p. ,and storari, s. 2007. testing careﬂow process execution
conformance by translating a graphical language to computational logic. in proceedings of the
11th conference on artiﬁcial intelligence in medicine (aime 07) , a. abu-hanna, r. bellazzi,
and j. hunter, eds. lnai, vol. to appear. springer-verlag.
chopra, a. k. and singh, m. p. 2006. producing compliant interactions: conformance, cover-
age, and interoperability. in declarative agent languages and technologies iv, 4th interna-
tional workshop, dalt 2006, hakodate, japan, may 8, 2006, selected, revised and invited
papers . lecture notes in computer science, vol. 4327. springer, 1–15.
acm transactions on the web, vol. v, no. n, may 2009.58· montali, pesic, van der aalst, chesani, mello, storari
christensen, e. ,curbera, f. ,meredith, g. ,and weerawarana, s. 2001. web services
description language (wsdl) 1.1. http://www.w3.org/tr/wsdl.
chrzastowski-wachtel, p. 2003. a top-down petri net based approach for dynamic work-
ﬂow modeling. in international conference on business process management (bpm 2003) ,
w. van der aalst, a. ter hofstede, and m. weske, eds. vol. 2678. 336–353.
clarke, e. ,grumberg, o. ,and peled, d. 1999. model checking . the mit press, cambridge,
massachusetts and london, uk.
cook, j. and wolf, a. 1998. discovering models of software processes from event-based data.
acm transactions on software engineering and methodology 7, 3, 215–249.
de raedt, l. and van laer, w. 1995. inductive constraint logic. in proceedings of the 6th
conference on algorithmic learning theory . lnai, vol. 997. springer verlag.
decker, g. ,zaha, j. ,and dumas, m. 2006. execution semantics for service choreographies.
inproceedings of the 3rd workshop on web services and formal method (ws-fm 2006) ,
m. bravetti, m. n´ u˜nez, and g. zavattaro, eds. lecture notes in computer science, vol. 4184.
springer-verlag, 163–177.
demri, s. ,laroussinie, f. ,and schnoebelen, p. 2006. a parametric analysis of the state-
explosion problem in model checking. journal of computer and system sciences 72, 4,
547–575.
demri, s. and schnoebelen, p. 1998. the complexity of propositional linear temporal logics
in simple cases. in proceedings of 15th annual symposium on theoretical aspects of computer
science (stacs 98) , g. goos, j. hartmanis, and j. leeuwen, eds. lecture notes in computer
science, vol. 1373/1998. springer-verlag, paris, france, 61–72.
denecker, m. and schreye, d. d. 1998. sldnfa: an abductive procedure for abductive logic
programs. journal of logic programming 34, 2, 111–167.
desai, n. ,chopra, a. k. ,and singh, m. p. 2006. business process adaptations via protocols.
in2006 ieee international conference on services computing (scc 2006), 18-22 september
2006, chicago, illinois, usa . ieee computer society, 103–110.
deutsch, a. ,sui, l. ,vianu, v. ,and zhou, d. 2006. veriﬁcation of communicating data-driven
web services. in pods ’06: proceedings of the twenty-ﬁfth acm sigmod-sigact-sigart
symposium on principles of database systems . acm, new york, ny, usa, 90–99.
dumas, m. ,van der aalst, w. ,and ter hofstede, a. 2005. process-aware information
systems: bridging people and software through process technology .
dustdar, s. ,gombotz, r. ,and baina, k. 2004. web services interaction mining. technical
report tuv-1841-2004-16, information systems institute, vienna university of technology,
wien, austria.
flum, j. and grohe, m. 2006. parameterized complexity theory . texts in theoretical computer
science. an eatcs series. springer-verlag.
fornara, n. and colombetti, m. 2002. operational speciﬁcation of a commitment-based agent
communication language. c. castelfranchi and w. lewis johnson, eds. bologna, italy, 535–542.
foster, h. ,uchitel, s. ,magee, j. ,and kramer, j. 2003. model-based veriﬁcation of web
service composition. in proceedings of 18th ieee international conference on automated
software engineering (ase) . montreal, canada, 152–161.
fu, x. ,bultan, t. ,and su, j. 2005. synchronizability of conversations among web services.
ieee transactions on software engineering 31, 12, 1042–1055. member-tevﬁk bultan and
senior member-jianwen su.
fung, t. h. and kowalski, r. a. 1997. the iff proof procedure for abductive logic program-
ming. journal of logic programming 33, 2 (nov.), 151–165.
gaaloul, w. ,bhiri, s. ,and godart, c. 2004. discovering workﬂow transactional behavior
from event-based log. in on the move to meaningful internet systems 2004: coopis, doa,
and odbase: otm confederated international conferences, coopis, doa, and odbase
2004, r. meersman, z. tari, w. aalst, c. bussler, and a. g. et al., eds. vol. 3290. 3–18.
gaaloul, w. and godart, c. 2005. mining workﬂow recovery from event based logs. in busi-
ness process management (bpm 2005) , w. aalst, b. benatallah, f. casati, and f. curbera,
eds. vol. 3649. 169–185.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 59
georgakopoulos, d. ,hornick, m. ,and sheth, a. 1995. an overview of workﬂow manage-
ment: from process modeling to workﬂow automation infrastructure. distributed and parallel
databases 3 , 119–153.
gerth, r. ,peled, d. ,vardi, m. ,and wolper, p. 1996. simple on-the-fly automatic veri-
ﬁcation of linear temporal logic. in proceedings of the fifteenth ifip wg6.1 international
symposium on protocol speciﬁcation, testing and veriﬁcation xv . chapman & hall, ltd.,
london, uk, 3–18.
giannakopoulou, d. and havelund, k. 2001. automata-based veriﬁcation of temporal proper-
ties on running programs. in ase ’01: proceedings of the 16th ieee international conference
on automated software engineering . ieee computer society, washington, dc, usa, 412.
gombotz, r. and dustdar, s. 2005. on web services mining. in first international workshop
on business process intelligence (bpi’05) , m. castellanos and t. weijters, eds. nancy, france,
58–70.
greco, g. ,guzzo, a. ,pontieri, l. ,and sacc `a, d. 2006. discovering expressive process models
by clustering log traces. ieee transactions on knowledge and data engineering 18, 8, 1010–
1027.
green, t. r. g. 1989. cognitive dimensions of notations. people and computers v , 443–460.
green, t. r. g. and petre, m. 1996. usab ility analysis of visual programming environments:
a ’cognitive dimensions’ framework. journal of visual languages and computing 7, 131–174.
hall ´e, s. and villemaire, r. 2009. runtime monitoring of web service choreographies using
streaming xml. in (to appear in) procedings of to the 24th annual acm symposium on
applied computing (acm sac 2009) .
herbst, j. 2000. a machine learning approach to workﬂow management. in proceedings 11th
european conference on machine learning . vol. 1810. 183–194.
holzmann, g. 2003. the spin model checker: primer and reference manual. addison-wesley,
boston, massachusetts, usa.
jaffar, j. and maher, m. 1994. constraint logic programming: a survey. journal of logic
programming 19-20 , 503–582.
kakas, a. c. ,kowalski, r. a. ,and toni, f. 1993. abductive logic programming. journal of
logic and computation 2, 6, 719–770.
kakas, a. c. and mancarella, p. 1990. on the relation between truth maintenance and
abduction. in proceedings of the 1st paciﬁc rim international conference on artiﬁcial intel-
ligence, pricai-90, nagoya, japan , t. fukumura, ed. 438–443.
kavantzas, n. ,burdett, d. ,ritzinger, g. ,fletcher, t. ,and lafon, y. 2004. web services
choreography description language, version 1.0. w3c working draft 17-12-04.
kowalski, r. a. and sergot, m. 1986. a logic-based calculus of events. new gen. comput. 4, 1,
67–95.
lamma, e. ,mello, p. ,montali, m. ,riguzzi, f. ,and storari, s. 2007. inducing declarative
logic-based models from labeled traces. in proceedings of the 5th international conference on
business process management (bpm 2007) , g. alonso, p. dadam, and m. rosemann, eds.
lncs, vol. 4714. springer, 344–359.
lamma, e. ,mello, p. ,riguzzi, f. ,and storari, s. 2007. applying inductive logic programming
to process mining. in proceedings of the 17th international conference on inductive logic
programming . springer.
latvala, t. 2003. eﬃcient model checking of safety properties. in proceedings of the 10th
spin workshop on model checking of software . lecture notes in computer science, vol.
2648. springer verlag, berlin, 74–88.
lazovik, a. ,aiello, m. ,and papazoglou, m. 2004. associating assertions with business
processes and monitoring their execution. in icsoc ’04: proceedings of the 2nd international
conference on service oriented computing . acm press, new york, ny, usa, 94–104.
lloyd, j. w. 1987. foundations of logic programming , 2nd extended ed.
ludwig, h. ,dan, a. ,and kearney, r. 2004. crona: an architecture and library for cre-
ation and monitoring of ws-agreements. in icsoc ’04: proceedings of the 2nd international
conference on service oriented computing . acm press, new york, ny, usa, 65–74.
acm transactions on the web, vol. v, no. n, may 2009.60· montali, pesic, van der aalst, chesani, mello, storari
mahbub, k. and spanoudakis, g. 2004. a framework for requirents monitoring of service
based systems. in icsoc ’04: proceedings of the 2nd international conference on service
oriented computing . acm press, new york, ny, usa, 84–93.
mallya, a. u. ,desai, n. ,chopra, a. k. ,and singh, m. p. 2005. owl-p: owl for protocol
and processes. in 4rd international joint conference on autonomous agents and multiagent
systems (aamas 2005), july 25-29, 2005, utrecht, the netherlands , f. dignum, v. dignum,
s. koenig, s. kraus, m. p. singh, and m. wooldridge, eds. acm, 139–140.
martens, a. 2005a. analyzing web service based business processes. in proceedings of the 8th
international conference on fundamental approaches to software engineering (fase 2005) ,
m. cerioli, ed. vol. 3442. 19–33.
martens, a. 2005b. consistency between executable and abstract processes. in proceedings
of international ieee conference on e-technology, e-commerce, and e-services (eee’05) .
ieee computer society press, 60–67.
massuthe, p. ,reisig, w. ,and schmidt, k. 2005. an operating guideline approach to the
soa. in proceedings of the 2nd south-east european workshop on formal methods 2005
(seefm05) . ohrid, republic of macedonia.
mecella, m. ,parisi-presicce, f. ,and pernici, b. 2002. modeling e-service orchestration
through petri nets. in proceedings of the third international workshop on technologies for
e-services . vol. 2644. 38–47.
milner, r. ,parrow, j. ,and walker, d. 1992. a calculus of mobile processes. information
and computation 100, 1, 1–40.
montali, m. ,alberti, m. ,chesani, f. ,gavanelli, m. ,lamma, e. ,mello, p. ,and torroni,
p.2008. veriﬁcation from declarative speciﬁcations using logic programming. in 24th inter-
national conference on logic programming (iclp) , m. g. d. l. banda and e. pontelli, eds.
number 5366 in lecture notes in computer science. springer verlag, udine, italy, 440–454.
muggleton, s. and de raedt, l. 1994. inductive logic programming: theory and methods. j.
logic program. 19/20 , 629–679.
owl services coalition . 2003. owl-s: semantic markup for web services .
pesic, m. 2008. constraint-based workﬂow management systems: shifting controls to users.
ph.d. thesis, beta research school for operations management and logistics, eindhoven.
pesic, m. ,schonenberg, h. ,and van der aalst, w. 2007. declare: full support for loosely-
structured processes. in 11th ieee international enterprise distributed object computing
conference (edoc 2007), 15-19 october 2007, annapolis, maryland, usa . ieee computer
society, 287–300.
ponnekanti, s. and fox, a. 2004. interoperability among independently evolving web services.
inmiddleware ’04: proceedings of the 5th acm/ifip/usenix international conference on
middleware . springer-verlag new york, inc., new york, ny, usa, 331–351.
reisig, w. and rozenberg, g. , eds. 1998. lectures on petri nets i: basic models . vol. 1491.
rouached, m. ,perrin, o. ,and godart, c. 2006. towards formal veriﬁcation of web service
composition. in 4th international conference on business process management . lncs, vol.
4102. springer, 257–273.
rozinat, a. and van der aalst, w. 2006. conformance testing: measuring the fit and ap-
propriateness of event logs and process models. in bpm 2005 workshops (workshop on
business process intelligence) , c. bussler et al., ed. vol. 3812. 163–176.
schlingloff, b. ,martens, a. ,and schmidt, k. 2005. modeling and model checking web
services. electronic notes in theoretical computer science: issue on logic and communication
in multi-agent systems 126 , 3–26.
shen, y.-d. ,you, j.-h. ,yuan, l.-y. ,shen, s. s. p. ,and yang, q. 2003. a dynamic approach
to characterizing termination of general logic programs. acm transactions on computational
logic 4, 4, 417–430.
singh, m. p. 2000. a social semantics for agent communication languages. in issues in agent
communication , f. dignum and m. greaves, eds. lecture notes in computer science, vol.
1916. springer, 31–45.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 61
van der aalst, w. and basten, t. 2002. inheritance of workﬂows: an approach to tackling
problems related to change. theoretical computer science 270, 1-2, 125–203.
van der aalst, w. ,de beer, h. ,and van dongen, b. 2005. process mining and veriﬁcation
of properties: an approach based on temporal logic. in on the move to meaningful internet
systems 2005: coopis, doa, and odbase: otm confederated international conferences,
coopis, doa, and odbase 2005 , r. meersman and z. t. et al., eds. vol. 3760. 130–147.
van der aalst, w. ,dumas, m. ,ouyang, c. ,rozinat, a. ,and verbeek, h. 2005. choreogra-
phy conformance checking: an approach based on bpel and petri nets (extended version).
bpm center report bpm-05-25, bpmcenter.org, to appear in acm transactions on internet
technology, special issue on middleware for service-oriented architectures.
van der aalst, w. ,dumas, m. ,and ter hofstede, a. 2003. web service composition lan-
guages: old wine in new bottles? in proceeding of the 29th euromicro conference: new
waves in system architecture , g. chroust and c. hofer, eds. ieee computer society, los
alamitos, ca, 298–305.
van der aalst, w. ,dumas, m. ,ter hofstede, a. ,russell, n. ,verbeek, h. m. w. ,and
wohed, p. 2005. life after bpel? in international workshop on web services and formal
methods, ws-fm 2005, versailles, france, september 1-3, 2005, pro ceedings , m. bravetti,
l. kloul, and g. zavattaro, eds. lecture notes in computer science, vol. 3670. springer,
35–50.
van der aalst, w. and song, m. 2004. mining social networks: uncovering interaction patterns
in business processes. in international conference on business process management (bpm
2004) , j. desel, b. pernici, and m. weske, eds. vol. 3080. 244–260.
van der aalst, w. ,van dongen, b. ,g¨unther, c. ,mans, r. ,de medeiros, a. a. ,rozinat,
a.,rubin, v. ,song, m. ,verbeek, h. ,and weijters, a. 2007. prom 4.0: comprehensive
support for real process analysis. in application and theory of petri nets and other models
of concurrency (icatpn 2007) , j. kleijn and a. yakovlev, eds. vol. 4546. 484–494.
van der aalst, w. ,van dongen, b. ,herbst, j. ,maruster, l. ,schimm, g. ,and weijters,
a.2003. workﬂow mining: a survey of issues and approaches. data and knowledge engi-
neering 47, 2, 237–267.
van der aalst, w. and van hee, k. 2002. workﬂow management: models, methods, and
systems . mit press, cambridge, ma.
van der aalst, w. and weijters, a. , eds. 2004. process mining . special issue of computers
in industry, volume 53, number 3. elsevier science publishers, amsterdam.
van der aalst, w. ,weijters, a. ,and maruster, l. 2004. workﬂow mining: discovering pro-
cess models from event logs. ieee transactions on knowledge and data engineering 16, 9,
1128–1142.
van der aalst, w. m. p. and pesic, m. 2006. decserﬂow: towards a truly declarative service
ﬂow language. in web services and formal methods, third international workshop, ws-
fm 2006 vienna, austria, september 8-9, 2006, pro ceedings , m. bravetti, m. n´ u˜nez, and
g. zavattaro, eds. lecture notes in computer science, vol. 4184. springer, 1–23.
van dongen, b. and van der aalst, w. 2005. a meta model for process mining data. in pro-
ceedings of the caise’05 works hops (emoi-interop workshop) , j. casto and e. teniente,
eds. vol. 2. feup, porto, portugal, 309–320.
van dongen, b. f. and van der aalst, w. m. p. 2004. multi-phase process mining: build-
ing instance graphs. in conceptual modeling - er 2004, 23rd international conference on
conceptual modeling . lncs, vol. 3288. springer, 362–376.
verbeek, h. ,basten, t. ,and van der aalst, w. 2001. diagnosing workﬂow processes using
woﬂan. the computer journal 44, 4, 246–279.
vilain, m. ,kautz, h. ,and van beek, p. 1990. constraint propagation algorithms for temporal
reasoning: a revised report. 373–381.
white, s. a. 2006. business process modeling notation speciﬁcation 1.0. tech. rep., omg.
yolum, p. and singh, m. 2002. flexible protocol speciﬁcation and execution: applying event
calculus planning using commitments. in the first international joint conference on au-
acm transactions on the web, vol. v, no. n, may 2009.62· montali, pesic, van der aalst, chesani, mello, storari
tonomous agents & multiagent systems, aamas 2002, july 15-19, 2002, bologna, italy,
proceedings . 527–534.
zaha, j. ,barros, a. ,dumas, m. ,and hofstede, a. 2006. let’s dance: a language for
service behavior modeling. in proceedings of the 14th international conference on cooperative
information systems (coopis 2006) , r. meersman and z. tari, eds. lecture notes in computer
science, vol. 4275. springer-verlag, 145–162.
zaha, j. ,barros, a. ,dumas, m. ,and ter hofstede, a. 2006. let’s dance: a language for
service behavior modeling. qut eprints 4468, faculty of information technology, queensland
university of technology.
zaha, j. ,dumas, m. ,hofstede, a. ,barros, a. ,and dekker, g. 2006. service interaction
modeling: bridging global and local views. qut eprints 4032, faculty of information tech-
nology, queensland university of technology.
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 63
a. decserflow templates and mappings onto ltl and sciff
decserflow is proposed as a language containing more than twenty initial tem-
plates. note that templates can be easily changed, added or removed in/from
decserflow. the remainder of this sectio n is organized as follows. in section a.1
we present decserflow templates. sect ions a.2 and a.3 decserflow show the
mappings onto ltl and onto sciff, respectively.
a.1 decserflow templates
decserflow templates currently involve only activities, i.e., templates specify re-
lations between service activities. templates can involve an arbitrary number of
activities, but for the sake of simplicity we present only unary and binary tem-
plates. unary templates are presented in table xiii. these templates specify the
possible number of executions of an activity and are graphically represented as a
cardinality constraint above the activity. the ﬁrst group of templates (i.e., the “ex-
istence
 n” templates) specify the minimal numb er of executions of an activity. the
second group of templates (i.e., the “absence
 n” templates) speciﬁes the maximal
number of executions of an activity. finally, the third group of templates (i.e., the
“exactly
 n” templates) speciﬁes the exact number of executions of an activity.
table xiv presents binary templates for specifying relations between two activ-
ities (“a” and “b”). these templates are graphically represented as special lines
(type of the line, symbols and line edges, etc...) between the two activities. the
ﬁrst two templates (i.e., “responded
 existence” and “coexistence”) do not take into
account the order in which “a” and “b” are executed. the second group of tem-
plates (i.e., “response”, “precedence” an d “succession”) takes into account the or-
der in which the two activities are executed in the most general way. the third
group of templates (i.e., “alternate
 response”, “alternate
 precedence” and “alter-
nate
 succession”) takes the order of activities into account and impose interposition,
i.e., one activity has to be executed between each two executions of the other activ-
ity. the fourth group of templates (i.e., “chain
 response”, “chain
 precedence” and
“chain
 succession”) speciﬁes the most strict ordering relations by requiring that the
two activities are executed immediately next to each other.
binary templates that specify “negativ e” relations are presented in table xv.
each of these templates presents a negat ion of a unary template presented in ta-
ble xiv. the graphical representation is similar to the one for the corresponding
template from table xiv – it has an extra negation symbol in the middle of the
line. note that there exists equivalence between some of the “negation” templates,
i.e., some templates have identical semantics . template “responded
 absence” can
be omitted because it is equivalent to the “not
 coexistence” template. templates
“neg
 response” and “neg
 precedence” can be omitted because they are equivalent
with the “neg
 succession” template. sim ilarly, templates “neg
 chain
 response” and
“neg
 chain
 precedence” are equivalent to the template “neg
 chain
 succession” and
they can, therefore, be omitted too.
a.2 decserflow templates: ltl mapping
the semantics of decserflow templates c an easily be speciﬁed in ltl. this section
presents ltl mappings (i.e., ltl formulas) for each of the decserflow templates
acm transactions on the web, vol. v, no. n, may 2009.64· montali, pesic, van der aalst, chesani, mello, storari
table xiii. decserflow existence templates.
name
 representation
 description
existence
 1(a)
a1..*
a is executed at least once.
existence
 2(a)
2..*
a
a is executed at least two times.
existence
 3(a)
3..*
a
a is executed at least three times.
...
 ...
 ...
existence
 n(n, a)
n..*
a
 a is executed at leas n times.
absence (a)
0
a
a is never executed.
absence
 2(a)
0..1
a
a is executed at most once.
absence
 3(na)
0..2
a
 a is executed at most two times.
...
 ...
 ...
absence
 n+1(a)
0..n
a
a is executed at most n times.
exactly
 1(a)
1
a
a is executed exactly once.
exactly
 2(a)
2
a
 a is executed exactly two times.
...
 ...
 ...
exactly
 n(a)
n
a
a is executed exactly n times.
presented in section a.1. t able xvi presents ltl speciﬁcations for (unary) exis-
tence templates form table xiii. tables xvii and xviii present ltl speciﬁcations
for binary templates from tables xiv and xv, respectively. note that tables xvii
and xviii contain two additional formulas that do not appear in the tables xiv
and xv. the “interposition” formula in table xvii is used in in templates “al-
ternate
 response” and “alternate
 precedence” and it speciﬁes that there is at least
one “b” between every two executions of “ a”. opposite to this, formula “nega-
tive
interposition” from table xvii speciﬁes that there cannot be any b between
every two executions of a. the “negative
 interposition” formula is used in templates
“neg
 alternate
 response” and “neg
 alternate
 precedence”.
table xvi show that new ltl formula has to be speciﬁed for each of the unary
templates, i.e., it is not possible to deﬁne general ltl formulas with a parameterized
number of executions of an activity.
a.3 decserflow templates: sciff mapping
the semantics of decserflow templa tes can also be speciﬁed in terms of sciff.
this section presents the sciff mapping for each of the decserflow templates
presented in section a.1. table xix presents sciff speciﬁcations for (unary)
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 65
table xiv. decserflow relation templates.
name
 representation
 description
responded
 existence (a, b)
ab
if a is executed, then b has to be
executed before or after a.
coexistence (a, b)
ab
if a is executed, then b has to be
executed before or after a and vice
versa.
response (a, b)
ab
every a is eventually followed by at
least one b.
precedence (a, b)
ab
b can be executed only after a is
executed.
succession (a, b)
ab
b is response of a and a is prece-
dence of b.
alternate
 response (a, b)
ab
b is response of a and there has to
be at least one b between every two
as.
alternate
 precedence (a, b)
ba
a is precedence of b and there has
to be at least one a between every
two bs.
alternate
 succession (a, b)
ab
b is alternate response of a and a
is alternate precedence of b.
chain
 response (a, b)
ab
if a is executed then b is executed
next (immediately after a).
chain
 precedence (a, b)
ba
b can be executed only if a was pre-
viously executed (immediately be-
fore b).
chain
 succession (a, b)
ab
a and b are always executed next
to each other, i.e., ﬁrst a and then
immediately b.
existence templates shown in table xiii. tables xx and xxi present the sciff
speciﬁcations for binary templates from tables xiv and xv, respectively.
unlike ltl, that requires a separate speciﬁcation of each of the unary templates
(cf. table xvi), the sciff formalism can specify th ese templates in a general
way (see section 5.6). ta ble xix presents the sciff template speciﬁcations for
unary existence templates (cf. table xiii ) with two parameters: (1) parameter
“a” represents an activity and (2) par ameter “n” the number of executions.
sciff speciﬁcation of binary templates in tables xix contain parameters “a”
that represents an activity and an additional parameter to represent moments in
time “ t” when “a” is executed. parameters “ ti” are “free”, i.e., they do not
have to be concretely speciﬁed but are required by the sciff formal speciﬁcation
language to denote (and, eventually, explicitly constrain) the diﬀerent execution
times. note that, e.g., in the “existence
 n” template “ ti” is not an information
related to the template formula, but is used to specify that “a” is executed multiple
times (i.e., ti>t i−1allows to diﬀerentiate the execution of two activities “a”).
sciff speciﬁcation of binary templates in tables xx and xxi contain param-
eters “a” and “b” that represent activitie s and additional parameters to represent
moments in time: (1) “ ta” when “a” is executed and (2) “ tb” when “b” is exe-
acm transactions on the web, vol. v, no. n, may 2009.66· montali, pesic, van der aalst, chesani, mello, storari
table xv. decserflow negation templates.
name
 representation
 description
responded
 absence (a, b)
ab
if a is executed, then b can never
be executed.
not
coexistence (a, b)
ab
either a or b are executed, but not
both.
neg
response (a, b)
ab
 b can never be executed after a.
neg
precedence (a, b)
ab
b cannot be executed if a is exe-
cuted before.
neg
succession (a, b)
ab
b is not
 response of a and a is
not
precedence of b.
neg
alt
response (a, b)
ab
there cannot be any b between ev-
ery two as.
neg
alt
precedence (a, b)
ba
there cannot be any a between ev-
ery two bs.
neg
alt
succession (a, b)
ab
there cannot be any b between ev-
ery two as and there cannot be any
a between every two bs.
neg
chain
 response (a, b)
ab
b cannot be the next (immediately)
after a.
neg
chain
 precedence (a, b)
ba
a cannot be previous (immedi-
ately) before b.
neg
chain
 succession (a, b)
ab
a and b cannot be executed in a
sequence.
table xvi. decserflow existence templates in ltl.
name
 ltl formula
existence
 1(a)
3(a)
existence
 2(a)
3(a∧/circlecopyrt(existence (a)))
existence
 3(a)
3(a∧/circlecopyrt(existence (a)))
...
 ...
existence
 n(n, a)
3(a∧/circlecopyrt(existence n−(a)))
absence (a)
¬(existence 1(a))
absence
 2(a)
¬existence (a)
absence
 3(a)
¬existence (a)
...
 ...
absence
 n+1(a)
 ¬existence n+(a)
exactly
 1(a)
existence (a)∧absence (a)
exactly
 2(a)
existence (a)∧absence (a)
...
 ...
exactly
 n(a)
existence n(a)∧absence n+(a)
cuted. just like in table xix, parameters “ ta” and “ tb” are “free”, i.e., they do
not have to be concretely speciﬁed (they co uld be substitued by the classical prolog
anonymous variable “
 ”) . note that, e.g., in the “responded
 existence” template
“ta” and “ tb” are not used for the template sem antics, while in the template
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 67
table xvii. decserflow relation templates in ltl.
name
 ltl formula
responded
 existence (a, b)
3(a)⇒3(b)
coexistence (a, b)
3(a)⇔3(b)
response (a, b)
2(a⇒3(b))
precedence (a, b)
3(b)⇒((¬b)/unionsqa)
succession (a, b)
response (a, b)∧precedence (a, b)
alternate
 response (a, b)
response (a, b)∧2(a⇒/circlecopyrt(precedence (b, a)))
alternate
 precedence (a, b)
precedence (a, b)∧2(b⇒/circlecopyrt(precedence (a, b)))
alternate
 succession (a, b)
alternate
 response (a, b)∧
alternate
 precedence (a, b)
chain
 response (a, b)
2(a⇒/circlecopyrt(b))
chain
 precedence (a, b)
precedence (a, b)∧2(/circlecopyrt(b)⇒a)
chain
 succession (a, b)
chain
 response (a, b)∧chain
 precedence (a, b)
interposition (a, b)
2(a→/circlecopyrt(precedence (b, a)
table xviii. decserflow negation templates in ltl.
name
 ltl formula
responded
 absence (a, b)
3(a)⇒¬(3(b))
not
coexistence (a, b)
neg
existence
 response (a, b)∧
neg
existence
 response (b, a)
neg
response (a, b)
2(a⇒¬(3(b)))
neg
precedence (a, b)
2(3(b)⇒(¬a))
neg
succession (a, b)
neg
response (a, b)∧neg
precedence (a, b)
neg
alt
response (a, b)
negative
 interposition (a, b)
neg
alt
precedence (a, b)
negative
 interposition (b, a)
neg
alt
succession (a, b)
neg
alt
response (a, b)∧neg
alt
precedence (a, b)
neg
chain
 response (a, b)
b2(a⇒/circlecopyrt(¬(b)))
neg
chain
 precedence (a, b)
2(/circlecopyrt(b)⇒¬(a))
neg
chain
 succession (a, b)
neg
chain
 response (a, b)∧
neg
chain
 precedence (a, b)
negative
 interposition (a, b)
2(a→/circlecopyrt((¬b)/unionsqa)
table xix. decserflow existence templates in sciff.
name
 sciff formula
absence (a)
true →en(performed (a),t)
existence
 n(n, a)
true →n^
i=1“
e(performed (a),ti)∧ti>t i−1”
absence
 n+ 1(n, a)
n^
i=1“
h(performed (a),ti)∧ti>t i−1”
→en(performed (a),t)∧t > t n
exactly
 n(n, a)
existence
 n(n, a)∧absence
 n+ 1(n, a)
we assume t0=0
acm transactions on the web, vol. v, no. n, may 2009.68· montali, pesic, van der aalst, chesani, mello, storari
“response” they are used to specify that “b” is executed after “a” (i.e., tb>t a).
formulas “chain
 response” and “chain
 precedence” use the “next” predicate to
specify that two activities are executed imme diately next to each other. this is for-
malized by stating that no activity should b e performed between the two activities,
i.e. by formalizing the next concept as follows:
next(t2,t1)←
en(performed (x),tx)∧tx>t 1∧tx<t 2.
such a concept is part of the general knowledge base.
table xx. decserflow relation templates in sciff.
name
 sciff formula
responded
 existence (a, b)
h(performed (a),ta)
→e(performed (b),tb).
coexistence (a, b)
responded
 existence (a, b)
∧responded
 existence (b, a).
response (a, b)
h(performed (a),ta)
→e(performed (b),tb)∧tb>t a.
precedence (a, b)
h(performed (b),tb)
→e(performed (a),ta)∧ta<t b.
succession (a, b)
response (a, b)
∧precedence (a, b).
alternate
 response (a, b)
response (a, b)
∧interposition (a, b).
alternate
 precedence (a, b)
precedence (a, b)
∧interposition (b, a).
alternate
 succession (a, b)
alternate
 response (a, b)
∧alternate
 precedence (a, b).
chain
 response (a, b)
h(performed (a),ta)
→e(performed (b),tb)∧tb>t a
∧next(tb,ta).
chain
 precedence (a, b)
h(performed (b),tb)
→e(performed (a),ta)∧ta<t b
∧next(tb,ta).
chain
 succession (a, b)
chain
 response (a, b)
∧chain
 precedence (a, a).
interposition (a, b)
h(performed (a),ta)
∧h(performed (a),ta2)∧ta2>t a
→e(performed (b),tb)
∧tb>t a∧tb<t a2.
table xxi shows the sciff formalization of “negation” templates from table
xv. for the sake of simplicity and reusability, in formulas “neg
 chain
 response”
acm transactions on the web, vol. v, no. n, may 2009.declarative speciﬁcation and veriﬁcation of service choreographies · 69
and “neg
 chain
 precedence”, we introduce a predicate to specify that if it is the
case that “a” is executed and “b” is execu ted after “a”, then the corresponding
execution times should not be next to each other. this is expressed by stating
that at least one activity should be performed between the two activities execution
times, i.e. by formalizing the not
next concept as follows:
not
next(t2,t1)←
e(performed (x),tx)∧tx>t 1∧tx<t 2.
table xxi. decserflow negation templates in sciff.
name
 sciff formula
responded
 absence (a, b)
h(performed (a),ta)
→en(performed (b),tb).
not
coexistence (a, b)
responded
 absence (a, b)
∧responded
 absence (b, a).
neg
response (a, b)
h(performed (a),ta)
→en(performed (b),tb)∧tb>t a.
neg
precedence (a, b)
h(performed (b),tb)
→en(performed (a),ta)∧ta<t b.
neg
succession (a, b)
negation
 response (a, b)
∧negation
 precedence (a, b).
neg
alt
response (a, b)
negative
 interposition (a, b).
neg
alt
precedence (a, b)
negative
 interposition (b, a).
neg
alt
succession (a, b)
neg
alt
response (a, b)
∧neg
alt
precedence (a, b).
neg
chain
 response (a, b)
h(performed (a),ta)
∧h(performed (b),tb)∧tb>t a
→not
next(tb,ta).
neg
chain
 precedence (a, b)
h(performed (b),tb)
∧h(performed (a),ta)∧ta<t b
→not
next(tb,ta).
neg
chain
 succession (a, b)
neg
chain
 response (a, b)
∧neg
chain
 precedence (a, b).
negative
 interposition (a, b)
h(performed (a),ta)
∧h(performed (a),ta2)∧ta2>t a
→en(performed (b),tb)
∧tb>t a∧tb<t a2.
acm transactions on the web, vol. v, no. n, may 2009.