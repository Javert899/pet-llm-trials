  155
chapter viii
service-oriented processes: 
an introduction to bpel
chun ouyang
queensland university of technology, australia
wil m.p. van der aalst
eindhoven university of technology, the netherlands and queensland university of technology, 
australia
marlon dumas
queensland university of technology, australiaaustralia
arthur h.m. ter hofstede
queensland university of technology, australiaaustralia
marcello la rosa
queensland university of technology, australia
copyright © 2007, idea group inc., distributing in print or electronic forms without written permission of igi is prohibited.abstract
the business process execution language for web services (bpel) is an emerging standard for specifying 
the behaviour of web services at different levels of details using business process modeling constructs. it 
represents a convergence between web services and business process technology. this chapter introduces 
the main concepts and constructs of bpel and illustrates them by means of a comprehensive example. 
in addition, the chapter reviews some perceived limitations of bpel and discusses proposals to addressperceived limitations of bpel and discusses proposals to address 
these limitations. the chapter also considers the possibility of applying formal methods and semantic 
web technology to support the rigorous development of service-oriented processes using bpel.156  service-oriented processes
introduction
web services are a standardised technology for 
building and integrating distributed software sys -
tems. web services are an incarnation of a software 
development paradigm known as service-ori -
ented architectures (soas). although there is no 
broad consensus around the definition of soas, 
it can be said that soas revolve around at least 
three major principles: (1) software systems are 
functionally decomposed into independently de -
veloped and maintained software entities (known 
as “services”); (2) services interact through the 
exchange of messages containing meta-data; 
and (3) the interactions in which services can 
or should engage are explicitly described in the 
form of interfaces.
at present, the first generation of web service 
technology has reached a certain level of maturity 
and is experiencing increasing levels of adoption, 
especially in the context of business applications. 
this first generation relies on xml, soap and 
a number of so-called ws-* specifications for 
message exchange (curbera, duftler, khalaf, 
nagy, mukhi, & weerawarana, 2002), and on 
xml schema and wsdl for interface descrip -
tion. in the meantime, a second generation of web 
services, based on richer service descriptions is 
gestating. whereas in first-generation web ser -
vices, interface descriptions are usually equated 
to sets of operations and message types, in the 
second generation the description of behavioural 
dependencies between service interactions (e.g., 
the order in which messages must be exchanged) 
plays a central role.
the business process execution language for 
web services (bea systems, microsoft, ibm, & 
sap, 2003), known as bpel4ws or bpel for 
short, is emerging as a standard for describing 
the behaviour of web services at different levels 
of abstraction. bpel is essentially a layer on top 
of wsdl and xml schema, with wsdl and 
xml schema defining the structural aspects of 
service interactions, and bpel defining the be -havioural aspects. to capture service behaviour, 
bpel adopts principles from business process 
modeling. indeed, the central idea of bpel is 
to capture the business logic and behavioural 
interface of services in terms of process models. 
these models may be expressed at different levels 
of abstraction, down to the executable level. at the 
executable level, bpel can be used to describe the 
entire behaviour of a new web service that relies 
on several other services to deliver its functional -
ity. this practice is known as service composition 
(casati & shan, 2001). an example of a composite 
service is a travel booking system integrating 
flight booking, accommodation booking, travel 
insurance, and car rental web services.
in this chapter, we introduce bpel by illustrat -
ing its key concepts and the usage of its constructs 
to define service-oriented processes and to model 
business protocols between interacting web ser -
vices. we also discuss some perceived limitations 
of bpel and extensions that have been proposed 
by industry vendors to address these limitations. 
finally, we review some research related to bpel 
and conclude with a note on future directions.
why bpel?
bpel supports the specification of service-
oriented processes, that is, processes in which 
each elementary step is either an internal action 
performed by a web service or a communication 
action performed by a web service (sending and/
or receiving a message). they can be executed 
to implement a new web service as a concrete 
aggregation of existing services to deliver its 
functionality (i.e. composite web service). for 
example, a service-oriented process may specify 
that a when a “sales” web service receives a 
“purchase order” from the “procurement” web 
service of a customer, the sales service engages 
in a number of interactions with several the “pro -
curement” web service as well as several other   157service-oriented processes
web services related to invoicing, stock control, 
and logistics, in order to fulfil the order. 
bpel draws upon concepts and constructs 
from imperative programming languages includ -
ing: (1) lexically scoped variables; (2) variable 
assignment; (3) sequential execution; (4) condi -
tional branching; (5) structured loops; and (6) 
exception handling (try-catch blocks). however, 
bpel extends this basic set of constructs with 
other constructs related to web services and 
business process management, to address the 
following aspects:
•	messaging: bpel provides primitive con -
structs for message exchange (i.e., send, 
receive, send/receive).
•	concurrency: to deal with concurrency 
between messages sent and received, bpel 
incorporates constructs such as block-struc -
tured parallel execution, race conditions, 
and event-action rules.
•	xml typing: to deal with the xml-inten -
sive nature of web services, bpel variables 
have xml types described in wsdl and 
xml schema. in addition, expressions may 
be written in xml-specific languages such 
as xpath or xslt.
bpel process definitions can be either fully 
executable or they can be left underspecified. ex -
ecutable bpel process definitions are intended to 
be deployed into an execution engine. this deploy -
ment results in a new web service being exposed, 
which usually relies upon and coordinates several 
other web services. this is why bpel is some -
times referred to as a language for “web service 
composition.” meanwhile, underspecified bpel 
definitions (called abstract processes ) capture 
a non-executable set of interactions between a 
given (web) service and several other services. 
one possible usage of abstract bpel processes is 
as a means for specifying the order in which the 
interactions (or “operations”) that a given service 
supports should occur for the service to deliver its functionality. such specification of dependencies 
between interactions is usually called a business 
protocol . coming back to the above purchase order 
process, one may capture the fact that an interac -
tion “request for quote” must precede a related 
interaction “place order.” a business protocol 
can be used for process monitoring, conformance 
checking and analysis of service compatibility. 
importantly, a web service whose business pro -
tocol is described as an abstract bpel process 
does not need to be implemented as an executable 
bpel process: it may very well be implemented 
using any other technology (e.g., standard j2ee 
or .net libraries and extensions for web service 
development). another usage of an abstract proc -
ess is as a template of a bpel process that needs 
to be refined into an executable implementation. 
the use of bpel abstract processes as business 
protocols or as templates is still the subject of 
ongoing research as discussed in the section 
“bpel-related research efforts”. at present, 
commercial bpel technology is mainly focused 
on fully executable bpel processes.
to further understand the reason for the emer -
gence of bpel, it is interesting to view it from a 
historical perspective. since 2000 there has been 
a growing interest in web services. this resulted 
in a stack of internet standards (http, xml, 
soap, wsdl, and uddi) which needed to be 
complemented by a process layer. several vendors 
proposed competing languages, for example,, ibm 
proposed wsfl (web services flow language) 
(leymann, 2001) building on flowmark/mq -
series and microsoft proposed xlang (web 
services for business process design) ( thatte,thatte, 
2001 ) building on bi �talk. bpel emerged as a ) building on bi �talk. bpel emerged as a 
compromise between both languages, supersed -
ing the corresponding specifications. it combines 
accordingly the features of a block-structured 
language inherited from xlang with those for 
directed graphs originating from wsfl. the 
first version of bpel (1.0) has been published 
in august 2002, and the second version (1.1) 
has been released in may 2003 as input for the 158  service-oriented processes
standardization within oasis. the appropri -
ate technical committee ( oasis web servicesoasis web services 
business process execution language tc, 2006 ) 
is working since the time of submission and is in 
the process of finali �ing the appropriate standard 
specification, namely web services business 
process execution language (ws-bpel) version 
2.0 (oasis, 2005).oasis, 2005). 
currently bpel is implemented in a variety of 
tools (see http://en.wikipedia.org/wiki/ bpel  for 
a compendium). systems such as bea weblogic, 
ibm websphere, microsoft bi �talk, sap xi and 
oracle bpel process manager support bpel 
to various degrees, thus illustrating the practi -
cal relevance of this language. also, there is a 
relatively complete open-source implementation 
of bpel, namely activebpel.
overview of bpel
bpel defines a model and a grammar for describ-pel defines a model and a grammar for describ -
ing the behaviour of a business process based on 
interactions between the process and its partners. 
a bpel process is composed of activities that can 
be combined through structured operators and 
related through so-called control links. in addition 
to the main process flow, bpel provides event 
handling, fault handling and compensation (i.e., 
“undo”) capabilities. in the long-running business 
processes, bpel applies correlation mechanism to 
route messages to the correct process instance. 
bpel is layered on top of several xml specifi -
cations: wsdl, xml schema and xpath. wsdl 
message types and xml schema type definitions 
provide the data model used in bpel processes. 
xpath provides support for data manipulation. all 
external resources and partners are represented 
as wsdl services.
partners and partner links
business processes that involve web services often 
interact with different partners . the interaction the interactionthe interaction with each partner occurs through web service 
interfaces called port types , and the structure of 
the relationship at the interface level is identified 
by a partner link . a partner link specifies which 
port type must be supported by each of the part -
ners it connects, and which port type it offers to 
each partner. a partner link is an instance of a 
typed connector, known as a partner link type , 
which specifies a set of roles  and the port type 
provided by each role. 
consider a simple purchase order process 
which interacts with two partners: the client and 
the invoicing service. each interaction involves 
one of the parties (i.e., the process or partner) 
exposing the required functionality via a port 
type, and the other party making use of that 
functionality. figure 1 briefly depicts this process 
and the interactions between the process and each 
of its two partners. 
for the above process, two partner links are 
created, namely “purchasing” and “invoicing”. 
figure 2 shows the xml code snippets defin -
ing these two partner links and their link types 
“purchasingplt” and “invoicingplt.” the link 
type “purchasingplt” includes the definition of 
a role “purchaseservice” (played by the purchase 
order process) referring to port type “purchasept” 
where a “purchase order” is received by the pro -
cess. similarly, the link type “invoicingplt” is 
defined featuring two roles: “invoiceservice” 
(played by the invoicing service) referring to port 
type “computerpricept” where the operation of 
a “request for price calculation” is called, and 
“invoicerequester” (played by the purchase order 
process) referring to port type “invoicecallback -
pt” where the invoice is received by the process. 
following common practice, we define the partner 
link types in the wsdl document to which the 
bpel process definition refers. meanwhile, the 
partner links themselves are defined in the bpel 
process definition.  159service-oriented processes
activities
a bpel process definition relates a number of 
activities . activities are split into two categories: 
basic and structured activities. basic activities  are 
also called primitive activities . they correspond 
to atomic actions and stand for work being per -
formed within a process. structured activities  
impose behavioural and execution constraints on 
a set of activities contained within them. struc -
tured activities can be nested and combined in 
arbitrary ways, thus enabling the presentation of 
complex structures. 
basic activities. these contain: invoke , invok -
ing an operation on some web service; receive , 
waiting for a message from an external partner; 
reply , replying to an external partner; wait, paus -
ing for a certain period of time; assign , copying 
data from one place to another; throw , indicating 
errors in the execution; compensate , undoing the 
effects of already completed activities; exit, ter-
minating the entire service instance; and empty , 
doing nothing. below, we look closer into three 
activities: invoke , receive , and reply .
invoke , receive , and reply  activities are three 
types of interaction activities defined in bpel. 
interaction activities must specify the partner 
link through which the interaction occurs, the 
operation involved, the port type in the partner  clientinvoicing
servicepurchas e
orderpurchas e
order
proces s"purchasept"
request fo r
price calculatio n
invoic e"computerpricept"
"invoicecallbackpt"figure 1.  a purchase order process interacting with two partners
wsdl snippet:
...
<partnerlinktype name="purchasingplt">
   <role name="purchaseservice">
      <porttype name="purchasept"/>
   </role>
</partnerlinktype>
<partnerlinktype name="invoicingplt">
   <role name="invoiceservice">
      <porttype name="computepricept"/>
   </role>
   <role name="invoicerequester">
      <porttype name="invoicecallbackpt"/>
   </role>
</partnerlinktype>
...
bpel snippet:
...
<partnerlinks>
   <partnerlink name="purchasing"
                partnerlinktype="purchasingplt"
                myrole="purchaseservice"/>
   <partnerlink name="invoicing"
                partnerlinktype="invoicingplt"
                myrole="invoicerequester"
                partnerrole="invoiceservice"/>
</partnerlinks>
... figure 2.  definition of the “purchasing” and 
“invoicing” partner links and their types160  service-oriented processes
link that is being used, and the input and/or output 
variables that will be read from or written to. note 
that variables are used to carry data (see subsec -
tion on “data handling”) and are required only 
in executable processes.
for an invoke  activity, the operation and port 
type that are specified are that of the service being 
invoked. such an operation can be a synchronous 
“request-response” or an asynchronous “one-way” 
operation. an invoke  activity blocks to wait for 
a response if it is calling a request-response op -
eration, whereas in the case of a one-way opera -
tion, invoke  can be viewed as a “send” action. a 
synchronous invocation requires both an input 
variable and an output variable. an asynchronous 
invocation requires only the input variable of the 
operation because it does not expect a response 
as part of the operation. for example, in the 
purchase order process shown in figure 1, the 
process initiates a price calculation service by 
sending a purchase order to the invoicing service. 
figure 3 provides the xml definition of this 
invoke  activity, which calls a one-way operation 
“initiatepricecalculation”.
a business process provides services to its 
partners through receive  activities and corre -
sponding reply  activities. a receive  activity al -
lows the process to block and wait for a matching 
message to arrive, while a reply  activity is used to 
send a response to a request that was previously 
accepted via a receive  activity. such responses 
are only meaningful for synchronous interactions. 
therefore, a pair of receive  and reply  activities must map to a request-response operation. in such 
case, any control flow between these two activities 
is effectively the implementation of that operation. 
a receive  with no corresponding reply  must map 
to a one-way operation, and the asynchronous 
response is always sent by invoking the same 
one-way operation on the same partner link. 
a receive  activity specifies the partner link 
it expects to receive from, and the port type and 
operation that it expects the partner to invoke. 
in addition, it may specify a variable used to re -
ceive the message data being expected. a receive  
activity also plays a key role in the lifecycle of 
a business process. it is always associated with 
a specific attribute called createinstance  with 
a value of “yes” or “no”. the default value of 
this attribute is “no”. a receive  activity with the 
createinstance  attribute set to “yes” must be an 
initial activity in a business process, which pro -
vides the only way to instantiate the process in 
bpel (see structured activity pick for a variant). 
a reply  activity shares the same partner link, port 
type and operation as the corresponding receive  
activity, but may specify a variable that contains 
the message data to be sent as the response. 
let’s revisit the purchase order process in 
figure 1. a process instance is instantiated upon 
receiving a purchase order from the client, and 
may be completed by replying to the client with 
an invoice listing the price for that purchase 
order. figure 4 provides the xml definition of 
the corresponding pair of receive  and reply  ac-
tivities over a request-response operation named 
“sendpurchaseorder”. in the same process, there 
is another receive  activity referring to a one-way 
operation “sendinvoice”. it is used for receiving 
the invoice produced by the invoicing service. 
the process defines this activity as the response 
to the price calculation request sent by the process 
before (see the invoke  activity defined in figure 
3). figure 5 gives the xml definition of this 
receive  activity.
before moving onto structured activities, it is 
worth mentioning the following two restrictions <invoke partnerlink="invoicing"
        porttype="computepricept"
        operation="initiatepricecalculation"
        inputvariable="purchaseorder"/>figure 3.  an invoke activity for initiating a price 
calculation service  161service-oriented processes
that bpel applies on the above three interaction 
activities:
• first, bpel does not allow two receive  ac-
tivities to be active (i.e., ready to consume 
messages) at the same time if they have the 
same partner link, port type, operation, and 
correlation set  which is used for routing mes -
sages to process instances (see subsection 
on “correlation”). if this happens, a built-in 
fault named “conflictingreceive” will be 
raised at runtime.
• second, bpel does not allow a request to 
call a request-response operation if an active 
receive  is found to consume that request, but 
a reply  has not yet been sent to a previous 
request with the same operation, partner 
link, and correlation set. if this happens, a 
built-in fault named “conflictingrequest” 
will be thrown.structured activities. bpel defines six struc -
tured activities: sequence , switch,  pick, while , flow, 
and scope . the use of these activities and their 
combinations enable bpel to support most of the 
workflow patterns described in ( aalst, van der,aalst, van der, 
hofstede, ter, kiepus �ewski, & barros, 2003 ).).
a sequence  activity contains one or more ac -
tivities that are performed sequentially. it starts 
once the first activity in the sequence starts, and 
completes if the last activity in the sequence com -
pletes. for example, figure 6 defines a sequence 
of activities performed within the purchase order 
process shown in figure 1. to improve readability, 
this and the following code snippets do not use 
xml syntax. instead, bpel element names are 
written in bold while the level of nestings of ele -
ments is captured through indentation.  
 a switch  activity supports conditional rout -
ing between activities. it contains an ordered 
list of one or more conditional branches called 
case branches. the conditions of branches are 
evaluated in order. only the activity of the first 
branch whose condition holds true will be taken. 
there is also a default branch called otherwise  
branch, which follows the list of case branches. 
the otherwise  branch will be selected if no case 
branch is taken. this ensures that there is always 
one branch taken in a switch activity. the switch 
activity completes when the activity of the selected 
branch completes. for example, consider a sup -
ply-chain process which interacts with a buyer 
and a seller. assume that the buyer has ordered <receive partnerlink="purchasing"
         porttype="purchasept"
         operation="sendpurchaseorder"
         variable="purchaseorder"
         createinstance="yes"/>
...
<reply partnerlink="purchasing"
       porttype="purchasept"
       operation="sendpurchaseorder"
       variable="invoice"/>figure 4. an initial receive activity for receiving 
a purchase order from the client and the cor -
responding reply activity for replying with an 
invoice for the order
<receive partnerlink="invoicing"
         porttype="invoicecallbackpt"
         operation="sendinvoice"
         variable="invoice"/>figure 5. a receive activity for receiving an invoice 
from the invoicing servicebegin sequence
    receive purchaseorder from client;
    invoke  pricecalculation on invoicing service;
    receive invoice from invoicing service;
    reply invoice to client
end sequencefigure 6.  a sequence of activities performed in 
the purchase order process in figure 1162  service-oriented processes
a volume of 100 items of a certain product. the 
process needs to check the stock inventory before 
fulfilment. if the result shows more than 100 items 
of the product in stock, the process performs the 
fulfilment work (which may contain a number of 
activities); if the result shows less than 100 items 
in stock, a fault is thrown indicating the product is 
out of stock; otherwise (i.e., no items are in stock), 
another fault is thrown signalling the product is 
discontinued. figure 7 shows how to use a switch  
construct to model these activities.
a pick activity captures race conditions based 
on timing or external triggers. it has a set of 
branches in the form of an event followed by an 
activity, and exactly one of the branches is selected 
upon the occurrence of the event associated with 
it. if more than one of the events occurs, the selec -
tion of the activity to perform depends on which 
event occurred first. if the events occur almost 
simultaneously, there is a race and the choice of 
activity to be performed depends on both tim -
ing and implementation. there are two types 
of events: message events ( onmessage ) which 
occur upon the arrival of an external message, 
and alarm events ( onalarm ) which occur upon a 
system timeout. 
note that onmessage  is a receive -like con -
struct and is thereby treated in much the same 
manner as a receive  activity, for example,, both 
are used for process instantiation, share the same 
attributes, and should not violate the constraint on 
“conflictingreceive.” a pick activity completes 
when one of the branches is triggered by the 
occurrence of its associated event and the corre -
sponding activity completes. figure 8 shows an 
example of a typical usage of pick for modeling 
the order entry/completion within a supply-chain 
process. there are three events: a line item mes -
sage event whose occurrence will trigger an order 
entry action; a completion message event whose 
occurrence will trigger an order completion ac -
tion; and an alarm event which will occur after 
a period of 3 days and 10 hours and thus trigger 
a timeout action.a while  activity supports repeated perfor -
mance of an activity in a structured loop, that is, a 
loop with one entry point and one exit point. the 
iterative activity is performed until the specified 
while condition  (a boolean expression) no longer 
holds true. for example, the pick activity defined 
in figure 8 can occur in a loop where the seller 
is accepting line items for a large order from begin switch
    case stockresult >100 : perform fulfillment work
    case stockresult > 0 : throw outofstock fault
    otherwise : throw itemdiscoutinued fault
end switchfigure 7.  a switch activity modeling stock inven -
tory check in a supply-chain process
begin pick
    onmessage lineitem : add line item to order
    onmessage completiondetail : perform order 
completion
    onalarm for ‘p3dt10h’ : handle timeout for 
order completion
end pickfigure 8.  a pick activity modeling order entry/
completion in a supply-chain process
while moreorderentriesexpected = true
    begin pick
       onmessage lineitem : add line item to order
       onmessage completiondetail : 
            begin sequence
                 perform order completion;
                 moreorderentriesexpected := false
            end sequence
       onalarm for ‘p3dt10h’ : 
            begin sequence
                 handle timeout for order completion;
                 moreorderentriesexpected := false
            end sequence
    end pickfigure 9.  a while activity modeling a loop of the 
pick activity defined in figure 8  163service-oriented processes
the buyer. figure 9 shows how this loop can be 
specified using a while  activity. the pick activity 
nested within while  can be repeated until no more 
order entries are expected.
a flow activity provides parallel execution and 
synchronization of activities. it also supports the 
usage of control link s for imposing further control 
dependencies between the activities nested within 
it. control links are non-structural constructs in 
bpel and will be covered in more detail in the 
next subsection. figure 10 shows an example of 
the simple usage of flow construct as equivalent to 
a nested concurrency construct. in this example, 
a supply-chain process sends questionnaires to 
the buyer and seller in parallel, and then blocks to 
wait for their responses. after both have replied, 
the process continues to next task (e.g., to gener -
ate an evaluation report). in figure 10, the two 
invoke  activities are enabled to start concurrently 
as soon as the flow starts. assume that both invoke  
activities refer to synchronous request-response 
operations. the flow is completed after the buyer 
and the seller have both responded.
a scope  is a special type of structured activity. 
it is used for grouping activities into blocks, andis used for grouping activities into blocks, and 
each block is treated as a unit to which the same 
event and exception handling can be applied. 
a scope  has a primary activity (i.e. main activ -
ity) that defines its normal behaviour, and canand can 
provide event handlers , fault handlers , and also 
a compensation handler . like other structured 
activities, scopes can be nested to arbitrary depth, 
and the whole process is implicitly regarded as the top level scope. the usage of scope  will be 
discussed in detail further on in subsection s on on 
“event handlers”, “fault handling” and “com -
pensation”.
control links
the sequence , flow, switch , pick,  and while  
described in the previous subsection provide a 
means of expressing structured flow dependen -
cies. in addition to these constructs, bpel pro -
vides another construct known as control link s 
which, together with the associated notions of 
join condition  and transition condition , support 
the definition of precedence, synchroni �ation and 
conditional dependencies on top of those captured 
by the structured activities. 
a control link  denotes a conditional transition 
between two activities. a join condition , which is 
associated to an activity, is a boolean expression 
in terms of the tokens carried by incoming 
control links to this activity. each token, which 
represents the status of the corresponding control 
link, may take either a positive (true) or a negative 
(false) value. for example, a control link between 
activities a and b indicates that b cannot start 
before a has either completed or has been skipped 
(e.g., a is part of an unselected branch of a switch  
or pick). moreover, activity b can only be executed 
if its associated join condition evaluates to true, 
otherwise b will not run. a transition condition , 
which is associated to a control link, is a boolean 
expression over the process variables (just like 
begin flow
    invoke fillquestionnaire (request-response) operation on the buyer
    invoke fillquestionnaire (request-response) operation on the seller
end flow
...figure 10.  a flow activity modeling two concurrent questionnaire interactions in a supply-chain pro -
cess164  service-oriented processes
the conditions in a switch  activity). for example, 
an activity x propagates a token with a positive 
value along an outgoing control link l, if and 
only if x was executed (as opposed to being 
skipped) and the transition condition associated 
to l evaluates to true. 
as mentioned above, if an activity has incoming 
control links, one of the enabling conditions for 
this activity to run is that its associated join 
condition evaluates to true. otherwise , a fault a fault 
called join failure  occurs. when a join failure 
occurs at an activity, it can be handled in two 
different ways as determined by the suppressjoin -
failure  attribute associated with the activity. this 
attribute can be set to a value of “yes” or “no”. 
if “yes,” it instructs to suppress the join failure. 
in this case, the activity will be skipped, and the 
tokens carried by all its outgoing links will take 
a negative value. the process by which positivethe process by which positive 
and negative tokens are propagated along control 
links, causing activities to be executed or skipped, 
is called dead path elimination . otherwise, if thethe 
suppressjoinfailure  is set to “no,” the join fail -
ure is thrown, which triggers the standard fault 
handling procedure (see subsection on “fault 
handling”). control links are non-structural constructs 
defined in bpel, and allow the definition of 
directed graphs. however, it is important to 
mention two link restrictions. first, control links 
must not create cyclic graphs. second, control 
links must not cross the boundary of a loop 
(i.e., a while  activity) as that would lead to an 
inconsistent state.
we revisit the example of the stock inventory 
check within a supply-chain process. this has 
been previously specified by a switch  activity 
shown in figure 7. below, we use control links 
to replace the switch  construct for the modeling. 
for completeness, we add two activities: one is 
that the process inquires the stock result from the 
seller before the inventory check switch  activity, 
and the other is that the process informs the 
seller about the updated stock result after the 
switch  activity. using structured constructs, the 
above two activities, together with the previous 
switch  activity for stock inventory check, can 
be specified in a sequence  construct. using 
control link constructs, we obtain a directed 
graph representation shown in figure 11. figure 
12 sketches the definition of the corresponding 
abstract bpel specification.
invoke 
stockr esultinquiry 
activi ty 
perfor m fulfillment  throw 
outofstock  throw 
itemdiscontinue d 
invoke 
updatest ockres ult tofulfil ment  
(stockresult >100 ) todiscontinued  
(stockresult = 0) toouto fstock 
(100>stockresult>0) 
afterfulfilm ent afterdiscontinued  afterout ofstock 
control link  activity  legend : figure 11.  a directed graph representing the stock inventory check procedure within a supply-chain 
process  165service-oriented processes
from the above example, it can be observed that 
any control link leaving an unexecuted activity 
or whose transition condition evaluates to false 
will have its link status set to false. as a result, 
each control link will propagate either a true or 
a false token so that the activities downstream 
which have a control dependency on the link do 
not end up waiting for ever. this is the mechanism 
of dead path elimination that we have mentioned 
before. also note that, as a syntactical restriction in bpel, control links must be used within a 
flow construct.
event handlers
the purpose of event handlers  is to specify logic 
to deal with events that take place concurrently 
while the process is running. an event handler is 
an event-action rule associated with a scope, and 
is in the form of an event followed by an activity. 
begin flow (suppressjoinfailure =”yes”)
    begin link declaration
        link “tofulfillment”
        link “tooutofstock”
        link “todiscontinued”
        link “afterfulfillment”
        link “afteroutofstock”
        link “afterdiscontinued”
    end link declaration
    invoke stockresultquery (request-response) operation on the seller
        source of link “tofulfillment” with 
            transitioncondition (stockresult >100)
        source of link “tooutofstock” with
            transitioncondition (stockresult > 0 and stockresult <100)
        source of link “todiscontinued” with 
            transitioncondition (stockresult = 0)
    activity : performing fulfillment work
        joincondition linkstatus(“tofulfillment”)
        target of link “tofulfillment”        
        source of link “afterfulfillment”
            transitioncondition (true)
    throw outofstock fault
        joincondition linkstatus(“tooutofstock”)
        target of link “tooutofstock” 
        source of link “afteroutofstock”
            transitioncondition (true)
    throw itemdiscoutinued fault
        joincondition linkstatus(“todiscontinued”)
        target of link “todiscontinued” 
        source of link “afterdiscontinued”
            transitioncondition (true)
    invoke stockresultupdate (one-way) operation on the seller
        joincondition linkstatus(“afterfulfillment”) or
                                linkstatus(“afteroutofstock”) or
                                linkstatus(“afterdiscontinued”)
        target of link “afterfulfillment” 
        target of link “afteroutofstock” 
        target of link “afterdiscontinued” 
end flowfigure 12.  using control links to model the stock inventory check procedure sketched in figure 11166  service-oriented processes
an event handler is enabled when its associated 
scope is under execution and may execute concur -
rently with the main activity of the scope. when 
an occurrence of the event associated with an 
enabled event handler is registered, the activity 
within the handler is executed while the scope’s 
main activity continues its execution. also, the 
activity within an event handler is invoked con -
currently when the corresponding event occurs. 
for this reason, control links are not allowed to 
cross the boundary of an event handler.
it is important to emphasize that event handlers 
are part of the normal behaviour of a scope, unlike 
fault and compensation handlers (see subsections 
on “fault handling” and “compensation”). 
the event handlers associated with a scope are 
enabled when that scope commences, and are 
disabled when the normal processing of the scope 
is complete. any event handler that has already 
started is allowed to finish its execution. an entire 
scope is not considered to complete until all event 
handlers associated with the scope have finished 
their executions.
bpel allows any type of activity, except the 
compensate  activity, to handle events. there are 
two types of events. one is the message events 
(onevent ) triggered by the arrival of an external 
message, the other is the alarm events ( onalarm ) 
triggered by an alarm which goes off after a user-
specified time. 
message event handlers. the semantics ofthe semantics of 
onevent  message events is very similar to receive  
activities, except that these message events cannot 
create process instances. an event handler is not 
enabled prior to the creation of a process instance, 
and is capable of processing events only if an 
instance has been created. the message that 
triggers an event is identified by the partner link 
from which the message arrives, the appropriate 
port type, operation and optional variable and 
correlation set. this message can be part of either 
an asynchronous (one-way) or a synchronous 
(request-response) operation. in the latter case, 
the event handling logic is expected to have a reply  activity, in order to fulfil the requirements 
of the operation.
when a message event is triggered, the activity 
specified within the corresponding message event 
handler is carried out. message event handlers 
remain active as long as the scope to which they 
are attached is active. an active message event 
handler can be triggered multiple times, even 
simultaneously, if the expected message events 
occur multiple times. however, it should be noted 
that simultaneously active instances of a message 
event handler is permitted, while the semantics of 
simultaneous onevent  from the same partner, port 
type, operation and with the same correlation set 
are undefined. the reader may recall that receive  
activities have a similar constraint.
alarm event handlers. an onalarm  event 
marks a system timeout. it has two alternative 
attributes: for and until, and exactly one of them 
must be specified. these two attributes determine 
two forms of alarm events. the first specifies 
duration within for attribute. in this form, a timer 
for calculating the duration is started when the 
associated scope is activated. as soon as the 
specified duration is reached, the activity in the 
corresponding event handler is executed. in the 
second form, until attribute details a specific point 
in time when the alarm will be fired. as soon as 
this specific point in time is reached, the alarm 
event is triggered and the corresponding event 
handler is executed. it should be noted that, unlike 
message events, alarm events can be processed at 
most once while the associate scope is active.
let’s revisit the purchase order process shown 
in figure 1. the process may terminate its execu -
tion if either a cancel message is received from 
the client or the process has been running already 
for two days in processing a purchase order from 
the client. in the latter case, the process will reply 
to the client with a cancel message (instead of 
an invoice). the two event handlers defined in 
figure 13 are used to implement the above two 
scenarios when the sequence activity defined in 
figure 6 is running.   167service-oriented processes
fault handling
fault handling in a business process enables the 
process to recover locally from possible antici -
pated faults that may arise during its execution. 
for example, consider a fault caused by insuf -
ficient funds in the client’s account for payment 
during a purchase order process. the fault may be 
handled by requesting the information of another 
available account from the client, without having 
to restart the entire process.
bpel considers three types of faults. these 
are: application faults  (or service faults ), which 
are generated by services invoked by the process, 
such as communication failures; process-defined 
faults , which are explicitly generated by the 
process using the throw  activity; and system faults , 
which are generated by the process engine, such 
as “conflictingreceive,” “conflictingrequest” and 
join failures introduced before. note that the first 
two types of faults are usually user-defined, while 
the last one consists of built-in faults defined in 
bpel.
fault handlers specify reactions to internal or 
external faults that occur during the execution of 
a scope, and are defined for a scope using catch  
activities. unlike event handlers, fault handlers do not execute concurrently with the scope’s main 
activity. instead, this main activity is interrupted 
before the body of the fault handler is executed. 
in more detail, if a fault occurs during the normal 
process of a scope, it will be caught by one of the 
fault handlers defined for the scope. the scope 
switches from the normal processing mode to the 
fault handling mode. note that it is never possible 
to run more than one fault handler for the same 
scope under any circumstances. 
a fault handler is defined either explicitly 
or implicitly. an implicit fault handler is also 
known as a default fault handler. it is created, 
using a catch -all activity, to catch any fault that 
is not caught by all explicit fault handlers within 
the scope. therefore, one can assume that each 
scope has at least one (default) fault handler. if a 
fault handler cannot handle a fault being caught 
or another fault occurs during the fault handling, 
both faults need to be re-thrown to the (parent) 
scope that directly encloses the current scope. a 
scope in which a fault has occurred is considered 
to have ended abnormally and thus cannot be 
compensated, no matter whether or not the fault 
can be handled successfully (without being re-
thrown) by the corresponding fault handler.
finally, control links may cross the boundary 
of fault handlers. however, a control link is 
only allowed to leave  the boundary of a fault 
handler, and the converse is not true. also, if a 
fault occurred within a scope has been handled 
successfully, any control link leaving from that 
scope will be evaluated normally. 
let’s refer back to the stock inventory check 
specified in figure 7. figure 14 shows two fault 
handlers used to catch the two faults that may 
occur during the inventory check. if a fault oc -
curs indicating the product is out of stock, the 
process invokes the order pending operation on 
the buyer. otherwise, if a fault occurs indicating 
the product discontinued, the process invokes the 
order rejection operation on the buyer.begin scope
    onevent cancel from client : exit
    onalarm for ‘p2dt’ : 
        begin sequence
            reply cancel to client; 
            exit
        end sequence
    (* sequence activity defined in figure 6 *)
end scopefigure 13.  examples of the message and alarm 
event handlers used for terminating the purchase 
order process shown in figure 1168  service-oriented processes
compensation
as part of the exception handling, compensation 
refers to application-specific activities that 
attempt to undo the already completed actions. 
for example, consider a client requests to cancel 
the air ticket reservation with a ticket order 
process. the process will need to carry out the 
following compensation actions, which involve 
the cancellation of the reservation with the airline, 
and optionally the conduction of fee charges to the 
client if there are fees applied for the cancellation 
of a reservation.
in bpel, compensation actions are specified 
within a compensation handler. each scope, except 
the top level scope (i.e. process scope), provides 
one compensation handler that is defined either 
explicitly or implicitly. similarly to a default fault 
handler, an implicit (or default) compensation 
handler is created for a scope, if the scope is asked 
for compensation but an explicit compensation 
handler is missing for that scope. a fault handler 
or the compensation handler of a given scope, 
may perform a compensate  activity to invoke the 
compensation of one of the sub-scopes nested 
within the given scope. similarly to the control 
link restrictions applied to event handlers, control 
links are not allowed to cross the boundary of 
compensation handlers. 
it is important to mention that whether the 
compensation handler of a scope is available for invocation depends on the current local state of the 
scope. for example, it is not possible to conduct 
the compensation of a scope that has never been 
executed. bpel uses a term “ scope snapshot ” 
to refer to the preserved state of a successfully 
completed uncompensated scope. in such state, the 
data to which the scope has access is snapshotted 
for use when the associated compensation handler 
is running. thus, the compensation handler of 
a scope is available for invocation only if the 
scope has a scope snapshot. otherwise, invoking 
a compensation handler that is unavailable is 
equivalent to performing an empty activity. since 
the compensation of already completed activities 
is a complex procedure, we decide not to include 
an example here and the interested reader may 
refer to (bea systems, microsoft, ibm, & sap, 
2003) for more details.
data handling
in the previous subsections, we mainly focus 
on the control logic of a bpel process. careful 
readers may already notice that the process data 
is necessary for the process logic to make data-
driven decisions (e.g., in a switch  activity). in the 
following, we introduce how data is represented 
and manipulated in bpel.
messages. business protocols specified in 
bpel prescribe exchange of messages  between 
interacting web services. these messages are 
wsdl messages defined in the appropriate wsdl 
definitions. briefly, a message consists of a set 
of named parts , and each of these parts is typed 
generally using xml schema. for example, in 
figure 15 below, the ordermsg  is shown with three 
message parts: an ordernumber  of an integer type, 
an orderdetails  of a string type, and a timestamp 
of a datetime type. note that the integer, string 
and datetime are all simple xml schema types. if 
a complex xml schema type is needed, it needs 
to be defined in the corresponding xml schema 
file (see section on “bpel at work”).begin scope
    catch outofstock fault :
        invoke orderpending operation on the buyer
    catch itemdiscontinued fault :
        invoke orderrejection operation on the buyer
    (* switch activity defined in figure 7 *)
end scopefigure 14.  examples of the fault handlers for 
catching the corresponding faults occurred during 
the stock inventory check defined in figure 7  169service-oriented processes
variables. in a bpel process definition, 
variables are used to hold messages exchanged 
between the process and its partners as well as 
internal data that is private to the process. vari -
ables are typed, using wsdl message types, xml 
schema simple types or xml schema elements. 
note that if a variable is of wsdl message type, 
it also consists of a set of named parts (each of 
which as specified in a part attribute). for exam -
ple, in figure 16 both order  and order_backup  
variables are defined as of the ordermsg  type 
above, and the number  variable is defined as of 
an integer type.
each variable is declared within a scope and 
is said to belong to that scope. variables that 
belong to the global process scope are called 
global variables , while others are called local 
variables . bpel follows the same rules as those 
in imperative programming languages with lexical 
scoping of variables. a variable is visible in the 
scope (e.g., namely q) to which it belongs and all 
scopes that are nested within q. thus, a global 
variable is visible in the entire process. also, it 
is possible to hide a variable in a scope (q) by 
defining a variable with the same name in one of 
the scopes nested in q.
expressions. bpel supports four types of 
expressions: (1) boolean-valued  expressions for 
specifying transition conditions, join conditions, 
and conditions in switch  or while  activities; 
(2) deadline-valued  expressions for specifying 
until attribute of onalarm  or a wait activity; (3) duration-valued  expressions for specifying for 
attribute of onalarm  or a wait activity; and (4) gen -
eral expressions for assignments (see next). bpel 
provides an extensible mechanism for specifying 
the language used to define expressions. this lan -
guage must have facilities such as to query data 
from variables, to query the status of control links, 
and so forth xpath 1.0 is the default language for 
specifying expressions. another language that can 
be used is xslt. figure 17 gives four examples 
of expressions used in bpel. the first two are 
both boolean-valued expressions: one indicating 
the status of a control link, the other indicating 
whether the ordernumber  of an order  message is 
greater than a given number (e.g. 50). the third 
one is a deadline-valued expression, and the last 
one is a duration-based expression.
assignments. data can be copied from one 
variable to another using the assign  activity. 
an assign activity may consist of a number of 
assignments, each of which being defined by a 
copy  element with from  and to attributes. the <message name="ordermsg"/>
  <part name="ordernumber" 
type="integer"/>
  <part name="orderdetails" 
type="string"/>
  <part name="timestamp" 
type="datetime"/>
</message>figure 15. example of a wsdl message defini -
tionfigure 16. examples of variable definitions in 
bpel
<variables>
  <variable name="order" 
messagetype="ordermsg"/>
  <variable name="order_backup" 
messagetype="ordermsg"/>
  <variable name="number" 
type="integer"/>
</variables>
figure 17. examples of expressions used in 
bpel
... bpws:getlinkstatus('linkl2') ...
... bpws:getvariabledata('order','ordernumber')>50 
...
... until="'2006-01-31t18:00'" ...
... for="'p40d'" ...170  service-oriented processes
source of the copy (specified by from attribute) 
and the target (specified by to attribute) must be 
type-compatible. bpel provides a complete set 
of possible types of assignments. for example, 
within common uses of assignment, the source 
of the copy can be a variable, a part of a variable, 
an xpath expression, and the target of the copy 
can be a variable or a part of a variable. figure 18 
illustrates copying data from one variable ( order ) 
to another ( order_backup ) as well as copying data 
from a variable part ( ordernumber  part of order ) 
to a variable of compatible type ( number ), and 
both assignments are defined within one assign  
activity.
correlation
business processes may in practice occur over 
a long period of time, possibly days or months. 
in long-running business processes, it is neces -
sary to route messages to the correct process 
instance. for example, when a request is issued 
from a partner, it is necessary to identify whether 
a new business process should be instantiated 
or the request should be directed to an existing 
process instance. instead of using the concept of 
instance id as often used in distributed object 
system, bpel reuses the information that can 
be identified from the specifically marked parts 
in incoming messages, such as order number  or 
client id , to route messages to existing instances 
of a business process. this mechanism is known 
as correlation . the concept of correlation set  is 
then defined by naming specific combinations of 
certain parts in the messages within a process. 
this set can be used in receive , reply  and invoke  
activities, the onmessage  branch of pick activities, 
and the onevent  handlers.
similarly to variables, each correlation set is 
defined within a scope. global correlation sets 
are declared in the process scope, and local cor -
relation sets are declared in the scopes nested 
within a process. correlation sets are only visible 
for the scope (q) in which they are declared and all scopes nested in q. also, correlation set can 
only be initiated once during the lifetime of the 
scope to which it belongs. how to define and use 
correlation sets will be illustrated through the 
example in the next section.
bpel at work
this section describes the example of a bpel 
process which provides sales service. this pro -
cess, namely salesbp, interacts with a customer 
process (customerbp) by means of asynchronous 
messages. the process salesbp enacts the role 
of service provider, whilst the customer is the 
service requester.
process description
figure 19 depicts the behaviour of the process 
salesbp. the process is instantiated upon receiv -
ing a request for quote ( rfq), which includes the 
description  and the amount of the goods needed, a 
unique identifier of the request ( rfqid ), and a dead -
line ( to). next, the process checks the availability 
of the amount of the goods being requested. if not 
available, a rejectrfq is sent back to the customer, 
providing the reason  of the rejection. otherwise, 
the process prepares a quote  with the cost of the <assign>
  <copy>
    <from variable="order"/>
    <to variable="order_backup"/>
  </copy>
  <copy>
    <from variable="order" 
part="ordernumber"/>
    <to variable="number"/>
  </copy>
</assign>figure 18. examples of assignments used in 
bpel  171service-oriented processes
figure 19.  flow diagram of the salesbp process172  service-oriented processes
offer and then sends it back to the customer. after 
sending the quote , the process waits for an order  
until time-limit to is reached. if the order  is not 
received by that time, no more activities will be 
performed. otherwise, if the order is returned 
before the deadline to, it will be processed. after 
the order has been processed successfully, the 
entire process instance will complete. however, 
the processing of the order may be cancelled at 
any time upon receiving a cancelorder  message 
from the customer, and as a result, the process 
will be forced to terminate.
xml schema definition
figure 20 shows the xml schema file “salex.
xsd” for the process salesbp. it defines the complex 
xml schema types for messages rfq, quote , or-
der, rejectrfq and cancelorder  that are involved in salesbp (lines 7-26). in particular, messages 
order  and cancelorder  have the same structure as 
message quote  (lines 4-6). besides, each message 
includes an element named rfqid (lines 9, 17, 23), 
through whose value a bpel-compliant execu -
tion engine is able to identify the proper process 
instance. in this example, this value, which is 
initially set by the requester (i.e., customerbp) 
and then propagated to the provider, is supposed 
to be unique. 
wsdl document
the bpel process salesbp is layered on top of the 
wsdl document “sales.wsdl” shown in figure 21. 
in particular, the first part of the code concerns 
the description of the messages exchanged by the 
service, and their mapping with the related ele -
ments in the salesx.xsd schema (lines 2-16). in the 
01: <schema ...>
02:   <element name="rfq" type="rfqmsgtype"/>
03:   <element name="quote" type="quotemsgtype"/>
04:   <element name="order" type="quotemsgtype"/>
05:   <element name="cancelorder" type="quotemsgtype"/>
06:   <element name="rejectrfq" type="rejectrfqmsgtype"/>
07:   <complextype name="rfqmsgtype">
08:     <sequence>
09:       <element name="rfqid" type="string"/>
10:       <element name="description" type="string"/>
11:       <element name="amount" type="integer"/>
12:       <element name="to" type="datetime"/>
13:     </sequence>
14:   </complextype>
15:   <complextype name="quotemsgtype">
16:     <sequence>
17:       <element name="rfqid" type="string"/>
18:       <element name="cost" type="double"/>
19:     </sequence>
20:   </complextype>
21:   <complextype name="rejectrfqmsgtype">
22:     <sequence>
23:       <element name="rfqid" type="string"/>
24:       <element name="reason" type="string"/>
25:     </sequence>
26:   </complextype>
27: </schema>figure 20.  xml schema definition - salesx.xsd  173service-oriented processes
second part, two port types called “providerpt” 
and “requesterpt” are defined: the former groups 
all the input messages of the salesbp process, 
that is, rfq, order  and cancelorder  (lines 17-27), 
the latter groups all its output messages, that is, 
quote  and rejectrfq  (lines 28-35). each message 
is enclosed in a corresponding operation featuring 
the same name; each operation is asynchronous 
(i.e. one-way operation) since it contains only one 
input message. 
bpel requires the port types involved in an 
interaction to be included in a partner link type 
construct together with their corresponding roles. 
therefore the partner link type “salesplt” has 
been defined, featuring two roles: provider (played 
by salesbp) and requester (played by custom -
erbp), assigned to port types “providerpt” and 
“requesterpt,” respectively (lines 36-43).
bpel process definition
figure 22 shows an excerpt from the bpel code 
that defines an executable salesbp process. a 
bpel process basically consists of a header, 
regarding the general process definition, and the 
process flow, which will be concretely executed 
by the bpel engine.
in the initial part, a partner link named 
“salespl” is defined (lines 2-5): it refers to the 
partner link type “salesplt” previously declared 
in the wsdl file and is used to allow the process 
to interact with its partner (customerbp). salespl 
has two roles: provider, played by the process 
itself (line 3), and requester, played by the cus -
tomer (line 4). a list of variables is also declared, 
which corresponds to the messages handled by 
the process (lines 6-13), and a correlation set 
called “salescs”, where rfqid  (set as a value of 
the so-called properties  attribute) contains the 
information for routing messages to the correct 
process instance (lines 14-16).
the process flow (lines 17-105) is basically 
a sequence of three activities: a receive , a check 
on some data and a switch , corresponding to the 01: <definitions name="sales".../>
02:   <message name="rfqmsg">
03:     <part name="payload" element="rfq"/>
04:   </message>
05:   <message name="ordermsg">
06:     <part name="payload" element="order"/>
07:   </message>
08:   <message name="quotemsg">
09:     <part name="payload" element="quote"/>
10:   </message>
11:   <message name="cancelordermsg">
12:     <part name="payload" element="cancelorder"/>
13:   </message>  
14:   <message name="rejectrfqmsg">
15:     <part name="payload" element="rejectrfq"/>
16:   </message>
17:   <porttype name="providerpt">
18:     <operation name="rfq">
19:       <input message="rfqmsg"/>
20:     </operation>
21:     <operation name="order">
22:       <input message="ordermsg"/>
23:     </operation>
24:     <operation name="cancelorder">
25:       <input message="cancelordermsg"/>
26:     </operation>
27:   </porttype>
28:   <porttype name="requesterpt">
29:     <operation name="quote">
30:       <input message="quotemsg"/>
31:     </operation>
32:     <operation name="rejectrfq">
33:       <input message="rejectrfqmsg"/>
34:     </operation>
35:   </porttype>
36:   <partnerlinktype name="salesplt">
37:     <role name="provider">
38:       <porttype name="providerpt"/>
39:     </role>
40:     <role name="requester">
41:       <porttype name="requesterpt"/>
42:     </role>
43:   </partnerlinktype>
44:   . . .
45: </definitions>figure 21.  wsdl interface document - sales.
wsdl174  service-oriented processes
001: <process name="salesbp"...>
002:  <partnerlinks>
003:    <partnerlink name="salespl" myrole="provider" 
004:      partnerrole="requester" partnerlinktype="salesplt"/>
005:  </partnerlinks>
006:  <variables>
007:    <variable name="rfq" messagetype="rfqmsg"/>
008:    <variable name="quote" messagetype="quotemsg"/>
009:    <variable name="order" messagetype="ordermsg"/>
010:    <variable name="cancelorder" messagetype="cancelordermsg"/>
011:    <variable name="rejectrfq" messagetype="rejectrfqmsg"/>
012:    <variable name="goodsavailable" type="boolean"/>
013:  </variables>
014:  <correlationsets>
015:    <correlationset name="salescs" properties="rfqid"/>
016:  </correlationsets>
017:  <sequence>
018:    <receive name=" receiverfq " partnerlink="salespl" 
019:      porttype="providerpt" operation="rfq" variable="rfq"
020:      createinstance="yes">
021:      <correlations>
022:        <correlation set="salescs" initiate="yes"/>
023:      </correlations>
024:    </receive>
025:    ...checkavailability : set variable "goodsavailable" to true
026:       or false...
027:    <switch>
028:      <case condition="getvariabledata('goodsavailable')">
029:        <sequence>
030:          <assign name=" preparequote ">
031:           <copy>
032:            <from variable="rfq" part="payload" query="/rfq/rfqid"/>
033:            <to variable="quote" part="payload" query="/quote/rfqid"/>
034:           </copy>
035:           <copy>
036:             <from expression="120"/>
037:             <to variable="quote" part="payload" query="/quote/cost"/>
038:           </copy>
039:          </assign>
040:          <invoke name=" sendquote " partnerlink="salespl" 
041:            porttype="requesterpt" operation="quote" 
042:            inputvariable="quote">
043:            <correlations>
044:              <correlation set="salescs" initiate="no".../>
045:            </correlations>
046:          </invoke>
047:          <pick name=" receiveorder ">
048:            <onmessage partnerlink="salespl" porttype="providerpt" 
049:              operation="order" variable="order">
050:              <correlations>
051:                <correlation set="salescs" initiate="no"/>
052:              </correlations>figure 22.  bpel executable process salesbp .bpel  175service-oriented processes
053:              <scope name="processorder_s">
054:                <faulthandlers>
055:                  <catch faultname="forcedtermination">
056:                    <exit/>
057:                  </catch>
058:                </faulthandlers>
059:                <eventhandlers>
060:                  <onmessage porttype="sales:providerpt" 
061:                    operation="cancelorder" variable="cancelorder" 
062:                    partnerlink="salespl">
063:                    <correlations>
064:                      <correlation set="salescs" initiate="no"/>
065:                    </correlations>
066:                    <throw name="forcedtermination" 
067:                      faultname="forcedtermination"/>
068:                  </onmessage>
069:                </eventhandlers>
070:                ...processorder...
071:              </scope>
072:            </onmessage>
073:            <onalarm 
074:              until="getvariabledata('rfq','payload','/rfq/to')">
075:              <empty/>
076:            </onalarm>
077:          </pick>
078:        </sequence>
079:      </case>
080:      <otherwise>
081:        <sequence>
082:          <assign name="preparerejectrfq">
083:            <copy>
084:              <from variable="rfq" part="payload" 
085:                query="/rfq/rfqid"/>
086:              <to variable="rejectrfq" part="payload"
087:                query="/rejectrfq/rfqid"/>
088:            </copy>
089:            <copy>
090:              <from expression="'goods unavailable'"/>
091:              <to variable="rejectrfq" part="payload"... 
092:                query="/rejectrfq/reason"/>
093:            </copy>
094:          </assign>
095:          <invoke name="sendrejectrfq" partnerlink="salespl" 
096:            porttype="requesterpt" operation="rejectrfq" 
097:            inputvariable="rejectrfq">
098:            <correlations>
099:              <correlation set="salescs" initiate="no".../>
100:            </correlations>
101:          </invoke>
102:        </sequence>
103:      </otherwise>
104:    </switch>
105:  </sequence>
106: </process>figure 22.  continued176  service-oriented processes
main flow depicted in figure 15. through the first 
activity, receiverfq, a new process instance is 
created once the initial message rfq is received 
(line 20). this is then copied into variable rfq 
(line 19), and the current instance is tagged with 
the value read from the correlation set “salescs” 
(lines 21-23). the second activity, checkavailabil -
ity (not shown in the code for simplicity), sets the 
boolean variable goodsavailable  to “true” if the 
amount of the goods being requested is available, 
otherwise to “false”.
next, the switch  activity checks the value of 
goodsavailable  to determine whether or not to 
continue processing the request for quote. this 
corresponds to take one of the two branches in 
the switch  activity (line 28).
if the goods are available, the case branch 
will be executed leading to a sequence of four 
sub-activities, as shown in figure 15 under the 
[goods available] branch. the first activity is the 
assign  preparequote (lines 30-39), through which 
salesbp can generate the quote  message to be sent 
to the customer copying into variable quote  the 
value of rfqid  taken out from variable rfq and 
setting the amount of the offer to 120 (in a real 
scenario, this value can be read from a proper 
database). then the quote is sent by means of 
the following invoke activity, sendquote (lines 
40-46), using the same correlation set “salescs” 
(lines 43-45). now the process should be able to 
receive an order  within a given time-limit: if this 
happens the order can be processed, otherwise the 
process must end. accordingly, receiveorder is 
realised with a pick activity specified to wait for the 
order  to arrive ( onmessage  branch – lines 48-72) 
or for the corresponding timeout alarm to go off 
(onalarm  branch – lines 73-76). in more detail, 
if the order  arrives before the timeout expires, it 
will be processed by the system; otherwise, the 
process will terminate doing nothing (specified 
by an empty  activity – line 75). assume that the 
onmessage  branch is taken. the execution of the 
activity processorder may be interrupted when a 
cancelorder  message arrives. for this reason, a scope activity, processorder_s, is defined (lines 
53-71), featuring a fault handler, an event handler 
and having processorder as its main activity.
in particular, the event handler (lines 59-69) 
captures the receipt of a cancelorder  message 
during the processing of the order, and then throws 
a “forcedtermination” fault, which interrupts the 
above order processing (lines 66-67). this fault 
will be immediately caught by the fault handler 
attached to the scope (lines 54-58), and as a result, 
the process will be forced terminate. note that the 
exit activity (within the fault handler – line 56) 
models the explicit termination, since a bpel 
process automatically ends when there is nothing 
left to do. the timeout value which triggers the 
onalarm  branch is extrapolated from the field to 
of variable rfq (line 74).
on the other hand, if the goods are unavailable,  
the otherwise branch of the switch  is executed 
incorporating two activities (lines 80-103), as 
illustrated in figure 15 under the [goods unavail -
able] branch. with the first one, preparerejectrfq, 
salesbp copies into variable rejectrfq  the value 
of rfqid  taken out from variable rfq, and sets 
the reason  of the rejection with the string “goods 
unavailable” (lines 82-94). the second activity, 
sendrejectrfq allows the process to send the 
message rejectrfq  back to the customer, report -
ing the rejection (lines 95-101).
now, we take closer look into the correlation 
mechanism used in this example. when the rfq 
is sent by an instance of customerbp, the bpel 
run-time system performs the following tasks 
step by step. it generates a new instance of the 
receiving process salesbp (line 20), reads the 
value of rfqid from the input message, initiates 
the corresponding correlation set “salescs,” and 
associates a tag with that value to the newly gen -
erated instance (lines 21-23). next, if the amount 
in the request is available (line 28), the quote  is 
sent back to the customer with the same correla -
tion set as rfq (lines 40-46), and hence it will be 
delivered to the requester process instance that 
previously sent the rfq. when an order  is sent   177service-oriented processes
by the customer, since it has the same correlation 
set as the quote  and rfq, it will be delivered to 
the process instance of salesbp that previously 
sent the quote  (lines 48-52). analogously, mes -
sages rejectrfq  and cancelorder  are sent to the 
correct instances of customerbp (lines 95-101) 
and salesbp (lines 60-65, for the correspond -
ing receipt). therefore in this example, from a 
global point of view, customerbp is the initiator 
for the correlation set salescs, whilst salesbp is 
the follower.
bpel process execution
we use oracle bpel process manager platform 
10.1.2 (see http://www.oracle.com/ technol -
ogy/products/ias/bpel) to edit and execute the 
salesbp process. figure 23 provides a graphical 
view of the bpel process definition of salesbp 
in oracle jdeveloper, a bpel editor integrated in 
the oracle platform. in jdeveloper, both the code 
and graphical perspectives are available to the 
user. after compiling the source files (including 
“salesbp.bpel,” “sales.wsdl” and “salesx.xsd”), a 
bpel process can be exposed as a web service 
deployed in a compliant run-time environment. a 
screenshot showing a running instance of salesbp 
on top of the oracle bpel engine is depicted in 
figure 24. in the running instance, the amount 
of the goods being requested by the customer is 
available and the process salesbp is waiting for 
an order from the customer.
note that in the salesbp process pictured in 
figures 23 and 24, activity checkavailability 
has been implemented by means of a scope 
(checkavailability_s) which encloses the 
necessary activities to interact with another 
partner link representing an internal web 
service. this service is responsible to check the 
availability of the goods and to send the result 
back to salesbp.bpel extensions
the bpel specification defines only the kernel 
of bpel, which mainly involves the control logic 
of bpel, limited definitions on the data handling 
and even less in the communication aspect. given 
the fact that bpel is already a very complicated 
language, a complete bpel specification covering 
full definitions of bpel will make the specifica -
tion less maintainable and the corresponding 
implementation will become less manageable. for 
this reason, the oasis technical committee on 
ws-bpel decides to keep the scope of the current 
specification and allows future extensions to be 
made in separate documentations. so far, there 
have been three extensions proposed to bpel.
bpel-spe. bpel currently does not support 
the modularization and reuse of “fragments” of a 
business process. this has driven the publication 
of a joint proposal of ws-bpel extension for sub-
processes, known as bpel-spe ( kloppmann, 
koenig, leymann, pfau, richay �en, riegen, et 
al., 2005 september ), by two major companies 
involved in web services standards: ibm and 
sap. bpel-spe proposes an extension to bpel 
that allows for the definition of sub-processes  
which are fragments of bpel code that can be 
reused within the same or across multiple bpel 
processes.
bpel4people. in practice, many business 
process scenarios require human user interac -
tions. for example, it may be desirable to define 
which people are eligible to start a certain business 
process; a process may be stuck because no one 
has been assigned to perform a particular task; 
or it is not clear who should perform the task in 
hand. bpel currently does not cover human user 
interactions. to fill in this blank, ibm and sap 
have recently proposed an extension to bpel, 
namely bpel4people  (kloppmann, koenig, 
leymann, pfau, richay �en, riegen, et al., 2005 
july). bpel4people  mainly defines how human 
tasks can be implemented in a process. this can 
be viewed as to add (human) resource and resource 178  service-oriented processes
figure 23. oracle jdeveloper 10.1.2: graphical view of the bpel process salesbp  179service-oriented processes
figure 24.  oraclebpel process manager console 10.1.2: execution flow of a running instance of the 
bpel process salesbp
allocation considerations to bpel. in parallel, 
another tool vendor, oracle, has implemented 
its own extension to bpel for handling human 
tasks into its bpel engine.
bpelj. in bpel, everything is seen as a 
service. a bpel executable process is an im -
plementation of a service that relies on other 
services. to express that a given service uses 
certain resources, such as a database, a file or a 
legacy application, it is necessary to expose the database system, the file system or the legacy 
application as services. since bpel needs to be 
used in environments where not all resources 
are exposed as services, it is sometimes handy 
to be able to break the “all-service” paradigm of 
bpel. driven by this imperative, an extension 
of bpel allowing for java code to be inserted at 
specific points has been defined, namely bpelj  
(blow, goland, kloppmann, leymann, pfau,blow, goland, kloppmann, leymann, pfau, 
roller, rowley, 2004 march ). this is similar to). this is similar to 180  service-oriented processes
how java code can be embedded into html code 
in the context of java server pages (jsps). as 
bpel gains more adoption both in the .net and 
the java platforms, one can expect other similar 
dialects of bpel to emerge. also, as a competing 
product to bpelj, oracle has implemented its 
own java snippet for embedding java program 
into a bpel process.
bpel- rela ted research 
efforts
there has been a number of research activities 
conducted on bpel. these include: systemati -
cal evaluation of bpel based on the so-called 
workflow patterns ( van der aalst, ter hofstede,van der aalst, ter hofstede, 
kiepus �ewski, & barros, 2003 ),analysisofbpel), analysis of bpel 
process models, generating bpel code from a 
“high-level” notations, and choreography con -
formance checking based on bpel.
pattern-based analysis of bpel
there are 20 control-flow patterns (van der aalst, 
ter hofstede, kiepus �ewski, & barros, 2003) and 
40 data patterns (russell, ter hofstede, edmond, 
& van der aalst, 2005), and accordingly the 
evaluation has been performed from control-flow 
perspective (wohed, van der aalst, dumas, & ter 
hofstede, 2003) as well as from data perspective 
(russel, ter hofstede, edmond, & van der aalst, 
2005). the results of the pattern-based evaluation 
of bpel show that bpel is more powerful than 
most traditional process languages. the control-
flow part of bpel inherits almost all constructs 
of the block-structured language xlang and 
the directed graphs of wsfl. therefore, it is no 
surprise that bpel indeed supports the union of 
patterns supported by xlang and wsfl. in par -
ticular, the bpel pick construct (namely “deferred 
choice” in workflow control-flow patterns) is not 
supported in many existing workflow languages. 
from the data perspective, bpel is one of the few languages that fully support the notion of “scope 
data” elements (one of the workflow data patterns). 
it provides support for a scope construct which 
allows related activities, variables and exception 
handlers to be logically grouped together. the 
default binding for data elements in bpel is at 
process instance level and they are visible to all 
of the components in a process. in addition to the 
above evaluation of bpel, work that has been 
conducted on the pattern-based evaluation of 
oracle bpel process manager ( mulyar, 2005)mulyar, 2005 )) 
also involves the evaluation based on a set of 
43 workflow resource patterns (russell, van der 
aalst, ter hofstede, & edmond, 2005).
generating and analyzing bpel 
models
since bpel is increasingly supported by various 
engines, it becomes interesting to link it to other 
types of models. in this respect, it is insightful to 
consider the following: (1) bpel more closely re -
sembles a programming language than a modeling 
language and (2) bpel supports the specification 
of service-oriented processes at various levels of 
details, down to executable specifications, but it 
is not designed to support any form of analysis 
(e.g., behaviour verification, performance analy -
sis, etc.). in other words, bpel definitions are 
somewhere in-between the higher-level process 
models that analysts and designers manipulate 
in the early phases of the development lifecycle, 
and fully-functional code. hence, there are two 
interesting translations relating to bpel: (1) a 
translation from a higher-level notation to bpel 
and (2) a translation from bpel to a model for 
which established analysis techniques can be 
applied.
until now, attention has focused on the second 
translation. several attempts have been made to 
capture the behaviour of bpel in a formal way. a 
comparative summary of mappings from bpel to 
formal languages can be found in ( van der aalst,van der aalst, 
dumas, terhofstede,russell,verbeek,&wohed,ter hofstede, russell, verbeek, & wohed,   181service-oriented processes
2005 ). the result of comparison shows that the). the result of comparison shows that the 
work in (ouyang, van der aalst, breutel, dumas, 
ter hofstede, & verbeek, 2005) presents the first 
full formali �ation of control flow in bpel that 
has led to a translation tool called bpel2pnml 
and a verification tool called wofbpel. both 
tools are publicly available at http://www.bpm.
fit.qut.edu.au/projects/babel/tools. wofbpel is 
capable of performing useful and non-syntactic 
analysis, for example,, detection of unreachable 
activities and detection of potentially “conflictin -
greceive“ faults in a bpel process. with respect 
to the verification issues related communication 
aspects, the work in (fu, bultan, & su, 2004) 
discusses how to verify the correctness of col -
lection of inter-communicating bpel processes, 
and similarly, the work in (martens, 2005) shows 
how to check the compatibility of two services 
with respect to communication.
in industry, various tools and mappings are 
being developed to generate bpel code from a 
graphical representation. tools such as the ibm 
websphere choreographer and the oracle bpel 
process manager offer a graphical notation for 
bpel. however, this notation directly reflects 
the code and there is no intelligent mapping. this 
implies that users have to think in terms of bpel 
constructs (e.g., blocks, syntactical restrictions on 
control links, etc.). more interesting is the work 
of white (2005) that discusses the mapping of 
business process modelling notations (bpmn) 
to bpel, the work of mantell (2005) on the map -
ping from uml activity diagrams to bpel, 
and the work by koehler and hauser (2004) on 
removing loops in the context of bpel. however, 
none of these publications provides a mapping of 
some (graphical) process modeling language onto 
bpel: white (2005) and mantell (2005) merely 
present the problem and discusses some issues 
using examples and koehler and hauser (2004) 
focuses on only one piece of the puzzle. this then 
motivated the recent work on develop mappings 
from workflow nets to bpel (van der aalst & 
lassen, 2005) and from a core subset of bpmn to bpel (ouyang, van der aalst, dumas, & ter 
hofstede, 2006).
choreography conformance 
checking based on bpel
to coordinate a collection of inter-communicat -
ing web services, the concept of “choreography” 
defines collaborations between interacting parties, 
that is,, the coordination process of interconnected 
web services that all partners need to agree on. 
a choreography specification is used to describe 
the desired behaviour of interacting parties. 
language such as bpel and the web services 
choreography description language (ws-cdl) 
(kavant �as,burdett,rit �inger,fletcher,&lafon, kavant �as, burdett, rit �inger, fletcher, & lafon, 
2004 december ) can be used to define a desired) can be used to define a desired 
choreography specification.
assuming that there is a running process and 
a choreography specification, it is interesting to 
check whether each partner (exposed as web 
service) is well behaved. note that partners have 
no control over each other’s services. moreover, 
partners will not expose the internal structure 
and state of their services. this triggers the ques -
tion of conformance: “do all parties involved 
operate as described?” the term “choreography 
conformance checking” is then used to refer to 
this question. to address the question, one can 
assume the existence of both a process model 
which describes the desired choreography and 
an event log which records the actual observed 
behaviour, that is, an actual choreography. 
choreography conformance checking benefits 
from the coexistence of event logs and process 
models and may be viewed from two angles. first 
of all, the model may be assumed to be “correct” 
because it represents the way partners should 
work, and the question is whether the events in 
the log are consistent with the process model. for 
example, the log may contain “incorrect” event 
sequences which are not possible according to 
the definition of the model. this may indicate 
violations of choreography that all parties 182  service-oriented processes
previously agreed upon. second, the event log 
may be assumed to be “correct” because it is what 
really happened. in the latter case the question is 
whether the choreography that has been agreed 
upon is no longer valid and should be modified.
the work in (van der aalst, dumas, ouyang, 
ro�inat, & verbeek, 2005) presents an approach 
for choreography conformance checking based 
on bpel and petri nets (murata, 1989). based 
on a process model described in terms of bpel 
abstract processes, a petri net description of the 
intended choreography can be created by using 
the translation defined in (ouyang, van der aalst, 
dumas, & ter hofstede, 2006) and implemented 
in the tool bpel2pnml. the conformance 
checking is then performed by comparing a 
petri net and an event log (transformed from 
soap messages under monitoring). to actually 
measure conformance, a tool called conformance 
checker  has been developed in the context of the 
prom framework  (see http://www.processmining.
org, which offers a wide range of tools related to 
process mining.
bpel and semantic web t echnology
researchers in the field of semantic web have 
put forward approaches to enhance bpel proc -
ess definitions with additional information in 
order to enable automated reasoning for a variety 
of purposes. one area in which semantic web 
technology can add value to service-oriented 
processes is that of dynamic binding . the idea of 
dynamic binding is that rather than hard-coding 
in the bpel process definition (or in an associ -
ated deployment descriptor) the identities and/or 
locations of the “partner services” with which the 
bpel process interacts, these partner services 
are determined based on information that is only 
available at runtime. for example, verma, ak-ak-
kiraju, goodwin, doshi, and le e (2004) present (2004) present 
an approach to achieve dynamic binding of web services to service-oriented processes described 
in bpel by considering inter-service dependen -
cies and constraints. they present a prototype that 
can handle bpel process definitions extended 
with such dependencies and constraints and can 
exploit this additional information for runtime 
discovery of suitable web services. the paper 
also discusses another area where semantic web 
technology complements service-oriented process 
technology: that of semi-automated refinement 
of process templates described as bpel abstract 
processes (see introduction) into fully executable 
processes. an example of a tool that implements 
such refinement techniques is presented in (be -
rardi, calvanese, de giacomo, hull, & mecella,calvanese, de giacomo, hull, & mecella , 
2005).
mandell and mcilraith (2003) present another 
approach to dynamic binding of web services 
to bpel processes. their approach is based on 
the daml web service ontology (daml-s) 
(ankolekar, burstein, hobbs, lasilla, martin, 
mcdermott, mcilraith, narayanan, paolucci, 
payne, & sycara, 2002), the daml query lan -
guage (dql) (fikes, hayes, & horrocks, 2002), 
and the java theorem prover (jtp) (frank, 1999) 
which implements dql. other approaches to 
capture web service semantics include wsdl-s 
(akkiraju, farrell, miller, nagarajan, schmidt, 
sheth, & verma, 2005) and owl-s (martin et 
al., 2005).
while the potential outcomes of these and simi -
lar research efforts are appealing, the scalability 
of the proposed techniques is still unproven and 
the involved tradeoffs restrict their applicability. 
several questions remain open such as: “which 
languages or approaches to describe service 
semantics provide the best tradeoffs between 
expressiveness and computational complexity?” 
or “how much can a user trust the decisions made 
by an automated web service discovery engine, 
especially at runtime?”  183service-oriented processes
conclusion
in this chapter, we have presented the core con -
cepts of bpel and the usage of its constructs to 
describe executable service-oriented processes. 
we have also discussed extensions to bpel that 
have been proposed by tool vendors to address 
some of its perceived limitations, as well as 
long-term challenges related to the use of bpel 
in the context of rigorous system development 
methodologies.
currently, bpel is being used primarily as a 
language for implementing web services using 
a process-oriented paradigm. in this respect, 
bpel is competing with existing enhancements 
to mainstream programming environments such 
as wse and wcf (which enhance the microsoft 
.net framework with functionality for web service 
development), or apache axis and beehive (which 
do the same for the java platform). certainly, bpel 
is making inroads in this area, and there is little 
doubt that it will occupy at least a niche position in 
the space of service implementation approaches. 
several case studies related to the use of bpel in 
system development projects have been reported 
in the trade press. these include a report of bpelthese include a report of bpel 
use at the european space agency and in an out -
sourcing project conducted by policy systems for 
a state health care service (http://tinyurl.com/zrcje 
and http://tinyurl.com/krg3o).
however, it must not be forgotten that bpel can 
also be used to describe the behaviour of services 
at a more abstract level. unfortunately, up to now, 
tool vendors have given little attention to exploring 
the possibilities opened by the description of bpel 
abstract processes. bpel abstract processes can be 
used to represent “service behaviour” at different 
levels of details. in particular, they enable the 
representation of temporal, casual and exclusion 
dependencies between message exchanges. in this 
respect, bpel abstract processes can be viewed 
as adding “behaviour semantics” on top of the 
basic structural definitions of service interactions 
provided by wsdl interfaces. two open questions at the moment are: (1) how to best exploit this 
additional behaviour semantics in order to support 
the analysis, testing, operation and maintenance 
of service-oriented systems; (2) what level of 
automated support can be realistically provided 
to aid in refinement of abstract bpel processes 
into executable ones. these and the other research 
directions reviewed in this chapter are only the tip 
of the iceberg of what can be achieved when richer 
semantic descriptions of web services covering 
behavioural aspects are available.
references
akkiraju, r., farrell, j., miller, j., nagarajan, m., 
schmidt, m., sheth, a., & verma, v. (2005, april). 
web service semantics – wsdl-s  (technical 
note). university of georgia and ibm. retrieved 
october 18, 2006, from http://lsdis.cs.uga.edu/li -
brary/download/wsdl-s-v1.html.
ankolekar, a., burstein, m., hobbs, j., lasilla, 
o., martin, d., mcdermott, d., mcilraith, s., 
narayanan, s., paolucci, m., payne, t., & sycara, 
k. (2002). daml-s: web service descriptiondaml-s: web service description 
for the semantic web. in proceedings of the 1st 
international semantic web conference  (pp. 
348-363).
bea systems, microsoft, ibm & sap (2003, 
may). business process execution language for 
web services (bpel4ws) . retrieved october retrieved october 
18, 2006, from ftp://www6.software.ibm.com/
software/developer/library/ws-bpel.pdf.
berardi, d., calvanese, d., de giacomo, g., 
hull, r., & mecella, m. (2005). automatic 
composition of transition-based semantic web 
services with messaging. in proceedings of the 
31st international conference on very large data 
bases  (pp. 613-624).
blow, m., goland, y., kloppmann, m., leymann, 
f., pfau, g., roller, d., & rowley, m. (2004, 184  service-oriented processes
march).  bpelj: bpel for java  (white paper). 
bea and ibm.
casati, f., & shan, m.-c. (2001). dynamic and 
adaptive composition of e-services. information 
systems, 26 (3), 143-162.
curbera, f., duftler, m., khalaf, r., nagy, w., 
mukhi, n., & weerawarana, s. (2002). unravelingunraveling 
the web services web: an introduction to soap, 
wsdl, and uddi. ieee internet computing , 
6(2), 86-93.
fikes, r., hayes, p., & horrocks, i. (2002). daml 
query language, abstract specification. re -
trieved october 18, 2006, from http://www.daml.
org/2002/08/dql/dql.
frank, g. (1999) a general interface for interaction 
of special-purpose reasoners within a modular 
reasoning system. in proceedings of the 1999 
aaai fall symposium on question answering 
systems  (pp. 57-62).
fu, x., bultan, t., & su, j. (2004). analysis of 
interacting bpel web services. in proceedings of 
the 13th international conference on world wide 
web (pp. 621-630). new york, ny: acm press.
kavant �as, n., burdett, d., rit �inger, g., fletcher, 
t., & lafon, y. (2004, december). web services 
choreography description language version 1.0 
(w3c working draft 17). retrieved october 18, 
2006, from http://www.w3.org/tr/2004/wd-ws-
cdl-10-20041217/.
kloppmann, m., koenig, d., leymann, f., pfau, 
g., richay �en, a., riegen, von, c., schmidt, p., 
& trickovic, i. (2005, july). ws-bpel extensionws-bpel extension 
for people: bpel4people. a joint white paper 
by ibm and sap.
kloppmann, m., koenig, d., leymann, f., pfau, 
g., richay �en, a., von riegen, c., schmidt, p., 
& trickovic, i. (2005, september). ws-bpelws-bpel 
extension for sub-processes: bpel-spe. a joint 
white paper by ibm and sap. koehler, j., & hauser, r. (2004). untangling 
unstructured cyclic flows: a solution based on 
continuations. in proceedings of otm con -
federated international conferences, coopis, 
doa, and odbase 2004  (pp. 121–138). berlin:berlin: 
springer-verlag.
leymann, f. (2001). web services flow language, 
version 1.0. retrieved october 18, 2006, from 
http://www-306.ibm.com/software/solutions/
webservices/pdf/wsfl.pdf
mandel, d., & mciiraith s. (2003). adapting 
bpel4ws for the semantic web: the bottom 
up approach to web service interoperation. in 
proceedings of the 2nd international semanticinternational semantic 
web conference .
mantell, k. (2005). from uml to bpel. re -
trieved october, 18, 2006, from http://www.ibm.
com/developerworks/webservices/library/ws-
uml2bpel
martens, a. (2005). analy �ing web service 
based business processes. in proceedings of the 
8th international conference on fundamental 
approaches to software engineering  (pp. 19-33). 
berlin: springer-verlag.
martin, d., et al. (2005, november). owl-s: se -
mantic markup for web services, w3c member 
submission. retrieved october 18, 2006, from 
http://www.w3.org/submission/owl-s 
mulyar, n. (2005). pattern-based evaluation of 
oracle-bpel  (bpm center report bpm-05-24). 
bpmcenter.org.
murata, t. (1989). petri nets: properties, analysispetri nets: properties, analysis 
and applications. proceedings of the ieee , 77(4), 
541–580.
oasis (2005, december 21). web services 
business process execution language version 2.0 
(committee draft). retrieved october 18, 2006,retrieved october 18, 2006, 
from http://www.oasis-open.org/committees/http://www.oasis-open.org/committees/
download.php/16024/wsbpel-specification-draft-
dec-22-2005.htm  185service-oriented processes
oasis web services business process execution 
language tc (2006). retrieved october 18, 2006, 
from http://www.oasis-open.org/committees/http://www.oasis-open.org/committees/
tc_home.php?wg_abbrev=wsbpel.
ouyang, c., van der aalst, w.m.p., breutel, s., 
dumas, m., ter hofstede, a.h.m., & verbeek, 
h.m.w. (2005). formal semantics and analysis 
of control flow in ws-bpel  (bpm center report 
bpm-05-15). bpmcenter.org.
ouyang, c., van der aalst, w.m.p., dumas, m., & 
ter hofstede, a.h.m. (2006). translating bpmn 
to bpel  (bpm center report bpm-06-02). bp -
mcenter.org.
russell, n., ter hofstede, a.h.m., edmond, d., 
& van der aalst, w.m.p. (2005). workflow data 
patterns: identification, representation and tool 
support. inin proceedings of the 24th international 
conference on conceptual modeling (pp. 353-353-
368). berlin: springer-verlag.). berlin: springer-verlag.
russell, n., van der aalst, w.m.p., ter hofstede, 
a.h.m., & edmond, d. (2005). workflow resource 
patterns: identification, representation and tool 
support. inin proceedings of the 17th international 
conference on advanced information systems 
engineering (pp. 216 -232). berlin: springer--232). berlin: springer-). berlin: springer-
verlag.
thatte, s. (2001). xlang web services for 
business process design. retrieved october 18, 
2006, from http://www.gotdotnet.com/team/
xml_wsspecs/xlang-c/default.ht m 
van der aalst, w.m.p., dumas, m., ouyang, c., 
ro�inat, a., & verbeek, h.m.w. (2005). chore -
ography conformance checking: an approach based on bpel and petri nets  (bpm center 
report bpm-05-25). bpmcenter.org.
van der aalst, w.m.p., dumas, m., ter hofstede, 
a.h.m., russell, n., verbeek, h.m.w., & wohed, 
p. (2005). life after bpel ��in life after bpel �� in proceedings of 
european performance engineering workshop 
and international workshop on web services and 
formal methods  (pp. 35-50). berlin: springer-(pp. 35-50). berlin: springer-
verlag.
van der aalst, w.m.p., & lassen, k.b. (2005). 
translating workflow nets to bpel (beta work -
ing paper series). eindhoven, the netherlands: 
eindhoven university of technology. 
van der aalst, w.m.p., ter hofstede, a.h.m., kie -
pus�ewski, b., & barros, a.p. (2003). workflowworkflow 
patterns. distributed and parallel databases , 
14(1), 5-51.
verma, k., akkiraju, r., goodwin, r., doshi, p., 
& lee, j. (2004). onaccommodatinginter-serviceon accommodating inter-service 
dependencies in web process flow composition. 
in proceedings of the american association for 
artificial intelligence (aaai) 2004 spring sym -
posium. stanford, ca: aaai.
white, s. (2005). using bpmn to model a bpel 
process. bptrends, 3 (3), 1-18. retrieved october, 
2006, from http://www.bptrends.com/
wohed, p., van der aalst, w.m.p., dumas, m., 
& ter hofstede, a.h.m. (2003). analysis of webanalysis of web 
services composition languages: the case of 
bpel4ws. in proceedings of the 22nd interna -
tional conference on conceptual modelling (pp. 
200-215 ). chicago: springer-verlag.). chicago: springer-verlag.. chicago: springer-verlag.186  service-oriented processes
appendex 1
exercises
1. describe two different ways supported by bpel for describing business processes. what are the 
differences between them? what are the usages of them?
2. describe how bpel uses wsdl, xml schema, and xpath. 
3. define the partner link between a purchase order process and the external shipping service, and 
the corresponding partner link type. in this relationship, the purchase order process plays the 
role of the service requester, and the shipping service plays the role of the service provider. the 
requester role is defined by a single port type called “shippingcallbackpt”. the provider role iscalled “shippingcallbackpt”. the provider role is 
defined by a single port type called “shippingpt”.
4. consider the following fragments of a bpel process definition:
 (a) write down all possible execution sequences of activities in the above definition.
(b) can we add the following pick activity in parallel to the two existing sequence  activities in the 
above flow? if yes, write down all possible execution sequences of activities in this updated 
process definition, otherwise explain why not. 
 
5. this exercise involves two interacting bpel processes p1 and p2. p1 consists of a sequence ofp1 consists of a sequence of 
activities starting with a receive  activity and ends with a reply  activity. the pair of receive  and reply  
defines an interaction with process p2. in p2, there is an invoke  activity calls a request-responsecalls a request-response 
operation on p1 , which triggers the executions of the above pair of, which triggers the executions of the above pair of receive  and reply  activities in 
p1.
(a) define an appropriate partner link between p1 and p2 (assume that p1 plays myrole , and p2 
plays partnerrole ).
(b) define the pair of receive  and reply  activities in p1.
(c) define the invoke  activity in p2.
6. describe the difference between switch  and pick constructs. given the four scenarios described 
below, which of them can be defined using switch  and which of them can be defined using pick?
(a) after a survey is sent to a customer, the process starts to wait for a reply. if the customer 
returns the survey in two weeks, the survey is processed; otherwise the result of the survey 
is discarded.
(b) based on the client’s credit rating, the client’s loan application is either approved or requires 
further financial capability analysis.
(c) after an insurance claim is evaluated, based on the findings the insurance service either 
starts to organize the payment for the claimed damage, or contacts the customer for further 
details.
(d) the escalation service of a call centre may receive a storm alert from a weather service which 
triggers a storm alert escalation, or it may receive a long waiting time alert from the queue 
management service which triggers a queue alert escalation.
7. the diagram below sketches a process with five activities a0, a1, a2, a3 and a4. a multi-choice 
node splits one incoming control flow into multiple outgoing flows. based on the conditions as -
sociated with these outgoing flows, one or more of them may be chosen. a sync-merge node 
synchronises all active incoming control flows into one outgoing flow. based on the above, sketch   187service-oriented processes
two possible bpel definitions for this process using sequence , flow and switch constructs. also, 
sketch another bpel definition of the process using only control link constructs (within a flow).
 
8. the definition below specifies the execution order of the activities within a bpel process:
(a) can we create the following two control links? justify your answer.
i) a control link leading from “activitya1” to “activitya3”
ii) a control link leading from “activitya3” to “activitya5”
(b) can we re-define the original process using only control links within the flow activity? if 
so, re-write the process definition, otherwise explain why not.
(c) assume that there exist two control links: one leading from “activitya1” to “activitya4”, the 
other from “activitya2” to “activitya4”. both links have a default transition condition, that 
is, a transition condition that always evaluates to true if the source of the link is executed. 
consider the following two scenarios: 
i) “activitya4” has a join condition that is a disjunction  of all incoming links.
ii) “activitya4” has a join condition that is a conjunction  of all incoming links.
  in both scenarios, “activitya4” has itshas its suppressjoinfailure  attribute set to “yes”. 
determine whether “activitya4” will be performed in each scenario ��justify your “activitya4” will be performed in each scenario �� justify your 
answer and provide a possible execution sequence for each scenario.
(d) what could verification do when analysing a syntactically correct bpel process �� argue 
why automated verification of a bpel specification is useful.
9. sketch the control logic of a bpel process for requesting quotes from an a priori  known set of 
n suppliers. the process is instantiated upon receiving a quoteservicerequest  from the client, 
and then a quoterequest  is sent in parallel to each of the n suppliers (supplier1, supplier2, …, 
suppliern). next, the process waits for quoteresponse from these suppliers. assume that (a) each 
supplier replies with at most one response and (b) only m out of n responses are required (m<=n), 
which means that after receiving the responses from m suppliers, the process can continue without 
waiting for the responses from the remaining n-m suppliers. to provide the ability to define how 
many responses are required, a loop is created that repeats until the required number of responses 
are received. the responses are collected in the order in which they are received. for each response 
received, the number of responses received ( nofresponse ) is incremented, and the variable contain -
ing the result ( result ) so far is updated. also, to provide the ability to stop collecting responses 
after some period of time (e.g., 2 hours), the above loop is contained within a scope activity that 
has an alarm event handler. if the alarm is triggered, an exception ( timeoutfault ) is thrown to 
be caught in the outer scope, thus allowing the process to exit the loop before it finishes. if the 
exception is thrown, then all that needs to be done is to incorporate a “timed out” indication to 
the result . finally, the process completes by sending the result  to the client. 
10. below is the bpel code for the definition of a supplier abstract process. since it is an abstract 
bpel process, not all elements are fully specified. in particular, you may note that the condition 
in each while  loop is omitted, which means that the loop may execute for an arbitrary number of 
times.appendex 1. continued188  service-oriented processes
(a) given the following sequences of executions, indicate which of them are possible and which 
of them are not possible based on the above definition. justify your answer.
i) receive order ;
ii) receive order , send orderresponse ;
iii) receive order , send orderresponse , receive change ;
iv) receive order , send orderresponse , send orderresponse , receive change , send order -
changeresponse ;
v) receive order , send orderresponse , receive change , send orderresponse , send order -
changeresponse .
(b) in the current process definition, the execution sequence “receive order , receive change , send 
orderchangeresponse ” is not possible. indicate what minimal changes need to be made to 
the current process definition, so that this execution sequence becomes possible and all the 
previous valid execution sequences are preserved.appendex 1. continued