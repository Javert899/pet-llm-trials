conformance checking of services using the
best matching private view
richard m uller1;2and wil m. p. van der aalst2and christian stahl2
1institut f ur informatik, humboldt-universit at zu berlin, germany
richard.mueller@informatik.hu-berlin.de
2department of mathematics and computer science,
technische universiteit eindhoven, the netherlands
fw.m.p.v.d.aalst, c.stahl g@tue.nl
abstract. we investigate whether a running implementation of a ser-
vice conforms to its formal specication in a setting, where only recorded
behavior of that implementation is given. existing conformance check-
ing techniques can be used to measure the degree of conformance of the
recorded behavior and its public view but may produce \false negatives",
because a correct implementation (i.e., private view ) may deviate signif-
icantly from its specication. the private view may, for example, reorder
some activities without introducing any problems, yet traditional confor-
mance checking would penalize such changes unjustiably. to overcome
this problem, we present a novel approach that determines a best match-
ingprivate view. we show that among the innitely many private views,
there is a canonical best matching private view. while the represented
theory is general and can be applied to arbitrary service models, the
implementation is currently limited to acyclic service models.
1 introduction
service-oriented computing (soc) [17] aims at building complex systems by ag-
gregating less complex, independently-developed building blocks called services .
a service encapsulates a business functionality and has an interface to interact
with its environment|that is, other services|via asynchronous message passing.
aggregating services results again in a service. this modular design of complex
systems requires a notion of service conformance to safely replace one service
(the specication) by another one (the implementation).
service conformance has been extensively studied in literature (e.g., [6,19]),
but most approaches can hardly be used in practice, because they assume that
the implementation and the specication of a service are given as formal models
which do not change over time. however, it is often not realistic to assume that
there exists an up-to-date formal model of the implementation . even if there ex-
ists a formal model of the implementation, it can dier signicantly from the
actual implementation: the formal model may have been implemented incor-
rectly, or the implementation may have been changed over time. nevertheless,
most implementations provide some kind of recorded behavior, also referred to assoftwaresystemeventlogscheckconformanceservice compositioncontractservice compositionimplementationpublicviewprivateviewfig. 1: illustration of our conformance checking approach
event log , transaction log, or audit trail [3]. therefore, in this paper, we assume
the implementation to be unknown. we only rely on a formal model of the speci-
cation and an event log of the unknown implementation. to this end, we answer
the question whether there exists a conforming implementation which may have
produced the event log . hence, our approach yields a necessary condition for
conformance of the unknown implementation with the given specication.
in this paper, we focus on conformance checking based on historic data (\of-
ine" conformance checking). however, the approach can be applied on-the-y
(\online" conformance checking or monitoring); that is, streaming event data
can be monitored at runtime and conformance can be checked immediately.
we investigate conformance checking in the setting of a contract among ser-
vices. a contract is a (formal) specication of a complex service that involves
several cooperating enterprises [1,6]. later on, each involved party implements
its share of the contract. a party's share of the contract|that is, the public
view|and the implementation thereof may dier signicantly but the overall
implementation has to conform to the contract. correctness of a contract (i.e.,
in our setting, the possibility to always terminate) has been formalized by the
accordance relation [19]: if every implementation accords with its public view,
then the correctness of the contract is preserved and the overall implementation
is correct. a party's implementation that accords with the party's public view is
aprivate view . accordance thereby guarantees that any environment that coop-
erates with a party's public view can cooperate with its respective private view.
instead of checking accordance of the public view and the implementation, we
check whether the event log of the implementation conforms to the public view.
figure 1 illustrates a contract involving four parties and its implementation. we
use recorded behavior in form of an event log of a running private view to check
conformance with its public view.
the main contribution of this paper is an approach to check conformance
of service in the setting of a contract when the public view of a party's share
is a given as a formal model and only observed behavior of its running imple-mentation is known. we show that it is not sucient to check conformance of
the observed behavior with its public view: accordance allows parties to reorder
some activities of their share, but traditional conformance checking would pe-
nalize such changes unjustiably. therefore, we need to check conformance of
the observed behavior with all possible private views instead. however, as there
are innitely many private views in general, this approach is not tractable. we
overcome this by proving the existence of a best matching private view . if a best
matching private view does not conform to l, then no private view does. we
present an approach to construct a canonical best matching private view from
a given public view using existing work on maximal and most-permissive con-
trollers. moreover, we show how to use a best matching private view not only
to check, but to measure conformance of an event log with an unknown private
view by using existing trace alignment-based techniques from the eld of process
mining. we have implemented the construction of the canonical best matching
private view, yet restricted to acyclic service models, and use the implementation
to provide rst experimental results.
the remainder is organized as follows. to clarify our setting and our problem
statement, we continue with a motivating example in sect. 2. in sect. 3, we
provide background information on a formal model for services, contracts, and
conformance checking. in sect 4, we show our main result, the existence of a best
matching private view. experimental results on how to compute a canonical best
matching private view in sect. 5 validate our approach. in sect. 6, we review
related work and close with a conclusion.
2 motivating example
as a motivating example, consider the public view in fig. 2a, which is modeled as
an open net [21,10]|that is, a petri net extended with interface places positioned
on a dashed frame around the net. the open net public either sends message
band then receives dor sends message aand then receives cord. a token on
placep3 models successful termination, also indicated by the thicker bound of
placep3.
we illustrate the idea of service conformance checking based on observed
behavior using open net public and the event log lin fig. 2c. the event log
lthereby represents the recorded behavior of the unknown implementation of
public .lcontains information of 120 traces, partitioned into three cases. a trace
is a sequence of messages sent or received by the implementation. we assume
that each event xin a trace of a log corresponds to the sending or receiving of
xof the environment of public . we can model this environment of an open net
by adding to each x-labeled input place an x-labeled transition that produces
tokens on this place and for each x-labeled output place an x-labeled transition
that consumes tokens from this place. all other transitions of this environment
are internal and, therefore, labeled by . figure 2b illustrates this construction
for the public view public ; for convenience, we omit all labels of transitions.
we present a formal denition in sect. 3.3.t3cat4p3p2p0t1t0p1bdt2(a) open net public .
t3cat4p3p2p0t1t0p1bdt2taatbtctddcb (b) environment of public .#trace
30ad
40bc
50cda
120
(c) logl.
fig. 2: the public view public and its asynchronous environment enva(public ).
the event log lrepresents recorded behavior of the implementation of public .
to check whether lconforms to the (environment of the) public view public ,
we need to replay the traces of lon the model in fig. 2b. more precisely, we
align [2] each trace in lto a trace (i.e., a ring sequence) of the model in fig. 2b.
some example alignments for land the environment of public are:
1=ad
ad
t1tatdt32=bc
bd
t0tbtdt23=cda
ca
tct1tat4
the top row of each alignment corresponds to \moves in the log" and the
bottom two rows correspond to \moves in the model". there are two bottom
rows because multiple transitions may have the same label; the upper bottom
row consists of transition labels, and the lower bottom row consists of transitions.
if a move in the log cannot be mimicked by a move in the model, then a \ "
(\no move") appears in the upper bottom row. for example, in 2the model
in fig. 2b cannot do the last c-move, because cis not connected to the locally
enabled transition t2. if a move in the model cannot be mimicked by a move in
the log, then a \" (\no move") appears in the top row. for example, all \silent
moves" (occurrences of -labeled transitions) in the model in fig. 2b cannot be
mimicked by l. moreover, ldid not do a d-move in2whereas the model in
fig. 2b has to make this move to reach the end. by using this notation, we
distinguish between a possible but silent move (depicted by ) and no move at
all (depicted by).
informally, conformance checking of an event log land a public view n
measure \how good" each case in lcan be replayed in the environment of n.
thereby, the smaller the number of mismatches in an alignment of a case is, the
better this case can be replayed. a mismatch is a move in the log which cannot
be mimicked by the model, or a non-silent move in the model which cannot bet3cat4p4p2t0p0
p5t2t1p3bdp1t5(a) open net private .
t3cat4p4p2t0p0
p5t2t1p3bdp1t5taatbtctddcb (b) environment of private .
fig. 3: a private view private and its asynchronous environment enva(private ).
mimicked by the log. clearly, the more traces we can replay on the model the
better the implementation conforms to the public view.
however, even an implementation that accords with its public view may allow
for traces that cannot be replayed on the public view, because the accordance
relation allows parties to reorder activities of their share, for instance. as an
illustration, consider the possible implementation private in fig. 3a. it is de-
rived from the public view public by parallelizing the sending and receiving of
messages. in contrast to the public view, the implementation can, therefore, re-
ceivecafter having sent b. in this paper, we dene correctness of a contract as
a nite state-space and the possibility to always terminate. for this denition
of correctness, the open net private accords with open net public ; that is, the
implementation private is a private view of the public view public . intuitively,
every cooperating environment of public knows by receiving either aorbwhether
public is in the left or the right branch. therefore, no cooperating environment
ofpublic will sendcafter having received b, as otherwise the cooperation may
get stuck. public may operate in such an environment. in fact, it even allows for
environments that send cafter having received b.
we can replay the event log lon the model of the environment of this open
net, which is depicted in fig. 3b. some resulting alignments are:
4=ad
ad
t0t1tatdt3t55=bc
bc
t0t2tbtct4t56=cda
da
tdt0t1tat3t5
clearly, we can replay more traces on private than on public ; that is, the con-
formance check with the private view gives a better result than the conformance
check with the public view. the example clearly shows that, in general, it is not
sucient to check conformance of an event log and the model of the public view.
checking conformance on the public view may generate \false negatives"|thatis, acceptable behavior may be diagnosed as non-conforming. as there may exist
a private view such that the conformance check with that model gives a better
result, we need to check conformance of a log with all private views . the chal-
lenge thereby is that there exist innitely many private views. in this paper, we
investigate this challenge and present an approach to determine a best matching
private view for a given public view.
3 background
in this section, we provide the basic notions of petri nets and open nets for mod-
eling services and formalize private view conformance. suitability of open nets
as service model has been demonstrated by feature-complete open net semantics
for languages such as bpmn and ws-bpel [12], and the application of open
nets in existing conformance checking techniques [18].
3.1 petri nets
as a basic model, we use place/transition petri nets extended with a set of nal
markings and transition labels.
denition 1 (net). anetn= (p;t;f;m n;
) consists of a nite set pof
places , a nite set toftransitions such thatpandtare disjoint, a ow relation
f(pt)[(tp), an initial marking mn, where a marking m2b(p) is
a multiset over p, and a set 
of nal markings.
alabeled net is a netntogether with an alphabetaof actions and a labeling
functionl2t!a[fg, where =2arepresents an invisible, internal action.
graphically, a circle represents a place, a box represents a transition, and
the directed arcs between places and transitions represent the ow relation. a
marking is a distribution of tokens over the places. graphically, a black dot
represents a token. we write transition labels beside into the respective boxes.
letx2p[tbe a node of a net n. as usual,x=fyj(y;x)2fgdenotes
thepreset ofxandx=fyj(x;y)2fgthepostset ofx. we interpret presets
and postsets as multisets when used in operations also involving multisets. for
markings, we dene + and  for the sum and the dierence of two markings in
the standard way; for example, [ p1;2p2] denotes a marking mwithm(p1) = 1,
m(p2) = 2, and m(p) = 0 forp2pnfp1;p2g. ifm12b(p1) andm22b(p2),
thenm1+m22b(p1[p2) (i.e., the underlying set of elements is adjusted when
needed).
the behavior of a netnrelies on changing the markings of nby ring
transitions of n. a transition t2tisenabled at a marking m, denoted by
mt  !, if for allp2t,m(p)>0. iftis enabled at m, it can re, thereby
changing the marking mto a marking m0=m t+t. the ring of tis
denoted by mt  !m0; that is,tis enabled at mand ring it results in m0.the behavior of ncan be extended to sequences: m1t1  !:::tk 1   !mk
is a runofnif for all 0 < i < k ,miti !mi+1. a marking m0isreachable
from a markingmif there exists a (possibly empty) run m1t1  !:::tk 1   !mk
withm=m1andm0=mk; forw=ht1:::tk 1i, we also write mw !m0.
markingm0isreachable if it is reachable from initial marking mn. the set
mn=fm0j9w:mnw !m0grepresents all reachable markings of n.
in the case of labeled nets, we lift runs to traces: if mw !m0andvis obtained
fromwby replacing each transition by its label and removing all -labels, we
writemv=)m0. for example, if w=ht1t1t2t1t2t3i,l(t1) =a,l(t2) =, and
l(t3) =b, andmw !m0, thenmv=)m0withv=haaabi. the behavior of a
labeled net nis described by the runs of nleading from the initial marking to
a nal marking. the set of nal runs of a labeled net n= (p;t;f;m n;
;l) is
r(n) =f2tj9mf2
:mn !mfg, and tr(n) =f2aj9mf2
:
mn= =)mfgis the set of nal traces .
a netnisbounded if there exists a bound b2i n such that for all reachable
markingsm2mnand all places p2p,m(p)b. a reachable marking m =2
ofnis a deadlock if no transition t2tofnis enabled at m. ifnhas no
deadlock, then it is deadlock free. a net is weakly terminating if from every
reachable marking it is always possible to reach a nal marking.
3.2 open nets
we model services as open nets [21,10], thereby restricting ourselves to the com-
munication protocol of a service. in the model, we abstract from data and identify
each message by the label of its message channel. an open net extends a net
by an interface . an interface consists of two disjoint sets of input and output
places corresponding to asynchronous input and output channels. an input place
has an empty preset, and an output place has an empty postset. in the initial
marking and the nal markings, interface places are not marked.
denition 2 (open net). anopen netnis a tuple (p;t;f;m n;i;o;
 ) with
{(p[i[o;t;f;m n;
) is a net such that p,i,oare pairwise disjoint;
{for allp2i[o,mn(p) = 0, and for all m2
andp2i[o,m(p) = 0;
{the setiofinput places satises for all p2i,p=;; and
{the setoofoutput places satises for all p2o,p=;.
open netnissequentially communicating if each transition is connected to at
most one interface place . ifi=o=;, thennis aclosed net . two open nets
areinterface-equivalent if they have the same sets of input and output places.
graphically, we represent an open net like a net with a dashed frame around
it. the interface places are positioned on the frame. if an open net has at most
one nal marking, we indicate places marked in that nal marking with a thicker
bound.for the composition of open nets, we assume that the sets of transitions are
pairwise disjoint and that no internal place of an open net is a place of any
other open net. in contrast, the interfaces overlap intentionally. we require that
all communication is bilateral and directed ; that is, every shared place phas
only one open net that sends into pand one open net that receives from p. we
refer to open nets that fulll these properties as composable . we compose two
composable open nets n1andn2by merging shared interface places and turn
these places into internal places. the denition of composable thereby guarantees
that an open net composition is again an open net (possibly a closed net).
denition 3 (open net composition). open nets n1andn2arecompos-
able if (p1[t1[i1[o1)\(p2[t2[i2[o2) = (i1\o2)[(i2\o1).
the composition of two composable open nets n1andn2is the open net
n1n2= (p;t;f;m n;
;i;o ) where
{p=p1[p2[(i1\o2)[(i2\o1),
{t=t1[t2,
{f=f1[f2,
{mn=mn1+mn2,
{i= (i1[i2)n(o1[o2),
{o= (o1[o2)n(i1[i2), and
{
=fm1+m2jm12
1;m22
2g.
we want the composition of a set of services to be correct . correctness refers
to boundedness and weak termination. a user that communicates with a service
such that the composition is correct can be seen as a controller of this service.
denition 4 (controller). letb2i n. an open net cis ab-controller of an
open netnif the composition ncis a closed net, b-bounded, and weakly
terminating.
in the remainder of the paper, we abstract from the actual bound chosen
and, therefore, use the term controller rather than b-controller for convenience.
example 1. consider open nets public in fig. 2a and controller in fig. 4b.
public has the initial marking mpublic = [p0], nal markings 
=f[p3]g, output
placesaandb, and input places candd.controller has the initial marking
mcontroller = [q0], nal markings 
=f[q3]g, output places candd, and input
placesaandb. clearly, public and controller are composable and their com-
position publiccontroller is the closed net in fig. 4a with initial marking
[p0;q0] and nal markings f[p3;q3]g. as publiccontroller is 1-bounded and
weakly terminating, we conclude that controller is a controller of public , and
vice versa.
3.3 private view conformance
we see a contract as a closed net n, where every transition is assigned to one
of the involved parties x1;:::;xk. we impose only one restriction: if a place ist3cat4p3p2p0t1t0p1bdt2u2q3q1q0u0u1q2u3(a) open net publiccontroller .
cau2q3q1q0u0u1q2bdu3 (b) open net controller .
fig. 4: the open net controller and its composition with the open net public .
accessed by more than one party, it should act as a directed bilateral communi-
cation place. this restriction reects the fact that a party's public view of the
contract is a service again. a contract ncan be cut into parts n1;:::;nk, each
representing the agreed public view of a single party xi(1ik). hence, we
dene a contract as the composition of the open nets n1;:::;nk.
denition 5 (contract). letx=fx1;:::;xkgbe the set of parties and
letfn1;:::;nkgbe a set of pairwise interface-compatible open nets such that
n=n1nkis a closed net. then, nis acontract forx. fori= 1;:::;k ,
open netniis the public view of xiinnand open net n 1
i=l
j6=injis the
environment ofxiinn.
each party xican independently substitute its public view niby a private
viewn0
iif the environment of xicannot distinguish between niandn0
i[5],
which is formalized by the accordance relation [19].
denition 6 (accordance). letniandn0
ibe interface-equivalent open nets.
open netn0
iaccords with open netni, denoted by n0
ivaccni, if every controller
ofniis also a controller of n0
i.
example 2. an example of a contract involving only two parties is the closed
net in fig. 4a. in sect. 2, we have motivated that open net private accords
with open net public . thus, we can safely replace public with private without
violating the contract.
sending or receiving a message is an activity. let adenote the set of all
activities. we dene an event log as a multiset of traces over a. each trace
describes the life-cycle of a particular case in terms of the activities executed.
denition 7 (event log). anevent logliof the observed behavior of party
xiin contract nis a multiset of traces over a, i.e.,li2b(a).t3t4p3p2p0t1t0p1t2adcbd(a)envs(public ).
t3t4p4p2t0p0
p5t2t1p3p1t5adcb (b)envs(private ).
fig. 5: the synchronous environment of open nets public and private . label
is omitted.
for conformance checking of party xi, we compare the observed behavior
(event logli) with the modeled behavior ( niorn0
i). we can take two viewpoints
depending on what/when events are recorded in li. if events are recorded when
partyxiconsumes a message from n 1
ior produces a message for n 1
i, then we
can use the synchronous environment envs(ni) for conformance checking. here,
we label each transition with the adjacent interface places|if possible|and re-
move the interface places. to simplify the labeling of transitions connected to
interface places, we only consider sequentially communicating nets. that way,
each transition is labeled by a single label rather than by a set of labels. this
restriction is not signicant, as every open net can be transformed into an equiv-
alent sequentially communicating open net [10].
denition 8 (synchronous environment). the synchronous environment
of a sequentially communicating open net n= (p;t;f;m n;
;i;o ) is the la-
beled net envs(n) = (p;t;f\((pt)[(tp));mn;
;l) withl(t) =p
wherepis the unique interface place p2i[oadjacent to t2t, orl(t) =if
no such adjacent interface place exists.
example 3. figure 5 shows the synchronous environments of open nets public
and private . a transition label is depicted inside a transition with bold font to
distinguish it from the transition's identity.
if events are recorded when the environment n 1
iof partyxiconsumes
a message from party xior produces a message for party xi, then we can
use the asynchronous environment enva(ni) for conformance checking. the net
enva(n) is a net that can be constructed from nby adding to each interface
placep2i[oap-labeled transition tpinenva(n). intuitively, the construction
translates the asynchronous interface of ninto a synchronous interface with
unbounded buers described by the transition labels of enva(n).denition 9 (asynchronous environment). the asynchronous environment
of an open net n= (p;t;f;m n;i;o;
 ) is the labeled net enva(n) = (p[i[
o;t[t0;f[f0;mn;
;l) where
{t0=ftxjx2i[og,
{f0=f(tx;x)jx2ig[f (x;tx)jx2og, and
{l(t) =(
x; tx2t0
; t2t:
example 4. figures 2b and 3b show the asynchronous environments of the open
nets public and private from figs. 2a and 3a. a transition label is depicted
inside a transition with bold font to distinguish it from the transition's identity.
thus, the choice of environment depends on what is actually logged. in the re-
mainder, we will abstract from these subtle dierences and simply write env(n).
to check conformance, we need to align traces in the event log to traces
of the service (environment); that is, we need to relate \moves" in the log to
\moves" in the model. however, there may be some moves in the log that cannot
be mimicked by the model, and vice versa. for convenience, we introduce the set
al=a[fg wherex2alnfg refers to \move xin the log" and2al
refers to \no move in the log". similarly, for a labeled net n, we introduce the
setan=f(a;t)2(a[fg)tjl(t) =ag[fg where (a;t)2anrefers to
\moveain the model" and 2anrefers to \no move in the model". a \move
in the model" ( ;t) is a silent move, as it is only observable by party xi.
denition 10 (alignment). for an event log land a labeled net n, one
move in an alignment is represented by a pair ( x;y)2alansuch that
{(x;y) is a move in the log ifx2aandy=,
{(x;y) is a move in the model ifx=andy2annfg ,
{(x;y) is a move in both ifx2aandy2annfg ,
{(x;y) is an illegal move x=andy=.
we refer to a move in the model ( x;(a;t)) witha=as a silent move .aln=
f(x;y)2alanjx6= _y6=gis the set of all legal moves .
analignment of2landw2r(n) is a sequence 2alnsuch that
the projection on the rst element (ignoring ) yieldsand the projection on
the second element (ignoring ) yieldsw. the set of alignments for innis
 ;n=f2alnj9w2r(n) :is an alignment of andwg.
example 5. for an example of an alignment of a trace of an event log and a
trace of an open net, consider the six alignments 1;:::; 6in sect. 2.
given a log trace, there may be many possible alignments. to measure the
quality of an alignment, we dene a distance function on legal moves.
denition 11 (distance function). adistance function :aln!i n as-
sociates costs to legal moves in an alignment. we dene a standard distance
functionsass(a;) = 1;s(;(b;t)) = 1, for b6=;s(;(;t)) = 0;
s(a;(b;t)) = 0, fora6=anda=b; ands(a;(b;t)) =1, fora6=anda6=b.we generalize a distance function to alignments by taking the sum of the
costs of all individual moves: () =p
(x;y)2(x;y). ins, only moves where
log and model agree on the activity, and silent moves of the model have no
associated costs. moves in only the log or model have cost 1, moves where both
log and model make a move but disagree on the activity have high costs; thereby,
1should be read as a number large enough to discard the alignment. note that
sis just an example cost function; various cost functions can be dened.
thus far, we considered a specic trace of the model. however, our goal is to
identify for each log trace the best matching trace of the model. therefore, we
dene the notion of an optimal alignment .
denition 12 (optimal alignment). an alignment 2 ;nisoptimal for
a log trace 2land a labeled net nif for any02 ;n:(0)().
ifr(n) is not empty, there is at least one (optimal) alignment for any given
log trace. however, there may be multiple optimal alignments for . since our
goal is to align traces in the event log to traces of the model, we nondetermin-
istically select an arbitrary optimal alignment. therefore, we can construct a
functionnthat provides an \oracle".
denition 13 (oracle). given a log trace and a labeled net n, the oracle
nproduces oneoptimal alignment n()2 ;n.
the alignments produced by the \oracle" ncan be used to quantify confor-
mance of a log land a model n. conformance checking involves the interplay of
four orthogonal dimensions: tness ,precision ,generalization , and simplicity [2].
fitness indicates how much of the behavior in the event log is captured by the
model. a model with good tness allows for most of the behavior seen in the
event log. precision indicates whether the model is not too general. to avoid
\undertting" we prefer models with minimal behavior to represent as closely
as possible the behavior seen in the event log. generalization penalizes overly
precise models which \overt" the given log. in general, a process model should
not restrict behavior to just the behavior seen in the event log. simplicity refers
to models minimal in structure, which clearly reect the log's behavior. this di-
mension is related to occam's razor, which states that \one should not increase,
beyond what is necessary, the number of entities required to explain anything."
in the remainder, we abstract from the dimensions involved in conformance
checking: we assume a function conf that computes the conformance of an
event logland a labeled net nbased on the alignments produced by the oracle
n; that is, conf(l;n) yields a number between 0 (poor conformance) and 1
(perfect conformance) [2]. we dene private view conformance as the maximal
conformance of all private views of a given public view.
denition 14 (private view conformance). letn=n1nkbe a
contract forx=fx1;:::;xkg. letnibe the public view of xi, and letlibe
an event log of xi. let pr(ni) =fmjmvaccnigdenote the set of all private
views that accord with ni. then{m2pr(ni) is a best matching private view forniandliif for anym02
pr(ni):conf(li;env(m))conf(li;env(m0)); and
{conf(li;env(m)) is the private view conformance for partyxiwherem2
pr(ni) is a best matching private view for niandli.
denition 14 provides a well-dened conformance notion that can be param-
eterized with dierent correctness notions (e.g., deadlock freedom, weak termi-
nation) and dierent environments (e.g., envs(n),enva(n)). however, def. 14
cannot easily be transformed into an algorithm. there may be many (if not in-
nitely many) private views that accord with ni. so far, no algorithm has been
implemented to select a best matching private view. in the next section, we show
how private view conformance for party xican be decided.
4 deciding private view conformance
in the previous section, we introduced a notion of private view conformance
that is independent from the conformance checking dimensions involved. in this
section, we decide private view conformance w.r.t. the tness dimension.
a model with good tness allows for most of the behavior seen in the event
log. therefore, it is natural to dene conf(l;n) inversely proportional to the
sum of the costs of aligning all traces of lto traces of n; that is, conf(l;n)
should be maximal ifp
2l(n()) is minimal. if a trace appears multiple
times in the event log, the associated costs should be counted multiple times.
denition 15 (fitness). conformance conf(l;n) w.r.t. tness of an event
logland a labeled net nyields a number between 0 (poor tness) and 1 (perfect
tness) and is maximal if the alignment-based costs (l;n) =p
2l(n())
are minimal.
our approach for deciding private view conformance does not rely on a spe-
cic tness measure; any tness measure is suitable as long as it meets the cri-
teria in def. 15. our approach relies on the existence of two specic controllers
of any open net n: amaximal controller maxc (n) [14,8] and a most permissive
controller mpc (n) [22]. a maximal controller is maximal w.r.t. the accordance
relation; that is, every controller of naccords with maxc (n). a most permis-
sive controller mpc (n) is maximal w.r.t. behavior; that is, ncan visit all the
states in composition with mpc (n) that can be visited in composition with any
controller of n. for technical details of maximal and most permissive controllers
we refer to [14] and [22], respectively; here, we only summarize their properties.
proposition 1 ([14]). for any open net n, there exist controllers maxc (n)
and mpc (n)such that for any controller cofn, we havecvaccmaxc (n)
and tr (env(c))tr(env(mpc (n))).
given a contract n=n1nk, we show that bi=mpc (maxc (ni)) is
a canonical best matching private view forniand event log li. in other words,
open netbiaccords with niand has minimal costs and, hence, maximal tness.theorem 2 (main result). letn=n1nkbe a contract for x=
fx1;:::;xkg. letnibe the public view of xi, and letlibe an event log of xi.
thenbi=mpc (maxc (ni))is a best matching private view for niandli.
proof. letn0
i2pr(ni) be a private view of ni. we prove(li;n0
i)(li;bi),
which implies conf(li;env(n0
i))conf(li;env(bi)) for conformance w.r.t. t-
ness according to def. 15. by the choice of n0
iand prop. 1, we conclude that
r(env(n0
i))r(env(bi)). let2libe a trace in the event log li. then, we
have ;env(n0
i) ;env(bi)by def. 10 and (env(n0
i)())(env(bi)()) by
defs. 11 and 12. thus, (li;n0
i)(li;bi) by def. 15. u t
theorem 2 gives a theoretical solution for deciding private view conformance
w.r.t. tness. in addition, thm. 2 gives a necessary condition for the question
whether the implementation accords with the given public view ni: if the best
matching private view bidoes not conform to the event log li, then no private
view ofniconforms to li.
corollary 3. letnbe a public view, lbe an event log of an implementation
ofn, andbbe the best matching private view of n. ifbdoes not conform to
l, then no private view of nconforms to l.
of course, we are interested in calculating the best matching private view
bifor a given open net ni. here, we reuse existing theory on maximal con-
trollers [14,8]. interestingly, the environment (i.e., envsorenva) we consider
when replaying the log le matters only for the construction of bi. in the next
section, we show that bi=mpc (maxc (ni)) can actually be calculated, yet for
acyclic open nets only. the reason for this restriction is that for acyclic open
nets, the correctness notions weak termination and deadlock freedom coincide.
the theory for maximal controllers in case of weak termination exists [8], but
has not been implemented so far.
5 experimental results
based on a prototypical implementation, we show rst experimental results on
computing a canonical best matching private view according to thm. 2. we
assume weak termination as a correctness criterion, use the asynchronous envi-
ronment enva, and employ the standard distance function sto nd the best
matching alignments.
for the running example, 1{3are best matching alignments for land
env(public ) with costs s(1) = 0,s(2) = 2, and s(3) = 1, yielding
alignment-based costs (l;env(public )) = 300 + 402 + 501 = 130. likewise,
4{6are best matching alignments for landenv(private ) with costs s(4) =
s(5) = 0, ands(6) = 1. thus, (l;env(private )) = 300+400+501 = 50.
we compute the canonical best matching private view bofpublic in three
steps: (1) compute the maximal controller maxc (public ), (2) compute the most
permissive controller b=mpc (maxc (public )), and (3) calculate (l;env(b)).privateview_conformance_checking
checkconformanceof b  and lusing p rompublic viewncanonicalbestmatchingprivate viewbevent loglcompute themaximalcontrollerusing w endy,maxis, p napicompute themost permissivecontroller usingwen d y, pnap imaximalcontrollermaxc(n)
richard müller1 of 122.09.2012fig. 6: conformance checking using the best matching private view.
figure 6 shows the three steps and the tools involved. our toolchain consists of a
bash script for deriving a best matching private view using the tools wendy [13],
maxis1, the pnapi [11], and prom.2we illustrate our approach in the following.
step 1: calculating maxc (public )
the open net maxc (public ) has 34 places and 45 transitions and was constructed
following the approach presented in [14]: using the tool wendy, we constructed
an annotated automaton that represents all controllers of public . subsequent,
we derived the behavior of maxc (public ) from this annotated automaton using
the tool maxis. finally, we transformed the behavior into an open net using
the pnapi. figure 7 illustrates a part of maxc (public ). as maxc (public ) is a
controller of public , it has the same interface as public with input and output
interchanged. initially, this service res nondeterministically one of the ve tran-
sitionstabd;:::;td . depending on the state reached, it can perform a number
of sending or receiving events. for example, after ring tabd, the open net can
receiveaorbor sendd.
step 2: deriving b
in the second step, we calculated the most permissive controller of maxc (public ),
resulting in the open net b=mpc (maxc (public )). we constructed the behav-
ior ofbusing the tool wendy and transformed it into open net busing the
pnapi. the resulting open net has 12 places and 22 transitions and is partly
depicted in fig. 8. the open nets band public are interface-equivalent. con-
sider the place empty . a token on empty corresponds to a marking that is not
reachable in the composition of band any controller of public . as no controller
ofpublic initially sends a message c, transition t8 andt9 encode such \mis-
behavior" by producing a token on empty . whenempty contains a token and
hence the composition will not be weakly terminating, every possible sending
1http://svn.gna.org/viewcvs/service-tech/trunk/maxis/
2http://www.promtools.org/catadp0
bdt0p3t1.........t2t5......t3...t6...t4...t7tabp2tabdp1tbdp4tdp5
...t8...t9fig. 7: the maximal controller maxc (public ) ofpublic .
t6cat7p8p3t1p0
p7t5p6bdemptyp2t8tctdtbtat0t2t3t4p5p1p4t9
fig. 8: the best matching private view b=mpc (maxc (public )) of public .
and receiving of messages is possible; thus, transitions ta;tb;tc;td are connected
to the correspondingly labeled interface places (indicated by the respective arcs
without source or target). what we can see is that the behavior of private can
be replayed on b. this shows that it is not wrong to implement a specication
such that the resulting implementation has more controllers than the speci-
cation. however, the added behavior cannot be used by any controller of the
specication. in our example, no controller of public will initially send message
calthough there exist implementations such as open net private that allow such
behavior.
step 3: checking conformance of lwithb
according to thm. 2, bis a best matching private view of public . therefore, in
the last step, we calculate the alignment-based cost for the log land the labeledcase_study
generate anevent logcheckconformanceof n and l
checkconformanceof b  and lgenerate apublic viewcompute thecanonical bestmatchingprivate viewpublic viewn
canonicalbestmatchingprivate viewbevent logl
richard müller1 of 118.09.2012fig. 9: our evaluation process with synthetic nets.
netenv(b) using the latest pnalignmentanalysis plug-in from the tu/e svn
repository.3we use the a-algorithm for cost-based tness with default options.
some best matching alignments for landenv(b)|as they are not unique|are
7=ad
ad
t2tatdt68=bc
bc
t1tbtct99=cda
cda
tct8tdtdtata
with(7) =(8) =(9) = 0 yielding alignment-based costs (l;env(b)) =
300 + 400 + 500 = 0. we see that (l;env(b)) is indeed lower than
(l;env(public )) = 130 and even lower than (l;env(private )) = 50.
we also evaluated our approach with synthetic open nets. figure 9 shows a
bpmn model of our evaluation process. first, we generated a random public
viewnusing a modied version of the process log generator4. afterward, we
computed the canonical best matching private view bfromnand generated a
random event log lfromb, which additionally contains random errors. finally,
we checked conformance of btoland compared it with the conformance of
nandl. we analyzed ve random public views. this time, we used the syn-
chronous environment envsfor computing the private view conformance with
prom. all experiments were conducted on a macbook pro, intel core i5 cpu
with 2.4 ghz and 8 gb of ram.
the results of our evaluation process in table 1 show that the average cost
s(b;l) for each case (using the standard distance function) for conformance
checking the log lwith the best matching private view b(column 13) is signi-
cantly lower than the average cost s(n;l) for conformance checking lwith the
3https://svn.win.tue.nl/repos/prom/
4http://www.processmining.it/sw/plgtable 1: fully automatic private view conformance checking of synthetic nets.
public view nbest matching bevent logls(n;l) times(b;l) time
jpjjijjoj jtjjpjjijjoj jtjcases events s=casems=cases=casems=case
14 4 2 6 35 4 2 132 100 605 6.21 3.47 0.20 0.34
16 5 3 8 41 5 3 190 100 541 7.53 3.31 0.20 0.88
30 6 3 18 106 6 3 681 100 540 8.26 6.21 0.19 1.41
38 6 4 32 32 6 4 168 100 507 4.89 7.10 0.05 0.17
88 6 5 74 806 6 5 6 ;060 100 528 7.24 33.93 0.03 45.60
public view n(column 11). this detail justies thm. 2. however, the lower cost
come at a price of an exponentially larger size of bcompared to n(columns 1
and 5), which is caused by the construction of b[14]. accordingly, the larger
net size resulted in a higher runtime of the a-algorithm (last row).
6 related work
research on conformance checking of services follows two lines. one research
line assumes a model of the implementation to be given (e.g., [20,6]) or that it is
discovered from the event log (e.g., [15]). the former assumption is not always
realistic. furthermore, the result of conformance checking relies on the quality
of the (discovered) model.
the second research line assumes recorded behavior of the implementation to
be given. here, techniques are adapted from process mining [18,2]. our contribu-
tion follows this research line. van der aalst et al. [4] map a contract specied in
bpel onto workow nets (which can be seen as the synchronous environment)
and employ conformance checking techniques from process mining [18]. in con-
trast, we measure the deviation of an implementation from its specication and
all possible private views.
comuzzi et al. [7] investigate online conformance checking using a weaker
renement notion than accordance. dierent conformance relations on a concur-
rency-enabled model have been studied by de le on et al. [9]. as their considered
conformance relations dier from accordance, their work is not applicable in our
setting (because maximal controllers have not been studied yet).
motahari-nezhad et al. [16] investigate event correlation; that is, they try
to nd relationships between events that belong to the same process execution
instance. in contrast to event correlation, we do not vary the service instances,
but rene the public view to a private view.
7 conclusion
given a formal model of a public view of a service and recorded behavior of
its running implementation, conformance checking requires to check the confor-mance of the recorded behavior with all (innitely) private views of the spec-
ication. to overcome these innitely many checks, we presented an approach
to calculate a best matching private view for a given event log and a public
view. moreover, checking conformance of a best matching private view and a
given event log from an implementation gives a necessary condition for accor-
dance of this implementation with its public view. we proved the existence of a
canonical best matching private view and showed that it can be automatically
constructed|in the case of acyclic services and weak termination|using exist-
ing theory and tools on maximal controllers controllers. although it is possible
to construct maximal controllers for cyclic services and weak termination [8],
this has not been implemented yet. for the actual conformance check, we used
existing alignment-based techniques from the eld of process mining.
a canonical best matching private view may become exponentially large in
net size compared to its public view. therefore, it is an open question whether
the current cost-based conformance checking techniques can be used for private
view conformance checking for industrial service models. in general, there exist
many best matching private views for a public view w.r.t. the tness dimension.
our approach computes a canonical best matching private view. there is a
trade-o between the tness dimension and the other quality dimensions (i.e.,
precision, generalization, simplicity) in conformance checking [2]; thus, it is an
open question how to generalize our approach to these other dimensions.
references
1. aalst, w.m.p.v.d.: inheritance of interorganizational workows: how to agree to
disagree without loosing control? information technology and management (2003)
2. aalst, w.m.p.v.d., adriansyah, a., dongen, b.f.v.: replaying history on process
models for conformance checking and performance analysis. wiley interdisciplinary
reviews: data mining and knowledge discovery 2(2), 182{192 (2012)
3. aalst, w.m.p.v.d., dongen, b.f.v., herbst, j., maruster, l., schimm, g., wei-
jters, a.: workow mining: a survey of issues and approaches. data & knowledge
engineering 47(2), 237267 (nov 2003)
4. aalst, w.m.p.v.d., dumas, m., ouyang, c., rozinat, a., verbeek, e.: conformance
checking of service behavior. acm transactions on internet technology 8(3) (2008)
5. aalst, w.m.p.v.d., lohmann, n., massuthe, p., stahl, c., wolf, k.: multiparty
contracts: agreeing and implementing interorganizational processes. comput. j.
53(1), 90{106 (2010)
6. bravetti, m., zavattaro, g.: contract-based discovery and composition of web ser-
vices. in: sfm 2009. lncs, vol. 5569, pp. 261{295. springer (2009)
7. comuzzi, m., vonk, j., grefen, p.: measures and mechanisms for process monitor-
ing in evolving business networks. data & knowledge engineering 71(1) (2012)
8. hee, k.v., mooij, a.j., sidorova, n., werf, j.m.v.d.: soundness-preserving rene-
ments of service compositions. in: ws-fm 2010. lncs, vol. 6551, pp. 131{145.
springer (2011)
9. de le on, h.p., haar, s., longuet, d.: conformance relations for labeled event
structures. in: tap 2012. lncs, vol. 7305, pp. 83{98. springer (2012)
10. lohmann, n., massuthe, p., wolf, k.: operating guidelines for nite-state services.
in: icatpn 2007. lncs, vol. 4546, pp. 321{341. springer (2007)11. lohmann, n., mennicke, s., sura, c.: the petri net api a collection of petri
net-related functions. awpn (2010)
12. lohmann, n., verbeek, e., dijkman, r.: petri net transformations for business
processesa survey. transactions on petri nets and other models of concurrency
ii p. 4663 (2009)
13. lohmann, n., weinberg, d.: wendy: a tool to synthesize partners for services.
fundam. inform. 113(3-4), 295{311 (2011)
14. mooij, a.j., parnjai, j., stahl, c., voorhoeve, m.: constructing replaceable services
using operating guidelines and maximal controllers. in: ws-fm 2010. lncs, vol.
6551, pp. 116{130. springer (2011)
15. motahari-nezhad, h.r., saint-paul, r., benatallah, b.: deriving protocol models
from imperfect service conversation logs. ieee transactions on knowledge and
data engineering 20(12), 1683{1698 (2008)
16. motahari nezhad, h.r., saint-paul, r., casati, f., benatallah, b.: event correla-
tion for process discovery from web service interaction logs. the vldb journal
20(3), 417{444 (sep 2010)
17. papazoglou, m.: web services - principles and technology. prentice hall (2008)
18. rozinat, a., aalst, w.m.p.v.d.: conformance checking of processes based on mon-
itoring real behavior. inf. syst. 33(1), 64{95 (2008)
19. stahl, c., massuthe, p., bretschneider, j.: deciding substitutability of services with
operating guidelines. in: topnoc ii. pp. 172{191. lncs 5460, springer (2009)
20. tran, h., zdun, u., dustdar, s.: vbtrace: using view-based and model-driven de-
velopment to support traceability in process-driven soas. software & systems mod-
eling 10(1), 5{29 (2009)
21. vogler, w.: modular construction and partial order semantics of petri nets,
lncs, vol. 625. springer (1992)
22. wolf, k.: does my service have partners? in: topnoc ii. pp. 152{171. lncs 5460,
springer (2009)