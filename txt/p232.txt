a novel approach for process mining based on
event types
lijie wen1,2, jianmin wang2, wil m.p. van der aalst3, zhe wang2,a n d
jiaguang sun1,2
1departmentofcomputerscience&technology,tsinghuauniversity,beijing,china
wenlj00@mails.tsinghua.edu.cn
2schoolofsoftware,tsinghuauniversity,beijing,china
{jimwang, sunjg }@tsinghua.edu.cn, wang02@mails.tsinghua.edu.cn
3departmentoftechnologymanagement,eindhovenuniversityoftechnology,
eindhoven,thenetherlands.
w.m.p.v.d.aalst@tm.tue.nl
abstract.despitetheomnipresenceofeventlogsintransactionalinfor-
mationsystems(cf.wfm,erp,crm,scm,andb2bsystems),historic
information is rarely used to analyze the underlying processes. process
mining aims at improving this by providing techniques and tools fordiscovering process, control, data, organizational, and social structures
fromeventlogs,i.e.,thebasicideaofprocessminingistodiagnosebusi-
ness processes by mining event logs for knowledge. given its potentialandchallengesitisnosurprisethatrecentlyprocessmininghasbecome
a vivid research area [5,6]. in this paper, a novel approach for process
miningbasedontwoeventtypes,i.e.,startandcomplete,ispro-posed.informationaboutthestartandcompletionoftaskscanbeused
to explicitly detect parallelism. the algorithm presented in this paper
overcomessomeofthelimitationsofexistingalgorithmssuchasthe α-
algorithm(e.g.,short-loops)andthereforeenhancestheapplicabilityof
processmining.
1 introduction
during the last decade workﬂow management technology[3] has become read-
ilyavailable. workﬂow management sy stems such as staﬀware, ibm mqseries,cosa, etc. oﬀer generic modeling and enactment capabilities for structured
business processes. bymaking process deﬁnitions, i.e., models describing the
life-cycle of a typical case (workﬂow instance) in isolation, one can conﬁgurethese systems to support business processes. these process deﬁnitions need to
be executable and are typically graphical, e.g., in terms of petri nets. besides
pure workﬂow management systems many other software systems have adoptedworkﬂow technology. consider for example erp (enterprise resource planning)
systems such as sap, peoplesoft, baan and oracle, crm (customer relation-
ship management) software, scm (supplychain management) sy stems, b2b2 lijiewenetal.
(business to business) applications, etc. which embed workﬂow technology. de-
spite its promise, manyproblems are encountered when apply ing workﬂow tech-nology. one of the problems is that these systems require a workﬂow design,
i.e., a designer has to construct a detailed model accuratelydescribing the rout-
ing of work. modeling a workﬂow is far from trivial: it requires deep knowledgeof the business process at hand (i.e., lengthydiscussions with the workers and
management are needed) and the workﬂow language being used.
in this paper, we do not focus on the design but instead we focus on tech-
niques for monitoring enterprise information systems (i.e., wfm, erp, crm,
scm-like systems). today, many enterprise information systems store relevantevents in some structured form. for example, workﬂow management systems
typically register the start and completion of activities [3]. erp systems like
sap log all transactions, e.g., users ﬁlling out forms, changing documents, etc.business-to-business (b2b) systems log the exchange of messages with other
parties. call center packages but also general-purpose crm systems log interac-
tions with customers. these examples show that manysy stems have some kind
ofevent log often referred to as “history”, “audit trail”, “transaction log”, etc.
[5,8,18,39]. the event log typically contains information about events referringto antaskand acase. the case (also named process instance) is the “thing”
which is being handled, e.g., a customer order, a job application, an insurance
claim, a building permit, etc. the task (also named activity, operation, action,or work-item) is some operation on the case. typically, events have a timestamp
indicating the time of occurrence. moreover, when people are involved, event
logs will typically contain information on the person executing or initiating theevent, i.e., the originator . based on this information several tools and techniques
for process mining have been developed [2,4,5,7,8,10,19,25,35,39,50].
process mining is useful for at least two reasons. first of all, it could be used
as a tool to ﬁnd out how people and/or procedures reallywork. second, process
mining could be used for delta analysis , i.e., comparing the actual process with
some predeﬁned process (i.e., a descriptive or prescriptive process model).
in this paper, we present a new algorithm for process mining. this algorithm
generates a petri net based on some event log where both the start and comple-
tion of some event are logged. to illustrate the algorithm and its distinguishing
features we use the event log shown in table 1. the event log contains the audit
trail of three cases. the ﬁrst event is the start of task t1 for case 1. the second
event is the completion of this task. the third event is the start of task t2 forcase 1. the fourth event is the start of task t3 for case 1. note that for case
1 the execution of t2 and t3 overlap. this suggests that t2 and t3 are in
parallel. after the completion of t3 and t2 for case 1, the ﬁrst event for case2 is registered in the log. in total there are 36 events in the event log shown in
table 1: 18 events of type start and 18 events of type complete.
using the algorithm presented in this paper, the log shown table 1 can be
used to generate the process model shown in figure 1. this process model is
expressed in terms of a petri net. it is easyto see that the three cases can indeedprocessmining 3
case id task name event type case id task name event type case id task name event type
1t1 start1t6 start2t5 start
1t1 complete 1t6 complete 2t5 complete
1t2 start3t2 start2t6 start
1t3 start3t2 complete 2t6 complete
1t3 complete 2t3 start3t4 start
1t2 complete 2t2 start3t4 complete
2t1 start2t3 complete 3t5 start
1t4 start2t2 complete 3t5 complete
2t1 complete 2t4 start3t5 start
1t4 complete 2t4 complete 3t5 complete
3t1 start3t3 start3t6 start
3t1 complete 3t3 complete 3t6 complete
table 1.aneventlogwithstartandcompleteevents.
p1 t1p2
p3t2
t3p4
p5t4 p6t5
t6 p7
t1= register order
t2 = pick productst3 = send billt4 = ship goodst5 = send remindert6 = handle payment
figure 1.thepetrinetcorrespondingtotheeventlogshownintable1.4 lijiewenetal.
be handled bythe petri net. in table 1 onlytask identiﬁers (t1, t2, etc.) are
used. figure 1 also shows the mapping of these identiﬁers onto task names.
existing techniques for process mining do not consider event types, i.e., tasks
are either considered to be atomic or onlythe completion of a task is considered
(i.e., just event type complete) [2,5,7,8,10,19,50]. note that the start andcompletionofataskcanbeconsideredastwoatomictaskswhenusingtheclassi-
cal process mining techniques. unfortunately, such an approach does not detect
explicitparallelism.moreover,theknowledgethatthestartandcompleteevents are related is not exploited. as far as we know, the algorithm presented
in this paper is the onlyalgorithm explicitlydetecting parallelism. it can be seen
as a variant of the α-algorithm [7]. however, the causal relations and complete-
ness notion are fundamentallydiﬀerent. moreover, the new algorithm overcomes
some of the problems of the basic α-algorithm, e.g., it is possible to correctly
mine short loops. note that figure 1 contains a short loop, i.e., the constructinvolving t5 and p6 (sending 0, 1, or more reminders). this indicates that the
basicα-algorithm is unable to correctlymine the process while the algorithm
presented in this paper does.
the remainder of this paper is organized as follows. section 2 reviews related
work. section 3 introduces some preliminaries. in section 4 a method for discov-
ering characteristic relations between tasks is given. based on these relations, in
section 5, a concrete algorithm for constructing process model is proposed. an
experimental evaluation is outlined in section 6. finally, a conclusion is drawnin section 7.
2 related work
the idea of process mining is not new [5,7,8,10–12,19–24,29–31,40–44,47–49].cook and wolf have investigated similar issues in the context of software en-gineering processes. in [10] theydescribe three methods for process discovery :
one using neural networks, one using a purelyalgorithmic approach, and one
markovian approach. the authors consider the latter two the most promisingapproaches.thepurelyalgorithmic approach buildsaﬁnite state machine where
states are fused if their futures (in terms of possible behavior in the next k steps)
are identical. the markovian approach uses a mixture of algorithmic and sta-
tistical methods and is able to deal with noise. note that the results presented
in [10] are limited to sequential behavior. related, but in a diﬀerent domain,is the work presented in [27,28] also using a markovian approach restricted to
sequential processes. cook and wolf extend their work to concurrent processes
in [11]. they propose speciﬁc metrics (entropy, event type counts, periodicity,and causality) and use these metrics to discover models out of event streams.
however, theydo not provide an approach to generate explicit process models.
in [12] cook and wolf provide a measure to quantifydiscrepancies between aprocess model and the actual behavior as registered using event-based data. the
idea of applying process mining in the context of workﬂow management was ﬁrst
introduced in [8]. this work is based on workﬂow graphs, which are inspired byprocessmining 5
workﬂow products such as ibm mqseries workﬂow (formerlyknown as flow-
mark) and inconcert. in this paper, two problems are deﬁned. the ﬁrst problemis to ﬁnd a workﬂow graph generating events appearing in a given workﬂow log.
the second problem is to ﬁnd the deﬁnitions of edge conditions. a concrete
algorithm is given for tackling the ﬁrst problem. the approach is quite diﬀer-ent from other approaches: because the nature of workﬂow graphs there is no
need to identifythe nature (and or or) of joins and splits. as shown in [26],
workﬂow graphs use true and false tokens which do not allow for cyclic graphs.nevertheless, [8] partiallydeals with iteration byenumerating all occurrences
of a given task and then folding the graph. however, the resulting conformal
graph is not a complete model. in [31], a tool based on these algorithms is pre-sented. schimm [40,41,44] has developed a mining tool suitable for discovering
hierarchicallystructured workﬂow processes. this requires all splits and joins to
be balanced. herbst and karagiannis also address the issue of process mining
in the context of workﬂow management [21,19,20,23,24,22] using an inductive
approach. the work presented in [22,24] is limited to sequential models. theapproach described in [21,19,20,23] also allows for concurrency. it uses stochas-
tic task graphs as an intermediate representation and it generates a workﬂow
model described in the adonis modeling language. in the induction step tasknodes are merged and split in order to discover the underlying process. a no-
table diﬀerence with other approaches is that the same task can appear multiple
times in the workﬂow model, i.e., the approach allows for duplicate tasks. thegraph generation technique is similar to the approach of [8,31]. the nature of
splitsandjoins(i.e.,andoror)isdiscoveredinthetransformationstep,where
the stochastic task graph is transformed into an adonis workﬂow model withblock-structured splits and joins. in contrast to the previous papers, the follow-
ing papers are characterized bythe focus on workﬂow processes with concurrent
behavior (rather than adding ad-hoc mechanisms to capture parallelism).
the algorithm presented in this paper is most related to the α-algorithm pre-
sentedin[2,7,47–50].basedonaneventlog,the α-algorithmisabletoconstruct
a corresponding petri net. in [47–50] a heuristic approach using rather simple
metrics is used to construct so-called “dependency/frequency tables” and “de-
pendency/frequency graphs” as an intermediate step before constructing the
corresponding petri net. in [29] another variant of this technique is presented
using examples from the health-care domain. the preliminaryresults presentedin [29,47–49] onlyprovide heuristics and focus on issues such as noise. however,
in [7] it is proventhat theα-algorithm can ﬁnd the proper process model for
certain subclasses of petri nets. in [2] the emit tool is presented which uses anextended version of α-algorithm to incorporate timing information. note that
emit also can handle start and complete events and use this to explic-
itlydetect parallelism. however, this approach is diﬀerent from the approachpresented in this paper because the ordering relations are completelydiﬀerent.
moreover, the wayemit deals with start and complete events is not
proven to be correct. in fact, it is hardlydocumented.6 lijiewenetal.
process mining can be seen as a tool in the context of business (process)
intelligence (bpi). in [18,39] a bpi toolset on top of hp’s process manager isdescribed. the bpi tools set includes a so-called “bpi process mining engine”.
however,thisenginedoesnotprovideanytechniquesasdiscussedbefore.instead
it uses generic mining tools such as sas enterprise miner for the generation ofdecision trees relating attributes of cases to information about execution paths
(e.g., duration). in order to do process mining it is convenient to have a so-
called “process data warehouse” to store audit trails. such as data warehousesimpliﬁes and speeds up the queries needed to derive causal relations. in [14,
33–35] the design of such warehouse and related issues are discussed in the
context of workﬂow logs. moreover, [35] describes the pisa tool which can beused to extract performance metrics from workﬂow logs. similar diagnostics are
provided bythe aris process performance manager (ppm) [25]. the later tool
is commerciallyavailable and a customized version of ppm is the staﬀware
process monitor (spm) [46] which is tailored towards mining staﬀware logs.
note that none of the latter tools is extracting the process model. the mainfocus is on clustering and performance analysis rather than causal relations as
in [8,10–12,19–24,29–31,40–44,47–49].
more from a theoretical point of view, the rediscoveryproblem discussed in
this paper is related to the work discussed in [9,16,17,37]. in these papers the
limits of inductive inference are explored. for example, in [17] it is shown thatthe computational problem of ﬁnding a minimum ﬁnite-state acceptor compati-
ble with given data is np-hard. several of the more generic concepts discussed
in these papers could be translated to the domain of process mining. it is pos-
sible to interpret the problem described in this paper as an inductive inference
problem speciﬁed in terms of rules, a hypothesis space, examples, and criteriafor successful inference. the comparison with literature in this domain raises
interesting questions for process mining, e.g., how to deal with negative exam-
ples (i.e., suppose that besides log wthere is a logvof traces that are not
possible, e.g., added bya domain expert). however, despite the manyrelations
with the work described in [9,16,17,37] there are also manydiﬀerences, e.g., we
are mining at the net level rather than sequential or lower level representations(e.g., markov chains, ﬁnite state machines, or regular expressions).
there is a long tradition of theoretical work dealing with the problem of
inferring grammars out of examples: given a number of sentences (traces) out
of a language, ﬁnd the simplest model that can generate these sentences. thereis a strong analogywith the process-mining problem: given a number of pro-
cess traces, can we ﬁnd the simplest process model that can generate these
traces. manyissues important in the language-learning domain are also relevantfor process mining (i.e. learning from onlypositive examples, how to deal with
noise, measuring the qualityof a model, etc.). however, an important diﬀer-
ence between the grammar inference domain and the process-mining domain isthe problem of concurrencyin the traces: concurrencyseems not relevant in the
grammarinferencedomain.inspiteofthisimportantdiﬀerence,itseemsusefully
to investigate which theoretical results, measurements, and mining techniquesprocessmining 7
can be used or updated so that theybecome useful in process mining. a good
overview of prominent computational approaches for learning diﬀerent classes offormal languages is given in [36].
additional related work is the seminal work on regions [15]. this work in-
vestigates which transition systems can be represented by (compact) petri nets
(i.e., the so-called synthesis problem). although the setting is diﬀerent and our
notionofcompletenessismuchweakerthanknowingthetransitionsystem,thereare related problems such as duplicate transitions, etc.
most of the work mentioned thus far is primarilyfocusing on the process
perspective. however, there are clear links with sociometry, and social net-
work analysis (sna) in particular. since the early work of moreno [32] sna
has been an active research domain. there is a vast amount of textbooks, re-search papers, and tools available in this domain [45]. there have been many
studies analyzing workﬂow processes based on insights from social network anal-
ysis. however, these studies typically have an ad-hoc character and sociograms
are typically constructed based on questionnaires rather than using a struc-
tured and automated approach as described in this paper. most tools in thesna domain take sociograms as input. mison is one of the few tools that gen-
erate sociograms as output. the onlycomparable tools are tools to analy ze
e-mail traﬃc, cf. buddygraph (http://www.buddygraph.com/) and metasight(http://www.metasight.co.uk/).however,thesetoolsmonitorunstructuredmes-
sages and cannot distinguish between diﬀerent activities (e.g., work-related in-
teraction versus social interaction). one of the few approaches constructing so-ciograms from structured event logs is described in [4].
for more information on existing research, we also refer to special issue of
computers in industryon process mining [6] and the surveypaper [5].
3 preliminaries: wf-nets
we assume some basic knowledge of petri nets and wf-nets in particular. read-ers not familiar with basic concepts such as ( p,t,f) as a representation for a
petri net, the ﬁring rule, ﬁring sequences, preset •x, postsetx•, boundedness,
liveness, reachability, etc. are referred to [1,13,38]. some basic deﬁnitions for
wf-nets are provided in this section.
before introducing the new algorithm we brieﬂydiscuss a subclass of petri
nets called a workflow nets (wf-nets). this subclass is tailored towards mod-
eling the control-ﬂow dimension of a workﬂow
4or anyother case driven process,
e.g., logging onto a system. it should be noted that a wf-net speciﬁes the dy-
namic behavior of a single case in isolation [1].
deﬁnition 1 (workﬂow nets). letn=(p,t,f)beapetrinetand ¯tafr esh
identiﬁer not in p∪t.nis aworkﬂow net (wf-net) iﬀ:
1.object creation :pcontains an input place isuch that •i=∅,
4notethatweusethewords workﬂowand processinterchangeably.8 lijiewenetal.
2.object completion :pcontains an output place osuch thato•=∅,
3.connectedness :¯n=(p,t∪{¯t},f∪{(o,¯t),(¯t,i)})is strongly connected,
the petri net shown in figure 1 is a wf-net. note that although the net is
not stronglyconnected, the short-circuited net with transition ¯tis stronglycon-
nected.evenifanetmeetsallthesyntacticalrequirementsstatedindeﬁnition1,
the corresponding process mayexhibit errors such as deadlocks, tasks which can
never become active, livelocks, garbage being left in the process after termina-tion, etc. therefore, we deﬁne the following correctness criterion.
deﬁnition 2 (sound). letn=(p,t,f)b eaw f - n e tw i t hi n p u tp l a c e iand
output placeo.nissoundiﬀ:
1.safeness:(n,[i])is safe,
5
2.proper completion : for any marking s∈[n,[i]/angbracketright,o∈simpliess=[o],
3.option to complete : for any marking s∈[n,[i]/angbracketright,[o]∈[n,s/angbracketright,a n d
4.absence of dead tasks :(n,[i])contains no dead transitions.
the set of all sound wf-nets is denoted w.
the wf-net shown in figure 1 is sound. soundness can be veriﬁed using stan-
dard petri-net-based analysis techniques [1,3].
most process modeling languages oﬀer standard building blocks such as the
and-split, and-join, xor-split, and xor-join [3]. these are used to model
sequential, conditional, parallel and iterative routing. clearly, a wf-net can be
used to specifythe routing of cases, i.e., process instances. tasks, also referred
to asactivities, are modeled bytransitions and causal dependencies are modeled
byplaces and arcs. in fact, a place corresponds to a condition which can be
used as pre- and/or post-condition for tasks. an and-split corresponds to a
transition with two or more output places, and an and-join corresponds to
a transition with two or more input places. xor-splits/xor-joins correspondto places with multiple outgoing/ingoing arcs. given the close relation between
tasks and transitions we use the terms interchangeably.
our process mining research aims at rediscovering wf-nets from event logs.
however, not all places in sound wf-nets can be detected. for example places
maybe implicit which means that theydo not aﬀect the behavior of the process.
these places remain undetected. therefore, we limit our investigation to wf-nets without implicit places.
deﬁnition 3 (implicit place). letn=(p,t,f)be a petri net with initial
markings. a placep∈pis called implicit in (n,s)if and only if, for all
reachable markings s
/prime∈[n,s/angbracketrightand transitions t∈p•,s/prime≥•t\{p}⇒s/prime≥•t.6
5(n,[i]) is the marked net with initial marking [ i], i.e., the marking with just one
tokeninthesourceplace i.similarly,[ o]isusedtodenotethethemarkingwithjust
onetokeninthesinkplace o.
6[n,s/angbracketrightisthesetofreachablemarkingsofnet nwhenstartinginmarking s,p•isthe
setofoutputtransitionsof p,•tisthesetofinputplacesof t,and ≥isthestandard
orderingrelationonmultisets.processmining 9
figure 1 contains no implicit places. however, adding a place pconnecting tran-
sitiont1a n dt4 yields an implicit place. no mining algorithm is able to detect
psince the addition of the place does not change the behavior of the net and
therefore is not visible in the log.
(i) (ii)
figure 2.constructsnotallowedinswf-nets.
for process mining it is veryimportant that the structure of the wf-net
clearlyreﬂects its behavior. therefore, we also rule out the constructs shown in
figure 2. the left construct illustrates the constraint that choice and synchro-nization shouldnevermeet.iftwo transitions shareaninputplace,andtherefore
“ﬁght” for the same token, theyshould not require sy nchronization. this means
that choices (places with multiple output transitions) should not be mixed withsynchronizations. the right-hand construct in figure 2 illustrates the constraint
that if there is a synchronization all preceding transitions should have ﬁred, i.e.,
it is not allowed to have sy nchronizations directlypreceded byan xor-join.wf-nets which satisfythese requirements are named structured workﬂow nets
and are deﬁned as:
deﬁnition 4 (swf-net). aw f - n e tn=(p,t,f)is answf-net(struc-
tured workﬂow net) if and only if:
1. for allp∈pandt∈twith(p,t)∈f:|p•|>1implies |•t|=1.
2. for allp∈pandt∈twith(p,t)∈f:|•t|>1implies |•p|=1.
3. there are no implicit places.
the wf-net shown in figure 1 is an example of an swf-net. note that all
three requirements are satisﬁed.
figure 3 gives another example of a process modelled in terms of an wf-net.
this model is sound but it is not an swf-net because the construct involvingp7a n dp8, i.e., (p7,t11)∈fand|•t11|>1 but |•p7|>1. nevertheless,
the model will be used as the main example throughout the paper.
/g51/g20 t1/g51/g21 t3 /g51/g22
/g51/g23t4
/g51/g24t7
/g51/g27
t5t11 /g51/g20/g19t2
t9t6 /g51/g25/g51/g26t8
/g51/g28 t10
figure 3.anexampleofprocessexpressedintermsofapetrinet.10 lijiewenetal.
the transitions (drawn as rectangles) t1,t2,···,t11 represent tasks and
the places (drawn as circles) p1,p2,···,p10 represent causal dependencies.
a place can be used as pre-condition and/or post-condition for tasks. the arcs
(drawnasdirectededges)betweentransitionsandplacesrepresentﬂowrelations.
in this process, sequential (from t9t ot10, etc.), alternative (from p4t ot4
andt5, etc.), parallel (from t1t op2a n dp4, etc.), synchronous (from p7a n d
p8t ot11, etc.) and iterative ( p2-t3-p3-t2-p2,p7-t8-p7, etc.) routing are
present. there are also three short loops (i.e., loops of length of one or two): theloop involvingt8 (length 1), the loop involving t2a n dt3 (length 2), and the
loop involvingt9a n dt10 (also length 2). also note the special parallel routing
(splits fromt7 and joins att11).
theα-algorithm is unable to correctlymine wf-nets such as the one shown
in figure 3 (but also the model shown in the introduction), because of thepresence of short loops. moreover, tasks (i.e., transition ﬁrings) are considered
to be atomic while in realitythis is not the case.
4 analyzing the event log
in this section, we focus on event logs with two event types. first, we deﬁne such
event logs. then, we deﬁne a new notion of completeness and ordering relationson tasks based on the two event types start and complete.
4.1 event logs with two types of events
existing approaches do not consider event types [2,5,7,8,10,19,50]. tasks are
either considered to be atomic or onlythe completion of a task is considered(i.e., just event type complete). one way to deal with this is to consider the
start and completion of a task as two atomic tasks. emit uses some pre- and
post-processing to incorporate multiple event types, but does not incorporate
this in the mining algorithm and ordering relations.
7in this paper, we propose
a fundamentallydiﬀerent approach where parallelism is detected explicitlybyregistering overlapping activities.
as indicated in the introduction, there are two event types: start and
complete. therefore, each event is characterized bya task and an event
type.
deﬁnition 5 (event). let t be a setof tasks. e=t×{0,1}is a set of events
overt.(t,0)∈edenotes the start of some task tand(t,1)∈edenotes the
completion oft. for convenience, we also introduce the following notation for
e∈e:e.taskrefers to the task and e.typerefers to the event type. if e=(t,0),
thene.task=tande.type=start.ife=(t,1),thene.task=tande.type=
complete .
7note that emit allows for even more event types, e.g., there are also event types
likeschedule,assign,withdraw,etc.processmining 11
note that deﬁnition 5 abstracts from other information that maybe present
in the log, e.g., the timestamp of the event, the performer executing the task,and data linked to the event. an event always occurs in the context of a single
case. the ordering of events corresponding to diﬀerent cases is not important.
therefore, we consider a log to be a set of traces where each trace correspondsto a case.
deﬁnition 6 (event trace, event log). lete=t×{0,1}be a set of events
overt.σ∈t
∗is anevent trace andw⊆t∗is anevent log.8
note that the log shown in table 1 is consistent with this notation. for example,
the event trace for the ﬁrst case is σ=(t1,0)(t1,1)(t2,0)(t3,0)(t3,1)(t2,1)
(t4,0)(t4,1)(t6,0)(t6,1).
event traces are sequences. we use the following standard notation for se-
quences.
deﬁnition 7. lete=t×{0,1},σ∈t∗a sequence containing nelements,
andt∈tsome task.
1.dom(σ)={1,2,...,n }is the domain of σ,
2.σiis thei-th element,i∈dom(σ),
3.t∈σiﬀthere exists an i∈dom(σ)such thatσi.task=t,
4.first(σ)=σ1.taskis the ﬁrst task to start, and
5.last(σ)=σn.taskis the last task to complete.
note that deﬁnition 6 allows for event traces like ( t1,1) (t1,0) and (t1,0)
(t2,1) (i.e., the complete event precedes the start event or there is not
start/complete event at all). therefore, we deﬁne the notion of consis-
tency.
deﬁnition 8 (consistent). lete=t×{0,1}be a set of events over tand
σ∈t∗an event trace. σisconsistent if and only if
1.∀i∈dom (σ)σi.type=0⇒(∃j∈dom (σ)j>i ∧σj=(σi.task,1)∧
∀i<k<jσi.task /negationslash=σk.task), i.e., every start event has a corresponding
complete event, and
2.∀i∈dom (σ)σi.type=1⇒(∃j∈dom (σ)j<i ∧σj=(σi.task,0)∧
∀j<k<iσi.task /negationslash=σk.task), i.e., every complete event has a correspond-
ing start event.
in the remainder we consider event traces to be consistent, i.e., anylog w
will hold onlyconsistent traces. note that in some situations this is not realistic,
i.e., parts of the log maybe missing or there maybe some kind of noise. in
[49] these issues are discussed and partiallysolved. we expect that the conceptspresented in [49] can be transferred to the mining algorithm presented here.
8t∗isthesetofallsequencesthatarecomposedofzeroofmoretasksfrom t.12 lijiewenetal.
4.2 ordering relations
an essential prerequisite for process mining is the ordering of tasks. to deﬁne
suitable ordering relations on tasks, we need to consider pairs of events, i.e., a
start event and a corresponding complete event. therefore, we deﬁne thenotion oftask occurrence .
deﬁnition 9 (task occurrence). letσ∈e
∗andσ=e1e2···en.
t(ei,ej)is a task occurrence of tinσiﬀ
1.1≤i<j ≤n,
2.ei.task=ej.task=t,
3.ei.type=0,
4.ej.type=1,a n d
5.∀i<k<jσk.task /negationslash=t).
notethateveryeventineventtracecorrespondstopreciselyonetaskoccurrence.
however, for one task there maybe multiple task occurrences in the same event
trace.
intuitively, a task occurrence can be represented as a line segment. the left
end is the start event and the right end is the complete event. these
line segments represent the time the task is being executed and can be used to
deﬁne succession (i.e., “directly” follows) and intersection (i.e., overlapping taskoccurrences).
deﬁnition 10 (succession). letw⊆e
∗an event log such that e=t×
{0,1}.l eta,b∈tbetwotasks.ais directly succeeded by binw,notationa>w
b, iﬀthere exists a σ∈e∗such thatσ=e1e2···enand two task occurrences
a(ei,ej)andb(ek,el)inσsuch thatj<kand there is no task occurrence
c(ep,eq)inσsatisfyingj<p<q<k .
aissucceededby bifandonlyifinatleastoneeventtrace ais“directlyfollowed”
byb, i.e., there is not another complete task occurrence in-between the two task
occurrencesa(ei,ej)a n db(ek,el).
deﬁnition 11 (intersection). letw⊆e∗an event log such that e=t×
{0,1}.l e ta,b∈tbe two tasks.aintersects with binw, notationa×wb,i ﬀ
there exists aσ∈e∗such thatσ=e1e2···enand two task occurrences a(ei,ej)
andb(ek,el)inσsuch thati<k<jork<i<l.
aintersects with bif and onlyif in at least one event trace where an occurrence
ofaoverlaps with an occurrence of b. note that the intersection relation is
symmetric, i.e., a×wbif and onlyifb×wa.
botha> wb(ais succeeded by b)a n da×wb(aintersects with b)a r e
illustrated in figure 4.
using the notation introduced in this section we can represent the ﬁnite set
of taskstw={t∈t|∃σ∈wt∈σ}, the ﬁnite set of initial tasks ti={t∈
t|∃σ∈wt=first(σ)}(the ﬁrst tasks to start), and the ﬁnite set of ﬁnal tasksprocessmining 13
a b a b a b b a
ora b a b
w ba >w ab >
w ab ×w ba ×
figure 4.illustrationof a> wb,b> wa,a×wb,and b×wa.
to={t∈t|∃σ∈wt=last(σ)}(the last tasks to complete). it is also fairly
straightforward to calculate the relations >wand×w. the complexityof an
eﬃcient algorithm to calculate these relations and sets is o(n), where n is the
number of total events in the corresponding traces.
the notionstw,ti,to,>w,a n d ×ware the basic ingredients for the
mining algorithm presented in this paper. to prove the correctness of the mining
algorithm we need to assume some notion of completeness, i.e., for a complex
process with manypossible event traces we need a log that somehow reﬂects thepossible behavior.
deﬁnition 12 (completeness of an event log). let n=(p,t,f) be a sound
wf-net.wis an event log of niﬀw⊆e
∗wheree=t×{0,1}and every
traceσ∈wis a ﬁring sequence of nstarting in state [i]and ending in state
[o].wis a complete event log of niﬀ1) for any event log w/primeofn:>w/prime⊆>w
and×w/prime⊆× w, and 2) for any t∈t, there is aσ∈wsuch thatt∈σ.
it is easyto check that the event log shown in table 1 is complete, i.e., all tasks
appear somewhere in the log and the relations >wand×ware maximal.
1 00 111 000000 1 0000000
2 00 1111 00000 2
3 0 1 0 1111 0000 3
4 0 11 00 1 00000 4
5 0 11 00 1 00000 5
6 0 11 000 1 0000 67 0000000 11 0 1 7
8 0000000 1111 8
9 0000000 1 0 1 0 9
1 0 0000000 11 0 1 1 01 1 00000000000 1 1tt
tt
tt
tttttttttt
tt
tttt


0000
000 111 00000
000 111 00000
0 11 000000000 11 000000000 11 000000000000000000000000000 11 0
0000000 1 000
0000000 1 00000000000000


t 1  t 2  t 3  t 4  t 5  t 6  t 7 t 8 t 9 t 10 t 11
w > t 1  t 2  t 3  t 4  t 5  t 6  t 7 t 8 t 9 t 10 t 11w ×
figure 5.matricesrepresenting >wand×wforthewf-netshowninfigure3based
onsomecompletelog w.
assume that we have a complete event log for the wf-net shown in figure 3.
the resulting relations >wand×ware shown in figure 5. in this ﬁgure 0
denotesfalseand 1 denotes true.
4.3 identifying the ordering relations between tasks
after establishing the basic relations >wand×wwe identifyfour derived rela-
tions. these derived ordering relations will be used to detect typical routings in14 lijiewenetal.
the process model, such as sequential, parallel, alternative, iterative (i.e., loops)
routing and their combination.
deﬁnition 13 (log-based ordering relations). letwbe an event log over
ew h e r ee=t×{0,1}. for anya,b∈t:
•a→wbiﬀa>wband¬(a×wb).
•a/bardblwbiﬀa×wb.
•a#wbiﬀ¬(a>wb)and¬(a×wb).
•a∦wbiﬀ¬(a×wb).
based on these deﬁnitions, it is obvious that relations /bardblwand ∦wsatisfy
commutativitywhile relations →wand # wdo not. the two relations /bardblwand
∦waremutuallyexclusiveandcomplementary .fromdeﬁnition13,thefollowing
propertycan be inferred directly .
property 1. letwbe an event log over e where e=t×{0,1}. for any
a,b∈t:a→wb,a#wb,o ra/bardblwb. moreover, the relations →w,#w,a n d /bardblw
are mutuallyexclusive and partition t×t. furthermore, the relation ∦wis the
union of the relations →wand # w.
afterapplyingdeﬁnition13tothetwomatricesshowninfigure5,weobtain
the matrix shown in figure 6.
# # ###### 1
# # / / / / / / ##### 2
# # / / / / / / #### 3
# / / / / ## ##### 4
# / / / / ## ##### 5
# / / / / ### #### 6
7 # ###### #
8 # ####
9
1011w w www wwwwww
w w w www wwwwwww w www w wwwww ww ww w wwwww
w ww ww w wwwww
w ww www w wwwww wwwwww ww w ww wwwwt
tttttttttt→→→
→
→→
→→
→
→→ →
# # // //
# ###### / / # ## ###### / / ## ##########ww w ww w
w wwwwww w w w w
w wwwwww w w w w
w wwwwwwwwww




→→→→→t 1 t 2 t 3 t 4  t 5 t 6 t 7 t 8 t 9 t 10 t 11
figure 6.matrixoftheorderingrelationsforthewf-netshowninfigure3basedon
thetwomatricesshowninfigure5.
the log-based relations shown in figure 6 reﬂect the relations between the
tasks in the wf-net shown in figure 3 in an intuitive manner. for example, t9
andt10 are clearlyin a sequence and indeed we obtain t9→wt10 from the
complete log. another example is that t3a n dt4 are in parallel and we indeed
gett3/bardblwt4.
notethatitmayappeartobestrangethatwecomparethelog-basedrelations
(e.g., figure 6) with a petri net that is alreadyknown (e.g., figure 3). however,
please note that while building the relations we onlyconsider the log and notthe wf-net itself. rediscovering a known wf-net based on a complete log is
used for demonstrating the accuracyof the mining algorithm. the challenge is
to derive figure 3 from a complete log without anyadditional knowledge. noteprocessmining 15
that completeness is veryimportant in this context. if the log is not complete,
our mining algorithm will still be able to discover a process but this is likelytodiﬀer from the actual process because there are not enough observations.
5 constructing a process model from ordering relations
in this section, we present the new algorithm which we have named the β-
algorithm. however, ﬁrst we investigate the relation between the ordering re-lations detected from the log and the presence of the connecting places in the
corresponding process model. we will use this to prove the correctness of the
β-algorithm. the proofs of all theorems presented in this section can be found
in the appendix of this paper.
5.1 ordering relations and connecting places
first we investigate the relation between →
w(i.e., the ordering relation in-
dicating causality) and the existence of connecting places. if →wrelates two
transitions (i.e., tasks), there will be a place connecting them.
theorem 1. letn=(p,t,f)be a sound wf-net and let wbe a complete
event log ofn. for anya,b∈t:a→wbimpliesa•∩•b/negationslash=∅.
figures 6 and 3, can be used to illustrate the theorem. since t1→wt3 (cf.
figure 6), there has to be a place between t1a n dt3. this place corresponds
top2 in the wf-net shown in figure 3.
theorem 1 holds for anywf-net. the other direction, does not hold for any
wf-net. however, for swf-nets we can show that if a place connects two suc-cessive transitions in an swf-net, their corresponding tasks are related through
→
w.
theorem 2. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b∈t:a•∩•b/negationslash=∅impliesa→wb.
based on ﬁgures 3 and 6, we can see that all connecting places between two
successive transitions lead to →wrelations between the corresponding two tasks
inthelog,e.g.,thepresenceoftheplace p2connectingt1andt3indeedimplies
t1→wt3, etc.
after showing the relation between →wand places in the corresponding
petri net, we focus on parallelism. first, we show that two transitions cannot be
in parallel according to /bardblwif theyhave common input or output places.
theorem 3. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b∈t:
1. ifa•∩b•/negationslash=∅, thena∦wb.
2. if•a∩•b/negationslash=∅, thena∦wb.16 lijiewenetal.
it is clear that t4a n dt5 share one input place p4 and one output place
p5 in figure 3. the ordering relations between t4a n dt5a r et4#wt5a n d
t5#wt4. thust4∦wt5 holds, i.e.,t4a n dt5 can not occur concurrently.
to show that a similar relation holds in the other direction consider three
tasksa,b,a n dc. if bothaandbare causallyrelated to c(i.e.,aandcare
connected bya place in the corresponding petri net and so are bandc)a n da
andbare not in parallel (i.e., a∦wbholds), thenaandbare connected to c
through a common place.
theorem 4. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b,c ∈t:
1. ifa→wc,b→wcanda∦wb, thena•∩b•∩•c/negationslash=∅.
2. ifc→wa,c→wbanda∦wb, thenc•∩•a∩•b/negationslash=∅.
forexample,t1→wt4,t1→wt5andt4∦wt5holdinfigure6.therefore,
as theorem 4 points out, there is a place p4 connectingt1,t4a n dt5i n
figure3.9anotherexampleisthefactthat t7→wt8,t8→wt8andt7∦wt8
implies thatt7•∩t8•∩•t8/negationslash=∅. as figure 3 shows, the shared place is p7.
note that in terms of theorem 4 a=t7,b=t8, andc=t8, i.e.,b=c. this
example shows that, unlike the classical relations used bythe α-algorithm [7],
the ordering relations can deal successfullywith short loops.
the following theorem shows how to identifythe connecting places.
theorem 5. letn=(p,t,f)be a sound swf-net and let wbe a com-
plete event log of n. for any two task sets psandss, such thatps⊆t,
ss⊆t:∀a∈ps∀b∈ssa→wb,∀a1,a2∈psa1∦wa2and∀b1,b2∈ssb1∦wb2iﬀ
∃p∈p∀a∈ps∀b∈ssa•∩•b={p}.
theorem 5 illustrates the relation between the connecting places and the
ordering relations among tasks. considering an example from figure 3, we get
ps={t4,t5},ss={t6}and the unique connecting places is p=p5.
notably, although the net shown in figure 3 is not an swf-net, we can still
get the correct relations. the connecting places p7a n dp8 can be rediscovered
successfullyand eﬃciently , which indicates the power of the mining algorithmpresented next.
5.2 mining algorithm based on the ordering relations
basedonthetheoreticalresultsshownintheprevioussubsection,wenowpresent
theβ-algorithm.
mining algorithm β.letwbeaneventlogover t.β(w)isdeﬁnedasfollows :
1.t
w={t∈t|∃σ∈wt∈σ},
9notethatfigure3isnotanswf-net.however,thepartofthenetconsidereddoes
satisfy the requirements of an swf-net. in fact, the applicability of the algorithm
andthereforealsothetheoremsarenotlimitedtojustswf-nets.processmining 17
2.ti={t∈t|∃σ∈wt=first(σ)},
3.to={t∈t|∃σ∈wt=last(σ)},
4.xw={<ps,ss> |ps⊆tw∧ss⊆tw∧∀a∈ps∀b∈ssa→wb∧∀a1,a2∈psa1∦w
a2∧∀b1,b2∈ssb1∦wb2},
5.yw={<ps,ss> ∈xw|∀<ps/prime,ss/prime>∈xwps⊆ps/prime∧ss⊆ss/prime⇒<ps,ss> =<
ps/prime,ss/prime>},
6.pw={p<ps,ss> |<ps,ss> ∈yw}∪{iw,ow},
7.fw={(a,p<ps,ss>)|<ps,ss> ∈yw∧a∈ps}∪{(p<p s , s s>,b)|<ps,ss> ∈
yw∧b∈ss}∪{(iw,t)|t∈ti}∪{(t,ow)|t∈to},a n d
8.β(w)=(pw,tw,fw).
the mining algorithm constructs a petri net ( pw,tw,fw) based on some
event logw. note thattw,tiandtocan be obtained easily, i.e., the ﬁrst
three steps are self-explanatoryand linear in the size of the log. the last three
steps are also straightforward once ywhas been obtained. in fact these three
steps are linear in the size of the resulting model. it is important to see thaty
wcorresponds to the set of internal places and that these places are discovered
usingtheinsightsresultingfromthetheoremspresentedinsection5.1.themost
important and time-consuming steps are 4 and 5. step 4 attempts to ﬁnd all thepairsoftasksetssatisfyingthespeciﬁcconditionstogenerate x
w.step5isused
to ﬁnd all the largest elements in xwwith respect to set inclusion to generate
yw. to calculateyw, the complexityof these two steps is exponential in the
number of tasks. in fact, the number of tasks in a practical process is less than
100. therefore, the complexityis not a bottleneck for large-scale applications.
now we will prove the correctness of the mining algorithm. again the focus
is on the connecting places.
theorem 6. letnbe a sound swf-net and let wbe a complete event log of
n.β(w)=nmodulo renaming of places, i.e., the discovered model matches
the original model after renaming places.
the names of the corresponding places of nandnware diﬀerent because
the names of the places are not stored in the event log. however, the names of
the places less relevant because theyonlyserve as pre- and post-conditions fortasks. let us demonstrate the algorithm using the results shown in figure 6. we
show the results in everystep of the β-algorithm.
1.t
w={t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11},
2.ti={t1},
3.to={t11},
4.xw={<{t1},{t3}>,<{t1},{t4}>,...,< {t7,t10},{t9,t11}>},
5.yw={<{t1,t2},{t3}>,<{t1},{t4,t5}>,<{t3},{t2,t7}>,
<{t4,t5},{t6}>,<{t7,t8},{t8,t11}>,<{t7,t10},{t9,t11}>,
<{t6},{t7}>,<{t9},{t10}>},
6.pw={iw,ow,p<{t1,t2},{t3}>,p<{t1},{t4,t5}>,...,p <{t9},{t10}>},
7.fw={(iw,t1),(t1,p<{t1,t2},{t3}>),(p<{t1,t2},{t3}>,t3),...,(t11,ow)},
8.β(w)=(pw,tw,fw).18 lijiewenetal.
the resulting net is indeed the wf-net shown in figure 3. although this
net is not a swf-net, the algorithm can still mine it successfully. there areno redundant nodes (i.e., transitions and places) or edges (i.e., arcs) and no
information is lost except the names of places. even the short loops and parallel
routings are identiﬁed correctly. this example shows that the applicability of thealgorithm is not limited to swf-nets. it is applicable to a larger class of sound
wf-nets.
basedonthelogshownintable1wecancalculatetheorderingrelationsand
successfullydiscover the process model shown in figure 1. note that this net is
an swf net and therefore for anycomplete log, the β-algorithm will discover
the swf net modulo renaming of places, cf. theorem 6. note that the classicalα-algorithm [7] is unable to successfullymine all swf nets and will generate an
incorrect model for a log shown in table 1.
6 experimental evaluation of the work
we have developed a mining tool based on the β-algorithm and integrated it
into our workﬂow management system named webflow . this tool consists of
three parts: a simulation component, a mining component and a process editor.
the simulation component is used to generate an event log either manuallyor
automatically. the mining component is used to mine a process model from aselected event log. the process editor is used to displaythe mined process model
to the process designer for further editing.
in an experimental setting logs can be obtained in three ways: (1) as a down-
load from an operation information system (i.e., a real log), (2) a manually
created log, and (3) a log resulting from a simulation which records events in
a simulation log. for evaluation of the β-algorithm, we have used all three pos-
sibilities. in this section, we show the results of our experimental evaluation of
theβ-algorithm.
table 2 summarizes the execution time of the mining procedure for the pro-
cess model shown in figure 3 with logs having varying number of traces. here
#lis the number of traces, # tis the number of tasks, # eis the number of
events,t
mis the execution time of the whole mining procedure and tcis the ex-
ecution time of the scanning step, i.e., loading the log and building the relations.
the time unit used in table 2 is seconds.
110( 4008) 220( 7486) 440(15192) 880(30112)
11 0.19 0.21 0.41 0.43 0. 802 0. 822 1. 632 1. 652#l(#e)
#ttctm
table 2.executiontimeinseconds.
note thattmandtcdo not diﬀer much, thus indicating that most of the
time is spent on the scanning step. for clarity, we transformed the data shown
in table 2 to the two graphs shown in figure 7. these graphs clearlyshow the
linear relations between tc,tmand #l,#e.processmining 19
/g19/g19/g17/g24/g20/g20/g17/g24/g21
/g19 /g24/g19/g19 /g20/g19/g19/g19
/g6/g47/g11/g81/g88/g80/g69/g72/g85/g3/g82/g73/g3/g87/g85/g68/g70/g72/g86/g12/g40/g91/g72/g70/g88/g87/g76/g82/g81/g3/g87/g76/g80/g72/g11/g86/g12/g55/g70
/g55/g80
/g19/g19/g17/g24/g20/g20/g17/g24/g21
/g19 /g21/g19/g19/g19/g19 /g23/g19/g19/g19/g19
/g6/g40/g11/g81/g88/g80/g69/g72/g85/g3/g82/g73/g3/g72/g89/g72/g81/g87/g86/g12/g40/g91/g72/g70/g88/g87/g76/g82/g81/g3/g87/g76/g80/g72/g11/g86/g12/g55/g70
/g55/g80
figure 7.relationsbetween tm,tcand# l,#e.
to evaluate the β-algorithm fully, we change the range of # tfrom 10 to 100
and the range of # lfrom 10 to 10000. the physical size of the log is roughly
proportional to # l.f o r#l=10000, the sizes of logs are 3mb, 7mb, 16mb
and 36mb for process models with 10, 25, 50 and 100 tasks respectively. table 3
summarizestheexecutiontimeoftheminingprocedurefortheseprocessmodels.
again the time unit is seconds.
10 25 50 100
10 270 0. 019 332 0. 025 756 0. 110 1478 0. 471
100 3176 0. 171 3170 0. 210 7170 0. 451 16460 1. 361
1000 31680 1. 682 32000 2. 073 72700 4. 136 159560 9. 814
10000 317720 16.694 318900 20.720 727200 38.896 1601648 91.061#t tm#e
#l
table 3.executiontimeinsecondsfordiﬀerentmodels.
to visualize the result presented in table 3 we again show two graphs, see
figure 8. in practical process models, the number of tasks (i.e., # t) is less
than 100. the number of traces # land also the number of events # eare
typically much larger. therefore the number of traces is the dominant factor in
determining the execution time of the mining procedure. table 3 and figure 8show that the mining procedure is fast enough and scales linearlywith the input
number of events for a given process model. it also scales well with the number
of tasks in the practical process models.
/g19/g21/g19/g23/g19/g25/g19/g27/g19/g20/g19/g19
/g19 /g24/g19 /g20/g19/g19 /g20/g24/g19
/g6/g55/g11/g81/g88/g80/g69/g72/g85/g3/g82/g73/g3/g87/g68/g86/g78/g86/g12/g40/g91/g72/g70/g88/g87/g76/g82/g81/g3/g87/g76/g80/g72/g11/g86/g12/g6/g47/g32/g20/g19
/g6/g47/g32/g20/g19/g19
/g6/g47/g32/g20/g19/g19/g19
/g6/g47/g32/g20/g19/g19/g19/g19
/g19/g21/g19/g23/g19/g25/g19/g27/g19/g20/g19/g19
/g19 /g24/g19/g19/g19 /g20/g19/g19/g19/g19 /g20/g24/g19/g19/g19
/g6/g47/g11/g81/g88/g80/g69/g72/g85/g3/g82/g73/g3/g87/g85/g68/g70/g72/g86/g12/g40/g91/g72/g70/g88/g87/g76/g82/g81/g3/g87/g76/g80/g72/g11/g86/g12/g6/g55/g32/g20/g19
/g6/g55/g32/g21/g24
/g6/g55/g32/g24/g19
/g6/g55/g32/g20/g19/g19
figure 8.executiontimefordiﬀerentmodelsusingdiﬀerenttraces.
from the experimental evaluation, it is clear that the mining procedure is
suitable for practical situations. it runs fast and scales well for large-scale ap-20 lijiewenetal.
plications. as far as the qualityof the mining algorithm is concerned, the β-
algorithm can mine all of the sound swf-nets successfully. in fact, in somecases sound wf-nets that do not satisfyall requirements of an swf-net can
still be rediscovered provided that the log is complete.
7 conclusion and future work
in this paper, a new mining algorithm was presented: the β-algorithm. a dis-
tinguishing feature of the β-algorithm is that it exploits the fact that tasks take
time and therefore parallelism can be detected explicitly. to do this, event logs
with two kinds of event types, i.e., start and complete, are considered.
usingthesetwotypesofeventsitispossibletoseeifoccurrencesoftasksoverlap.together with causalityinformation, this is used to derive the ordering relations
→
w,#w,o r/bardblw. based on these relations the β-algorithm constructs a petri
net. assuming a complete log, it can be proven that the β-algorithm is able to
correctlydiscover anyswf-net. in fact the application is not limited to swf-
nets, i.e., it can be applied to anyevent log with start and complete
events. however, for some non-swf-nets the result maybe incorrect. throughexperimental evaluation of the work, we demonstrated that the β-algorithm is
simple, fast and powerful enough to be used in practical situations.
theβ-algorithm can be seen as an extension of the α-algorithm. some of
the known problems of the α-algorithm, e.g., short-loops, are tackled bythe
β-algorithm using fundamentallydiﬀerent ordering relations. however, there is
also a drawback. the α-algorithm can be applied in environments where tasks
are considered to be atomic, e.g., just the complete events are logged. in
such environments the α-algorithm will be unable to detect parallelism, while
theα-algorithm is able to do this implicitly(assuming interleaving semantics).
our future work will focus on the following three aspects. first of all, we
plan to further evaluate and applythe mining algorithm in practical situations.secondly, we plan to improve the storage structure of the event log and reduce
the running time of the mining procedure even further. finally, we will investi-
gate which kind of sound non-swf-nets (i.e., ordinarysound wf-nets) can berediscovered bythe β-algorithm.
acknowledgements
the authors would like to thank ton weijters, ana karla alves de medeiros,
boudewijn van dongen, minseok song, laura maruster, eric verbeek, monique
jansen-vullers, hajo reijers, michael rosemann, and peter van den brand fortheir on-going work on process mining techniques and tools at eindhoven uni-
versityof technology .
references
1. w.m.p.vanderaalst. theapplicationofpetrinetstoworkﬂowmanagement.
the journal of circuits, systems and computers ,8(1):21–66,1998.processmining 21
2. w.m.p.vanderaalstandb.f.vandongen. discoveringworkﬂowperformance
modelsfromtimedlogs.iny.han,s.tai,andd.wikarski,editors, international
conference on engineering and deployment of cooperative information systems(edcis 2002) ,volume2480of lecture notes in computer science ,pages45–63.
springer-verlag,berlin,2002.
3. w.m.p.vanderaalstandk.m.vanhee. workﬂow management: models, methods,
and systems. mitpress,cambridge,ma,2002.
4. w.m.p.vanderaalstandm.song. miningsocialnetworks:uncoveringinterac-
tionpatternsinbusinessprocesses. inm.weske,b.pernici,andj.desel,editors,
international conference on business process management (bpm 2004) ,lecture
notesincomputerscience.springer-verlag,berlin,2004.
5. w.m.p.vanderaalst,b.f.vandongen,j.herbst,l.maruster,g.schimm,and
a.j.m.m.weijters. workﬂowmining:asurveyofissuesandapproaches. data
and knowledge engineering ,47(2):237–267,2003.
6. w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining ,s p e c i a l
issueofcomputersinindustry,volume53,number3.elseviersciencepublishers,
amsterdam,2004.
7. w.m.p.vanderaalst,a.j.m.m.weijters,andl.maruster.workﬂowmining:dis-
coveringprocessmodelsfromeventlogs.quttechnicalreport,fit-tr-2003-03,
queensland university of technology, brisbane, 2003. (accepted for publicationinieeetransactionsonknowledgeanddataengineering.).
8. r.agrawal,d.gunopulos,andf.leymann. miningprocessmodelsfromwork-
ﬂow logs. in sixth international conference on extending database technology ,
pages469–483,1998.
9. d.angluinandc.h.smith.inductiveinference:theoryandmethods. computing
surveys,15(3):237–269,1983.
10. j.e.cookanda.l.wolf. discoveringmodelsofsoftwareprocessesfromevent-
based data. acm transactions on software engineering and methodology ,
7(3):215–249,1998.
11. j.e.cookanda.l.wolf. event-baseddetectionofconcurrency. in proceedings
of the sixth international symposium on the foundations of software engineering(fse-6),pages35–45,1998.
12. j.e.cookanda.l.wolf. softwareprocessvalidation:quantitativelymeasuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology ,8(2):147–176,1999.
13. j.deselandj.esparza. free choice petri nets ,volume40of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
14. j. eder, g.e. olivotto, and wolfgang gruber. a data warehouse for workﬂow
logs. in y. han, s. tai, and d. wikarski, editors, international conference on
engineering and deployment of cooperative information systems (edcis 2002) ,
volume2480of lecture notes in computer science ,pages1–15.springer-verlag,
berlin,2002.
15. a.ehrenfeuchtandg.rozenberg. partial(set)2-structures-part1andpart2.
acta informatica ,27(4):315–368,1989.
16. e.m. gold. language identﬁcation in the limit. information and control ,
10(5):447–474,1967.
17. e.m.gold.complexityofautomatonidentiﬁcationfromgivendata. information
and control,37(3):302–320,1978.22 lijiewenetal.
18. d.grigori,f.casati,u.dayal,andm.c.shan.improvingbusinessprocessqual-
ity through exception understanding, prediction, and prevention. in p. apers,
p. atzeni, s. ceri, s. paraboschi, k. ramamohanarao, and r. snodgrass, ed-itors, proceedings of 27th international conference on very large data bases
(vldb’01),pages159–168.morgankaufmann,2001.
19. j.herbst.amachinelearningapproachtoworkﬂowmanagement.in proceedings
11th european conference on machine learning ,volume1810of lecture notes in
computer science ,pages183–194.springer-verlag,berlin,2000.
20. j.herbst. dealingwithconcurrencyinworkﬂowinduction. inu.baake,r.zo-
bel,andm.al-akaidi,editors, european concurrent engineering conference .scs
europe,2000.
21. j. herbst. ein induktiver ansatz zur akquisition und adaption von workﬂow-
modellen. phdthesis,universit¨ atulm,november2001.
22. j.herbstandd.karagiannis. integratingmachinelearningandworkﬂowman-
agement to support acquisition and adaptation of workﬂow models. in pro-
ceedings of the ninth international workshop on database and expert systemsapplications,pages745–752.ieee,1998.
23. j. herbst and d. karagiannis. an inductive approach to the acquisition and
adaptationofworkﬂowmodels. inm.ibrahimandb.drabble,editors, proceed-
ings of the ijcai’99 workshop on intelligent workﬂow and process management:the new frontier for ai in business , pages 52–57, stockholm, sweden, august
1999.
24. j.herbstandd.karagiannis. integratingmachinelearningandworkﬂowman-
agementtosupportacquisitionandadaptationofworkﬂowmodels. international
journal of intelligent systems in accounting, finance and management ,9:67–92,
2000.
25. idsscheer. arisprocessperformancemanager(arisppm). http://www.ids-
scheer.com,2002.
26. b. kiepuszewski. expressiveness and suitability of languages for control flow
modelling in workﬂows . phdthesis,queenslanduniversityoftechnology,bris-
bane,australia,2003. availableviahttp://www.workﬂowpatterns.com.
27. h. mannila and d. rusakov. decomposing event sequences into independent
components. in v. kumar and r. grossman, editors, proceedings of the first
siam conference on data mining ,pages1–17.siam,2001.
28. h. mannila, h. toivonen, and a.i. verkamo. discovery of frequent episodes in
eventsequences. data mining and knowledge discovery ,1(3):259–289,1997.
29. l. maruster, w.m.p. van der aalst, a.j.m.m. weijters, a. van den bosch, and
w.daelemans. automateddiscoveryofworkﬂowmodelsfromhospitaldata. in
b.kr¨ose,m.derijke,g.schreiber,andm.v ansomeren,editors, proceedings of
the 13th belgium-netherlands conference on artiﬁcial intelligence (bnaic 2001) ,
pages183–190,2001.
30. l. maruster, a.j.m.m. weijters, w.m.p. van der aalst, and a. van den bosch.
processmining:discoveringdirectsuccessorsinprocesslogs. in proceedings of
the 5th international conference on discovery science (discovery science 2002) ,
volume 2534 of lecture notes in artiﬁcial intelligence , pages 364–373. springer-
verlag,berlin,2002.
31. m.k. maxeiner, k. k¨ uspert, and f. leymann. data mining von workﬂow-
protokollenzurteilautomatisiertenkonstruktionvonprozemodellen. in proceed-
ings of datenbanksysteme in b¨ uro, technik und wissenschaft ,pages75–84.infor-
matikaktuellspringer,berlin,germany,2001.processmining 23
32. j.l.moreno. who shall survive? nervousandmentaldiseasepublishingcom-
pany,washington,dc,1934.
33. m. zur m¨ uhlen. process-driven management information systems combining
datawarehousesandworkﬂowtechnology. inb.gavish,editor, proceedings of
the international conference on electronic commerce research (icecr-4) ,pages
550–566.ieeecomputersocietypress,losalamitos,california,2001.
34. m. zur m¨ uhlen. workﬂow-based process controlling-or: what you can mea-
sureyoucancontrol. inl.fischer,editor, workﬂow handbook 2001, workﬂow
management coalition ,pages61–77.futurestrategies,lighthousepoint,florida,
2001.
35. m.zurm¨ uhlenandm.rosemann. workﬂow-basedprocessmonitoringandcon-
trolling-technicalandorganizationalissues. inr.sprague,editor, proceedings
of the 33rd hawaii international conference on system science (hicss-33) ,pages
1–10.ieeecomputersocietypress,losalamitos,california,2000.
36. r. parekh and v. honavar. automata induction, grammar inference, and lan-
guageacquisition. indale,moisl,andsomers,editors, handbook of natural lan-
guage processing .newyork:marceldekker,2000.
37. l.pitt. inductiveinference,dfas,andcomputationalcomplexity. ink.p.jan-
tke, editor, proceedings of international workshop on analogical and inductive
inference (aii) , volume 397 of lecture notes in computer science , pages 18–44.
springer-verlag,berlin,1889.
38. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume1491of lecture notes in computer science .springer-verlag,berlin,1998.
39. m.sayal,f.casati,andm.c.shanu.dayal. businessprocesscockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb’02) ,
pages880–883.morgankaufmann,2002.
40. g.schimm. processmining. http://www.processmining.de/.
41. g.schimm.genericlinearbusinessprocessmodeling.ins.w.liddle,h.c.mayr,
and b. thalheim, editors, proceedings of the er 2000 workshop on conceptual
approaches for e-business and the world wide web and conceptual modeling ,
volume1921of lecture notes in computer science ,pages31–39.springer-verlag,
berlin,2000.
42. g.schimm.processminingelektronischergesch¨ aftsprozesse.in proceedings e lek-
tronische gesch¨ aftsprozesse,2001.
43. g. schimm. process mining linearer prozessmodelle - ein ansatz zur automa-
tisierten akquisition von prozesswissen. in proceedings 1. konferenz profes-
sionelles wissensmanagement ,2001.
44. g. schimm. process miner - a tool for mining process schemes from event-
based data. in s. flesca and g. ianni, editors, proceedings of the 8th european
conference on artiﬁcial intelligence (jelia) ,v o l u m e2 4 2 4o f lecture notes in
computer science ,pages525–528.springer-verlag,berlin,2002.
45. j.scott. social network analysis . sage,newburyparkca,1992.
46. staﬀware. staﬀwareprocessmonitor(spm). http://www.staﬀware.com,2002.
47. a.j.m.m.weijtersandw.m.p.vanderaalst. processmining:discoveringwork-
ﬂowmodelsfromevent-baseddata. inb.kr¨ ose,m.derijke,g.schreiber,and
m.vansomeren,editors, proceedings of the 13th b elgium-netherlands conference
on artiﬁcial intelligence (bnaic 2001) ,pages283–290,2001.
48. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data. in v. hoste and g. de pauw, editors, proceedings of
the 11th dutch-belgian conference on machine learning (benelearn 2001) ,pages
93–100,2001.24 lijiewenetal.
49. a.j.m.m. weijters and w.m.p. van der aalst. workﬂow mining: discovering
workﬂow models from event-based data. in c. dousson, f. h¨ oppner, and
r.quiniou,editors, proceedings of the ecai workshop on knowledge discovery
and spatial data ,pages78–84,2002.
50. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering,10(2):151–162,2003.
appendix
theorem 1. letn=(p,t,f)be a sound wf-net and let wbe a complete
event log ofn. for anya,b∈t:a→wbimpliesa•∩•b/negationslash=∅.
proof.assumea→wbanda•∩•b=∅. we will show that this assumption
leads to a contradiction and thus prove the theorem. from deﬁnition 13, we
know thata→wbimpliesa>wband¬(a×wb). sincea>wbthere exists
at least one trace σ=e1e2e3···en∈wsuch that ∃i,j2≤i≤n−2∧i<
j<nsuch thatei.type=complete, ei.task=a,ej.type=start,ej.task=b
and there is not anytask occurrence between eiandej.f o r ∀ki<k<j and
ek.type=complete, we know that ekcan occur before eiin some traces.
similarly, for ∀mi<m<j andem.type=start, we know that emcan wait
untilejoccurs. thus we can get a marking mofn, under whichacan complete
and afteracompletes,bcan start immediately. because a•∩•b=∅,adoes not
produce tokens for anyinput place of b. so under the marking m,bcan start
beforeacompletes. therefore, we can ﬁnd a×wbfrom the log and a/bardblwbholds.
this result contradicts a→wband we conclude that a→wbimpliesa•∩•b/negationslash=∅.
theorem 2. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b∈t:a•∩•b/negationslash=∅impliesa→wb.
proof.becausea•∩•b/negationslash=∅, we assume a place p∈a•∩•b. we should prove this
theoremfromthefollowingtwosituationspartitionedaccordingtothepropertiesof an swf-net.
1.|p•|>1. thus |•b|=1,bcan start after acompletes and a>
wbholds in
the log. remains to prove ¬(a×wb). if|•p|=1,bcannot start before a
completes. if |•p|>1, thenbmight start before acompletes and a×wb
might hold. if this assumption is true, there should be one token in punder
some markingm.i facompletes under m,awill produce one token for p
and there would be two tokens in p. we get a contradiction, thus ¬(a×wb)
holds. sincea>wband¬(a×wb), we concludea→wb.
2.|p•|=1. if |•b|=1, the proof is as before. if |•b|>1, then |•p|=1.bcannot
start beforeacompletes and ¬(a×wb). beforeacompletes, there should
be a markingmsuch thatmcovers all other input places of bexceptp.i f
not, there should be one path leading from ato the remainder input places
ofb.t h u spbecomes an implicit place connecting aandb, which violates
the swf-net requirement. under the marking m, whenacompletes,bcan
start immediately. so a>wbholds and we conclude a→wb.processmining 25
theorem 3. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b∈t:
1. ifa•∩b•/negationslash=∅, thena∦wb.
2. if•a∩•b/negationslash=∅, thena∦wb.
proof.assumea/bardblwbin both situations, we will show that this can lead to a
contradiction respectivelyfor the following two parts.
1. assume a place p∈a•∩b•.f o ra/bardblwb, there should at least be one
“overlapping sequence” in the log, i.e., a×wb. since the complete event
of a task mayoccur at anytime after the corresponding start event, there
maybe a snippet ( a,1)(b,1) or (b,1)(a,1) in some trace. in this case, there
will be a marking mthat does not cover p, under which both aandbhave
startedandcancompleteimmediately.thus pwillcontainatleasttwotokens
afteraandbcomplete and the net is not safe. so we get a contradiction and
a∦wbholds.
2. assume a place p∈•a∩•b.f o ra/bardblwb, there should be at least a sequence
a×wbin the log. there will be a marking mof the net under which pis
covered andaorbcan start. (note that |•a|=|•b|= 1.) but after aor
bstarts, the onlytoken in pis consumed and the other transition can not
start. the other one will wait until there is a token in pagain. so a snippet
of (a,0)(c,1)(b,0) or (b,0)(c,1)(a,0) will appear in some trace in the log.
however, the complete event of cmaystart before the start event of
aorb. under the marking m,(c,1) mayoccur just before ( a,0) or (b,0) and
thus there will be two tokens in the place p, i.e., the net is not safe. so we
get a contradiction and a∦wbholds.
theorem 4. letn=(p,t,f)be a sound swf-net and let wbe a complete
event log ofn. for anya,b,c ∈t:
1. ifa→wc,b→wcanda∦wb, thena•∩b•∩•c/negationslash=∅.
2. ifc→wa,c→wbanda∦wb, thenc•∩•a∩•b/negationslash=∅.
proof.now we should prove the above two sub theorems respectively.
1. from theorem 1 and a→wc, we deducea•∩•c/negationslash=∅. we assume a place
p1∈a•∩•c. similarly, we assume a place p2∈b•∩•c.t op r o v et h et h e o r e m ,
we make an assumption that a•∩b•∩•c=∅, i.e., for anyp1andp2,p1/negationslash=p2.
because the net nis an swf-net, |p1•|=|•p1|=|p2•|=|•p2|=1 holds. thus
a,bandcwill execute the same number of times. if astarts beforebstarts,
aalways completes before bstarts, i.e.,bcan onlystart after acompletes in
this situation (a∦wb). there should be at least one path lableading from
atobon the net. after acompletes,awill produce tokens for the ﬁrst place
onlab. similarly, one path lbaleads frombtoaand afterbcompletes,
bwill produce tokens for the ﬁrst places on lba. afteraandbcomplete
successively, some tokens are left on lba. there should be some transitions
not onlbawhich consume the left tokens. since nis an swf-net, these26 lijiewenetal.
transitions all have one input place on lbaand then these transitions cannot
includec(chas at least two input places p1andp2). once the onlyinput
place contains a token, theymayconsume it (free choice). similarly , there
should be some transitions not on labwhich consume the left tokens too.
thus there will be a marking mofn, which coversp1only(aexecutes ﬁrst
andbstill has to execute next) but does not cover p2because the tokens
onlabhave been consumed byother transitions (neither bnorc)a n db,c
could not execute this time, i.e., a deadlock occurs. therefore, the net is notsound and we get a contradiction. thus the assumption is wrong and p
1is
the same asp2, i.e.,a•∩b•∩•c/negationslash=∅.
2. from theorem 1 and c→wa, we derivec•∩•a/negationslash=∅. we assume a place
p1∈c•∩•a.similarly,weassumeaplace p2∈c•∩•b.toprovethetheorem,
we make an assumption that c•∩•a∩•b=∅, i.e., for anyp1andp2,p1/negationslash=p2.
according toc→wa,a f t e rccompletes, there should be a marking munder
whichacan start and both p1andp2contain one token. in this situation,
p1/∈•bandp2/∈•ahold. afterastarts,aconsumes the onlytoken in p1and
there is still a token in p2. now let us investigate what will happen to band
for this purpose we distinguish two situations: (i) |p2•|>1 and (ii) |p2•|=1.
assume |p2•|>1. thus we get |•b|=1. because the onlyinput place of
bcontains one token, bcan start immediately. there will be at least one
sequence in the log containing the snippet ( a,0)(b,0) anda×wb.w eg e t
the relationa/bardblwb, which is conﬂicting with the premise a∦wb. therefore
we get a contradiction.
assume |p2•|=1. if |•b|=1, the situation is similar to (i) and we can get
a contradiction. if |•b|>1,bmust start ﬁnallybecause there is a token in
one of its input places which can onlybe consumed by b. becausea∦wb
andahas started,bcan onlystart after acompletes, i.e., the start of bis
dependent on the completion of a.t h u st h e r ei sap a t h lableading from
atob. similarly, there is a path lbaleading frombtoa. the remainder
of the proof is similar to the situation considered before. again, we get a
contradiction.
as a consequence, p1andp2must be the same place and c•∩•a∩•b/negationslash=∅.
theorem 5. letn=(p,t,f)be a sound swf-net and let wbe a com-
plete event log of n. for any two task sets psandss, such thatps⊆t,
ss⊆t:∀a∈ps∀b∈ssa→wb,∀a1,a2∈psa1∦wa2and∀b1,b2∈ssb1∦wb2iﬀ
∃p∈p∀a∈ps∀b∈ssa•∩•b={p}.
proof.we should prove the theorem in both directions.
1. assume ∃p∈p∀a∈ps∀b∈ssa•∩•b={p}. using theorem 2, it is easyto
see that ∀a∈ps∀b∈ssa→wb. using theorem 3 we can also show that the
elements ofpsand the elements in sscannot be in parallel.
2. assume ∀a∈ps∀b∈ssa→wb,∀a1,a2∈psa1∦wa2a n d ∀b1,b2∈ssb1∦wb2.
from ∀a∈ps∀b∈ssa→wband theorem 1, we derive that a•∩•b/negationslash=∅for
anya∈psand anyb∈ss. from the propertyof an swf-net, we get
|a•∩•b|=1. from ∀a1,a2∈psa1∦wa2a n da1→wbanda2→wb,w eg e tprocessmining 27
a1•∩a2•∩•b/negationslash=∅(theorem 4) where bcan be anytask in ss. note that
|a1•∩a2•∩•b|=1. hence we can deduce that a1•∩•b=a2•∩•b={p}
for somepand complete the proof.
theorem 6. letnbe a sound swf-net and let wbe a complete event log of
n.β(w)=nmodulo renaming of places, i.e., the discovered model matches
the original model after renaming places.
proof.letn=(p,t,f)a n dβ(w)=nw=(pw,tw,fw). based on the com-
pleteness ofwand mining step 1 of the βalgorithm, we get tw=t. for the
source and sink places (i.e., iando)o fn, there are the source and sink places
iwandowofnwsuch thatiw•=i•∧•ow=•oand vice versa. remains to
prove that the “internal places” of the two petri nets nandnwmatch.
1. first we prove that ∀p∈p\{i,o}∃pw∈pw\{iw,ow}•pw=•p∧pw•=p•.
according to the β-algorithm and theorem 5, we know that <•p,p•>∈xw
and∃pw∈pw•p⊆•pw∧p•⊆pw•, i.e.,<•pw,pw•>∈yw. assume that
∃t/prime∈tt/prime∈•pw∧t/prime/∈•p. from theorem 4, we get that ∀tp∈•p∀ts∈p•tp•∩t/prime•∩•
ts/negationslash=∅. assume thatp/prime∈tp•∩t/prime•∩•ts. becauset/prime/∈•p, we know that p/prime/negationslash=p.
therefore for ∀ts∈p•∃p/prime∈•ts|•ts|>1∧| •p/prime|>1. this violates the second
requirement of an swf-net and we get a contradiction. if we assume that
∃t/prime∈tt/prime∈pw•∧t/prime/∈p•, we can still get a similar contradiction. therefore we
prove the result in one direction.
2. finally, we prove ∀pw∈pw\{iw,ow}∃p∈p\{i,o}•p=•pw∧p•=pw•.
according to the β-algorithm and pw∈pw, we know that <•pw,pw•>∈
yw. theorem 5 can be used to show that ∃p∈p∀a∈•pw∀b∈pw•a•∩•b={p}.
therefore we deduce •pw⊆•p∧pw•⊆p•. assume that ∃t/prime∈tt/prime∈•p∧t/prime/∈
•pw. using theorem 2 and theorem 3 we can show that ∀t∈•pwt/prime∦wtand
∀t∈pw•t/prime→wt. therefore we can prove that <•pw∪{t/prime},pw•>∈ywand
thus obtain a contradiction. if we assume that ∃t/prime∈tt/prime∈p•∧t/prime/∈pw•,w ec a n
also get a contradiction, thus complete the proof.