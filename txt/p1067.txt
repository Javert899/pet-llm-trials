modeling and reasoning over declarative data-aware
processes with object-centric behavioral constraints
alessandro artale1, alisa kovtunova1, marco montali1, and wil m.p. van der aalst2
1free university of bozen-bolzano, italy
surname@inf.unibz.it
2process and data science, rwth aachen university, germany
wvdaalst@pads.rwth-aachen.de
abstract. existing process modeling notations ranging from petri nets to bpmn
have difﬁculties capturing the data manipulated by processes. process models of-
ten focus on the control ﬂow, lacking an explicit, conceptually well-founded in-
tegration with real data models, such as er diagrams or uml class diagrams. to
overcome this limitation, object-centric behavioral constraints (ocbc) models
were recently proposed as a new notation that combines full-ﬂedged data models
with control-ﬂow constraints inspired by declarative process modeling notations
such as declare and dcr graphs. we propose a formalization of the ocbc
model using temporal description logics. the obtained formalization allows us
to lift all reasoning services deﬁned for constraint-based process modeling no-
tations without data, to the much more sophisticated scenario of ocbc. fur-
thermore, we show how reasoning over ocbc models can be reformulated into
decidable, standard reasoning tasks over the corresponding temporal description
logic knowledge base.
1 introduction
despite the plethora of notations available to model business processes, process model-
ers struggle to capture real-life processes using mainstream notations such as business
process model and notation (bpmn), event-driven process chains (epc), and uml
activity diagrams. all such notations require the simplifying assumption that each pro-
cess model focuses on a single, explicitly deﬁned case notion (also referred to as process
instance ). the discrepancy between the single case view and reality becomes evident
when using process mining techniques to reconstruct processes based on the available
data [2]. process mining starts from the available data and, unless one is using a busi-
ness process management (bpm) or workﬂow management (wfm) system for process
execution, explicit case information is typically missing. process-centric diagrams us-
ing bpmn, epcs, or uml describe the life-cycle of individual cases. when formal
languages like petri nets, automata, and process algebras are used to describe business
processes, they tend to model cases in isolation, and the data perspective is secondary
or missing completely. languages like bpmn allow modelers to attach data to pro-
cesses, but without the possibility to express complex constraints over such data (e.g.,
cardinality constraints, is-a links, disjointness, covering, etc. as in er/uml/orm data
models). mainstream business process modeling notations describe the lifecycle of onetype of process instance at a time missing the opportunity to capture the co-evolution
of multiple, interacting instances. in particular, complex constraints over data attached
to processes must inﬂuence the behavior of the process itself—e.g., consider the man-
agement of different orders, where the evolution of one order impacts on the possible
evolutions of the related orders.
object-centric behavioral constraint (ocbc) [3, 21, 22] models have been pro-
posed as a modeling language that combines ideas from declarative, constraint-based
languages like declare [1], and from data modeling languages. ocbc allows to:
(i)describe the temporal interaction between activities in a given process and to at-
tach (structured) data to processes in a uniﬁed framework ;(ii)model the interactions
between multiple process instances , speciﬁcally when there is a one-to-many ormany-
to-many relationship between them. fig. 1 illustrates the way in which ocbc models
tackle the above two issues. register email andsend invite are two activities re-
lated to object classes person andmeeting , respectively. a meeting is organized by
many persons, each of which can in turn organize many meetings. the double-headed
arrow connecting register email andsend invite expresses the constraint that an
invitation for a meeting can be sent only if at least one organizer of that meeting has
previously registered her e-mail. assuming that the object targeted by each activity is
indeed a case for that activity, this simple example already contains two distinct case
notions ( person andmeeting ) that are intertwined. in conventional notations, this can
only be modeled from the viewpoint of one of the two instances: the registration pro-
cess of a person or the invitation process for a meeting. taking the latter viewpoint using
conventional notations such as bpmn would require to explicitly introduce a loop to
handle the registration of one or more persons organizing a meeting. however, this is in-
correct because one registration may be followed by many meetings. one-to-many and
many-to-many relationships lead to convergence and divergence problems that cannot
be handled in notations describing isolated cases.
register
emailsend
invite
person meeting
organizesof0..1
1is for0..1
1
fig. 1: an ocbc constraintocbc models are related to artifact- and data-
centric approaches [12, 16, 19] aiming to integrate
data and processes. however, this is not done in a
single diagram representing different types of pro-
cess instances and their interactions. in addition,
these approaches usually assume complete knowl-
edge over the data, and require to fully spell out
data updates when specifying the activities [26, 14]. the few proposals dealing with
artifact-centric models with incomplete knowledge [10] do not come with a fully inte-
grated, declarative semantics as done here, but follow instead the levesque functional
approach [20] to separate the evolution of the system from the inspection of (incom-
plete) knowledge in each state.
this paper provides a complete characterization of the formal semantics of the
ocbc approach, unambiguously deﬁning the logical meaning of ocbc constraints.
we provide a visual and textual syntax for ocbc, then deﬁning the semantics of the
different modeling constructs in terms of temporal description logics , i.e., a temporal
extension of (fragments of) the well-known owl language. the obtained formaliza-
tion, in turn, allows us to lift all reasoning services deﬁned for constraint-based process6
78create
orderpay
order
pick
itemwrap
itemdeliver
items
order order line delivery
product
customer1
contains

belongs to 1
is for11..
results in0..1
1 receivescreates
1
11
closes
1ﬁlls2
11
prepares
1refers to
113
5
4
fig. 2: example of an ocbc model
modeling notations without data, to the much more sophisticated setting of ocbc. in
particular, we show how reasoning over ocbc models can be reformulated into decid-
able, standard reasoning tasks over the corresponding temporal description logic knowl-
edge base, giving solid foundations to the boundaries of decidability and complexity of
reasoning over processes and their manipulated data.
the paper is organized as follows. we present a running example in sect. 2. sect. 3
brieﬂy illustrates the temporal dl that will be used to encode and reason over ocbc
models. sect. 4 shows the syntax for ocbc models and their semantics via the temporal
dl encoding. reasoning and veriﬁcation tasks for ocbc models are tackled in sect. 5.
we present our remarks and future work in sect. 6.
2 running example
the driving assumption underlying our proposal is that processes are modeled as a
mirror of their manipulated data. such data is structured according to complex data
modeling constraints (see the lower part of fig. 2). data can be attached to activities
(see the dotted lines of fig. 2) and ad-hoc co-reference constraints can be expressed on
those manipulated data (see the dash-dotted lines of fig. 2) describing how activities
can share/reuse the same data objects.
example 1. fig. 2 shows an ocbc model for a process composed by ﬁve activities
(createorder ,pickitem ,wrapitem ,payorder anddeliveritems ) and ﬁve object
classes in the data model ( order ,orderline ,delivery ,product andcustomer ).
the top part describes the temporal ordering of activities and the bottom part how ob-
jects relevant for the process execution are structured (read the lower part as a standard
uml class diagram). the middle layer (dotted lines) relates activities and data. we
now informally describe the constructs highlighted in fig. 2. 1there is a one-to-
one correspondence between a createorder activity and an order , i.e., the execu-
tion of a createorder activity creates a unique order and, vice-versa, due to the 1o1:order
ol1:order line
ol2:order line
ol3:order line
d1:delivery
d2:delivery. . .
. . .
. . .
. . .
. . .
. . .co1:create orderpi1:pick itempi2:pick itemwi1:wrap itemwi2:wrap itempi3:pick itemwi3:wrap itempo1:pay orderdi1:deliver itemsdi2:deliver items
t0 t1 t2 t3 t4 t5 t6 t7 t8 t9createsfills
containsfills
containspreparespreparesfills
containspreparesclosesrefers to
results in
results inrefers to
results in
fig. 3: trace fragment for the ocbc model in fig. 2
on the createorder side, each order has been generated by a single execution of a
createorder activity. 2every execution of the pickitem activity refers to a unique
orderline and each orderline has been generated by an execution of a pickitem
activity (and not by a wrapitem activity). 3each createorder activity is followed
by exactly one (single arrow) payorder activity related to the same order. 4each
payorder activity is preceded by possibly many (double arrow) pickitem activities.
5whenever we execute payorder we will never execute pickitem on the same paid
order. 6the dash-dotted line denotes a co-reference constraint over an object class,
imposes that when the createorder creates an order instance, thatorder instance will
eventually be paid by executing a payorder activity. 7the dash-dotted line is, in this
case, a co-reference constraint now over a relationship which imposes that when we
ﬁll an order line it must have been contained in exactly one order created by executing
acreateorder activity. since an order line instance could not exist at the same time
we create an order instance and relationships are instantiated by co-existing objects, the
uml model correctly speciﬁes that, at each point in time, each order participates zero
or more times in the contains relation. on the other hand, the co-reference constraint
together with the mandatory cardinalities constraints and the temporal constraints be-
tween createorder ,payorder andpickitem imply the eventual existence of at least
oneorder line contained in any given order. 8the dash-dotted line starting with a 
denotes a negative co-reference constraint that forbids ﬁlling with further order lines an
order that has been closed by a payorder activity.
a possible execution of an ocbc process, called in the following trace fragment ,
records at once events, with their execution time, and the objects they operate on. in
addition, it also captures facts that are known to hold over such objects in a given
timestamp, in particular, the classes to which objects belong to at that time, as well
as how objects are related to each other. in addition, the trace fragment captures, as
customary in a standard ﬁrst-order logic setting, incomplete knowledge about a process
execution, and ocbc constraints are hence interpreted under the open-world seman-
tics. this means that a trace fragment conforms to an ocbc model if it can be extendedtowards a full trace that satisﬁes all the constraints contained therein. a trace fragment
conforming to the ocbc model of fig. 2 is depicted in fig. 3 and shown in the follow-
ing ﬁrst-order logic notation (but also as a dl abox after a small transformation). we
abbreviate activity names with their initials. instances of activities, classes and relation-
ships are timestamped denoting the execution time of the activity, and the time point
when the described fact holds (timestamps respect the time ordering starting from t0).
co(co1;t0);pi(pi1;t1);pi(pi2;t2);wi(wi1;t3);wi(wi2;t4);pi(pi3;t5);wi(wi3;t6);po(po1;t7);
di(di1;t8);di(di2;t9);creates (co1;o1;t0);fills (pi1;ol1;t1);contains (o1;ol1;t1);fills (pi2;ol2;t2);
contains (o1;ol2;t2);prepares (wi1;ol1;t3);prepares (wi2;ol2;t4);fills (pi3;ol3;t5);
contains (o1;ol3;t5);prepares (wi3;ol3;t6);closes (po1;o1;t7);refers to (di1;d1;t8);
results in (ol1;d1;t8);results in (ol2;d1;t8);refers to (di2;d2;t9);results in (ol3;d2;t9);
the process described in the example cannot be modeled using conventional process
modeling languages, because (a) three different types of instances (of activities, classes
and also relationships instances) are intertwined in a uniform framework so that no
further coding or annotations are needed, and (b) cardinality and structural constraints
in the object class model inﬂuence the allowed behavior of activities, and vice-versa.
take, e.g., the fact that in the example we have three different orderline instances
(ol1;ol2;ol3), then, together with the co-reference constraints on orderline , we im-
plicitly enforce the occurrence of three different pickitem andwrapitem activities.
3 a gentle introduction to temporal dls
since description logics (dls) are able to capture data models [11, 4, 17] and are the
logical formalism underpinning ontologies expressed in the standard web ontology
language owl ( www.w3.org/2007/owl ), while the linear temporal logic (ltl) is
able to formalize the temporal interweaving of the activities in a process [1], we propose
here to use temporal description logics based on tusalcqi and its fragments [27,
18, 8] to formally describe the semantics of ocbc models and to capture in a uniform
formalism both the processes and their attached data.
tusalcqi is one of the most expressive and still decidable temporal descrip-
tion logics. the language alphabet contains object names a 0;a1;:::,concept names
a0;a1;::: androle names p 0;p1;:::. then, roles r andconcepts c are given by the
following grammar:
r::=pijr c::=>jaij(qr c )j:cjc1uc2jc1uc2jc1sc2
where r denotes the inverse of the role r(obtained by reversing the relation r) and qis
a positive integer. we use the standard abbreviations: c1tc2=:(:c1u:c2),?=:>,
9r= (1r>),9r.c= (1r c),(qr c ) =:((q+1)r c).furthermore, all
the temporal operators used in ltl can be expressed via s‘since’ andu‘until’ [18].
operators 3fand3p(‘sometime in the future/past’) can be expressed as 3fc=>uc
and3pc=>sc; operators 2f(‘always in the future’) and 2p(‘always in the past’)
are deﬁned as dual to 3fand3p, i.e.,2fc=:3f:cand2pc=:3p:c. the non-
strict operators (including the current evaluation time), denoted as 3+
pand3+
f, can be
captured as 3+
pc=cu3pcand3+
fc=cu3fc(similarly, 2+
pand2+
fare deﬁnedas the dual operators of 3+
pand3+
f, respectively). the ‘always’ operator 2can be
expressed as 2c=2f2pc, while the dual ‘sometime’ is deﬁned as 3c=:2:c.
finally, the temporal operators f(‘next time’) and p(‘previous time’) can be deﬁned
asfc=?ucandpc=?sc.
atusalcqi tboxtis a ﬁnite set of concept androle inclusion axioms of the
form c1vc2andr1vr2, respectively. an abox ,a, consists of assertions of the form
nak(ai);npk(ai;aj);where akis a concept name, pka role name, ai,ajobject names
and, for n2z,
n=ff|{z}
ntimes;ifn0;andn=pp|{z}
 ntimes;ifn<0:
taken together, the tbox tand aboxaform the knowledge base (kb)k= (t;a).
in this paper, ocbc models will be encoded using tboxes (see sect. 4.4), while single
process executions (i.e., trace fragments as shown in example 1) are encoded as aboxes
(e.g., co(co1;t0)is encoded as t0co(co1)).
atemporal interpretation is a structure of the form i= ((z;<);di;fijn2zg),
where (z;<)is the linear model of time, diis a non-empty interpretation domain
andi(n)gives a standard dl interpretation for each time instant n2z:i(n) = 
di;ai(n)
0;ai(n)
0;:::; pi(n)
0;:::
;assigning to each concept name aia unary predicate
ai(n)
idiand to each role name pia binary relation pi(n)
ididi. we assume
that the domain diand the interpretations ai
i2diof object names are the same for
alln2z, i.e., we adopt the constant domain assumption andrigid designators (con-
sult [18] for more details on these assumptions). at each time instant n2z, role and
concept constructs are interpreted as follows
(r )i(n)=f(y;x)2didij(x;y)2ri(n)g;
(qr c )i(n)=
x2dij]fy2ci(n)j(x;y)2ri(n)gq	
;
(:c)i(n)=dinci(n);>i=di;(c1uc2)i(n)=ci(n)
1\ci(n)
2;
(c1uc2)i(n)=[
k>n 
ci(k)
2\\
n<m<kci(m)
1
;
(c1sc2)i(n)=[
k<n 
ci(k)
2\\
n>m>kci(m)
1
;
where ]xdenotes the cardinality of x. thus, for example, x2(c1uc2)i(n)iff there is
a moment k>nsuch that x2ci(k)
2andx2ci(m)
1, for all moments mbetween nand
k. note that the operators sanduare ‘strict’ in the sense that their semantics does not
include the current moment of time.
concept and role inclusion axioms (tbox) are interpreted in iglobally :
ij=c1vc2iffci(n)
1ci(n)
2forall n2z;
ij=r1vr2iff ri(n)
1ri(n)
2forall n2z:
abox assertions are interpreted relatively to the initial moment , 0:
ij=nak(ai)iff ai
i2ai(n)
k;
ij=npk(ai;aj)iff (ai
i;ai
j)2pi(n)
k:we calliamodel of a kbk= (t;a)and writeij=kifisatisﬁes all inclusions
intand all assertions in a. a kbkissatisﬁable if it has a model. a concept c
(role r) issatisﬁable with respect tokif there are a model iofkandn2zsuch
thatci(n)6=/ 0 (respectively, ri(n)6=/ 0). it is readily seen that the concept and role
satisﬁability problems are equivalent to kb satisﬁability.
reasoning in tusalcqi w.r.t. to a kb is a problem which has been proven to be
exptime-complete [27, 18]. to achieve better complexity results fragments of alcqi
must be considered. nice results have been gained when temporalizing dl-lite log-
ics [13, 6]—see, e.g., the temporal dl-lite called tusdl-lite(hn )
boolwhere reasoning
has the same complexity of ltl reasoning, i.e., pspace-complete [8].
4 the ocbc model
we now present the syntax and graphical appearance of ocbc models, together with
their formal semantics. the original proposal of the ocbc model is the way activities
and data are related. in particular, an ocbc model captures, at once: (i) data depen-
dencies , represented using standard data modeling constructs, i.e., classes ,relationships
andconstraints between them; (ii) activities , accounting for units of work within a pro-
cess; (iii) mutual relationships between activities and classes , linking the execution
of activities in a given process with the data objects they manipulate; (iv) temporal
constraints between activities; (v) co-reference constraints that enforce the application
of temporal constraints, and in particular limit their application to those activities that
indirectly co-refer thanks to the objects and relationships they point to.
4.1 the data model – clam
data used by the activities of an ocbc model is structured according to a standard
modeling language, i.e., er/uml/orm. while alcqi is able to fully capture the
semantics of such data models (see [11, 4, 17] and references therein) in the follow-
ing, just for the sake of simplicity and lack of space, we present only a subset of the
complete set of modeling constructs allowed in those standard data modeling languages
and denote such set of modeling constructs as the clam data model (which stands for
class data model ). in particular, the following syntax limits clam to capture object
classes that can be organized along isahierarchies (with possibly disjoint sub-classes
and covering constraints), binary relationships between object classes and cardinalities
expressing participation constraints of object classes in relationships.
deﬁnition 1 (clam syntax). a conceptual schema sin the class model, clam, is a
tuple s= (uc;ur;t;#dom;#ran;isa;disj;cov );where:
–ucis the universe of object classes. we denote object classes as o 1;o2;:::;
–uris the universe of binary relationships among object classes. we denote rela-
tionships as r 1;r2;:::;
–t:ur!u cu cis atotal function associating a signature to each binary relation-
ship. if t(r) = ( o1;o2)then o 1is the range and o 2thedomain of the relationship;
–#dom:uru c7 !n(n[f¥g)is apartial function deﬁning cardinality constraints
on the domain of a relationship. #dom(r;o)is deﬁned only if t(r) = ( o;o1);a bresponse
a bunary-response
a bnon-response
a bprecedence
a bunary-precedence
a bnon-precedence
a bresponded-existence
a bnon-coexistence
response (a;b) if a is executed, then b must be executed afterwards.
unary -response (a;b) if a is executed, then b must be executed exactly once afterwards.
precedence (a;b) if a is executed, then b must have been executed before.
unary -precedence (a;b) if a is executed, then b must have been executed exactly once before.
responded -existence (a;b) if a is executed, then b must also be executed (either before or afterwards).
non-response (a;b) if a is executed, then b will not be executed afterwards.
non-precedence (a;b) if a is executed, then b was never executed before.
non-coexistence (a;b) a and b cannot be both executed.
fig. 4: types of temporal constraints between activities and their intuitive semantics
–#ran:uru c7 !n(n[f¥g)is apartial function deﬁning cardinality constraints
on the range of a relationship. #ran(r;o)is deﬁned only if t(r) = ( o1;o);
–isau cu cis a binary relation deﬁning the super-class and sub-class hierarchy
on object classes. if isa(c1;c2)then c 1is said to be a sub-class of c 2while c 2is
said to be a super-class of c 1;
–disj2ucu cis a binary relation deﬁning the set of disjoint sub-classes in an
isahierarchy;
–cov2ucu cis a binary relation deﬁning the set of sub-classes covering the
super-class in an isahierarchy.
as for the full-ﬂedged syntax of er/uml/orm, their formal set-theoretic semantics,
and their translation as alcqi kbs we refer to [11, 4, 17]. concerning the semantics
of the clam constructs, cardinality constraints are interpreted as the number of times
each instance of the involved class participates in the given relationship, isais inter-
preted as sub-setting, disj and cov are interpreted in the obvious way using disjoint-
ness/union between classes, relationships are interpreted as binary predicates, while the
relationship signature acts as a typing for its arguments.
example 2. the lower part of the ocbc model shown in fig. 2 captures the data model
as a clam diagram with:
uc=forder ;orderline ;product ;customer ;deliveryg;
ur=fcontains ;belongs to ;is for ;results in ;receivesg;
t(contains ) = ( order ;orderline );:::
#dom(contains ;order ) = ( 0;¥); #ran(contains ;orderline ) = ( 1;1);:::
cardinalities are shown in the diagram following the uml reading.
4.2 temporal constraints over activities
taking inspiration from the declare patterns [1], we present here the temporal con-
straints between (pairs of) activities that can be expressed in ocbc. fig. 4 graphi-cally renders such constraints together with their intuitive meaning. in the following we
present their syntax.
deﬁnition 2 (temporal constraints). let
–uabe the universe of activities, denoted with capital letters a 1;a2;:::;
–utcbe the universe of temporal constraints , i.e.,utc=fresponse ,
unary -response ,precedence ,unary -precedence ,responded -existence ,
non-response ,non-precedence ,non-coexistenceg, where each tc2u tcis
a binary relation over activities, i.e., tc u au a.
the set of temporal constraints in a given ocbc model is denoted as stcand is con-
ceived as a set of elements of the form tc (a1;a2), where tc2u tcand a 1;a22u a.
remark 1. we observe that the non-precedence constraint is syntactic sugar, as it
can be emulated using non-response :non-precedence (a;b)non-response (b;a):
thus, in the following we will not consider it anymore. when deﬁning later
on the ocbc model we will consider the set s+
tcofpositive constraints
containing response ,unary -response ,precedence ,unary -precedence , and
responded -existence , and the set s 
tcofnegative constraints containing
non-response andnon-coexistence .
4.3 syntax of ocbc models
we are now ready to deﬁne the ocbc model starting from data models and temporal
constraints as respectively deﬁned in sections 4.1 and 4.2.
deﬁnition 3 (ocbc syntax). an ocbc model,m, is a tuple:
(clam;stc;ua;urac;trac;#act;#obj;cref;neg-cref );where:
–clam is a data model as in def. 1, and stca set of temporal constraints as in
def. 2;
–uais the universe of activities;
–uracis the universe of activity-object relationships being a set of binary relation-
ships;
–trac:urac!u au cis atotal function associating a signature to each activity-
object relationship. if trac(r) = ( a;o)then a2u aand o2u c;
–#act:uracu a7 !n(n[f¥g)is a partial function deﬁning cardinality con-
straints on the participation of activities in activity-object relationships. #act(r;a)
is deﬁned only if trac(r) = ( a;o);
–#obj:uracu c7 !f1gis apartial function denoting the activity that generated a
given object in o. #obj(r;o)is deﬁned only if trac(r) = ( a;o);
–cref is the partial function of co-reference constraints s.t.
cref:s+
tcu racu rac7 !uc[u r;
–neg-cref is the partial function of negative co-reference constraints s.t.
neg-cref :s 
tcu racu rac7 !uc[u r.
inverses of activity-object relationships are assumed to be functional capturing the intu-
ition that a single occurrence of an activity can manipulate an object at a given point in
time. to clarify the syntax of the ocbc modeling language we illustrate the scenario
provided in example 1.example 3. we consider the ocbc model in fig. 2 where the activities are depicted
in the upper part of the ﬁgure while the lower part shows the clam data model for the
data manipulated by the activities of the process. the set uracof the activity-object
relationships is:urac=fcreate ;closes ;fills ;prepares ;refers togconnecting
an activity with the manipulated objects as an effect of executing the activity itself.
for example, the activity createorder creates an instance of the object class order
when it is executed. cardinality constraints can be added to activity-object relationships
to specify participation constraints either on the activity side or on the object class side.
for example, each execution of pickitem fills one and only one orderline , i.e.,
#act(fills ;pickitem ) = ( 1;1). on the other hand, any orderline must be neces-
sarily ﬁlled by executing a pickitem activity, i.e., # obj(fills ;orderline ) =1. the
co-reference constraints involving object classes specify constraints on how objects
connected to different activities can be shared. for example, the orderline instance
ﬁlled by a pickitem is the same as the one prepared by the corresponding wrapitem .
these co-reference constraints can be expressed using the following ocbc syntax:
cref 
unary -response (pickitem ;wrapitem );fills ;prepares
=orderline ;
cref 
unary -precedence (wrapitem ;pickitem );prepares ;fills
=orderline :
the co-reference constraint 7, and the negative co-reference constraint 8are ex-
pressed as, respectively:
cref(unary -precedence (pickitem ;createorder );fills ;creates ) =contains ;
neg-cref (non-response (payorder ;pickitem );closes ;fills ) =contains :
4.4 semantics of ocbc models
we now focus on the semantics of ocbc models. as pointed out in sect. 2, ocbc
models are interpreted using traces that capture the occurrence of events, the relation-
ships between events and objects, and the evolution of objects and relationships over
time. here, we base the ocbc semantics on inﬁnite traces (cf. sect. 6 for a remark on
ﬁnite traces). the information recorded in an actual execution trace is interpreted under
incomplete knowledge, i.e., as a trace fragment containing explicit factual knowledge
that is known to certainly hold but, in general, only partially capturing what actually
occurred. thus, the notion of trace as used in event log formats such as the xes ieee
standard has to be interpreted, in our setting, as a trace fragment.
our effort is to reconcile the process ﬂow semantics with the data model seman-
tics. we thus resort to a knowledge base expressed in the temporal dl tusalcqi .
in particular, we map both activities and object classes to tusalcqi concepts,
while activity-object relationships and relationships of the data model are mapped to
tusalcqi roles. such an encoding of ocbc models using kbs in the temporal dl
tusalcqi interprets constraints of an ocbc model over inﬁnite traces, while the
abox, that encodes the explicit factual knowledge, i.e., the trace fragment at hand, is
interpreted as a ﬁnite portion of such inﬁnite traces. here we detail the encoding.
concerning the semantics of the clam data model , we interpret it via a mapping to
alcqi as already discussed in sect. 4.1. furthermore, we can add to the data model
temporal constraints captured in tusalcqi as shown in [5, 7].a1 a2
or1 r2
(a)a1 a2
o1 o2rr1 r2
(b)a1 a2
or1 r2
(c)a1 a2
o1 o2rr1 r2
(d)
fig. 5: co-reference (response) constraints over (a) object classes and (b) relationships,
with their negated versions (c-d)
as for activity-object relationships , letr2u racso that trac(r) = ( a;o). the fol-
lowing tusalcqi axioms captures inverse functionality , and domain andrange re-
strictions for r:
(2r >)v?;9rva;9r vo: (1)
a cardinality constraint of the form # obj(r;o) =1, denoting the activity that generated
an object of class o, is captured as:
ov3+
p(ou9r ):
cardinality constraints for the participation of activities in activity-object relationships
(#act) are instead captured as classical cardinalities in data models (see [11, 5, 7]).
semantics of co-reference constraints. having ﬁxed the semantics for the clam data
model and the one for the activity-object relationships we are left with the most tricky
aspect of ocbc, namely the semantics of co-reference constraints . in the following,
we consider the different kinds of co-reference constraints which, according to deﬁni-
tion 3, can be either positive or negative, and can range either over object classes (as
illustrated in fig. 5a and 5c) or over relationships (as illustrated in fig. 5b and 5d).
letr1;r22u rac,a1;a22u aando2u cs.t.tc(a1;a2)2s+
tc,trac(r1) = ( a1;o),
trac(r2) = ( a2;o)andcrefbe aco-reference constraint over object classes of the form:
cref(tc(a1;a2);r1;r2) =o(as in fig. 5a). then, co-reference over object classes when
tcis the response temporal constraint is captured by the axiom:
9r 
1v3f9r 
2(2)
this expresses that ” whenever an object is in the range of r 1then sometime in the future
it must be also in the range of r 2”. this semantics enforces a temporal constraint over
the activities via the co-referenced object, i.e., when the activity a1is linked via r1to
an object in othen it must be followed by an execution of a2referencing the same
object via r2. formally, the following logical implication holds:
f(1);(2);a1v9r1gj=a1v9r1.3f9r 
2.a2 (3)
when tcis the unary -response temporal constraint we need to add to formula (2) an-
other formula that guarantees a unique occurrence of a2over the co-referenced object:
9r 
2u3p9r 
1v2f:9r 
2(4)o1 . . .a1:a1b1:a2b2:a2
t0 t1 t2r1 r2 r2
(a)o1:o1
o2:o2. . .
. . .a1:a1b1:a2b2:a2
t0 t1 t2r1r2
rr2
(b)
fig. 6: (a) trace fragment for (2) but not (4); (b) trace fragment for (8) but not (10)
fig. 6a shows a possible instantiation of the ocbc model in fig. 5a which, in turn, is
not a valid fragment in case the temporal constraint is changed to unary -response .
similar formulas hold when tcis a temporal constraint over the past, i.e., ei-
ther precedence (formula (5)), unary -precedence (formulas (5) and (6)) or
responded -existence (formula (7)).
9r 
1v3p9r 
2(5)
9r 
2u3f9r 
1v2p:9r 
2(6)
9r 
1v39r 
2(7)
we now consider co-reference constraints over relationships . as in fig. 5b, let
o1;o22u c,r2u r, with t(r) = ( o1;o2),trac(r1) = ( a1;o1),trac(r2) = ( a2;o2)
andcref be a co-reference of the form: cref(tc(a1;a2);r1;r2) =r:then, the semantics
ofco-reference over relationships when tcis the response constraint is captured by:
9r 
1v3f9r.9r 
2(8)
expressing that ” every object in the range of r 1sometime in the future should be con-
nected via r to an object in the range of r 2.” a logical implication similar to (3) holds:
f(1);(8);a1v9r1gj=a1v9r1.3f9r.9r 
2.a2 (9)
when tcisunary -response we should add to formula (8) another formula that guar-
antees that activity a1is followed by a single occurrence of a2viar. the following
axiom expresses that ” whenever an object is in the range of r 2(thus under the occur-
rence of a 2) and is connected via r to an object that before was in the range of r 1
(due to the occurrence of the activity a 1) then, it will never be in the range of r 2.”
9r 
2u9r .3p9r 
1v2f:9r 
2(10)
fig. 6b shows an instantiation of the ocbc model in fig. 5b that, in turn, is not any-
more a valid fragment in case the temporal constraint is changed to unary -response
(because o2is pointed to by two different instances— b1;b2—of the activity a2).
similar formulas hold when tcisprecedence (axiom (11)), unary -precedence (ax-
ioms (11) and (12)) and responded -existence (axiom (13))
9r 
1v9r.3p9r 
2(11)
9r 
2u3f9r .9r 
1v2p:9r 
2(12)
9r 
1v39r.39r 
2(13)note that axiom (13) allows for responded -existence to be symmetric—as for ax-
iom (7)—i.e.,f(13)gj=9r 
2v39r .39r 
1.
we now consider co-references in the presence of negative behavioral con-
straints (see fig. 5c-5d). we start with co-reference over object classes. in case tcis
non-response (as in fig. 5c) then the following axiom expresses that ” whenever an
object is in the range of r 1then never in the future it could be in the range of r 2”:
9r 
1v2f:9r 
2: (14)
as a consequence of this axiom, and of the fact that the domains of r1andr2are
activities a1anda2, while they both range over the same class o, we can also read
this negative co-reference as ” every instance of activity a 1can never be followed by
instances of a 2sharing the same object in o ”. the right-hand side of the axiom is the
negation of the right-hand side of axiom (2). when tcisnon-coexistence , we have
9r 
1v2:9r 
2(15)
again, the right-hand side is the negation of the right-hand side of axiom (7).
when negative co-references involve a relationship and tcisnon-response (as in
fig. 5d) the following axiom expresses that “ whenever an object is in the range of r 1
then never in the future it could be connected via r to an object in the range of r 2(thus
under the occurrence of a 2)”:
9r 
1v2f:9r.9r 
2(16)
implying that “ every instance of activity a 1can never be followed by instances of a 2
sharing the same pair of objects in r ”. notice again that the right-hand side of the
above axiom is the negation of the right-hand side of axiom (8). finally, by negating
the right-hand side of axiom (13) we capture the case when tcisnon-coexistence
9r 
1v2:9r.39r 
2(17)
similar to responded -existence ,non-coexistence over both object classes (15)
and relationships (17) is obviously symmetric. formally, considering the co-reference
over a relationship, f(17)gj=9r 
2v2:9r .39r 
1.
altogether, an ocbc model can be captured via a tbox in tusalcqi , and its
trace fragments using corresponding aboxes. overall, a tusalcqi kb is thus able
to provide a uniform representation for ocbc, on which we can apply ad hoc reasoning
services as described in the following section.
5 veriﬁcation and reasoning over ocbc models
the main motivation to provide a mapping from ocbc models to a dl knowledge
base is the possibility of carrying out automated reasoning over them. we discuss how
the typical services for verifying declarative, constraint-based process models can be
lifted to the more sophisticated setting of ocbc. to do so, we build on the services de-
ﬁned for the well-established declare language [25, 24]. in the following, we showhow such services can be reformulated as standard reasoning tasks over tusalcqi
knowledge bases, in turn inheriting their decidability and worst-case complexity.
letmbe an ocbc model of interest, and ra trace fragment over m. we denote
bytmandarthe tbox and abox obtained by encoding mandrintusalcqi ,
and bykm;rthe resulting tusalcqi kb, i.e.,km;r= (tm;ar).
model consistency. the most fundamental service is to check whether mis consis-
tent, that is, supports the empty trace fragment (in turn witnessesing that it supports at
least one full trace). this directly reduces to check whether tmis satisﬁable.
activity executability. an ocbc model may be consistent, but including so-called
dead activities [25], i.e., activities that cannot be executed at all. we can show whether
an activity ainmcan be executed by verifying whether such an activity is not logically
implied to be empty in the corresponding tbox, i.e., tm6j=av?.
create
orderpay
order
ordercreates closes
(a)
pay
orderwrap
item
order order linecontainscloses prepares
(b)
fig. 7: implied (a) and non-
implied (b) constraints by the
ocbc model of fig. 2implied properties. letabe a model property ex-
pressible in tusalcqi . we can check whether
mj=aby checking whether km;rj=a. e.g., (3) is
a property implied by m. the presented encoding of
ocbc into tusalcqi allows us to use its reason-
ing capabilities to detect so-called hidden constraints
[24], i.e., constraints that are implicitly present in m
even though they are not shown graphically.
example 4. consider again the ocbc model of
fig. 2, and the two constraints in fig. 7, where fig. 7a
captures that an order can be paid only if it has been
created before, and fig. 7b that no order line of an or-
der can be wrapped after that order is paid. it is easy
to verify that the former constraint is indeed implied,
while the latter constraint it is not. while it is true that once an order is paid no further
items can be picked for it, already picked order lines may still need to be wrapped.
execution trace compliance. this amounts to check whether a trace fragment rsat-
isﬁes the constraints in m. since ris a trace fragment, we require that no explicit
violation is contained in rand that rcan be ’completed’ into a fully speciﬁed, inﬁ-
nite trace that satisﬁes m. this corresponds to the notion of conditional compliance
recently introduced in [15]. in our setting, this amounts to check whether the abox ar
encoding ris satisﬁable w.r.t. the tbox tm, i.e., whether the kb km;ris satisﬁable.
complexity considerations. notice that, kb satisﬁability and logical implication are
mutually reducible in alcqi [6] (and thus in tusalcqi ) and these reasoning prob-
lems over tusalcqi are exptime-complete [27, 18], which establishes an exptime
upper bound for verifying properties of ocbc models. the need to use alcqi as
the base dl is due to co-reference constraints over relationships, which requires the
power of qualiﬁed existential ( 9r.c) and its dual. if we renounce such constraints
(i.e., only consider ocbc constraints co-referring on classes), we could use a tem-
poralized version of a dl-lite dialect. in particular, the temporal dl-lite fragment
tusdl-lite(hn )
bool, showed to be pspace-complete in [8], is able to capture ocbc mod-
els with the exception of co-reference constraints over relationships while, at the levelof the data model, tusdl-lite(hn )
boolcaptures the main constructs of uml—with the
exception of isa between relationships and n-ary relationships (cf. [4, 7] for details).
6 conclusions
we presented the ﬁrst, complete formalization of object-centric behavioral constraints
(ocbc): a new approach to business process modeling where data models and declar-
ative constraints over activities are seamlessly integrated. our approach comes with
a logic-based semantics for ocbc in terms of an encoding into the temporal dl
tusalcqi . this unambiguously deﬁnes the meaning of ocbc models, and lays
the foundations for reasoning over them, allowing us to understand the (decidability
and) complexity boundaries of reasoning tasks over ocbc models. tusalcqi inter-
prets time as a linear, inﬁnite structure, which contrasts with the ﬁnite-trace semantics
adopted in other declarative process modeling languages such as declare. the study
of temporal description logics with ﬁnite-time semantics is rather novel [9], and may
constitute the basis for reasoning over ocbc models on ﬁnite traces.
we have considered here standard data models to capture the structural aspects of
ocbc. variants of ocbc with non-conventional temporalized cardinality constraints
over relationships have been used [21, 22]. we intend to study whether such constraints
may impact on the decidability and complexity of reasoning over ocbc models.
in our research agenda, we are interested not only in design-time reasoning of
ocbc models, but also in enactment, monitoring, and runtime veriﬁcation. this poses
two major challenges. on the one hand, a monitored trace has to be considered under
a “partially closed” semantics, that is, by interpreting it as a complete record of what
happened so far, while missing information about the future. on the other hand, a more
ﬁne-grained analysis, in the style of [23], regarding if and how a monitored trace con-
forms to an ocbc model is needed. we intend to attack this problem by combining
ﬁnite and inﬁnite reasoning over a partially closed knowledge base.
acknowledgments. this research has been partially supported by the unibz crc
projects pworm and rekap.
references
1. van der aalst, w., pesic, m., schonenberg, h.: declarative workﬂows: balancing be-
tween flexibility and support. computer science–research and development 23(2), 99–113
(2009)
2. van der aalst, w.m.p.: process mining: data science in action. springer (2016)
3. van der aalst, w.m.p., li, g., montali, m.: object-centric behavioral constraints. corr
technical report, corr (2017), http://arxiv.org/abs/1703.05740
4. artale, a., calvanese, d., kontchakov, r., ryzhikov, v ., zakharyaschev, m.: reasoning over
extended er models. in: proc. of the 26th int. conf. on conceptual modeling (er). lncs,
vol. 4801, pp. 277–292. springer (2007)
5. artale, a., parent, c., spaccapietra, s.: evolving objects in temporal information systems.
annals of mathematics and artiﬁcial intelligence 50(1–2), 5–38 (2007)
6. artale, a., calvanese, d., kontchakov, r., zakharyaschev, m.: the dl-lite family and re-
lations. jair 36, 1–69 (2009)7. artale, a., kontchakov, r., ryzhikov, v ., zakharyaschev, m.: complexity of reasoning over
temporal data models. in: proc. of the 29th int. conf. on conceptual modeling (er). lncs,
vol. 4801, pp. 277–292. springer (2010)
8. artale, a., kontchakov, r., ryzhikov, v ., zakharyaschev, m.: a cookbook for temporal con-
ceptual data modeling with description logics. acm transactivity on computational logic
(tocl) 15(3) (2014)
9. artale, a., mazzullo, a., ozaki, a.: do you need inﬁnite time? in: in proc. of the 28th
international joint conference on artiﬁcial intelligence (ijcai) (2019), to appear
10. bagheri hariri, b., calvanese, d., montali, m., de giacomo, g., de masellis, r., felli, p.:
description logic knowledge and action bases. jair 46(2013)
11. berardi, d., calvanese, d., de giacomo, g.: reasoning on uml class diagrams. artiﬁcial
intelligence journal 168(1–2), 70–118 (2005)
12. bhattacharya, k., gerede, c., hull, r., liu, r., su, j.: towards formal analysis of artifact-
centric business process models. in: proc. of the 11th int. enterprise distributed object
computing conf. (edoc). lncs, vol. 4714, pp. 288–304. springer (2007)
13. calvanese, d., de giacomo, g., lembo, d., lenzerini, m., rosati, r.: tractable reasoning
and efﬁcient query answering in description logics: the dl-lite family. journal of auto-
mated reasoning 39(3), 385–429 (2007)
14. calvanese, d., de giacomo, g., montali, m.: foundations of data-aware process analysis: a
database theory perspective. in: proc. of 32nd pods. acm (2013)
15. chesani, f., de masellis, r., di francescomarino, c., ghidini, c., mello, p., montali,
m., tessaris, s.: compliance in business processes with incomplete information and time
constraints: a general framework based on abductive reasoning. fundamenta informaticae
159(3), 1–37 (2018)
16. cohn, d., hull, r.: business artifacts: a data-centric approach to modeling business op-
erations and processes. ieee data engineering bulletin 32(3), 3–9 (2009)
17. franconi, e., mosca, a., solomakhin, d.: orm2: formalisation and encoding in owl2. in:
proc. of int. workshop on fact-oriented modeling (orm). pp. 368–378 (2012)
18. gabbay, d., kurucz, a., wolter, f., zakharyaschev, m.: many-dimensional modal logics:
theory and applications. studies in logic. elsevier (2003)
19. gonzalez, p., griesmayer, a., lomuscio, a.: veriﬁcation of gsm-based artifact-centric
systems by predicate abstractivity. in: proc. of the 13th int. conf. on service-oriented
computing (icsoc). lncs, vol. 9435, pp. 253–268. springer (2015)
20. levesque, h.j.: foundations of a functional approach to knowledge representation. artiﬁcial
intelligence journal 23, 155–212 (1984)
21. li, g., de carvalho, r., van der aalst, w.: automatic discovery of object-centric behavioral
constraint models. in: int. conf. on business information processing (bis17) (2017)
22. li, g., de carvalho, r., de murillas, e., van der aalst, w.: extracting object-centric event
logs to support process mining on databases. in: caise forum. springer (2108)
23. maggi, f.m., westergaard, m., montali, m., van der aalst, w.m.p.: runtime veriﬁcation
of ltl-based declarative process models. in: proc. of the 2nd international conference on
runtime veriﬁcation (rv). lncs, vol. 7186, pp. 131–146. springer (2011)
24. montali, m., pesic, m., van der aalst, w.m.p., chesani, f., mello, p., storari, s.: declarative
speciﬁcation and veriﬁcation of service choreographies. acm trans. tweb 4(1) (2010)
25. pesic, m., schonenberg, h., van der aalst, w.m.: declare: full support for loosely-
structured processes. in: proc. of the eleventh ieee int. enterprise distributed object com-
puting conference (edoc’07). pp. 287–298. ieee computer society (2007)
26. vianu, v .: automatic veriﬁcation of database-driven systems: a new frontier. in: proc. of the
12th int. conf. on database theory (icdt). pp. 1–13 (2009)
27. wolter, f., zakharyaschev, m.: temporalizing description logics. in: frontiers of combining
systems, pp. 379 – 401. research studies press-wiley (2000)