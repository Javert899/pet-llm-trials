aggregating causal runs into workow nets
b.f. van dongen1, j. desel2, and w.m.p. van der aalst1
1department of mathematics and computer science,
technische universiteit eindhoven, the netherlands.
{b.f.v.dongen,w.m.p.v.d.aalst }@tue.nl
2department of software engineering,
fernuniversit¨ at in hagen, germany
joerg.desel@fernuni-hagen.de
abstract. this paper provides three aggregation algorithms for deriv-
ing system nets from sets of partially-ordered causal runs. the three
algorithms diﬀer with respect to the assumptions about the information
contained in the causal runs. speciﬁcally, we look at the situations where
labels of conditions (i.e. references to places) or events (i.e. references to
transitions) are unknown. since the paper focuses on aggregation in the
context of process mining, we solely look at workﬂow nets, i.e. a class of
petri nets with unique start and end places. the diﬀerence of the work
presented here and most work on process mining is the assumption that
events are logged as partial orders instead of linear traces. although the
work is inspired by applications in the process mining and workﬂow do-
mains, the results are generic and can be applied in other application
domains.
1 introduction
this paper proposes diﬀerent approaches to “discover” process models from ob-
served runs, i.e., runs (also known as causal nets or occurrence nets, cf. [14])
are aggregated into a single petri net that captures the observed behavior. runs
provide information about events together with pre- and post-conditions which
constitute a (partial) order between these events. this is useful in many domains
where processes are studied based on their recorded behavior, such as:
{discovering administrative processes by following the document ﬂows in the
organization with the goal to improve eﬃciency.
{auditing processes in organizations in order to make sure that they conform
to some predeﬁned rules.
{constructing enterprise models by observing transaction logs or document
ﬂows in enterprise systems such as sap, peoplesoft and oracle.
{monitoring the ﬂow of soap messages between web-services to see how
diﬀerent services interact.
{observing patient ﬂows in hospitals to improve careﬂows and to verify med-
ical guidelines.there are many techniques to discover process models based on sequential event
logs (also known as transaction logs, audit trails, etc). people working on pro-
cess mining techniques [6] generally tackle situations where processes may be
concurrent and the set of observations is incomplete. especially since the set of
possible sequences is typically larger than the number of process instances, it is
unrealistic to assume that all possible sequences have been observed.
in many applications, event logs are assumed to be linear, for example since
all events are ordered in time. however, there are many processes where it is
possible to monitor causal dependencies (e.g., by analyzing the dataﬂows). in
the examples mentioned before, it is easy to identify situations where activities
are causally linked by documents or explicit messages which can be monitored
and hence explicit information about the causal dependencies between events
is available. consider for example service-oriented systems where one service
calls another service. these services have input and output data. using these
dataﬂow one can ﬁnd explicit causal dependencies. furthermore, we encoun-
tered several business process management (bpm) systems that actually log
behavior using a representation similar to runs. the ad-hoc workﬂow manage-
ment system inconcert of tibco (formerly xerox) allows end users to deﬁne
and modify process instances (e.g., customer orders) while capturing the causal
dependencies between the various activities. the representation used by these
systems directly corresponds to the notion of runs. the analysis tool aris ppm
(process performance monitor) of ids scheer can extract runs represented as
so-called instance epcs (event-driven process chains) from systems such as
sap r/3 and staﬀware. these examples show that in real-life systems and pro-
cesses runs can be recorded or already are being recorded, thus motivating the
work presented in this contribution.
the remainder of this paper is structured as follows. after discussing related
work in section 2 and some preliminary deﬁnitions in section 3, we provide
algorithms for the aggregation of runs. in section 4, three algorithms are pre-
sented for the aggregation of runs for the situations depicted in figures 1 to 3.
figures 1 to 3 each show two runs on the left-hand side and the most likely can-
didate for the aggregated model on the right hand side. the ﬁrst algorithm we
present assumes we have full knowledge of each event, its preconditions and its
postconditions. this is shown in figure 1, where all events and conditions are la-
beled and these labels uniquely identify the corresponding transition or place in
the aggregated model. then, we assume that we cannot uniquely identify events,
i.e. the label of an event may refer to multiple transitions, as shown in figure 2,
where send goods and send billcannot be distinguished, since both of them are
recorded as send something . in the aggregated model however, two occurrences
of the transition send something have been identiﬁed. finally, we provide an al-
gorithm that assumes less knowledge about pre- and post-conditions, as shown
in figure 3, where no conditions have labels, while the corresponding aggregated
model shows the same structure as in figure 1. in section 5, we formally prove
that the algorithms we presented in section 4 are correct, i.e. that the aggregated
nets can reproduce the original causal nets. we conclude the paper in section 6.start order c1
c2
c3send_bill
send_goods 
pay_credit_card pay_cash c4
c5
c6archive endstart order c1
c2
c3send_bill
send_goods 
pay_cash c4
c5
c6archive end 
start order c1
c2
c3send_bill
send_goods 
pay_credit_card c4
c5
c6archive fig. 1. example of aggregating runs with known event and condition labels (sec-
tion 4.1).
start order c1
c2
c3send_something 
pay_credit_card pay_cash c4
c5
c6endstart order c1
c2
c3pay_cash c4
c5
c6end 
start order c1
c2
c3pay_credit_card c4
c5
c6send_something send_something 
send_something 
send_something 
send_something 
fig. 2. example of aggregating runs with known condition labels and unknown or
non-unique event labels (section 4.2).
order send_bill
send_goods 
pay_credit_card pay_cash archive order send_bill
send_goods 
pay_cash archive 
order send_bill
send_goods 
pay_credit_card archive 
fig. 3. example of aggregating runs with known event labels and unknown condition
labels (section 4.3).2 related work
for an extensive overview of the process mining domain, we refer to the recent
book on process mining [2].
since the mid-nineties several groups have been working on techniques for
automated process discovery based on event logs [5, 7, 8, 12, 13, 20, 28, 29]. in [6]
an overview is given of the early work in this domain. the idea to apply pro-
cess mining in the context of workﬂow management systems was introduced
in [8]. in parallel, datta [13] looked at the discovery of business process models.
cook et al. investigated similar issues in the context of software engineering pro-
cesses [12]. herbst [22] was one of the ﬁrst to tackle more complicated processes,
e.g., processes containing duplicate tasks. most of the classical approaches have
problems dealing with concurrency. the α-algorithm [7] is an example of a sim-
ple technique that takes concurrency as a starting point. however, this simple
algorithm has problems dealing with complicated routing constructs and noise
(like most of the other approaches described in literature).
in all of the algorithms mentioned above, these tasks (i.e., events) in each
case are totally ordered (typically based on the timestamps). in this paper, we
take a diﬀerent approach. we start by looking at so-called runs. these runs are a
partial ordering on the tasks within each case. however, in addition to the partial
ordering of tasks, we may have information about the local states of the system
from which the logs originated, i.e. for each event the pre- and post-conditions
are known. this closely relates to the process mining algorithms presented in [17]
and [18]. however, also in these papers only causal dependencies between events
are considered and no state information is assumed to be known.
the generation of system nets from their causal runs has been investigated
before. the ﬁrst publication on this topic is [27]. here the basis is assumed to be
the set of all runs. these runs are folded, i.e., events representing the occurrence
of the same transition are identiﬁed, and so are conditions representing a token
on the same place. in [15] a similar folding approach is taken, but there the
authors start with a set of causal runs, as we do in the present paper. [15]
does not present algorithms in details for the aggregation of runs but rather
concentrates on correctness criteria for the derived system net. [11] presents an
aggregation algorithm that constructs event-driven process chains from sets of
partially ordered sets of events (without conditions).
the problem tackled in this paper is closely related to the so-called synthesis
problem of petri nets (see [16] and [19] for the synthesis of elementary net systems
and [9] for more general cases). in this work, the behavior is given in the form
of state graphs (where the events are known but the states are anonymous). in
process mining, the observed behavior is not complete and it is not known, which
process executions lead to identical global states. more recently, [26] extracts
petri nets from models which are based on message sequence charts (mscs), a
concept quite similar to causal runs. less related is the work presented in [21],
where a special variant of mscs is used to generate a system implementation.
in [24], so-called regions are deﬁned for partial orders of events representing
runs. these regions correspond to anonymous places of a synthesized place/tran-sition net, which can generate these partial orders. in contrast to our work, the
considered partial orders are any linearizations of causal orders, i.e., two ordered
events can either occur in a sequence (then there is a causal run with a condition
”between” the events) or they can occur concurrently. consequently, conditions
representing tokens on places are not considered in these partial orders whereas
our approach heavily depends on these conditions. more recently, this region-
based approach was used for the synthesis of place/transition nets from sets of
ﬁnite [10] or inﬁnite [11] partially ordered sets of events.
3 preliminaries
in this section, we introduce some basic deﬁnitions used in the remainder of this
paper and formalize the starting point for the aggregation of partially ordered
runs. typically, a partial order is represented by a graph, and therefore we
introduce some concepts related to graphs, such as a complete subgraph and a
graph coloring. a graph-coloring is a way to label the nodes of a graph in such
a way that no two neighboring nodes (i.e. nodes connected by an edge) have the
same color.
denition 3.1. (graphs)
letg= (n, e ) be a directed graph, i.e. nis the set of nodes and e⊆n×nis
the set of edges. if n′⊆n, we say that g′= (n′, e∩(n′×n′)) is a subgraph
ofg.gis acomplete graph if and only if e= (n×n).
in the sequel, we assume g= (n, e ) is a directed graph.
denition 3.2. (undirected path in a graph)
leta∈nandb∈n. we deﬁne an undirected path from atobas a sequence of
nodes denoted by < n 1, . . . , n k>with k≥1 such that n1=aandnk=band
∀i∈{1...k−1}((ni, ni+1)∈e∨(ni+1, ni)∈e).
denition 3.3. (connected graph)
gis a connected graph if for all n1, n2∈nholds that there is an undirected
path from n1ton2. a set of vertices n′⊆ngenerates a maximal connected
subgraph if it is a maximal set of vertices generating a connected subgraph.
denition 3.4. (graph coloring)
letµbe a set of colors. a function f:n→µis a coloring function if, for all
(n1, n2)∈e, either n1=n2orf(n1)̸=f(n2).
lemma 3.5. (colorings on subgraphs can be combined)
lete1, e2⊆e, such that e1∪e2=e. furthermore, let f:n→µbe a
coloring function on the graph ( n, e 1) as well as a coloring function on the
graph ( n, e 2). then fis also a coloring function on g.
proof. let ( n1, n2)∈eandn1̸=n2. since e=e1∪e2, we either have
(n1, n2)∈e1or (n1, n2)∈e2. since fis a coloring function on both ( n, e 1)
and ( n, e 2),f(n1)̸=f(n2). ⊓ ⊔in graphs, we would like to be able to talk about predecessors and successors
of nodes. therefore, we introduce a special notation for that.
denition 3.6. (pre-set and post-set)
letn∈n. we deﬁneg•n={m∈n|(m, n)∈e}as the pre-set and ng•={m∈
n|(n, m)∈e}as the post-set of nwith respect to the graph g. if the context
is clear, the superscript gmay be omitted, resulting in •nandn•.
as stated in the introduction, our starting point is not only a partial order
of events within a case, but also information about the state of a case. since we
want to be able to represent both events and states, petri nets provide a natural
basis for our approach. in this paper, we use the standard deﬁnition of ﬁnite
marked place/transition (p/t-nets) nets n= (p, t, f, m 0).
denition 3.7. (bag)
letsbe a set. a bagoversis a function from sto the natural numbers i n.
denition 3.8. (place/transition net)
n= (p, t, f, m 0) is a marked place/transition net (or p/t-net) if:
{pis a ﬁnite set of places,
{tis a ﬁnite, non-empty set of transitions, such that p∩t=∅,
{f⊆(p×t)∪(t×p) is the ﬂow relation of the net,
{m0:p→i n represents the initial marking of the net, where a marking is a
bag over the set of places p.
note that any p/t-net n= (p, t, f, m 0) deﬁnes a directed graph (( p∪t), f).
in this paper, we restrict ourselves to p/t-nets where for each transition tholds
that•t̸=∅andt• ̸=∅.
denition 3.9. (bag notations)
we use square brackets for the enumeration of the elements of a bag represent-
ing a marking of a p/t-net. the sum of two bags ( x⊎y), the presence of an
element in a bag ( a∈x), and the notion of subbags ( x≤y) are deﬁned in a
straightforward way, and they can handle a mixture of sets and bags. further-
more,⊎
a∈a(
f(a))
denotes the sum over the bags that are results of function f
applied to the elements aof a bag a.
petri nets specify processes. the behavior of a petri net is given in terms of
causal nets, representing process instances (i.e. cases). therefore, we introduce
some concepts (notation taken from [14]). first, we introduce the notion of a
causal net, this is a speciﬁcation of one process instance.
denition 3.10. (causal net)
the p/t-net ( c, e, k, s 0) is called a causal net if:
{for every place c∈cholds that | •c| ≤1 and |c• | ≤ 1,
{the transitive closure of kis irreﬂexive, i.e. it is a partial order on c∪e,
{for each place c∈cholds that s0(c) = 1 if •c=∅ands0(c) = 0 if •c̸=∅.
in causal nets, we refer to places as conditions and to transitions as events .each event of a causal net should refer to a transition of a corresponding
p/t-net and each condition should refer to a token on some place of the p/t-
net. these references are made by mapping the conditions and the events of a
causal net onto places and transitions, respectively, of a petri net. we call the
combination of a causal net and such a mapping a run.
denition 3.11. (run)
a run ( n, α, β ) of a p/t-net ( p, t, f, m 0) is a causal net n= (c, e, k, s 0),
together with two mappings α:c→pandβ:e→t, such that:
{for each event (transition) e∈e, the mapping αinduces a bijection from
•eto•β(e) and a bijection from e•toβ(e)•,
{α(s0) =m0where αis generalized to markings by α: (c→i n)→(p→
i n), such that α(s0)(p) =∑
c|α(c)=ps0(c).
the causal behavior of the p/t-net ( p, t, f, m 0) is deﬁned as its set of runs. to
avoid confusion, the p/t-net ( p, t, f, m 0) is called system net in the sequel.
in this paper, we take a set of runs as a starting point. from these runs, we
generate a system net describing the behavior of all individual runs. remember
that we do not assume to have all runs as a starting point.
4 aggregation of runs
in this section, we introduce an approach that takes a set of runs as a starting
point. from this set of runs, a system net is constructed. moreover, we need
to ﬁnd a mapping from all the events and conditions in the causal nets to the
transitions and places in the system net. from deﬁnition 3.11, we know that
there should exist a bijection between all conditions in the pre- or post-set of
an event in the causal net and the pre- or post-set of a transition in a system
net. therefore, two conditions belonging to the pre- or post-set of a single event
should not be mapped onto the same place . this restriction is in fact merely
another way to express the fact that our p/t-nets do not allow for more than
one edge between a place and a transition or vice versa. more generally, we
deﬁne a labeling function on the nodes of a graph as a function that does not
give the same label to two nodes that have a common element in their pre-sets
or a common element in their post-sets.
denition 4.1. (labeling function)
letµbe a set of labels. let g= (n, e ) be a graph. let r={(n1, n2)⊆
n×n|n1g•∩n2g•̸=∅ ∨g•n1∩g•n2̸=∅}. we deﬁne f:n→µto be a labeling
function iffis a coloring function on the graph ( n, r ).
we focus on the aggregation of runs that originate from a petri net with
clearly deﬁned starting state and completion state, i.e. processes that describe
a lifespan of some case. this assumption is very natural in the context of work-
ﬂow management systems. however, it applies to many other domains where
processes are instantiated for speciﬁc cases. hence, we will limit ourselves to a
special class of petri nets, namely workﬂow nets.denition 4.2. (workow nets)
a p/t-net n= (p, t, f, m 0) is a workow net (wf-net) if:
1.pcontains an input place pinisuch that •pini=∅,
2.pcontains an output place poutsuch that pout•=∅,
3.there is a path from pinito every node and a path from every node to pout,
4.m0= [pini], i.e. the initial marking marks only pini.
as a consequence, a wf-net has exactly one input place. when looking at a
run of a wf-net, we can therefore conclude that there is exactly one condition
containing a token initially and all other conditions do not contain tokens. a set
of causal nets fulﬁlling this condition and some structural consequences is called
acausal set .
denition 4.3. (causal set)
letn∈i n and let φ={(ci, ei, ki, si)|0≤i < n}be a set of causal nets. we
call this set a causal set if the sets ci,eiandkiare pairwise disjoint and, for
0≤i < n holds:
{∑
c∈cisi(c) = 1, i.e. exactly one condition has an empty pre-set,
{if for some c∈ci, holds that si(c) = 1 and e∈c•, then {c}=•e, i.e. each
event in the postset of an initially marked condition has only this condition
in its preset,
{if for some c∈ci, holds that c•=∅ande∈ •c, then e•={c}, i.e. each
event in the preset of a condition with empty postset (representing a token
on the place pout) has only this condition in its postset.
the concept of constructing a system net from a causal set is called aggre-
gation . this concept can be applied if we assume that each causal net in the
given set can be called a run of some system net. from deﬁnition 3.11 we know
that we need two mappings αandβsatisfying the two properties mentioned.
using the deﬁnition of a system net and the relation between system nets and
runs, we can conclude that any aggregation algorithm should have the following
functionality:
{it should provide the set of places pof the system net,
{it should provide the set of transitions tof the system net,
{it should provide the ﬂow relation fof the system net,
{it should provide the initial marking m0of the system net,
{for each causal net in the causal set, it should provide the mappings αi:
ci→pandβi:ei→t, in such a way that for all causal nets, αi(si) is
the same (i.e. they have the same initial marking) and they induce bijections
between pre- and post-sets of events and their corresponding transitions.
each event that appears in a causal net has a corresponding transition in the
original system net. moreover, bijections exist between the pre- and post-sets of
this event and the corresponding transitions. in order to express this in terms
of labeling functions of causal nets, we formalize this concept using the notion
oftransition equivalence .denition 4.4. (transition equivalence)
letµ, νbe two disjoint sets of labels. let φ={ni= (ci, ei, ki, si)|0≤i < n}
be a causal set, and let ψ={(αi:ci→µ, βi:ei→ν)|0≤i < n }be a
corresponding set of labeling functions for each ( ci, ei, ki, si). we deﬁne ( φ, ψ)
torespect transition equivalence if and only if for each ei∈eiandej∈ejwith
βi(ei) =βj(ej) the following holds:
{for each ( ci, ei)∈kithere is a ( cj, ej)∈kjsuch that αi(ci) =αj(cj),
{for each ( ei, ci)∈kithere is a ( ej, cj)∈kjsuch that αi(ci) =αj(cj).
using the concepts of a causal set and transition equivalence, we introduce
three aggregation algorithms with diﬀerent requirements on the available infor-
mation. first, in section 4.1 we introduce an algorithm to aggregate causal nets
where all places and transitions have known labels. then, in section 4.2, we
show an algorithm that can deal with the situation where diﬀerent transitions
have the same label. the ﬁnal algorithm, presented in section 4.3, deals with
the situation where transitions are correctly labeled, but places are not labeled
at all.
4.1 aggregation with known labels
in this section, we present an aggregation algorithm that assumes that we know
all mapping functions, and that these mapping functions adhere to the deﬁnition
of a run. to illustrate the aggregation process, we make use of a running example.
consider figure 4 where four parts of runs are shown. we assume that the events
a,b,c,d,e,fandgdo not appear in any other part of each run.
our ﬁrst aggregation algorithm is called alk (short for “all labels known”).
this algorithm assumes known labels for events and known labels for conditions,
such as in figure 4. these labels refer to concrete transitions and places in the
aggregated system net.
denition 4.5. (alk aggregation algorithm)
letµ, νbe two disjoint sets of labels. let φbe a causal set of size nwith causal
nets ( ci, ei, ki, si) (0≤i < n ).
furthermore, let {(αi:ci→µ, βi:ei→ν)|0≤i < n}be a set of labeling
functions respecting transition equivalence, such that for all causal nets αi(si)
is the same. we construct the system net ( p, t, f, m 0) belonging to these runs
as follows:
{p=∪
0≤i<nrng(αi) is the set of places (note that p⊆µ)3,
{t=∪
0≤i<nrng(βi) is the set of transitions (note that t⊆ν),
{f=∪
0≤i<n{(αi(c), βi(e))∈p×t|(c, e)∈ki∩(ci×ei)}∪∪
0≤i<n{(βi(e), αi(c))∈t×p|(e, c)∈ki∩(ei×ci)}
is the ﬂow relation,
{m0=α0(s0) is the initial marking.··
a
p1p2b
c
(a)·· ··
a
p2p1
d
(b)·· ··
ep2b
(c)·· ··
p2p1
df
g
(d)··
fig. 4. four examples of parts of runs.
the result of the alk aggregation algorithm applied to the parts presented
in figure 4 is shown in figure 5. another example is given in figure 1.
the aggregated net shown in figure 5 can generate the runs of figure 4.
however, it also allows for the possibility to execute transitions ffollowed by
c. the token ﬂow from ftocthrough place p1 was never directly observed
in any of the runs. nonetheless, from the run in figure 4(a) we can see that
theccan ﬁre using a token from p1 and from the run in figure 4(d) we can
derive that transition findeed produces this token, hence no “new” behavior is
introduced.
the alk algorithm is a rather trivial aggregation over a set of runs. although
we prove its correctness in section 5.1, the algorithm relies on the assumption
that the mapping functions αiandβiare known for each causal net. further-
more, we assume two sets of labels µandνto be known. however, when applying
these techniques in the context of process mining, it is often not realistic to as-
sume that all of these are present. therefore, in the remainder of this paper, we
relax some of these assumptions to obtain more usable aggregation algorithms
for process mining.
: : :
a
p1p2b
cde
fg : : :
fig. 5. the aggregated petri net.
4.2 aggregation with duplicate or missing transition labels
in this section, we assume that the causal set used to generate the system net
and the labeling functions do not respect transition equivalence (deﬁnition 4.4).
we introduce an algorithm to change the labeling function for events in such a
way that this property holds again. in the domain of process mining, the problem
of so-called “duplicate transitions” (i.e. several transitions with the same label)
3with rng we denote the range of a function, i.e. rng( f) ={f(x)|x∈dom(f)}is well-known (cf. [3, 23, 25]). therefore, there is a need for algorithms to ﬁnd
out which events actually belong to which transition. we assume that we have
causal nets with labeling functions, where some events have the same label, even
though they may refer to diﬀerent transitions (see figure 6). note that this
ﬁgure is similar to figure 4, except that we now labeled the events previously
labeled with fandgwith a new label x.
since the previous aggregation algorithm given in deﬁnition 4.5 assumes that
transition equivalence holds, we provide an algorithm to redeﬁne the labeling
functions for events it this is not the case.
denition 4.6. (relabeling algorithm)
letµ, νbe two disjoint sets of labels. let φ={ni|ni= (ci, ei, ki, si)∧
0≤i < n }be a causal set and let ψ={(αi:ci→µ, βi:ei→ν)|0≤
i < n }be a set of labeling functions in ( ci, ei, ki, si) such that αi(si) is the
same for all causal nets. furthermore, assume that µandνare minimal, i.e.∪
0≤i<nrng(αi) =µand∪
0≤i<nrng(βi) =ν. let e⋆=∪
0≤i<neibe the set of
all events in the causal set.
we deﬁne the relabeling algorithm as follows:
1.deﬁne ◃ ▹⊆e⋆×e⋆as an equivalence relation on the elements of e⋆in such
a way that ei◃ ▹ ejwith ei∈eiandej∈ejif and only if βi(ei) =βj(ej),
αi(ni•ei) =αj(ni•ej), and αi(eini•) =αj(ejni•).
2.for each e∈e⋆, we say eqvl( e) ={e′∈e⋆|e ◃ ▹ e′}.
3.letν′be the set of equivalence classes of ◃ ▹, i.e.ν′={eqvl(e)|e∈e⋆}.
4.for all causal nets ( ci, ei, ki, si) and labeling functions αi, deﬁne a labeling
function β′
i:ei→ν′such that for an event ei,β′
i(ei) = eqvl( ei), i.e. it
returns the equivalence class of ◃ ▹containing ei.
after re-labeling the events, the part of the run shown in figure 6(d) is rela-
beled to include the pre- and post-conditions. figure 7 shows the fragment after
relabeling. (we only show the relabeling with respect to the post-conditions.)
applying the alk algorithm of deﬁnition 4.5 to the relabeled runs yields the
result as shown in figure 8. note that we do not show the ν′labels explicitly,
i.e.brefers to the equivalence class of events labeled b.
what remains to be shown is that our algorithm does not only work for
our small running example, but also in the general case. the only diﬀerence
between the assumptions in deﬁnition 4.5 and deﬁnition 4.6 is the requirement
with respect to transition equivalence. therefore, if suﬃces to show that after
··
a
p1p2b
c
(a)·· ··
a
p2p1
d
(b)·· ··
ep2b
(c)·· ··
p2p1
dx
x
(d)··
fig. 6. four examples of parts of runs.p2p1
dx
xp1
p2fig. 7. the relabeled part of figure 6(d).: : :
a
p1p2b
cde
xx
p2
p1 : : :
fig. 8. part of the aggregated net.
applying the relabeling algorithm on a causal set, we can establish transition
equivalence.
property 4.7. (transition equivalence holds after relabeling)
letµ, νbe two disjoint sets of labels. let φ={(ci, ei, ki, si)|0≤i < n }
be a causal set, and let ψ={(αi:ci→µ, βi:ei→ν)|0≤i < n }be a
set of labeling functions in ( ci, ei, ki, si), such that αi(si) is the same for all
causal nets. after applying the relabeling algorithm, the property of transition
equivalence holds for ( φ, ψ′), with ψ′={(αi:ci→µ, β′
i:ei→ν′)|0≤i < n},
andβ′
ias deﬁned in deﬁnition 4.6.
proof. we prove that property 4.4 holds for ( φ, ψ′) after applying the relabeling
function. assume ( ci, ei, ki, si) and ( cj, ej, kj, sj) are two causal nets from φ.
the new function β′
iis indeed a function, since for each event ei∈eithere exists
exactly one equivalence class containing ei. furthermore, let ei∈eiandej∈ej,
such that β′
i(ei) =β′
j(ej). we know that ei◃ ▹ ejand from the deﬁnition of ◃ ▹,
we know that αi(•ei) =αj(•ej) and αi(ei•) =αj(ej•), which directly implies
transition equivalence. ⊓ ⊔
the algorithm presented above is capable of ﬁnding events that have the
same label, but correspond to diﬀerent transitions in the system net. when no
transition labels are known at all , it can be applied to nd all transition labels ,
by using an initial ν={τ}and initial mapping functions βi, mapping everything
ontoτ. however, in that case, no distinction can be made between events that
have the same pre- and post-set, but should have diﬀerent labels. after applying
this relabeling algorithm, the alk algorithm of section 4.1 can be used to ﬁnd
the system net belonging to the given causal nets.
4.3 aggregation with unknown place labels
in section 4.2, we have shown a way to identify the transitions in a system net,
based on the labels of events in causal nets. however, what if condition labels
are not known? notice that the diﬀerence to other approaches based on partial
orders is that here we do know the conditions constituting the order between
events but do notknow which two conditions refer to a token in the same place
of the p/t-net representing the process.
so, in this section, we take one step back. we assume all events to refer to
the correct transition, as we did in section 4.1 and we try to identify the labels··
ab
c
(a)·· ··
a d
(b)·· ··
e b
(c)·· ··
df
g
(d)··
fig. 9. four examples of parts of runs.
of conditions. we introduce an algorithm to aggregate causal nets to a system
net, such that the original causal nets are indeed runs of that system net.
in figure 9, we again show our small example of the aggregation problem,
only this time there are no labels for conditions p1 and p2, which we did have
in figures 4 and 6.
consider the four runs of figure 9. remember that they are parts of causal
nets, in such a way that the tasks a, b, c, d, e, f andgdo not appear in
any other way in another causal net. in contrast to the algorithms presented in
previous sections, we cannot always derive a unique aggregated system net for
causal nets if we do not have labels for the conditions. instead, we deﬁne an
aggregation class , describing a class of wf-nets that could have generated these
causal nets. the following table shows some requirements all wf-nets in the
aggregation class of our example should satisfy.
table 1. information derived from runs shown in figure 9.
fragment conclusions
fig. 9(a) a•=•b⊎ •c
fig. 9(b) a•=•d
fig. 9(c) e•=•b
fig. 9(d) f• ⊎g•=•d
the information in table 1 is derived from the runs of figure 9 in the fol-
lowing way. figure 9(a) shows that the transition aproduces two tokens in two
places and that transitions bandcconsume these two tokens, while at the
same time they do not need more input. hence, we can conclude that in any
aggregated net, the multiset of tokens produced by ashould be equal to the
multiset of tokens consumed by bandctogether, which is stated in the ﬁrst
line of table 1.
in the general case, this information can be derived using the concept of a
segment, which can be considered to be the context of a condition in a causal net.
a segment consists of two sets of events (an input set and an output set), such
that the tokens produced by the transitions in the system net, corresponding
to the events in the input set are exactly the tokens consumed by the transi-
tions corresponding to the events in the output set, i.e. we formally capture the
relations described in table 1.: : :
ab
cde
gf
(a): : : : : :
ab
cde
fg
(b): : :
fig. 10. two aggregated nets.
denition 4.8. (segment)
letn= ((c, e, k ), s0) be a causal net and let n′= (c′, ein, eout) be such
thatc′⊆c,ein∪eout⊆e,ein̸=∅andeout̸=∅. we call n′asegment if:
{for all c∈c′holds that •c⊆einandc• ⊆eout, and
{for all e∈einholds that e• ⊆c′, and
{for all e∈eoutholds that •e⊆c′, and
{the subgraph of nmade up by c′∪ein∪eoutis connected.
we call the events in einthe input events and the events in eoutthe output
events.
a segment is called minimal ifc′is minimal, i.e. if there does not exist a
segment n′′= (c′′, e′
in, e′
out) with c′′⊂c′andc′′̸=∅.
for the fragments of figure 9, it is easy to see that each of them contains
only one minimal segment, where the input events are the events on the left
hand side and the output events are the events on the right hand side.
the meaning of a segment is as follows. if we have a run and a segment in
that run, then we know that after all events in the input set of the segment
occurred, all the events in the output set occurred in the execution represented
by this run. this translates directly to a marking in a system net, since the
occurrence of a set of transitions would lead to some marking (i.e. a bag over
places), which enables another set of transitions. furthermore, each transition
only produces one token in each output place. combining this leads to the fact
that for each minimal segment in a causal net the bag of places following the
transitions corresponding to the input events of the segment should be the same
as the bag of places preceding the transitions corresponding to the output set of
events, as indicated in table 1.
clearly, when looking only at these fragments, what we are looking for are
the places that should be put between tasks a, e, f andgon the one hand,
andb, c anddon the other hand. therefore, we only focus on this part of the
causal nets. for this speciﬁc example, there are two possibilities, both of which
are equally correct, namely the two wf-net fragments shown in figure 10.
from the small example, we have seen that it is possible to take a set of
causal nets without labels for any of the conditions (but with labels for all the
events) and to deﬁne a class of potential system nets of the causal nets. in theinvite 
reviewers get 
review 1
get 
review 2
get 
review 3collect 
& decide accept 
paper (a)
invite 
reviewers get 
review 1
get 
review 2
time-out 
review 3collect 
& decide reject 
paper 
(b)
invite 
reviewers time-out 
review 1
time-out 
review 2
get 
review 3collect 
& decide invite add. 
reviewer 
get add.
review reject 
paper 
(c)
fig. 11. three causal nets of a review process of a paper.
remainder of this section, we show that this is indeed possible for all causal sets.
for this, we ﬁrst introduce the ncl algorithm.
4.4 ncl algorithm
before presenting the ncl algorithm (which stands for “no condition labels”),
we ﬁrst take a look at a more intuitive example. consider figure 11, where we
present three causal nets, each of which corresponds to a paper review process. in
the ﬁrst causal net, three reviewers are invited to review the paper and after the
three reviews are received, the paper is accepted. in the second causal net, only
two reviews are received (the third one is not received on time), but the paper
is rejected nonetheless (apparently the two reviewers that replied rejected the
paper). in the third example only one review is received in time, and therefore
an additional reviewer is invited, which hands in his review in time, but does
not accept the paper.
as we stated before, we deﬁne an aggregation class of a causal set that
contains all wf-nets that are capable of generating the causal nets in the causal
set. the information needed for this aggregation class comes directly from thetable 2. information derived from review example.
causal net conclusions on transitions in the aggregation class
fig. 11(a) •“invite reviewers” = [pini]
“invite reviewers” • =•“get review 1” ⊎
•“get review 2” ⊎
•“get review 3”
“get review 1” • ⊎
“get review 2” • ⊎
“get review 3” •=•“collect & decide”
“collect & decide” • =•“accept paper”
|“accept paper” • | = 1
fig. 11(b) •“invite reviewers” = [pini]
“invite reviewers” • =•“get review 1” ⊎
•“get review 2” ⊎
•“time-out review 3”
“get review 1” • ⊎
“get review 2” • ⊎
“time-out review 3” •=•“collect & decide”
“collect & decide” • =•“reject paper”
|“reject paper” • | = 1
fig. 11(c) •“invite reviewers” = [pini]
“invite reviewers” • =•“time-out review 1” ⊎
•“time-out review 2” ⊎
•“get review 3”
“time-out review 1” • ⊎
“time-out review 2” • ⊎
“get review 3” •=•“collect & decide”
“collect & decide” • =•“invite add. reviewer”
“invite add. reviewer” •=•“get add. review”
“get add. review” • =•“reject paper”
|“reject paper” • | = 1causal nets, using minimal segments. in table 2, we present the conclusions we
can draw based on the three causal nets of figure 11. in this table we consider
bags of pre- and post-sets of transitions in the aggregation class. the information
in this table is obtained from the causal nets in the following way. consider for
example figure 11(a), where invite reviewers is followed by get review 1 ,get
review 2 and get review 3 . this implies that the bag of output places of invite
reviewers should be the same as the sum over the bags of the input places of
get review 1 ,get review 2 and get review 3 .
denition 4.9. (ncl algorithm: aggregation class)
letφ={(ci, ei, ki, si)|0≤i < n}be a causal set, and let n= (p, t, f, m 0)
be a marked wf-net. for each causal net ni∈φi, letβi:ei→tbe a mapping
from the events of that causal net to t, such that βiis a labeling function for
ei. we deﬁne aφ, the aggregation class ofφ, as the set of all pairs ( n,b) such
that the following conditions are satisﬁed:
1.t=∪
0≤i<nrng(βi) is the set of transitions, i.e. each transition appears as
an event at least once in some causal net,
2.for all p∈pholds thatn•p∪pn•̸=∅,
3.m0= [pini] andn•pini=∅,
4.bis the set of all labeling functions, i.e. b={βi|0≤i < n}. we use βi∈ b
to denote the labeling function for events belonging to ni∈φ,
5.for each causal net ni= (ci, ei, ki, si), with e∈eiandβi(e) =tholds
that if si(ni•e) = 1 then pini∈n•t,
6.for each causal net ni= (ci, ei, ki, si), with e∈eiandβi(e) =tholds
that|tn•|=|eni•|and|n•t|=|ni•e|,
7.for each causal net ni= (ci, ei, ki, si), with e∈ei,βi(e) =tandt′⊆t
holds that |tn•∩∪
t′∈t′(n•t′)| ≥∑
e′∈ei,β(e′)∈t′|eni•∩ni•e′|,
8.for each causal net ni= (ci, ei, ki, si), with e∈ei,βi(e) =tandt′⊆t
holds that |∪
t′∈t′(t′n•)∩n•t| ≥∑
e′∈ei,β(e′)∈t′|e′ni•∩ni•e|,
9.for each causal net ni= (ci, ei, ki, si) and any minimal segment
(c′
i, ein, eout) ofni, holds that⊎
e∈ein(
βi(e)n•)
=⊎
e∈eout(n•βi(e))
.
deﬁnition 4.9 deﬁnes an aggregation class of models in the following way:
{for each workﬂow net in the class, items 1 to 4 deﬁne the transitions, places,
initial marking and the labeling functions, labeling all events and conditions
of each causal net with the transitions and places of that workﬂow net.
{item 5 guarantees that all events in causal sets consuming the initial to-
kens are labeled with output transitions of the initially marked place in the
workﬂow net.
{item 6 guarantees that, for all events, the numbers of input and output
conditions correspond to the numbers of input and output places of the
corresponding transition.{items 7 and 8 refer to the token ﬂow in the model, in relation to the causal
nets, i.e. when considering the ﬂow between a set of transitions and one
other transitions (in any direction), the number of tokens ever observed in
any causal set cannot be larger than the number of tokens allowed according
to the model. hence, choices in the model do not correspond to parallel
behavior in any causal net.
{figure 12 is used to gain more insight into item 9 of deﬁnition 4.9. in
the lower causal net of that ﬁgure, there is a token traveling from atod
and another one from btoc. the upper causal net only connects aand
c. assuming that these are the only causal nets in which these transitions
appear, we know that the conditions between aanddand between b
andcshould represent a token in the same place, since there is a minimal
segment ( {c4, c5, c6},{a, b},{c, d}) in the lower causal net and therefore,
a• ⊎b•=•c⊎ •d= [p1,2p2].
a
c2c1 c
t s
a
p1
p2c
dt
bs
a
c5c4
c6c
dt
bs… …
… …
fig. 12. example explaining the use of bags.
consider the information presented in table 2 and the two petri nets in
figure 13. both nets in figure 13 adhere to all constraints of table 2. as this
example shows, there is no unique petri net satisfying all constraints. instead,
there is a class of nets satisfying all constraints.
the condition provided in item 9 of deﬁnition 4.9 provides the key to con-
structing the actual elements of the aggregation class. by considering all minimal
segments in the provided runs that refer to the same transitions, possible sets of
places can be identiﬁed that satify this condition. however, in this paper, we do
not provide construction steps for constructing the aggregation class. instead,
in the next section, we show that if a set of runs is generated by a system net,
then that system net is a member of the aggregation class.
5 correctness of the aggregation algorithms
in section 4, we described three scenarios for which we can construct an ag-
gregated net from a set of runs. in section 4.1, we showed the alk algorithm,
which assumes that in the runs, all conditions and events are labeled with theinvite 
reviewers get 
review 1
get 
review 2
time-out 
review 3collect 
& decide invite add. 
reviewer get add.
review 
accept 
paper time-out 
review 1
time-out 
review 2
get 
review 3reject 
paper (a)
invite 
reviewers get 
review 1
get 
review 2
time-out 
review 3collect 
& decide invite add. 
reviewer get add.
review 
accept 
paper time-out 
review 2
time-out 
review 1
get 
review 3reject 
paper 
(b)
fig. 13. two possible aggregated nets, both obeying the constraints of table 2.
corresponding places and transitions of the aggregated net. in section 4.2, we
showed that in case some transition labels are duplicated or missing, we can still
use the alk algorithm after relabeling the transitions using the surrounding
places. finally, in section 4.3, we presented the ncl algorithm that provides
an aggregation class of nets that are all capable of reproducing the given set of
runs in which none of the conditions is labeled.
in this section, we formally prove correctness of the alk and the ncl algo-
rithms.
5.1 correctness of the alk algorithm
the alk algorithm deﬁnes a single aggregated net for a given set of runs.
in order to prove its correctness, we show that the runs used as input can be
generated by the resulting aggregated net.
property 5.1. (the alk algorithm is correct)
for all 0 ≤i < n andni= (ci, ei, ki, si), the tuple ( ni, αi, βi) is indeed a
run of n= (p, t, f, m 0) (i.e., the requirements stated in deﬁnition 3.11 are
fulﬁlled).proof. since we assumed that all causal nets ni= (ci, ei, ki, si) are elements
of the causal set φ, we need to prove the following for each αiandβi.
1.αiis a function from ciontop. this trivially follows from deﬁnition 4.5.
2.βiis a function from eiontot. this trivially follows from deﬁnition 4.5.
3.αi(si) =m0holds by deﬁnition, since it holds for s0and for all causal nets,
αi(si) is the same.
4.for each event e∈ei, the mapping αiinduces a bijection from •eto•βi(e)
and a bijection from e•toβi(e)•.
lete∈ei. we start by showing that αi(ni•e) =n•βi(e) and αi(eni•) =βi(e)n•.
assume p∈αi(ni•e)\n•βi(e), i.e. there exists a c∈ciwith ( c, e)∈ki, such
thatp=αi(c),βi(e) =tand ( p, t)̸∈f. clearly this contradicts with the
deﬁnition of fin deﬁnition 4.5. now assume p∈n•βi(e)\αi(ni•e), i.e. there
is a ( p, t)∈fsuch that βi(e) =tand there is no c∈ciwith αi(c) =p,
such that ( c, e)∈ki. if this is the case in all causal nets for 0 ≤i < n , then
this leads to a contradiction since this would imply ( p, t)̸∈f(cf. deﬁnition
offin deﬁnition 4.5). if there is a 0 ≤j < n , such that ( c′, e′)∈kjwith
βj(e′) =tandαj(c′) =p, then there has to be a c∈cisuch that ( c, e)∈ki,
since αi(ni•e) =αj(ni•e′) (cf. deﬁnition 4.4). combined with the fact that αi
andβiare labeling functions, αi(ni•e) =n•βi(e) and αi(eni•) =βi(e)n•yields
the bijection. similar arguments apply for the post-set.
⊓ ⊔
property 5.1 shows that the alk algorithm indeed results in a system net
of which the causal nets used as input are runs.
5.2 correctness of the ncl algorithm
in case that no condition labels are present, the ncl algorithm deﬁnes an equiv-
alence class of aggregated nets. in this section, we show that for each net in this
aggregation class, the causal nets used as inputs can be considered runs. fur-
thermore, we show that if we take the runs of a sound workﬂow model as input,
then that model is part of the aggregation class.
deﬁnition 4.9 deﬁnes a nite class of wf-nets for a causal set. what remains
to be given are the conditions under which it is a ﬁnite non-empty class of
petri nets and the proof that each petri net with its mappings is indeed a system
net for the causal set. to prove this, we ﬁrst introduce the concept of a condition
graph .
denition 5.2. (condition graph)
letni= (ci, ei, ki, si) be a causal net. the undirected graph ∆ni= (ci, a),
with a={(c1, c2)∈ci×ci| ∃e∈ei{c1, c2} ⊆ni•e∨ {c1, c2} ⊆eni•}is called a
condition graph . note that ( c1, c2)∈aimplies that ( c2, c1)∈a.
we use condition graphs to prove that each petri net with its mappings in
the aggregation class of a causal set is indeed a system net for that causal set.for this, we ﬁrst introduce some lemmas on these condition graphs that show
the relation between condition graphs and causal nets. we start by showing that
pre- and post-sets of events correspond to complete subgraphs in the condition
graph, i.e. subgraphs where each pair of nodes is connected by an edge.
lemma 5.3. (pre- and post sets relate to complete subgraphs in con-
dition graphs)
letni= (ci, ei, ki, si) be a causal net and ∆ni= (ci, a) its condition graph.
we show that, for each e∈ei, holds that ∆nirestricted toni•eis a complete
subgraph and ∆nirestricted to eni•is a complete subgraph. furthermore, for
each complete subgraph ( c′, a′), there exists an e∈eisuch that c′⊆ni•eor
c′⊆eni•.
proof. since for all {c1, c2} ⊆ni•e, holds that ( c1, c2)∈aby deﬁnition, the
ﬁrst part is correct. the same applies to eni•. now assume ( c′, a′) is a complete
subgraph. assume {c1, c2} ⊆c′. and c1̸=c2. since we are looking at a complete
subgraph, we know ( c1, c2)∈a′, therefore there exists an e1∈ei, such that
{c1, c2} ⊆ni•e1or{c1, c2} ⊆e1ni•.
assume {c1, c2} ⊆ni•e1(the proof is symmetrical for e1ni•).
now assume c3∈c′such that c1̸=c3andc2̸=c3. let
c3̸∈ni•e1. we show that this leads to a contradiction. since
for all c∈cholds that |cni•| ≤1 and {c1, c2} ⊆ni•e1, we
know that there must be an e2∈ei, such that {c2, c3} ⊆
e2ni•.
c1c2
c3e1
e2 e3
similarly, we know that there is an e3∈ei, such that {c1, c3} ⊆e3ni•. however,
since |ni•c3| ≤1, this implies that e2=e3and thus {c1, c2, c3} ⊆e2ni•. ⊓ ⊔
using the fact that each pre- and post-set correspond to a complete sub-
graph, we can infer that each minimal segment in a causal net corresponds to a
connected subgraph in the condition graph, i.e. a subgraph such that there is a
path between each two nodes. furthermore, we show that these connected sub-
graphs are maximal, i.e. all nodes in the subgraph are only connected to nodes
inside the subgraph.
lemma 5.4. (minimal segments correspond to maximal connected sub-
graphs in condition graphs)
letni= (ci, ei, ki, si) be a causal net and ∆ni= (ci, a) its condition graph.
let (c′, ein, eout) be a minimal segment in ni. we show that ( c′, a∩(c′×c′))
is a maximal connected subgraph of ∆ni.
proof. from deﬁnition 4.8 we know that the graph ( c′∪ein∪eout, ki∩((c′∪
ein∪eout)×(c′∪ein∪eout))) is a connected graph. now, let c∈c′be a
condition in the minimal segment and assume that {ein}=ni•cand{eout}=cni•.
from lemma 5.3, we know that einni•andni•eoutmake up a complete subgraph
in∆niand since c∈ni•eout∩einni•that these two complete subgraphs makeup a connected subgraph. by induction over the elements of c′, it is easy to
show that c′makes up a connected subgraph in ∆ni. therefore, each minimal
segment deﬁnes a complete subgraph g′in∆ni. furthermore, let g′= (c′, a′)
be the connected subgraph of ∆nicorresponding to the segment. let c∈ci\c′
and assume there exists a c′∈c′, such that ( c, c′)∈a. this implies that there
is an e∈ei, such that {c, c′} ⊆ni•eor{c, c′} ⊆eni•. however, this implies that
e∈einore∈eout, either of which imply that c∈c′. therefore, such a cdoes
not exist and g′is maximal. ⊓ ⊔
at this point, we look at the deﬁnitions of section 3 again. if we assume that
we have a system net and the causal behavior of this system net, we can derive
the next lemma using deﬁnition 3.4.
lemma 5.5. (system nets color condition graphs)
letn= (p, t, f, m 0) be a system net and ( ni, αi, βi) be a run of that system
net, with ni= (ci, ei, ki, si). furthermore, let ∆ni= (ci, a) be the condition
graph of ni. the mapping αi:ci→pis a coloring function of ∆ni, with the
set of colors being p.
proof. letn1, n2∈cibe two nodes in ∆niwith n1̸=n2. for αito be a
coloring, αi(n1)̸=αi(n2) should hold if ( n1, n2)∈a. assume ( n1, n2)∈a. this
means that there is an e∈eisuch that {n1, n2} ⊆ni•eor{n1, n2} ⊆eni•. from
deﬁnition 3.11, we know that αiinduces a bijection fromni•eton•βi(e) and from
eni•toβi(e)n•. therefore, αi(n1)̸=αi(n2). ⊓ ⊔
we have shown that system nets color condition graphs. however, we can go
one step further and introduce the concept of a condition coloring, which is a
coloring on the condition graph, such that the coloring function, when applied to
the conditions in a causal net, induces local bijections for the input and output
sets of events.
denition 5.6. (condition coloring)
letφbe a causal set and let aφbe the aggregation class of φ. moreover, let
(n,b)∈ a φ, with n= (p, t, f, m 0) and let ni= (ci, ei, ki, si)∈φbe a
causal net and ∆ni= (ci, a) be the condition graph of ni. assume αi:ci→p
is a function, such that αiis a coloring on ∆niand for all c∈ciholds that
αi(c)∈ {p∈p|β(ni•c)⊆n•p∧β(cni•)⊆pn•}.4we then call αia condition
coloring of ∆ni.
the concept of a condition coloring we introduced here is often referred to
in mathematics as a list coloring.
lemma 5.7. (condition coloring induces bijections)
letφbe a causal set and let aφbe the aggregation class of φ, and let ( n,b)∈
aφ, with n= (p, t, f, m 0). let ni= (ci, ei, ki, si)∈φbe a causal net and
∆ni= (ci, a) be the condition graph of ni. let αi:ci→pbe a condition
4note that is generalized, i.e. for a set eholds that (e) ={(e)|e∈e}.coloring of ∆ni. we show that for all e∈ei,αiinduces a bijection fromni•eto
n•βi(e) and from eni•toβ(ei)n•.
proof. the requirements stated in deﬁnition 4.9, imply that |ni•e|=|n•β(e)|.
furthermore, since ∆nirestricted toni•eis a complete graph (lemma 5.3), and
αiis a coloring function (lemma 5.5), we know that |αi(ni•e)|=|ni•e|since
all elements inni•eare mapped to diﬀerent colors. combining both implies that
|αi(ni•e)|=|n•βi(e)|.
for all c∈ni•eholds that αi(c)∈ {p∈p|βi(ni•c)⊆n•p∧βi(cni•)⊆pn•}
(deﬁnition 5.6) and cni•={e}, because niis a causal net we know that αi(c)∈
{p∈p|βi(e)∈pn•}and thus αi(c)∈n•βi(e). since this holds for all c∈ni•e, we
can conclude that αi(ni•e)⊆n•βi(e). by combining the above, we can conclude
thatαi(ni•e) =n•β(e), and thus that αiinduces a bijection fromni•eton•βi(e). a
similar proof holds for the mapping from eni•toβi(e)n•. ⊓ ⊔
at this point we still need to prove the following for an arbitrary wf-net in
the aggregation class. for each causal net in a causal set, we should be able to
color its condition graph using a condition coloring. if we are able to construct
such a coloring, we have satisﬁed the ﬁrst requirement stated in deﬁnition 3.11.
lemma 5.8. (condition coloring exists)
letφbe a causal set, let aφbe the aggregation class of φ, and let ( n,b)∈ a φ,
with n= (p, t, f, m 0). let ni= (ci, ei, ki, si)∈φbe a causal net and
∆ni= (ci, a) be the condition graph of ni. let βi∈ bbe the labeling function
belonging to ni. we show that we can construct a mapping αi:ci→p, such
thatαiis a condition coloring of ∆ni.
proof. first, we look at the initial condition, i.e. the initially marked source
condition. assume c∈cisuch thatni•c=∅. we call cni•={e}. from the
deﬁnition of a causal set (def. 4.3), we know that {c}=ni•eand thus that there
is noc′∈ciwithc̸=c′and (c, c′)∈a. we know thatn•βi(e) ={pini}(def. 4.9).
by setting αi(c) =pini, we have a correct coloring for the initial condition cin
n.
second, we look at the ﬁnal conditions, i.e. the sink conditions. assume
c∈cisuch that cni•=∅. we callni•c={e}. from the deﬁnition of a causal set
(def. 4.3), we know that {c}=eni•and thus that there is no c′∈ciwithc̸=c′
and ( c, c′)∈a. we know that |βi(e)n•|= 1 (def. 4.9). we say that βi(e)n•={p}.
by setting αi(c) =p, we have a correct coloring for any ﬁnal condition cinni.
finally, we split the graph up into two subgraphs. let ain={(c1, c2)∈
a|ni•c1=ni•c2}and let aout={(c1, c2)∈a|c1ni•=c2ni•}. using the deﬁnition
of a condition graph it is easy to see that ain∪aout=a. we now show that for
each subgraph δin(ni) = (c, a in) and δout(ni) = (c, a out) we can construct at
least one condition coloring. then, we show that there is at least one condition
coloring that is the same for both subgraphs after which we can use lemma 3.5
to show that this is a condition coloring on the complete graph.consider the subgraph δin(ni) = (c, a in). using lemma 5.3, it is easy to see
that this graph consists of several complete components and that each component
is a complete graph. let e∈ei. we know that eni•⊆cand that eni•deﬁnes
a complete component in δin(ni). now, let v1, . . . , v nbe maximal sets, such
that for each 0 < i≤nholds that vi⊆eni•and for all c1, c2∈viholds that
c1ni•=c2ni•. for each viandc∈vi, we say that vi,in={e}andvi,out=cni•.
from deﬁnition 5.6, we know that for each c∈vimust hold that αi(c)∈ {p∈
p|βi({e})⊆n•p∧β(vi,out)⊆pn•}. using item 7 of deﬁnition 4.9, we ﬁrst prove
a necessary condition for this. assume βi({e}) ={t}, and βi(vi,out) =t′={t′}.
item 7 shows us that |tn•∩n•t′| ≥∑
e′∈vi;out|eni•∩ni•e′|. from the deﬁnition of
partition v, we know that∑
e′∈vi;out|eni•∩ni•e′|=|vi|. furthermore, tn•∩n•t′=
{p∈p|βi(vi,in)⊆n•p∧βi(vi,out)⊆pn•}. therefore we know that there are at
least enough colors available for each partition vi. the same way of reasoning
can be used to show that there are at least enough colors available for each set
of partitions υ⊆ {v1, . . . , v n}. (the latter requires the use of item 8 instead of
7 of deﬁnition 4.9). therefore, there exists at least one condition coloring for
the entire subgraph δin(ni). similarly, this can be shown for δout(ni).
at this point, we have shown that we can construct condition colorings for
two subgraphs of δ(ni), namely δin(ni) and δout(ni). the ﬁnal part of the
proof use item 9 of deﬁnition 4.9, since we now have to show that the same
condition coloring can be constructed for both subgraphs. for this purpose, we
consider a segment ( c′, ein, eout) inni. since segments correspond to connected
components of δ(ni), it is suﬃcient to show that the same condition coloring
can be constructed for δin(ni) and δout(ni), restricted to c′, which we call
δ′
in(ni) and δ′
out(ni). from the deﬁnition of a segment, it is clear that this
restriction does not disturb the structure of δin(ni) and δout(ni), i.e. in both
graphs, each connected component is still a complete subgraph. now consider
a possible condition coloring on δ′
in(ni). each color given to a condition in
that graph refers to a place in the causal net. however, multiple conditions
can be mapped onto each place, namely one condition for each token that was
produced in that place by an element of ein. the same holds for δ′
out(ni), i.e.
multiple condition can be mapped onto each place, namely one condition for
each token that was consumed by a succeeding element of eout. since item 9 of
deﬁnition 4.9 states that the tokens produced by einare the tokens consumed
byeout, it must be possible to construct the same condition coloring αifor both
δ′
in(ni) and δ′
out(ni). using lemma 3.5, we then know that this coloring αiis a
condition coloring on δ(ni)′, i.e. the restriction of δ(ni) toc′.
since we can now provide a condition coloring on each connected component
ofδ(ni), we have shown that we can construct a condition coloring on the entire
graph δ(ni). ⊓ ⊔
to clarify the rather complex proof of lemma 5.8 we use an example. con-
sider a causal net containing the fragment of a wf-net presented in figure 14.
we numbered the conditions 1 through 8 to be able to distinguish them. now,assume that the two petri nets presented in figure 15 are parts of two alternative
system nets appearing in the aggregation class of that causal net.
ab
a
b
cdd
e
f
gc2
c3c1
c5c4
c6
c7
c8
fig. 14. a part of a run containing two
segments.
ab
c
ge
fd p1
p2
p3
p4(a)
ab
c
ge
fd p1
p2
p3
(b)
fig. 15. two parts of system nets in the
aggregation class of figure 14.
the proof of lemma 5.8 depends on the condition graph of a run. therefore,
in figure 16 we present the condition graph of the run presented in figure 14.
note that we labeled the edges to show from which event the edge was derived.
c1c2 c5 c4 c3
c6 c7e a
f
f cf
c8a
fig. 16. part of the condition graph of the run of figure 14.
in lemma 5.8, the condition graph of figure 16 (i.e. δ(ni) in the lemma) is
split up into two subgraphs, namely one for the input side of events (i.e. δin(ni),
see figure 17) and one for the output sides of events (i.e. δout(ni), see figure 18).
then the proof continues, by showing that for each of these two subgraphs
it is possible to provide a condition coloring. figure 19 shows the possible labels
for each subgraph and both petri nets from figure 15. it is easy to see that this
indeed leads to several possible colorings in each graph.c1c2 c5 c4 c3
c6 c7a
cc8afig. 17. input subgraph of figure 16.
c1c2 c5 c4 c3
c6 c7e
f
ff
c8 fig. 18. output subgraph of figure 16.
at this point it is proven that it is always possible to construct two coloring
functions on the input and output subgraph that give the same label to each
condition in both graphs. if we look at figure 19 and we take the input subgraph
shown in figure 15(a) (i.e. the left-top ﬁgure) then it is easy to see that it is
possible to label c4with p2andc5with p1. this however is not possible in the
output subgraph, since neighbor c6has to be mapped onto p1. instead, there
is only one mapping that is the same for both subgraphs. the last part of the
proof uses the fact that for each segment the input enables the output. this
implies that the token that is placed in p1has to be consumed from there again.
therefore, if we would label c5with p1then this would be the same as saying
that transition aproduces a token in p1which is consumed by transition f
again. however, transition falso consumes another token from p1, namely the
one corresponding to c6, i.e. coming from transition b. this violates the fact
that only one edge can exist between a place and a transition.
figure 20 shows the only possible condition coloring of the condition graph
of figure 16, using the labels provided by the system net of figure 15(a) and
figure 21 shows the only possible condition coloring of the condition graph of
figure 16, using the labels provided by the system net 15(b). note that in general
additional condition colorings may be possible.
c1c2 c5 c4 c3
c6 c7 c8p1p1,p2p1,p2p1,p2
p1 p3 p4p1
input subgraph
c1c2 c5 c4 c3
c6 c7 c8p1p1,p2p1,p2p1,p2
p1 p3 p4p1
output subgraph
labels according to figure 15(a).
c1c2 c5 c4 c3
c6 c7 c8p1p1,p2p1,p2p1,p2
p1 p2,p3 p2p1input subgraph
c1c2 c5 c4 c3
c6 c7 c8p1p1,p2p1,p2p1,p2
p1 p2,p3 p2p1
output subgraph
labels according to figure 15(b).
fig. 19. possible condition colorings for the subgraphs of ﬁgures 17 and 18.c1c2 c5 c4 c3
c6 c7 c8p1 p2 p1 p2
p1 p3 p4p1fig. 20. the condition coloring of fig-
ure 16 according to figure 15(a).
c1c2 c5 c4 c3
c6 c7 c8p1 p2 p1 p2
p1 p3 p2p1fig. 21. the condition coloring of fig-
ure 16 according to figure 15(b).
from figures 20 and 21, we can conclude that both system nets depicted in
figure 15 are indeed capable of producing the causal net of figure 14, since we
can construct a condition coloring on the condition graphs.
what remains to be shown is that the condition coloring also fulﬁlls the last
part of the deﬁnition of a run, namely the demand with respect to the initial
marking. furthermore, we conclude that at least three places are needed in the
system net and that, for example, the place between candgcould also be p1.
lemma 5.9. (initial marking can be mapped)
letφbe a causal set, let aφbe the aggregation class of φand let ( n,b)∈ a φ
with n= (p, t, f, m 0). let ni= (ci, ei, ki, si)∈φbe a causal net and
∆ni= (ci, a) be the condition graph of ni. let αi:ci→p, such that αiis a
condition coloring of ∆ni. we show that αi(si) =m0.
proof. from deﬁnition 4.9, we know that m0= [pini]. furthermore, from def-
inition 4.3, we know that there is exactly one c∈ciwith s(c) = 1. moreover,
using lemma 5.8, we conclude that αi(c) =piniand thus αi(si) = [pini] =m0.
⊓ ⊔
finally, we can combine everything and state that each wf-net in an aggre-
gation class is indeed a system net of a causal set.
property 5.10. (aggregation class only contains system nets)
letφbe a causal set, let aφbe the aggregation class of φand let ( n,b)∈ a φ
withn= (p, t, f, m 0). let ni= (ci, ei, ki, si)∈φbe a causal net with event
labeling function βi∈ b, condition graph ∆ni= (ci, a) and αi:ci→pa
condition coloring of ∆ni. then ( ni, αi, βi) is a run of n.
proof. this result combines lemma 5.7, which shows that for all e∈ei,αi
induces a bijection fromni•eton•βi(e) and from eni•toβi(e)n•and lemma 5.9
which shows that αi(si) =m0. ⊓ ⊔
we have shown that it is possible to take a set of causal nets and construct
a system net such that each causal net is a run of that system net, as long as
the causal nets have one initially marked condition. what we did not show are
the conditions under which the aggregation class is not empty. these conditions
however, cannot be given based on a set of causal nets. even if these causal nets
belong to one causal set, this is still not enough. what we canshow however,is that if we start from a sound wf-net as a system net, generate a set of runs
and remove the labels of places, the original wf-net is in the aggregation class.
for the full deﬁnition of soundness, we refer to [1,4].
property 5.11. (a system net is in the aggregation class of its runs)
letn= (p, t, f, m 0) be a sound wf-net. we consider nto be a system net.
letb={(ni, αi, βi)|0≤i < n }be the causal behavior of that system net,
such that each ( ni, αi, βi) is a run of that system net, with ni= (ci, ei, ki, si).
letb={βi|0≤i < n}andφ={ni|0≤i < n}be a causal set. we show
that ( n,b)∈ a φ.
proof. we show that all conditions of deﬁnition 4.9 are satisﬁed.
1.t=∪
0≤i<nrng(βi) is the set of transitions. since the wf-net is sound, there
are no dead transitions thus implying that in its causal set each transition
appears as an event at least once.
2.for all p∈pholds thatn•p∪pn•̸=∅. since every sound wf-net is connected,
this condition is satisﬁed,
3.m0= [pini] andn•pini=∅. since nis a wf-net, there is exactly one place
pini∈p, such thatn•pini=∅andm0= [pini],
4.bis the set of all labeling functions, i.e. b={βi|0≤i < n}.
5.for each causal net ni, with e∈eiandβi(e) =tandni•e={c}, holds that
ifsi(c) = 1 then pini∈n•t. since si(c) = 1, we know thatni•c=∅. now
assume αi(c) =p. the fact that for all e′∈ei,αiinduces local bijections
from e′ni•toβi(e′)n•implies thatn•p=∅and since nis a workﬂow net,
this implies that p=pini. moreover, the fact that for all αiinduces local
bijections fromni•eton•timplies that pini∈n•t,
6.for each causal net ni, with e∈eiandβi(e) =tholds that |tn•|=|eni•|
and|n•t|=|ni•e|. since αiinduces bijections from eni•totn•and fromni•eto
n•t, this condition is satisﬁed,
7.for each causal net ni, with e∈ei,βi(e) =tandt′⊆tholds that
|tn•∩∪
t′∈t′(n•t′)| ≥∑
e′∈ei,βi(e′)∈t′|eni•∩ni•e′|. let e∈eiwith βi(e) =t
and let t′⊆t. assume that there |tn•∩∪
t′∈t′(n•t′)|=m, i.e. there are m
places between tandt′. furthermore, assume that∑
e′∈ei,βi(e′)∈t′|eni•∩ni•
e′|< m. since for all e′∈eiwith beta i(ei) =ti,αiinduces local bijections
fromni•eiton•ti, we know that there are at least two c1, c2∈eni•that are
mapped onto the same p∈p. however, since p∈tn•this violates the local
bijection property of αi,
8.for each causal net ni, with e∈ei,βi(e) =tandt′⊆tholds that
|∪
t′∈t′(t′n•)∩n•t| ≥∑
e′∈ei,βi(e′)∈t′|e′ni•∩ni•e|. the proof for this property
is similar to the previous one.
9.for each causal net niand any segment ( c′
i, ein, eout) ofniholds that⊎
e∈ein(
βi(e)n•)
=⊎
e∈eout(n•βi(e))
. this property relates to soundness. ifone set of transitions produces tokens then these tokens will be consumed by
another set of transitions (i.e. no tokens are “left behind” in the execution
of a sound wf-net). the only exception is the transition that produces a
token in the output place, but that transition cannot produce any tokens in
any other place. therefore, in each run, the input events of a segment will
enable the output events of that segment.
⊓ ⊔
the nlc algorithm takes a set of causal nets without condition labels as a
starting point. from these nets, an aggregation class of wf-nets is deﬁned. in
this section, we have formally proven that every element of the aggregation class
indeed is capable of constructing the causal nets used as input. furthermore, if
the runs were generated from some sound wf-net, then the wf-net itself is in
that aggregation class.
6 conclusion
in this paper, we looked at process mining from a new perspective. instead
of starting with a set of traces, we started with runs which constitute partial
orders on events. we presented three algorithms to generate a petri net from
these runs. the ﬁrst algorithm assumes that, for each run, all labels of both
conditions and events are known. the second algorithm relaxes this by assuming
that some transitions can have the same label (i.e. duplicate labels are allowed in
the system net). this algorithm can also be used if only condition/place-labels
were recorded. finally, we provided an algorithm that does not require condition
labels, i.e. the event/transition labels are known, the condition/place labels are
unknown and duplicate transition labels are not allowed.
the results presented in this paper hold for a subclass of petri nets, the
so-called wf-nets. however, the ﬁrst two algorithms presented here can easily
be generalized to be applicable to any petri net. for the third algorithm this
can also be done, however, explicit knowledge about how the initial markings of
various runs relate is needed. when taking a set of runs as a starting point, this
knowledge is not present in the general case.
references
1.w.m.p. van der aalst. workﬂow veriﬁcation: finding control-flow errors using
petri-net-based techniques. in w.m.p. van der aalst, j. desel, and a. oberweis,
editors, business process management: models, techniques, and empirical stud-
ies, volume 1806 of lecture notes in computer science , pages 161–183. springer-
verlag, berlin, 2000.
2.w.m.p. van der aalst. process mining - discovery, conformance and enhance-
ment of business processes . springer, 2011.
3.w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. genetic
process mining. in proceedings of the 26th international conference on applica-
tions and theory of petri nets , volume 3536 of lecture notes in computer science ,
pages 48 – 69. springer-verlag, berlin, 2005.4.w.m.p. van der aalst, k.m. van hee, a.h.m. ter hofstede, n. sidorova, h.m.w.
verbeek, m. voorhoeve, and m.t. wynn. soundness of workﬂow nets: classiﬁ-
cation, decidability, and analysis. formal aspects of computing , 23(3):333–363,
2011.
5.w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters, b.f. van dongen, a.k.
alves de medeiros, m. song, and h.m.w. verbeek. business process mining: an
industrial application. information systems , 32(5):713–732, 2007.
6.w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
7.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
8.r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
9.e. badouel and ph. darondeau. theory of regions. in w. reisig and g. rozenberg,
editors, lectures on petri nets part 1 (basic models) , volume 1491 of lecture notes
in computer science , pages 529–586. springer-verlag, berlin, 1998.
10.r. bergenthum, j. desel, r. l., and s. mauser. synthesis of petri nets from finite
partial languages. fundamenta informatica , 88(1):437–468, 2008.
11.r. bergenthum, j. desel, s. mauser, and r. lorenz. synthesis of petri nets from
term based representations of inﬁnite partial languages. fundamenta informat-
ica, 95(1):187–217, 2009.
12.j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
13.a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275–301,
1998.
14.j. desel. validation of process models by construction of process nets. in w.m.p.
van der aalst, j. desel, and a. oberweis, editors, business process management:
models, techniques, and empirical studies , volume 1806 of lecture notes in com-
puter science , pages 110–128. springer-verlag, berlin, 2000.
15.j. desel and t. erwin. hybrid speciﬁcations: looking at workﬂows from a run-time
perspective. computer systems science and engineering , 5:291–302, 2000.
16.j. desel and w. reisig. the synthesis problem of petri nets. acta informatica ,
33:297–315, 1996.
17.b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors,
conceptual modeling - er 2004 , volume 3288 of lecture notes in computer sci-
ence, pages 362–376. springer-verlag, berlin, 2004.
18.b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: aggre-
gating instance graphs into epcs and petri nets. in pncwb 2005 workshop ,
pages 35–58, 2005.
19.a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315–368, 1989.
20.g. greco, a. guzzo, l. pontieri, and d. sacc` a. discovering expressive process
models by clustering log traces. ieee transaction on knowledge and data
engineering , 18(8):1010–1027, 2006.21.d. harel, h. kugler, and a. pnueli. synthesis revisited: generating statechart
models from scenario-based requirements. in h.j. kreowski, u. montanari,
f. orejas, g. rozenberg, and g. taentzer, editors, formal methods in software
and systems modeling , volume 3393 of lecture notes in computer science , pages
309–324. springer, 2005.
22.j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
23.j. herbst and d. karagiannis. workﬂow mining with inwolve. computers in
industry , 53(3):245–264, 2004.
24.r. lorenz and g. juh´ as. towards synthesis of petri nets from scenarios. in
s. donatelli and p.s. thiagarajan, editors, icatpn , volume 4024 of lecture notes
in computer science , pages 302–321. springer, 2006.
25.a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245–304, 2007.
26.a. roychoudhury and p.s thiagarajan. communicating transaction processes. in
j. lilius, f. balarin, and r. machado, editors, proceedings of third international
conference on application of concurrency to system design (acsd2003) , pages
157–166. ieee computer society, 2003.
27.e. smith. on net systems generated by process foldings. in g. rozenberg,
editor, advances in petri nets , volume 524 of lecture notes in computer science ,
pages 253–276. springer-verlag, berlin, 1991.
28.a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.
29.j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. fundamenta informaticae ,
94:387–412, 2010.