translating message sequence charts to other
process languages using process mining
kristian bisgaard lassen1, boudewijn f. van dongen2, and wil m.p. van der aalst2
1department of computer science, university of aarhus,
it-parken, aabogade 34, dk-8200 aarhus n, denmark.
k.b.lassen@daimi.au.dk
2department of information systems, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fb.f.v.dongen,w.m.p.v.d.aalst g@tue.nl
abstract. message sequence charts (mscs) are a well known language for speci-
fying scenarios that describe how di®erent actors (e.g., system components, people,
or organizations) interact. mscs are often used as a starting point for software
analysts to discuss the behavior of a system with di®erent stakeholders. often
such discussions lead to more complete behavioral models described by e.g. event-
driven process chains (epcs), uml activity diagrams, bpmn models, petri nets,
etc. the contribution of this paper is to present a method that uses process min-
ing to translate a set of mscs that represent example scenarios into a complete
process model, e.g., represented in terms of epcs or petri nets. our approach takes
mscs and translates them into a special kind event logs. unlike all known process
mining techniques, we use a new approach that uses event logs containing explicit
causal dependencies. this allows us to discover high-quality process models. the
approach has been implemented in the process mining framework prom.
1 introduction
message sequence charts (mscs) [28, 23] are a well-known language to specify communi-
cation between processes, and are supported by many tools, standards, and approaches,
e.g., the object management group (omg) has decided to adapt a variant of them called
sequence charts in the uml notational framework [18]. in this paper we look at mscs
that are restricted to only using processes and messages. we do not consider structured
language features such as choice and iteration that the uml 2.0 standard introduces,
i.e., we consider basic mscs rather than high-level mscs. [25] show how structured con-
structs such as parallels routing, iteration, choice, etc. in uml 2.0 sequence charts, can
be unfolded to the mscs we use in this paper. the unfolded mscs can be mined using
the techniques we present in this paper.
when developing a system it is often useful to describe requirements for the system by
mscs were each msc depicts a single scenario. for example, we have been involved in a
project were many mscs were generated by the sta® at a hospital and software developers
to capture the requirements for a new pervasive health care system [27]. the strength of
mscs is that they depict a single scenario using an intuitive notation. therefore, they
are easy to understand. however, this strength can at the same time also be considered aweakness. how does one consolidate several scenarios from the same system? this is far
from trivial. for example, two mscs may be similar up to a certain point, after which they
diverge. this point corresponds to a choice if we look at them in combination, but this is
not clear just by looking at one of the mscs. synchronization points are not discovered
just by looking at one diagram, one would again have to consolidate all mscs. note that
many behavioral patterns can be described implicitly when using multiple mscs.
considerable work has been done on the synthesis of scenario-based models such as
mscs (see [26] and the related work section for an overview). existing approaches are
very di®erent and typically have problems dealing with concurrency. moreover, the ma-
jority of approaches uses explicit annotations to \glue" mscs together in a single model.
for example, high-level mscs are being used [17, 29, 30] or there are \precharts", \state
conditions" or similar concepts to explicitly relate mscs [12, 21, 22]. other problems are
related to performance, implied scenarios (i.e., the model allows for more behavior than
what has actually been observed), and consistency (e.g., the synthesized model contains
deadlocks) [6, 7]. therefore, it is interesting to apply ideas from process mining [2{4, 10,
13, 15, 24] to the synthesis of mscs.
the aim of the approach presented in this paper is to generate process models -
represented using languages such as event-driven process chains (epcs), petri nets,
yawl [1], or even bpel [8] - based on a set of mscs. the large variety of languages
that we can use to represent models is a result of using our process mining framework
prom [16, 31] which supports a wide variety of process modeling languages (petri nets,
epcs, yawl, bpel, transition systems, heuristics nets, etc.). using prom the process
mining results can be mapped on any of these languages.
this paper is organized as follows. first we provide some background information
required to understand our approach (section 2). then, in section 3, we describe how
we actually generate the behavioral models. section 4 presents an example of an online
bookstore where we apply our method and section 5 discusses related work. section 6
concludes the paper.
2 preliminaries
2.1 message sequence charts
as mentioned in the introduction, several variants of msc exists, such as uml 2.0 se-
quence charts [18] and live sequence charts [12]. in this paper we focus on mscs with
only two syntactical constructs, i.e., processes and messages. processes can be used to
denote a wide variety of entities ranging from software components and web services to
people and organizations. a message is passed from one process to the other and therefore
each message has a, (not necessarily di®erent) sender and receiver process. a process has
a lifeline representing a sequence of messages that the process is the sender or receiver of.
in figure 1 we show two examples of the mscs that we consider. each of them
consists of three processes, process a ,process b , and process c . these processes are
represented by their name and their lifelines. these lifelines are connected to each other
by messages, which are represented by labelled arrows. internal events (i.e., messages
where the sender and receiver are the same process) are represented by a box on the
lifeline of the corresponding process, again with a label.fig. 1. two example mscs of three processes communicating.
table 1. an event log (audit trail).
case id activity id originator case id activity id originator
case 1 activity a john case 5 activity a sue
case 2 activity a john case 4 activity c carol
case 3 activity a sue case 1 activity d pete
case 3 activity b carol case 3 activity c sue
case 1 activity b mike case 3 activity d pete
case 1 activity c john case 4 activity b sue
case 2 activity c mike case 5 activity e clare
case 4 activity a sue case 5 activity d clare
case 2 activity b john case 4 activity d pete
case 2 activity d pete
the process shown in both mscs of figure 1 starts by the sending of message aby
process a . then message ais received by process b . next process a sends a message
atoprocess c . the overall process continues like that until process c sends a message
cthat is received by process a and process b sends a message bthat is received by
process a .
2.2 process mining
the goal of process mining, or more speci¯cally control °ow discovery is to extract in-
formation about processes from transaction logs, such that we can discover the control
°ow of a process in a model. process mining always starts from an event log that con-
tains events such that (i) each event refers to an activity (i.e., a well-de¯ned step in the
process), (ii) each event refers to a case(i.e., a process instance) and (iii) events may have
atimestamp implying a total order on them. table 1 shows an example of a log involving
19 events and 5 activities. this event log happens to also contain information about the
people executing the corresponding activities (cf. the orginator ¯eld table 1). often logs
also contain information about data associated to events (e.g., message content).
figure 2 shows some examples of process mining results that can be obtained using
the log of table 1. this ¯gure clearly shows that process mining is not limited to control°ow discovery, i.e., the roles of the actors in the process, as well as their social relations
can be discovered as well. however, in this paper, we only focus on the control °ow, which
in figure 2 is shown as a petri net.
although in this paper we focus on control °ow discovery, we make a fundamentally
di®erent assumption with regard to the process log, i.e., we say that events are no longer
totally ordered . instead, we consider logs, where events are partially ordered , since message
sequence charts can be considered as partial orders on events (i.e., each event being the
sending and receiving of a message). for this, we had to make changes to the very core
of the prom framework , which we introduce in the next section.
2.3 the prom framework
the (pro)cess (m)ining framework prom has been developed as a completely plug-able
environment for process mining and related topics. it can be extended by simply adding
plugins, i.e., there is no need to know or to recompile the source code. currently, more
than 130 plugins have been added. for more information on the prom framework, we
refer to [16, 31] and the web site www.processmining.org. the most interesting plugins
in the context of this paper are the mining plugins, that focus on control °ow discovery.
however, besides mining plugins the architecture of prom allows for four more types of
plugins:
mining plugins which implement some mining algorithm, e.g., mining algorithms that
construct a petri net based on some event log.
export plugins which implement some \save as" functionality for some objects (such
as graphs). for example, there are plugins to save epcs, petri nets, spreadsheets,
etc.
import plugins which implement an \open" functionality for exported objects, e.g.,
load instance-epcs from aris ppm.
aand
-splitb
cand
-join
d
e
(a) the control-flow structure expressed in terms of a petri net.
(b) the organizational structure expressed in
terms of a activity-role-performer diagram.john sue mike carol pete clarerole x role y role zjohn sue
mike
carol peteclare
(c) a sociogram based on transfer of work.
fig. 2. some mining results from di®erent perspectives, based on the log of table 1.fig. 3. mxml schema de¯nition.
analysis plugins which typically implement some property analysis on some mining
result. for example, for petri nets there is a plugin which constructs place invariants,
transition invariants, and a coverability graph.
conversion plugins which implement conversions between di®erent data formats, e.g.,
from epcs to petri nets and from petri nets to yawl and bpel.
prom uses a standard log format, named mxml as described in [14] for storing
process logs, such as the one in table 1. in the context of the promimport framework
[20], several adaptors have been developed to map logs from di®erent information systems
onto mxml (e.g., sta®ware, flower, ms exchange, mqseries, etc.). figure 3 shows
the hierarchical structure of mxml. the format is xml-based and is de¯ned by an xml
schema (cf. www.processmining.org).
in this paper, we show that we can use the prom framework to analyze mscs. how-
ever, to take full advantage of the fact that mscs describe a partial order of events
(something typically not found in transaction logs), we had to modify the framework in
two ways, which we describe in detail in the next section.
the prom framework can be downloaded from www.processmining.org and can be
freely used (it is open source software). the reader is invited to experiment with the
plug-in reported in this paper and apply it to mscs expressed in the omg's xmi format.
3 generating process models from mscs
this section presents our approach of generating a process model from a set of mscs. to
do so, we have to construct a mapping from mscs to transaction logs, i.e., we ¯x whichpart of an msc refers to an mxml process instance, an mxml audit trail entry, an
mxml work°ow model element, and the rest of the elements in mxml.
3.1 mscs to mxml
in the ¯rst phase of our approach, we take a set of mscs, all describing the same system
and we translate them to one mxml log ¯le. we have chosen to use xmi [19], the object
management group (omg) standard interchange format, as our input format for mscs,
which enabled us to implement the translation in a plugin for the promimport framework
[20].
in this promimport plugin, each msc is translated into one mxml process instance.
the reason for this is simple. since each msc describes one possible execution scenario
of the system, it corresponds nicely to the notion of a case also referred to as process
instance.
furthermore, within each msc, all messages are translated into twoaudit trail entries;
one referring to the sending of the message and one referring to the receiving of the
message. to accomplish this, we make sure that both audit trail entries refer to the same
work°ow model element (i.e., the message). the audit trail entry that refers to the sending
of the message has event type start . receiving audit trail entries have type complete .
to incorporate the information about processes in mxml, we use the originator ¯eld
of each audit trail entry in a trivial way. if process a sends message atoprocess b , then
the originator ¯eld of the audit trail entry relating to the sending of the message equals
process a and the originator ¯eld of the audit trail entry relating to the receiving of the
message equals process b . notice, we do not consider instances of the same process. if
the same process occur as several instances in the msc, the originator ¯eld remains the
same; i.e. the name of the process type and not the instance name.
finally, we add data to each audit trail entry, such that each audit trail entry has
a unique label within a process instance. then, using these labels, we store the set of
predecessors and successors that we have observed in the msc. consider for example
the msc of figure 1, where the ¯rst three events are: (1) the sending of message aby
process a , (2) the receiving of message abyprocess b and (3) the sending of message
abyprocess a . these events are represented in mxml by the audit trail entries in
figure 4.
the relations between audit trail entries stored in the data part of mxml are built
in a trivial way. if an audit trial entry refers to the sending of a message, the preset of
that audit trail entry is the event that happened before it on the lifeline of that process.
if the audit trail entry refers to the receiving of a message, the preset alsocontains the
audit trail entry referring to the sending of the same message. the postsets are build in
a similar fashion.
up to this point, the prom framework ordinarily order events in a process log based
on two criteria, namely the timestamp of each audit trail entry and/or their relative
position in the mxml ¯le. therefore, we extend the prom framework to store and read
the partial order we represented in the data elements ate_id ,ate_post andate_pre (see
figure 4). furthermore, to indicate that a process instance is a partial order, we added a
data element ispartialorder to the data part of each process instance, allowing us to
mix partial and linear orders in one log ¯le.<processinstance id="id-instance-0">
<data>
<attribute name="ispartialorder">true</attribute>
</data>
<audittrailentry>
<data>
<attribute name="ate_id">id1</attribute>
<attribute name="ate_post">id2,id3</attribute>
<attribute name="ate_pre"></attribute>
</data>
<workflowmodelelement>a
</workflowmodelelement>
<eventtype>start</eventtype>
<originator>process a</originator>
</audittrailentry>
<audittrailentry>
<data>
<attribute name="ate_id">id2</attribute>
<attribute name="ate_post">id6</attribute>
<attribute name="ate_pre">id1</attribute>
</data>
<workflowmodelelement>a</workflowmodelelement>
<eventtype>complete</eventtype>
<originator>process c</originator>
</audittrailentry>
<audittrailentry>
<data>
<attribute name="ate_id">id3</attribute>
<attribute name="ate_post">id4,id5</attribute>
<attribute name="ate_pre">id1</attribute>
</data>
<workflowmodelelement>a</workflowmodelelement>
<eventtype>start</eventtype>
<originator>process a</originator>
</audittrailentry>
fig. 4. example mxml log with par-
tial order stored in attributes.
fig. 5. the mxml snapshot of figure 4 shown in prom.
fig. 6. an msc that leads to problems in the aggrega-
tion.
figure 4 shows a part of an mxml ¯le illustrating the partial order extension. it
contains the ispartialorder °ag for the process instance and the identi¯ers and pre-
and postsets for the audit trail entries. figure 5 shows the same log in prom, where it is
clearly represented as a partial order.
since the prom framework is now capable of reading partial orders from mxml ¯les,
we need new plugins for mining partial orders. fortunately, we can build on the ideas and
plugins introduced in [13] and [15].
3.2 process discovery on partial orders
the second and ¯nal phase of our approach is to mine a process model using the mxml
document that describes the example scenarios, i.e., partially ordered example behaviors
of the system. furthermore, we are interested in constructing models that describe thebehavior of each individual process present in the mscs. to make a model from the
mscs, we extend an already implemented mining algorithm in prom.
the multi phase mining plugin, which was introduced in [13] and [15] is an implemen-
tation of a multi-stage algorithm. the multi phase approach presented in these papers,
basically consist of the following phases, when executed on a totally ordered log ¯le:
1.first the whole log is analyzed and causal dependencies between event are determined
in a way similar as presented in [3].
2.then, each process instance is translated from a linear order of events into a partial
order, following the discovered causal dependencies.
3.finally, these partial orders are aggregated and translated into some model, such as
an epc or petri net.
in the context of our process discovery problem, this algorithm seems to ¯t perfectly:
we can just skip the ¯rst two phases and directly aggregate the partial orders that we
have as input. however, there are two important requirements:
partial orders need to be minimal the aggregation algorithm presented in [15] as-
sumes that the partial orders used as input are minimal, i.e., there are no two paths be-
tween two nodes. this requirement is clearly not met by our mscs, i.e., if process a
sends message atoprocess b and then gets message bback from process b , i.e.,
there are two paths between the audit trail entry referring to the sending message
aand the one referring to the receiving of message b(see figure 1). therefore, we
apply the concept of transitive reduction [5] to each msc, before aggregating them1.
input and output sets are uniquely labeled the second requirement for our ag-
gregation algorithm is that no single audit trail entry is preceded or succeeded by
two audit trail entries with the same label twice. consider figure 6, where the start
event of message abyprocess b is followed by two complete events of the same
message, i.e. the one coming in from process a and the one going to process c .
if we make sure to avoid such a situation, we can be certain that the aggregation
algorithm produces a correct result.
before we present the aggregation algorithm, we ¯rst consider the abilities of prom
to ¯lter logs and we show how we adapted this ¯ltering procedure for partially ordered
log ¯les.
3.3 msc projection
although the mscs can be used directly in process mining, our experience is that very
often, people are not interested in the overall process, but only in parts thereof. for
this purpose, prom is equipped with log ¯lters, which look at each process instance and
¯lter out not required information. for example, to get the ¯rst idea about a process, we
typically only consider complete events. this process, of removing audit trail entries from
each process instance is called projection .
1the idea of transitive reduction is that an edge between two nodes in a graph is removed
if there is a di®erent path from the source node to the target node. since partial orders are
a-cyclic, the transitive reduction is unique [5].log ¯lters typically remove audit trail entries that are not of interest. if audit trail
entries are totally ordered, then this is easy to do. in our case, however, audit trail entries
are partially ordered, in which case it is less trivial to remove audit trail entries. in fact,
audit trail entries can only be removed if the partial order is ¯rst transitively closed .
for this purpose, we implemented two log ¯lters in prom. the ¯rst one transitively
closed the partial order. then already existing ¯lters do their ¯ltering and afterward
our second plugin transitively reduces the partial order2. in section 4, we show the use
of these ¯lters in practice, however, we ¯rst introduce the aggregation algorithm and a
translation algorithm.
3.4 aggregation and translation
under the assumption that our mxml ¯le contains information about partial orders,
we can use the partial order aggregator to generate a so-called aggregation graph. this
partial order aggregator is a new mining plugin in the prom framework, which accepts
an mxml ¯le, but it ignores each process instance for which the ispartialorder °ag is
not set to true. the plugin aggregates the partial orders into an aggregation graph .
the aggregation graph that results from this procedure is described in detail in [15].
in essence, an aggregation graph is a straightforward sum over a set of partial orders,
with two unique nodes tsandtfin such a way that tsis the only source node and tfis
the only sink node. the labels of nodes and edges represent the number of times it was
visited in some partial order. figure 7 shows the result, after aggregating the two partial
order generated from the mscs in figure 1. note that we ¯rst projected the mscs onto
the audit trail entries where process c is described in the originator ¯eld.
finally, each of these aggregation graphs can be translated into an epc, i.e., into a
human-readable format. this is where the requirements that the mscs are minimal and
that the in- and output sets are uniquely labeled are important, since the translation
depends on the labels of nodes and edges. in short, if a node has the same label as each of
its input edges, it is an and-join, if a node has a label that equals the sum of the labels
2due to space limitations, we cannot provide proofs that the transitive reduction of the tran-
sitive closure is isomorphic to the transitive closure of the original. the idea is that, any edge
in the original, but not in the reduction, is a combination of edges in the reduction. hence
those edges are in the transitive closure of the reduction, which is enough to show that the
transitive closures are isomorphic.
2
42acomplete 2cstart
4
ccomplete 4 22tf
22
ts
tsacomplete 
status 
change to 
cstart cstart status 
change to 
ccomplete ccomplete tf
xx
fig. 7. the aggregation graph and epc of process c after aggregating both mscs of figure 1.of all input edges it is an xor-join and otherwise an or-join and symmetrically for the
split type3.
3.5 comments about the mined models
process mining di®ers from, for example, the theory of regions [9], in the sense that
process mining start from a ¯nite, but presumably incomplete set of executions. from
there the aim is to discover a model that describe at least the log that is considered.
the partial order aggregator described in section 3.2, has this property, i.e., the only
guarantee, is that the input set of partial orders is a subset of the possible executions of
the mined model.
the essence of process mining is to discover models with a good balance between
being too general (where anything can happen in any order) or too speci¯c (where, e.g.,
the instances are put next to each other, and a choice node put in front selecting one of
them).
4 bookstore example
in this section we present an application of our process mining approach to a system
modelled by mscs. the system that we describe is an online bookstore. the system
contains four msc processes whose behavior we give an overview of here:
customer the person that wants to buy a book.
bookstore handles the customer request to buy a book. the virtual bookstore always
contacts a publisher to see if it can handle the order. if the bookstore cannot ¯nd a
suitable publisher, the customer's order is rejected. if the bookstore ¯nds a publisher,
a shipper is selected and the book is shipped. during shipping, the bookstore sends
a bill to the customer.
publisher may or may not have the book that the customer wants to buy.
shipper may or may not be able to carry out the shipping order.
we start out with some message sequence charts. in figure 8 we see two examples
where the customer orders a book at the bookstore. the bookstore then tries to get the
book from di®erent publishers (1 in the left hand ¯gure, 2 in the right hand ¯gure) until
it gives up and tells the customer that the order cannot be ful¯lled. note that in both
cases, the shipper does not to anything.
we started from 10 of such mscs, containing 23 di®erent messages and we translated
them into mxml using the plugin for the promimport tool we developed. then, we
used the process mining technique described in section 3 to obtain process models for
the bookstore, the publisher, the shipper and the customer, by projecting each process
instance on the corresponding audit trail entries.
due to space limitations, we can not show the resulting models in detail. hence, we
limit ourselves to presenting a screenshot of prom that shows some models discovered
3if one of the two requirements of the input is violated, these translation rules may not be
valid.based on the 10 mscs. the three process models depicted in figure 9 are the result of
projecting the log onto the bookstore, i.e., we only took into account the audit trail entries
that had the bookstore as an originator. the petri net at the top of the screenshot shows
the whole bookstore process discovered using the approach described in this paper. as
indicated before, prom can transform models from one notation to another, e.g., mapping
petri nets onto epcs, yawl, bpel, etc. the epc in the bottom-right corner and the
yawl model in the bottom-left corner, show only a part of the process. the epc shows
the part of the petri net in the small oval and the yawl model the part in the big oval.
furthermore, a dialog is shown resulting from an analysis of the epc model. prom epc
analysis plugin reports that the epc is a correct epc, i.e., it contains no deadlocks or
livelocks.
5 related work
we discuss related work in the two research ¯elds our work joins, namely process mining
andsynthesis of scenario based models .
process mining. since the mid-nineties several groups have been working on techniques
for process mining, i.e., discovering process models based on observed events. in [2] an
overview is given of the early work in this domain. the idea to apply process mining in the
context of work°ow management systems was introduced in [4]. cook et al. investigated
similar issues in the context of software engineering processes [10]. herbst [24] was one of
the ¯rst to tackle more complicated processes, e.g., processes containing duplicate tasks.
most of the approaches have problems dealing with concurrency. the ®algorithm [3] is
an example of a simple technique that takes concurrency as a staring point. however, this
fig. 8. two mscs describing scenarios in our bookstore example.fig. 9. prom showing the mined bookstore process in di®erent languages.
simple algorithm has problems dealing with complicated routing constructs and noise (like
most of the other approaches described in literature). approaches based on heuristics or
genetic algorithms can deal with noise [32]. moreover, advanced techniques, e.g., based
on the theory regions [11], can mine processes containing complex mixtures of choice
and synchronization. this paper uses a process mining approach based on the technique
presented in [13, 15]. as described in this paper, the approach has been adapted to deal
with the explicit causal dependencies in scenario-based representations such as mscs. the
results presented in this paper are fully implemented in prom (www.processmining.org).
prom serves as a testbed for our process mining research. most of the leading process
mining approaches have been implemented in prom. through the extensions presented
in this paper, these approaches can now be applied to the synthesis of scenario-based
models.
synthesis of scenario-based models. this paper considers a speci¯c format for represent-
ing scenarios, i.e., message sequence charts (mscs) [23, 28]. however, many variants and
dialects are available, e.g., the itu standard for mscs, uml sequence diagrams (sds),
communication diagrams (cds), interaction overview diagrams (iods), and harel's
live sequence charts (lscs), just to name a few. in their basic form, these notations
model individual scenarios, i.e., a particular example behavior of the process/system and
not the full behavior. however, many of the approaches have been extended with com-
position constructs to model a set of example behaviors or even the full process/system
behavior. some authors use the term \high-level mscs" to refer to mscs which are com-
posed using operators such as \sequence", \iteration", \parallel composition", \choice",etc. we consider these high-level mscs as less appropriate, i.e., if one just wants to model
example behavior, then the basic mscs are more suitable. however, if one wants to model
the full system behavior, traditional techniques such uml activity diagrams, state charts,
bpmn, epcs, petri-net based languages, etc. seem more appropriate.
many researchers have been working on the synthesis of scenario-based models, in
particular the generation of process models from di®erent variants of mscs. in [26] an
excellent overview of 21 approaches is given. this overview shows that existing approaches
are very di®erent and typically have problems dealing with concurrency. other problems
are related to performance, implied scenarios (i.e., the model allows for more behav-
ior than what has actually been observed), and consistency (e.g., the synthesized model
contains deadlocks). it is impossible to give an overview of all approaches reported in
literature. therefore, we only describe some representative examples. harel et al. [12, 21,
22] have worked on the notion of live sequence charts (lscs). the primary goal has
been to turn lscs (\play-in") into an executable system (\play out") without necessar-
ily constructing an explicit process model. however, in [22] the synthesis of lscs into
statecharts is described. note that this approach is very di®erent from the notion of syn-
thesis used in this paper, i.e., through the so-called prechart of lscs the links between
the various mscs are made explicit. hence there is no real synthesis in the sense of de-
riving a process model from example scenarios. this holds for many other approaches,
e.g., several authors assume \state conditions" or similar concepts to make the linking
of mscs explicit [17, 30]. in a way, sets of scenarios are explicitly encoded in high-level
mscs. however, there are also approaches that really derive process models from mscs
without some explicit a-priori encoding. an example is the work by alur et al. [6, 7].
in [6, 7] two problems are discussed: the inference of additional (possibly undesirable)
implied behavior and the construction of incorrect models (e.g., models having potential
deadlocks). using di®erent algorithms implemented in prom we can vary the degree of
implied behavior and balance between under-¯tting and over-¯tting. for example, the
plugins in prom based on the theory of regions [11] can construct process models without
any implied behavior. the plugin introduced in this paper allows for additional implied
behavior (this is the e®ect we aim at). however, the resulting model is always correct,
i.e., it does not have deadlocks and it is able to reproduce the observed mscs. finally,
we would like to mention the approach described in [29]. like many other authors, these
authors provide formal semantics of mscs in terms of petri nets. the authors also syn-
thesize mscs into an overall petri net. however, they assume that there is a petri net
gluing all mscs together, i.e., sets of scenarios are explicitly encoded in high-level mscs.
to conclude this section, we would like to point out that, unlike other methods, we
are able to generate di®erent types of process models, e.g., epcs, petri nets, bpel, or
yawl. most of the approaches described in literature can only generate statecharts or
basic transition systems.
6 conclusion
this paper presented a new approach to synthesize a process model from mscs. the
approach uses ideas from the process mining community and adapts these to incorporate
the explicit causal dependencies present in mscs. the approach has been fully imple-mented in prom, by extending the mxml language with the notion of partial orders, and
developing an import plug-in to convert xmi to mxml, and a partial order aggregator
to generate the process models from the mxml.
we showed how an existing process mining algorithm can be adapted to exploit causal
dependencies and that the discovered model can be represented in di®erent notations, e.g.,
epcs, petri nets, bpel, and yawl. moreover, the ideas are not limited to mscs and can
be applied to other event logs containing explicit causal dependencies, e.g., collaboration
diagrams, groupware products, document management systems, case handling systems,
product data management systems, etc.
references
1.w.m.p. van der aalst and a.h.m. ter hofstede. yawl: yet another work°ow language.
information systems , 30(4):245{275, 2005.
2.w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and a.j.m.m.
weijters. work°ow mining: a survey of issues and approaches. data and knowledge
engineering , 47(2):237{267, 2003.
3.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining: discovering
process models from event logs. ieee transactions on knowledge and data engineering ,
16(9):1128{1142, 2004.
4.r. agrawal, d. gunopulos, and f. leymann. mining process models from work°ow logs.
insixth international conference on extending database technology , pages 469{483, 1998.
5.a. aho, m. garey, and j. ullman. the transitive reduction of a directed graph. siam
journal on computing , 1(2):131{137, 1972.
6.r. alur, k. etessami, and m. yannakakis. inference of message sequence charts. ieee
transactions on software engineering , 29(7):623{633, 2003.
7.r. alur, k. etessami, and m. yannakakis. realizability and veri¯cation of msc graphs.
theoretical computer science , 331(1):97{114, 2005.
8.t. andrews, f. curbera, h. dholakia, y. goland, j. klein, f. leymann, k. liu, d. roller,
d. smith, s. thatte, i. trickovic, and s. weerawarana. business process execution language
for web services, version 1.1. standards proposal by bea systems, international business
machines corporation, and microsoft corporation, 2003.
9.eric badouel and philippe darondeau. theory of regions. lecture notes in computer
science: lectures on petri nets i: basic models , 1491:529{586, 1998.
10.j.e. cook and a.l. wolf. discovering models of software processes from event-based data.
acm transactions on software engineering and methodology , 7(3):215{249, 1998.
11.j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets from finite
transition systems. ieee transactions on computers , 47(8):859{882, august 1998.
12.w. damm and d. harel. lcss: breathing life into message sequence charts. formal
methods in system design , 19(1):45{80, 2001.
13.b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building instance
graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, international
conference on conceptual modeling (er 2004) , volume 3288 of lecture notes in computer
science , pages 362{376. springer-verlag, berlin, 2004.
14.b.f. van dongen and w.m.p. van der aalst. a meta model for process mining data. in
proceedings of the caise workshops , volume 2, pages 309{320. feup, 2005.
15.b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: aggregating
instance graphs into epcs and petri nets. in pncwb 2005 workshop , pages 35{58, 2005.16.b.f. van dongen, a.k.a. de medeiros, h.m.w. verbeek, a.j.m.m. weijters, and w.m.p. van
der aalst. the prom framework: a new era in process mining tool support. in application
and theory of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
444{454. springer-verlag, berlin, 2005.
17.h. foster, s. uchitel, j. magee, and j. kramer. tool support for model-based engineering
of web service compositions. in proceedings of 2005 ieee international conference on
web services (icws 2005) , pages 95{102, orlando, fl, usa, july 2005. ieee computer
society.
18.object management group. omg uni¯ed modeling language 2.0 . omg,
http://www.omg.com/uml/, 2005.
19.object management group. xml meta interchange.
http://www.omg.org/technology/documents/formal/xmi.htm, 2006.
20.christian w. gä unther. promimport. http://promimport.sourceforge.net, 2006.
21.d. harel. from play-in scenarios to code: an achievable dream. computer , 34(1):53{60,
2001.
22.d. harel, h. kugler, and a. pnueli. synthesis revisited: generating statechart models
from scenario-based requirements. in formal methods in software and systems modeling ,
volume 3393 of lecture notes in computer science , pages 309{324. springer-verlag, berlin,
2005.
23.d. harel and p.s. thiagarajan. message sequence charts. in uml for real: design of
embedded real-time systems , pages 77{105, norwell, ma, usa, 2003. kluwer academic
publishers.
24.j. herbst. a machine learning approach to work°ow management. in proceedings 11th
european conference on machine learning , volume 1810 of lecture notes in computer
science , pages 183{194. springer-verlag, berlin, 2000.
25.kristian bisgaard lassen. translating uml 2.0 sequence charts into coloured petri net
using process mining. technical report, department of computer science at the university
of aarhus, 2007.
26.h. liang, j. dingel, and z. diskin. a comparative survey of scenario-based to state-
based model synthesis approaches. in proceedings of the 2006 international workshop on
scenarios and state machines: models, algorithms, and tools (scesm06) , pages 5{12, new
york, ny, usa, 2006. acm press.
27.r.j. machado, k.b. lassen, s. oliveira, m. couto, and p. pinto. execution of uml models
with cpn tools for work°ow requirements validation. in proc. of sixth cpn workshop ,
volume pb-576 of daimi , pages 231{250, 2005.
28.e. rudolph, j. grabowski, and p. graubmann. tutorial on message sequence charts.
computer networks and isdn systems , 28(12):1629{1641, 1996.
29.m. sgroi, a. kondratyev, y. watanabe, l. lavagno, and a. sangiovanni-vincentelli. syn-
thesis of petri nets from message sequence charts speci¯cations for protocol design. in
design, analysis and simulation of distributed systems symposium (dasd '04) , pages 193{
199, washington dc, usa, april 2004.
30.s. uchitel, j. kramer, and j. magee. synthesis of behavioral models from scenarios. ieee
transactions on software engineering , 29(2):99{115, 2003.
31.h.m.w. verbeek, b.f. van dongen, j. mendling, and w.m.p. van der aalst. interoperability
in the prom framework. in emoi workshop , 2006.
32.a.j.m.m. weijters and w.m.p. van der aalst. rediscovering work°ow models from event-
based data using little thumb. integrated computer-aided engineering , 10(2):151{162,
2003.