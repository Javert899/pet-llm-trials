business process conï¬guration in the cloud:
how to support and analyze multi-tenant processes?
w.m.p. van der aalst
department of mathematics and computer science, eindhoven university of technology
eindhoven, the netherlands
www: vdaalst.com
abstract â€”lionâ€™s share of cloud research has been focusing
on performance related problems. however, cloud computingwill also change the way in which business processes are man-aged and supported, e.g., more and more organizations willbe sharing common processes. in the classical setting, whereproduct software is used, different organizations can makead-hoc customizations to let the system ï¬t their needs. this isundesirable, especially when multiple organizations share acloud infrastructure. conï¬gurable process models enable the
sharing of common processes among different organizations
in a controlled manner. this paper discusses challengesand opportunities related to business process conï¬guration.causal nets (c-nets) are proposed as a new formalism to
deal with these challenges, e.g., merging variants into aconï¬gurable model is supported by a simple union operator.c-nets also provide a good representational bias for process
mining , i.e., process discovery and conformance checking
based on event logs. in the context of cloud computing,we focus on the application of c-nets to cross-organizational
process mining.
keywords -conï¬gurable process models; cross-
organizational process mining; cloud computing; causalnets
i. i ntroduction
the interest for cloud computing is rapidly growing
both in industry and research communities. cloud com-
puting focuses on the sharing of it resources to achievesigniï¬cant cost reductions. in this paper, we do not focus
on the infrastructure level, but at the level of business pro-
cesses shared among different parties. we aim to supportfamilies of processes for different organizations using the
likes of amazon web services (aws) and google app
engine (gae).
multi-tenant processes are organization-speciï¬c variants
of the same process running in a cloud infrastructure. con-sider for example salesforce and easychair. the sales pro-
cesses of many organizations are managed and supported
by salesforce. on the one hand, these organizations sharean infrastructure (processes, databases, etc.). on the other
hand, they are not forced to follow a strict process model
as the system can be conï¬gured to support variants of thesame process. easychair supports the review processes of
many conferences. on the one hand, conferences share
common functionality and processes. on the other hand,many variations are possible.
despite examples like salesforce and easychair, as y s -
tematic approach to support and analyze multi-tenant pro-
cesses is missing . business process management (bpm) is
gaining momentum, but for the actual implementation ofmost multi-tenant processes conventional methods are still
being used. processes and their conï¬guration parameters
are hard-coded and systems are data-centric rather than
process-centric. this is undesirable and there is clear needforprocess conï¬guration support [1], [2]. a conï¬gurable
process model represents a family of process models.
through conï¬guration, behavior is restricted to ï¬t the
needs of a particular organization.
having a process-aware cloud infrastructure enables
new forms of analysis. in this paper, we focus on cross-
organizational process mining [3]. process mining fuses
data mining and process analysis techniques and is driven
by the omnipresence of event data in modern information
systems [4]. cloud-based systems will record event logsin a systematic manner and at a scale not seen before.
moreover, event logs of different organizations can be
analyzed and compared systematically.
we propose to use causal nets (c-nets) as a formalism
to support and analyze multi-tenant processes. c-nets are
related to the representations used by several process
discovery techniques (e.g., heuristic mining, fuzzy mining,and genetic mining) [4]. however, unlike mainstream no-
tations like petri nets, bpmn, bpel, epcs, and uml ac-
tivity diagrams, c-nets provide declarative semantics moresuitable for process mining and process conï¬guration. for
example, c-nets provide a much better representational
bias than conventional techniques which allow for modelsthat are obviously incorrect, i.e., by using c-nets the search
space is reduced to the more interesting models. it is also
very easy to merge different c-nets into an overarching c-
net that allows for all behavior possible in the individual
nets. this in stark contrast with more traditional notationsfor which it is far from trivial to fold a set of variants into
a conï¬gurable model [5]. the veriï¬cation of conï¬gurable
models and their conï¬gurations is also difï¬cult as suchmodels implicitly describe families of models [6], [7].
the remainder is organized as follows. section ii
introduces the topic of process conï¬guration. then we
introduce c-nets as a new formalism to deal with thechallenges imposed by process conï¬guration and mining
(section iii). subsequently, we use c-nets to introduce the
notions of process conï¬guration (section iv) and processmining (section v). section vi discusses challenges and
opportunities related to multi-tenant processes. section vii
concludes this paper.ii. p rocess configuration
to motivate the need for conï¬gurable processes, we ï¬rst
sketch some example domains where many variants of the
same process co-exist.
there are about 430 municipalities in the netherlands.
in principle, they all execute variants of the same set of
processes [3], [5]. for example, they all support processes
related to building permits, such as the process handlingapplications for permits and the process for handling
objections against such permits.
suncorp is the largest australian insurance group. the
suncorp group offers various types of insurance using
brands such as suncorp, aami, apia, gio, just car,
bingle, vero, etc. there are insurance processes related todifferent types of risks (home, motor, commercial, liability,
etc.) and these processes exist for the different suncorp
brands. hence, there are up to 30 different variants of theprocess of handling an insurance claim at suncorp.
hertz is the largest car rental company in the world with
more than 8,000 locations in 146 countries. all ofï¬ces
of hertz need to support the same set of processes, e.g.,how to process a reservation. however, there are subtle
differences among the processes at different locations
due to regional or national variations. for example, the
law in one country or the culture in a particular region
forces hertz to customize the standard process for differentlocations.
organizations such as suncorp and hertz need to
support many variants of the same process (intra-
organizational variation). different municipalities in acountry need to offer the same set of services to their
citizens, and, hence, need to manage similar collections
of processes. however, due to demographics and po-litical choices, municipalities are handling things dif-
ferently. sometimes these differences are unintentional;
however, often these differences can be easily justiï¬edby the desired â€œcouleur localeâ€ (inter-organizational vari-
ation). clearly, it is undesirable to support these intra-
organizational and inter-organizational variations by devel-
oping organization-speciï¬c systems or by adapting stan-
dard systems in an ad-hoc manner. cloud technology canhelp to reduce costs by sharing a common infrastructure,
but currently process conï¬guration is not supported by
such infrastructures.
as cloud infrastructures are gaining importance, it be-
comes more important to better support variability using
conï¬gurable process models. multi-tenant processes, i.e.,
the sharing of similar processes in the cloud, require amore systematic treatment of process conï¬guration. there-
fore, we elaborate on the nature of process conï¬guration.
michelangelo buonarroti (1475â€“1564), the famous ital-
ian sculptor, painter, architect and engineer, made the
following well-known statements which illustrate the idea
of conï¬guration:
âˆ™â€œevery block of stone has a statue inside it and it isthe task of the sculptor to discover it.â€
âˆ™â€œi saw the angel in the marble and carved until i sethim free.â€âˆ™â€œcarving is easy, you just go down to the skin and
stop.â€
we take the viewpoint that conï¬guration is like sculpting ,
i.e., carving out the desired behavior. this means that con-ï¬guration implies the removal of behavior, i.e., blocking
particular execution paths in the process.
scope
small
(single case in
one
organization)large
(processes in
different
organizations)long
(years)short
(seconds)
timedecisions
figure 1. conï¬guration is like carving stone to create a sculpture.
making choices removes potential behavior, just like a sculptor removesstone. decisions need to be made at different levels until at run-time all
decisions have been made.
when developing product software that will be used
in many organizations, one needs to make choices that
will impact all of these organizations, the processes in
these organizations, and the instances of these processes.therefore, the scope of such design decisions is large
and the timeframe associated with such decisions is long.
organizations using sap r/3 beneï¬t/suffer from choicesmade in the early 1990s when the erp system was de-
veloped. when an organization chooses to install a system
like sap r/3, it needs to be conï¬gured to meet the speciï¬cneeds of the organization. this implies that again various
choices are made. the scope of such decisions is consider-
able, but smaller than the scope of initial design decisionsmade by the software vendor of a successful product.
when conï¬guring the system, one is operating within the
bounds imposed by the product software. subsequently,the installed system is used to support processes. this
triggers another set of choices. once the process is up
and running, instances (often referred to as â€œcasesâ€) are
handled by the system. however, there may still be choices
left (cf. xor-splits in a process model). these choices areresolved at run-time. when the instance has been handled,
no choices remain. sometimes, we refer to this as â€œaudit
timeâ€ as history cannot be changed and it is undesirableto try and change any records describing the completed
execution of a process instance. fig. 1 illustrates this
process of decision making. at different levels, choicesneed to be made. some choices have a small scope and
a short timeframe whereas other choices have a large
scope and a long timeframe. as shown in fig. 1 thereis a continuum of decision making. for example, one
can have a process that is reconï¬gured when things get
very busy. imagine for example how suncorp changedits processes when it got overloaded with thousands of
claims due to the ï¬‚ooding of queensland in january 2011.
such reconï¬guration decisions impact many cases. one
can also have a process that is different in weekends or
during holidays. a process may depend on the region (e.g.,location of a hertz ofï¬ce), on the weather (e.g., when it
rains a location is closed), on the type of customer (e.g.,
gold customers do not need to register), etc. all of thesevariations correspond to decisions that were made at some
point in time. decisions made at one level, remove options
at a lower level.
in this paper, we assume that conï¬guration implies the
removal of possibilities . the desired behavior needs to be
â€œcarved outâ€. clearly, other viewpoints are possible. for
example, some authors also consider reï¬nement and modelextension as conï¬guration primitives [8]â€“[10]. neverthe-
less, most approaches view conï¬guration as the restriction
of behavior before runtime. moreover, when dealing withmulti-tenant processes in the cloud, it seems unrealistic to
assume that organizations will be able to remodel parts of
standard processes.
often two basic operators are used to remove behavior:
â€œhidingâ€ and â€œblockingâ€ [11]. all other mechanisms for
removing behavior can be expressed in terms of these ba-
sic operations (see [1], [2] for examples). moreover, thesecorrespond to the inverse of the basic operators describing
inheritance of dynamic behavior [12]. while conï¬guration
corresponds to removing behavior, inheritance correspondsto adding behavior while preserving certain properties.
+ =
configuration configurable model configured model
figure 2. given a conï¬gurable model and a conï¬guration, a conï¬gured
model is derived. the conï¬gured model has less behavior because
potential behavior is removed during conï¬guration.
notions such as blocking and hiding are language inde-
pendent. fig. 2 illustrates that the basic mechanisms apply
to different languages. different conï¬gurable languages
have been deï¬ned in the literature, e.g., c-y awl, c-epc, and c-sap [1], [2]. a so-called conï¬guration can
be applied to a conï¬gurable model created using such a
language (thus restricting behavior). after applying theconï¬guration, one obtains the conï¬gured model . the latter
is a conventional executable model, e.g., a model that can
be enacted using a bpm system.iii. c
ausal nets
as illustrated by fig. 2, there are various conï¬gurable
languages where conï¬guration corresponds to the removalof behavior. in this paper, we use causal nets (c-nets)
[4], [13], [14] as a basic language to reason about process
conï¬guration.
fig. 3 shows a c-net modeling the booking of a trip.
after activity ğ‘(start booking ) there are three possible
activities: ğ‘(book ï¬‚ight ),ğ‘(book car ), and ğ‘‘(book hotel ).
the process ends with activity ğ‘’(complete booking ). each
activity has sets of potential input and output bindings
(indicated by the black dots). every connected set of dots
on the output arcs of an activity is an output binding. for
example, ğ‘has four output bindings modeling that ğ‘may
be followed by (1) just ğ‘,( 2 )j u s t ğ‘,( 3 )ğ‘andğ‘‘,o r( 4 )
ğ‘,ğ‘, andğ‘‘. hence, it is not possible to book just a hotel
or a hotel and a car. activity ğ‘has two input bindings
modeling that it is preceded by (1) just ğ‘or (2) ğ‘andğ‘.
this construct is used to model that when both a ï¬‚ightand a car are booked, the ï¬‚ight is booked ï¬rst. output
bindings create obligations whereas input bindings remove
obligations. for example, the occurrence of ğ‘with output
binding {ğ‘,ğ‘‘}creates two obligations: both ğ‘andğ‘‘need
to be executed while referring to the obligations created
byğ‘.
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
f i g u r e3 . c a u s a ln e t ğ¶travel .
in a c-net there is one start activity ( ğ‘in fig. 3) and
one end activity ( ğ‘’in fig. 3). a valid binding sequence
models an execution path starting with ğ‘and ending
withğ‘’while removing all obligations created during
execution. the behavior of a c-net is restricted to valid
binding sequences . hence, unlike conventional modeling
languages, the semantics are non-local. the syntax of a
c-net can be formalized as follows.
deï¬nition 1 (causal net [4]): acausal net (c-net) is
a tuple ğ¶=(ğ´,ğ‘ ğ‘–,ğ‘ğ‘œ, ğ·,ğ¼,ğ‘‚ )where:
âˆ™ğ´is a ï¬nite set of activities ;
âˆ™ğ‘ğ‘–âˆˆğ´is the start activity ;
âˆ™ğ‘ğ‘œâˆˆğ´is the end activity ;
âˆ™ğ·âŠ†ğ´Ã—ğ´is the dependency relation ,
âˆ™as={ğ‘‹âŠ†ğ’«(ğ´)âˆ£ğ‘‹={âˆ…} âˆ¨ âˆ… âˆ•âˆˆğ‘‹};1
âˆ™ğ¼âˆˆğ´â†’as deï¬nes the set of possible input
bindings per activity; and
1ğ’«(ğ´)={ğ´â€²âˆ£ğ´â€²âŠ†ğ´}is the powerset of ğ´. hence, elements of
as aresets of sets of activities.âˆ™ğ‘‚âˆˆğ´â†’as deï¬nes the set of possible output
bindings per activity,
such that
âˆ™ğ·={(ğ‘1,ğ‘2)âˆˆğ´Ã—ğ´âˆ£ğ‘1âˆˆâˆª
asâˆˆğ¼(ğ‘2)as};
âˆ™ğ·={(ğ‘1,ğ‘2)âˆˆğ´Ã—ğ´âˆ£ğ‘2âˆˆâˆª
asâˆˆğ‘‚(ğ‘1)as};
âˆ™{ğ‘ğ‘–}={ğ‘âˆˆğ´âˆ£ğ¼(ğ‘)={âˆ…}} ;
âˆ™{ğ‘ğ‘œ}={ğ‘âˆˆğ´âˆ£ğ‘‚(ğ‘)={âˆ…}} ; and
âˆ™all activities in the graph (ğ´,ğ· )are on a path from
ğ‘ğ‘–toğ‘ğ‘œ.
there is one unique start activity ğ‘ğ‘–and one unique
end activity ğ‘ğ‘œ. each activity ğ‘has a set of possible
input bindings ğ¼(ğ‘)and a set of possible output bindings
ğ‘‚(ğ‘). for example, in fig. 3, ğ¼(ğ‘)={{ğ‘},{ğ‘,ğ‘}}and
ğ‘‚(ğ‘)={{ğ‘’}}. start activity ğ‘ğ‘–has one input binding and
end activity ğ‘ğ‘œhas one output binding: ğ¼(ğ‘ğ‘–)=ğ‘‚(ğ‘ğ‘œ)=
{âˆ…}. the notion of input and output bindings allows for
the typical modeling constructs found in languages such
as epcs, bpmn, petri nets, uml activity diagram, etc.fig. 4 shows some of the basic process patterns.
xor-split and-split or-split
xor-join and-join or-joinoutput
bindingsinput
bindings
figure 4. input and output bindings.
an activity binding is a tuple (ğ‘,asğ¼,asğ‘‚)denoting
the occurrence of activity ğ‘with input binding asğ¼and
output binding asğ‘‚. for example, (ğ‘,{ğ‘,ğ‘},{ğ‘’})denotes
the occurrence of activity ğ‘in fig. 3 while being preceded
byğ‘andğ‘, and succeeded by ğ‘’.
deï¬nition 2 (binding): letğ¶=(ğ´,ğ‘ ğ‘–,ğ‘ğ‘œ,ğ·,ğ¼,ğ‘‚ )be
a c-net. ğµ={(ğ‘,asğ¼,asğ‘‚)âˆˆğ´Ã—ğ’«(ğ´)Ã—ğ’«(ğ´)âˆ£asğ¼âˆˆ
ğ¼(ğ‘)âˆ§asğ‘‚âˆˆğ‘‚(ğ‘)}is the set of activity bindings .a
binding sequence ğœis a sequence of activity bindings, i.e.,
ğœâˆˆğµâˆ—.
note that sequences are denoted using angle brackets,
e.g.,âŸ¨âŸ©denotes the empty sequence. ğµâˆ—is the set of all
sequences over ğµ(including âŸ¨âŸ©). function ğ›¼âˆˆğµâˆ—â†’ğ´âˆ—
projects binding sequences onto activity sequences , i.e.,
the input and output bindings are abstracted from and only
the activity names are retained.
a possible binding sequence for the c-net shown
in fig. 3 is ğœ =âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘,ğ‘‘}),(ğ‘‘,{ğ‘},{ğ‘’}),
(ğ‘,{ğ‘},{ğ‘,ğ‘’}),(ğ‘,{ğ‘,ğ‘},{ğ‘’}),(ğ‘’,{ğ‘,ğ‘,ğ‘‘},âˆ…)âŸ©, i.e., the
scenario in which a hotel, a ï¬‚ight, and a car are booked.
ğ›¼(ğœ)= âŸ¨ğ‘,ğ‘‘,ğ‘,ğ‘,ğ‘’ âŸ©is the corresponding activity se-
quence. note that in fig. 3 a hotel can only be bookedif a ï¬‚ight is booked. moreover, when both a car and a
ï¬‚ight are booked, then ï¬rst the ï¬‚ight needs to be booked.
a binding sequence is valid if a predecessor activity and
successor activity always â€œagreeâ€ on their bindings. for a
predecessor activity ğ‘¥and successor activity ğ‘¦we need to
see the following â€œpatternâ€: âŸ¨...,(ğ‘¥,{...},{ğ‘¦,...}),...,(ğ‘¦,{ğ‘¥,...}
,{...}), ...âŸ©, i.e., an occurrence of activity ğ‘¥
withğ‘¦in its output binding needs to be followed by an
occurrence of activity ğ‘¦, and an occurrence of activity
ğ‘¦withğ‘¥in its input binding needs to be preceded by
an occurrence of activity ğ‘¥. to formalize the notion of a
valid binding sequence, we ï¬rst deï¬ne the notion of state .
states are represented by multi-sets of obligations , e.g.,
state [(ğ‘,ğ‘)2,(ğ‘,ğ‘)]denotes the state where there are two
pending activations of ğ‘byğ‘and there is one pending
activation of ğ‘byğ‘. this means that ğ‘needs to happen
twice while having ğ‘in its input binding and ğ‘needs to
happen once while having ğ‘in its input binding.
deï¬nition 3 (state): letğ¶=(ğ´,ğ‘ ğ‘–,ğ‘ğ‘œ,ğ·,ğ¼,ğ‘‚ )be a
c-net. ğ‘†=ib(ğ´Ã—ğ´)is the state space ofğ¶.2ğ‘ âˆˆğ‘†is
astate , i.e., a multi-set of pending obligations . function
ğœ“âˆˆğµâˆ—â†’ğ‘†is deï¬ned inductively: ğœ“(âŸ¨âŸ©)=[ ] and
ğœ“(ğœâŠ•(ğ‘,asğ¼,asğ‘‚)) = (ğœ“(ğœ)âˆ–(asğ¼Ã—{ğ‘}))âŠ({ğ‘}Ã—asğ‘‚)
for any binding sequence ğœâŠ•(ğ‘,asğ¼,asğ‘‚)âˆˆğµâˆ—.3ğœ“(ğœ)
is the state after executing binding sequence ğœ.
avalid binding sequence is a binding sequence
that (1) starts with start activity ğ‘ğ‘–, (2) ends with
end activity ğ‘ğ‘œ, (3) only removes obligations that are
pending, and (4) ends without any pending obligations.consider, for example, the valid binding sequence ğœ=
âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘‘}),(ğ‘‘,{ğ‘},{ğ‘’}),(ğ‘,{ğ‘},{ğ‘’}),(ğ‘’,{ğ‘,ğ‘‘},âˆ…)âŸ©
for c-net ğ¶
travel in fig. 3:
ğœ“(âŸ¨âŸ©)=[] ,
ğœ“(âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘‘})âŸ©)=[ (ğ‘,ğ‘),(ğ‘,ğ‘‘)],
ğœ“(âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘‘}),(ğ‘‘,{ğ‘},{ğ‘’})âŸ©)=[ (ğ‘,ğ‘),(ğ‘‘,ğ‘’)],
ğœ“(âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘‘}),(ğ‘‘,{ğ‘},{ğ‘’}),(ğ‘,{ğ‘},{ğ‘’})âŸ©)=
[(ğ‘,ğ‘’),(ğ‘‘,ğ‘’)],
ğœ“(âŸ¨(ğ‘,âˆ…,{ğ‘,ğ‘‘}),(ğ‘‘,{ğ‘},{ğ‘’}),(ğ‘,{ğ‘},{ğ‘’}),
(ğ‘’,{ğ‘,ğ‘‘},âˆ…)âŸ©)=[] .
sequence ğœindeed starts with start activity ğ‘, ends with
end activity ğ‘’, only removes obligations that are pending
(i.e., for every input binding there was an earlier output
binding), and ends without any pending obligations:
ğœ“(ğœ)=[] .
deï¬nition 4 (valid): letğ¶=(ğ´,ğ‘ ğ‘–,ğ‘ğ‘œ,ğ·,ğ¼,ğ‘‚ )be
a c-net and ğœ=âŸ¨(ğ‘1,asğ¼
1,asğ‘‚
1),(ğ‘2,asğ¼
2,asğ‘‚
2),...
,(ğ‘ğ‘›,asğ¼
ğ‘›,asğ‘‚
ğ‘›)âŸ©âˆˆğµâˆ—be a binding sequence. ğœis avalid
binding sequence ofğ¶if and only if:
âˆ™ğ‘1=ğ‘ğ‘–,ğ‘ğ‘›=ğ‘ğ‘œ, andğ‘ğ‘˜âˆˆğ´âˆ–{ğ‘ğ‘–,ğ‘ğ‘œ}for1<
ğ‘˜<ğ‘› ;
âˆ™ğœ“(ğœ)=[] ; and
âˆ™for any non-empty preï¬x ğœâ€²=âŸ¨(ğ‘1,asğ¼
1,asğ‘‚
1),
...,(ğ‘ğ‘˜,asğ¼
ğ‘˜,asğ‘‚
ğ‘˜)âŸ©(1â‰¤ğ‘˜â‰¤ğ‘›):(asğ¼
ğ‘˜Ã—
{ğ‘ğ‘˜})â‰¤ğœ“(ğœâ€²â€²)withğœâ€²â€²=âŸ¨(ğ‘1,asğ¼
1,asğ‘‚
1),...
,(ğ‘ğ‘˜âˆ’1,asğ¼
ğ‘˜âˆ’1,asğ‘‚
ğ‘˜âˆ’1)âŸ©
ğ‘‰(ğ¶)is the set of all valid binding sequences ofğ¶.
the ï¬rst requirement states that valid binding sequences
start with ğ‘ğ‘–and end with ğ‘ğ‘œ(ğ‘ğ‘–andğ‘ğ‘œcannot appear
2ib(ğ´)is a multiset over ğ´.ğ‘‹=[ğ‘2,ğ‘3,ğ‘]is a multiset with six
elements: two times ğ‘, three times ğ‘, and one ğ‘,ğ‘‹âŠğ‘Œis the union of
two multi-sets. ğ‘‹âˆ–ğ‘Œremoves ğ‘Œfrom ğ‘‹(difference of two multi-sets).
ordinary sets will be used as multi-sets throughout this paper.
3âŠ•is used to concatenate an element to the end of a sequence, e.g.,
âŸ¨ğ‘, ğ‘, ğ‘ âŸ©âŠ•ğ‘‘=âŸ¨ğ‘, ğ‘, ğ‘, ğ‘‘ âŸ©.in the middle of valid sequence). the second requirement
states that at the end there should not be any pending
obligations. (one can think of this as the constraint that notokens left in the net.) the last requirement considers all
non-empty preï¬xes of ğœ. the last activity binding of the
preï¬x (i.e., (ğ‘
ğ‘˜,asğ¼
ğ‘˜,asğ‘‚
ğ‘˜)) should only remove pending
obligations, i.e., (asğ¼
ğ‘˜Ã—{ğ‘ğ‘˜})â‰¤ğœ“(ğœâ€²â€²)where asğ¼
ğ‘˜Ã—{ğ‘ğ‘˜}
are the obligations to be removed and ğœ“(ğœâ€²â€²)are the
pending obligations just before the occurrence of the ğ‘˜-th
binding. (one can think of this as the constraint that one
cannot consume tokens that have not been produced.)
the c-net in fig. 3 has seven valid binding sequences:
onlyğ‘is executed ( âŸ¨(ğ‘,âˆ…,{ğ‘}),(ğ‘,{ğ‘},{ğ‘’}),(ğ‘’,{ğ‘},âˆ…)âŸ©),
onlyğ‘is executed (besides ğ‘andğ‘’),ğ‘andğ‘‘are executed
(two possibilities), and ğ‘,ğ‘andğ‘‘are executed (3 possi-
bilities because ğ‘needs to occur before ğ‘).
for the semantics of a c-net we only consider valid
binding sequences, i.e., invalid sequences are not part of
the behavior described by the c-net. this means that c-
nets do not use plain â€œtoken-game semanticsâ€ as employedin conventional languages like bpmn, petri nets, epcs,
and y awl. the semantics of c-nets are more declarative
as they are deï¬ned over complete sequences rather than alocal ï¬ring rule. note that the semantics abstract from the
moment of choice; pending obligations are not exposed to
the environment and are not ï¬xed during execution (i.e.,allvalid interpretations remain open).
iv . c
onfiguration =r emoving beha vior
after introducing c-nets as a process modeling lan-
guage, we now focus on process conï¬guration. as dis-
cussed in section ii, we restrict behavior to conï¬gure
a process. whereas a conï¬gurable model allows for the
behavior exhibited in different variants of a process, a
conï¬gured model is more speciï¬c. to formalize the notion
of conï¬guration, we introduce some basic operations on
c-nets.
deï¬nition 5 (operations on c-nets): letğ¶1=(ğ´1,
ğ‘ğ‘–,ğ‘ğ‘œ,ğ·1,ğ¼1,ğ‘‚1)andğ¶2=(ğ´2,ğ‘ğ‘–,ğ‘ğ‘œ,ğ·2,ğ¼2,ğ‘‚2)be
two c-nets having identical start and end activities.
âˆ™ğ¶1âŠ‘ğ¶2if and only if ğ´1âŠ†ğ´2and for all ğ‘âˆˆğ´1:
ğ¼1(ğ‘)âŠ†ğ¼2(ğ‘)andğ‘‚1(ğ‘)âŠ†ğ‘‚2(ğ‘).
âˆ™ğ¶1âŠğ¶2=(ğ´,ğ‘ ğ‘–,ğ‘ğ‘œ,ğ·,ğ¼,ğ‘‚ )withğ´=ğ´1âˆªğ´2,
ğ·=ğ·1âˆªğ·2,ğ¼=ğ¼1âŠ”ğ¼2, andğ‘‚=ğ‘‚1âŠ”ğ‘‚2.4
consider two c-nets such that ğ¶1âŠ‘ğ¶2.ğ¶1can be
viewed as the conï¬gured model and ğ¶2as the conï¬gurable
model. the intuition is that ğ¶1allows for less behavior
thanğ¶2, i.e., by removing potential input and output
bindings the behavior of the process is restricted. it ispossible to use more sophisticated notions. for example,
one could deï¬ne a conï¬gurable model as a set of c-nets,
e.g.,ğ’={ğ¶âŠ‘ğ¶
ğ‘âˆ£ğµ(ğ¶)}where ğµis a boolean
expression over all c-nets that are contained in some base
model ğ¶ğ‘.ğµcan be used to encode domain constraints
4âŠ”takes the union of two set valued functions, i.e., ğ‘“=ğ‘“1âŠ”ğ‘“2
is a function such that ğ‘“(ğ‘¥)= ğ‘“1(ğ‘¥)ifğ‘¥âˆˆdom (ğ‘“1)âˆ–dom (ğ‘“2),
ğ‘“(ğ‘¥)=ğ‘“2(ğ‘¥)ifğ‘¥âˆˆdom (ğ‘“2)âˆ–dom (ğ‘“1),a n d ğ‘“(ğ‘¥)=ğ‘“1(ğ‘¥)âˆªğ‘“2(ğ‘¥)
ifğ‘¥âˆˆdom (ğ‘“1)âˆ©dom (ğ‘“2).or data dependencies, e.g., activity ğ‘¥may require input
data produced by activity ğ‘¦,s oğ‘¦cannot be hidden or
blocked when ğ‘¥is enabled [1], [6], [7]. for simplicity, we
assume that ğµevaluates to true in this paper, i.e., the set
ğ’is uniquely identiï¬ed by some base model ğ¶ğ‘.i nt h e
remainder, we will refer to ğ¶ğ‘as the conï¬gurable model
and to ğ¶âŠ‘ğ¶ğ‘as one of its possible conï¬gurations.
theorem 1: letğ¶1andğ¶2be two c-nets having
identical start and end activities. if ğ¶1âŠ‘ğ¶2, then
ğ‘‰(ğ¶1)âŠ†ğ‘‰(ğ¶2).
proof: consider valid binding sequence ğœ=
âŸ¨(ğ‘1,asğ¼
1,asğ‘‚
1),(ğ‘2,asğ¼
2,asğ‘‚
2),..., (ğ‘ğ‘›,asğ¼
ğ‘›,asğ‘‚
ğ‘›)âŸ©âˆˆ
ğ‘‰(ğ¶1). first we show that ğœis indeed a binding sequence
ofğ¶2, i.e., for any ğ‘˜:(ğ‘ğ‘˜,asğ¼
ğ‘˜,asğ‘‚
ğ‘˜)should be a binding.
this is the case because ğ‘ğ‘˜âˆˆğ´1âŠ†ğ´2,asğ¼
ğ‘˜âˆˆğ¼1(ğ‘ğ‘˜)âŠ†
ğ¼2(ğ‘ğ‘˜)andasğ‘‚
ğ‘˜âˆˆğ‘‚1(ğ‘ğ‘˜)âŠ†ğ‘‚2(ğ‘ğ‘˜). clearly, ğ‘1=ğ‘ğ‘–,
ğ‘ğ‘›=ğ‘ğ‘œ, and ğ‘ğ‘˜âˆˆğ´1âˆ–{ğ‘ğ‘–,ğ‘ğ‘œ}âŠ†ğ´2âˆ–{ğ‘ğ‘–,ğ‘ğ‘œ}for
1<ğ‘˜<ğ‘› , i.e., the ï¬rst requirement in deï¬nition 4 is
satisï¬ed. ğœ“(ğœ)=[ ] in both models because this function
only depends on ğœand not on the model. the same
holds for the third requirement in deï¬nition 4. hence,
ğœâˆˆğ‘‰(ğ¶2).
theorem 1 shows that the set of valid sequences of
the conï¬gured process ğ¶1is included in the set of valid
sequences of the conï¬gurable process ğ¶2.f i g .5s h o w s
three c-nets whose behaviors are embedded in the initial
c-net of fig. 3. it is easy to see that ğ¶1âŠ‘ğ¶travel ,
ğ¶2âŠ‘ğ¶travel , andğ¶3âŠ‘ğ¶travel . this implies that all valid
binding sequences of these three variants are included in
the set of valid binding sequences of ğ¶travel .
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
a e dbbook flight
start
bookingcomplete
booking
figure 5. three conï¬gured process models obtained by restricting the
conï¬gurable process model in fig. 3: ğ¶1(top left), ğ¶2(top right), and
ğ¶3(bottom). note that ğ¶travel =ğ¶1âŠğ¶2âŠğ¶3.
a conï¬gurable process model contains the behavior of
different variants. this is operationalized by the following
observation.
corollary 1: letğ¶1andğ¶2be two c-nets having
identical start and end activities. ğ‘‰(ğ¶1)âˆªğ‘‰(ğ¶2)âŠ†
ğ‘‰(ğ¶1âŠğ¶2).
the corollary follows directly from theorem 1 because
ğ¶1âŠ‘ğ¶1âŠğ¶2andğ¶2âŠ‘ğ¶1âŠğ¶2. using classical process
notations such as petri nets, epcs, bpmn, uml activitydiagrams, it is far from trivial to merge models. the
merged model may have all kinds of anomalies (deadlocks,
livelocks, etc.) as discussed [5], [7]. using the declarativesemantics of c-nets, it is trivial to merge variants of a
process into a model that allows for all behaviors present
in the individual variants.for c-nets it is easy to add and remove behavior and
to merge process variants. as indicated in section i, this
is important in the context of multi-tenant processes. theexecution can simply block input and output bindings for
particular tenants.
v. m
ining =d iscovering beha vior
the goal of process mining is to extract knowledge
about a particular (operational) process from event logs.
an event refers to the occurrence of an activity for a
particular process instance (often referred to as case ). the
events related to a case are ordered and form a trace .
deï¬nition 6 (event, trace, event log): letğ´be a set
of activities. ğœâˆˆğ´âˆ—is a trace , i.e., a sequence of events.
ğ¿âˆˆib(ğ´âˆ—)is an event log , i.e., a multi-set of traces.
an event log may contain additional information, e.g.,
an event may have an explicit timestamp and attributessuch as amount, customer, resource, etc. as shown in [4],
this information can be used for different types of analysis
ranging from bottleneck analysis and prediction to socialnetwork analysis. for simplicity we abstract from this and
consider just activity names. moreover, we focus on c-nets
as a target model. this allows us to restrict the notion ofprocess mining to the discovery of a c-net from a multiset
of traces.
deï¬nition 7 (mining algorithm): letğ¿be an event
log. a mining algorithm ğœ‡derives a process model from
such an event log, i.e., ğœ‡(ğ¿)=(ğ´,ğ‘
ğ‘–,ğ‘ğ‘œ,ğ·,ğ¼,ğ‘‚ )when
c-nets are used as a target model.
process discovery algorithms can discover models
such as the one shown in fig. 3 from event logs
such as ğ¿travel =[âŸ¨ğ‘,ğ‘,ğ‘’âŸ©8,âŸ¨ğ‘,ğ‘,ğ‘’âŸ©11,âŸ¨ğ‘,ğ‘,ğ‘‘,ğ‘’ âŸ©30,
âŸ¨ğ‘,ğ‘‘,ğ‘,ğ‘’ âŸ©22,âŸ¨ğ‘,ğ‘,ğ‘,ğ‘‘,ğ‘’ âŸ©7,âŸ¨ğ‘,ğ‘,ğ‘‘,ğ‘,ğ‘’ âŸ©12,âŸ¨ğ‘,ğ‘‘,ğ‘,ğ‘,ğ‘’ âŸ©9],
i.e.,ğœ‡(ğ¿travel )=ğ¶travel .
various process discovery algorithms have been pro-
posed in literature (see [4] for an overview). these al-
gorithms use techniques varying from genetic algorithms
to region-based approaches. there are different ways todeï¬ne the quality of the discovered process model, e.g.,
ï¬tness measures the fraction of the event log that can be
â€œreplayedâ€ by the event log.
deï¬nition 8 (fitness): letğ¿be an event log and ğ¶a
discovered process model. a ï¬tness function ğœ‹measures
the quality of the model with respect to the log. for
example, a naive ï¬tness function is ğœ‹(ğ¿,ğ¶ )=# [ ğœâˆˆ
ğ¿âˆ£âˆƒ
ğœâ€²âˆˆğ‘‰(ğ¶)ğ›¼(ğœâ€²)=ğœ]/#ğ¿.
various ï¬tness notions have been proposed. the ex-
ample function ğœ‹(ğ¿,ğ¶ )given in deï¬nition 7 simply
measures the fraction of traces that correspond to valid
binding sequences. a single deviating event in a long trace
that has no other deviations results in a non-ï¬tting case.
hence, the metric cannot distinguish between an almostï¬tting trace and a trace consisting of many deviating
events. therefore, most notions measure ï¬tness at the
level of events [4], [15]. moreover, ï¬tness is just onedimension. in general, there is a trade-off between the
following four quality criteria: (a) ï¬tness : the discovered
model should allow for the behavior seen in the event log,(b)precision : the discovered model should not allow for
behavior completely unrelated to what was seen in the
event log, (c) generalization : the discovered model should
generalize the example behavior seen in the event log, and
(d)simplicity : the discovered model should be as simple
as possible.
traditionally, process mining techniques are applied to
one event log originating from some process, i.e., the focusis on a single log. in the context of conï¬gurable/multi-
tenant processes, we need to compare the event logs
and models of different organizations. as clouds providean infrastructure to systematically collect events, cross-
organizational analysis comes into reach.
vi. c
hallenges and opportunities
after introducing c-nets as a representation for process
conï¬guration and process mining, we now discuss the
challenges and opportunities associated to multi-tenantprocesses in the cloud. fig. 6 is used to structure the
discussion. assume there are ğ‘›variants of the same
process running in parallel. we refer to these processesasğ‘ƒ
1,ğ‘ƒ2,...ğ‘ƒ ğ‘›. these processes generate event logs
ğ¿1,ğ¿2,...ğ¿ ğ‘›. the corresponding process models are
ğ¶1,ğ¶2,...ğ¶ ğ‘›. a process model ğ¶ğ‘–may have been made
by hand or has been discovered from event log ğ¿ğ‘–(for
1â‰¤ğ‘–â‰¤ğ‘›). in the latter case: ğ¶ğ‘–=ğœ‡(ğ¿ğ‘–).t o
simplify the discussion, we assume that ğ¶ğ‘–is a c-net
as deï¬ned in deï¬nition 1 and ğ¿ğ‘–is an event log as
deï¬ned in deï¬nition 6. note that in reality event logswill contain much more information and process models
also describe resources, data ï¬‚ow, routing conditions,
triggers, etc. [4]. fig. 6 shows for each process ğ‘ƒ
ğ‘–an
event log ğ¿ğ‘–and process model ğ¶ğ‘–. the different process
models can be merged into an overall conï¬gurable model
ğ¶all=ğ¶1âŠğ¶2âŠ...âŠğ¶ğ‘›. the overall event log covering
all variants can be obtained my merging the individual
event logs: ğ¿all=ğ¿1âŠğ¿2âŠ...âŠğ¿ğ‘›. an alternative way to
get the overall conï¬gurable model is via discovery basedon the merged event log, i.e., ğ¶
all=ğœ‡(ğ¿all). assuming
that the processes have been running for a while, it is also
possible to extract key performance indicators (kpis) andcompare these among different variants. the small meter-
like symbols in fig. 6 refer to these kpis.
a. capturing variability into a single conï¬gurable model
as indicated in section iv, a conï¬gurable model de-
scribes a family of processes ğ’={ğ¶âŠ‘ğ¶
ğ‘âˆ£ğµ(ğ¶)}
where ğµis a boolean expression over a c-nets that are
contained in some base model ğ¶ğ‘. to simplify discussion,
we referred to ğ¶ğ‘as if it is the conï¬gurable model. in
reality, it is more difï¬cult to describe a conï¬gurable model.
first of all, the model should also take other perspectivesinto account. second, it is non-trivial to describe the
possible conï¬gurations in an intuitive manner. consider
for example a set of rather sequential process variantsthat do not agree on the ordering of most activities. the
resulting model will be spaghetti-like and it is still unclear
how to address this problem properly [1], [6], [7].process 1event
log 1process
model 1
process 2event
log 2process
model 2
process nevent
lognprocess
model n... ... ...(configurable)
process model
event logc
c
c
figure 6. overview of the different challenges and connections between
conï¬gurable/conï¬gured models and event logs.
b. analyzing conï¬gurable process models
traditionally, analysis techniques focus on the analysis
of a single process model. conï¬gurable process modelsdeï¬ne a family of process models. therefore, analysis
becomes more challenging. for example, in [7] we show
how to compute a so-called â€œconï¬guration guidelineâ€ thatallows for the analysis of potential problems at design
time. the conï¬guration guideline also enables new func-
tionality such as â€œauto-completingâ€ a partially conï¬guredmodel (taking data dependencies into account).
c. learning conï¬gurable models
as fig. 6 shows there are basically two ways to obtain
a conï¬gurable model. one approach is to merge the
different models: ğ¶
all=ğ¶1âŠğ¶2âŠ...âŠğ¶ğ‘›. another
approach is to merge the individual event logs into one logğ¿
all=ğ¿1âŠğ¿2âŠ...âŠğ¿ğ‘›and then apply some process
discovery algorithm ğ¶all=ğœ‡(ğ¿all). for c-nets this is
relatively simple provided that the various â€œingredientsâ€(event logs, models, etc.) are available and of high quality.
in practice, these assumptions often do not hold, thus
making the problem challenging. moreover, it will rarelybe the case that ğœ‡(ğ¿
all)orğ¶1âŠğ¶2âŠ...âŠğ¶ğ‘›will be
taken as the deï¬nitive conï¬gurable model as the goal is to
capture â€œbest practicesâ€. undesirable features of particular
processes may be left out or processes are uniï¬ed to â€œï¬ght
complexityâ€.
d. conformance checking
given an event log ğ¿and a process model ğ¶,w e
can check the conformance of both. for example, we
can measure ï¬tness ğœ‹(ğ¿,ğ¶ ), i.e., the fraction of the
event log that is possible according to the model (can be
deï¬ned in different ways [4]). in the phase where oneis building a conï¬gurable model ğ¶, it is interesting to
see how good ğ¶ï¬ts the event log of each individual
organization, i.e., measure ğœ‹(ğ¿
ğ‘–,ğ¶)for1â‰¤ğ‘–â‰¤ğ‘›.
this will show which organizations are most affected
by (changes to) the conï¬gurable model. note that the
goal is not to simply merge all existing behaviors; theconï¬gurable model should capture â€œbest practicesâ€ while
still allowing for the â€œcouleur localeâ€ required by the
individual organizations.
conformance checking techniques [4], [15] analyze be-
havioral differences between a log and model, i.e., log-to-
model comparison. however, it is also possible to compare
two models or two logs. model-to-model comparison can
be used to analyze the differences between the individual
process models ğ¶1,ğ¶2,...ğ¶ ğ‘›or differences between the
conï¬gurable model ğ¶and a speciï¬c process model ğ¶ğ‘–.
log-to-log comparison can be used to compare the dif-
ferent processes based on their event logs. for example,
one can ï¬nd that ğ¿ğ‘–andğ¿ğ‘—are most similar or that the
behavior of ğ¿ğ‘–is contained in ğ¿ğ‘—.
e. cross-tenant process mining
having event logs from different organizations in
a format that allows for comparison, enables cross-
organizational process mining. the service provider that
is supporting processes for different organizations (e.g.salesforce or easychair) is interested in knowing how
organizations are using the common infrastructure. com-
parative analysis may lead to additional services (e.g.,guidance of end-user organizations) or to changes to the
conï¬gurable model. in the coselog project [3], [16],
[17] we experienced that organizations are interested in
learning from each other. in this project, 10 of the 430
dutch municipalities are participating to investigate howcloud technology can be used to reduce costs and improve
service. all dutch municipalities need to offer the same
services to their citizens, and need to manage similarcollections of processes. however, due to demographics
and political choices, municipalities are handling things
differently. therefore, process conï¬guration is important.moreover, municipalities are not in competition with
one another. in fact, the ten municipalities involved in
coselog are eager to learn â€œproven best practicesâ€ fromone another. this can be operationalized using cross-
organizational process mining [17].
besides a pair-wise comparison of logs and models, we
can also use supervised learning to explain differences.for example, we can use classiï¬cation techniques such as
decision tree learning. for this purpose we need to label
the data at the level of cases or at the level of event logs.classiï¬cation is based on a selected response variable and
a set of predictor variables . for example, the response
variable could be the (average) ï¬‚ow time or costs of acase or log. the ï¬tness of an event log or case with
respect to some reference model can also be taken as a
response variable. predictor variables are other properties
of cases, event logs, or process models. for example,
the complexity of the process model and the number orresources involved. based on such information one can
construct a decision tree that aims to explain the response
variable in terms of predictor variables . for example,
classiï¬cation based on logs of different municipalities may
reveal that (a) larger municipalities tend to have fewer
deviations, (b) allowing for more concurrency results inshorter ï¬‚ow times but more deviations, and (c) a pre-
check of building permits results in shorter ï¬‚ow times and
a higher acceptance rate.
vii. c onclusion
emerging cloud infrastructures provide new opportu-
nities for sharing processes and allow for new typesof analysis such as cross-organizational process mining.
when organizations share processes in the cloud, we
refer to these as multi-tenant processes. however, differentorganizations have different requirements. therefore, the
cloud infrastructure needs to support variants of the same
process. in product software installed locally (e.g., sap), itis common practice to customize the system in a rather ad-
hoc manner. clearly, this is unacceptable in a cloud setting.
therefore, we advocated the need for conï¬gurable processmodels. once different variants of the same conï¬gurable
model are running in the cloud, events are recorded in
a systematic manner and it becomes relatively easy tocompare these variants using cross-organizational mining.
in this paper, we advocated the use of causal nets (c-
nets) for process conï¬guration and mining. this represen-
tation emerged from the process mining domain [4]. as
shown, essential operators such as merging two modelsğ¶
1âŠğ¶2and checking containment ğ¶1âŠ‘ğ¶2can be deï¬ned
without the traditional complications (e.g., dealing with
deadlock and other anomalies). although c-nets are closeto existing languages having and/xor/or-splits/joins,
their semantics are deï¬ned in terms valid binding se-
quences. these semantics simplify both conï¬guration andprocess mining.
a
cknowledgments
the author would like to thank marcello la rosa,
florian gottschalk, niels lohmann, michael rosemann,
jan v ogelaar, marlon dumas, eric verbeek, boudewijn
van dongen, joos buijs, and hajo reijers for their workon conï¬gurable models (c-y awl, c-epc, etc.) and their
involvement in the coselog project.
r
eferences
[1] m. rosemann and w. van der aalst, â€œa conï¬gurable ref-
erence modelling language,â€ information systems , vol. 32,
no. 1, pp. 1â€“23, 2007.
[2] f. gottschalk, w. van der aalst, m. jansen-vullers, and
m. l. rosa, â€œconï¬gurable workï¬‚ow models,â€ interna-
tional journal of cooperative information systems , vol. 17,
no. 2, pp. 177â€“221, 2008.
[3] w. van der aalst, â€œconï¬gurable services in the cloud: sup-
porting variability while enabling cross-organizationalprocess mining,â€ in coopis 2010 , lecture notes in com-
puter science, vol. 6426. springer-verlag, berlin, 2010,pp. 8â€“25.
[4] w. van der aalst, process mining: discovery, conformance
and enhancement of business processes . springer-verlag,
berlin, 2011.[5] f. gottschalk, t. wagemakers, m. jansen-vullers,
w. van der aalst, and m. la rosa, â€œconï¬gurable processmodels: experiences from a municipality case study,â€ incaiseâ€™09 , lecture notes in computer science, vol. 5565.
springer-verlag, berlin, 2009, pp. 486â€“500.
[6] w. van der aalst, m. dumas, f. gottschalk, a. ter hofstede,
m. la rosa, and j. mendling, â€œpreserving correctnessduring business process model conï¬guration,â€ formal
aspects of computing , vol. 22, no. 3, pp. 459â€“482, 2010.
[7] w. van der aalst, n. lohmann, m. la rosa, and j. xu,
â€œcorrectness ensuring process conï¬guration: an ap-proach based on partner synthesis,â€ in business process
management (bpm 2010) , ser. lecture notes in computer
science, r. hull, j. mendling, and s. tai, eds., vol. 6336.springer-verlag, berlin, 2010, pp. 95â€“111.
[8] j. becker, p. delfmann, and r. knackstedt, â€œadaptive
reference modeling: integrating conï¬gurative and genericadaptation techniques for information models,â€ in ref-
erence modeling: efï¬cient information systems designthrough reuse of information models , physica-verlag,
springer, 2007, pp. 27â€“58.
[9] a. hallerbach, t. bauer, and m. reichert, â€œcapturing vari-
ability in business process models: the provop approach,â€journal of software maintenance and evolution: researchand practice , vol. 22, no. 6-7, pp. 519â€“546, 2010.
[10] i. reinhartz-berger, p. soffer, and a. sturm, â€œextending
the adaptability of reference models,â€ ieee transactions
on systems, man and cybernetics - part a: systems andhumans , vol. 40, no. 5, pp. 1045â€“1056, 2011.
[11] f. gottschalk, w. van der aalst, and m. jansen-vullers,
â€œconï¬gurable process models: a foundational approach,â€inreference modeling: efï¬cient information systems de-
sign through reuse of information models , physica-verlag,
springer, 2007, pp. 59â€“78.
[12] w. van der aalst and t. basten, â€œinheritance of workï¬‚ows:
an approach to tackling problems related to change,â€theoretical computer science , vol. 270, no. 1-2, pp. 125â€“
203, 2002.
[13] w. van der aalst, â€œdo petri nets provide the right rep-
resentational bias for process mining?â€ in workshop ap-
plications of region theory 2011 (art 2011) ,s e r .c e u r
workshop proceedings, j. desel and a. yakovlev, eds., vol.725. ceur-ws.org, 2011, pp. 85â€“94.
[14] w. van der aalst, a. adriansyah, and b. van dongen,
â€œcausal nets: a modeling language tailored towardsprocess discovery,â€ in 22nd international conference on
concurrency theory (concur 2011) , ser. lecture notes
in computer science, j. katoen and b. koenig, eds.springer-verlag, berlin, 2011.
[15] a. rozinat and w. van der aalst, â€œconformance checking
of processes based on monitoring real behavior,â€ infor-
mation systems , vol. 33, no. 1, pp. 64â€“95, 2008.
[16] coselog, â€œconï¬gurable services for local governments
(coselog) project home page,â€ www.win.tue.nl/coselog.
[17] j. buijs, b. van dongen, and w. van der aalst, â€œto-
wards cross-organizational process mining in collectionsof process models and their executions,â€ in international
workshop on process model collections (pmc 2011) .
springer-verlag, berlin, 2011.