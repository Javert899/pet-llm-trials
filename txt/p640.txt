business process conﬁguration in the cloud:
how to support and analyze multi-tenant processes?
w.m.p. van der aalst
department of mathematics and computer science, eindhoven university of technology
eindhoven, the netherlands
www: vdaalst.com
abstract —lion’s share of cloud research has been focusing
on performance related problems. however, cloud computingwill also change the way in which business processes are man-aged and supported, e.g., more and more organizations willbe sharing common processes. in the classical setting, whereproduct software is used, different organizations can makead-hoc customizations to let the system ﬁt their needs. this isundesirable, especially when multiple organizations share acloud infrastructure. conﬁgurable process models enable the
sharing of common processes among different organizations
in a controlled manner. this paper discusses challengesand opportunities related to business process conﬁguration.causal nets (c-nets) are proposed as a new formalism to
deal with these challenges, e.g., merging variants into aconﬁgurable model is supported by a simple union operator.c-nets also provide a good representational bias for process
mining , i.e., process discovery and conformance checking
based on event logs. in the context of cloud computing,we focus on the application of c-nets to cross-organizational
process mining.
keywords -conﬁgurable process models; cross-
organizational process mining; cloud computing; causalnets
i. i ntroduction
the interest for cloud computing is rapidly growing
both in industry and research communities. cloud com-
puting focuses on the sharing of it resources to achievesigniﬁcant cost reductions. in this paper, we do not focus
on the infrastructure level, but at the level of business pro-
cesses shared among different parties. we aim to supportfamilies of processes for different organizations using the
likes of amazon web services (aws) and google app
engine (gae).
multi-tenant processes are organization-speciﬁc variants
of the same process running in a cloud infrastructure. con-sider for example salesforce and easychair. the sales pro-
cesses of many organizations are managed and supported
by salesforce. on the one hand, these organizations sharean infrastructure (processes, databases, etc.). on the other
hand, they are not forced to follow a strict process model
as the system can be conﬁgured to support variants of thesame process. easychair supports the review processes of
many conferences. on the one hand, conferences share
common functionality and processes. on the other hand,many variations are possible.
despite examples like salesforce and easychair, as y s -
tematic approach to support and analyze multi-tenant pro-
cesses is missing . business process management (bpm) is
gaining momentum, but for the actual implementation ofmost multi-tenant processes conventional methods are still
being used. processes and their conﬁguration parameters
are hard-coded and systems are data-centric rather than
process-centric. this is undesirable and there is clear needforprocess conﬁguration support [1], [2]. a conﬁgurable
process model represents a family of process models.
through conﬁguration, behavior is restricted to ﬁt the
needs of a particular organization.
having a process-aware cloud infrastructure enables
new forms of analysis. in this paper, we focus on cross-
organizational process mining [3]. process mining fuses
data mining and process analysis techniques and is driven
by the omnipresence of event data in modern information
systems [4]. cloud-based systems will record event logsin a systematic manner and at a scale not seen before.
moreover, event logs of different organizations can be
analyzed and compared systematically.
we propose to use causal nets (c-nets) as a formalism
to support and analyze multi-tenant processes. c-nets are
related to the representations used by several process
discovery techniques (e.g., heuristic mining, fuzzy mining,and genetic mining) [4]. however, unlike mainstream no-
tations like petri nets, bpmn, bpel, epcs, and uml ac-
tivity diagrams, c-nets provide declarative semantics moresuitable for process mining and process conﬁguration. for
example, c-nets provide a much better representational
bias than conventional techniques which allow for modelsthat are obviously incorrect, i.e., by using c-nets the search
space is reduced to the more interesting models. it is also
very easy to merge different c-nets into an overarching c-
net that allows for all behavior possible in the individual
nets. this in stark contrast with more traditional notationsfor which it is far from trivial to fold a set of variants into
a conﬁgurable model [5]. the veriﬁcation of conﬁgurable
models and their conﬁgurations is also difﬁcult as suchmodels implicitly describe families of models [6], [7].
the remainder is organized as follows. section ii
introduces the topic of process conﬁguration. then we
introduce c-nets as a new formalism to deal with thechallenges imposed by process conﬁguration and mining
(section iii). subsequently, we use c-nets to introduce the
notions of process conﬁguration (section iv) and processmining (section v). section vi discusses challenges and
opportunities related to multi-tenant processes. section vii
concludes this paper.ii. p rocess configuration
to motivate the need for conﬁgurable processes, we ﬁrst
sketch some example domains where many variants of the
same process co-exist.
there are about 430 municipalities in the netherlands.
in principle, they all execute variants of the same set of
processes [3], [5]. for example, they all support processes
related to building permits, such as the process handlingapplications for permits and the process for handling
objections against such permits.
suncorp is the largest australian insurance group. the
suncorp group offers various types of insurance using
brands such as suncorp, aami, apia, gio, just car,
bingle, vero, etc. there are insurance processes related todifferent types of risks (home, motor, commercial, liability,
etc.) and these processes exist for the different suncorp
brands. hence, there are up to 30 different variants of theprocess of handling an insurance claim at suncorp.
hertz is the largest car rental company in the world with
more than 8,000 locations in 146 countries. all ofﬁces
of hertz need to support the same set of processes, e.g.,how to process a reservation. however, there are subtle
differences among the processes at different locations
due to regional or national variations. for example, the
law in one country or the culture in a particular region
forces hertz to customize the standard process for differentlocations.
organizations such as suncorp and hertz need to
support many variants of the same process (intra-
organizational variation). different municipalities in acountry need to offer the same set of services to their
citizens, and, hence, need to manage similar collections
of processes. however, due to demographics and po-litical choices, municipalities are handling things dif-
ferently. sometimes these differences are unintentional;
however, often these differences can be easily justiﬁedby the desired “couleur locale” (inter-organizational vari-
ation). clearly, it is undesirable to support these intra-
organizational and inter-organizational variations by devel-
oping organization-speciﬁc systems or by adapting stan-
dard systems in an ad-hoc manner. cloud technology canhelp to reduce costs by sharing a common infrastructure,
but currently process conﬁguration is not supported by
such infrastructures.
as cloud infrastructures are gaining importance, it be-
comes more important to better support variability using
conﬁgurable process models. multi-tenant processes, i.e.,
the sharing of similar processes in the cloud, require amore systematic treatment of process conﬁguration. there-
fore, we elaborate on the nature of process conﬁguration.
michelangelo buonarroti (1475–1564), the famous ital-
ian sculptor, painter, architect and engineer, made the
following well-known statements which illustrate the idea
of conﬁguration:
∙“every block of stone has a statue inside it and it isthe task of the sculptor to discover it.”
∙“i saw the angel in the marble and carved until i sethim free.”∙“carving is easy, you just go down to the skin and
stop.”
we take the viewpoint that conﬁguration is like sculpting ,
i.e., carving out the desired behavior. this means that con-ﬁguration implies the removal of behavior, i.e., blocking
particular execution paths in the process.
scope
small
(single case in
one
organization)large
(processes in
different
organizations)long
(years)short
(seconds)
timedecisions
figure 1. conﬁguration is like carving stone to create a sculpture.
making choices removes potential behavior, just like a sculptor removesstone. decisions need to be made at different levels until at run-time all
decisions have been made.
when developing product software that will be used
in many organizations, one needs to make choices that
will impact all of these organizations, the processes in
these organizations, and the instances of these processes.therefore, the scope of such design decisions is large
and the timeframe associated with such decisions is long.
organizations using sap r/3 beneﬁt/suffer from choicesmade in the early 1990s when the erp system was de-
veloped. when an organization chooses to install a system
like sap r/3, it needs to be conﬁgured to meet the speciﬁcneeds of the organization. this implies that again various
choices are made. the scope of such decisions is consider-
able, but smaller than the scope of initial design decisionsmade by the software vendor of a successful product.
when conﬁguring the system, one is operating within the
bounds imposed by the product software. subsequently,the installed system is used to support processes. this
triggers another set of choices. once the process is up
and running, instances (often referred to as “cases”) are
handled by the system. however, there may still be choices
left (cf. xor-splits in a process model). these choices areresolved at run-time. when the instance has been handled,
no choices remain. sometimes, we refer to this as “audit
time” as history cannot be changed and it is undesirableto try and change any records describing the completed
execution of a process instance. fig. 1 illustrates this
process of decision making. at different levels, choicesneed to be made. some choices have a small scope and
a short timeframe whereas other choices have a large
scope and a long timeframe. as shown in fig. 1 thereis a continuum of decision making. for example, one
can have a process that is reconﬁgured when things get
very busy. imagine for example how suncorp changedits processes when it got overloaded with thousands of
claims due to the ﬂooding of queensland in january 2011.
such reconﬁguration decisions impact many cases. one
can also have a process that is different in weekends or
during holidays. a process may depend on the region (e.g.,location of a hertz ofﬁce), on the weather (e.g., when it
rains a location is closed), on the type of customer (e.g.,
gold customers do not need to register), etc. all of thesevariations correspond to decisions that were made at some
point in time. decisions made at one level, remove options
at a lower level.
in this paper, we assume that conﬁguration implies the
removal of possibilities . the desired behavior needs to be
“carved out”. clearly, other viewpoints are possible. for
example, some authors also consider reﬁnement and modelextension as conﬁguration primitives [8]–[10]. neverthe-
less, most approaches view conﬁguration as the restriction
of behavior before runtime. moreover, when dealing withmulti-tenant processes in the cloud, it seems unrealistic to
assume that organizations will be able to remodel parts of
standard processes.
often two basic operators are used to remove behavior:
“hiding” and “blocking” [11]. all other mechanisms for
removing behavior can be expressed in terms of these ba-
sic operations (see [1], [2] for examples). moreover, thesecorrespond to the inverse of the basic operators describing
inheritance of dynamic behavior [12]. while conﬁguration
corresponds to removing behavior, inheritance correspondsto adding behavior while preserving certain properties.
+ =
configuration configurable model configured model
figure 2. given a conﬁgurable model and a conﬁguration, a conﬁgured
model is derived. the conﬁgured model has less behavior because
potential behavior is removed during conﬁguration.
notions such as blocking and hiding are language inde-
pendent. fig. 2 illustrates that the basic mechanisms apply
to different languages. different conﬁgurable languages
have been deﬁned in the literature, e.g., c-y awl, c-epc, and c-sap [1], [2]. a so-called conﬁguration can
be applied to a conﬁgurable model created using such a
language (thus restricting behavior). after applying theconﬁguration, one obtains the conﬁgured model . the latter
is a conventional executable model, e.g., a model that can
be enacted using a bpm system.iii. c
ausal nets
as illustrated by fig. 2, there are various conﬁgurable
languages where conﬁguration corresponds to the removalof behavior. in this paper, we use causal nets (c-nets)
[4], [13], [14] as a basic language to reason about process
conﬁguration.
fig. 3 shows a c-net modeling the booking of a trip.
after activity 𝑎(start booking ) there are three possible
activities: 𝑏(book ﬂight ),𝑐(book car ), and 𝑑(book hotel ).
the process ends with activity 𝑒(complete booking ). each
activity has sets of potential input and output bindings
(indicated by the black dots). every connected set of dots
on the output arcs of an activity is an output binding. for
example, 𝑎has four output bindings modeling that 𝑎may
be followed by (1) just 𝑏,( 2 )j u s t 𝑐,( 3 )𝑏and𝑑,o r( 4 )
𝑏,𝑐, and𝑑. hence, it is not possible to book just a hotel
or a hotel and a car. activity 𝑐has two input bindings
modeling that it is preceded by (1) just 𝑎or (2) 𝑎and𝑏.
this construct is used to model that when both a ﬂightand a car are booked, the ﬂight is booked ﬁrst. output
bindings create obligations whereas input bindings remove
obligations. for example, the occurrence of 𝑎with output
binding {𝑏,𝑑}creates two obligations: both 𝑏and𝑑need
to be executed while referring to the obligations created
by𝑎.
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
f i g u r e3 . c a u s a ln e t 𝐶travel .
in a c-net there is one start activity ( 𝑎in fig. 3) and
one end activity ( 𝑒in fig. 3). a valid binding sequence
models an execution path starting with 𝑎and ending
with𝑒while removing all obligations created during
execution. the behavior of a c-net is restricted to valid
binding sequences . hence, unlike conventional modeling
languages, the semantics are non-local. the syntax of a
c-net can be formalized as follows.
deﬁnition 1 (causal net [4]): acausal net (c-net) is
a tuple 𝐶=(𝐴,𝑎 𝑖,𝑎𝑜, 𝐷,𝐼,𝑂 )where:
∙𝐴is a ﬁnite set of activities ;
∙𝑎𝑖∈𝐴is the start activity ;
∙𝑎𝑜∈𝐴is the end activity ;
∙𝐷⊆𝐴×𝐴is the dependency relation ,
∙as={𝑋⊆𝒫(𝐴)∣𝑋={∅} ∨ ∅ ∕∈𝑋};1
∙𝐼∈𝐴→as deﬁnes the set of possible input
bindings per activity; and
1𝒫(𝐴)={𝐴′∣𝐴′⊆𝐴}is the powerset of 𝐴. hence, elements of
as aresets of sets of activities.∙𝑂∈𝐴→as deﬁnes the set of possible output
bindings per activity,
such that
∙𝐷={(𝑎1,𝑎2)∈𝐴×𝐴∣𝑎1∈∪
as∈𝐼(𝑎2)as};
∙𝐷={(𝑎1,𝑎2)∈𝐴×𝐴∣𝑎2∈∪
as∈𝑂(𝑎1)as};
∙{𝑎𝑖}={𝑎∈𝐴∣𝐼(𝑎)={∅}} ;
∙{𝑎𝑜}={𝑎∈𝐴∣𝑂(𝑎)={∅}} ; and
∙all activities in the graph (𝐴,𝐷 )are on a path from
𝑎𝑖to𝑎𝑜.
there is one unique start activity 𝑎𝑖and one unique
end activity 𝑎𝑜. each activity 𝑎has a set of possible
input bindings 𝐼(𝑎)and a set of possible output bindings
𝑂(𝑎). for example, in fig. 3, 𝐼(𝑐)={{𝑎},{𝑎,𝑏}}and
𝑂(𝑐)={{𝑒}}. start activity 𝑎𝑖has one input binding and
end activity 𝑎𝑜has one output binding: 𝐼(𝑎𝑖)=𝑂(𝑎𝑜)=
{∅}. the notion of input and output bindings allows for
the typical modeling constructs found in languages such
as epcs, bpmn, petri nets, uml activity diagram, etc.fig. 4 shows some of the basic process patterns.
xor-split and-split or-split
xor-join and-join or-joinoutput
bindingsinput
bindings
figure 4. input and output bindings.
an activity binding is a tuple (𝑎,as𝐼,as𝑂)denoting
the occurrence of activity 𝑎with input binding as𝐼and
output binding as𝑂. for example, (𝑐,{𝑎,𝑏},{𝑒})denotes
the occurrence of activity 𝑐in fig. 3 while being preceded
by𝑎and𝑏, and succeeded by 𝑒.
deﬁnition 2 (binding): let𝐶=(𝐴,𝑎 𝑖,𝑎𝑜,𝐷,𝐼,𝑂 )be
a c-net. 𝐵={(𝑎,as𝐼,as𝑂)∈𝐴×𝒫(𝐴)×𝒫(𝐴)∣as𝐼∈
𝐼(𝑎)∧as𝑂∈𝑂(𝑎)}is the set of activity bindings .a
binding sequence 𝜎is a sequence of activity bindings, i.e.,
𝜎∈𝐵∗.
note that sequences are denoted using angle brackets,
e.g.,⟨⟩denotes the empty sequence. 𝐵∗is the set of all
sequences over 𝐵(including ⟨⟩). function 𝛼∈𝐵∗→𝐴∗
projects binding sequences onto activity sequences , i.e.,
the input and output bindings are abstracted from and only
the activity names are retained.
a possible binding sequence for the c-net shown
in fig. 3 is 𝜎 =⟨(𝑎,∅,{𝑏,𝑐,𝑑}),(𝑑,{𝑎},{𝑒}),
(𝑏,{𝑎},{𝑐,𝑒}),(𝑐,{𝑎,𝑏},{𝑒}),(𝑒,{𝑏,𝑐,𝑑},∅)⟩, i.e., the
scenario in which a hotel, a ﬂight, and a car are booked.
𝛼(𝜎)= ⟨𝑎,𝑑,𝑏,𝑐,𝑒 ⟩is the corresponding activity se-
quence. note that in fig. 3 a hotel can only be bookedif a ﬂight is booked. moreover, when both a car and a
ﬂight are booked, then ﬁrst the ﬂight needs to be booked.
a binding sequence is valid if a predecessor activity and
successor activity always “agree” on their bindings. for a
predecessor activity 𝑥and successor activity 𝑦we need to
see the following “pattern”: ⟨...,(𝑥,{...},{𝑦,...}),...,(𝑦,{𝑥,...}
,{...}), ...⟩, i.e., an occurrence of activity 𝑥
with𝑦in its output binding needs to be followed by an
occurrence of activity 𝑦, and an occurrence of activity
𝑦with𝑥in its input binding needs to be preceded by
an occurrence of activity 𝑥. to formalize the notion of a
valid binding sequence, we ﬁrst deﬁne the notion of state .
states are represented by multi-sets of obligations , e.g.,
state [(𝑎,𝑏)2,(𝑎,𝑐)]denotes the state where there are two
pending activations of 𝑏by𝑎and there is one pending
activation of 𝑐by𝑎. this means that 𝑏needs to happen
twice while having 𝑎in its input binding and 𝑐needs to
happen once while having 𝑎in its input binding.
deﬁnition 3 (state): let𝐶=(𝐴,𝑎 𝑖,𝑎𝑜,𝐷,𝐼,𝑂 )be a
c-net. 𝑆=ib(𝐴×𝐴)is the state space of𝐶.2𝑠∈𝑆is
astate , i.e., a multi-set of pending obligations . function
𝜓∈𝐵∗→𝑆is deﬁned inductively: 𝜓(⟨⟩)=[ ] and
𝜓(𝜎⊕(𝑎,as𝐼,as𝑂)) = (𝜓(𝜎)∖(as𝐼×{𝑎}))⊎({𝑎}×as𝑂)
for any binding sequence 𝜎⊕(𝑎,as𝐼,as𝑂)∈𝐵∗.3𝜓(𝜎)
is the state after executing binding sequence 𝜎.
avalid binding sequence is a binding sequence
that (1) starts with start activity 𝑎𝑖, (2) ends with
end activity 𝑎𝑜, (3) only removes obligations that are
pending, and (4) ends without any pending obligations.consider, for example, the valid binding sequence 𝜎=
⟨(𝑎,∅,{𝑏,𝑑}),(𝑑,{𝑎},{𝑒}),(𝑏,{𝑎},{𝑒}),(𝑒,{𝑏,𝑑},∅)⟩
for c-net 𝐶
travel in fig. 3:
𝜓(⟨⟩)=[] ,
𝜓(⟨(𝑎,∅,{𝑏,𝑑})⟩)=[ (𝑎,𝑏),(𝑎,𝑑)],
𝜓(⟨(𝑎,∅,{𝑏,𝑑}),(𝑑,{𝑎},{𝑒})⟩)=[ (𝑎,𝑏),(𝑑,𝑒)],
𝜓(⟨(𝑎,∅,{𝑏,𝑑}),(𝑑,{𝑎},{𝑒}),(𝑏,{𝑎},{𝑒})⟩)=
[(𝑏,𝑒),(𝑑,𝑒)],
𝜓(⟨(𝑎,∅,{𝑏,𝑑}),(𝑑,{𝑎},{𝑒}),(𝑏,{𝑎},{𝑒}),
(𝑒,{𝑏,𝑑},∅)⟩)=[] .
sequence 𝜎indeed starts with start activity 𝑎, ends with
end activity 𝑒, only removes obligations that are pending
(i.e., for every input binding there was an earlier output
binding), and ends without any pending obligations:
𝜓(𝜎)=[] .
deﬁnition 4 (valid): let𝐶=(𝐴,𝑎 𝑖,𝑎𝑜,𝐷,𝐼,𝑂 )be
a c-net and 𝜎=⟨(𝑎1,as𝐼
1,as𝑂
1),(𝑎2,as𝐼
2,as𝑂
2),...
,(𝑎𝑛,as𝐼
𝑛,as𝑂
𝑛)⟩∈𝐵∗be a binding sequence. 𝜎is avalid
binding sequence of𝐶if and only if:
∙𝑎1=𝑎𝑖,𝑎𝑛=𝑎𝑜, and𝑎𝑘∈𝐴∖{𝑎𝑖,𝑎𝑜}for1<
𝑘<𝑛 ;
∙𝜓(𝜎)=[] ; and
∙for any non-empty preﬁx 𝜎′=⟨(𝑎1,as𝐼
1,as𝑂
1),
...,(𝑎𝑘,as𝐼
𝑘,as𝑂
𝑘)⟩(1≤𝑘≤𝑛):(as𝐼
𝑘×
{𝑎𝑘})≤𝜓(𝜎′′)with𝜎′′=⟨(𝑎1,as𝐼
1,as𝑂
1),...
,(𝑎𝑘−1,as𝐼
𝑘−1,as𝑂
𝑘−1)⟩
𝑉(𝐶)is the set of all valid binding sequences of𝐶.
the ﬁrst requirement states that valid binding sequences
start with 𝑎𝑖and end with 𝑎𝑜(𝑎𝑖and𝑎𝑜cannot appear
2ib(𝐴)is a multiset over 𝐴.𝑋=[𝑎2,𝑏3,𝑐]is a multiset with six
elements: two times 𝑎, three times 𝑏, and one 𝑐,𝑋⊎𝑌is the union of
two multi-sets. 𝑋∖𝑌removes 𝑌from 𝑋(difference of two multi-sets).
ordinary sets will be used as multi-sets throughout this paper.
3⊕is used to concatenate an element to the end of a sequence, e.g.,
⟨𝑎, 𝑏, 𝑐 ⟩⊕𝑑=⟨𝑎, 𝑏, 𝑐, 𝑑 ⟩.in the middle of valid sequence). the second requirement
states that at the end there should not be any pending
obligations. (one can think of this as the constraint that notokens left in the net.) the last requirement considers all
non-empty preﬁxes of 𝜎. the last activity binding of the
preﬁx (i.e., (𝑎
𝑘,as𝐼
𝑘,as𝑂
𝑘)) should only remove pending
obligations, i.e., (as𝐼
𝑘×{𝑎𝑘})≤𝜓(𝜎′′)where as𝐼
𝑘×{𝑎𝑘}
are the obligations to be removed and 𝜓(𝜎′′)are the
pending obligations just before the occurrence of the 𝑘-th
binding. (one can think of this as the constraint that one
cannot consume tokens that have not been produced.)
the c-net in fig. 3 has seven valid binding sequences:
only𝑏is executed ( ⟨(𝑎,∅,{𝑏}),(𝑏,{𝑎},{𝑒}),(𝑒,{𝑏},∅)⟩),
only𝑐is executed (besides 𝑎and𝑒),𝑏and𝑑are executed
(two possibilities), and 𝑏,𝑐and𝑑are executed (3 possi-
bilities because 𝑏needs to occur before 𝑐).
for the semantics of a c-net we only consider valid
binding sequences, i.e., invalid sequences are not part of
the behavior described by the c-net. this means that c-
nets do not use plain “token-game semantics” as employedin conventional languages like bpmn, petri nets, epcs,
and y awl. the semantics of c-nets are more declarative
as they are deﬁned over complete sequences rather than alocal ﬁring rule. note that the semantics abstract from the
moment of choice; pending obligations are not exposed to
the environment and are not ﬁxed during execution (i.e.,allvalid interpretations remain open).
iv . c
onfiguration =r emoving beha vior
after introducing c-nets as a process modeling lan-
guage, we now focus on process conﬁguration. as dis-
cussed in section ii, we restrict behavior to conﬁgure
a process. whereas a conﬁgurable model allows for the
behavior exhibited in different variants of a process, a
conﬁgured model is more speciﬁc. to formalize the notion
of conﬁguration, we introduce some basic operations on
c-nets.
deﬁnition 5 (operations on c-nets): let𝐶1=(𝐴1,
𝑎𝑖,𝑎𝑜,𝐷1,𝐼1,𝑂1)and𝐶2=(𝐴2,𝑎𝑖,𝑎𝑜,𝐷2,𝐼2,𝑂2)be
two c-nets having identical start and end activities.
∙𝐶1⊑𝐶2if and only if 𝐴1⊆𝐴2and for all 𝑎∈𝐴1:
𝐼1(𝑎)⊆𝐼2(𝑎)and𝑂1(𝑎)⊆𝑂2(𝑎).
∙𝐶1⊎𝐶2=(𝐴,𝑎 𝑖,𝑎𝑜,𝐷,𝐼,𝑂 )with𝐴=𝐴1∪𝐴2,
𝐷=𝐷1∪𝐷2,𝐼=𝐼1⊔𝐼2, and𝑂=𝑂1⊔𝑂2.4
consider two c-nets such that 𝐶1⊑𝐶2.𝐶1can be
viewed as the conﬁgured model and 𝐶2as the conﬁgurable
model. the intuition is that 𝐶1allows for less behavior
than𝐶2, i.e., by removing potential input and output
bindings the behavior of the process is restricted. it ispossible to use more sophisticated notions. for example,
one could deﬁne a conﬁgurable model as a set of c-nets,
e.g.,𝒞={𝐶⊑𝐶
𝑏∣𝐵(𝐶)}where 𝐵is a boolean
expression over all c-nets that are contained in some base
model 𝐶𝑏.𝐵can be used to encode domain constraints
4⊔takes the union of two set valued functions, i.e., 𝑓=𝑓1⊔𝑓2
is a function such that 𝑓(𝑥)= 𝑓1(𝑥)if𝑥∈dom (𝑓1)∖dom (𝑓2),
𝑓(𝑥)=𝑓2(𝑥)if𝑥∈dom (𝑓2)∖dom (𝑓1),a n d 𝑓(𝑥)=𝑓1(𝑥)∪𝑓2(𝑥)
if𝑥∈dom (𝑓1)∩dom (𝑓2).or data dependencies, e.g., activity 𝑥may require input
data produced by activity 𝑦,s o𝑦cannot be hidden or
blocked when 𝑥is enabled [1], [6], [7]. for simplicity, we
assume that 𝐵evaluates to true in this paper, i.e., the set
𝒞is uniquely identiﬁed by some base model 𝐶𝑏.i nt h e
remainder, we will refer to 𝐶𝑏as the conﬁgurable model
and to 𝐶⊑𝐶𝑏as one of its possible conﬁgurations.
theorem 1: let𝐶1and𝐶2be two c-nets having
identical start and end activities. if 𝐶1⊑𝐶2, then
𝑉(𝐶1)⊆𝑉(𝐶2).
proof: consider valid binding sequence 𝜎=
⟨(𝑎1,as𝐼
1,as𝑂
1),(𝑎2,as𝐼
2,as𝑂
2),..., (𝑎𝑛,as𝐼
𝑛,as𝑂
𝑛)⟩∈
𝑉(𝐶1). first we show that 𝜎is indeed a binding sequence
of𝐶2, i.e., for any 𝑘:(𝑎𝑘,as𝐼
𝑘,as𝑂
𝑘)should be a binding.
this is the case because 𝑎𝑘∈𝐴1⊆𝐴2,as𝐼
𝑘∈𝐼1(𝑎𝑘)⊆
𝐼2(𝑎𝑘)andas𝑂
𝑘∈𝑂1(𝑎𝑘)⊆𝑂2(𝑎𝑘). clearly, 𝑎1=𝑎𝑖,
𝑎𝑛=𝑎𝑜, and 𝑎𝑘∈𝐴1∖{𝑎𝑖,𝑎𝑜}⊆𝐴2∖{𝑎𝑖,𝑎𝑜}for
1<𝑘<𝑛 , i.e., the ﬁrst requirement in deﬁnition 4 is
satisﬁed. 𝜓(𝜎)=[ ] in both models because this function
only depends on 𝜎and not on the model. the same
holds for the third requirement in deﬁnition 4. hence,
𝜎∈𝑉(𝐶2).
theorem 1 shows that the set of valid sequences of
the conﬁgured process 𝐶1is included in the set of valid
sequences of the conﬁgurable process 𝐶2.f i g .5s h o w s
three c-nets whose behaviors are embedded in the initial
c-net of fig. 3. it is easy to see that 𝐶1⊑𝐶travel ,
𝐶2⊑𝐶travel , and𝐶3⊑𝐶travel . this implies that all valid
binding sequences of these three variants are included in
the set of valid binding sequences of 𝐶travel .
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
a
start
bookingc e
complete
bookingbook car
d
book hotelbbook flight
a e dbbook flight
start
bookingcomplete
booking
figure 5. three conﬁgured process models obtained by restricting the
conﬁgurable process model in fig. 3: 𝐶1(top left), 𝐶2(top right), and
𝐶3(bottom). note that 𝐶travel =𝐶1⊎𝐶2⊎𝐶3.
a conﬁgurable process model contains the behavior of
different variants. this is operationalized by the following
observation.
corollary 1: let𝐶1and𝐶2be two c-nets having
identical start and end activities. 𝑉(𝐶1)∪𝑉(𝐶2)⊆
𝑉(𝐶1⊎𝐶2).
the corollary follows directly from theorem 1 because
𝐶1⊑𝐶1⊎𝐶2and𝐶2⊑𝐶1⊎𝐶2. using classical process
notations such as petri nets, epcs, bpmn, uml activitydiagrams, it is far from trivial to merge models. the
merged model may have all kinds of anomalies (deadlocks,
livelocks, etc.) as discussed [5], [7]. using the declarativesemantics of c-nets, it is trivial to merge variants of a
process into a model that allows for all behaviors present
in the individual variants.for c-nets it is easy to add and remove behavior and
to merge process variants. as indicated in section i, this
is important in the context of multi-tenant processes. theexecution can simply block input and output bindings for
particular tenants.
v. m
ining =d iscovering beha vior
the goal of process mining is to extract knowledge
about a particular (operational) process from event logs.
an event refers to the occurrence of an activity for a
particular process instance (often referred to as case ). the
events related to a case are ordered and form a trace .
deﬁnition 6 (event, trace, event log): let𝐴be a set
of activities. 𝜎∈𝐴∗is a trace , i.e., a sequence of events.
𝐿∈ib(𝐴∗)is an event log , i.e., a multi-set of traces.
an event log may contain additional information, e.g.,
an event may have an explicit timestamp and attributessuch as amount, customer, resource, etc. as shown in [4],
this information can be used for different types of analysis
ranging from bottleneck analysis and prediction to socialnetwork analysis. for simplicity we abstract from this and
consider just activity names. moreover, we focus on c-nets
as a target model. this allows us to restrict the notion ofprocess mining to the discovery of a c-net from a multiset
of traces.
deﬁnition 7 (mining algorithm): let𝐿be an event
log. a mining algorithm 𝜇derives a process model from
such an event log, i.e., 𝜇(𝐿)=(𝐴,𝑎
𝑖,𝑎𝑜,𝐷,𝐼,𝑂 )when
c-nets are used as a target model.
process discovery algorithms can discover models
such as the one shown in fig. 3 from event logs
such as 𝐿travel =[⟨𝑎,𝑏,𝑒⟩8,⟨𝑎,𝑐,𝑒⟩11,⟨𝑎,𝑏,𝑑,𝑒 ⟩30,
⟨𝑎,𝑑,𝑏,𝑒 ⟩22,⟨𝑎,𝑏,𝑐,𝑑,𝑒 ⟩7,⟨𝑎,𝑏,𝑑,𝑐,𝑒 ⟩12,⟨𝑎,𝑑,𝑏,𝑐,𝑒 ⟩9],
i.e.,𝜇(𝐿travel )=𝐶travel .
various process discovery algorithms have been pro-
posed in literature (see [4] for an overview). these al-
gorithms use techniques varying from genetic algorithms
to region-based approaches. there are different ways todeﬁne the quality of the discovered process model, e.g.,
ﬁtness measures the fraction of the event log that can be
“replayed” by the event log.
deﬁnition 8 (fitness): let𝐿be an event log and 𝐶a
discovered process model. a ﬁtness function 𝜋measures
the quality of the model with respect to the log. for
example, a naive ﬁtness function is 𝜋(𝐿,𝐶 )=# [ 𝜎∈
𝐿∣∃
𝜎′∈𝑉(𝐶)𝛼(𝜎′)=𝜎]/#𝐿.
various ﬁtness notions have been proposed. the ex-
ample function 𝜋(𝐿,𝐶 )given in deﬁnition 7 simply
measures the fraction of traces that correspond to valid
binding sequences. a single deviating event in a long trace
that has no other deviations results in a non-ﬁtting case.
hence, the metric cannot distinguish between an almostﬁtting trace and a trace consisting of many deviating
events. therefore, most notions measure ﬁtness at the
level of events [4], [15]. moreover, ﬁtness is just onedimension. in general, there is a trade-off between the
following four quality criteria: (a) ﬁtness : the discovered
model should allow for the behavior seen in the event log,(b)precision : the discovered model should not allow for
behavior completely unrelated to what was seen in the
event log, (c) generalization : the discovered model should
generalize the example behavior seen in the event log, and
(d)simplicity : the discovered model should be as simple
as possible.
traditionally, process mining techniques are applied to
one event log originating from some process, i.e., the focusis on a single log. in the context of conﬁgurable/multi-
tenant processes, we need to compare the event logs
and models of different organizations. as clouds providean infrastructure to systematically collect events, cross-
organizational analysis comes into reach.
vi. c
hallenges and opportunities
after introducing c-nets as a representation for process
conﬁguration and process mining, we now discuss the
challenges and opportunities associated to multi-tenantprocesses in the cloud. fig. 6 is used to structure the
discussion. assume there are 𝑛variants of the same
process running in parallel. we refer to these processesas𝑃
1,𝑃2,...𝑃 𝑛. these processes generate event logs
𝐿1,𝐿2,...𝐿 𝑛. the corresponding process models are
𝐶1,𝐶2,...𝐶 𝑛. a process model 𝐶𝑖may have been made
by hand or has been discovered from event log 𝐿𝑖(for
1≤𝑖≤𝑛). in the latter case: 𝐶𝑖=𝜇(𝐿𝑖).t o
simplify the discussion, we assume that 𝐶𝑖is a c-net
as deﬁned in deﬁnition 1 and 𝐿𝑖is an event log as
deﬁned in deﬁnition 6. note that in reality event logswill contain much more information and process models
also describe resources, data ﬂow, routing conditions,
triggers, etc. [4]. fig. 6 shows for each process 𝑃
𝑖an
event log 𝐿𝑖and process model 𝐶𝑖. the different process
models can be merged into an overall conﬁgurable model
𝐶all=𝐶1⊎𝐶2⊎...⊎𝐶𝑛. the overall event log covering
all variants can be obtained my merging the individual
event logs: 𝐿all=𝐿1⊎𝐿2⊎...⊎𝐿𝑛. an alternative way to
get the overall conﬁgurable model is via discovery basedon the merged event log, i.e., 𝐶
all=𝜇(𝐿all). assuming
that the processes have been running for a while, it is also
possible to extract key performance indicators (kpis) andcompare these among different variants. the small meter-
like symbols in fig. 6 refer to these kpis.
a. capturing variability into a single conﬁgurable model
as indicated in section iv, a conﬁgurable model de-
scribes a family of processes 𝒞={𝐶⊑𝐶
𝑏∣𝐵(𝐶)}
where 𝐵is a boolean expression over a c-nets that are
contained in some base model 𝐶𝑏. to simplify discussion,
we referred to 𝐶𝑏as if it is the conﬁgurable model. in
reality, it is more difﬁcult to describe a conﬁgurable model.
first of all, the model should also take other perspectivesinto account. second, it is non-trivial to describe the
possible conﬁgurations in an intuitive manner. consider
for example a set of rather sequential process variantsthat do not agree on the ordering of most activities. the
resulting model will be spaghetti-like and it is still unclear
how to address this problem properly [1], [6], [7].process 1event
log 1process
model 1
process 2event
log 2process
model 2
process nevent
lognprocess
model n... ... ...(configurable)
process model
event logc
c
c
figure 6. overview of the different challenges and connections between
conﬁgurable/conﬁgured models and event logs.
b. analyzing conﬁgurable process models
traditionally, analysis techniques focus on the analysis
of a single process model. conﬁgurable process modelsdeﬁne a family of process models. therefore, analysis
becomes more challenging. for example, in [7] we show
how to compute a so-called “conﬁguration guideline” thatallows for the analysis of potential problems at design
time. the conﬁguration guideline also enables new func-
tionality such as “auto-completing” a partially conﬁguredmodel (taking data dependencies into account).
c. learning conﬁgurable models
as fig. 6 shows there are basically two ways to obtain
a conﬁgurable model. one approach is to merge the
different models: 𝐶
all=𝐶1⊎𝐶2⊎...⊎𝐶𝑛. another
approach is to merge the individual event logs into one log𝐿
all=𝐿1⊎𝐿2⊎...⊎𝐿𝑛and then apply some process
discovery algorithm 𝐶all=𝜇(𝐿all). for c-nets this is
relatively simple provided that the various “ingredients”(event logs, models, etc.) are available and of high quality.
in practice, these assumptions often do not hold, thus
making the problem challenging. moreover, it will rarelybe the case that 𝜇(𝐿
all)or𝐶1⊎𝐶2⊎...⊎𝐶𝑛will be
taken as the deﬁnitive conﬁgurable model as the goal is to
capture “best practices”. undesirable features of particular
processes may be left out or processes are uniﬁed to “ﬁght
complexity”.
d. conformance checking
given an event log 𝐿and a process model 𝐶,w e
can check the conformance of both. for example, we
can measure ﬁtness 𝜋(𝐿,𝐶 ), i.e., the fraction of the
event log that is possible according to the model (can be
deﬁned in different ways [4]). in the phase where oneis building a conﬁgurable model 𝐶, it is interesting to
see how good 𝐶ﬁts the event log of each individual
organization, i.e., measure 𝜋(𝐿
𝑖,𝐶)for1≤𝑖≤𝑛.
this will show which organizations are most affected
by (changes to) the conﬁgurable model. note that the
goal is not to simply merge all existing behaviors; theconﬁgurable model should capture “best practices” while
still allowing for the “couleur locale” required by the
individual organizations.
conformance checking techniques [4], [15] analyze be-
havioral differences between a log and model, i.e., log-to-
model comparison. however, it is also possible to compare
two models or two logs. model-to-model comparison can
be used to analyze the differences between the individual
process models 𝐶1,𝐶2,...𝐶 𝑛or differences between the
conﬁgurable model 𝐶and a speciﬁc process model 𝐶𝑖.
log-to-log comparison can be used to compare the dif-
ferent processes based on their event logs. for example,
one can ﬁnd that 𝐿𝑖and𝐿𝑗are most similar or that the
behavior of 𝐿𝑖is contained in 𝐿𝑗.
e. cross-tenant process mining
having event logs from different organizations in
a format that allows for comparison, enables cross-
organizational process mining. the service provider that
is supporting processes for different organizations (e.g.salesforce or easychair) is interested in knowing how
organizations are using the common infrastructure. com-
parative analysis may lead to additional services (e.g.,guidance of end-user organizations) or to changes to the
conﬁgurable model. in the coselog project [3], [16],
[17] we experienced that organizations are interested in
learning from each other. in this project, 10 of the 430
dutch municipalities are participating to investigate howcloud technology can be used to reduce costs and improve
service. all dutch municipalities need to offer the same
services to their citizens, and need to manage similarcollections of processes. however, due to demographics
and political choices, municipalities are handling things
differently. therefore, process conﬁguration is important.moreover, municipalities are not in competition with
one another. in fact, the ten municipalities involved in
coselog are eager to learn “proven best practices” fromone another. this can be operationalized using cross-
organizational process mining [17].
besides a pair-wise comparison of logs and models, we
can also use supervised learning to explain differences.for example, we can use classiﬁcation techniques such as
decision tree learning. for this purpose we need to label
the data at the level of cases or at the level of event logs.classiﬁcation is based on a selected response variable and
a set of predictor variables . for example, the response
variable could be the (average) ﬂow time or costs of acase or log. the ﬁtness of an event log or case with
respect to some reference model can also be taken as a
response variable. predictor variables are other properties
of cases, event logs, or process models. for example,
the complexity of the process model and the number orresources involved. based on such information one can
construct a decision tree that aims to explain the response
variable in terms of predictor variables . for example,
classiﬁcation based on logs of different municipalities may
reveal that (a) larger municipalities tend to have fewer
deviations, (b) allowing for more concurrency results inshorter ﬂow times but more deviations, and (c) a pre-
check of building permits results in shorter ﬂow times and
a higher acceptance rate.
vii. c onclusion
emerging cloud infrastructures provide new opportu-
nities for sharing processes and allow for new typesof analysis such as cross-organizational process mining.
when organizations share processes in the cloud, we
refer to these as multi-tenant processes. however, differentorganizations have different requirements. therefore, the
cloud infrastructure needs to support variants of the same
process. in product software installed locally (e.g., sap), itis common practice to customize the system in a rather ad-
hoc manner. clearly, this is unacceptable in a cloud setting.
therefore, we advocated the need for conﬁgurable processmodels. once different variants of the same conﬁgurable
model are running in the cloud, events are recorded in
a systematic manner and it becomes relatively easy tocompare these variants using cross-organizational mining.
in this paper, we advocated the use of causal nets (c-
nets) for process conﬁguration and mining. this represen-
tation emerged from the process mining domain [4]. as
shown, essential operators such as merging two models𝐶
1⊎𝐶2and checking containment 𝐶1⊑𝐶2can be deﬁned
without the traditional complications (e.g., dealing with
deadlock and other anomalies). although c-nets are closeto existing languages having and/xor/or-splits/joins,
their semantics are deﬁned in terms valid binding se-
quences. these semantics simplify both conﬁguration andprocess mining.
a
cknowledgments
the author would like to thank marcello la rosa,
florian gottschalk, niels lohmann, michael rosemann,
jan v ogelaar, marlon dumas, eric verbeek, boudewijn
van dongen, joos buijs, and hajo reijers for their workon conﬁgurable models (c-y awl, c-epc, etc.) and their
involvement in the coselog project.
r
eferences
[1] m. rosemann and w. van der aalst, “a conﬁgurable ref-
erence modelling language,” information systems , vol. 32,
no. 1, pp. 1–23, 2007.
[2] f. gottschalk, w. van der aalst, m. jansen-vullers, and
m. l. rosa, “conﬁgurable workﬂow models,” interna-
tional journal of cooperative information systems , vol. 17,
no. 2, pp. 177–221, 2008.
[3] w. van der aalst, “conﬁgurable services in the cloud: sup-
porting variability while enabling cross-organizationalprocess mining,” in coopis 2010 , lecture notes in com-
puter science, vol. 6426. springer-verlag, berlin, 2010,pp. 8–25.
[4] w. van der aalst, process mining: discovery, conformance
and enhancement of business processes . springer-verlag,
berlin, 2011.[5] f. gottschalk, t. wagemakers, m. jansen-vullers,
w. van der aalst, and m. la rosa, “conﬁgurable processmodels: experiences from a municipality case study,” incaise’09 , lecture notes in computer science, vol. 5565.
springer-verlag, berlin, 2009, pp. 486–500.
[6] w. van der aalst, m. dumas, f. gottschalk, a. ter hofstede,
m. la rosa, and j. mendling, “preserving correctnessduring business process model conﬁguration,” formal
aspects of computing , vol. 22, no. 3, pp. 459–482, 2010.
[7] w. van der aalst, n. lohmann, m. la rosa, and j. xu,
“correctness ensuring process conﬁguration: an ap-proach based on partner synthesis,” in business process
management (bpm 2010) , ser. lecture notes in computer
science, r. hull, j. mendling, and s. tai, eds., vol. 6336.springer-verlag, berlin, 2010, pp. 95–111.
[8] j. becker, p. delfmann, and r. knackstedt, “adaptive
reference modeling: integrating conﬁgurative and genericadaptation techniques for information models,” in ref-
erence modeling: efﬁcient information systems designthrough reuse of information models , physica-verlag,
springer, 2007, pp. 27–58.
[9] a. hallerbach, t. bauer, and m. reichert, “capturing vari-
ability in business process models: the provop approach,”journal of software maintenance and evolution: researchand practice , vol. 22, no. 6-7, pp. 519–546, 2010.
[10] i. reinhartz-berger, p. soffer, and a. sturm, “extending
the adaptability of reference models,” ieee transactions
on systems, man and cybernetics - part a: systems andhumans , vol. 40, no. 5, pp. 1045–1056, 2011.
[11] f. gottschalk, w. van der aalst, and m. jansen-vullers,
“conﬁgurable process models: a foundational approach,”inreference modeling: efﬁcient information systems de-
sign through reuse of information models , physica-verlag,
springer, 2007, pp. 59–78.
[12] w. van der aalst and t. basten, “inheritance of workﬂows:
an approach to tackling problems related to change,”theoretical computer science , vol. 270, no. 1-2, pp. 125–
203, 2002.
[13] w. van der aalst, “do petri nets provide the right rep-
resentational bias for process mining?” in workshop ap-
plications of region theory 2011 (art 2011) ,s e r .c e u r
workshop proceedings, j. desel and a. yakovlev, eds., vol.725. ceur-ws.org, 2011, pp. 85–94.
[14] w. van der aalst, a. adriansyah, and b. van dongen,
“causal nets: a modeling language tailored towardsprocess discovery,” in 22nd international conference on
concurrency theory (concur 2011) , ser. lecture notes
in computer science, j. katoen and b. koenig, eds.springer-verlag, berlin, 2011.
[15] a. rozinat and w. van der aalst, “conformance checking
of processes based on monitoring real behavior,” infor-
mation systems , vol. 33, no. 1, pp. 64–95, 2008.
[16] coselog, “conﬁgurable services for local governments
(coselog) project home page,” www.win.tue.nl/coselog.
[17] j. buijs, b. van dongen, and w. van der aalst, “to-
wards cross-organizational process mining in collectionsof process models and their executions,” in international
workshop on process model collections (pmc 2011) .
springer-verlag, berlin, 2011.