int j data sci anal
doi 10.1007/s41060-017-0078-6
regular paper
online conformance checking: relating event streams to process
models using preﬁx-alignments
sebastiaan j. van zelst1·alfredo bolt1·marwan hassani1·
boudewijn f. van dongen1·wil m. p. van der aalst1
received: 26 may 2017 / accepted: 11 october 2017
© the author(s) 2017. this article is an open access publication
abstract companies often specify the intended behaviour
of their business processes in a process model. conformance
checking techniques allow us to assess to what degree such
process models and corresponding process execution data
correspond to one another. in recent years, alignments have
proven extremely useful for calculating conformance check-
ing statistics. existing techniques to compute alignments
have been developed to be used in an ofﬂine, a posteriori
setting. however, we are often interested in observing devi-
ations at the moment they occur, rather than days, weeks or
even months later. hence, we need techniques that enable
us to perform conformance checking in an online setting. in
this paper, we present a novel approach to incrementally com-
pute preﬁx-alignments, paving the way for real-time online
conformance checking. our experiments show that the reuse
of previously computed preﬁx-alignments enhances mem-
ory efﬁciency, whilst preserving preﬁx-alignment optimality.
moreover, we show that, in case of computing approximate
preﬁx-alignments, there is a clear trade-off between memory
efﬁciency and approximation error.
b sebastiaan j. van zelst
s.j.v.zelst@tue.nl
alfredo bolt
a.bolt@tue.nl
marwan hassani
m.hassani@tue.nl
boudewijn f. van dongen
b.f.v.dongen@tue.nl
wil m. p . van der aalst
w.m.p.v.d.aalst@tue.nl
1department of mathematics and computer science,
eindhoven university of technology, p .o. box 513, 5600 mb
eindhoven, the netherlandskeywords process mining ·conformance checking ·event
streams
1 introduction
today’s information systems track, in great detail, the exe-
cution of business processes within companies. often, a
company has an idea, or even a formal speciﬁcation, of how
their business process is required to be executed. in other
cases, laws, regulations and/or legislations dictate the exact
way the process is to be executed. such process speciﬁca-
tion is often recorded in a process model, i.e. a behavioural
speciﬁcation. however, in many cases, the actual execution
of the process, as recorded by the information system, is
not in line with the behaviour described by the correspond-
ing process model. conformance checking , a sub-ﬁeld of
process mining [1], aims at assessing to what degree the
behaviour described by a process model is in line with
behaviour captured in an event log. in particular, the tech-
niques are able to check conformance based on process
modelling formalisms that allow for describing concurrency ,
i.e. the possibility to specify order-independent execution of
activities.
early conformance checking techniques, e.g. “token-
based replay” [ 2], often lead to ambiguous and/or unpre-
dictable results. hence, alignments [3] were developed with
the speciﬁc goal in mind to explain and quantify devia-
tions in a non-ambiguous manner. alignments have rapidly
developed into the de facto standard conformance check-
ing technique. moreover, alignments serve as a basis for
techniques that link event data to process models, e.g.
they support performance analysis, decision mining [ 4],
business process model repair [ 5] and prediction tech-
niques.
123i n tjd a t as c ia n a l
fig. 1 schematic overview of
online conformance checking
information systemtime
event streamevent
event
eventc1
c2
...
cn
...process model
preﬁx-alignments
(a, t1),(b, t2), ...
(b, ),(a, t1), ...
...
(a, t1)
...cases
{activity boccurred
prior to activity a
techniques to compute alignments are only deﬁned in
an ofﬂine setting. however, early process-oriented devia-
tion detection is critical for many organizations in different
domains. for example, within hospitals, deviating process
executions often lead to higher costs, and/or delays in exam-
ination time. similarly, within highly complex administrativeprocesses, e.g. provision of mortgages, notary processes and
unemployment administration, deviant behaviour often leads
to excessive process execution time and costs. upon detectionof a deviation, a process owner, or the supporting informa-tion system, is able to take adequate actions such as blocking
the current process instance, assigning a case manager for
additional specialized intervention and restarting the processinstance.
in this paper, we present a new approach to com-
pute alignment-based conformance checking statistics in anonline setting. instead of conventionally used event logs ,
i.e. a static data source describing past process execution
behaviour, we rely on event streams . an event stream is a con-
tinuous data stream that describes a potentially unboundedsequence of events. the fundamental difference of event
streams w.r.t. event logs is related to the fact that the knowl-
edge of executed events for a case changes over time, i.e. newevents related to the same case can occur in the future. hence,
at any point in time, we are unaware whether the sequence of
events observed for a certain case is complete or not. as a con-sequence, we aim at computing preﬁx-alignments rather than
conventional alignments as they describe the events observed
for a case in the best possible way w.r.t. the reference modelwithout requiring explicit termination. in fig. 1, we present
a schematic overview of online conformance checking. we
have two main sources of input, i.e. an event stream gen-
erated by an information system and a reference processmodel. over time, we observe events emitted on the event
stream which tell us what activity has been performed in
context of what case. for each case we maintain a preﬁx-alignment. whenever we receive a new event for a case, werecompute its preﬁx-alignment. we try to recompute preﬁx-
alignments greedily; however, in some cases we need to resort
to solving a shortest path problem. the focus of this paper ismainly towards the efﬁciency of solving such shortest prob-
lem.
our proposed approach entails an incremental algorithm
that allows for computing both optimal and approximate
preﬁx-alignments. we additionally show that the cost of
an optimal preﬁx-alignment is always an underestimate forthe cost of a conventional alignment of any of its possiblesufﬁxes. as a consequence, when computing optimal preﬁx-
alignments, our approach underestimates alignment costs for
completed cases. this implies that once we detect a devia-tion from the reference model, we are guaranteed that the
behaviour related to the case is not compliant with the refer-
ence model. computing approximate preﬁx-alignments leadsto an increase in memory efﬁciency, however, at the cost of
losing preﬁx-alignment optimality. we experimentally assess
the trade-off between memory efﬁciency and optimality lossusing several artiﬁcially generated process models. we addi-tionally assess the applicability of our technique using a real
data set originating from a hospital information system. our
experiments show that reusing previously computed preﬁx-alignments positively impacts the efﬁciency of computing
new preﬁx-alignments. moreover, in case of approximation,
we observe a clear trade-off between memory usage and pre-ﬁx alignment optimality loss.
the remainder of this paper is structured as follows: in
sect. 2, we present related work. in sect. 3, we present
background concepts. in sect. 4, we introduce event streams
and motivate the need for computing preﬁx-alignments. in
sect. 5, we present our incremental algorithm for preﬁx-
alignment computation together with two memory optimiza-tion techniques. in sect. 6, we evaluate the proposed approach
in terms of performance and approximation accuracy. in
sect. 7, we provide a discussion of the proposed approach.
section 8concludes the paper.
123int j data sci anal
2 related work
a plethora of different process mining techniques exists,
ranging from discovery to prediction. however, given the
focus of this paper, we limit related work to the ﬁeld ofalignment computation and online process mining. hence,we refer to [ 1] for an overview of different process mining
techniques.
early work in conformance checking uses token-based
replay [ 2]. the techniques replay a trace of executed events
in a process model (petri net) and add missing tokens if tran-
sitions are not able to ﬁre. after replay, remaining tokensare counted and a conformance statistic is computed based
on missing and remaining tokens. alignments were intro-
duced in [ 3] and have rapidly developed into the de facto
standard for conformance checking. in [ 6,7], decomposition
techniques are proposed together with computing align-
ments. using decomposition techniques greatly enhances
computation time, i.e. the techniques successfully applythe divide-and-conquer paradigm; however, the techniques
provide lower bounds on conformance checking statistics,
rather than computing alignments. more recently, generalapproximation schemes for alignments, i.e. computation of
near-optimal alignments, have been proposed in [ 8].
a relatively limited amount of work has been done in the
area of online process mining. in [ 9] ,aﬁ r s td e s i g no fa n
online process discovery algorithm was proposed, based on
the heuristic miner [ 10]. the approach was improved in [ 11]
by adopting a different internal storage model. in [ 12], the
work was generalized and converted in an architecture that
covers a wide range of process discovery algorithms. in [ 13],
an alternative discovery approach is presented for the purposeof discovering declarative process models.
to the best of our knowledge this paper is the ﬁrst work
that covers conformance checking/alignments in online/incremental settings.
3 background
in this section, we brieﬂy present key process mining con-cepts such as event logs ,workﬂow nets andalignments .w e
assume the reader to be familiar with mathematical conceptssuch as sets, multisets, functions and sequences. we only
present notational conventions regarding these concepts, as
used in this paper.
given set xand y/∈xwe write x
yforx∪{y}.n
denotes the set of natural numbers, n0includes 0. a multiset
generalizes the concept of a set and allows elements to havea multiplicity exceeding one. let x={e
1,e2,..., en}be
a set, a multiset mover xis a function m:x→n0.w e
write a multiset as m=[ek1
1,ek2
2,..., ekmm](m≤n), where
for each i∈{1,..., m}we have m(ei)=ki.i fm(ei)=0,we omit eifrom multiset notation, and, if m(ei)=1w e
omit ei’s superscript. we write sequence σof length nas
σ=/angbracketleftσ(1),σ( 2) ,...,σ( n)/angbracketright, where for 1 ≤i≤n,σ(i)
denotes the ith element of σ. the set of all possible sequences
over xis written as x∗. concatenation of sequences σ1and
σ2is written as σ1·σ2. an empty sequence is written as /epsilon1.
given a sequence σ∈(x1×x2×···× xn)∗we deﬁne,
for 1≤i≤n,πi(σ)∈x∗
iwithπi(σ)( j)=σ(j)(i),∀j∈
{1,2,...,|σ|},e . g .g i v e n σ∈(x×y)∗,w eh a v e π1(σ)∈
x∗andπ2(σ)∈y∗.g i v e n σ∈x∗and y⊆xwe deﬁne
σ↓y∈y∗recursively with /epsilon1↓y=/epsilon1and(/angbracketleftx/angbracketright·σ/prime)↓y=
/angbracketleftx/angbracketright·σ/prime
↓yifx∈yandσ/prime
↓yifx/∈y.
3.1 event logs and process models
the execution of business processes within a company gener-
ates traces of event data in its supporting information system.
typically we are able to extract such data from the com-
pany’s information system describing, for speciﬁc cases, e.g.an insurance claim, what activities have been performed over
time. we often refer to a collection of such data as an event
log. from a formal perspective, an event log is considered to
be a multiset of sequences of executed process activities, orsimply events . consider table 1, which depicts a simpliﬁed
view of an event log. the event log describes the execution of
activities related to a ﬁctional compensation request processfor concert tickets. for example, consider all events related to
case 13 (represented by case-id 13), i.e. a new request is reg-
istered byluke ,harry subsequently examines the request,
pete checks the corresponding ticket ,e t c .
for each event recorded in the event log, we have infor-
mation regarding its id, what activity it related to, which
resource executed the activity and at what time it was exe-
cuted. in general, we are able to obtain even more event
data, for example what is the corresponding ticket id , what
concert the ticket belongs to, what is the ticket price ,e t c .
however, for the sake of simplicity we abstract from such
data. in particular, in context of this paper, we are only inter-
ested in actual activities performed, instead of all possibledata/resource aspects involved in the activity execution, i.e.
we focus on the control-ﬂow perspective . for example, based
on table 1we deduce that for case 13, the sequence /angbracketleftregister
request ,examine ,check ticket ,decide ,pay compensation /angbracketright
was performed. we assume the execution of activities to be
atomic; hence, given the universe of activities a, an event
loglis a multiset over sequences of a, i.e. l:a
∗→n0.
a process model describes the intended behaviour of a
process. although many process modelling formalisms exist,
we focus on (labelled) petri nets [ 14], which allow us to
explicitly model concurrency in a concise and compact man-
ner. in fig. 2, we depict an example petri net. the petri net,
like the example event log in table 1, describes handling of
a compensation request. it dictates that the ﬁrst activity to be
123i n tjd a t as c ia n a l
table 1 example event log
fragmentevent-id case-id activity resource time-stamp
... ... ... ... ...
5 12 decide (d) boris 2017-05-08 09:45
6 13 register request (a) luke 2017-05-08 10:12
7 12 update records (h) harry 2017-05-08 10:14
8 13 examine (b) harry 2017-05-08 10:31
9 13 check ticket (c) pete 2017-05-08 10:40
10 13 decide (d) harry 2017-05-08 10:49
11 13 pay compensation (e) harry 2017-05-08 11:01
12 14 register request (a) boris 2017-05-08 11:03
... ... ... ... ...
fig. 2 example petri net n1
(adopted from [ 1]) with initial
marking [pi]
pi t1aregister
requestp1
t2bexamine
p2 t3ccheck ticketp3
p4t5ddecidet4ddecide
p5
t6ft7epaycompensation
t8
f
reject requestpo
performed should always be register request . subsequently,
theexamine andcheck ticket activities can be performed con-
currently. however, we are also allowed to only perform thecheck ticket activity and subsequently make a decision, i.e. toskip the examination. after a decision is made, we are able to
redo the examination and ticket check. however, such deci-
sion, i.e. to redo these activities, is not explicitly captured bythe system. eventually, either the pay compensation or the
reject request activity is performed.
a petri net consists of places and transitions . places are
used to represent the state of the described process, whereas
transitions represent possible executable activities, subject to
the state. the petri net in fig. 2consists of 7 places (denoted
p), i.e. p={p
i,p1,..., p5,po}, visualized as circles. for-
mally, we represent the state of a petri net in terms of a
marking m , which is a multiset of places, i.e. m:p→n0.
for example, in fig. 2place piismarked with a token ,v i s u -
alized by a black dot. thus, the marking of the petri net in
fig. 2, as visualized, is [pi]. the petri net furthermore con-
tains 8 transitions (denoted t), i.e. {t1,..., t8}, visualized
as boxes. transitions allow us to manipulate a petri net’s
marking. a transition t∈tisenabled if all places pthat
have an outgoing arc to tcontain a token. if a transition is
enabled in marking m, we write m[t/angbracketright. an enabled transition
is able to ﬁre. if we ﬁre a transition t, it consumes a token
from each place that has an outgoing arc to t. subsequently,a token is produced in each place that has an incoming arc
from t. for example, in fig. 2,t1is the only enabled transi-
tion in marking [p0], and, if it ﬁres we obtain new marking
[p1,p2]. in marking [p1,p2],w ea r ea b l et oﬁ r eb o t h t2and
t3, in any order. we are thus able to generate sequences of
ﬁred transitions, e.g. /angbracketleftt1,t2,t3/angbracketrightand/angbracketleftt1,t3,t2/angbracketright, which both
yield marking [p3,p4]. note that, in marking [p1,p2], tran-
sition t4is not (yet) enabled. if we ﬁre t3, leading to marking
[p1,p4], transition t4is enabled. when executing a sequence
σ∈t∗of transitions from marking mresults in m/prime,w e
write mσ−→m/prime.w el e t mdenote the universe of all possi-
ble markings.
all transitions, except transition t6, have a single character
label , e.g. transition t1has label a. typically, these labels
represent actual activities that can be executed in the processdescribed by the petri net. for convenience, we also added
more descriptive names, e.g. register request . transition t
6is
aninvisible transition , i.e. it is able to manipulate the marking
of the petri net, without being noticed by the outside world.also, there are two transitions with label d, i.e. t
4andt5.
we formally deﬁne a petri net nas a tuple n=
(p,t,f,λ), where prepresents its places, tits transitions,
f⊆(p×t)∪(t×p)represents the ﬂow relation, i.e.
the arcs in fig. 2. observe that a place is only connected to
a transition and vice versa, i.e. there is never an arc betweentwo places/transitions. finally, given a set of activity labels
123int j data sci anal
γ1:a b c d e
t1 t2 t3 t5 t7γ2:x a d e z
t1 t3 t4 t7
fig. 3 example alignments for /angbracketlefta,b,c,d,e/angbracketrightand/angbracketleftx,a,d,e,z/angbracketrightwith
n1
λandτ/∈λ,λ:t→λτrepresents the labelling function
ofn. for example, λ(t1)=aandλ(t6)=τ.
we assume that a reference model of a process is designed
by a human business process analyst/designer. we thereforeassume that a process model has a certain level of quality, e.g.the petri net is a sound workﬂow net [15, deﬁnition 7]. we
do not introduce the characteristics of such models, however,
soundness guarantees that we are always able to reach a des-ignated ﬁnal marking m
f,f r o ma n ym a r k i n g mreachable
from designated initial marking mi. for the purpose of this
paper, we assume that the petri nets we consider also con-sist of this property, which we deem the proper termination
assumption .
3.2 alignments
when we reconsider the example sequence of activities
related to case 13, i.e. written short-hand as /angbracketlefta,b,c,d,e/angbracketright,
we observe that indeed by ﬁring transitions t
1,t2,t3,t5and
t7, such sequence of activities is produced by n1in fig. 2.
if we consider another example trace, i.e. /angbracketleftx,a,d,e,z/angbracketright,w e
observe some problems. for example, activities xand zare
not labels of n1. furthermore, according to n1,a tl e a s t c
must be executed in-between aandd.
alignments allow us to identify and quantify the afore-
mentioned problems and moreover allow us to express these
deviations in terms of the reference model. conceptually,
an alignment is a mapping between the execution of transi-tions in the process model and the activities observed in atraceσin a given event log l. consider fig. 3, in which we
present alignments for traces /angbracketlefta,b,c,d,e/angbracketrightand/angbracketleftx,a,d,e,z/angbracketright
w.r.t. petri net n
1. alignments are sequences of pairs, e.g.
γ1=/angbracketleft(a,t1),(b,t2),...,( e,t7)/angbracketright. each pair within an align-
ment is referred to as a move . the ﬁrst element of a move
refers to an activity of the trace, whereas the second elementrefers to a transition. the goal is to create pairs of the form
(a,t)s.t.λ(t)=a,e . g .a l lm o v e si n γ
1are of this form. the
sequence of activity labels in the alignment needs to equalthe input trace. the sequence of transitions in the alignmentneeds to correspond to a σ∈t
∗s.t., given a designated ini-
tial marking miand ﬁnal marking mf,w eh a v e miσ−→mf.
forn1,w eh a v e mi=[pi]and mf=[po]. in some cases,
we are not able to construct a move of the form (a,t)s.t.
λ(t)=a. in case of trace /angbracketleftx,a,d,e,z/angbracketright, we are not able tomap xand zto any transition in n1with an equally valued
label. furthermore, we at least need to execute transition t3in
order to form a sequence of transitions that generates marking
mffrom mi. in some cases we need to ﬁre a transition twith
λ(t)=τ, for which we again are not able to construct a label-
transition mapping. in such cases, we use skip-symbol /greatermuchin
either the activity or the transition part of a move. for exam-
ple, consider γ2in fig. 3, which contains three skip symbols.
v erify that again, when ignoring skip symbols, the sequenceof activity labels equals the input trace, and the sequence of
transitions is valid for m
iand mf. if a move is of the form
(a,t), we call this a synchronous move ,(a,/greatermuch)is an activity
move and(/greatermuch,a)is amodel move .
deﬁnition 1 (alignment )l e tσ∈a∗.l e t n=(p,t,f,λ)
be a petri net and let mi,mfdenote n/primesinitial and ﬁnal
marking. let /greatermuch/∈a∪t∪λwith/greatermuch/negationslash=τ. a sequence
γ∈(a/greatermuch×t/greatermuch)∗is an alignment iff:
1.(π1(γ))↓a=σ; activity part (excluding /greatermuch’s) equals σ.
2.mi(π2(γ))↓t−−−−−− →mf; transition part (excluding /greatermuch’s) in
petri net language.
3.∀(a,t)∈γ(a/negationslash=/greatermuch ∨ t/negationslash=/greatermuch);(/greatermuch,/greatermuch)is not valid in an align-
ment.
we let γdenote the universe of alignments, and let γ(n,
σ,mi,mf)denote all alignments of nandσgiven miand
mf.
given the deﬁnition of alignments as presented in deﬁni-
tion 1, several alignments, i.e. sequences of moves adhering
to deﬁnition 1, exist for a given trace and petri net. for
example, consider alignment γ3depicted in fig. 4which,
according to deﬁnition 1, is an alignment of /angbracketleftx,a,d,e,z/angbracketright
and n1as well. the main difference between γ2andγ3,
i.e. both aligning trace /angbracketleftx,a,d,e,z/angbracketrightwith n1, is the fact
thatγ2binds the execution of t4to the observed activity d,
whereas γ3binds the execution of t5to the observed activity
d. clearly, both explanations are possible, however, to be able
to bind executed activity dtot5, and alignment γ3requires
the explicit execution of transition t2as well. since activity
bis not observed in the given trace, we observe the presence
of move (/greatermuch,t2)inγ3, which is not needed in γ2. both align-
ments are feasible; however, we prefer alignment γ2overγ3
as it minimizes non-synchronous moves, i.e. moves of the
form(a,/greatermuch)or(/greatermuch,t).
as exempliﬁed by alignments γ2andγ3, we need means
to be able to rank and compare alignments and somehow
express our preference of certain alignments w.r.t. others.to this end, we deﬁne a cost function over the moves of
fig. 4 two possible alignments
for/angbracketleftx,a,d,e,z/angbracketrightand n1γ2:x a d e z
t1 t3 t4 t7γ3:x a d e z
t1 t2 t3 t5 t7
123i n tjd a t as c ia n a l
an alignment. the cost of an alignment is simply the sum
of the costs of its individual moves. typically synchronousmoves are assigned a low, or even 0, cost. the costs of model
and activity moves are usually higher than the costs of syn-
chronous moves. assume we assign cost 0 to synchronousmoves and cost 1 to activity/model moves. in this case, thecost of γ
1is 0. the cost of alignment γ2is 3, whereas the
cost of alignment γ3is 4. hence, the cost of γ2is lower than
the cost of γ3, and we prefer it over γ2. formally, we deﬁne
the cost of a move as a function δ:a/greatermuch×t/greatermuch→r0.t h e
costsκδof a sequence of moves γ, given move cost func-
tionδ, are deﬁned as κδ(γ)=/summationtext|γ|
i=1δ(γ( i)). in general,
we are able to use an arbitrary instantiation of δ; however,
in the remainder of the paper, we adopt the unit-cost func-
tion:
1.δ(a,t)=0⇔a∈a,t∈tandλ(t)=aora=/greatermuch,t∈
tandλ(t)=τ,
2.δ(a,t)=∞⇔ a∈a,t∈tandλ(t)/negationslash=a,
3.δ(a,t)=1 otherwise.
since we assume unit-costs throughout the paper, we omit δ
as superscript and simply refer to κ(γ) . we write γoptto refer
toan optimal alignment , i.e.γopt=arg minγ∈γ(n,σ,mi,mf)
κ(γ) . consequently, computing an optimal alignment is sim-
ply deﬁned as a minimization problem. in [ 3], it is shown
that computing an optimal alignment is equivalent to solvingashortest path problem on the state space of the syn-
chronous product net of n and σ. the exact nature of such
synchronous product net and an equivalence proof of thetwo problems is outside the scope of this paper. hence,we refer to [ 3] for these deﬁnitions and proofs. in this
paper, we use the fact that an algorithm to ﬁnd an opti-
mal alignment exists and we use it as a black box. finally,it is important to note that multiple optimal alignments
exist.
4 computing preﬁx-alignments on event streams
we aim at computing conformance checking statistics inan online fashion in order to observe deviations at the
moment they occur. hence, we deﬁne the notion of eventstreams. subsequently, we motivate why computing conven-
tional alignments on event streams overestimate the potential
deviation severity, and therefore, we resort to computingpreﬁx-alignments .4.1 event streams
formally, an event stream is a, possibly inﬁnite, sequence of
events. an event is a pair consisting of a case-identiﬁer and
anactivity . an event describes what activity is performed in
context of what process instance (represented by the case-identiﬁer). event streams differ from event logs in two ways:
(1) an event stream is potentially inﬁnite and (2) behaviour
seen for a case is incomplete , i.e. in future new events may
be executed in context of a case.
deﬁnition 2 (event stream )l e t cdenote the universe of
case identiﬁers. let adenote the universe of possible activ-
ities. an event stream sis an inﬁnite sequence over c×a,
i.e.s∈(c×a)
∗.
a pair (c,a)∈c×arepresents an event, i.e. activity a
was executed in context of case c.s(1)denotes the ﬁrst event
that we receive, whereas s(i)denotes the ith event. consider
stream s1in fig. 5as an example where we show the emission
of activities based on the process model in fig. 2using short-
hand activity names. observe that event (3,d)is emitted ﬁrst
(s1(1)=(3,d)), event (4,a)is emitted second, etc. our
knowledge after receiving the third event, i.e. s1(3)=(5,a),
w.r.t. case 5, is different from our knowledge after receivingthe ﬁfth event. after the third event, for case 5, we observed
/angbracketlefta/angbracketright, whereas after the ﬁfth event this is /angbracketlefta,b,c/angbracketright.
we aim at computing alignments for the cases emitted
onto an event stream, as they allow us to quantify deviations
in a clear manner. assume that we have only seen the ﬁrst
three events, i.e. (3,d),(4,a)and(5,a),o f s
1. the only
activity seen for case 5 is activity a. an optimal alignment
for case 5 is /angbracketleft(a,t1),(/greatermuch,t3),(/greatermuch,t4),(/greatermuch,t7)/angbracketright. after receiv-
ing the fourth event, i.e. (5,b), an optimal alignment for
case 5 is /angbracketleft(a,t1),(b,t2),(/greatermuch,t3),(/greatermuch,t5),(/greatermuch,t7)/angbracketright. in both
cases, the costs of the alignments are 3. however, after receiv-
ing the ﬁrst nine events on stream s1we obtain activity
sequence /angbracketlefta,b,c,d,e/angbracketrightfor case 5 with corresponding optimal
alignment /angbracketleft(a,t1),(b,t2),(c,t3),(d,t5),(e,t7)/angbracketrightwith costs
0. thus, since the knowledge we possess about cases changes
over time, computing conventional alignments prior to casecompletion is expected to lead to an overestimation of thetrue alignment costs. we do not assume explicit knowledge
of case termination w.r.t. the events observed on the stream.
moreover, we aim at detecting potential behaviour duringcase execution as opposed to computing such ﬁgures after
case completion. as indicated, doing so with conventional
alignments is expected to lead to cost overestimation, and asa consequence, false positives from a deviation perspective.
fig. 5 example event stream
s1s1 ∞ (3,d),(4,a),(5,a),(5,b),(5,c)(6 ,a),(4,d),(5,d),(5,e),···
123int j data sci anal
γ1:a c d
t1 t3 t4γ2:a c d
t1 t2 t3 t5
fig. 6 two preﬁx-alignments for /angbracketlefta,c,d/angbracketrightand n1
therefore, we aim at computing preﬁx-alignments , which are
speciﬁcally designed to incorporate trace incompleteness.
4.2 preﬁx-alignments
preﬁx-alignments are a relaxed alternative to conventional
alignments [ 3, sect. 4 .5]. in essence, they relax requirement
two of deﬁnition 1in such way that after executing the t/greatermuch-
part of the alignment, projected onto t, the ﬁnal marking
mfcan still be reached . formally, we rephrase requirement
two to ∃σ/prime∈t∗/parenleftbigg
mi(π2(γ))↓t·σ/prime
−−−−−−− →mf/parenrightbigg
. consider fig. 6in
which we depict two example preﬁx-alignments of incom-
plete trace /angbracketlefta,c,d/angbracketrightandn1. observe that, for both alignments
we need to append either /angbracketleftt7/angbracketrightor/angbracketleftt8/angbracketrightto obtain marking
mf, and thus, the relaxed requirement is satisﬁed. sim-
ilar to conventional alignments, several preﬁx-alignmentsexist that correctly align a preﬁx and a petri net. hence, weagain need means to rank and compare preﬁx-alignments.
for example, in fig. 6we prefer
γ1overγ2, since it only
contains synchronous moves, whereas γ2contains a model
move. again, we deﬁne a cost function for preﬁx-alignments.
since a preﬁx-alignment, like a conventional alignment, is
a sequences of moves, the cost of a preﬁx alignment isdeﬁned in the exact same manner to the costs of conventional
alignments, i.e. it is simply the sum of the costs of its indi-
vidual moves. observe that cost function κis deﬁned over
a sequence of moves, and thus, given some preﬁx-alignment
γ,κ(γ)is readily deﬁned.
as a consequence, we again have the notion of opti-
mality . for example, γ1is an optimal preﬁx-alignment for
/angbracketlefta,c,d/angbracketrightand n1.w el e t γdenote the universe of possible
preﬁx-alignments and let γ(n,σ,mi,mf)denote all pos-
sible preﬁx-alignments of σand ngiven miand mf.
interestingly, any optimal preﬁx-alignment of any preﬁx
of a trace is always underestimating the costs of the optimal
alignment of any of its possible sufﬁxes, and thus, of theeventual completed trace.
proposition 1 (preﬁx-alignments underestimate alignment
costs) letσ∈a
∗. let n =(p,t,f,λ) be a petri net
with corresponding initial- and ﬁnal marking m i,mf. let
γ∈γ(n,σ,mi,mf)be optimal. if σis a preﬁx of σand
γ∈γ(n,σ,mi,mf)is an optimal preﬁx-alignment, then
κ(γ)≤κ(γ) .
proof (contradiction) let us write γasγ=γ/prime·γ/prime/prime, s.t.
(π1(γ/prime))↓a=σ. by deﬁnition, γ/primeis a preﬁx-alignment ofσ. in case κ(γ) > κ(γ) , then also κ(γ) > κ(γ/prime), which
contradicts optimality of γ. /intersectionsq/unionsq
the underestimating property is useful since, in an online
setting, once an optimal preﬁx-alignment has nonzero costs,
it guarantees that a deviation from the reference model is
present. on the other hand, if a case is not properly terminatedand will never terminate, yet the sequence of activities seen
so far has a preﬁx-alignment cost of zero, we do not observe
this type of deviation until we compute a corresponding con-ventional (optimal) alignment.
any shortest path algorithm to compute conventional
alignments, i.e. as brieﬂy discussed in sect. 3.2, is easily
altered to compute preﬁx-alignments. in fact, in line with therelaxation of requirement two of deﬁnition 1, such alteration
only consists of adding more states to the set of ﬁnal states
of the search problem. hence, to compute optimal (preﬁx-)alignments we are able to use any algorithm designed for
ﬁnding shortest paths in a graph. however, in [ 3]t h e a
∗
algorithm [ 16] is proposed and evaluated. in this paper, we
simply assume that we are able to use an algorithm α, i.e.:
α:n×a∗×m×m→γ
here, we assume α(n,σ,mi,mf)∈γ(n,σ,mi,mf)and
it is optimal. observe that the proper termination assump-
tion, w.r.t. the process models considered, guarantees that α
always ﬁnd an optimal preﬁx-alignment.
5 computing preﬁx-alignments incrementally
in this section, we present an incremental algorithm for
the purpose of online preﬁx-alignment computation. subse-
quently, we present effective parametrization of the algorithmthat allows us to reduce memory usage and computation time.
5.1 an incremental framework
we aim at computing a preﬁx-alignment for each sequence
of events seen so far for each case c∈c. in this paper,
we primarily focus on the performance of preﬁx-alignmentcomputation in an incremental setting; we therefore do not
consider (the impact of) storing the information seen on
the event stream in great detail. henceforth, we assumethe existence of a case administration d
c:c×n0→γ,
where, for i≥1,dc(c,i)represents the currently known
preﬁx-alignment related to case cafter receiving events
s(1),s(2),... , s(i). initially, we have dc(c,0)=/epsilon1,∀c∈
c. for now, we assume that dcis able to store all most recent
preﬁx-alignments for all cases. such assumption, theoreti-cally, requires inﬁnite memory; hence in sect. 5.3, we brieﬂy
123i n tjd a t as c ia n a l
algorithm 1: incremental prefix-alignments
input :n=(p,t,f, λ), mi,mf:p→ n0,α:n×a∗×m×m→
γ,s∈(c×a)∗
begin
1 i←0;
2 while true do
3 i←i+1;
4 (c,a)←s(i);
5 γ←dc(c,i−1);
6 copy all alignments of dc(c/prime,i−1)todc(c/prime,i)for all c/prime∈c;
7 letmbe the marking of nobtained by γ;
8 if∃t∈t(λ(t)=a)then
9 if∃t∈t(λ(t)=a∧m[t/angbracketright)then
10 lettdenote such transition;
11 dc(c,i)←γ·/angbracketleft(a,t)/angbracketright;
12 else
13 σ←(π1(γ))↓a;
14 dc(c,i)←α(n,σ·/angbracketlefta/angbracketright,mi,mf);
15 else
16 dc(c,i)←γ·/angbracketleft(a,/greatermuch)/angbracketright;
discuss how to handle this problem, and the corresponding
limitations in practice.
to compute preﬁx-alignments based on the event stream,
we conceptually perform the following steps. when wereceive an event related to a certain case, we check whether
we previously computed a preﬁx-alignment for that case. in
case we are guaranteed that the event refers to an activitymove, i.e. because the activity simply has no corresponding
label in the reference model, we append such activity move
to the preﬁx-alignment. if this is not the case, we fetch themarking in the reference model, corresponding to the previ-ous preﬁx-alignment. for example, given preﬁx alignment
/angbracketleft(a,t
1)/angbracketrightbased on n1(fig. 2), the corresponding marking is
[p1,p2]. if the event is the ﬁrst event received for the case,
we simply obtain marking mi. in case we are able to directly
ﬁre a transition within the obtained marking with the same
label as the activity that the event refers to, we append a cor-responding synchronous move to the previously computed
preﬁx-alignment. otherwise we use a shortest path algo-
rithm, of which we present some parametrization in sect. 5.2,
to ﬁnd a new (optimal) preﬁx-alignment. in algorithm 1,
we present an algorithmic description of the aforementioned
rationale.
the algorithm expects a petri net, initial- and ﬁnal mark-
ing, an algorithm that computes optimal preﬁx-alignments
and an event stream as an input. note that, after receiv-
ing a new event, the case administration for index i−1i s
copied into the ith version, i.e. line 6. this operation is o(1)
in practice. since optimal preﬁx-alignments underestimate
conventional alignment costs (proposition 1), we are inter-
ested to what extent algorithm 1guarantees optimality of
the preﬁx-alignments stored in d
c.
theorem 1 (optimality of algorithm 1)we let d c:c×
n0→γ, with d c(c,0)=/epsilon1,∀c∈c, and, assume d cisupdated according to algorithm 1. for any c ∈c,i∈n
andγ=dc(c,i)we have γ∈γandγis optimal for
(π1(γ))↓a.
proof (induction on i)
•base case i :i=0 all alignments are /epsilon1.
•base case i i :i=1l e t (c,a)bes(i). we know
dc(c,i−1)=dc(c,0)=/epsilon1. in case we are able to ﬁre
some twithλ(t)=ainm0, we obtain alignment /angbracketleft(a,t)/angbracketright,
which, under the unit-cost function, is optimal.1in case
∄t∈t(λ(t)=a)we obtain /angbracketleft(a,/greatermuch)/angbracketrightwhich is trivially
an optimal preﬁx-alignment for trace /angbracketlefta/angbracketright. in any other
case, we compute α(n,mi,mf,/angbracketlefta/angbracketright)which is optimal
by deﬁnition.
•induction hypothesis let i>1. for any c∈c,w e
assume that for γ=dc(c,i),w eh a v e γ∈γandγis
optimal.
•inductive step we prove that, for any c∈c,f o rγ=
dc(c,i+1),w eh a v e γ∈γandγis optimal. let
(c,a)bes(i+1). in case dc(c,i)=/epsilon1we know that
γis optimal ( base case i =1). let dc(c,i)=γ/primes.t.
γ/prime/negationslash=/epsilon1.i nc a s ew ea r ea b l et oﬁ r es o m e twithλ(t)=a
inm0we obtain γ=γ/prime·/angbracketleft(a,t)/angbracketright. since, under unit-
cost function, δ(a,t)=0, ifγis non-optimal, then also
γ/primeis non-optimal which contradicts the ih. a similar
rationale holds in case ∄t∈t(λ(t)=a). in any other case,
we compute α(n,mi,mf,σ·/angbracketlefta/angbracketright)which is optimal by
deﬁnition. /intersectionsq/unionsq
theorem 1proves that algorithm 1always computes opti-
mal preﬁx-alignments for (πa/greatermuch(γ))↓a, i.e. the sequence
of activities currently stored within dcfor some c∈c.
hence, combining this result with proposition 1, we conclude
that whenever the algorithm observes certain alignment costs
exceeding 0, the corresponding conventional alignment hasat least the same costs, or higher.
5.2 parametrization
in the previous section, we used
αcompletely as a black
box and always solved a shortest path problem starting from
mi. in this section, we show that we are able to exploit the
previously calculated alignment for a case cin order to prune
the search state-space. moreover, we show means to limit the
search by changing its starting point.
5.2.1 cost upper-bounds
assume that we receive the ith event (c,a)on the stream and
we let γ/prime=dc(c,i−1)andγ=dc(c,i). let us write
1observe that this is true under the proper termination assumption .
123int j data sci anal
a b x c d
t1 t2 t3 t5receive b−−−−−−− →a b c d b
t1 t2 t3 t5 t6 t2x
fig. 7 partially reverting ( k=2) the preﬁx-alignment of /angbracketlefta,b,x,c,d/angbracketrightand n1in case of receiving new activity b. the grey coloured moves are
not considered when computing the new alignment
the corresponding sequence of activities as σ=σ/prime·/angbracketlefta/angbracketright.b y
proposition 1, we know that γ/primeis an optimal preﬁx-alignment
forσ/prime. it is easy to see that the costs of γ/primetogether with an
activity move on aare an upper bound for the costs of γ, i.e.
κ(γ)≤κ(γ/prime)+δ(a,/greatermuch). we are able to utilize this knowl-
edge within the shortest path search algorithm α. whenever
we encounter a path within the search that is (guaranteed to
be) exceeding κ(γ/prime)+δ(a,/greatermuch), we simply ignore it, and all
paths extending it.
as indicated, in alignment computation, the a∗algorithm
is often used as an instantiation for α.t h e a∗algorithm tra-
verses the state space in an implicit manner, i.e. it expectseach state it visits to tell which states are their neigh-
bours, and, at what distance. moreover, it assumes that
each state is able to estimate its distance to the closestﬁnal state, i.e. each state has a heuristic distance estima-
tion to the closest ﬁnal state. for the purpose of computing
(preﬁx-)alignments, there are two of these heuristic distancefunctions deﬁned [ 3, chapter 4]. the exact characterization
of these heuristic functions is out of this paper’s scope, i.e.
it sufﬁces to know that we are able to, for each markingin the synchronous product net, compute the estimated dis-tance (in terms of alignment costs) to ﬁnal marking m
f.
moreover, such estimation is always underestimating the
true distance. thus, whenever we encounter a marking m
in the state space of which the distance to reach mfrom
mi, combined with the estimated distance to mf, exceeds
κ(γ/prime)+δ(a,/greatermuch), we ignore it and all of its possible subse-
quent markings.
5.2.2 limiting the search
again, assume we receive the ith event (c,a)and we let
marking mbe the marking obtained by executing the tran-
sitions of γ/prime=dc(c,i−1). in case there exist transitions t
withλ(t)=a, yet none of these transitions are enabled in m,
the basic algorithm simply utilizes α(n,σ·/angbracketlefta/angbracketright,mi,mf).
in general, the shortest path algorithm does not need mi
as a start state, i.e. we are able to choose any marking of
nas a start state. hence, we propose to partially revert
alignment γ/primeup to a maximal revert distance kand start
the shortest path search from the corresponding marking.
doing so however no longer guarantees optimality as we
are no longer searching for a global optimum in the statespace.consider fig. 7, where we depict a preﬁx-alignment for
/angbracketlefta,b,x,c,d/angbracketrightand n
1(fig. 2). assume we receive a new
event that states that activity bfollows /angbracketlefta,b,x,c,d/angbracketrightand we
use a revert window size of k=2. note that the marking
related to the alignment is [p5]. in this marking, no tran-
sition with label bis enabled and the algorithm normally
callsα(n1,/angbracketlefta,b,x,c,d,b/angbracketright,[pi],[po]). however, we revert
the alignment two moves, i.e. we revert (d,t5)and(c,t3)
and call α(n1,/angbracketleftc,d,b/angbracketright,[p2,p3],[po])instead. the result
of this call is /angbracketleft(c,t3),(d,t5),(/greatermuch,t6),(b,t2)/angbracketright, depicted on
the right-hand side of fig. 7. note that after this call, the
window shifts, i.e. the call appended two moves, and thus,(c,t
3)and(d,t5)are no longer considered upon receiving of
new events.
5.3 administering cases in ﬁnite memory
thus far, we assumed dcto be of inﬁnite memory, an
infeasible assumption in practice. in an online setting, caseadministration d
cneeds to deploy some form of memory
management that removes entries based on some case char-
acteristic, e.g. age, relative frequency on the stream, etc.examples of such mechanisms are reservoirs [ 17,18], time
decay-based data structures [ 19] and frequency approxima-
tion algorithms [ 20]. these techniques, at some point, remove
preﬁx-alignments related to some, seemingly inactive, case.note that this no longer guarantees that a preﬁx-alignment
maintained in d
cis always an underestimation for all activ-
ities emitted on the stream for case c. in fact, theorem 1
actually does not prove this, as it proves optimality for
(π1(γ))↓a, which under assumption of inﬁnite memory is
equivalent to the previous statement. moreover, if we receiveactivities related to a case that was previously deleted, we
are falsely starting to compute new preﬁx-alignments for the
case, i.e. there was some past behaviour that we no longerpossess.
a way to solve this problem is by tracking what cases
are removed from case administration. if new events appear
related to such case, we simply ignore them. in such way,any element of the case administration truly relates to all
behaviour emitted on the stream related to the case. how-
ever, again, at some point in time we need to drop cases fromthe secondary storage component. it is, however, reasonable
to assume that the number of distinct cases is orders of mag-
nitudes smaller than the number of events emitted onto theevent stream.
123i n tjd a t as c ia n a l
table 2 parameters used in experiments
parameter type v alues
use upper-bound boolean true ,false
window size integer {1,2,3,4,5,10,20,∞}
6 evaluation
we have evaluated the proposed algorithm, including its
parametrization, using the rapidprom [21] extension for
rapidminer .2as a search algorithm, we use a the a∗
algorithm provided by hipster4j [22]. to evaluate the
proposed algorithm, we generated several process models
with different characteristics, i.e. different degrees of par-allelism, choice and loops. additionally we evaluated our
approach using real event data, related to the treatment of
hospital patients suspected of having sepsis. in this experi-ment, we additionally compare computing preﬁx-alignmentswith repeatedly computing conventional alignments on an
event stream.
6.1 experimental set-up
we used a scientiﬁc workﬂow implemented in rapidprom
which, conceptually, performs the following steps:
1. generate a (block-structured) workﬂow net with klabelled
transitions, where kis drawn from a triangular distribu-
tion with parameters {10,20,30}, for increasing levels of
parallelism, choice and loops (from 0 to 50% in steps
of 10%) [ 23].
2. for each workﬂow net, generate an event log with 1000
cases.
3. for each event log, add increasing levels (from 0 to 50%
in steps of 10%) of one type of noise, i.e. remove activity ,
add activity orswap activities .
4. for each “noisy” event log, do incremental conformance
checking against the workﬂow net it was generated from,using all parameter combinations presented in table 2.
observe that within the experiments we mimic event
streams by visiting each event in a trace, one by one, e.g.
if we have event log l=[ /angbracketleft a,b,c/angbracketright,/angbracketlefta,c,b/angbracketright], we gener-
ate event stream /angbracketleft(1,a),(1,b),(1,c),(2,a),(2,c),(2,b)/angbracketright.
moreover, we align every trace-variant once, i.e. if /angbracketlefta
,b,c/angbracketright
occurs multiple times in the event log, we only align it once.
in total, we have generated 18 different models, for which wegenerate 18 different event logs, each containing 1000 traces,
2all (raw) experiment results, data and scientiﬁc workﬂows
used are available via https://github.com/s-j-v-zelst/research/releases/
download/2017_jdsa/experiments.tar.gz .yielding 18 .000 noise-free traces. after applying the differ-
ent types of noise, we obtain a total of 324 .000 traces. clearly,
the number of events per trace greatly varies depending on the
generated model; however, within our experiments, in total
44.537.728 events were processed (with varying algorithm
parametrization). out of these events, 12 .151.510 state-space
searches were performed.
6.2 results
here, we present the results of the experiments, in line with
the parametrization options as described in sect. 5.2.w eﬁ r s t
present results related to using cost upper-bounds; later we
present the results related to limited search.
6.2.1 cost upper-bounds
in this section, we present the results related to the perfor-
mance of using cost upper-bounds. within these results, we
only focus on execution of αwith m0as a start state, i.e. we
do not incorporate results related to varying window sizes. infig. 8, we present, in terms of the level of introduced noise,
the average number of enqueued states, queue size, visited
nodes and traversed arcs for each search in the state space.
clearly, using the upper bound as a cut-off value in state-
space traversal greatly enhances the memory efﬁciency. we
observe that, when using the upper bound deﬁned in sect. 5.2,
the average number of states enqueued during the searchis less than half compared to not using the upper bound.
the average queue size, i.e. average number of states in
the queue throughout the search, is much lower in case ofusing a lower bound. we observe that the search efﬁciency(fig. 8c, d) is positively affected by using the upper bound;
however, the difference is less severe and in some cases neg-
ligible (0% noise level). thus, using previously computedpreﬁx-alignment values for a case allows effective states-
space pruning in the shortest path algorithm.
in fig. 9, we show the effect of the length of the preﬁx
that needs to be aligned in terms of memory consumption.
we only show results for length ≤100. both in case of using
and not using the upper bound, we observe a linear increasein number of states queued and average queue size. however,the rate of growth is much lower when using an upper bound.
we observe a small region of spikes in both charts around
preﬁx-length 20–25. after investigating the distribution ofpreﬁx-length w.r.t. type of process model, i.e. containing
loops vs. not containing loops, we observed that most traces
exceeding such length are related to the models containingloops. as the other group of models contains relatively more
parallelism and/or choices, the complexity of the underlying
shortest path search is expected to be slightly more complex,which explains the spikes for relatively short preﬁx-lengths.
123int j data sci anal
050100150200
0.0 0.1 0.2 0.3
% noiseavg. enqueued statesupper bound
true
false
(a)0204060
0.0 0.1 0.2 0.3
% noiseavg. queue sizeupper bound
true
false
(b)
020406080
0.0 0.1 0.2 0.3
% noiseavg. visited statesupper bound
true
false
(c)0100200
0.0 0.1 0.2 0.3
% noiseavg. traversed arcsupper bound
true
false
(d)
fig. 8 performance results of using upper bounds while searching for optimal preﬁx-alignments. aaverage number of states enqueued, baverage
number queue size, caverage number of states visited and daverage number of traversed arcs
0100200300400500
0 25 50 75 100
prefix lengthavg. enqueued statesupper bound
true
false
(a)050100150
0 25 50 75 100
prefix lengthavg. queue sizeupper bound
true
false
(b)
fig. 9 memory performance per preﬁx-length (up to length 100). aaverage number of states enqueued and baverage queue size
6.2.2 reverting alignments
in this section, we present results related to the perfor-
mance and approximation quality of using revert windowsas described in sect. 5.2.2 .i nf i g . 10, we present perfor-
mance results in terms of memory efﬁciency and approx-
imation error, plotted against noise level. in fig. 10a, we
show the average number of states enqueued when using
different revert window sizes. clearly, the memory usage
increases when we increase the window size. interest-ingly, this increase seems linear. the approximation error(fig. 10b) shows an inverse pattern; however, the decrease
in approximation error seems nonlinear, when the windowsize increases. moreover, in case we set the window size to
5 we observe that the approximation error, within this exper-
iment, is negligible, whereas memory-wise window sizes of
10 and 20 use much more memory while hardly improvingthe quality of the result.
in fig. 11, we present performance results in terms of
memory efﬁciency and approximation error, plotted againstpreﬁx length. we observe that in terms of enqueued nodes
(fig. 11a), at ﬁrst a rapid increase appears, after which a
steep decline is present. stabilization around lengths ≥25
is again due to the fact that all traces of such length originatefrom models with loops. the peak and decline behaviour is
explained by the fact that the complexity of solving state-
123i n tjd a t as c ia n a l
01020304050
0.0 0.1 0.2 0.3
% noiseavg. enqueued stateswindow size
1
2345
10
20
(a)0.00.10.20.3
0 . 00 . 10 . 20 . 3
% noiseavg. cost differencewindow size
1
2345
10
20
(b)
fig. 10 memory performance and cost difference w.r.t. optimal preﬁx-alignments when using different revert window sizes. aaverage number
of states enqueued and baverage cost difference
1015202530
0 25 50 75 100
prefix lengthavg. enqueued stateswindow size
1
2345
(a)0.00.20.40.6
0 25 50 75 100
prefix lengthavg. cost differencewindow size
1
2345
(b)
fig. 11 memory usage and cost difference w.r.t. optimal preﬁx-alignments per preﬁx-length, with different revert window sizes. aaverage number
of states enqueued and baverage cost difference
space-based search within the models is most likely to be
most complex in the middle of the trace. towards the end of
a model’s behaviour, we expect less state-space complexity,
which explains the decline in the chart around preﬁx length10–20.
in fig. 11b, we observe similar results as observed in
fig. 10b. a window size of 1 is simply too small and it seems
that, when the preﬁx length increases, the costs increaselinearly. however, when using a window ≥2 we observe
asymptotic behaviour in terms of approximation error. again
we observe that using a window of at least size 5 leads to neg-ligible approximation errors.
6.3 evaluation using real event data
in this section, we discuss the results of applying incremen-
tal alignment calculation based on real event data. we focus
on the under/overestimation of true eventual conventional
alignment cost, as well as the method’s performance. as abaseline, we compute conventional alignments every time we
receive a new event. we use an event log originating from a
dutch hospital related to the treatment of patients suspectedof having sepsis [ 24]. since we do not have a reference model,we generated one based on a subset of the data. this generated
process model still describes around 90% of the behaviour
within the event log (computed using conventional align-
ments). the data set contains 15 .214 events divided over
1.050 cases. preﬁx-alignments were computed for 13 .775
different events. we plot all results w.r.t. the aligned preﬁx
length as noise percentages, i.e. used in figs. 8and 10,a r e
unknown when using real event data. finally note that the dis-tribution of trace length within the data is heavily skewed and
has a long infrequent tail. the majority of the trace’s length
is below 30, hence, ﬁgures for preﬁx lengths above this valuerefer to a relatively limited set of cases. nonetheless, we plot
all results for all possible preﬁx lengths observed.
in fig. 12, we present results related to computed align-
ment costs. we show results for using the incremental scheme
proposed in this paper with window sizes 5, 10 and 20, and,
the baseline (“ conventional ”). in fig. 12a, we show the aver-
age absolute alignment costs per preﬁx length. we observethat using a window size of 5 in general leads to higher
alignment costs. this is explained by the fact that the rel-
atively little window size does not allow us to revert anychoices made in previous alignments, which consequently
does not allow us to ﬁnd an eventual global optimum. inter-
123int j data sci anal
050100150
0 50 100 150
prefix lengthavg. alignment costversion
prefix (window = 5)
prefix (window = 10)
prefix (window = 20)
conventional
(a)04080120
0 50 100 150
prefix lengthavg. cost differenceversion
prefix (window = 5)
prefix (window = 10)
prefix (window = 20)
conventional
(b)
fig. 12 average cost results per preﬁx-length, with different revert window sizes. aaverage (preﬁx-) alignment cost and baverage cost difference
w.r.t. eventual optimal conventional alignment
estingly, both window sizes 10 and 20 lead to, on average,
comparable alignment costs to simply computing conven-
tional alignments. however, in the beginning of cases, i.e. for
small preﬁxes, as expected, computing conventional align-ments leads to higher values. in fig. 12b, we show the average
cost difference w.r.t. the eventual alignment costs, i.e. after
case completion. interestingly, after initially overestimating
eventual costs, conventional alignments underestimate thecosts of conventional alignments quite severely. this can be
explained by the fact that partial traces are aligned by a short
path of model moves through the model combined with alimited set of activity moves.
in order to quantify the potential business impact of
applying the (preﬁx-)alignment approach, we derive severaldifferent measures of relevance for the three different win-dow sizes and the baseline. these ﬁgures are presented in
table 3. to obtain the results as presented, for each received
event we deﬁne:
– if the difference of the current (preﬁx-)alignment cost
with the eventual alignment cost is zero, and the eventualcosts exceed zero, we deﬁne a true positive , i.e. we have
an exact estimate of non-compliant behaviour.
– if the difference of the current (preﬁx-)alignment cost
with the eventual alignment cost is greater than zero,we deﬁne a false positive , i.e. we overestimate non-
compliant behaviour.
– if the difference of the current (preﬁx-)alignment cost
with the eventual alignment cost is zero, and the eventual
costs equals zero, we deﬁne a true negate , i.e. we have
an exact estimate of the fact that no deviation occurs.
– if the difference of the current (preﬁx-)alignment cost
with the eventual alignment cost is lower than zero,
we deﬁne a false negative , i.e. we underestimate non-
compliant behaviour.
we acknowledge that alternative deﬁnitions of true/false
positives/negatives are possible. therefore, the resultsobtained are speciﬁc for the deﬁnition provided, as well as
the data set of use. we observe that computing conventional
alignments, for every event received, leads to better recall ,
i.e.
tp
tp+fn. this implies that the ratio of correctly observed
deviations w.r.t. neglected deviations is better for the con-ventional approach. however, using the incremental scheme
leads to signiﬁcantly higher speciﬁcity (
tn
tn+fp) and preci-
sion values (tp
tp+fp). speciﬁcally for window sizes 10 and
20 we observe very high precision values. this in fact is in
line with proposition 1and, moreover, shows that the results
obtained with these window sizes are close to results for an
inﬁnite window size. finally, we observe that the accuracy
of window sizes 10 and 20 is comparable and higher than thealternative approaches, i.e. window size 5 and conventional.
however, in terms of f1-score, simply calculating conven-
tional alignments outperforms using the incremental schemeas proposed.
in fig. 13, we show the performance of the different
approaches in terms of enqueued states and visited states.
note that the results presented consider the full incrementalscheme, i.e. if we are able to execute a synchronous move
directly, queued/visited states equals 0. as expected, using a
window size of 5 is most efﬁcient. window sizes 10 and 20are less efﬁcient yet for longer preﬁx lengths, they outper-
form computing conventional alignments. for window size
20, we do observe a peak in terms of computational complex-ity for preﬁx lengths of 10–20. such peak is explained by therelatively inaccurate heuristic used within the a
∗-searches
performed for preﬁx-alignment computation. the drops in
the chart relate to purely incremental alignment updates.we observe that computational complexity of conventional
alignment computation is in general increasing when preﬁx
length increases. the incremental-based approach seems notto suffer from this and shows relatively stabilizing behaviour.
based on the experiments using real hospital data, we
conclude that, for this speciﬁc data set, a window size of10 is appropriate. as opposed to computing conventional
123i n tjd a t as c ia n a l
table 3 measures of relevance
for different window-sizedapproaches versus computingconventional alignmentsv ariant window ∼5 window ∼10 window ∼20 conventional
variant window ∼5 window ∼10 window ∼20 conventional
true positive 1517 2060 2110 3179
false positive 2076 204 13 5215
true negative 2962 3340 3377 1424
false negative 7220 8171 8275 3957
recall 0.173629392 0.201348842 0.20317766 0.445487668
speciﬁcity 0.587931719 0.942437923 0.996165192 0.214490134
precision 0.422209852 0.909893993 0.99387659 0.378722897
negative predictive value 0.29090552 0.290157241 0.28982149 0.264634826
false negative rate 0.826370608 0.798651158 0.79682234 0.554512332
fall-out 0.412068281 0.057562077 0.003834808 0.785509866
false discovery rate 0.577790148 0.090106007 0.00612341 0.621277103
false omission rate 0.70909448 0.709842759 0.71017851 0.735365174
accuracy 0.325154265 0.392014519 0.398330309 0.33415608
f1-score 0.246066504 0.329731893 0.337384074 0.409401159
1100
0 50 100 150
prefix lengthavg. enqueued statesversion
prefix (window = 5)
prefix (window = 10)prefix (window = 20)conventional
(a)1100
0 50 100 150
prefix lengthavg. visited statesversion
prefix (window = 5)
prefix (window = 10)prefix (window = 20)conventional
(b)
fig. 13 performance results based on the hospital data set (logarithmic scales). aaverage number of states enqueued and baverage number of
traversed arcs
alignments, it achieves precise results, i.e. whenever a devi-
ation is detected it is reasonable to assume that this is indeedthe case. moreover, it outperforms computing conventionalalignments in terms of computational complexity and mem-
ory usage.
7 discussion
the aim of the incremental technique presented in this paperis to compute approximations of alignments, by means of
utilizing the concept of preﬁx-alignments, based on eventstreams. in particular, we aim at computing these approxima-
tions more efﬁciently w.r.t. simply computing conventional
alignments, whilst at the same time limiting the loss in resultaccuracy.
in general, we conclude that the use of the technique pro-
posed is justiﬁed in cases where computational resourcesare limited, and/or there is a need for high precision, i.e.we aim at high degrees of certainty when we observe a
deviation. in cases where computational complexity is notan urgent issue, and/or high recall is more preferable, onecan resort to computing conventional alignments. however,
recall that conventional alignments initially overestimate
alignment costs and thus are not able to properly detect devia-tions in early stages of a case. hence, when resorting to using
conventional alignments, a warm-up period is advisable.
in the experiments performed using real data, we observe
a certain unpredictability w.r.t. memory usage/computational
efﬁciency of preﬁx-alignment computation, i.e. consider the
peeks for window size 20 in fig. 13. in general, although
the search algorithm used in preﬁx-alignment computation is
a
∗[16], the practical search performance is, however, equal
to the performance of dijkstra’s shortest path algorithm [ 25].
this is mainly related to the fact that when computing preﬁx-alignments we need to resort to a rather inaccurate heuristic
function. by partially reverting the alignments, combined
with applying the upper-bound pruning, we are able to reduce
123int j data sci anal
the search complexity, however, at the cost of losing accuracy.
when computing conventional alignments, we are able toresort to a more accurate heuristic which explains the more
predictable computational efﬁciency trends in fig. 13.
8 conclusion
in this paper, we proposed an online, event stream-based,
conformance checking technique based on the use of preﬁx-
alignments. the algorithm only performs a state-space searchto compute a new preﬁx-alignment if no direct label- or syn-
chronous move is possible. we presented two techniques to
increase the search efﬁciency of the underlying shortest pathproblems solved. the ﬁrst technique preserves optimality andallows for effective state-space pruning. the second tech-
nique uses an approximation scheme providing a balance
between optimality and memory usage. in our evaluation,we primarily focussed on the performance of the underly-
ing shortest path problems solved. our results show that we
are able to effectively prune the state space by using previ-ously computed alignment results. particularly in terms of
memory efﬁciency, these results are promising. when using
our approximation approach, we observe a linear trend inneeded memory when increasing window sizes. however,the approximation error seems to decrease more rapidly, i.e.
in a nonlinear fashion when increasing window sizes.
future work we aim to extend our work as follows.
we plan to extend our experiments, using more levels of
choice/parallelism/loops, more models per level and larger
data sets. moreover, we plan to perform more experimentsusing real event data. we also plan to deﬁne alterna-
tive accuracy measures regarding under/overestimation of
conventional alignments to more accurately measure theindicative behaviour of preﬁx-alignments. finally, the stateof a preﬁx-alignment, in terms of the underlying reference
model, carries some predictive value w.r.t. case termination.
thus, in cases we do not know explicit case termination, it isinteresting to study the effect of using preﬁx-alignments as
a case termination predictor.
open access this article is distributed under the terms of the creative
commons attribution 4.0 international license ( http://creativecomm
ons.org/licenses/by/4.0/ ), which permits unrestricted use, distribution,
and reproduction in any medium, provided you give appropriate creditto the original author(s) and the source, provide a link to the creativecommons license, and indicate if changes were made.
references
1. van der aalst, w.m.p .: process mining—data science in
action, 2nd edn. springer, berlin (2016). https://doi.org/10.1007/
978-3-662-49851-42. rozinat, a., van der aalst, w.m.p .: conformance checking of pro-
cesses based on monitoring real behavior. inf. syst. 33(1), 64–95
(2008). https://doi.org/10.1016/j.is.2007.07.001
3. adriansyah, a.: aligning observed and modeled behavior. ph.d.
thesis, eindhoven university of technology, department of math-ematics and computer science (2014). https://doi.org/10.6100/
ir770080
4. de leoni, m., van der aalst, w.m.p .: data-aware process mining:
discovering decisions in processes using alignments. in: shin, s.y .,maldonado, j.c. (eds.) proceedings of the 28th annual acm sym-posium on applied computing, sac’13, coimbra, portugal, pp.1454–1461. acm, 18–22 march 2013 (2013). https://doi.org/10.
1145/2480362.2480633
5. fahland, d., van der aalst, w.m.p .: model repair—aligning process
models to reality. inf. syst. 47, 220–243 (2015). https://doi.org/10.
1016/j.is.2013.12.007
6. van der aalst, w.m.p .: decomposing petri nets for process min-
ing: a generic approach. distrib. parallel databases 31(4), 471–507
(2013). https://doi.org/10.1007/s10619-013-7127-5
7. munoz-gama, j., carmona, j., van der aalst, w.m.p .: single-entry
single-exit decomposed conformance checking. inf. syst. 46, 102–
122 (2014). https://doi.org/10.1016/j.is.2014.04.003
8. taymouri, f., carmona, j.: a recursive paradigm for align-
ing observed behavior of large structured process models.in: la rosa, m., loos, p ., pastor, o. (eds.) bpm 2016,riode janeiro, brazil, proceedings, lecture notes in computer
science , vol. 9850, pp. 197–214. springer,18–22 sept 2016
(2016). https://doi.org/10.1007/978-3-319-45348-4_12 .http://dx.
doi.org/10.1007/978-3-319-45348-4
9. burattin, a., sperduti, a., van der aalst, w.m.p .: control-ﬂow dis-
covery from event streams. in: proceedings of the ieee congresson evolutionary computation, cec 2014, beijing, china, pp.2420–2427. ieee, 6–11 july 2014 (2014). https://doi.org/10.1109/
cec.2014.6900341
10. weijters, a.j.m.m., ribeiro, j.t.s.: flexible heuristics miner
(fhm). in: proceedings of the ieee symposium on computationalintelligence and data mining, cidm 2011, part of the ieee sym-posium series on computational intelligence 2011, paris, france,pp. 310–317, 11–15 april 2011 (2011). https://doi.org/10.1109/
cidm.2011.5949453
11. hassani, m., siccha, s., richter, f., seidl, t.: efﬁcient process
discovery from event streams using sequential pattern mining.in: ieee symposium series on computational intelligence, ssci2015, cape town, south africa, pp. 1366–1373. ieee, 7–10 dec2015 (2015). https://doi.org/10.1109/ssci.2015.195
12. van zelst, s.j., van dongen, b.f., van der aalst, w.m.p .:
event stream-based process discovery using abstract repre-
sentations. knowl. inf. syst. (2017). https://doi.org/10.1007/
s10115-017-1060-2
13. burattin, a., cimitile, m., maggi, f.m., sperduti, a.: online dis-
covery of declarative process models from event streams. ieeetrans. serv. comput. 8(6), 833–846 (2015). https://doi.org/10.
1109/tsc.2015.2459703
14. murata, t.: petri nets: properties, analysis and applications. proc.
ieee 77(4), 541–580 (1989). https://doi.org/10.1109/5.24143
15. van der aalst, w.m.p .: the application of petri nets to workﬂow
management. j. circuits syst. comput. 8(1), 21–66 (1998). https://
doi.org/10.1142/s0218126698000043
16. hart, p .e., nilsson, n.j., raphael, b.: a formal basis for the heuris-
tic determination of minimum cost paths. ieee trans. syst. sci.cyberne. 4(2), 100–107 (1968). https://doi.org/10.1109/tssc.
1968.300136
17. aggarwal, c.c.: on biased reservoir sampling in the presence of
stream evolution. in: dayal, u., whang, k., lomet, d.b., alonso,g., lohman, g.m., kersten, m.l., cha, s.k., kim, y . (eds.) pro-ceedings of the 32nd international conference on v ery large data
123i n tjd a t as c ia n a l
bases, seoul, korea, pp. 607–618. acm, 12–15 sept 2006 (2006).
http://dl.acm.org/citation.cfm?id=1164180
18. vitter, j.s.: random sampling with a reservoir. acm trans. math.
softw. 11(1), 37–57 (1985). https://doi.org/10.1145/3147.3165
19. cormode, g., shkapenyuk, v ., srivastava, d., xu, b.: forward
decay: a practical time decay model for streaming systems. in:ioannidis, y .e., lee, d.l., ng, r.t. (eds.) proceedings of the25th international conference on data engineering, icde 2009,shanghai, china, pp. 138–149. ieee computer society, 29 march2009–2 april 2009 (2009). https://doi.org/10.1109/icde.2009.65
20. cormode, g., hadjieleftheriou, m.: methods for ﬁnding frequent
items in data streams. vldb j. 19(1), 3–20 (2010). https://doi.org/
10.1007/s00778-009-0172-z
21. van der aalst, w.m.p ., bolt, a., van zelst, s.j.: rapidprom:
mine your processes and not just your data. corr (2017).arxiv:1703.03740
22. rodrguez-mier, p ., gonzalez-sieira, a., mucientes, m., lama, m.,
bugarin, a.: hipster: an open source java library for heuristicsearch. in: 2014 9th iberian conference on information systemsand technologies (cisti). ieee (2014). https://doi.org/10.1109/
cisti.2014.687691423. jouck, t., depaire, b.: ptandloggenerator: a generator for artiﬁ-
cial event data. in: azevedo, l., cabanillas, c. (eds.) proceedingsof the bpm demo track 2016 co-located with the 14th interna-tional conference on business process management (bpm 2016),rio de janeiro, brazil, ceur workshop proceedings , vol. 1789,
pp. 23–27. ceur-ws.org, 21 sept 2016 (2016). http://ceur-ws.
org/v ol-1789/bpm-demo-2016-paper5.pdf
24. mannhardt, f.: sepsis cases–event log (2016). https://doi.org/10.
4121/uuid:915d2bfb-7e84-49ad-a286-dc35f063a460
25. dijkstra, e.w.: a note on two problems in connexion with
graphs. numer. math. 1(1), 269–271 (1959). https://doi.org/10.
1007/bf01386390
123