genetic process mining
w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
{w.m.p.v.d.aalst,a.k.medeiros,a.j.m.m.weijters }@tm.tue.nl
abstract. the topic of process mining has attracted the attention of
both researchers and tool vendors in the business process management
(bpm) space. the goal of process mining is to discover process models
from event logs, i.e., events logged by some information system are used
to extract information about activities and their causal relations. several
algorithms have been proposed for process mining. many of these algo-rithms cannot deal with concurrency. other typical problems are the
presence of duplicate activities, hidden activities, non-free-choice con-
structs, etc. in addition, real-life logs contain noise (e.g., exceptions orincorrectly logged events) and are typically incomplete (i.e., the event
logs contain only a fragment of all possible behaviors). to tackle these
problems we propose a completely new approach based on genetic al-gorithms. as can be expected, a genetic approach is able to deal with
noise and incompleteness. however, it is not easy to represent processes
properly in a genetic setting. in this paper, we show a genetic processmining approach using the so-called causal matrix as a representation
for individuals. we elaborate on the relation between petri nets and this
representation and show that genetic algorithms can be used to discoverpetri net models from event logs.
keywords : process mining, petri nets, genetic algorithms, process discovery, busi-
ness process intelligence, business activity monitoring.
1 introduction
buzzwords such as business process intelligence (bpi) and business activ-
ity monitoring (bam) illustrate the practical interest in techniques to extract
knowledge from the information recorded by today’s information systems. most
information systems support some form of logging. for example, enterprise re-
source planning (erp) systems such as sap r/3, peoplesoft, oracle, jd ed-wards, etc. log transactions at various levels. any workﬂow management (wfm)
system records audit trails for individual cases. the sarbanes-oxley act is forcing
organizations to log even more information. the availability of this informationtriggered the need for process mining techniques that analyze event logs.
the goal of process mining is to extract information about processes from
transaction logs [3]. we assume that it is possible to record events such that(i) each event refers to an activity (i.e., a well-deﬁned step in the process), (ii)
each event refers to a case(i.e., a process instance), (iii) each event canhave
aperformer also referred to as originator (the actor executing or initiating theactivity), and (iv) events canhave a timestamp and are totally ordered. table 1
shows an example of a log involving 18 events and 8 activities. in addition tothe information shown in this table, some event logs contain more information
on the case itself, i.e., data elements referring to properties of the case.
case activity origi- timestamp case activity origi- timestamp
id id nator id id nator
case 1 activity a john 09-3-2004:15.01 case 3 activity e pete 10-3-2004:12.50
case 2 activity a john 09-3-2004:15.12 case 3 activity f carol 11-3-2004:10.12
case 3 activity a sue09-3-2004:16.03 case 4 activity d pete 11-3-2004:10.14
case 3 activity d carol 09-3-2004:16.07 case 3 activity g sue11-3-2004:10.44
case 1 activity b mike 09-3-2004:18.25 case 3 activity h pete 11-3-2004:11.03
case 1 activity h john 10-3-2004:09.23 case 4 activity f sue11-3-2004:11.18
case 2 activity c mike 10-3-2004:10.34 case 4 activity e clare 11-3-2004:12.22
case 4 activity a sue10-3-2004:10.35 case 4 activity g mike 11-3-2004:14.34
case 2 activity h john 10-3-2004:12.34 case 4 activity h clare 11-3-2004:14.38
table 1. an event log (audit trail).
event logs such as the one shown in table 1 are used as the starting point for
mining. we distinguish three diﬀerent perspectives: (1) the process perspective,
(2) the organizational perspective and (3) the case perspective. the process per-
spective focuses on the control-ﬂow, i.e., the ordering of activities. the goal of
mining this perspective is to ﬁnd a good characterization of all possible paths,
e.g., expressed in terms of a petri net or event-driven process chain (epc). theorganizational perspective focuses on the originator ﬁeld, i.e., which performers
are involved and how are they related. the goal is to either structure the or-
ganization by classifying people in terms of roles and organizational units or toshow relation between individual performers (i.e., build a social network [2]).
thecase perspective focuses on properties of cases. cases can be characterized
by their path in the process or by the originators working on a case. however,cases can also be characterized by the values of the corresponding data elements.
for example, if a case represents a replenishment order it is interesting to know
the supplier or the number of products ordered.
the process perspective is concerned with the “how?” question, the orga-
nizational perspective is concerned with the “who?” question, and the case
perspective is concerned with the “what?” question. in this paper we will focus
completely on the process perspective, i.e., the ordering of the activities. thismeans that here we ignore the last two columns in table 1. (although the times-
tamps determine the order of events (activities) in a case, the actual timestamps
are not used during mining.) for the mining of the other perspectives we referto [3] and http://www.processmining.org. note that the prom tool described in
this paper is able to mine the other perspectives and can also deal with other
issues such as transactions, e.g., in the prom tool we consider diﬀerent eventtypes such as “schedule”, “start”, “complete”, “abort”, etc. however, for rea-
sons of simplicity we abstract from this in this paper and consider activities to
be atomic as shown in table 1.if we abstract from the other perspectives, table 1 contains the following
information: case 1 has event trace a,b,h , case 2 has event trace a,c,h ,c a s e
3 has event trace a,d,e,f,g,h , and case 4 has event trace a,d,f,e,g,h .
if we analyze these four sequences we can extract the following information
about the process (assuming some notion of completeness and no noise). theunderlying process has 8 activities ( a,b, ...,h).ais always the ﬁrst activity to
be executed and his always the last one. after ais executed, activities b,cor
dcan be executed. in other words, after a, there is a choice in the process and
only one of these activities can be executed next. when borcare executed,
they are followed by the execution of h(see cases 1 and 2). when dis executed,
botheandfcan be executed in any order. since we do not consider explicit
parallelism, we assume eandfto be concurrent (see cases 3 and 4). activity g
synchronizes the parallel branches that contain eandf. activity his executed
whenever b,corghas been executed. based on these observations, the petri
net shown in figure 1 is a good model for the event log containing the four cases.
note that each of the four cases can be “reproduced” by the petri net shown infigure 1, i.e. the petri net contains all observed behavior. in this particular case,
also the reverse holds, i.e., all possible ﬁring sequences of the petri net shown in
figure 1 are contained in the log. generally, this is not the case since in practiceit is unrealistic to assume that all possible behavior is always contained in the
log, cf. the discussion on completeness in [4].
ab
dec
fgh
fig. 1. petri net discovered based on the event log in table 1.
existing approaches for mining the process perspective [3–6, 11, 13, 18] have
problems dealing with issues such as duplicate activities, hidden activities, non-
free-choice constructs, noise, and incompleteness. the problem with duplicate
activities occurs when the same activity can occur at multiple places in the pro-
cess. this is a problem because it is no longer clear to which activity some event
refers. the problem with hidden activities is that essential routing decisions are
not logged but impact the routing of cases. non-free-choice constructs are prob-
lematic because it is not possible to separate choice from synchronization. we
consider two sources of noise: (1) incorrectly logged events (i.e., the log does
not reﬂect reality) or (2) exceptions (i.e., sequences of events corresponding to
“abnormal behavior”). clearly noise is diﬃcult to handle. the problem of incom-
pleteness is that for many processes it is not realistic to assume that all possible
behavior is contained in the log. for processes with many alternative routes and
parallelism, the number of possible event traces is typically exponential in the
number of activities, e.g., a process with 10 binary choices in a sequence willhave 210(= 1024) possible event sequences and a process with 10 activities in
parallel will have even 10!(= 3628800) possible event sequences.
we can consider process mining as a search for the most appropriate process
out of the search space of candidate process models. mining algorithms can use
diﬀerent strategies to ﬁnd the most appropriate model. two extreme strategies
can be distinguished (i) local strategies primarily based on a step by step building
of the optimal process model based on local information, and (ii) global strategies
primarily based on a one strike search for the optimal model. most process
mining approaches use a local strategy. an example of a such a local strategy is
used by the α-algorithm [4] where only local information about binary relations
between events is used. a genetic search is an example of a global search strategy;because the quality or ﬁtness of a candidate model is calculated by comparing
the process model with all traces in the event log the search process takes place
at a global level. for a local strategy there is no guarantee that the outcomeof the locally optimal steps (at the level of binary event relations) will result in
a globally optimal process model. hence, the performance of such local mining
techniques can be seriously hampered when the necessary information is notlocally available because one erroneous example can completely mess up the
derivation of a right model. therefore, we started to use genetic algorithms.
in this paper, we present a genetic algorithm to discover a petri net given a
set of event traces . genetic algorithms are adaptive search methods that try to
mimic the process of evolution [9]. these algorithms start with an initial popula-
tion of individuals (in this case process models). populations evolve by selectingthe ﬁttest individuals and generating new individuals using genetic operators
such as crossover (combining parts of two of more individuals) and mutation
(random modiﬁcation of an individual). our initial work on applying geneticalgorithms to process mining [14] shows that a direct representation of individ-
uals in terms of a petri net is not a very convenient. first of all, the petri net
contains places that are not visible in the log. (note that in figure 1 we cannotassign meaningful names to places.) second, the classical petri net is not a very
convenient notation for generating an initial population because it is diﬃcult to
apply simple heuristics. third, the deﬁnition of the genetic operators (crossoverand mutation) is cumbersome. finally, the expressive power of petri nets is in
some cases too limited (combinations of and/or-splits/joins). therefore, we
use an internal representation named casual matrix . however, we use petri nets
to give semantics to this internal representation and adopt many ideas from petri
nets (e.g., playing the token game to measure ﬁtness). moreover, in this paper
we focus on the relation between the casual matrix and petri nets.
the remainder of this paper is organized as follows. first, we discuss some
related work (section 2) and start with some preliminaries (section 3). then,
in section 4, we present the causal matrix as our internal representation. insection 5 we explore the relation between the causal matrix and petri nets.
section 6 introduces the genetic algorithm and in section 7 some experimental
results are given. finally, we conclude the paper.2 related work
the idea of process mining is not new [3, 4, 2, 5, 6, 11, 13, 18]. most of the scien-
tiﬁc papers aim at the control-ﬂow perspective, although a few focus on other
perspectives such as the organizational perspective [2]. it is also interesting to
note that some commercial tools such as aris ppm oﬀer some limited form of
process mining as discussed in this paper. however, most tools in the bpi/bam
arena focus on key performance indicators such as ﬂow time and frequencies.
given the many papers on mining the process perspective it is not possi-
ble to give a complete overview. instead we refer to [3, 4]. historically, cook et
al. [6] and agrawal et al. [5] started to work on the problem addressed in thispaper. herbst et al. [11] took an alternative approach which allows for dealing
with duplicate activities. the authors of this paper have been involved in dif-
ferent variants of the so-called α-algorithm [4, 18]. each of the approaches has
its pros and its cons. most approaches that are able to discover concurrency
have problems dealing with issues such as duplicate activities, hidden activities,non-free-choice constructs, noise, and incompleteness.
there have been some papers combining petri nets and genetic algorithms,
cf. [12, 15–17]. however, these papers do not try to discover a process modelbased on some event log.
for readers familiar with petri net theory, it is important to discuss the rela-
tion between this work and the work on regions [8]. the seminal work on regions
investigates which transition systems can be represented by (compact) petri nets
(i.e., the so-called synthesis problem). although there are related problems suchas duplicate transitions, etc., the setting is quite diﬀerent because our notion
of completeness is much weaker than perfect knowledge of the underlying tran-
sition system. we assume that the log contains only a fraction of the possiblebehavior, as mentioned in the introduction.
the approach in this paper is the ﬁrst approach using genetic algorithms
for process discovery. some more details about the experimental/genetic-side of
this approach can be found in a technical report [14]. the goal of using genetic
algorithms is to tackle problems such as duplicate activities, hidden activities,non-free-choice constructs, noise, and incompleteness, i.e., overcome the prob-
lems of some of the traditional approaches. however, in this paper we focus on
the initial idea and the representation rather than a comparison with existingnon-genetic algorithms.
3 preliminaries
this section brieﬂy introduces the basic petri net terminology and notations,
and also discusses concepts such as wf-nets andsoundness .
deﬁnition 1 (petri net). a petri net is a triple (p,t,f ).pis a ﬁnite set of
places, tis a ﬁnite set of transitions ( p∩t=∅), and f⊆(p×t)∪(t×p)
is a set of arcs (ﬂow relation).for any relation/directed graph g⊆n×nwe deﬁne the preset •n={(m1,m2)∈
g|n=m2}and postset n•={(m1,m2)∈g|n=m1}for any node n∈n.
we useg•norng•to explicitly indicate the context gif needed. based on the
ﬂow relation fwe use this notation as follows. •tdenotes the set of input places
for a transition t. the notations t•,•pandp•have similar meanings, e.g., p•is
the set of transitions sharing pas an input place. note that we do not consider
multiple arcs from one node to another.
at any time a place contains zero or more tokens , drawn as black dots. this
state, often referred to as marking , is the distribution of tokens over places, i.e.,
m∈p→i n. for any two states m1andm2,m1≤m2iﬀ for all p∈p:
m1(p)≤m2(p). we use the standard ﬁring rule , i.e., a transition tis said to
beenabled iﬀ each input place poftcontains at least one token, an enabled
transition may ﬁre, and if transition tﬁres, then tconsumes one token from
each input place poftandproduces one token for each output place poft.
given a petri net ( p,t,f ) and a state m1, we have the standard notations
for a transition tthat is enabled in state m1and ﬁring tinm1results in state
m2(notation: m1t→m2) and a ﬁring sequence σ=t1t2t3...tn−1leads from
statem1to state mnvia a (possibly empty) set of intermediate states (notation:
m1σ→mn). a state mnis called reachable fromm1(notation m1∗→mn)i ﬀ
there is a ﬁring sequence σsuch that m1σ→mn. note that the empty ﬁring
sequence is also allowed, i.e., m1∗→m1.
in this paper, we will focus on a particular type of petri nets called workflow
nets(wf-nets) [1, 7, 10].
deﬁnition 2 (wf-net). a petri net pn =(p,t,f )is a wf-net (workﬂow
net) if and only if:
(i) there is one source place i∈psuch that •i=∅.
(ii) there is one sink place o∈psuch that o•=∅.
(iii) every node x∈p∪tis on a path from itoo.
a wf-net represents the life-cycle of a case that has some initial state repre-
sented by a token in the unique input place ( i) and a desired ﬁnal state rep-
resented by a token in the unique output place ( o). the third requirement in
deﬁnition 2 has been added to avoid “dangling transitions and/or places”. inthe context of workﬂow models or business process models, transitions can be
interpreted as tasks oractivities and places can be interpreted as conditions .
although the term “workflow net” suggests that the application is limited to
workﬂow processes, the model has wide applicability, i.e., any process where
each case has a life-cycle going from some initial state to some ﬁnal state ﬁtsthis basic model.
the three requirements stated in deﬁnition 2 can be veriﬁed statically, i.e.,
they only relate to the structure of the petri net. to characterize desirable dy-namic properties, the notation of soundness has been deﬁned [1, 7, 10].
deﬁnition 3 (sound). a procedure modelled by a wf-net pn =(p,t,f )is
sound if and only if:(i) for every state mreachable from state i, there exists a ﬁring sequence leading
from state mto state o. formally: ∀m(i∗→m)⇒(m∗→o).1
(ii) state ois the only state reachable from state iwith at least one token in
place o. formally: ∀m(i∗→m∧m≥o)⇒(m=o).
(iii) there are no dead transitions in (pn,i). formally: ∀t∈t∃m,m/primei∗→mt→
m/prime.
note that the soundness property relates to the dynamics of a wf-net. the
ﬁrst requirement in deﬁnition 3 states that starting from the initial state (state
i), it is always possible to reach the state with one token in place o(state o).
the second requirement states that the moment a token is put in place o, all
the other places should be empty. the last requirement states that there are no
dead transitions (activities) in the initial state i.
4 causal matrix
after these preliminaries we return to the goal of this paper: genetic process
mining. in order to apply a genetic algorithm we need to represent individuals.
each individual corresponds to a possible process model and its representationshould be easy to handle. our initial idea was to represent processes directly
by petri nets. unfortunately, petri nets turn out to be a less convenient way
to represent processes in this context. the main reason is that in petri netsthere are places whose existence cannot be derived from the log, i.e., events
only refer to the active components of the net (transitions). because of this it
becomes more diﬃcult to generate an initial population, deﬁne genetic operators(crossover and mutation), and describe combinations of and/or-splits/joins.
note that given a log it is very easy to discover the activities and therefore the
transitions that exist in the petri net. however, enforcing certain routings by justconnecting transitions through places is complex (if not impossible). therefore,
we will use a diﬀerent internal representation. however, this representation and
its semantics are closely linked to petri nets as will be shown in section 5.
table 2 shows the internal representation of an individual used by our ge-
netic mining approach. this so-called causal matrix deﬁnes the causal relations
between the activities and in case of multiple input or output activities, the logic
is depicted. consider for example the row starting with a. this row shows that
there is a not a causal relation between aanda(note the ﬁrst 0 in the row),
but there is a causal relation between aandb(note the ﬁrst 1 in this row). the
next two entries in the row show that there are also causal relations betweenaandcandaandd. the last element in the row shows the routing logic,
i.e.,b∨c∨dindicates that ais followed by b,c,o rd. the column labelled
‘output’ shows the logic relating an activity to causally following activities.
the ﬁrst row below ‘input’ shows the logic relating an activity to causally
1note that there is an overloading of notation: the symbol iis used to denote both
theplace i and the statewith only one token in place i. the same holds for o.input
true a a a d de∧fb∨c∨g
→ a b c d e f g h output
a 0 1 1 1 0 0 0 0 b∨c∨d
b 0 0 0 0 0 0 0 1 h
c 0 0 0 0 0 0 0 1 h
d 0 0 0 0 1 1 0 0 e∧f
e 0 0 0 0 0 0 1 0 g
f 0 0 0 0 0 0 1 0 g
g 0 0 0 0 0 0 0 1 h
h 0 0 0 0 0 0 0 0 true
table 2. a causal matrix is used for the internal representation of an individual.
preceding activities. note that the input condition of aistrue, i.e., no input
needed. activity ghase∧fas input condition, i.e., both eandfneed to
complete in order to enable g. activity hhasb∨c∨gas input condition,
i.e.,b,c,o rgneeds to complete in order to enable h.
activity input output
a {} {{b,c,d }}
b {{a}} {{h}}
c {{a}} {{h}}
d {{a}} {{e},{f}}
e {{d}} {{g}}
f {{d}} {{g}}
g {{e},{f}} {{h}}
h {{b,c,g }} {}
table 3. a more succinct encoding of the individual shown in table 2.
table 3 shows a more convenient notation removing some of the redundancies.
note that the 0 and 1 entries in table 2 can be trivially derived from the input
and output conditions. moreover, we assume that we can write the logical expres-
sions in a normal form, e.g., {{b,c,d }}corresponds to b∨c∨d,{{e},{f}}
corresponds to e∧f,a n d {{a,b},{c,d}}corresponds to ( a∨b)∧(c∨d).
in fact, the logical expression is represented by a set of sets corresponding to a
conjunction of disjunctions, i.e., a kind of conjunctive normal form (cnf).2
let us now formalize the notion of a causal matrix .
deﬁnition 4 (causal matrix). a causal matrix is a tuple cm =(a,c,i,o ),
where
-ais a ﬁnite set of activities,
-c⊆a×ais the causality relation,
2note that unlike the conjunctive normal form we do not allow for negation and also
do not allow for “overlapping” disjunctions, cf. deﬁnition 4.-i∈a→p(p(a))is the input condition function,3
-o∈a→p(p(a))is the output condition function,
such that
-c={(a1,a2)∈a×a|a1∈/uniontexti(a2)},4
-c={(a1,a2)∈a×a|a2∈/uniontexto(a1)},
-∀a∈a∀s,s/prime∈i(a)s∩s/prime/negationslash=∅⇒ s=s/prime,
-∀a∈a∀s,s/prime∈o(a)s∩s/prime/negationslash=∅⇒ s=s/prime,
-c∪{(ao,ai)∈a×a|aoc•=∅∧c•ai=∅}is a strongly connected graph.
the mapping of table 3 onto cm=(a,c,i,o ) is straightforward (the latter
two columns represent iando). note that ccan be derived from both iand
o. its main purpose is to ensure consistency between iando. for example,
ifa1has an output condition mentioning a2, then a2has an input condition
mentioning a1(and vice versa). this is enforced by the ﬁrst two constraints.
the third and fourth constraint indicate that some activity amay appear only
once in the conjunction of disjunctions, e.g., {{a,b},{a,c}}is not allowed
because aappears twice. the last requirement has been added to avoid that the
causal matrix can be partitioned in two independent parts or that nodes are not
on a path from some source activity aito a sink activity ao.
5 relating the causal matrix and petri nets
in this section we relate the causal matrix to petri nets. we ﬁrst map petri nets
(in particular wf-nets) onto the notation used by our genetic algorithms. thenwe consider the mapping of the causal matrix onto petri nets.
5.1 mapping a petri net onto a causal matrix
the mapping from an arbitrary petri net to its corresponding causal matrix
illustrates the expressiveness of the internal format used for genetic mining.
first, we give the deﬁnition of the mapping π
pn→cm.
deﬁnition 5 ( πpn→cm).let pn =(p,t,f )be a petri net. the mapping of
pn is a tuple πpn→cm(pn)=(a,c,i,o ),w h e r e
-a=t,
-c={(t1,t2)∈t×t|t1•∩•t2/negationslash=∅},
-i∈t→p(p(t))such that ∀t∈ti(t)={•p|p∈•t},
-o∈t→p(p(t))such that ∀t∈to(t)={p•|p∈t•}.
3p(a) denotes the powerset of some set a.
4
/cbi(a2) is the union of the sets in set i(a2).letpnbe the petri net shown in figure 1. it is easy to check that πpn→cm(pn)
is indeed the causal matrix in table 2. however, there may be petri nets pnfor
which πpn→cm(pn) is not a causal matrix. the following lemma shows that
for the class of nets we are interested in, i.e., wf-nets, the requirement that
there may not be two diﬀerent places in-between two activities is suﬃcient toprove that π
pn→cm(pn) represents a causal matrix as deﬁned in deﬁnition 4.
lemma 1. let pn =(p,t,f )be a wf-net with no duplicate places in between
two transitions, i.e., ∀t1,t2∈t|t1•∩•t2|≤1.πpn→cm(pn)represents a causal
matrix as deﬁned in deﬁnition 4.
proof. letπpn→cm=(a,c,i,o ). clearly, a=tis a ﬁnite set, c⊆a×a,
andi,o∈a→p(p(a)).c={(a1,a2)∈a×a|a1∈/uniontexti(a2)}because
a1∈/uniontexti(a2) if and only if a1•∩•a2/negationslash=∅. similarly, c={(a1,a2)∈a×a|a2∈/uniontexto(a1)}.∀a∈a∀s,s/prime∈i(a)s∩s/prime/negationslash=∅⇒ s=s/primebecause ∀t1,t2∈t|t1•∩•t2|≤1.
similarly, ∀a∈a∀s,s/prime∈o(t)s∩s/prime/negationslash=∅⇒ s=s/prime. finally, it is easy to verify that
c∪{(ao,ai)∈a×a|ao•=∅∧• ai=∅}is a strongly connected graph. /intersectionsq/unionsq
the requirement ∀t1,t2∈t|t1•∩• t2|≤1 is a direct result of the fact that
in the conjunction of disjunctions in iando, there may not be any overlaps.
this restriction has been added to reduce the search space of the genetic mining
algorithm, i.e., the reason is more of a pragmatic nature. however, for the successof the genetic mining algorithm such reductions are of the utmost importance.
5.2 a naive way of mapping a causal matrix onto a petri net
the mapping from a causal matrix onto a petri net is more involved because we
need to “discover places” and, as we will see, the causal matrix is slightly more
expressive than classical petri nets.
5let us ﬁrst look at a naive mapping.
deﬁnition 6 ( πn
cm→pn).let cm =(a,c,i,o )be a causal matrix. the naive
petri net mapping is a tuple πn
cm→pn(cm)=(p,t,f ),w h e r e
-p={i,o}∪{it,s|t∈a∧s∈i(t)}∪{ot,s|t∈a∧s∈o(t)},
-t=a∪{mt1,t2|(t1,t2)∈c},
-f={(i,t)|t∈a∧c•t=∅} ∪ { (t,o)|t∈a∧tc•=∅} ∪ { (it,s,t)|t∈
a∧s∈i(t)}∪{(t,ot,s)|t∈a∧s∈o(t)}∪{(ot1,s,mt1,t2)|(t1,t2)∈
c∧s∈o(t1)∧t2∈s}∪{(mt1,t2,it2,s)|(t1,t2)∈c∧s∈i(t2)∧t1∈s}.
the mapping πn
cm→pnmaps activities onto transitions and adds input places
and output places to these transitions based on functions iando. these places
are local to one activity. to connect these local places, one transition mt1,t2
is added for every ( t1,t2)∈c. figure 2 shows a causal matrix and its naive
mapping πn
cm→pn(we have partially omitted place/transition names).
5expressiveness should not be interpreted in a formal sense but in the sense of con-
venience when manipulating process instances, e.g., crossover operations.activity input output
a {} {{c,d}}
b {} {{d}}
c {{a}} {}
d {{a, b}} {}a
bc
d
a
bc
d(a) naive mapping.
(b) incorrect mapping.
fig. 2. a causal matrix (left) and two potential mappings onto petri nets (right).
figure 2 shows two wf-nets illustrating the need for “silent transitions” of
the form mt1,t2. the dynamics of the wf-net shown in figure 2(a) is consis-
tent with the causal matrix. if we try to remove the silent transitions, the bestcandidate seems to be the wf-net shown in figure 2(b). although this is a
sound wf-net capturing incorporating the behavior of the wf-net shown in
figure 2(a), the mapping is notconsistent with the causal matrix. note that
figure 2(b) allows for a ﬁring sequence where bis followed by c. this does
not make sense because c/negationslash∈/uniontexto(b)a n d b/negationslash∈/uniontexti(c). therefore, we use the
mapping given in deﬁnition 6 to give petri-net semantics to causal matrices.
it is easy to see that a causal matrix deﬁnes a wf-net. however, note that
the wf-net does not need to be sound.
lemma 2. let cm =(a,c,i,o )be a causal matrix. π
n
cm→pn(cm)is a
wf-net.
proof. it is easy to verify the three properties mentioned in deﬁnition 2. note
that the “short-circuited” cis strongly connected and that each mt1,t2transition
makes a similar connection in the resulting petri net. /intersectionsq/unionsq
figure 3 shows that despite the fact that πn
cm→pn(cm) is a wf-net, the
introduction of silent transitions may introduce a problem. figure 3(b) shows the
wf-net based on deﬁnition 6, i.e., the naive mapping. clearly, figure 3(b) is notsound because there are two potential deadlocks, i.e., one of the input places of e
is marked and one of the input places of fis marked but none of them is enabled.
the reason for this is that the choices introduced by the silent transitions are not“coordinated” properly. if we simply remove the silent transitions, we obtain the
wf-net shown in figure 3(a). this network is consistent with the causal matrix.
this can easily be checked because applying the mapping π
pn→cmdeﬁned in
deﬁnition 5 to this wf-net yields the original causal matrix shown in figure 3.
figures 2 and 3 show a dilemma. figure 2 demonstrates that silent transitions
are needed while figure 3 proves that silent transitions can be harmful. thereare two ways to address this problem taking the mapping of deﬁnition 6 as a
starting point.
first of all, we can use relaxed soundness [7] rather than soundness [1]. this
implies that we only consider so-called sound ﬁring sequences and thus avoid theactivity input output
a {} {{b},{c,d}}
b {{a}} {{e,f}}
c {{a}} {{e}}
d {{a}} {{f}
e {{b},{c}} {{g}}
f {{b},{d}} {{g}}
g {{e},{f}} {}
a c
db e
fga c
db e
fg
(a) mapping without silent transitions.
(b) naive mapping.
fig. 3. another causal matrix (left) and two potential mappings onto petri nets (right).
two potential deadlocks in figure 3(b). see [7] for transforming a relaxed sound
wf-net into a sound one.
second, we can change the ﬁring rule such that silent transitions can only ﬁre
if they actually enable a non-silent transition. the enabling rule for non-silent
transitions is changed as follows: a non-silent transition is enabled if each of its
input places is marked or it is possible to mark all input places by just ﬁring
silent transitions , i.e., silent transitions only ﬁre when it is possible to enable a
non-silent transition. note that non-silent and silent transitions alternate and
therefore it is easy to implement this semantics in a straightforward and localized
manner.
in this paper we use the second approach, i.e., a slightly changed enabling/-
ﬁring rule is used to specify the semantics of a causal matrix in terms of a
wf-net. this semantics allows us also to deﬁne a notion of ﬁtness required for
the genetic algorithms. using the petri-net representation we can play the “tokengame” to see how each event trace in the log ﬁts the individual represented by
a causal matrix.
5.3 a more sophisticated mapping
although not essential for the genetic algorithms, we elaborate a bit on the
dilemma illustrated by ﬁgures 2 and 3. the dilemma shows that the causal
net representation is slightly more expressive than ordinary petri nets. (notethe earlier comment on expressiveness!) therefore, it is interesting to see which
causal matrices can be directly mapped onto a wf-net without additional silent
transitions. for this purpose we ﬁrst deﬁne a mapping π
r
cm→pnwhich only
works for a restricted class of causal matrices.
deﬁnition 7 ( πr
cm→pn).let cm =(a,c,i,o )be a causal matrix. the re-
stricted petri net mapping of is a tuple πr
cm→pn(cm),w h e r e-x={(ti,to)∈p(a)×p(a)|∀t∈tito∈o(t)∧∀ t∈toti∈i(t)},
-p=x∪{i,o},
-t=a,
-f={(i,t)|t∈t∧c•t=∅} ∪ { (t,o)|t∈t∧tc•=∅} ∪ { ((ti,to),t)∈
x×t|t∈to}∪{(t,(ti,to))∈t×x|t∈ti}.
if we apply this mapping to the causal matrix shown in figure 3, we obtain
the wf-net shown in figure 3(a), i.e., the desirable net without the superﬂuoussilent transitions. however, in some cases the π
r
cm→pndoes not yield a wf-
net because some connections are missing. for example, if we apply πr
cm→pn
to the causal matrix shown in figure 2, then we obtain a result where there
are no connections between a,b,c,a n d d. this makes sense because there
does not exist a corresponding wf-net. this triggers the question whether it ispossible to characterize the class of causal matrices for which π
r
cm→pnyields
the correct wf-net.
deﬁnition 8 (simple). let cm =(a,c,i,o )be a causal matrix. cm is sim-
ple if and only if ∀ta,tb∈t∀ta∈o(ta)∀tb∈o(tb)∀tc∈(ta∩tb)∀tc∈i(tc){ta,tb}⊆
tc⇒ta=tband∀ta,tb∈t∀ta∈i(ta)∀tb∈i(tb)∀tc∈(ta∩tb)∀tc∈o(tc)
{ta,tb}⊆tc⇒ta=tb.
clearly the causal matrix shown in figure 3 is simple while the one in figure 2
is not. the following lemma shows that πr
cm→pnprovides indeed the correct
mapping if the causal matrix is simple.
lemma 3. let cm =(a,c,i,o )be a causal matrix. if cm is simple, then
each of the following properties holds:
(i)∀(t1,t2)∈c∃t1,t2∈p(a)t1∈t1∧t2∈t2∧(∀t∈t1t2∈o(t))∧(∀t∈t2t1∈
i(t)),
(ii)πr
cm→pn(cm)is a wf-net, and
(iii)πpn→cm(πr
cm→pn(cm)) =cm.
proof. we only provide a sketch of the full proof (a more detailed proof is beyond
the scope of this paper). the ﬁrst property can be derived by using the following
observation: ( t1,t2)∈ciﬀ∃t2∈o(t1)t2∈t2iﬀ∃t1∈o(t2)t1∈t1. hence there is
exactly one t1andt2such that t1∈t1,t2∈t2,t2∈o(t1), and t1∈o(t2).
fort∈t1we need to prove that t2∈o(t). this follows from the deﬁnition of
simple by taking ta=t1andtb=t. the other cases are similar. the second
property follows from the ﬁrst one because if ( t1,t2)∈cthen a connecting
place between t1andt2is introduced by the set x. the rest of the proof is
similar to the proof of lemma 2. the third property can be shown using similararguments. note that no information is lost during the mapping onto the wf-
netπ
r
cm→pn(cm) and that πpn→cmretranslates the sets tiandtoin the
places of xto functions iando. /intersectionsq/unionsqin this section, we discussed the relation between the representation used by our
genetic algorithm and petri nets. we used this relation to give semantics to ourrepresentation. it was shown that this representation is slightly more expressive
than petri nets because any wf-net can be mapped into causal matrix while
the reverse is only possible after introducing silent transitions and modifying theﬁring rule or using relaxed soundness. we also characterized the class of causal
matrices that can be mapped directly. in the next sections, we will demonstrate
the suitability of the representation for genetic process mining.
6 genetic algorithm
in this section we explain how our genetic algorithm (ga) works. figure 4
describes its main steps. in the following subsections (6.1 – 6.3) we roughly
explain the most important building blocks of our genetic approach: (i) the
initialization process, (ii) the ﬁtness measurement, and (iii) the genetic operators.
for a more detailed explanation about the algorithm we refer to [14].
start i ii iii iv
viv endyes
no
fig. 4. main steps of our genetic algorithm. (i) read the event log. (ii) calculate
dependency relations among activities. (iii) build the initial population. (iv) calcu-
late individuals’ ﬁtness. (v) stop and return the ﬁttest individuals? (vi) create next
population by using the genetic operators.
6.1 initial population
the initial population is randomly built by the genetic algorithm. as explained in
section 4, individuals are causal matrices. when building the initial population,
we roughly follow deﬁnition 4. given a log, all individuals in any population
of the genetic algorithm have the same set of activities (or tasks) a. this set
contains the tasks that appear in the log. however, the causality relation cand
the condition functions iandomay be diﬀerent for every individual in the
population. additionally, to guide the ga algorithm during the building of the
initial population, the initialization of the causality relation cis supported by
the dependency measure heuristics [18]. the motivation behind this heuristic issimple. if, in the event log, the pattern t
1t2appears frequently and t2t1only as
an exception, then there is a high probability that t1andt2are in the causality
relation (i.e., ( t1,t2)∈c). the conditions functions iandoare randomly
built. as a result, the initial population can have any individual in the search
space deﬁned by a set of activities a. the higher the amount of tasks that a log
contains, the bigger this search space. given the event log in table 1, table 4shows two individuals that could be created during the initialization.individual1
activity input output
a {} {{b,c,d }}
b {{a}} {{h}}
c {{a}} {{h}}
d {{a}} {{e}}
e {{d}} {{g}}
f {} {{g}}
g {{e},{f}}{{h}}
h {{c,b,g }} {}individual2
activity input output
a {} {{b,c,d }}
b {{a}} {{h}}
c {{a}} {{h}}
d {{a}} {{e,f}}
e {{d}} {{g}}
f {{d}} {{g}}
g {{e},{f}} {{h}}
h {{c},{b},{g}} {}
table 4. two randomly created individuals for the log in table 1.
6.2 fitness calculation
if an individual in the genetic population correctly describes the registered be-
havior in the event log, the ﬁtness of that individual will be high. in our approach
the ﬁtness is strongly related to the number of correctly parsed traces from the
event log. note that in case of noisy situation, we cannot aim at mining a processmodel that can correctly parse alltraces, because the traces with noise cannot
also be parsed by the desired model.
the parsing technique we use for the causal matrix is very similar to the
ﬁring rule for petri nets as discussed in section 5.2. we use the naive semantics
with silent transitions that only ﬁre when needed and simply play the “tokengame”. when the activity to be parsed is not enabled, the parsing process does
not stop. the problem is registered and the parsing proceeds as if the activity
was enabled (conceptually, this is equivalent to adding the necessary missingtokens in the petri net to enable the activity and, then, ﬁring it). we adopt
this parsing semantics because it is more robust to noisy logs and it gives more
information about the ﬁtness of the complete process models (i.e not biased toonly the ﬁrst part of the process model). in a noise-free situation, the ﬁtness of a
model can be 1 (or 100%) (i.e. all traces can be parsed). in practical situations,
the ﬁtness value ranges from 0 to 1. the exact ﬁtness of an individual to a givenlog is given by the formula:
ﬁtness =0.40×
allparsedactivities
numberofactivitiesatlog+0.60×allproperlycompletedlogtraces
numberoftracesatlog
where: numberofactivitiesatlog is the number of activities in the log. for in-
stance, the log shown in table 1 has 18 activities. numberoftracesatlog is the
number of log traces, e.g., in table 1 there are 4. allparsedactivities is the sum
of parsed activities (i.e. activities that could ﬁre without the artiﬁcial additionof tokens) for all log traces. allproperlycompletedlogtraces is the number of log
traces that were properly parsed (i.e. after the parsing the end place is the only
one to be marked).6.3 genetic operations
we use elitism, crossover and mutation to build the population elements of the
next genetic generation. elitism means that a percentage of the ﬁttest individ-
uals in the current generation is copied into the next generation. crossover andmutation are the basic genetic operators. crossover creates new individuals (oﬀ-
springs) based on the ﬁttest individuals (parents) in the current population. so,
crossover recombines the ﬁttest material in the current population in the hope
that the recombination of useful material in one of the parents will generate an
even ﬁtter population element. the mutation operation will change some minordetails of a population element. the hope is that the mutation operator will
insert new useful material in the population. the genetic algorithm (ga) stops
when: (i) it ﬁnds an individual whose ﬁtness is 1; or(ii) it computes ngenera-
tions, where nis the maximum number of generation that is allowed; or(iii) the
ﬁttest individual has not changed for n/2 generations in a row. if none of these
conditions hold, the ga creates a new population as follows:
input : current population, elitism rate, crossover rate and mutation rate
output : new population
1. copy “elitism rate ×population size” of the best individuals in the current popu-
lation to the next population.
2. while there are individuals to be created do:
(a) use tournament selection to select parent1.
(b) use tournament selection to select parent2.
(c) select a random number rbetween 0(inclusive) and 1(exclusive).
(d) if rless than the crossover rate:
thendo crossover with parent1 and parent2. this operation generates two
oﬀsprings: oﬀspring1 and oﬀspring2.elseoﬀspring1 equals parent1 and oﬀspring2 equals parent2.
(e) mutate oﬀspring1 and oﬀspring2. (this step is only needed if the mutation
rate is non-zero.)
(f) copy oﬀspring1 and oﬀspring2 to the new population.
6
3. return the new population.
tournament selection to select a parent the tournament selection algorithm
randomly selects 5 individuals and returns the ﬁttest individual among the ﬁve
ones.
crossover the most important and complex genetic operation in our genetic
approach is the crossover operation. starting point of the crossover operation are
the two parents (i.e. parent1 and parent2). the result of applying the crossover
6note: if the population size is nand the new population has already n−1 individuals,
then only oﬀspring1 is copied into this new population.operation are two oﬀsprings (oﬀspring1 and oﬀspring2). first, the crossover al-
gorithm randomly selects an activity tto be the crossover point . this means
that the input and output of tin parent1 will be recombined with the in-
put and output of tin parent2. second, parent1 is copied to oﬀspring1 and
parent2 to oﬀspring2. third, the algorithm randomly selects a swap point for the
input( t) sets in both oﬀsprings and another swap point for the output( t)
sets. the swap point determines which subsets of the input/output of tin
the oﬀspring are going to be swapped (or exchanged). a random swap point is
chosen for every input/output and oﬀsprings. the respective input and
output sets of the crossover point at the two oﬀsprings are then recombined
by interchanging the subsets from the swap point until the end of the set. therecombined input/output sets are then checked to make sure that they are
proper partitions. finally, the two oﬀsprings undergo a repair operation called
update related elements .
update related elements when the parents (and consequently the oﬀ-
springs) have diﬀerent causal matrices, the crossover operation may generate
inconsistencies. note that the boolean expression may contain activities whoserespective cell in the causal matrix is zero. similarly, an activity may not appear
in the boolean expression after the crossover and the causal matrix still has a
non-zero entry for it. so, after the input/output sets have being recom-bined, we need to check the consistency of the recombined sets with respect to
the other activities boolean expressions and the causal matrix. when they are
inconsistent, we need to update the causal matrix and the related boolean expres-sions of the other activities. as an example, assume parent1 equals individual1
andparent2 equals individual2 in table 4. these two parents undergo crossover
and mutation to generate two oﬀsprings. let activity dbe the randomly selected
crossover point. since input1(d) equals input2(d), the crossover has no real
eﬀect for d’s input. let us look at the d’s output sets. both d’s outputsets have a single subset, so the only possible swap point to select equals 0, i.e.,
before the ﬁrst and only element. after swapping the subsets oﬀpring1 (parent1
after crossover) has input1(d)= {{a}}and output1(d)= {{e,f}}. note
that output1(d) now contains f. so, the update related elements algorithm
makes input1(f)= {{d}}.oﬀspring2 is updated in a similar way. the two
oﬀsprings are shown in table 5.
mutation the mutation works on the input and output boolean expres-
sions of an activity. for every activity tin an individual, a new random number
ris selected. whenever ris less than the “mutation rate”
7, the subsets in
input( t) are randomly merged or split. the same happens to output( t). as
an example, consider oﬀspring1 in table 5. assume that the random number
rwas less than the mutation rate for activity d. after applying the mutation,
7the mutation rate determines the probability that an individual’s task undergoes
mutation.oﬀspring1
activity input output
a {} {{b,c,d }}
b {{a}} {{h}}
c {{a}} {{h}}
d {{a}} {{e,f}}
e {{d}} {{g}}
f {{d}} {{g}}
g {{e},{f}}{{h}}
h {{c,b,g }} {}oﬀspring2
activity input output
a {} {{b,c,d }}
b {{a}} {{h}}
c {{a}} {{h}}
d {{a}} {{e}}
e {{d}} {{g}}
f {} {{g}}
g {{e},{f}} {{h}}
h {{c},{b},{g}} {}
table 5. example of two oﬀsprings that can be produced after a crossover between
the two individuals in table 4.
output(d) changes from {{e,f}}to{{e},{f}}. note that this mutation
does not change an individual’s causal relations, only its and-or/join-splitmay change.
7 some experimental results
to test our approach we applied the algorithm to many examples, mostly ar-tiﬁcially generated and some based on real-life logs [14]. in this paper we onlyconsider two wf-nets; one with 8 and one with 12 activities. both models con-
tain concurrency and loops. the wf-net with 8 activities corresponds to the ﬁrst
example in this paper, i.e., the petri net shown in figure 1. the other wf-netrepresents a completely diﬀerent process model. for each model we generated
10 diﬀerent event logs with 1000 traces. without noise the rediscovering of the
underlying wf-nets was no problem for the genetic algorithm. to test the be-havior of the genetic algorithm for event logs with noise, we used 6 diﬀerent
noise types: missing head ,missing body ,missing tail ,missing activity ,exchanged
activities andmixed noise . if we assume a event trace σ=t
1...tn−1tn, these noise
types behave as follows. missing head, body andtailrandomly remove subtraces
of activities in the head, body and tail of σ, respectively. the head goes from t1
totn/3. the body goes from t(n/3)+1tot(2n/3). the tail goes from t(2n/3)+1to
tn.missing activity randomly removes oneactivity from σ.exchanged activities
exchange two activities in σ.mixed noise is a fair mix of the other 5 noise types.
real life logs will typically contain mixed noise. however, the separation between
the noise types allow us to better assess how the diﬀerent noise types aﬀect the
genetic algorithm.
for every noisy type, we generated logs with 5%, 10% and 20% of noise. so,
every process model in our experiments has 6 ×3 = 18 noisy logs. for each
event-log the genetic algorithms runs 10 experiments with a diﬀerent random
initialization. the populations had 500 individuals and were iterated for at most
100 generations. the crossover rate was 1.0 and the mutation rate was 0.01. the
elitism rate was 0.01. details about the experiments and results can be found in
[14]. here we summarize the main ﬁndings.
overall the higher the noise percentage, the lower the probability the al-
gorithm will come up with the original wf-net. in this particular setting thealgorithm can always handle the missing tail noise type. this is related to the
high impact of proper completion in our ﬁtness measure. also the exchanged
activities noise type does not harm the performance of the algorithm. this is
related to the heuristic that is used during the initialization of the population.
missing head impacts more the algorithm because our ﬁtness does not (yet!)
punish individuals with missing tokens. missing body andmissing activity noise
types are the most diﬃcult to handle. this is also related to the heuristics during
the building of the initial population because the removal of activities generatest
1t2“fake” subtraces that will not be counter-balanced by subtraces t2t1. con-
sequently, the probability that the algorithm will causally relate t1andt2is
increased. tables 6 and 7 contain the results obtained for the noisy logs of thetwo process models with 8 and 12 activities.
noise type
noise missing missing missing missing exchanged mixed
percentage head tail body activity activities noise
5% 10/10 10/10 0/10 1/10 9/10 1/10
10% 10/10 10/10 1/10 1/10 5/10 3/10
20% 0/10 10/10 0/10 0/10 0/10 2/10
table 6. results of applying the genetic algorithm for noisy logs of the process model
with 8 activities, i.e., figure 1. the ratio relates the number of times the algorithm
found the correct model by the number of times the algorithm ran.
noise type
noise missing missing missing missing exchanged mixed
percentage head tail body activity activities noise
5% 10/10 10/10 0/10 0/10 10/10 2/10
10% 1/10 10/10 0/10 0/10 9/10 3/10
20% 1/10 10/10 0/10 0/10 8/10 2/10
table 7. results of applying the genetic algorithm for noisy logs of the process model
with 12 activities.
tables 6 and 7 show that our approach works well for relatively simple exam-
ples. moreover in contrast to most of the existing approaches it is able to dealwith noise. to improve our approach we are now reﬁning the ﬁtness calculation.
for instance, the ﬁtness should consider the number of tokens that remained in
the individual after the parsing is ﬁnished as well as the number of tokens thatneeded to be added during the parsing.
the generic mining algorithm presented in this paper is supported by a plu-
gin in the prom framework (cf. http://www.processmining.org). figure 5 showsscreenshot of the plugin. this screenshot presents the result for the process model
with 8 activities in terms of petri nets and epcs.
8 conclusion
in this paper we presented our ﬁrst experiences with a more global mining tech-
nique (e.g. a genetic algorithm). for convenience we did not use petri nets forfig. 5. a screenshot of the geneticminer plugin in the prom framework analyzing the
event log in table 1 and generating the correct wf-net, i.e., the one shown in figure 1.
the internal representation of the individuals in a genetic population. instead we
used causal matrices which are slightly more expressive. we elaborated on therelationships between our representation and petri nets. the bottom line is that
any wf-net can be mapped onto our notation and also some constructs that
require duplicate activities (i.e., two transitions with the same label) or silenttransitions (i.e., steps not visible in the log) can be discovered. this way the
approach overcomes some of the problems with earlier algorithms. for example,
it is possible to mine non-free choice constructs. the main added value of usinga genetic algorithm is the ability to deal with noise and incompleteness. at this
point in time we are ﬁne-tuning our genetic algorithms based on many artiﬁcial
examples (i.e., process mining based on simulation logs) and real-life examples.
experimental results on event logs with noise point out that we are on the right
track on our quest to develop a genetic algorithm that mines process models.our next steps will focus on further improvements of the ﬁtness measurement
so that it gives a better indication of the optimal ﬁt between a process model
and an event-log.
references
1. w.m.p. van der aalst. business process management demystiﬁed: a tutorial on
models, systems and standards for workﬂow management. in j. desel, w. reisig,and g. rozenberg, editors, lectures on concurrency and petri nets , volume 3098
oflecture notes in computer science , pages 1–65. springer-verlag, berlin, 2004.
2. w.m.p. van der aalst and m. song. mining social networks: uncovering interac-
tion patterns in business processes. in j. desel, b. pernici, and m. weske, editors,international conference on business process management (bpm 2004) ,v o l u m e
3080 of lecture notes in computer science , pages 244–260. springer-verlag, berlin,
2004.
3. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
4. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.5. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
6. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
7. j. dehnert and w.m.p. van der aalst. bridging the gap between business models
and workﬂow speciﬁcations. international journal of cooperative information
systems , 13(3):289–332, 2004.
8. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures — part 1 and part
2.acta informatica , 27(4):315–368, 1989.
9. a.e. eiben and j.e. smith. introduction to evolutionary computing . natural
computing. springer-verlag, berlin, 2003.
10. k. van hee, n. sidorova, and m. voorhoeve. soundness and separability of work-
ﬂow nets in the stepwise reﬁnement approach. in w.m.p. van der aalst and
e. best, editors, application and theory of petri nets 2003 , volume 2679 of lec-
ture notes in computer science , pages 335–354. springer-verlag, berlin, 2003.
11. j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
12. h. mauch. evolving petri nets with a genetic algorithm. in e. cantu-paz and
j.a. foster et al., editors, genetic and evolutionary computation (gecco 2003) ,
volume 2724 of lecture notes in computer science , pages 1810–1811. springer-
verlag, berlin, 2003.
13. a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workﬂow
mining: current status and future directions. in r. meersman, z. tari, and d.c.schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science ,p a g e s
389–406. springer-verlag, berlin, 2003.
14. a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. using ge-
netic algorithms to mine process models: representation, operators and results.
beta working paper series, wp 124, eindhoven university of technology, eind-hoven, 2004.
15. j.h. moore and l.w. hahn. petri net modeling of high-order genetic systems
using grammatical evolution. biosystems , 72(1-2):177–86, 2003.
16. j.h. moore and l.w. hahn. an improved grammatical evolution strategy for
hierarchical petri net modeling of complex genetic systems. in g.r. raidl et al.,
editor, applications of evolutionary computing, evoworkshops 2004 , volume 3005
oflecture notes in computer science , pages 63–72. springer-verlag, berlin, 2004.
17. j.p. reddy, s. kumanan, and o.v.k. chetty. application of petri nets and a
genetic algorithm to multi-mode multi-resource constrained project scheduling.
international journal of advanced manufacturing technology , 17(4):305–314, 2001.
18. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.