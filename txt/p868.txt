expert systems with applications  59 (2016) 101–118 
contents  lists available  at sciencedirect  
expert  systems  with  applications  
journal  homepage:  www.elsevier.com/locate/eswa  
building  instance  graphs  for highly  variable  processes  
claudia  diamantini  a , laura  genga  a , ∗, domenico  potena  a , wil van der aalst b 
a information  engineering  department,  universitá politecnica  delle marche, via brecce bianche, 60131 ancona, italy 
b faculty of mathematics  and computer  science, eindhoven  university  of technology,  nl-5600 mb, eindhoven,  the netherlands  
a r t i c l e i n f o 
article history: 
received  24 september  2015 
revised 16 april 2016 
accepted  17 april 2016 
available  online 23 april 2016 
keywords:  
process mining 
highly variable processes  
building instance graphs 
process instances  a b s t r a c t 
organizations  increasingly  rely on business  process analysis  to improve  operations  performance.  process 
mining can be exploited  to distill models from real process executions  recorded  in event logs, but exist- 
ing techniques  show some limitations  when applied in complex  domains,  where human actors have high 
degree of freedom  in the execution  of activities  thus generating  highly variable  processes  instances.  this 
paper contributes  to the research  on process mining in highly variable  domains,  focusing  on the genera-  
tion of process instance  models (in the form of instance  graphs) from simple event logs. the novelty of 
the approach  is in the exploitation  of ﬁltering  process discovery  (pd) techniques  coupled  with repairing,  
which allows obtaining  accurate  models for any instance  variant, even for rare ones. it is argued that this 
provides  the analyst with a more complete  and faithful knowledge  of a highly variable  process,  where no 
process execution  can be really targeted  as “wrong” and  hence overlooked.  the approach  can also ﬁnd 
application  in more structured  domains,  in order to obtain accurate  models of exceptional  behaviors.  the 
quality of generated  models will be assessed  by suitable  metrics and measured  in empirical  experiments  
enlightening  the advantage  of the approach.  
©2 0 1 6 elsevier  ltd. all rights reserved.  
1. introduction  
information  systems  are widely adopted  by organizations  to 
support  the execution  of their business  processes.  notable  exam- 
ples are business  process  management  systems  (bpms),  work- 
ﬂow management  systems  (wms),  enterprise  resource  planning  
(erp), and customer  relationship  management  (crm). these sys- 
tems typically  record all past process  executions  in an event log . 
a single execution  of a business  process  is called process  instance  , 
or case , and it can include  parallel  execution  of business  activities.  
however,  event logs typically  store only the trace of a process  in- 
stance,  i.e., the sequence  of the activities  stored according  to their 
temporal  order of occurrence.  typically  the start time of the activ- 
ity is also recorded  together  with an instance  identiﬁer.  depending  
on the system,  other information  can be found as well, like the ex- 
ecutor, input/output  data, and the total duration  of the activity  (or, 
equivalently,  its end time). 
event logs store invaluable  information  about organization’s  be- 
havior that can be exploited  by analysts  to monitor  and improve  
operations  performance.  simple  analyses  can be performed  directly  
on sequential  traces. for instance,  average  instance  lead time, re- 
∗corresponding  author. 
e-mail addresses:  c.diamantini@univpm.it  (c. diamantini),  l.genga@univpm.it  (l. 
genga), d.potena@univpm.it  (d. potena), w.m.p.v.d.aalst@tue.nl  (w. van der aalst). source usage, event interval  analysis  ( suriadi,  ouyang,  van der 
aalst, & ter hofstede,  2015 ) can be obtained.  however,  more in- 
sights can be derived  only when the control  ﬂow structure  of the 
instance  is known  or, in other terms, when the instance  model is 
known.  an instance  model explicitly  represents  parallelisms  among  
activities  that are hidden  in the sequential  trace, e.g., in the form 
of an instance  graph . fig. 1 shows a simple example  of a set of 
traces and the corresponding  instance  graphs  (ig). 
in order to build instance  models,  causal relations  among  ac- 
tivities must be known,  or they can be inferred  from event logs. 
process  discovery  is the discipline  devoted  to infer relations  from 
a log and build models.  process  discovery  (pd) techniques  belong 
to the broader  process  mining discipline,  whose goal consists  in 
discovering,  monitoring  and improving  a given process  exploiting  
event log generated  during process  execution  ( van der aalst, 2011 ). 
most of techniques  aim to generate  a complete  process  model. 
however,  such a model is not always required,  and a good rep- 
resentation  of each individual  process  instance  can provide  useful 
insights  as well, and can be used in addressing  several  tasks. as 
an example,  ( lu, fahland,  & van der aalst, 2015 ) proposes  to ex- 
ploit instance  models  in conformance  checking  applications,  i.e., 
for measuring  the extent to which actual executions  adhere  to a 
predeﬁned  normative  process  model. ( van beest, dumas,  garcía-  
ba nuelos,  & la rosa, 2015 ) uses instance  models  to implement  
a log delta-analysis  technique,  which allows to identify  relevant  
differences  between  the executions  recorded  in two event logs. 
http://dx.doi.org/10.1016/j.eswa.2016.04.021  
0957-4174/© 2016 elsevier ltd. all rights reserved.  102 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
1 /angbracketlefta,b,c,d,e,f,g/angbracketright
2 /angbracketlefta,b,c,e,d,f,g/angbracketright
3 /angbracketlefta,i,l,m,g/angbracketright
b a
fig. 1. a set of traces (a) and their corresponding  instance graphs (b). 
another  relevant  application  is described  in our previous  work 
( diamantini,  genga, & potena,  2016; diamantini,  genga, potena,  & 
storti, 2013; diamantini,  potena,  & storti, 2012 ), where we intro- 
duced a methodology  aimed at extracting  the most relevant  com- 
mon substructures  in a set of instance  models.  
in the literature,  some approaches  to build instance  models  ex- 
ploit information  of richly annotated  logs like i/o data (an activ- 
ity that needs certain  data in input causally  depends  from activi- 
ties producing  that data in output),  or the overlap  between  execu- 
tion intervals  (if two intervals  overlap  then clearly the correspond-  
ing activities  has been executed  in parallel).  the applicability  of 
these approaches  is thus limited.  others propose  the exploitation  
of some domain  knowledge  provided  by experts  (e.g., to publish  
articles,  they must undergo  a review cycle) or by a reference  pro- 
cess model. in this paper, we deal with building  ig from simple 
event logs, i.e., logs providing  the minimal  set of information,  and 
without  resorting  to any domain  knowledge.  in this setting,  to the 
best of our knowledge,  only two approaches  have been proposed,  
both based on the causal relations  inference  rules embedded  in the 
α-algorithm  pd technique  ( van beest et al., 2015; van dongen  & 
van der aalst, 2004 ). 
it is noteworthy  that the α-algorithm,  and then the two above 
mentioned  approaches,  perform  fairly well with well structured  
processes,  but they show limitations  when applied  to unstructured,  
highly variable  processes.  this kind of processes  is typical of real- 
world domains,  where human  actors have high degree of free- 
dom in the execution  of activities.  this is the case, for instance,  
of health care where, although  clinical  guidelines  are given, there 
may be good reasons  to deviate  from such guidelines  ( de man, 
2009; rovani,  maggi, de leoni, & van der aalst, 2015 ). the lim- 
its of the application  of α-algorithm  to highly variable  processes  
are well studied  in the literature.  they are related  to the inference  
of models  affected  by overgeneralization  . in practice,  being unable 
to recognize  existing  causal relations  among  activities,  the algo- 
rithm generates  models  involving  a high number  of parallel  activ- 
ities, thus allowing  for more instances  than the real ones. simi- 
larly, the use of the algorithm  to build ig produce  poor results,  in 
terms of inaccurate,  overgeneralizing  ig, accounting  for much more 
traces than those actually  recorded  in the event log. we provide  
a detailed  discussion  of overgeneralization  issues and examples  in 
section  4 . 
in this paper we propose  a novel methodology  that elaborates  
upon ( van beest et al., 2015; van dongen  & van der aalst, 2004 ) 
to improve  the quality  of generated  ig in the presence  of highly 
variable  processes.  we propose  to exploit  causal relation  inference  
rules typical of ﬁltering  techniques,  which model only the most 
frequent  process  behaviors,  thus being able to cut down overgen-  
eralization.  however,  the application  of a ﬁltering  technique  also 
presents  some drawbacks.  in particular,  (causal  relations  of) sev- eral traces of the event log are now not represented  in the model 
(i.e., they are irregular  with respect  to the model),  impacting  nega- 
tively on the quality  of the corresponding  ig. while in loosely  vari- 
able domains  this can still be acceptable,  since irregular  traces can 
be considered  the result of “wrong” or  outlier behaviors,  and can 
then be discarded,  this is not the case with highly variable  pro- 
cesses, where no execution  can be really targeted  as wrong and 
then overlooked,  or in the case we like to analyze  exactly  those 
outlier behaviors.  to address  this issue, we also propose  to couple 
the exploitation  of ﬁltering  techniques  with an original  technique  
aimed at repairing  ig of irregular  traces, thus providing  the analyst  
with a more complete  and faithful  knowledge  of the reality regis- 
tered in the event log. 
the quality  of generated  models  will be assessed  by suitable  
metrics  and measured  in empirical  experiments  enlightening  the 
advantage  of the approach.  
summing  up, the main contributions  of this work are as fol- 
lows: 
•we throughly  investigate  and discuss  the limitation  of existing  
pd techniques  to build ig in highly variable  domains;  
•we consider  two ﬁltering  techniques,  the heuristic  miner 
( weijters,  van der aalst, & de medeiros,  2006 ) and infrequent  
inductive  miner ( leemans,  fahland,  & van der aalst, 2014 ) al- 
gorithms,  to induce causal relations  between  activities  and we 
discuss  their features  in the context  of present  work; 
•we exploit  conformance  checking  techniques  to recognize  irreg- 
ular traces and then we introduce  a novel algorithm  aimed at 
repairing  irregular  ig, discussing  main challenges  and showing  
its behavior  by means of several  examples;  
•we provide  experimental  evidences  on both synthetic  and real- 
world logs, comparing  the proposed  methodology  with exist- 
ing approaches,  and by enlightening  the advantage  of repairing  
with respect  to simple ﬁltering  techniques,  using accuracy  and 
generalization  capability  as ﬁgures of merit. 
the rest of the paper is organized  as follows.  section  2 pro- 
vides an overview  of related  work. section  3 recalls some basic 
notions  and deﬁnitions.  section  4 introduces  the issues related  to 
the building  of ig in highly variable  domains.  in section  5 we de- 
lineate our methodology,  and in section  6 experimental  results are 
discussed.  finally,  in section  7 we draw some conclusions  and de- 
lineate future work. 
2. related  work 
our work aims at building  an instance  model, in the form of 
ig, for each trace of a given event log. moreover,  since igs built for 
highly variable  processes  are often of poor quality,  we introduce  
a repairing  procedure  aimed to enhance  them. in the following  c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 103 
subsections  ﬁrst we review some approaches  which deal with 
building  instance  models;  then we discuss  some techniques  aimed 
to enhance  process  models.  
2.1. building  instance  models 
pd is the process  mining  branch  aimed at extracting  models  
from event logs. a plethora  of different  techniques  has been de- 
veloped  during last years (see de weerdt  et al., 2012; van don- 
gen, alves de medeiros,  and wen, 2009 , for an overview).  most of 
them, however,  aim at deriving  a process  model able to describe  
the entire process;  our proposal,  instead,  is focused  on deriving  
models  describing  single process  instances.  few approaches  have 
been proposed  to deal with this issue, which can be grouped  in 
two categories,  i.e., model-based  and log-based  approaches,  intro- 
duced in the following  subsections.  
2.1.1. model-based  approaches  
these approaches  instantiate  instance  models  from an a-priori  
known  process  model. this is the case, for example,  of the vip tool 
( desel, juhás, lorenz,  & neumair,  2003 ), which, given a petri net, 
is able to derive the set of its runs , where each run represents  a 
single, complete  execution  of the net. the obtained  set of runs is 
exploited  for analysis  and validation  of the petri net. other exam- 
ples of building  of instance  models  can be found in some work- 
ﬂow management  systems.  among  them, we can mention  the in- 
concert  tool ( van der aalst & van hee, 2004 ), which is interesting  
from a historic  point of view. inconcert  aims at ensuring  a ﬂexi- 
ble management  of the workﬂows,  by supporting  both the classi- 
cal workﬂows  instantiation  from the overall process  model and the 
deﬁnition  of ad-hoc  workﬂow  instances.  the ad-hoc  instances  can 
be obtained  by modifying  an instance  of the model or by instanti-  
ating an empty instance,  allowing  the user to create the workﬂow  
instance  as she needs. furthermore,  the routing  of completed  in- 
stances  can be exploited  to create new instances  template.  clearly,  
in these approaches  the deﬁnition  of the instances  is more a de- 
sign activity,  rather than an automatic  discovery;  indeed,  the user 
has to specify  the high level deﬁnition  of the instance  models.  
2.1.2. log-based  approaches  
log-based  approaches  derive instance  models  starting  from a 
given event log. they ﬁrst derive the causal relations  existing  
among  process  activities,  and then use these relations  to build the 
instance  models.  three kinds of approaches  have been proposed  in 
literature,  namely  i) approaches  based on special  attributes  stored 
in the event log, ii) approaches  based on a-priori  knowledge  and, 
ﬁnally, iii) approaches  based on basic attributes  of the event log. 
examples  of approaches  of the ﬁrst group are ( hwang,  wei, & 
yang, 2004 ) and ( lu et al., 2015 ). in ( hwang  et al., 2004 ) authors  
propose  to take into account  temporal  relationships  between  ac- 
tivities.  for each pair of activities  a and b of a trace two types of 
temporal  relationships  are modeled,  i.e., 1) the “followed” relation-  
ship, which states that b is performed  after a is terminated,  and 2) 
the “overlapped” relationship,  which states that the execution  of a 
and b is temporally  overlapping.  to this end, authors  assume  the 
event log to store for each activity  both the starting  time end the 
completion  time, using these attributes  to derive the set of tem- 
poral relationships.  these relationships  are then used to build for 
each process  instance  an instance  model named  “temporal  graph”,  
which consists  in a directed  graph where each node corresponds  to 
an activity  of the trace, and an edge is inserted  between  two nodes 
only if a followed  relation  exists between  corresponding  activities.  
it should be noted that applicability  of this approach  is limited  
to event logs storing  the actual duration  of activities  executions.  
moreover,  temporal  relationships  are deﬁned  locally to each trace 
of the log. ( lu et al., 2015 ) proposes  an approaches  that deals with so-called  data annotated  log (dal), where each event has a set of 
input attributes,  describing  data that are read when executing  an 
activity,  and of output attributes,  describing  data that are written  
by the activity.  as one clearly argue, in a dal one can deﬁne re- 
liable ordering  relations,  since if an activity  a j has as input an at- 
tribute x , which is generated  as output by an activity  a i , obviously  
a j depends  on the execution  of a i and, hence, has to be executed  
after it. the generation  of a dal requires  either a suitable  event log 
management  system,  or the preprocessing  of the log by a domain  
expert.  many real life event logs do not include  any information  
about data dependencies.  
an example  of knowledge-based  approach  is implemented  in 
the aris ppm tool 1 . it models  each process  instance  as instance  
epc (i.e., event driven process  chain),  another  process  modeling  
formalism  (see e.g., forrester,  1999 ). the tool is able to build se- 
quential  instance  epcs and can acquire  domain  knowledge  by ex- 
perts in order to enrich an instance  epc with parallelisms.  
another  example  of knowledge-based  approach  is ( greco, 
guzzo, manco,  & saccà, 2007 ). here authors  assume  to have at dis- 
posal an a-priori  model of the process,  like those used in wms. 
they derive for each trace of the log the corresponding  process  in- 
stance by replaying  the trace on the model, i.e., by identifying  the 
enacted  subgraph  in the overall model, that is the one whose nodes 
correspond  to the activities  of the trace. the work also introduces  
the idea to exploit  a model mined from event logs by pd tech- 
niques,  as in our proposal.  however,  they do not delve into the is- 
sues related  with building  instances  from mined models,  assuming  
a correct  model can be generated,  which is not the case for highly 
variable  processes.  as a further  difference,  we start from causal re- 
lations,  instead  of using replay. the two approaches  are equivalent  
in the case all traces fully ﬁt the model, which, however,  is usually  
not the case when a ﬁltering  pd technique  is adopted.  
approaches  of group iii) address  the most general  case, i.e., the 
building  of instance  models  from a simple event log, storing  only 
basic information  for each activity,  i.e., its timestamp,  its name and 
the case it belongs  to, without  exploiting  additional  domain  knowl-  
edge. the approach  proposed  in this work belongs  to this group. 
to the best of our knowledge,  the only approaches  developed  to 
deal with this issue are ( van dongen  & van der aalst, 2004 ) and 
( van beest et al., 2015 ), which propose  to apply the α-algorithm  to 
derive, respectively,  the set of causal relations  and the set of par- 
allelisms  existing  among  activities  of the process.  ( van dongen  & 
van der aalst, 2004 ) uses causal relations  to determine  which ac- 
tivities have to be linked in an ig, generating  the graph in such 
a way that each activity  is linked to its closest causal predeces-  
sors and to its closest causal successors.  therefore,  an edge is in- 
serted between  two activities  only if a causal relation  exists among  
them. ( van beest et al., 2015 ) adopts the opposite  idea. at the be- 
ginning,  each activity  is linked to all its successors;  then, edges 
between  parallel  activities,  as well as edges linking  activities  be- 
tween which another  path exists, are removed.  hence, an edge is 
inserted  between  two activities  only when no explicit  parallelism  
exists among  them. 
it is noteworthy  that both approaches  present  severe limitations  
when addressing  highly variable  processes.  both of them exploit  
the α-algorithm  to derive the causal relations,  that is known  to 
have issues in dealing  with event logs of highly variable  processes.  
indeed,  in these cases the α-algorithm  usually  returns  imprecise,  
overgeneralizing  models,  i.e., models  allowing  for too much behav-  
iors, from which one obtains,  in turn, overgeneralizing  ig, which 
do not provide  any aid to the analysis  of corresponding  process  in- 
stances.  
1 http://www.softwareag.com/nl/products/aris  _ platform/aris  _ controlling/  
aris _ process _ performance/overview/default.asp  104 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
we use as starting  point for the development  of this work the 
approach  proposed  by ( van dongen  & van der aalst, 2004 ) in that 
we exploit  causal relations  for building  ig, adopting  a ﬁltering  pd 
technique  to infer causal relations  instead  of αrules. we point 
out, anyway,  that also the exploitation  of the parallelisms  could be 
taken into account.  
2.2. model enhancement  
the aim of model enhancement  techniques  consists  in exploit-  
ing information  recorded  in an event log to improve  a process  
model ( van der aalst, 2011 ). among  the possible  kinds of enhance-  
ment, our work is especially  related  to the the repairing  of a model. 
given a process  model and an event log which does not ﬁt the 
model, the goal of model repairing  techniques  consists  in modify-  
ing the original  model to better represent  the behaviors  stored in 
the event log. an example  of model repairing  is proposed  in ( buijs, 
la rosa, reijers,  van dongen,  & van der aalst, 2013 ). here, authors  
exploit  a genetic  pd technique  (i.e., the etm algorithm)  to infer a 
process  model from the event log. in particular  authors  propose  an 
extension  of the etm algorithm  to take into account  the structural  
similarity  between  the discovered  process  model and the reference  
one, to obtain a model that represents  the deviating  behaviors  re- 
maining  as close as possible  to the reference  model. 
a different  approach  is proposed  in ( fahland  & van der aalst, 
2015 ). here, authors  exploit  a conformance  checking  technique  to 
identify  possible  deviations  between  the event log and the process  
model, represented  by means of a petri net. if irregularities  exist, 
they add one or more fragments  representing  the irregular  behav-  
iors to the original  net, thus obtaining  a new petri net. more pre- 
cisely, for each irregular  behavior  authors  detect the corresponding  
“location”,  namely  the set of places that are marked  when the ir- 
regularity  occurs.  then, they group sequences  of irregular  activities  
which are related  to the same location.  finally,  a new petri net is 
inferred  from each group that is then integrated  into the original  
net. our repairing  procedure  presents  some similarities  with the 
idea proposed  in ( fahland  & van der aalst, 2015 ), since we also ex- 
ploit conformance  checking  to detect irregularities  and repair the 
model. however,  our approach  is tailored  to analyze  and repair di- 
rectly single instance  models.  to the best of our knowledge,  the 
approach  proposed  in this work is the ﬁrst attempt  aimed to deal 
with instance  model enhancement.  
3. preliminaries  
this section  introduces  important  concepts  used throughout  the 
paper, recalling  common  deﬁnitions  of pm literature  (e.g., van der 
aalst, 2011; 2013 ). in particular,  the ﬁrst two subsections  are de- 
voted to recall basic concepts,  e.g., some basic deﬁnitions  and con- 
cepts like event, trace, petri net and so on, while the remaining  sub- 
sections  describe  the main concepts  related  to conformance  check- 
ing, model evaluation  measures  and instance  graphs , respectively.  
3.1. basic concepts  
the concepts  we introduce  in this subsection  will be used in 
the deﬁnitions  provided  in the rest of the article. 
given a set a , b (a ) is the set of all multiset  s over a . some ex- 
amples:  b 1 = [] , b 2 = [ x, x, y ] , b 3 = [ x, y, z] , b 4 = [ x, x, y, x, y, z] , b 5 = 
[ x 3 , y 2 , z] are multisets  over a = { x, y, z} . b 1 is the empty multiset,  
b 2 and b 3 both consist  of three elements,  and b 4 = b 5 , i.e., the or- 
dering of elements  is irrelevant  and a more compact  notation  may 
be used for repeating  elements.  multisets  are used to represent  the 
state of a petri net and to describe  event logs where the same trace 
may appear  multiple  times. the standard  set operators  can be ex- tended  to multisets,  e.g., x ∈ b 2 , b 2 /unionmulti b 3 = b 4 , b 5 \ b 2 = b 3 , | b 5 | = 6 , 
etc. 
a relation  r ⊆x ×y is a set of pairs. π1 (r ) = { x | (x, y ) ∈ r } 
is the domain  of r , π2 (r ) = { y | (x, y ) ∈ r } is the range of r , 
and ω(r ) = π1 (r ) ∪ π2 (r ) are the elements  of r . for example,  
ω({ (a, b) , (b, c) } ) = { a, b, c} . a relation  (or function)  is bijective  if 
there is a one-to-one  correspondence  between  the elements  of the 
domain  and range, i.e., it is total, functional,  surjective,  and injec- 
tive. 
f : x /negationslash→ y is a partial function  with domain  dom ( f ) ⊆x and 
range rng (f) = { f(x ) | x ∈ x} ⊆y . f : x → y is a total function  , i.e., 
dom (f) = x. a partial function  f : x /negationslash→ y is injective  if f(x 1 ) = 
f(x 2 ) implies  x 1 = x 2 for all x 1 , x 2 ∈ dom ( f ). 
σ= /angbracketleft a 1 , a 2 , . . . , a n /angbracketright ∈ x ∗denotes  a sequence  over x of length n . 
/angbracketleft /angbracketright is the empty sequence.  sequences  are used to represent  paths 
in a graph and traces in an event log. σ1 ·σ1 is the concatenation  
of two sequences.  
functions  can also be applied  to sequences,  such that: if 
dom (f) = { x, y } , then f ( /angbracketleft y, z, y /angbracketright ) = /angbracketleft f ( y ), f ( y ) /angbracketright . 
deﬁnition  1. (applying  functions  to sequences)  
let f : x /negationslash→ y be a partial function.  f can be applied  to se- 
quences  of x using the following  recursive  deﬁnition  (1) f(/angbracketleft /angbracketright ) = /angbracketleft /angbracketright 
and (2) for σ∈ x ∗and x ∈ x : 
f(/angbracketleft x /angbracketright ·σ) = /braceleftbigg
f(σ) if x /negationslash∈ dom (f) 
/angbracketleft f(x ) /angbracketright ·f(σ) if x ∈ dom (f) 
3.2. events, traces, petri nets 
in this subsection,  we introduce  deﬁnitions  related  to event logs 
and their constituents,  as well as to petri nets. in the remainder,  
we assume  the following  universes  of names,  identiﬁers,  and val- 
ues: 
•cis the set of all possible  process  instance  identiﬁers,  where 
a process  instance  corresponds  to a speciﬁc  execution  of a pro- 
cess; 
•a is the set of all possible  activity  names,  where an activity  is a 
well-deﬁned  task that has to be performed  within the process;  
•eis the set of all possible  event identiﬁers,  where an event is 
an instance  of an activity.  
an event log is deﬁned  as follows:  
deﬁnition  2. (event log) 
l = (e, c, act , pi , /precedesequal) is an event log iff: 
•e ⊆eis a set of events identiﬁers,  
•c ⊆cis a set of identiﬁers  of process  instances  (or cases), 
•act : e → a maps events onto activities,  
•pi : e → c maps events onto process  instances,  and 
•/precedesequal⊆e ×e deﬁnes  a total order on events ( /precedesequalis reﬂexive,  anti- 
symmetric,  transitive,  and total). 2 
the goal of the pd is to elaborate  upon a given event log to de- 
rive a process  model which describes  the ordering  relations  existing  
between  activities  of the process.  process  instances  can be mapped  
onto traces of a process  model using the function  trace . 
deﬁnition  3. (trace)  
let l = (e, c, act , pi , /precedesequal) be an event log. trace : c → a ∗maps 
process  instances  onto traces such that for any process  instance  
c ∈ c : 
•trace (c) = /angbracketleft a 1 , a 2 , . . . , a n /angbracketright ∈ a ∗is a sequence  of activities,  each 
corresponding  to an event, 
2 e 1 ≺e 2 if and only if e 1 /precedesequale 2 and e 1 /negationslash = e 2 . c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 105 
•there exists a bijection  f c ∈ { 1 , 2 , . . . , n } → { e ∈ e | pi (e ) = c} 
such that 
–act (f c (i )) = a i for any i ∈ { 1 , 2 , . . . , n } , and 
–f c ( i ) /precedesequalf c ( j ) for any i, j ∈ { 1 , 2 , . . . , n } with i ≤j . 
note that there is a one-to-one  correspondence  between  the 
events of a process  instance  and positions  on the trace. in the con- 
text of an event log and a process  instance,  f c provides  the map- 
ping. hereafter,  given an event log l , we will write that σis a trace 
of l if there exists a c ∈ c such that σ= trace (c) . 
several  modeling  formalisms  exist to represent  process  models;  
in this work, we refer to the petri net , deﬁned  as follows:  
deﬁnition  4. (petri net) 
a petri net is a tuple n = (p, t , f ) with p the set of places, t 
the set of transitions,  p ∩ t = ∅ , and f ⊆( p ×t ) ∪ ( t ×p ) the ﬂow 
relation.  
places may contain  a discrete  number  of marks called token s; 
the distribution  of tokens is a conﬁguration  of the petri net, which 
is called a marking  . 
deﬁnition  5. (marking)  
let n = (p, t , f ) be a petri net. a marking  m is a multiset  of 
places, i.e., m ∈ b(p ) . 
a petri net deﬁnes  a bipartite  graph, with nodes p ∪ t and 
egdes f . for every x ∈ p ∪ t , n •x = { y | (y, x ) ∈ f } is the set of in- 
put nodes while, similarly,  x n •= { y | (x, y ) ∈ f } denotes  the set of 
output nodes ; we drop the superscript  n if it is clear from the con- 
text. a transition  t ∈ t is said enabled  only if there is at least one 
token for each of its input nodes. an enabled  transition  t may ﬁre , 
i.e., one token is removed  from each of the input places •t and 
one token is produced  for each of the output places t•. formally:  
m /prime = (m \ •t) /unionmulti t•is the marking  resulting  from ﬁring enabled  
transition  t in marking  m of petri net n . ( n, m )[ t /angbracketright ( n, m /prime ) denotes  
that t is enabled  in m and ﬁring t results in marking  m /prime . let 
σ= /angbracketleft t 1 , t 2 , . . . , t n /angbracketright ∈ t ∗be a sequence  of transitions.  ( n, m )[ σ/angbracketright ( n, 
m /prime ) denotes  that there is a set of markings  m 0 , m 1 , . . . , m n such 
that m 0 = m, m n = m /prime , and (n, m i )[ t i +1 /angbracketright (n, m i +1 ) for 0 ≤i < n . a 
marking  m /prime is reachable  from m if there exists a σsuch that ( n, 
m )[ σ/angbracketright ( n, m /prime ). 
deﬁnition  6. (firing sequence)  
let ( n, m ) with n = (p, t , f ) be a marked  petri net. a se- 
quence  σ∈ t ∗is called a ﬁring sequence  of ( n, m ) if and only 
if, for some natural  number  n ∈ n , there exist markings  m 1 , ..., 
m n and transitions  t 1 , . . . , t n ∈ t such that σ= /angbracketleft t 1 , . . . , t n /angbracketright and ∀ i : 
1 ..n ((n, m i )[ t i +1 /angbracketright (n, m i +1 )) . 
for process  modeling,  typically  labeled petri net are used, de- 
ﬁned as: 
deﬁnition  7. (labeled  petri net) 
a labeled  petri net n = (p, t , f , l) is a petri net ( p, t, f ) with 
labeling  function  l : t /negationslash→ a . let σv = /angbracketleft a 1 , a 2 , . . . , a n /angbracketright ∈ a ∗be a se- 
quence  of activities.  (n, m)[ σv ⊿ (n, m /prime ) if and only if there is a 
sequence  σ∈ t ∗such that ( n, m )[ σ/angbracketright ( n, m /prime ) and l(σ) = σv (cf. 
deﬁnition  1 ). 
we use the τlabel for a silent transition  , namely  a transi- 
tion t /negationslash∈ dom (l) . an example  of labeled  petri net is shown in 
fig. 2 , which will be used as running  example  throughout  the pa- 
per. for such a net, p = { start, p 1 , . . . , p 9 , end} , t = { t 1 , t 2 , . . . , t 13 } 
and f = { (start, t 1 ) , (t 1 , p 1 ) , (p 1 , t 2 ) , . . . , (t 13 , end) } . each transition  
is labeled,  e.g., l ( t 1 ) = a, l ( t 3 ) = b and so on. note that t 2 is a silent 
transition.  
for a given process,  typically  a speciﬁc  initial state (i.e., the ini- 
tial conﬁguration  of the net) and a speciﬁc  ﬁnal state (i.e., the ﬁnal 
conﬁguration  of the net) exist. this can be modeled  by referring  to the concept  of system net . 
deﬁnition  8. (system  net) 
a system  net is a triplet sn = (n, m init , m ﬁnal ) where n = 
(p, t , f , l) is a labeled  petri net, m init ∈ b(p ) is the initial marking,  
and m ﬁnal ∈ b(p ) is the ﬁnal marking.  u sn is the universe  of system 
nets . 
for the labeled  petri net in fig. 2 , m init = [ start ] and m ﬁnal = 
[ end] . each ﬁring sequence  which starts in m init and end in m ﬁnal 
is a complete  ﬁring sequence.  
given a system  net, φ( sn ) is the set of all possible  visible traces 
which can be generated  from the net, i.e., complete  ﬁring se- 
quences  projected  onto the set of observable  activities.  
deﬁnition  9. (traces  of a system  net) 
let sn = (n, m init , m ﬁnal ) ∈ u sn be a system  net. φ( sn ) = { σv | 
(n, m init )[ σv ⊿ (n, m ﬁnal ) } is the set of  visible traces starting in m init 
and ending  in m ﬁnal . φf ( sn ) = { σ| (n, m init )[ σ/angbracketright (n, m ﬁnal ) } is the 
corresponding  set of complete  ﬁring sequences.  
3.3. conformance  checking  
given an event log l and a petri net n , conformance  checking  
techniques  are aimed at checking  whether  or not n ﬁts the log. n 
perfectly  ﬁts l iff each  trace can be replayed  on the model from the 
begin to the end. 
deﬁnition  10. (perfectly  ﬁtting log) 
let l = (e, c, act , pi , /precedesequal) be an event log and let sn = 
(n, m init , m ﬁnal ) ∈ u sn . sn is perfectly  ﬁtting l if and only if 
∀ c ∈ c ( trace ( c ) ∈ φ( sn )). 
one of the most common  measures  used for conformance  
checking  is the ﬁtness , which can be measured  by aligning  the 
traces of the event log with the ﬁring sequences  of the net. an 
alignment  , here indicated  with the symbol  γ, shows a possible  
correspondence  between  a trace of an event log and a ﬁring se- 
quence  of a petri net. for example,  let us consider  the trace σ= 
/angbracketleft a, b, d, e, f, b, g/angbracketright . a possible  alignment  between  σand a ﬁring se- 
quence  of the petri net in fig. 2 is: 
γ= a /greatermuch b /greatermuch d e f b g 
a τ b c d e f /greatermuch g 
t 1 t 2 t 3 t 6 t 7 t 8 t 9 t 13 
the ﬁrst row refers to the event log, while the other two refer 
to the model. in particular,  the sequence  of activities  in the trace 
is shown in the ﬁrst row. the second  row shows activities  corre- 
sponding  to transitions  of the ﬁring sequence,  which are shown 
in the last row. we need two rows for the model since multiple  
transactions  corresponding  to the same activity  could exist. 
when the petri net perfectly  ﬁts with the log, each activity  in 
the ﬁrst row occurs also in the second  row, in the same position;  
otherwise,  a “no-move” symbol  /greatermuchis inserted.  for example,  in the 
fourth column  we have a no-move  in the trace, since according  to 
the ﬁring sequence  of the petri net the transition  t 6 should have 
been ﬁred, but the corresponding  activity  c is not displayed  in the 
trace. every pair ( x , ( y, t )), such that the ﬁrst element  belongs  to 
the ﬁrst line (i.e., it refers to the log) and the second  one involves  
an element  from the second  and the third line (i.e., the label and 
the id of a transition  of the net, respectively)  is called “move”.  for 
example,  ( a , ( a, t 1 )) states that both the log and the model make 
an “a” move.  note that the move in the model is caused  by the oc- 
currence  of the transition  t 1 , whose label is a . there can be three 
possible  kinds of moves:  a) a synchronous  move if x is an activity  
in the trace and t is a transition  in the model, b) a “move-in-the-  
log”, if t is /greatermuchand c) a “move-in-the-model”,  if x is /greatermuch. note that 106 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
fig. 2. a labeled petri net. 
a move-in-the-log  means that an activity  has occurred  in a not al- 
lowed position,  while a move-in-the-model  means that a certain  
activity  should have been occurred  according  to the model and it 
did not occur in the reality. such cases are usually  indicated  as 
inserted  and deleted  activities,  respectively.  moves a, b and c are 
called “legal moves”.  
deﬁnition  11. (legal moves)  
let l be an event log and let sn = (n, m init , m ﬁnal ) be a system  
net, with n = (p, t , f , l) . a lm = { (x, (x, t)) | x ∈ (a ) ∧ t ∈ t ∧ l(t) = 
x } ∪ { (/greatermuch, (x, t)) | t ∈ t ∧ l(t) = x } ∪ { (x, /greatermuch) | x ∈ (a ) } is the set of 
legal moves . 
formally,  we deﬁne an alignment  as follows.  
deﬁnition  12. (alignment)  
let σl be a trace of an event log l , let σsn ∈ φf ( sn ) be a com- 
plete ﬁring sequence  of the system  net sn , and let a ∗
lm be the set 
of all sequences  of legal moves.  an alignment  of σl and σsn is a 
sequence  γ∈ a ∗lm such that the projection  on the ﬁrst element  of 
each pair (ignoring  /greatermuch) yields σl and the projection  on the last 
element  (ignoring  /greatermuch) yields σsn . 
it is noteworthy  that for a given trace many possible  alignments  
typically  exist (possibly,  inﬁnitely  many).  nevertheless,  it is pos- 
sible to evaluate  the quality  of alignments,  by introducing  a cost 
function:  
deﬁnition  13. (cost of an alignment)  
let δ: a lm → n be a cost function,  which assigns  each legal 
move to a speciﬁc  cost. the cost of an alignment  γ∈ a ∗
lm is the 
sum of all costs: δ(γ) = /summationtext 
(x,y ) ∈ γδ(x, y ) . 
the cost function  can be deﬁned  in several  ways; anyway,  in 
this work we refer to the standard  cost function.  this function  as- 
signs a zero cost to synchronous  moves and to moves-in-the-model  
corresponding  to silent transitions,  while the cost for each move- 
in-the-log  and each move-in-the-model  corresponding  to a non 
silent transition  are both equal to one. hence, in our example  we 
have σ(a, (a, t 1 )) = 0 , since the move-in-the-log  is mimicked  by 
the move-in-the-model,  and σ(/greatermuch, (τ, t 2 )) = 0 , being t 2 is a silent 
transition.  instead,  σ(/greatermuch, (c, t 6 )) = 1 , since activity  c (caused  by the 
occurrence  of the transition  t 6 ) is not mimicked  in the event log. 
given a trace σ, the alignment  with the lowest cost (i.e., the one 
which allows the most synchronous  moves)  is called optimal  align- 
ment . it is noteworthy  that for a given trace more than one optimal  
alignments  can exist. to obtain for each trace in the log a unique  
optimal  alignment,  a mapping  function  κ: a ∗→ a lm is deﬁned,  
which deterministically  assigns  each trace σto an alignment  γ
such that γis optimal.  this function  can be seen as an “oracle”,  
which provides  us with a unique  complete  ﬁring sequence  of the 
model for each trace in the log ( adriansyah,  munoz-gama,  car- 
mona, van dongen,  & van der aalst, 2013 ). hereafter,  we indicate  
the optimal  alignment  provided  by κfor a given trace σas γ∗σ. 
several  criteria  can be used to deﬁne κ; however,  the deﬁnition  of the mapping  function  is out of the scope of this paper. here, for 
computing  the alignments  we refer to the technique  proposed  in 
( adriansyah,  van dongen,  & van der aalst, 2011 ), which introduces  
a cost-based  replay technique  based on the a ∗algorithm.  
in order to introduce  our technique  in section  5 we will make 
use of the following  deﬁnitions  that formally  specify  the notions  of 
irregularity  using the notion of alignment  cost. 
deﬁnition  14. (irregular  traces) 
let sn = (n, m in , m fi n ) be a system  net, and let σbe a trace of 
the event log l . if δ(γ∗σ) > 0 , then σis an irregular  trace. 
since the cost of the best alignment  is greater  than zero, an 
irregular  trace involves  one or more inserted/deleted  activities.  
deﬁnition  15. (inserted  activity)  
let σ= trace (c) = /angbracketleft a 1 , ... , a i , . . . , a n /angbracketright be an irregular  trace with 
respect  to the system  nset sn , with δ(γ∗σ) = h, h ≥1 . the activity  
a i is an inserted  activity  in the i th position  of σiff a trace σ/prime = 
/angbracketleft a 1 , . . . , a i −1 , a i +1 , . . . , a n /angbracketright exists such that δ(γ∗
σ/prime ) = h −1 . 
deﬁnition  16. (deleted  activity)  
let σ= trace (c) = /angbracketleft a 1 , ... , a n /angbracketright be an irregular  trace with re- 
spect to the system  net sn , with δ(γ∗σ) = h, h ≥1 . the activity  
a /prime ∈ a is a deleted  activity  in the i th position  of σiff a trace 
σ/prime = /angbracketleft a 1 , . . . , a i −1 , a /prime , a i , . . . , a n /angbracketright exists such that δ(γ∗
σ/prime ) = h −1 . 
in other words, given a trace which does not ﬁt with a model, 
an activity  is considered  an insertion  (deletion)  if by removing  
(adding)  such activity,  a new trace is obtained  whose cost of align- 
ment is decreased  by one. in general,  when a set of inserted  
(deleted)  activities  are detected  in the same position,  conformance  
checking  techniques  return a sequence  of inserted  (deleted)  activi- 
ties. 
3.4. model evaluation  measures  
common  measures  exploited  to evaluate  a process  model with 
respect  to an event log are ﬁtness, simplicity,  generalization  , and pre- 
cision . fitness,  as mentioned  above, measures  the extent to which 
the model is able to describe  behaviors  stored in the event log. 
simplicity  is used to evaluate  to some extent the readability  of 
a process  model, and can be measured  in several  ways (e.g., by 
counting  the number  of nodes and edges in the model).  the as- 
sumption  underlying  this metric is that the best model is the sim- 
plest one which is able to properly  represent  the behavior  in the 
event log. as regards  generalization  and precision,  both are based 
on comparing  the behaviors  allowed  by the process  model, with 
the behaviors  actually  stored in the event log. generalization  re- 
gards the capability  of the model to generate  traces which differ 
from the ones in the event log, i.e, its capability  to ﬁt with future 
process  instances.  indeed,  a model which can represent  only the 
behaviors  stored in the event log is an overﬁtting  model, i.e., it can 
only describes  past process  executions,  while a good model should c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 107 
be able to represent  all process  executions,  also those which did 
not occur yet. at the same time, a good process  model has also to 
be precise,  namely  it does not have to allow for “too many” not  
observed  behavior.  otherwise,  the model allows for any order of 
occurrence  of activities  in the process,  thus resulting  useless  in an- 
alyzing  the process.  in this case, the model underﬁts  , or overgener-  
alizes ( de medeiros  et al., 2008 ) the log. note that, it is not easy to 
deﬁne which are good values for precision  and generalization  for 
a generic  process;  intuitively,  one should look for models  with a 
good trade-off between  these metrics.  clearly,  the concrete  value 
for such a trade-off is  usually  not known  a-priori,  and depends  on 
the context.  
3.5. instance  graphs 
although  a process  usually  involves  some parallel  activities,  
events that occur are recorded  in a trace as a sequence,  thus hid- 
ing possible  parallelism.  hence, in order to identify  parallel  events 
within a trace, one needs to know which are the dependencies  ex- 
isting between  the activities  of the process.  to face with such issue, 
( van dongen  & van der aalst, 2004 ), ( van dongen  & van der aalst, 
2005 ) introduce  the concept  of instance  graph (ig), which is brieﬂy 
recalled  in the following.  
deﬁnition  17. (causal  relation)  
a causal relation  ( cr ) is a relation  on the set of activities,  i.e., 
cr ⊆a ×a . a 1 → cr a 2 denotes  that ( a 1 , a 2 ) ∈ cr . 
each element  of cr represents  the order of execution  of a pair 
of activities  of a process.  for example,  a 1 → cr a 2 states that a 2 
cannot be executed  until a 1 is terminated;  in other words, the ex- 
ecution  of a 2 depends  on the execution  of a 1 . a 1 is deﬁned  as the 
causal predecessor  of a 2 , and a 2 is the causal successor  of a 1 . note 
that the above deﬁnition  of cr involves  also self-loops;  indeed,  one 
can ﬁnd a 1 → cr a 1 . 
given a trace σ, we can build its instance  graph (ig), deﬁned  as 
follows:  
deﬁnition  18. (instance  graph) 
let l = (e, c, act , pi , /precedesequal) be an event log and let c ∈ c be a pro- 
cess instance.  the instance  graph of c is ig c = (v, w, η) with 
•v = { e ∈ e | pi (e ) = c} is the set of nodes corresponding  to 
events of c , 
•w = { (e 1 , e 2 ) ∈ v ×v | e 1 /precedesequale 2 ∧ act (e 1 ) → cr act (e 2 ) ∧ (∀ e /prime ∈ 
v (e 1 ≺e /prime ≺e 2 ⇒ act (e 1 )/negationslash→ cr act (e /prime )) ∨ ∀ e /prime/prime ∈v (e 1 ≺e /prime/prime ≺
e 2 ⇒ act (e /prime/prime ) /negationslash→ cr act (e 2 ))) } orders the events,  
•η: v → a with η(e ) = act (e ) for e ∈ v , labels a node with the 
corresponding  activity.  
e 1 → w e 2 denotes  that ( e 1 , e 2 ) ∈ w . 
ig c is a graph representing  the ﬂow of the activities  for the pro- 
cess instance  c . the nodes set v contains  a node for each event in 
σ= trace (c) ; each node is labeled,  by means of η, with the corre- 
sponding  activity.  w is a set of directed  edges between  nodes v i , 
v j . 
two nodes are connected  in ig c by means of a path , deﬁned  as: 
deﬁnition  19. (path) 
let ig c = (v, w, η) be an instance  graph. given two nodes e /prime , 
e /prime /prime ∈ v , a path from e /prime to e /prime /prime v is deﬁned  as a sequence  /angbracketleft e 1 , e 2 , 
... e k /angbracketright ∈ v ∗with k ≥2 such that e 1 = e /prime and e k = e /prime/prime and ∀ 1 < i ≤
k ((e i −1 , e i ) ∈ w ) 
we would like to note that, from the deﬁnition  18 , if ( e /prime , e /prime /prime ) ∈ 
w , then /angbracketleft e /prime , e /prime /prime /angbracketright is the only path between  e /prime and e /prime /prime . 
example  1. let us consider  the trace σ1 = /angbracketleft a, b, c, d, e, f, g/angbracketright of the 
process  instance  c , for which we assume  cr = { (a, b) , ( b, c ), ( c, d ), fig. 3. instance graph ig 1 for the trace σ1 . 
( c, e ), ( d, f ), ( d, g ), ( e, f ), ( f, g )}. to build the corresponding  ig c , ﬁrst 
a node is created  for each event; then, each pair of events in the 
trace is analyzed.  the ﬁrst pair is characterized  by the activities  
a and b ; since a → cr b and there are no other events between  
them in the trace (i.e., b is a direct follower  of a ), the correspond-  
ing nodes are linked by means of an edge in the graph. all other 
pairs starting  from the ﬁrst event, (i.e., (a, c) , (a, d) , . . . , and ( a, g )) 
are not part of cr , so we move to the second  event. for this event, 
we have only b → cr c , and since c is a direct follower  of b , the 
corresponding  nodes are linked. the third event is the causal pre- 
decessor  of two events,  characterized  by activities  d and e respec-  
tively. the former  is a direct follower  of c , and hence the edge is 
drawn.  the latter does not directly  follow c , but we have d in the 
trace between  c and e . since c → cr d but d /negationslash→ cr e, these nodes are 
also linked. the procedure  is repeated  until all events have been 
considered.  fig. 3 shows the instance  graph corresponding  to σ1 . 
it should be noted that the set of edges w of an ig represents  a 
subset of cr . the constraints  deﬁned  for w are aimed to avoid the 
presence  of redundant  edges in the graph, namely  edges linking  
nodes that are already  linked by a path. in this example,  the rela- 
tion d → cr g does not produce  any edge, since the path /angbracketleft d, f, g /angbracketright 
already  exists. 
deﬁnition  18 allows to represent  only split/join  and constructs.  
hence, when an ig has parallel  branches,  it means that in the 
corresponding  process  instance,  events of the branches  have been 
executed  in parallel.  in the case a process  has split/join  or con- 
structs,  in the process  instance  (and hence, in the trace) only the 
branches  actually  executed  will be reported.  furthermore,  igs are 
always acyclic;  in fact, if a loop exists in the process,  in the trace 
each execution  of the loop is represented  by a sequence  of differ- 
ent events,  which correspond  to different  nodes in the ig. 
from the above deﬁnitions,  it turns out that a process  instance  
c generates  the trace σ= trace (c) and the instance  graph ig c ; how- 
ever, the same instance  graph could be obtained  also from other 
traces in the event log. sequences  of activities  that could generate  
the same instance  graph are called occurrence  sequences,  as fol- 
lows: 
deﬁnition  20. (occurrence  sequence)  
let ig c = (v, w, η) be an instance  graph. the sequence  σ= 
/angbracketleft a 1 , a 2 , . . . , a n /angbracketright is an occurrence  sequence  of ig c if there exists a bi- 
jection  g ∈ { 1 , 2 , . . . , n } → v such that: 
•η(g(i )) = a i for any i ∈ { 1 , 2 , . . . , n } , 
•/2204e ∈ v | ( e, g (1)) ∈ w , 
•/2204e ∈ v | ( g ( n ), e ) ∈ w , 
•g ( i ) → w g ( j ) implies  that i < j ∀ i, j ∈ { 1 , 2 , . . . , n } . 
in other words, in an occurrence  sequence  of an instance  graph 
the ﬁrst and the last events correspond  to nodes of the graph for 
which no input and no output edges are deﬁned.  
example  2. let us consider  again the ig shown in fig. 3 . since it 
involves  a parallelism,  two different  occurrence  sequences  can be 
generated,  i.e., σ1 = /angbracketleft a, b, c, d, e, f, g/angbracketright and σ2 = /angbracketleft a, b, c, e, d, f, g/angbracketright . it 
is interesting  to note that only one of these occurrence  sequences  
(i.e., σ1 ) actually  corresponds  to the trace from which the graph 
has been built. 
by analyzing  the occurrence  sequences,  it is possible  to 
apply the quality  measures  regarding  the precision  and the 108 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
(a) (b)
fig. 4. examples  of overgeneralizing  models. 
generalization  of a process  model introduced  in the previous  sub- 
section  also to an ig. we will discuss  their use in section  6 , when 
describing  the experiments.  
4. causal relation  discovery  for highly variable  processes  
the aim of this section  is to provide  an in depth analysis  of 
the issues encountered  by existing  techniques  in inferring  causal 
relations  and hence ig for highly variable  domains.  we hasten to 
note that the problem  of inferring  causal relations  is strictly  re- 
lated to the problem  addressed  by pd. as a matter of fact, cr rep- 
resents  the basic information  pd techniques  elaborate  upon to gen- 
erate the model, and every pd technique  has its own cr inference  
rules. therefore,  to simplify  the reading,  hereafter,  we refer to pd 
approaches  to indicate  the corresponding  rules to extract  the cr . 
a relevant  aspect of a pd technique  is its ﬁltering  capability.  
especially  in highly variable  contexts,  very different  results can be 
obtained  when choosing  either a non-ﬁltering  approach,  which tries 
to represent  all the behaviors  stored in the event log, or a ﬁltering  
approach,  which considers  only more frequent  behaviors.  we ad- 
dress both cases in the following  subsections,  showing  the effects 
on building  igs. 
4.1. non ﬁltering  approaches  
non-ﬁltering  pd techniques  try to build a model able to rep- 
resent all the behaviors  stored in the event log. when applied  
to event logs involving  heterogenous  behaviors,  non-ﬁltering  tech- 
niques tend to build models  which overgeneralizes  the process  
( de medeiros  et al., 2008 ), i.e., which allow for practically  every 
execution  order among  activities.  fig. 4 shows two examples  of 
overgeneralizing  models.  
fig 4 a shows a model where almost all of the activities,  ex- 
cept a and g , are represented  in parallel,  while fig. 4 b represents  a 
dual situation,  where all activities  are linked among  each other. a 
well-known  approach  which can easily lead to model represented  
in fig. 4 a when applied  to highly variable  processes  is the α- 
algorithm,  which is the technique  used in ( van dongen  & van der 
aalst, 2004 ) and in ( van beest et al., 2015 ). it recognizes  a causal 
relation  between  two activities  a and b only if b directly  follows  
a in at least one trace and the opposite  never occurs;  otherwise,  
they are considered  parallel  3 . hence, it is apparent  that also with 
just one exception  in the log, two activities  will be modeled  as par- 
allel. the kind of model depicted  in fig. 4 b, known  in literature  as 
3 in ( van dongen & van der aalst, 2004 ) the improved  version of the α-algorithm  
is used, which takes into account also possible two-length  loops when determining  
causal relations.  a “flower  model”,  can be obtained  by applying  the heuristic  miner 
(hm) ( weijters  et al., 2006 ) in a non-ﬁltering  conﬁguration.  the 
hm can be viewed  as an extension  of the α-algorithm.  it rede- 
ﬁnes and extends  the original  rules of the α-algorithm,  in order 
to take into account  the frequency  of follows  relations,  applying  
some heuristics  to determine  causality  and parallelisms.  in partic- 
ular, given two activities  a and b , hm returns  in output a → cr b 
if the difference  between  the number  of times b follows  a and the 
number  of times a follows  b is above an user-deﬁned  threshold;  
otherwise  it is ﬁltered  out. similarly  for b → cr a . when very low 
thresholds  are used for ﬁltering  (or no ﬁltering  is exploited  at all), 
then both the relations  are displayed  in the outcome;  for highly 
variable  processes,  this easily leads to a model where all the activ- 
ities are connected  to each other. 
igs generated  by using the cr corresponding  to models  in 
fig. 4 cannot properly  represent  process  instances.  let us consider,  
for example,  the trace σ= /angbracketleft a, b, c, d, e, f, h, g/angbracketright corresponding  to a 
process  instance  k . the ig k built by using the cr of the model in 
fig. 4 a results identical  to the model, i.e., all the activities  except 
a and g will be in parallel.  hence, several  occurrence  sequences  of 
ig c are allowed  and the instance  graph overgeneralizes,  providing  a 
very poor representation  of k . instead,  from the cr of the model in 
fig. 4 b, we can obtain only sequential  igs. indeed,  since each event 
is linked to its direct follower  in the trace, ig k will be a sequence  
which mimics  the order of the events in the trace; such a graph is 
clearly a trivial model for k . 
4.2. filtering  approaches  
filtering  techniques  use only the most relevant  dependencies  
to build the model, where a dependency  is usually  relevant  if it 
occurs more frequently  than a given threshold.  two well-known  
examples  of ﬁltering  pd algorithms  are the already  mentioned  
heuristic  miner (hm) and the infrequent  inductive  miner (iim). 
the iim algorithm  adopts an iterative  procedure.  at the beginning,  
it generates  a directed  graph representing  the direct follows  rela- 
tions between  activities  of the event log. then, it deﬁnes  a “cut”
of the graph, i.e., a partition  between  the nodes in disjoint  sets 
such that all the activities  in a subset have the same relation  with 
activities  in the other subsets.  relations  like sequences,  loops, par- 
allelism  are taken into account.  the log is then split to reﬂect the 
partitioning  of the activities  and the procedure  is then repeated  
on each sublog,  until sublogs  contain  only one activity.  similarly  to 
hm, iim introduces  a set of heuristics  aimed at ﬁltering  infrequent  
behaviors.  
by considering  the most common  process  behavior,  ﬁltering  ap- 
proaches  usually  cut down overgeneralization,  at the expenses  of 
the completeness,  since some of the traces will not ﬁt the model. c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 109 
fig. 5. ig for the trace σin 1 . 
fig. 6. ig for the trace σdel 1 . 
fig. 7. ig of the trace σdel 2 . 
according  to deﬁnition  14 they are called irregular  traces. when 
applied  to an irregular  trace deﬁnition  18 leads to the genera-  
tion of an ig (hereafter  irregular  instance  graph, or iig) provid-  
ing a very imprecise  representation  of the corresponding  process  
instance,  as shown in the following  examples.  
example  3. let us consider  the trace σin 1 = trace (in 1 ) = 
/angbracketleft a, b, c, i , d, e, f, g/angbracketright . according  to the model of fig. 2 , there is 
an inserted  activity  i at the 4th position.  fig. 5 shows the ig built 
from σin 1 , i.e., ig in 1 . the node i has only one input edge, and no 
output edges. in such a way, the only execution  constraint  for 
i is to be performed  after a ; hence, ig in 1 can generate  several  
occurrence  sequences,  where the activity  i occurs in very different  
positions,  e.g., σ1 = /angbracketleft a, i, b, c, d, e, f, g/angbracketright , σ2 = /angbracketleft a, b, c, d, e, f, g, i /angbracketright , and 
so on. 
example  4. let us consider  the trace σdel 1 = /angbracketleft a, b, d, e, f, g/angbracketright . ac- 
cording  to the model of fig. 2 , there is a deleted  activity  c at the 
3rd position.  fig. 6 shows the ig built from such trace, i.e., ig del 1 , 
which consists  of two disconnected  graphs.  this representation  is 
clearly too imprecise;  the two components  are not linked, thus im- 
plying that no ordering  relations  exist between  them. hence, the 
graph can generate  occurrence  sequences  like σ1 = /angbracketleft a, d, e, f, g, b/angbracketright , 
σ2 = /angbracketleft d, e, f, g, a, b/angbracketright and so on. 
from the previous  examples,  it turns out that an iig may pro- 
vide an overgeneralized  representation  of the corresponding  pro- 
cess instance,  which is clearly not desired.  examples  3 and 4 show 
also that the overgeneralization  can be, in many cases, detected  
also by means of some structural  anomalies  which affect the 
graph, e.g., disconnected  nodes, presence  of more than one start- 
ing/ending  nodes. it is also possible,  however,  to obtain graphs cor- 
rected from a structural  point of view, but which anyway  allow for 
not desired  occurrence  sequences,  as shown by the following  ex- 
ample. 
example  5. let us consider  the trace σdel 2 = /angbracketleft a, b, j, r, j, r, b, c, d, 
e, f, g /angbracketright , where each activity  a i in the i th position  corresponds  to 
an event e i | act(e i ) = a i . according  to the model of fig. 2 , there is 
a deletion  of the activity  b in the 5th position.  the resulting  graph 
is shown in fig. 7 . note that for this example  we also report the 
event identiﬁers,  in order to avoid possible  misunderstandings  due 
to the multiple  occurrences  of some activities.  as we can see, this ig has no structural  anomalies;  however,  there is a parallelism  be- 
tween the two occurrences  of the activities  j and r , which is due 
to the deletion  of b but is not allowed  by the model. again, the in- 
stance graph overgeneralizes  returning  four occurrence  sequences.  
while in structured  processes  the number  of irregular  traces is 
not signiﬁcant  and these traces could be discarded,  in higly vari- 
able processes  irregular  traces have to be properly  handled.  as a 
matter of fact, these kind of processes  usually  represent  human-  
intensive  processes,  where irregular  behaviors  are intentional  vari- 
ations of regular  behaviors,  hence their analysis  turns to be inter- 
esting. hence, rather than removing  iigs, our goal is to repair them. 
in next section  we detail the proposed  algorithms  for graph repair- 
ing that, starting  from models  generated  by ﬁltering  techniques,  
transform  an iig in order to reduce overgeneralization.  
5. building  instance  graphs  
algorithm  1 provides  an overview  of the building  instance  
graphs  ( big ) algorithm.  given an event log l , ﬁrst the ﬁltering  
technique  pd is applied  to obtain the process  model m , with its 
corresponding  cr (step 1). then, for each trace σk = trace (k ) , k ∈ 
cthe corresponding  instance  graph ig k is built by referring  to 
deﬁnition  18 (step 3). step 4 checks whether  σk is an irregular  
trace, by checking  the conformance  with the model. this check is 
done by evaluating  the ﬁtness of the trace to the model. in this 
work, we refer to the conformance  checking  approach  proposed  by 
( adriansyah  et al., 2011 ), which minimizes  the standard  cost func- 
tion deﬁned  in section  3 . if a trace is irregular,  then the lists of 
inserted  ( i ) and deleted  ( d ) activities  are returned.  indeed,  each el- 
ement of d and i is a consecutive  sequence  of irregular  activities.  
for instance,  if at the i th position  there is only one inserted  ac- 
tivity and from j th to h th position  there are h −j + 1 consecutive  
inserted  activities,  we have i = {/angbracketleft a i /angbracketright , /angbracketleft a j , . . . , a h /angbracketright} . irregular  traces 
are repaired  in step 6, by using the repairing  algorithm  reported  in 
algorithm  2 . 
given a trace, its instance  graph ig k and the lists of its in- 
serted/deleted  activities,  algorithm  2 returns  a repaired  graph ig /prime 
k 
having same nodes and a few difference  in the set of edges. note 
that varying  edges returns  a graph that is not fully compliant  with 
deﬁnition  18 ; nevertheless,  since the graph is still the ﬂow of ac- 
tivities of the trace, for the sake of simplicity  we call it ig as well. 
algorithm  1 building  instance  graphs  algorithm.  
let l = (e, c, act , pi , /precedesequal) be an event log 
1: [ m, cr ] =applyprocessdiscovery(  l , p d ); 
2: for k = 1 to | c| do 
3: ig k =extractinstancegraph(  σk , cr ); 
4: [ d, i] =checktraceconformance(  σk , m); 
5: if d ∪ i /negationslash = ∅ then 
6: i g k =irregulargraphrepairing(  i g k , σk , d, i, cr ); 
algorithm  2 the irregular  graph repairing  algorithm.  
let ig k = (v, w, η) be the irregular  instance  graph for the trace σk 
let d be the set of deleted  activities  of σk 
let i be the set of inserted  activities  of σk 
let cr be the causal relation  
1: w /prime = w 
2: for all a ∈ d do 
3: w /prime = dr (w /prime , a, cr ) 
4: for all a ∈ i do 
5: w /prime = ir (w /prime , a, cr, σ/prime 
k ) 
6: ig /prime = (v, w /prime , η) 110 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
algorithm  3 the deletion  repairing  algorithm.  
let σdel = /angbracketleft a 1 , a 2 , . . . , a i −1 , a i , a i +1 , . . . , a n /angbracketright be an irregular  trace 
let /angbracketleft a d 1 , . . . , a d n /angbracketright be the sequence  of deleted  activities  in the ith 
position  of σdel 
let ig σdel = (v, w, η) be the iig for the trace σdel , with a i = η(e i ) 
let cr be the causal relation  
1: w r 1 = { (e k , e i ) | k < i ∧ ((e k , e i ) ∈ w ) ∧ 
(∃ e h , k ≤h < i | η(e h ) → cr a d 1 ) ∧ (a d n → cr η(e i )) } 
2: w r 2 = { (e k , e j ) | k < i ∧ j > i ∧ ((e k , e j ) ∈ w ) ∧ (η(e k ) → cr 
a d 1 ) ∧ (a d n → cr η(e i )) ∧ ∃ e l , i < l < j | (e l , e j ) ∈ w } 
3: w /prime = w \ (w r 1 ∪ w r 2 ) 
4: for k = i −1 to 1 do 
5: for j = i to n do 
6: if (η(e k ) → cr a d 1 ) ∧ (a d n → cr η(e j )) ∧ (/angbracketleft e k , . . . , e j /angbracketright / ∈ w /prime ) ∧ 
((∄ e l , k < l < j | (e k , e l ) ∈ w /prime ) ∨ (∄ e m , k < m < i | (e m , e j ) ∈ 
w /prime ))) then 
7: w /prime = w /prime ∪ { (e k , e j ) } 
the algorithm  repairs  ﬁrst all the deleted  activities,  and then all 
the inserted  activities,  calling the deletion  repairing  algorithm  (dr) 
and the insertion  repairing  algorithm  (ir) respectively.  
5.1. deletion  repairing  algorithm  
the idea underlying  the dr algorithm  consists  in connecting  ac- 
tivities occurred  before and after the deleted  activities,  and in re- 
moving  those edges which should not have been created  accord-  
ing to the model. algorithm  3 describes  the general  case when 
a sequence  of deleted  activities  is detected  in the same position  
of the trace. the algorithm  starts by identifying  the sets w r 1 , w r 2 , 
which contain  edges generated  by the deleted  activities.  indeed,  
the deletion  of one or more activities  could lead to an irregular  ig 
where some events are linked although  they should not be linked 
according  to the model (e.g., see example  5 ). these edges have to 
be recognized  and deleted.  in particular,  w r 1 contains  edges be- 
tween events occurring  before the position  of the deletion  and the 
i th event. edges in w r 2 link events before and after the i th posi- 
tion. then, a set of edges to be added to the graph is computed  
(steps 4–7). these edges link those events occurring  before and af- 
ter the deleted  sequence,  such that a dependency  exists between  
them and the ﬁrst and the last events in the sequence  respectively.  
note that only direct edges are considered,  namely  edges between  
events which are no linked by other paths in the new graph. as 
output we obtain the transformed  set w /prime , which is needed  to de- 
ﬁne the repaired  graph. 
example  6. let us consider  the trace σdel 1 = /angbracketleft a, b, d, e, f, g/angbracketright of 
the example  4 . we have only one deleted  activity  c in the 
3rd position.  at the beginning  of the procedure,  we have w = 
{ (a, b) , (d, f) , (e, f) , (f, g) } 4 . in this case, both the sets w r 1 , w r 2 
are empty;  while from steps 4–7 it results that the edges 
( b, d ) and ( b, e ) have to be added. at the end, we obtain 
w /prime = { (a, b) , (d, f) , (e, f) , (f, g) , (b, d) , (b, e ) } ; the resulting  graph 
is shown in fig. 8 . 
example  7. let us consider  the trace σdel 2 = /angbracketleft a, b, j, r, j, r, b, c, d, 
e, f, g /angbracketright , deﬁned  in example  5 . the deleted  activity  is b in 
the ﬁfth position.  in the original  instance  graph we have w = 
{ (e 1 , e 2 ) , (e 2 , e 3 ) , (e 2 , e 5 ) , (e 3 , e 4 ) , (e 5 , e 6 ) , (e 4 , e 7 ) , ( e 6 , e 7 ), ( e 7 , e 8 ), 
( e 8 , e 9 ), ( e 8 , e 10 ), ( e 9 , e 11 ), ( e 10 , e 11 ), ( e 11 , e 12 )}. it is straightforward  
to verify that w r 1 = { (e 2 , e 5 ) } and w r 2 = { (e 4 , e 7 ) } . then, we derive 
4 we use activities  instead events identiﬁers  with an abuse of notation in case 
this creates no misunderstandings.  fig. 8. repaired  graph for σdel 1 . 
fig. 9. repaired  graph for σdel 2 . 
that the edge ( e 4 , e 5 ) has to be added to w /prime . the repaired  graph is 
shown in fig. 9 . 
5.2. the insertion  repairing  algorithm  
algorithm  4 describes  the ir algorithm,  which is aimed at re- 
structuring  an iig when a sequence  of inserted  activities  is de- 
tected. 
the algorithm  starts by detecting  sets w r 1 , w r 2 and w r 3 of edges 
to be deleted.  w r 1 ( w r 2 ) involves  edges which link events before 
(after) the inserted  sequence  to activities  belonging  to the irreg- 
ular trace. w r 3 contains  edges connecting  inserted  activities.  after 
algorithm  4 the insertion  repairing  algorithm.  
let σins = /angbracketleft a 1 , a 2 , . . . , a i −1 , a i , . . . , a j , . . . , a n /angbracketright be an irregular  trace 
let /angbracketleft a i , . . . , a j /angbracketright be the sequence  of inserted  activities  from position  
i to j of σins 
let i be the set of inserted  activities  of σins 
let ig σins = (v, w, η) be the iig for the trace σins , with a i = η(e i ) 
let cr be the causal relation  
1: w r 1 = { (e k , e l ) | k < i ∧ i ≤l ≤j ∧ ((e k , e l ) ∈ w ) } 
2: w r 2 = { (e k , e l ) | i ≤k ≤j ∧ l > j ∧ ((e k , e l ) ∈ w ) } 
3: w r 3 = { (e k , e l ) | i ≤k ≤j ∧ i ≤l ≤j ∧ (e k , e l ) ∈ w ) } 
4: w /prime = w \ (w r 1 ∪ w r 2 ∪ w r 3 ) 
5: for k = j + 1 to n do 
6: if η(e k ) / ∈ i ∧ ((η(e i −1 ) → cr η(e k )) ∨ ((e i −1 , e k ) ∈ w )) ∧ (/angbracketleft e j , 
. . . , e k /angbracketright / ∈ w /prime ) then 
7: w /prime = w /prime ∪ { (e j , e k ) } ∧ w a 1 = w a 1 ∪ { (e j , e k ) } 
8: if η(e i −1 ) /notarrowright cr η(e i +1 ) then 
9: w /prime = w /prime ∪ { (e i −1 , e i ) } ∧ w a 2 = w a 2 ∪ { (e i −1 , e i ) } 
10: else 
11: for k = i −1 to 1 do 
12: if η(e k ) / ∈ i ∧ ((η(e k ) → cr η(e j+1 )) ∨ ((e k , e j+1 ) ∈ w )) ∧ 
(/angbracketleft e k , . . . , e i /angbracketright / ∈ w /prime ) then 
13: w /prime = w /prime ∪ { (e k , e i ) } ∧ w a 2 = w a 2 ∪ { (e k , e i ) } 
14: w a 3 = { (e k , e k +1 ) : i ≤k ≤(j −1) } 
15: w /prime = w /prime ∪ w a 3 
16: w r 4 = { (e k , e l ) | (e k , e h ) ∈ w a 2 ∧ i ≤h ≤j ∧ (e p , e l ) ∈ w a 1 ∧ i ≤
p ≤j} 
17: w /prime = w /prime \ w r 4 
18: if η(e i −1 ) /notarrowright cr η(e i +1 ) then 
19: w r 5 = { (e i −1 , e k ) ∈ w /prime | k > i } 
20: w /prime = w /prime \ w r 5 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 111 
fig. 10. repaired  graph for σin 1 . 
the removal  of edges, the algorithm  extracts  the sets w a 1 , w a 2 and 
w a 3 of edges to be added. w a 1 has edges linking  the last inserted  
activity  to subsequent  events.  the building  of the set w a 2 depends  
on the presence  of inserted  activities  between  two parallel  events 
in the graph. note that in both cases we don’t insert an edge be- 
tween two inserted  activities,  i.e., edges of the sets w a 1 , w a 2 link a 
regular  activity  and an inserted  one. the case in which the state- 
ment (in step 8) is true will be detailed  at the end of the sub- 
section.  otherwise,  in the case of insertion  between  non-parallel  
activities,  w a 2 contains  edges linking  the ﬁrst inserted  activity  to 
previous  events.  note that the iig on which the algorithm  works 
could be already  transformed  to repair previous  irregularities,  so 
we might have edges between  events which correspond  to activ- 
ities for which cr is not deﬁned.  for this reason in w a 1 as well 
as w a 2 we need to specify  that an edge is built if either the cr 
is deﬁned  between  corresponding  activities,  or an edge exists in 
the graph. note that an edge can be added to w a 1 or w a 2 only if 
no paths, connecting  events in the edge, already  exist. in fact, if 
an edge between  e i and e j exists, then /angbracketleft e i , e j /angbracketright is the only path be- 
tween the two events (see deﬁnition  18 ). then w a 3 simply adds 
an edge between  each consecutive  activities  within the sequence.  
finally,  the set w r 4 is deﬁned  to remove  edges which link nodes 
connected  to the inserted  activities  in previous  steps. 
example  8. let us consider  σin 1 = /angbracketleft a, b, c, i , d, e, f, g/angbracketright , of 
example  3 , where w = { (a, i ) , (a, b) , (b, c) , (c, d) , (c, e ) , (d, f) , (e, f) , 
(f, g) } . in this case, the algorithm  returns  w r 1 = { (a, i ) } ; 
w r 2 = w r 3 = ∅ ; w a 1 = { (i, d) , (i, e ) } ; w a 2 = { (c, i ) } ; w a 3 = ∅ ; 
w r 4 = { (c, d) , (c, e ) } . the repaired  graph is the one shown in 
fig. 10 . 
the statements  in steps 8-9 and 18–20 of the algorithm  deﬁne 
a variant  for the set w a 2 and introduce  the set w r 5 . these steps al- 
low to handle  a special  case of insertion,  namely  activities  inserted  
between  parallel  activities.  in the remaining  of this subsection,  we 
brieﬂy show the motivations  for the deﬁnition  of this variant.  
example  9. let us consider  σin 2 = /angbracketleft a, b, c, d, x , e, f, g/angbracketright , where 
x is the inserted  activity.  the initial edges set is w = 
{ (a, b) , (b, c) , (c, d) , (c, e ) , (d, f) , ( e, f ), ( f, g )}. the iig is reported  in 
fig. 11 (a). since x is not in the model, the graph has a disconnected  
node for x . if we do not consider  statements  in steps 8 and 18, the 
removing  edges sets are w r 1 = w r 2 = w r 3 = ∅ , while the other sets 
are w a 1 = { (x, f) } , w a 2 = { (c, x ) } , w a 3 = ∅ . the resulting  repaired  
graph is shown in fig. 11 (b). 
it is noteworthy  that the inserted  activity  x has been considered  
as parallel  to d and e ; indeed,  since cr is not deﬁned  for these two 
activities,  x is linked to the predecessor  and the follower  of both of 
them. the adding  of another  parallel  branch  increases  the number  
of occurrence  sequences,  hence the overgeneralization  of the ig. 
in order to reduce this phenomenon,  we add the inserted  activ- 
ity in one of the already  existing  parallel  branches.  to this end, in 
w r 5 the new parallel  branch  is removed,  and in w a 2 the inserted  
activity  is moved to an existing  path originates  from its direct pre- 
decessor  in the trace. fig. 12 shows the effect of the variant  of the 
algorithm.  
it is important  to note that when a trace involves  different  
kinds of irregular  behavior,  ﬁrst all the deleted  activities  are re- (a)
(b)
fig. 11. iig (a) and the partially repaired graph (b) for σin 2 . 
fig. 12. repaired  ig for l in 2 . 
paired,  then the inserted  ones (see algorithm  2 ). this repairing  or- 
der depends  on the fact that when one or more deletions  occur, 
the ir algorithm  could be not able to correctly  connect  the inserted  
activities.  this issue is discussed  through  the following  example.  
example  10. let us consider  the trace σin −del = /angbracketleft a, b, i, d, e, f, g/angbracketright ; 
here we have an inserted  event i in the 3rd position  and a deleted  
event c in the 4th position.  the initial edges set is w = { (a, b) , 
( a, i ), ( d, f ), ( e, f ), ( f, g )}; the graph is shown in fig. 13 a. first, let 
us repair the graph by following  only the order in which the ir- 
regular  behaviors  have occurred,  i.e., ﬁrst we repair the insertion  
and then the deletion.  the removing  edges set are w r 1 = { (a, i ) } , 
w r 2 = ∅ , w r 3 = ∅ . as regards  adding  edges, w a 1 = ∅ and w a 2 = ∅ ; 
in fact, both the activities  occurred  before and after i should have 
been linked to c , which however  has been skipped.  as a result, i 
cannot be linked to anything.  at the end of the insertion  repairing,  
we have w /prime = { (a, b) , (d, f) , (e, f) , (f, g) } . as regards  the deletion  
repairing,  we have: w r 1 = w r 2 = ∅ . the edges to add are ( b, d ) and 
( b, e ). hence, the ﬁnal edge set is w /prime = { (a, b) , ( b, d ), ( b, e ), ( d, f ), 
( e, f ), ( f, g )}. the resulting  graph is shown in fig. 13 b. the pres- 
ence of a disconnected  node leads to undesired  overgeneralization.  
let us now perform  the repairing  by following  the algorithm  2 ; 
ﬁrst we consider  the deletion  and then the insertion.  now, after 
the deletion  repairing  we have w /prime = { (a, b) , ( a, i ), ( b, d ), ( b, e ), ( d, 
f ), ( e, f ) ( f, g )}. with respect  to the previous  case, the insertion  re- 
pairing  now returns  w a 1 = { (i, d) , (i, e ) } and w a 2 = { (b, i ) } . hence, 
w /prime = { (a, b) , ( b, i ), ( i, d ), ( i, e ), ( d, f ), ( e, f ), ( f, g )}; the repaired  graph 
is shown in fig. 13 c, which shows a considerably  reduced  overgen-  
eralization.  
6. experiments  
in this section  we evaluate  the igs obtained  by our building  
instance  graph methodology  adopting  the heuristic  miner (hm) 
and the infrequent  inductive  miner (iim) to derive cr . we com- 
pare the obtained  igs with (1) igs obtained  by adopting  the tech- 
niques proposed  in ( van dongen  & van der aalst, 2004 ) and in 112 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
(a) (b)
(c)
fig. 13. (a) iig for σin −del ; (b) repaired graph when insertion  repairing  is executed  before deletion repairing;  (c) repaired graph following  the execution  order of algorithm  2 . 
( van beest et al., 2015 ), and (2) igs obtained  by using the hm and 
iim without  repairing.  experiments  are performed  both on syn- 
thetic ( subsection  6.1 ) and real-world  ( subsection  6.2 ) event logs. 
in order to evaluate  igs, the following  metrics  are introduced:  
•the accuracy  (acc), i.e., the number  of graphs correctly  recon- 
structed.  we report both the numbers  of correct  igs, and the 
percentage  of correct  igs with respect  to the overall igs set. 
note that, we evaluate  accuracy  only for the synthetic  experi-  
ments, since the set of true igs is unknown  in real-world  sce- 
narios;  
•the matching  cost (mc), i.e., the distance  between  repaired  and 
true igs, which allows to evaluate  the error made in building  
the ig. in order to compute  mc, we refer to typical measures  
exploited  to compare  graphs.  in particular,  given an instance  
graph ig σ, the execution  of which has generated  the trace σ, 
the difference  between  ig σand the reconstructed  ig /prime σis evalu- 
ated as the number  of transformations  that are needed  to make 
them isomorphic.  such transformations  include  a) adding  or 
deleting  an edge, b) adding  or deleting  a node, c) changing  a 
label of an edge or a node and d) reversing  the direction  of an 
edge. in our case, all of these transformations  are considered  as 
having cost 1. when mc is 0 the ig has been correctly  gener- 
ated; the greater  the mc the greater  the error made in building  
the ig. note that, like accuracy,  mc can be measured  only in 
the case of synthetic  experiments;  
•the average  generalization  (ag) of the ig set, which evaluates  
the number  of occurrence  sequences  which can be generated  
on average  by each ig. on the one hand, if ag is 1 then igs 
are tailored  to represent  only the corresponding  traces; on the 
other hand high values means overgeneralizing  graphs,  allow- 
ing for several  different  occurrence  sequences.  we compute  the 
average  generalization  over the whole ig set ( ag all ), the set of 
igs obtained  from regular  traces ( ag reg ) and the set of igs ob- 
tained from irregular  traces ( ag irr ). when a non-ﬁltering  ap- 
proach  is adopted  (e.g., for vd and vb) all traces ﬁt the model, 
thus ag reg = ag all and ag irr can not be computed.  
a metric commonly  used in pm literature  to evaluate  the qual- 
ity of mined models  is the ﬁtness,  which evaluates  to what extent 
the model is able to represent  the set traces from which it was 
derived  (see section  3.3 ). although  in principle  it is possible  to 
compute  the ﬁtness also for an ig, by checking  whether  its cor- 
responding  trace is among  its occurrence  sequences,  this metric 
turns out to be not useful to evaluate  the ig quality.  indeed,  the 
algorithms  for building  igs always return an ig capable  of repre- 
senting  its original  trace. we have anyway  computed  the ﬁtness for each igs, to test the correctness  of the algorithm;  as expected,  
each trace ﬁts its corresponding  built ig. 
6.1. synthetic  experiments  
the ﬁrst set of experiments  have been performed  on event logs 
generated  by simulating  the petri net shown in fig. 14 . in this net, 
there are some “regular” (i.e.,  frequent)  behaviors,  represented  by 
the paths involving  solid edges; but several  “irregular” (i.e.,  not fre- 
quent) behaviors  can occur, whose paths are characterized  by dot- 
ted edges. as an example,  the activity  a is usually  followed  by ei- 
ther b or i , but in rare cases c is executed  immediately  after a . 
the adopted  experimental  procedure  involves  three main steps: 
1) generating  a set of process  instances  from the given petri net 
and, hence, their true igs and the event log; 2) building  the igs 
adopting  different  approaches;  3) evaluating  the built igs, compar-  
ing them with the true ones. 
as regards  the event log generation,  we consider  process  in- 
stances  with at most one irregular  path; hence, irregular  behaviors  
are variants  of regular  ones and differ only for the irregular  path. 
this constraint  limits the variability  of the experiments,  without  
affecting  the goal. 
from the model, it turns out that there are thirteen  irregular  
behaviors.  as regards  the regular  behaviors,  instead,  there are only 
two possible  paths: i 1 , that moves from the event a to the event b 
(i.e., the upper path in fig. 14 ) and i 2 , that follows  the lower path 
from a to g through  i . note that i 2 can generate  only one kind of 
trace, while i 1 can generate  four possible  kinds of traces, depend-  
ing on the order in which activities  d and e are performed  and 
by the execution  of the cycle. we grouped  traces from i 1 into two 
groups:  g1 involves  traces having d performed  before e , while the 
second  one, g2 having e performed  before d ; each group can be 
instantiated  with or without  cycle execution  (whatever  the num- 
ber of executed  cycle instances  is). the groups  of traces of i 1 are 
shown in fig. 15 . note that, same considerations  hold also for any 
irregular  behaviors  which are variants  of i 1 ; also in this case there 
are four irregular  traces. 
we performed  several  experiments,  varying  the event log in or- 
der to increase  the number  of regular  traces. first, we randomly  
generated  one trace for each irregular  behavior,  thus obtaining  
thirteen  irregular  traces; then, at each step we added an increas-  
ing number  of regular  traces, randomly  generated  by the regular  
behaviors.  since i 2 corresponds  only to one kind of trace, while 
i 1 corresponds  to two different  groups  of traces, we added 1/3 
of the regular  traces from the instance  i 2 , and the remaining  2/3 
from i 1 . we started  with a log involving  16 traces (i.e., 13 irregular  
traces plus 2 traces from i 1 and 1 from i 2 ), until obtaining  a log c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 113 
fig. 14. the petri net used for synthetic  experiments.  
(a)g1abcdefg
abjrbcdefg
g2abcdfeg
abjrbcedfg
fig. 15. group of traces corresponding  to i 1 . 
table 1 
accuracy  (number  and percentage  of correctly  reconstructed  igs) obtained  by vary- 
ing the percentage  of irregular  traces (irt) in the synthetic  log. results of 6 experi- 
ments: vd, vb, big −
hm , big hm , big −
iim , and big iim . 
trace irt(%) acc vd vb big −
hm big hm big −
iim big iim 
16 81.3% #ig 2 3 3 12 5 12 
%ig 12.5% 18.8% 18.8% 75.0% 31.3% 75.0% 
19 68.4% #ig 2 3 5 14 7 14 
%ig 10.5% 15.8% 26.3% 73.7% 36.8% 73.7% 
22 59.1% #ig 2 3 10 22 9 16 
%ig 9.1% 13.6% 45.5% 100% 40.9% 72.7% 
27 48.2% #ig 2 3 15 27 12 20 
%ig 7.4% 11.1% 55.6% 100% 44.4% 74.1% 
34 38.2% #ig 2 3 21 34 16 24 
%ig 5.9% 8.8% 61.8% 100% 47.1% 70.6% 
49 26.5% #ig 2 3 36 49 26 34 
%ig 4.1% 6.1% 73.5% 100% 53.1% 69.4% 
99 13.1% #ig 2 3 86 99 60 68 
%ig 2.0% 3.0% 86.9% 100% 60.6% 68.7% 
199 6.5% #ig 2 3 186 199 126 134 
%ig 1.0% 1.5% 93.5% 100% 63.3% 67.3% 
298 4.4% #ig 2 3 285 298 191 199 
%ig 0.7% 1.0% 95.6% 100% 64.1% 66.8% 
with 298 traces (i.e., 13 irregular  plus 190 from i 1 and 95 from i 2 ). 
clearly,  as the number  of the regular  traces in the log increases,  
the percentage  of irregular  traces (irt) decreases.  hence, we move 
from irt = 81.25%,  to irt = 4.36%. details  are reported  in tables 1 
and 2 . 
tables also report accuracy  and matching  cost for the 6 dif- 
ferent approaches  analyzed:  van dongen  (vd), van beest (vb), the 
big algorithm  using heuristic  miner (big hm ) and infrequent  in- 
ductive  miner (big iim ) and the big −algorithm,  which corresponds  
to the big algorithm  without  applying  the repairing  (i.e., without  
performing  steps 4–6 in algorithm  1 ), using the same pd tech- 
niques ( big −
hm , big −
iim ). note that, since both vd and vb adopt the 
α-algorithm,  that is a non-ﬁltering  pd technique  (see section  4 ), 
no repairing  strategy  is needed.  table 1 reports  the accuracy  of 
each set of built igs, in terms of number  and percentage  of cor- 
rectly reconstructed  igs; while table 2 reports  both the total mc, 
i.e., the sum of the mc computed  on the whole log, and the av- 
erage mc, which is computed  only on the wrong graphs,  since for 
correct  graphs the value is zero. table 2 
matching  cost (total and average)  obtained  by varying the percentage  of irregular  
traces (irt) in the synthetic  log. results of 6 experiments:  vd, vb, big −
hm , big hm , 
big −
iim , and big iim . 
trace irt(%) mc vd vb big −
hm big hm big −
iim big iim 
16 81.3% tot 105 88 63 20 62 20 
avg 7.5 6.8 4.8 5.0 5.6 5.0 
19 68.4% tot 118 103 68 25 67 25 
avg 6.9 6.4 4.9 5.0 5.6 5.0 
22 59.1% tot 131 118 50 0 72 30 
avg 6.6 6.2 4.2 0.0 5.5 5.0 
27 48.2% tot 152 143 50 0 80 35 
avg 6.1 6.0 4.2 0.0 5.3 5.0 
34 38.2% tot 183 187 51 0 95 50 
avg 5.7 6.0 3.9 0.0 5.3 5.0 
49 26.5% tot 248 354 51 0 120 75 
avg 5.3 7.7 3.9 0.0 5.2 5.0 
99 13.1% tot 464 604 51 0 200 155 
avg 4.8 6.3 3.9 0.0 5.1 5.0 
199 6.5% tot 898 1308 51 0 370 325 
avg 4.6 6.7 3.9 0.0 5.1 5.0 
298 4.4% tot 1327 1814 51 0 540 495 
avg 4.5 6.1 3.9 0.0 5.0 5.0 
fig. 16. accuracy  vs. percentage  of irregular  traces. 
fig. 16 provides  a graphical  representation  of the accuracy  
trends with respect  to the percentage  of irregular  traces in the 
event log. 
first, we can note that the worst results are provided  by vd, 
that is able to correctly  build only two igs of the entire set. vb 114 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
obtains  only slightly  better results,  being able to correctly  build 
three igs of the set. these values do not change  by reducing  the 
percentage  of irregular  traces, resulting  in a decay of the accu- 
racy for both the approaches;  indeed,  the corresponding  lines in 
fig. 16 tend to an accuracy  of 0%. this trend is due to the pres- 
ence of swaps in the irregular  traces. the α-algorithm  considers  
the pairs b and c , and l and m as parallels;  hence, it is not able to 
properly  build the igs corresponding  to regular  traces. indeed,  the 
only graphs that are properly  reconstructed  by vd are those which 
correspond  to traces involving  the deletion  of l and the deletion  of 
b , respectively;  while vb was able to reconstruct  also the ig cor- 
responding  to the trace involving  the deletion  of c . this is due to 
the fact that vb connects  the activity  b to both the activities  d and 
e , since no explicit  parallelism  is detected  between  them, while vd 
cannot connect  b and d , since no causal relation  exists between  
them. as regards  big −
hm , it provides  better results than vd and vb, 
as expected.  however,  for the ﬁrst event log it shows the same per- 
formance  of vb, since it is able to reconstruct  three igs. as a mat- 
ter of facts, the model mined by hm describes  almost all regular  
behavior  of fig. 14 , but the activities  l and m are considered  as par- 
allel, with the result that the igs involving  these activities  cannot 
be properly  reconstructed.  as irt reduces,  hm is able to correctly  
represent  regular  traces, thus the big −hm
 error tends to decrease  
(see fig. 16 ); in particular,  from 70% to 60% there is an improve-  
ment in accuracy  of the 20%. then, as the number  of regular  traces 
increases,  the outcome  of the algorithm  stabilizes  and the accuracy  
trends becomes  linear. 
similar  considerations  hold for big −
iim . at the beginning  it ob- 
tains poor results,  because  of the high percentage  of noise, which 
leads to induce incorrect  parallelisms;  by reducing  the noise in the 
log, accuracy  increases.  however,  it is noteworthy  that for irt less 
than 60%, big −
hm obtains  better results than big −
iim . the accuracy  of 
big −
hm tends to 100%, while for big −
iim the accuracy  tends to 65%. 
this depends  again on the identiﬁcation  of a wrong parallelism  be- 
tween the activities  l and m , which is kept also for low percentage  
of irregular  traces; the result is that the igs built from traces in- 
volving  these activities  turn out to be incorrect.  
when the repairing  procedure  is applied,  the accuracy  increases  
signiﬁcantly.  both big hm and big iim outperform  results obtained  
with same models  without  repairing.  for the ﬁrst log the improve-  
ment is 43.75%  using the iim and 56.25%  using the hm. decreasing  
irt, the accuracy  of big iim shows a linear trend with a little slope 
(from 73% to 67%); while big hm moves to 100%, namely  it is able 
to reconstruct  all igs. when irt is very low, irregular  traces are 
very rare and the scenario  moves from unstructured  to structured  
one. in this scenario,  the effect of repairing  is almost negligible.  
as regards  the mc, results are consistent  with the consider-  
ations done for accuracy.  indeed,  both vd and vb obtain for all 
the event logs the highest  values of total mc. this was expected,  
since they turned out to be able to correctly  build only two igs 
in all the cases, respectively.  , big −
hm and , big −
iim obtain similar  
values at the beginning,  but , big −
hm improves  signiﬁcantly  its val- 
ues by decreasing  the percentage  of irregular  traces. the repaired  
approaches  are the best ones; in particular  big hm obtains  a cost 
equal to zero when the irt decreases  under 68%, and big iim ob- 
tains a total mc much lower than big −
iim . let us now consider  the 
average  mc, which provides  an indication  about the magnitude  of 
the error, i.e., how many errors each approach  has done on aver- 
age when building  a graph. note that this value has to be evalu- 
ated with respect  to the average  number  of elements  (i.e., nodes 
and edges) per graph, which results in [15; 17] for all event log. 
again, vd and vb are the approaches  that return the highest  num- 
ber of errors per graph, ranging  from 4.48 to 7.5, and from 5.9 to 
7.69 respectively.  big −
iim and big iim return for all the event logs an 
average  mc around  5; it depends  on errors in the model mined by 
the iim, as we discussed  before.  finally,  approaches  based on hm table 3 
average generalization  over the whole ig set ( ag all ), the set of regular igs ( ag reg ) 
and the set of irregular  igs ( ag irr ) obtained  by varying the percentage  of irregular  
traces (irt) in the synthetic  log. results of 6 experiments:  vd, vb, big −
hm , big hm , 
big −
iim , and big iim . 
trace irt(%) ag vd vb big −
hm big hm big −
iim big iim 
16 81.3% ag all 7.8 3.6 23.7 1.9 19.4 1.9 
ag reg 7.8 3.6 2.0 2.0 2.0 2.0 
ag irr – – 28.7  1.9 23.5 1.9 
19 68.4% ag all 7.2 3.5 20.3 1.9 16.7 2.0 
ag reg 7.2 3.5 2.0 2.0 2.0 2.0 
ag irr – – 28.7  1.9 23.5 1.9 
22 59.1% ag all 6.7 3.5 16.5 1.7 14.7 2.0 
ag reg 6.7 3.5 1.7 1.7 2.0 2.0 
ag irr – – 26.8  1.7 23.5 1.9 
27 48.2% ag all 6.3 3.5 13.8 1.7 13.2 2.0 
ag reg 6.3 3.5 1.7 1.7 2.0 2.0 
ag irr – – 26.7  1.7 25.2 1.9 
34 38.2% ag all 5.8 3.4 11.6 1.7 10.9 2.0 
ag reg 5.8 3.4 1.7 1.7 2.0 2.0 
ag irr ––2 7 . 7  1.7 25.2 1.9 
49 26.5% ag all 5.2 3.4 8.6 1.7 8.2 2.0 
ag reg 5.2 3.4 1.7 1.7 2.0 2.0 
ag irr ––2 7 . 7  1.7 25.2 1.9 
99 13.1% ag all 4.6 3.4 5.1 1.7 5.1 2.0 
ag reg 4.6 3.4 1.7 1.7 2.0 2.0 
ag irr ––2 7 . 7  1.7 25.2 1.9 
199 6.5% ag all 4.3 3.4 3.4 1.7 3.5 2.0 
ag reg 4.3 3.4 1.7 1.7 2.0 2.0 
ag irr ––2 7 . 7  1.7 25.2 1.9 
298 4.4% ag all 4.2 3.3 2.8 1.7 3.0 2.0 
ag reg 4.2 3.3 1.7 1.7 2.0 2.0 
ag irr ––2 7 . 7  1.7 25.2 1.9 
fig. 17. average generalization  vs. percentage  of irregular  traces. synthetic  event 
log. 
algorithm  show the best values ( big −
hm in [3.92; 4.84], while big hm 
is 5 for irt > 60%, 0 otherwise),  demonstrating  that the model ob- 
tained by using the hm algorithm  is the best one. 
table 3 shows the ag values obtained  by the performed  exper- 
iments.  
in order to evaluate  the values of the ag, we need a refer- 
ence value for igs with “good” generalization.  to this end, we re- 
fer to ag reg obtained  by ﬁltering  approaches.  as a matter of fact, 
since in these experiments  irregular  traces are variants  of regular  
traces they differ each other for few changes;  hence ag reg and ag irr 
should assume  similar  values. we emphasize  that to compute  ag 
we do not use a-priori  knowledge  about the true process  model;  
hence, regular  and irregular  traces are the ones which perfectly  ﬁt 
and not ﬁt the model respectively.  from table 3 , it turns out that 
the ag reg for big hm is 1.7 on average,  while for big iim is 2; hence, 
we consider  the interval  [1.7; 2] as reference.  
fig. 17 shows the ag all obtained  by the six experimented  ap- 
proaches  with respect  to irt; the interval  of reference  values is 
represented  by dotted lines. both big −hm
 and big −
iim show worse 
results than vd and vb. this is due to the presence  of deleted  c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 115 
fig. 18. petri net mined by the iim from the wabo4 event log. 
activities,  which leads to disconnected  graphs and in turn to 
high overgeneralization  (see example  4 ). this statement  is sup- 
ported by results in table 3 , where ag irr is signiﬁcantly  higher 
than ag reg . we can note that vb obtains  better results than vd. 
indeed,  the latter is also affected  by a relevant  overgeneraliza-  
tion ranging  in [4.2; 7.75], that is more than double  of the ref- 
erence values;  while vb obtains  quite stable results,  around  3 
traces per graph, that is closer, but still outside  the reference  
interval.  
finally,  by applying  the repairing  procedure  we obtain the best 
results,  both for big hm and for big iim ; their lines overlap  almost 
completely  in fig. 17 . the resulting  ag all and ag irr are in the ref- 
erence interval,  hence showing  the capability  of the proposed  re- 
pairing  procedure  of preventing  overgeneralization.  
6.2. real-world  event log 
this subsection  shows the results obtained  on wabo4  , which is 
one of the real-world  event logs of the coselog  project  5 . wabo4  
refers to the process  of environmental  permit application  of a 
dutch municipality.  the log involves  332 different  activities  in 787 
traces. fig. 18 , which shows the petri net mined by the iim, allows 
us to perceive  the highly variable  nature of the process.  
we preprocessed  the event log by adding  artiﬁcial  start and end 
activities  to all traces. 
for this experiment  we could not use the hm. it is worth not- 
ing that hm does not guarantee  to obtain a sound process  model 
(i.e., a model where all process  steps can be executed  and the ﬁnal 
marking  is always reachable),  leading  to problems  in conformance  
checking  ( leemans  et al., 2014 ). in particular,  using hm to mine 
a model for wabo4,  the conformance  checker  is able to deﬁne 
an alignment  only for 5 of 787 traces; in other words, for most 
of traces we cannot know if they are regular  or irregular,  hence, 
we cannot apply the proposed  repairing  procedure.  for this reason,  
we used only iim as ﬁltering  pd technique,  that always returns  a 
sound process  model. it is worth noting that there are 485 irregu-  
lar traces with respect  to the model mined by iim, that is around  
62% of the whole log. nevertheless,  the model has a high ﬁtness 
(i.e., the ability to reproduce  traces in the log), which is around  
98%. this can be explained  by considering  that the ratio between  
the number  of inserted/deleted  activities  and the number  of activ- 
ities per trace is low (we have around  two inserted/deleted  activi- 
ties for trace on average,  and each trace is formed  by 46 events on 
average);  hence, a relevant  portion  of each trace can be actually  
replied  by the model. table 4 shows the ag values obtained  on the 
wabo4  event log by vd, vb, big −
iim and big iim approaches.  note 
that the values reported  for vd and vb represent  lower bounds  
5 http://data.3tu.nl/repository/collection:event  _ logs _ real table 4 
ag results obtained  on wabo4 event log. 
trace irt(%) ag vd vb big −
iim big iim 
787 61.3% ag all /greatermuch99.14 /greatermuch92.82 15.4 9.5 
ag reg /greatermuch99.14 /greatermuch92.82 3.8 3.8 
ag irr – – 22.7  9.5 
of actual ag values. indeed,  applying  vd and vb we obtained  very 
complex  igs, with a high number  of edges, which made generating  
the entire occurrence  sequences  set for each ig time-consuming.  
therefore,  for vb and vd we limited  the occurrence  sequences  gen- 
eration  to the ﬁrst 100. noteworthily,  in both cases we found few 
igs generating  less than 100 occurrence  sequences;  therefore,  we 
had that most of the igs (691 for vb, 776 for vd) generated  a num- 
ber of occurrence  sequences  at least equal (but very likely much 
bigger)  than 100, thus motivating  the high ag all values computed  
for these algorithms.  
applying  iim, we obtain signiﬁcantly  better generalization  re- 
sults. in particular,  it turns out that big iim outperforms  the big −
iim . 
indeed,  big −
iim shows still a quite high ag all value (i.e., 15.4 oc- 
currence  sequences  per graph);  while applying  the repairing  the 
ag all decreases  to 9.5. the improvement  achieved  by the repairing  
is especially  evident  for the irregular  traces, where we move from 
ag irr = 22 . 7 of big −iim
 to ag irr = 13 when the repairing  is applied.  
the results achieved  in terms of generalization  values prove 
that the proposed  approach  was actually  able to obtain igs signif- 
icantly more accurate  than other techniques,  especially  when the 
repairing  is applied.  
in order to better appreciate  the effect of the proposed  ap- 
proach,  in fig. 19 we show an example  of iig built by big −iim
 and 
big iim for a trace σ1 extracted  from the wabo log, involving  78 
events;  for the sake of space, in the figure only the portions  of 
igs including  irregularities  are shown,  black dots represent  the 
remaining  parts of the process.  the trace has a deleted  activity,  
i.e., 01_hoofd_510_2a  , and an inserted  activity,  i.e., 16_lgsd_010  . 
fig. 19 a shows an evident  structural  problem:  besides  start node 
the process  has two other nodes without  predecessors,  namely  
01_hoofd_510_3  and 01_hoofd_515  , and two nodes without  suc- 
cessors,  namely  end and 16_lgsd_010  . hence, big −iim
 returns  an 
ig having a very high number  of occurrence  sequences.  fig. 19 b 
shows the ig obtained  by big iim ; the repairing  procedure  corrects  
the structural  problems  and provides  a clear and not ambiguous  
representation  of the execution  order of corresponding  process  in- 
stance.  moreover,  in the dotted box of fig. 20 a and b we show 
the same portion  of igs as returned  by applying  vd and vb ap- 
proaches.  differing  from igs obtained  by big iim , vb and vd ap- 
proaches  return igs with a high number  of parallel  behaviors;  
hence revealing  a signiﬁcant  overgeneralization;  the number  of 116 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
(a)
(b)
fig. 19. instance graph obtained  by big −
iim (a) and big iim (b) for σ1 . 
(a)
(b)
fig. 20. instance graph obtained  by vd (a), vb (b) for σ1 . 
occurrence  sequences  is four for big iim and more than 100 for 
other approaches.  
figs. 19 and 20 clearly show the advantage  of using our ap- 
proach  with respect  to other ones; indeed,  it is apparent  that over- 
generalizing  igs do not provide  useful insights  on the execution  of 
the process.  
7. conclusions  
this work introduced  a methodology  for building  instance  
graphs  for highly variable  processes  starting  from a simple event 
log. igs offer a different  perspective  on the process,  focusing  on 
the analysis  of individual  process  instances.  the proposed  approach  
bases the generation  of igs on casual relations  among  activities,  
which are inferred  from the log by resorting  to pd techniques.  
in particular  ﬁltering  pd techniques  are adopted,  which represent  
only the most relevant  casual relations,  thus cutting  down over- 
generalization.  however,  ﬁltering  leads to irregular  traces; hence, 
instance  graphs  built for irregular  traces are not accurate.  to ad- 
dress this issue, we couple the exploitation  of ﬁltering  techniques  
with an original  technique  aimed at repairing  graphs.  
we performed  several  experiments,  both on synthetic  and real- 
world event logs, to assess the advantages  of the approach.  it turns 
out that our proposal  outperforms  other approaches  both in terms 
of accuracy  and average  generalization.  in particular,  in the syn- 
thetic experiments  we were able to evaluate  the the correctness  of the methods  with respect  to reference  igs. results  show that 
techniques  based on the α-algorithm  were not able to generate  
the correct  igs in most cases even on event logs with a very low 
percentage  of irregularities,  since also few irregular  traces led to 
overgeneralizing  models.  adopting  ﬁltering  approaches  instead,  the 
effects of the irregularities  were signiﬁcantly  reduced,  resulting  in 
more igs correctly  reconstructed.  however,  from experiments  it is 
also apparent  that ﬁltering  approaches  without  repairing  perform  
really bad in terms of average  generalization,  obtaining  worse re- 
sults than van dongen’s  and van beest’s approaches.  such a result 
pointed  out the importance  of the repairing  procedure,  which cor- 
rects structural  anomalies  and improves  accuracy  and generaliza-  
tion. the results obtained  in the synthetic  case were conﬁrmed  in 
the real-world  case. here, the α-based approaches  obtained  really 
high values of average  generalization,  thus meaning  that the cor- 
responding  igs involved  many parallelisms,  as also shown in ex- 
amples  from which it was apparent  that these igs do not provide  
much aid to the analysis  of process  instances.  similar  considera-  
tions also hold for ﬁltering  approaches  without  repairing;  while 
the introduction  of repairing  allowed  to obtained  signiﬁcantly  bet- 
ter performance.  
experiments  also enlightened  that the feasibility  of the pro- 
posed repairing  technique  is constrained  to the availability  of 
sound models,  due to the conformance  checking  technique  
adopted.  this in turn put a constraint  on the pd technique  to be 
used to mine the model. nevertheless,  we like to note that iim 
guarantees  to always return a sound model, so that we can state 
that our approach  can be applied  to any event log, although  the 
model mined by iim could not be the best in terms of generaliza-  
tion performance.  hence the possibility  to detect irregular  traces 
also on unsound  models  could provide  more ﬂexibility  in selecting  
the most accurate  technique  for the data at hand. we plan to in- 
vestigate  the usage of different  conformance  checking  techniques  
to detect irregular  traces in future work. we plan also to investi-  
gate the effects of the usage of process  discovery  techniques  other 
than heuristic  miner and infrequent  inductive  miner. furthermore,  
we intend to further  develop  the repairing  algorithm  for special  
cases. for example,  we intend to analyze  and evaluate  alternative  
strategies  to deal with the insertion  of activities  occurring  in the 
middle  of parallel  branches.  
references  
adriansyah,  a. , van dongen, b. f. , & van der aalst, w. (2011). conformance  checking  
using cost-based  ﬁtness analysis. in proceedings  of the 15th ieee international  
enterprise  distributed  object computing  conference  (pp. 55–64). helsinki,  finland: 
ieee . 
adriansyah,  a. , munoz-gama,  j. , carmona,  j. , van dongen, b. f. , & van der 
aalst, w. m. (2013). alignment  based precision  checking.  in m. la rosa, & p. sof- 
fer (eds.), business process management  workshops  . in lecture notes in business 
information  processing.:  vol. 132 (pp. 137–149).  berlin heidelberg:  springer . c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 117 
buijs, j. c. a. m. , la rosa, m. , reijers, h. a. , van dongen, b. f. , & van der 
aalst, w. m. p. (2013). improving  business  process models using observed  be- 
havior. in p. cudre-mauroux,  p. ceravolo,  & d. gaševi ´c (eds.), data-driven  process 
discovery  and analysis . in lecture notes in business information  processing:  vol. 162 
(pp. 44–59). berlin heidelberg:  springer . 
de medeiros,  a. k. a. , guzzo, a. , greco, g. , van der aalst, w. , weijters,  a. j. m. m. , 
van dongen, b. f. , & saccà, d. (2008). process mining based on clustering:  a 
quest for precision.  in a. ter hofstede,  b. benatallah,  & h.-y. paik (eds.), business 
process management  workshops  . in lecture notes in computer  science: vol. 4928 
(pp. 17–29). berlin heidelberg:  springer . 
de weerdt, d. , de backer, m. , vanthienen,  j. , & baesens, b. (2012). a multi-dimen-  
sional quality assessment  of state-of-the-art  process discovery  algorithms  using 
real-life event logs. information  syst, 37 , 654–676  . 
desel, j. , juhás, g. , lorenz, r. , & neumair,  c. (2003). modelling  and validation  with 
viptool. in w. van der aalst, & m. weske (eds.), business process management.  
lecture notes in computer  science: vol. 2678 (pp. 380–389).  berlin heidelberg:  
springer . 
diamantini,  c. , genga, l. , & potena, d. (2016). behavioral  process mining for un- 
structured  processes.  journal of intelligent  information  system . 
diamantini,  c. , genga, l. , potena, d. , & storti, e. (2013). pattern discovery  from in- 
novation  processes.  in collaboration  technologies  and systems (cts), 2013 interna- 
tional conference  on (pp. 457–464).  san diego, california,  usa: ieee . 
diamantini,  c. , potena, d. , & storti, e. (2012). mining usage patterns from a repos- 
itory of scientiﬁc  workﬂows.  in proceedings  of the 27th annual acm symposium  
on applied computing  (pp. 152–157).  acm . 
fahland, d. , & van der aalst, w. (2015). model repair—aligning  process models to 
reality. information  system, 47 , 220–243  . 
forrester,  p. (1999). business  process engineering:  reference  models for industrial  
enterprises.  integrated  manufacturing  system, 10 . 57–57 
greco, g. , guzzo, a. , manco, g. , & saccà, d. (2007). mining unconnected  patterns in 
workﬂows.  information  system, 32 , 685–712  . 
hwang, s. , wei, c. , & yang, w. (2004). discovery  of temporal  patterns from process 
instances.  computers  in industry, 53 , 345–364  . 
leemans,  s. j. , fahland, d. , & van der aalst, w. (2014). discovering  block-struc-  
tured process models from event logs containing  infrequent  behaviour.  in 
n. lohmann,  m. song, & p. wohed (eds.), business process management  work- 
shops . in lecture notes in business information  processing:  vol. 171 (pp. 66–78). 
springer international  publishing  . lu, x. , fahland, d. , & van der aalst, w. (2015). conformance  checking  based on par- 
tially ordered event data. in f. fournier,  & j. mendling  (eds.), business process 
management  workshops  . in lecture notes in business information  processing:  vol. 
202 (pp. 75–88). springer international  publishing  . 
de man, h. (2009). case management:  a review of modeling  approaches.  
bptrends,  january, 2009 . http://www.ww.bptrends.com/publicationﬁles/  
01- 09- art- %20case%20management-  1- deman.1165%20doc-  - ﬁnal.pdf . last 
access: 16/09/2015.  
rovani, m. , maggi, f. m. , de leoni, m. , & van der aalst, w. m. (2015). declarative  
process mining in healthcare.  expert system with applications,  42 , 9236–9251  . 
suriadi, s. , ouyang, c. , van der aalst, w. m. , & ter hofstede,  a. h. (2015). event inter- 
val analysis:  why do processes  take time? decision support system, 79 , 77–98 . 
van beest, n. , dumas, m. , garcía-ba  nuelos, l. , & la rosa, m. (2015). log delta anal- 
ysis: interpretable  differencing  of business  process event logs. in h. r. motahar-  
i-nezhad,  j. recker, & m. weidlich  (eds.), business process management  . in lec- 
ture notes in computer  science: vol. 9253 (pp. 386–405).  springer international  
publishing  . 
van der aalst, w. (2011). process mining: discovery,  conformance  and enhancement  of 
business processes  . springer-verlag  berlin heidelberg  . 
van der aalst, w. (2013). decomposing  petri nets for process mining: a generic ap- 
proach. distributed  and parallel databases,  31 , 471–507  . 
van der aalst, w. , & van hee, k. m. (2004). workﬂow  management:  models, methods,  
and systems . cambridge,  ma, usa: mit press . 
van dongen, b. , & van der aalst, w. (2004). multi-phase  process mining: build- 
ing instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, & t.-w. ling (eds.), 
conceptual  modeling-  er 2004 . in lecture notes in computer  science: vol. 3288 
(pp. 362–376).  berlin heidelberg:  springer . 
van dongen, b. , alves de medeiros,  a. , & wen, l. (2009). process mining: overview  
and outlook of petri net discovery  algorithms.  in k. jensen, & w. van der aalst 
(eds.), transactions  on petri nets and other models of concurrency  ii . in lecture 
notes in computer  science: vol. 5460 (pp. 225–242).  berlin heidelberg:  springer . 
van dongen, b. f. , & van der aalst, w. (2005). multi-phase  process mining: aggre- 
gating instance graphs into epcs and petri nets. in d. marinescu  (ed.), proceed- 
ings of the second international  workshop  on applications  of petri nets to coordina-  
tion, workﬂow  and business process management  (pp. 35–58). miami, florida,usa:  
florida international  university  . 
weijters,  a. , van der aalst, w. , & de medeiros,  a. a. (2006). process mining with 
the heuristics  miner-algorithm.  technische  universiteit  eindhoven,  technical  re- 
port wp, 166 . 1–34 118 c. diamantini  et al. / expert systems with applications  59 (2016) 101–118 
claudia diamantini  is associate  professor  at the department  of information  engineering,  università politecnica  delle marche, where she coordinates  the degree courses in 
computer  and automation  engineering  and leads the knowledge  discovery  & management  research group. she received the phd degree in artiﬁcial intelligent  systems from 
the university  of ancona in 1995. at present her main research interests  are in business  analytics  and data mining, and in semantic  models for integrated  interoperable  
analytics  and mining in distributed  settings. she has been working on these topics within national and international  projects. she is author of about 100 technical  papers in 
refereed journals and conferences.  she is a member of the ieee and acm. 
laura genga is a phd student of the department  of information  engineering  of the università politecnica  delle marche, where she graduated  in computer  and automation  
engineering  in 2012. her research interests  are in the areas of data mining and knowledge  discovery,  process mining and innovation  support. 
domenico  potena received the phd in information  systems engineering  from the università politecnica  delle marche, italy, in 2004. from 2005 to 2008, he was post-doctoral  
fellow at the same university.  at present, he is an assistant  professor  at the università politecnica  delle marche, department  of information  engineering.  his research interests  
include knowledge  discovery  in databases,  data warehousing,  data semantics,  innovation  management  systems. 
wil van der aalst is a full professor  of information  systems at the technische  universiteit  eindhoven  (tu/e). he is also an adjunct professor  at queensland  university  of 
technology  (qut). his research interests  include workﬂow  management,  process mining, petri nets, business  process management,  process modeling,  and process analysis. 
he is an elected member of the royal holland society of sciences and humanities  (koninklijke  hollandsche  maatschappij  der wetenschappen)  and the academy  of europe 
(academia  europaea).  