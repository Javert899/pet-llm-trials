multi-phase process mining: aggregating
instance graphs into epcs and petri nets
b.f. van dongen, and w.m.p. van der aalst
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
{b.f.v.dongen, w.m.p.v.d.aalst }@tm.tue.nl
abstract. the goal of process mining is to automatically generate a
process model from an event log, e.g., automatically constructing anepc based on the transaction logs in sap. currently available process
mining techniques typically try to generate a complete process model
from the data acquired in a single step. in this paper, we propose a multi-step approach. first models are generated for each individual process
instance (this can be done in many steps). in the ﬁnal step however,
these instance models are aggregated to obtain an overall model for the
entire data set. in this paper, we focus on that ﬁnal step, i.e., aggregating
instance graphs. the work is motivated by recent tools and techniques togenerate instance models. for example, widely used tools such as aris
ppm and inconcert generate instance models that can be interpreted
by our process mining tool. the result of our multi-step approach canbe represented in diﬀerent types of process models. in this paper, we
show a translation from aggregated instance graphs to petri nets using
event-driven process chains (epcs) as an intermediate step.
keywords : process mining, event-driven process chains, aggregation.
1 introduction
increasingly, process-driven information systems are used to support operational
business processes. some of these information systems enforce a particular way
of working. for example, workﬂow management systems (wfmss) can be used
to force users to execute tasks in a predeﬁned order. however, in many cases
systems allow for more ﬂexibility. for example transactional systems such aserp (enterprise resource planning), crm (customer relationship manage-
ment) and scm (supply chain management) are known to allow the users to
deviate from the process speciﬁed by the system, e.g., in the context of sap r/3the reference models, expressed in terms of event-driven process chains (epcs,
cf. [16, 17, 21]), are only used to guide users rather than to enforce a particular
way of working. operational ﬂexibility typically leads to diﬃculties with respectto performance measurements. the ability to do these measurements, however,
is what made companies decide to use a transactional system in the ﬁrst place.
one way of doing performance measurements is trough so-called instance
graphs. instance graphs can be considered to be process models of single exe-cutions of a case. these instance graphs are a nice way to show parallelism in
process execution and using these instance graphs, many interesting performance
characteristics can be calculated and visualized. however, sometimes looking atsingle instances of a process is too ﬁne-grained. especially managers usually want
to calculate performance measures on a more aggregated level. therefore, in thispaper, we propose a way to aggregate instance graphs to an aggregation graph.
such an aggregation graph represents the execution of a set of cases instead of
just one. these aggregation graphs can be used as the starting point for manyinteresting measurements in the context of business process management. the
work presented in this paper is greatly inspired by the commercial tool aris
ppm (aris process performance monitor, c.f. [15]). this tool indeed visualizessingle instances of a process using instance graphs and is capable of aggregating
them. however, in contradiction to the algorithms presented here, each installa-
tion of aris ppm requires consultants to manually conﬁgure the way instances
are generated and the way they are to be aggregated.
process
design
process
configurationprocess
enactmentprocess
diagnosis(2) process mining
(1) traditional approach(3) delta analysis
fig. 1. the bpm life cycle.
 fig. 2. a partial epc.
in figure 1, we show the typical life cycle of a process in business process
management. in the traditional approach, you start with a process design. then,the design is implemented in some process aware information system in the con-
ﬁguration phase. after the process has been running for a while in the enactment
phase, diagnostics can be used to come to another (and preferably better) de-sign. the research area of process mining focuses mainly on trying to come to
a process design using data gathered in the enactment phase. furthermore, the
concept of delta analysis is to compare a process as it is actually executed with
the way it was intended to be executed. with the approach presented in this
paper, we focus on process mining, i.e. we generate a process model from cases
that have been executed. the result can then be used for comparison with theoriginal process model (delta analysis).
processes can be described in several modeling languages. each language has
its own advantages and disadvantages. in this paper, we choose to focus on themodeling language of event driven process chains, or epcs (c.f. [16, 17]. this
choice is motivated by the fact that it is widely used in industry and is easy to
comprehend for people without a background in theoretical computer science.however, the general result is independent of this format, and in section 5 and
section 6, we show a translation to petri nets. an example of a part of an epc
can be seen in figure 2. we introduce epcs in some more detail in section 4.the remainder of this paper is organized as follows. first, we give some
general notations and concepts that will be used throughout the paper. then,in section 3, we show the formal process of aggregating instance graphs. in
section 4, we show how our format-independent result can be translated to epcs.
in section 5 and section 6, we give a translation of our result into petri nets.the latter translation into petri nets uses epcs as an intermediate step. finally,
in section 7, we present our toolset that supports the processes discussed here,
and we conclude the paper with some conclusions.
a short version of the work presented here has been submitted to the interna-
tional conference on conceptual modelling (er 2005) [12]. this paper extends
[12] by adding formal proofs for the various aggregation steps and by adding atranslation to petri nets.
2 preliminaries
in this section, we introduce the basic concepts behind multi-phase process min-ing, as well as some basic notations. in process mining, the goal is to construct
a formal model describing a set of real life executions. usually, these models can
be visualized as a graph. in this paper, we do this by assuming that for each
process instance or case, there is a graph that describes that instance. then, we
sum these individual graphs to an aggregation graph. an example of an algo-rithm to generate a graph that describes a process instance can be found in [11].
in order to be able to talk about instance and aggregation graphs, we introduce
some basic notations.
2.1 general concepts
in general, a graph consists of a set of nodes and a set of edges. we introduce
a counting operator # over sets, such that we are able to count the number of
elements of a set for which a certain property holds.
deﬁnition 2.1. (counting operator) letsbe some set. we deﬁne a counting
operator # over the elements of s, in such a way that we can count the number of
elements for which some predicate pholds as #
s∈sp(s)=/summationtext
s∈s/braceleftbigg
1i fp(s)
0i fn o t p(s).
note that by deﬁnition, s=∅implies that # s∈sp(s)=0 .
since we will be using graphs throughout the paper, we introduce some basic
notations for graph-related properties.
deﬁnition 2.2. (path in a directed graph) letg=(n,e) be a directed
graph with nthe set of nodes and e⊆n×nthe set of edges. let a∈nand
b∈n. we deﬁne a path from atobas a list of nodes denoted by /angbracketleftn1,n2,...,n k/angbracketright
withk≥2 such that n1=aandnk=band∀i∈{1,...,k−1}((ni,ni+1)∈e).
a path in a directed graph is an ordered list of nodes, such that for every
node in the list, there is an edge to the next node in the list. note that we deﬁne
a path to contain at least two nodes.deﬁnition 2.3. (pre-set and post-set) letg=(n,e) be a directed graph
and let n∈n. we deﬁneg•n={m∈n|(m,n)∈e}as the pre-set and
ng•={m∈n|(n,m)∈e}as the post-set of nwith respect to graph g.i ft h e
context is clear, the superscript gmay be omitted, resulting in •nandn•.
using the pre- and postset of a node, we indicate which nodes have an edge
to or from that node respectively.
2.2 instance graphs
as stated in the introduction, we use a multi-step approach where we ﬁrst gener-
ate models of instances and then aggregate these instance models into an overall
process model. for this purpose each process instance is not described by a sim-ple sequence of events but as a directed graph. in every process, there is a set
of tasks that has to be executed. whether or not a speciﬁc task is executed,
and if so, how often, completely depends on a speciﬁc instance of a process. forexample an insurance claim handling process can contain a rule that in case of a
claim that exceeds a speciﬁc amount, a manager has to check the ﬁnal decision
before sending it to the customer. however, if we look at a completed processinstance, we know that for all those choices, a certain decision was made. as
a result, there is no need to visualize any kind of choice in the representation
of a process instance, i.e. every split/join is an and -split/join. this implies
that it suﬃces to use a normal directed graph. we call such a representation an
instance graph and each node in that graph represents the execution of a task
in the process.
1
fig. 3. aris ppm
 fig. 4. aris ppm
as indicated in the introduction, tools such aris ppm (ids scheer, [15]),
staﬀware spm, and inconcert (tibco) generate instance graphs. figures 3
and 4 show screenshots of aris ppm. each of the two ﬁgures depicts an instance
1in spite of some subtle diﬀerences, instance graphs are similar to runs [9] also known
as occurrence nets or partially ordered petri net processes, cf. section 8.graph of an insurance process. both instance graph are represented in terms of so-
called instance epc. besides tools such as aris ppm directly providing instancegraphs, it is also possible to obtain instance graphs via an analysis of “raw” event
logs (e.g., transaction logs, audit trails, etc.). for a more detailed description of
instance graphs and how they can be generated from a event logs, we refer to [11].however, we do not limit ourselves to the algorithm presented [11]. instead, we
deﬁne an instance graph in a generic way. this explains the term “multi-phase
process mining”, instead of “two-phase process mining”. generating instancegraphs from log ﬁles can be done in multiple phases.
deﬁnition 2.4. (instance graph) lettbe a set of tasks. we deﬁne ig=
(n,e,t,l ) as an instance graph over twhere:
1.n/negationslash=∅is the set of nodes.
2.e⊆n×nis the set of edges
3.tis a set of tasks.
4.l:n→tis a labeling function, mapping nodes onto t.
5. the graph ( n,e) is a-cyclic, i.e. for all paths /angbracketleftn
1,...,n k/angbracketright:n1/negationslash=nk.
6.∀(a,b)∈e/angbracketlefta,b/angbracketrightis the onlypath from atob.
7.∀a,b∈nl(a)=l(b) implies that there is a path from atobor from btoa.
deﬁnition 2.4 shows that instance graphs consist of four parts. nis a set of nodes
that represent all task-executions that appeared in that instance. the labeling
function lis a function that maps the task executions in nonto tasks that were
speciﬁed in the information system. note that there can be multiple executions
of the same task, which means that several elements of nwill be mapped onto
the same element in t. also, not all elements of tneed to be mapped, i.e. not all
tasks have to appear in a process instance. using a set of edges e, we represent
causal relations between task executions, i.e. an edge represents the fact that
tasks appeared as a result of the execution of another task. finally, there are
three properties that an instance graph has to adhere to:
1. there cannot be any cycles in the graph. a cycle would mean that a task
instance is performed more than once. however, this is impossible, sinceit would be the taskthat is executed twice, resulting in two instances or
executions , and thus, two nodes in the instance graph with the same label.
2. if there is an edge between two nodes, there cannot be another path between
these nodes. the reason for this is that an edge represents a direct causal
relation. if task awould cause task bto execute and task bwould cause task
cto be executed, then there is already a causal relation between aandcand
the edge ( a,c) would be irrelevant.
3. two executions of the same task cannot appear unrelated. there must be
a direct or indirect causal dependency between the two. this property is
necessary for the aggregation process and realistic in practice where multiple
executions of the same task typically result from a loop.figure 5 shows a collection of three instance graphs, where the nodes are rep-
resented by their labels. note that we use an abstract example rather than reallife instance graphs such as the ones shown in ﬁgures 3 and 4.
abd
ce abd
cfabd
cgh
ibd
ce
(b) (c)(a)
fig. 5. example set of instance graphs.
as we stated before, the labeling function lprovides the actual task that
belongs to a task execution. for our convenience we deﬁne the same labelingfunction on a set of task executions.
deﬁnition 2.5. (label set) letig=(n,e,t,l ) be an instance graph. for
s⊆nwe deﬁne l(s)=/uniontext
s∈s{l(s)}.
we have now deﬁned how a process instance can be described by an instance
graph. these instance graphs have an interesting property with respect to the
labeling function. these properties will be used later in the aggregation process.
property 2.6. (instance graph properties) letig=(n,e,t,l )b ea n
instance graph. for n∈n:
–|n•|=|l(n•)|, i.e. all nodes in a postset have diﬀerent labels.
–|•n|=|l(•n)|, i.e. all nodes in a preset have diﬀerent labels
proof. from the deﬁnition of a label set, it is obvious that |n•|≥| l(n•)|.i t
remains to be proven that |n•|/negationslash>|l(n•)|. assume that |n•|>|l(n•)|. then
there exists a m1,m2∈n•such that l(m1)=l(m2). from deﬁnition 2.4 we
know that there must exist a path /angbracketleftm1,...,m 2/angbracketrightinig(or the other way around,
for which the proof is symmetrical). since m1∈n•there also exists a path
/angbracketleftn,m 1,...,m 2/angbracketright. however, since ( n,m 2)∈ethis violates the sixth requirement
in deﬁnition 2.4. therefore, |n•|=|l(n•)|.f o r |•n|=|l(•(n)|a similar proof
holds. 2
in this section, we have described a formalism to describe process instances
in terms of instance graphs. when deploying a system like aris ppm [15],
this would be the ﬁrst step of the implementation phase. using these instances,already basic performance metrics could be calculated. however, in this paper
we are interested in the process of aggregating process instances. therefore, we
will show a way to generate a description of a whole process using an algorithmto aggregate a set of instance graphs.
3 aggregation
in the previous section, we described the result of the ﬁrst phase (or phases) inmulti-phase process mining. this result can be obtained using tools like arisppm (ids scheer, [15]) or inconcert (tibco), or by applying our algorithm
presented in [11] to a simple event log. however, we like to point out again,that we do not limit the aggregation algorithm to any speciﬁc way of generating
instance graphs, as long as deﬁnition 2.4 is followed.
in this section, we look at the the ﬁnal phase. this phase consists of aggre-
gating a set of instance graphs. this aggregation allows us to ﬁnd a description
of a set of instances, instead of just one instance. the reason for doing that is
twofold. first, it can be of help when monitoring performance. for example itcould be possible to give a model for all cases that involved a certain amount of
people. this could be useful to indicate whether the amount of people involved
inﬂuences the throughput time. on the other hand, using the same technique, itis possible to generate a description of all instances, which is the goal in process
mining in general.
since an instance graph shows causal relations between executions of tasks,
and an aggregation graph will show relations between the tasks themselves ,w e
need to take an intermediate step, by deﬁning a projection graph for each in-stance. then, we will make an aggregation over these projections.
3.1 instance graph projections
the ﬁrst step in the aggregation process is projecting task executions in instance
graphs onto tasks. formally, an instance graph is projected onto its label setand the result is a new graph, where each task that was executed in the process
instance is represented by a single node. note the diﬀerence between a node
for each task-execution in an instance graph and a node for each task that was
executed in a projection graph. furthermore, in the projection we introduce a
ﬁctive startnode and a ﬁctive ﬁnalnode.
deﬁnition 3.1. (instance graph projection) letig=(n,e,t,l )b ea n
instance graph. we deﬁne π(ig)=(n
/prime,e/prime,t,l/prime) as the projection of this in-
stance graph onto tsuch that:
–n/prime=t∪{ts,tf}is the set of nodes, where {ts,tf}∩t=∅∧ts/negationslash=tf.
–e/prime={(l(a),l(b))|(a,b)∈e}∪
{(ts,l(b))|b∈n∧ig•b=∅}∪
{(l(a),tf)|a∈n∧aig•=∅}is the set of edges.
–l/prime:n/prime∪e/prime→in where
- for all a∈twe deﬁne l/prime(a)=# a/prime∈n(l(a/prime)=a)
-l/prime(ts)=l/prime(tf)=1
- for all ( ts,b)∈e/primewe deﬁne l/prime((ts,b)) = 1
- for all ( a,tf)∈e/primewe deﬁne l/prime((a,tf)) = 1
- for all ( a,b)∈e/primesuch that a/negationslash=ts∧b/negationslash=tf, we deﬁne
l/prime((a,b)) = # (a/prime,b/prime)∈e(l(a/prime)=a∧l(b/prime)=b)
in deﬁnition 3.1 we build an instance graph in such a way that all nodes are
now elements of the set of tasks, or one of the ﬁctive nodes. furthermore, edges
are constructed in such a way that if two task executions were connected in theinstance graph then the tasks are connected in the projection. finally, for each
task execution that was not preceded or succeeded by any other execution therenow is an edge connecting the task to the start or ﬁnal node respectively. the
result is a graph where each node lies on a path from the start node to the ﬁnal
node. furthermore, we introduced a labeling function l
/primethat gives the number
of times a task was executed (or an edge was taken) in an instance. figure 6
shows the instance projections of the four instances of figure 5.
abd
ce 11
11
1 1 11
11tf11 ts1
1
(b)
abd
cf 11
11
1 1 11
11tf11 ts1
1
(c)abd
c g12
2
h
ie
1 22
21
1
1
11
1
1
1
1
11
1ts1
1tf11
(a)
fig. 6. set of instance projections.
let us now consider some interesting properties of instance projections and
investigate their relations with instance graphs. the ﬁrst property shows that
when making a projection graph, no causality information is lost. in other words,
each path that is present in an instance graph is also present in a projection, ifwe look at the tasks and not their individual executions.
property 3.2. (projection preserves paths) letig=(n,e,t,l )b ea n
instance graph and let π(ig)=(n
/prime,e/prime,t,l/prime) be the projection of this instance
graph. let {n1,..., n k}⊆nsuch that /angbracketleftn1,...,n k/angbracketrightis a path in ig. we show
that{n/prime|∃1≤i≤kl(ni)=n/prime}⊆n/primeand/angbracketleftl(n1),...,l (nk)/angbracketrightis a path in π(ig).
(note that k≥2.)
proof. follows directly from deﬁnition 3.1. it is trivial to see that all nodes in
the path are respected by the projection. therefore, we can suﬃce by proving
that all the edges from the original path are in the instance projection. assume1≤i<k. from the deﬁnition of a path we know that ( n
i,ni+1) is an edge, such
that (ni,ni+1)∈e. from the deﬁnition of the projection function, we know that
if (ni,ni+1)∈ethen ( l(ni),l(ni+1))∈e/prime. since this holds for all isuch that
1≤i<k, we have shown that /angbracketleftl(n1),...,l (nk)/angbracketrightis indeed a path in π(ig).2
property 3.2 shows that each path in an instance is still present in its projec-
tion. for an instance graph, we know that every time a node has two outgoing
or incoming edges, this represents a parallel split or join respectively. there areno choices, since each node represents a task execution and not a task. clearly
this no longer holds for projection graphs where nodes represent tasks and not
individual executions. therefore, when making an instance graph projection, weloose explicit information about parallelism. however, we show that we do not
loose too much information, i.e. multi-choices and true parallelism is still visible
in a projection graph.in property 3.3, we give some properties of the labeling function l/prime.t h e
labeling function of an instance graph projection represents the number of timesa task is executed in an instance. furthermore, it shows how often causality
relations caused the execution of a task. for these labels, we again derive some
interesting properties that we need in the aggregation process.
property 3.3. (label properties) letig=(n,e,t,l ) be an instance graph
and let π(ig)=(n
/prime,e/prime,t,l/prime) be the projection of this instance graph.
–∀(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))≤l/prime(n/prime), i.e. the labels of all outgoing edges at a node
are less or equal to the label of the node.
–∀n/prime∈n/prime/parenleftbig/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))/parenrightbig
≥l/prime(n/prime), i.e. the sum over the labels of all
outgoing edges at a node is greater or equal to the label of the node.
–∀(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))≤l/prime(m/prime), i.e. the labels of all incoming edges at a node
are less or equal to the label of the node.
–∀n/prime∈n/prime/parenleftbig/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))/parenrightbig
≥l/prime(m/prime), i.e. the sum over the labels of all
incoming edges at a node is greater or equal to the label of the node.
proof. let us ﬁrst consider the ﬁrst property. assume that the opposite holds,
i.e. there exists an ( n/prime,m/prime)∈e/primesuch that l/prime((n/prime,m/prime))>l/prime(n/prime). we will show
that this leads to a contradiction. if n/prime=ts(orm/prime=tf), then it is easy to
ﬁnd this contradiction because l/prime(n/prime) = 1 (or l/prime(m/prime) = 1) and l/prime((n/prime,m/prime)) = 1.
therefore, we may assume that n/prime/negationslash=tsandm/prime/negationslash=tf. using deﬁnition 3.1
we know that l/prime((n/prime,m/prime)) = # (n,m)∈e(l(n)=n/prime∧l(m)=m/prime). the assump-
tionl/prime((n/prime,m/prime))>l/prime(n/prime) can only hold if ∃m1,m2∈n(l(m1)=l(m2)=m/prime∧
(n,m 1)∈e∧(n,m 2)∈e). however, this violates property 2.6. therefore,
∀(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))≤l/prime(n/prime).
let us now consider the second property. assume that the opposite holds,
i.e. there exists an n/prime∈n/primesuch that/parenleftbig/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))/parenrightbig
<l/prime(n/prime). again
we will derive a contradiction. let q={n∈n|l(n)=n/prime}. from deﬁnition 3.1
we know that |q|=l/prime(n/prime). we can partition qinto two subsets q1andq2, such
thatq1={n∈q||nig•|=0}andq2={n∈q||nig•|>0}. it is clear
thatq1∩q2=∅andq=q1∪q2. we can now express a lower bound on/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime)) based on the cardinalities of q1andq2. from deﬁni-
tion 3.1 we know that for all elements q1∈q1there exists ( l(q1),tf)∈e/primesuch
thatl/prime((l(q1),tf)) = 1. furthermore, for all elements q2∈q2there exists at least
onem∈q2ig•such that ( l(q2),l(m))∈e/prime. note that therefore l/prime((l(q2),l(m)))≥
1. since q1∩q2=∅, we know that/parenleftbig/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))/parenrightbig
≥|q1|+|q2|.
however, we know that |q1|+|q2|=|q|=l/prime(n/prime). therefore we have shown that/parenleftbig/summationtext
(n/prime,m/prime)∈e/primel/prime((n/prime,m/prime))/parenrightbig
≥l/prime(n/prime)
the remaining two properties can be proven in a similar way. 2
using the properties from property 3.3, we derive three properties that show
that the type of branching at a task can still be derived from a projection graph.these properties will be used in section 4 in order to determine which types of
connectors should be used in the translation to an epc.
in property 3.4 we show that if one task execution in an instance graph never
directly precedes more than one other task execution in the same graph, then
this has to be an exclusive choice.
property 3.4. (exclusive choices can be found in projections) letig=
(n,e,t,l ) be an instance graph and let π(ig)=(n/prime,e/prime,t,l/prime) be the projection
of this instance graph. for all n∈nsuch that |nig•|= 1 with l(n)=n/primeand
∀m∈n∧l(m)=n/prime(|mig•|= 1) holds that/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime((n/prime,m/prime))/parenrightbig
=l/prime(n/prime).
proof. letn∈nbe such that |nig•|= 1 with l(n)=n/primeand∀m∈n∧l(m)=n/prime
(|mig•|= 1). from deﬁnition 3.1, we know that l/prime(n/prime)=# m∈nl(m)=n/prime.
letnout={m∈n|∃(a,m)∈el(a)=n/prime}. since ∀m∈n∧l(m)=n/prime(|mig•|= 1),
we know that |nout|=l/prime(n/prime). for all ( n/prime,m/prime)∈e/prime, we know that l/prime((n/prime,m/prime)) =
#(n,m)∈noutl(m)=m/prime. obviously, this implies that/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime((n/prime,m/prime))/parenrightbig
=
l/prime(n/prime).
2
in property 3.5 we show that if the execution of a task sometimes directly
precedes the execution of more than one other task, then this is still visible in
the projection graph.
property 3.5. (multi-choices can be found in projections) letig=
(n,e,t,l ) be an instance graph and let π(ig)=(n/prime,e/prime,t,l/prime) be the projection
of this instance graph. for all n∈nsuch that |nig•|>1a n d l(n)=n/primeholds
that/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime((n/prime,m/prime))/parenrightbig
>l/prime(n/prime).
proof. letn∈nbe a node such that |nig•|>1a n d n/prime=l(n). ifnis the only
node in the instance graph with label n/primethen the property holds, since l/prime(n/prime)=1
and/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime(n/prime,m/prime)/parenrightbig
=|nig•|by deﬁnition.
if there exist other nodes with label n/primethen we partition them into two sets:
n1={n1∈n|l(n1)=n/prime∧|n1ig•|>0}andn2={n1∈n|l(n1)=n/prime∧|n1ig•
|=0}. note that n∈n1. since n1∩n2=∅, we know by the deﬁnition of the
projection that l/prime(n/prime)=|n1|+|n2|. furthermore, from that same deﬁnition,
we know that/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime(n/prime,m/prime)/parenrightbig
=/summationtext
n1∈n1(|n1ig•|)+/summationtext
n2∈n2(1). the
second term here comes from the fact that the nodes in n2are ﬁnal nodes.
therefore, in the projection they get exactly one outgoing edge to tf. since we
know that |n1ig•|>0f o r n1∈n1and|nig•|>1, we can conclude that/summationtext
n1∈n1(|n1ig•|)>|n1|. hence, we deduce that/parenleftbig/summationtext
m/prime∈n/primeπ(ig)•l/prime(n/prime,m/prime)/parenrightbig
>
|n1|+|n2|=l/prime(n/prime). 2
the ﬁnal property is stronger. we show that if a certain task execution always
directly precedes the execution of the same set of other tasks, then this remains
visible in the instance graph projection.property 3.6. (true parallelism can be found in projections) letig=
(n,e,t,l ) be an instance graph and let π(ig)=(n/prime,e/prime,t,l/prime) be the projec-
tion of this instance graph. for all n/prime∈n/prime:∀
m/prime∈n/primeπ(ig)•l/prime((n/prime,m/prime)) =l/prime(n/prime)⇒
(∀n∈n
l(n)=n/primel(nig•)=n/primeπ(ig)
•)∨{tf}=n/primeπ(ig)
•.
proof. for the proof we have to consider three cases. in each case we assume
that the left hand side of the implication holds and prove that the right hand
side also holds.
–assume n/prime=ts. since there does not exists an n∈nsuch that l(n)=n/prime
the property holds.
–assume tf∈n/primeπ(ig)
•. since from deﬁnition 3.1, we know that l/prime((n/prime,tf)) = 1.
hence, l/prime(n/prime) = 1. therefore, there is only one n∈nsuch that l(n)=n/prime.
this and ( n/prime,tf)∈e/primeimplies ∀m∈n(n,m)/negationslash∈e. from this we can conclude
that{tf}=n/primeπ(ig)
•and the property holds.
–assume that n/prime/negationslash=tsandtf/negationslash∈n/primeπ(ig)
•. we assume that there exists a n∈n
such that l(n)=n/primeandl(nig•)/negationslash=n/primeπ(ig)
•and show a contradiction. assume
m∈n,m/negationslash∈nig•,l(m)=m/primeandm/prime∈n/primeπ(ig)
•. since l/prime((n/prime,m/prime)) =l/prime(n/prime),
we know from deﬁnition 3.1 we know that there must exist three nodes
n1,m1,m2∈nsuch that l(n1)=n/primeandl(m1)=l(m2)=m/primeand (n1,m1)∈
eand (n1,m2)∈e. since l(m1)=l(m2), we know that there exists a path
/angbracketleftm1,...,m 2/angbracketright(or the other way around). furthermore, /angbracketleftn1,m2/angbracketrightis a path
fromn1tom2. however, combining the two violates the sixth requirement in
deﬁnition 2.4 leading to contradiction. therefore, ∀n∈n
l(n)=n/primel(nig•)=n/primeπ(ig)
•.
2
note that properties 3.4 through 3.6 also hold for their symmetrical counter-
parts, i.e., considering input sets rather than output sets.
3.2 aggregating projections
in section 3.1, we transformed an instance graph into an instance graph pro-
jection. this is an important ﬁrst step in the aggregation process, since we can
aggregate two instance projections, while we cannot aggregate instance graphs.
furthermore, we have derived properties for instance graph projections with re-spect to the labels of nodes and edges. these properties will prove essential in
the process of translating the aggregation graph to an epc. in this section, we
give an algorithm to generate an aggregation graph . this graph is a summation
over a set of instance graph projections. therefore, the set of nodes is simply
the union set of all instance graph projections.
deﬁnition 3.7. (aggregation graph) lettbe a set of tasks and let sbe
a set of instance graphs over t.l e t πbe a function giving instance graph
projections. we deﬁne α(s)=(n
s,es,ls) to be the aggregation graph over s
such that:–ns=/uniontext
ig∈s
π(ig)=(n,e,t,l )n, i.e. the set of nodes.
–es=/uniontext
ig∈s
π(ig)=(n,e,t,l )e, i.e. the set of edges.
–for all n∈ns∪eswe deﬁne ls(n)=/summationtext
ig∈s
π(ig)=(n,e,t,l )l(n), where we
assume that l(n)=0i f n/negationslash∈n∪e.
in essence, the aggregation graph is the straightforward sum over a set of instance
graph projections. note that each instance projection contains the start nodet
sand the ﬁnal node tf. therefore, the aggregation graph also contains these
unique nodes tsandtfin such a way that tsis the only source node and tfis
the only sink node. the labels represent the number of times a task is executed
or a causal relation is present in some instance graph.
abd
c
g34
4
h
ie3 44
42
1
1
11
1
21
1
11
1ts3
3
tf32f
1 12
fig. 7. labelled aggregation graph.
figure 7 shows the resulting aggregation graph after aggregating the instance
graph projections of the example in figure 6.
now we extend some of the results for projections to aggregation graphs (cf.
properties 3.3 through 3.6). note that the labels in the aggregation graphs will
later serve as a basis for the conversion of an aggregation graph into an epc.
using these properties, we will show that no information is lost in the aggregationprocess.
property 3.8. (label properties) lettbe a set of tasks and sis a set of
instance graphs over t.α(s)=(n
s,es,ls) is the aggregation graph over s.
–∀(n/prime,m/prime)∈esls((n/prime,m/prime))≤ls(n/prime), i.e. the labels of all outgoing edges at a node
are less or equal to the label of the node.
–∀n/prime∈ns/parenleftbig/summationtext
(n/prime,m/prime)∈esls((n/prime,m/prime))/parenrightbig
≥ls(n/prime), i.e. the sum over the labels of
all outgoing edges at a node is greater or equal to the label of the node.
–∀(n/prime,m/prime)∈esls((n/prime,m/prime))≤ls(m/prime), i.e. the labels of all incoming edges at a
node are less or equal to the label of the node.
–∀n/prime∈ns/parenleftbig/summationtext
(n/prime,m/prime)∈esls((n/prime,m/prime))/parenrightbig
≥ls(m/prime), i.e. the sum over the labels of
all incoming edges at a node is greater or equal to the label of the node.
proof. proving these properties can be done by using property 3.3 and simple
induction over s. 2similar to property 3.2 we show that every path in some instance graph is
still a path in the aggregation graph. this property reﬂects the fact that theresulting graph actually represents each instance graph.
property 3.9. (aggregation preserves paths) lettbe a set of tasks and
sis a set of instance graphs over t.α(s)=(n
s,es,ls) is the aggregation
graph over s. for all ig=(n,e,t,l )∈sand{n1,...,n k}⊆nsuch that
/angbracketleftn1,...,n k/angbracketrightis a path in ig:{n/prime|∃1≤i≤kl(ni)=n/prime}⊆nsand/angbracketleftl(n1),...,l (nk)/angbracketright
is a path in α(s).
proof. follows directly from property 3.2 and deﬁnition 3.7. from property 3.2
we know that if {n1,...,n k}⊆nsuch that /angbracketleftn1,...,n k/angbracketrightis a path in some
instance graph ig∈sthen/angbracketleftl(n1),...,l (nk)/angbracketrightis a path in π(ig)=(n/prime,e/prime,t,l/prime)
and{n/prime|∃1≤i≤kl(ni)=n/prime}⊆n/prime. from the deﬁnition of aggregation we know
thatn/prime⊆nsande/prime⊆es. therefore we know that {n/prime|∃1≤i≤kl(ni)=n/prime}⊆
nsand/angbracketleftl(n1),...,l (nk)/angbracketrightis a path in α(s). 2
similar to instance graph projections, we show that in an aggregation graph
it is possible to ﬁnd the type of branching at a node. for this, we introduce threeproperties, similar the properties 3.4 through 3.6. first, we show the aggregative
counterpart of property 3.4, i.e. exclusive choices can be found in aggregation
graphs.
property 3.10. (exclusive choices can be found) lettbe a set of tasks and
sis a set of instance graphs over t.α(s)=(n
s,es,ls) is the aggregation graph
overs. if for some node ns∈nsholds that/summationtext
m∈nsα(s)•ls((ns,m)) =ls(ns)
then for all elements ig∈s, where ig=(n,e,t,l ) holds that
∀n∈n
l(n)=ns|nig•|≤1.
proof. ifns=tsthen the property holds, because ts/negationslash∈l(n). therefore,
assume ns/negationslash=ts. furthermore, assume that there exists a ig∈s, where
ig=(n,e,t,l )a n d n∈nwithl(n)=ns, such that |nig•|>1. we prove
by contradiction that this is not possible. π(ig)=(n/prime,e/prime,t,l/prime) is the projec-
tion of ig. from property 3.5 we know that/summationtext
m∈nsπ(ig)•l/prime((ns,m))>l/prime(ns).
furthermore, from property 3.3 we know that for all instance graphs ig/prime,/summationtext
m∈nsπ(ig/prime)•l/prime((ns,m))≥l/prime(ns). using deﬁnition 3.7 we can now conclude
that/summationtext
m∈nsα(s)•ls((ns,m))>ls(ns). this yields contradiction. 2
besides exclusive choices, it is possible to ﬁnd true parallelism as well. prop-
erty 3.11 shows this for the aggregation graph, similar to property 3.6 for pro-
jection graphs.
property 3.11. (true parallelism can be found) lettbe a set of tasks
andsis a set of instance graphs over t.α(s)=( ns,es,ls) is the aggre-
gation graph over s. for all n/prime∈nsandig∈s, where ig=(n,e,t,l ):/parenleftbig
∀
m/prime∈n/primeα(s)•ls((n/prime,m/prime)) =ls(n/prime)/parenrightbig
⇒/parenleftbigg/parenleftbig
∀n∈n
l(n)=n/primel(nig•)=n/primeα(s)
•/parenrightbig
∨{tf}=n/primeα(s)
•/parenrightbigg
.proof. we prove this property by induction over the number of instance graphs
ins. assume that scontains only one instance graph ig. since α(s)=π(ig)
in that case, we have proven in property 3.6 that this property holds. assume
that we have a set of instances ssuch that for α(s) the property holds. we will
show that adding one instance ig=(n,e,t,l )t os, generating a new set s/prime,
does not violate the property, i.e., we need to prove that the property holds for
s/prime=s∪{ig}assuming that it holds for s. consider an n/prime∈ns/prime.i fn/prime/negationslash∈ns,
thenn/prime∈l(n)a n d igis the ﬁrst instance graph containing n/prime. hence we can
apply property 3.6. if n/prime∈ns, we need to consider two cases:
1. the left-hand side of the implication, i.e., ∀
m/prime∈n/primeα(s)•ls((n/prime,m/prime)) = ls(n/prime)
holds for s.i fn/prime/negationslash∈l(n), it is easily seen that the property is not violated.
therefore, assume n/prime∈l(n). adding instance igtoscan have two re-
sults. first, ∀
m/prime∈n/primeα(s/prime)•ls((n/prime,m/prime)) =ls(n/prime) holds. in this case, we know that
n/primeα(s)
•=n/primeπ(ig)
•and∀
m/prime∈n/primeπ(ig)•l/prime((n/prime,m/prime)) =l/prime(n/prime) holds. property 3.6 shows
that therefore,/parenleftbig
∀n∈n
l(n)=n/primel(nig•)=n/primeα(s)
•/parenrightbig
∨{tf}=n/primeα(s)
•holds for ig.
combining our assumptions we can conclude that the right hand side of the
implication still holds for all instances. second, ∀
m/prime∈n/primeα(s/prime)•l/prime((n/prime,m/prime)) =l/prime(n/prime)
does not hold. this is a trivial case, since now the implication still holds.
2. the left-hand side of the implication does not hold of s. this can only be
the case if there is some m/prime∈ns, such that ls((n/prime,m/prime))<ls(n/prime). using
property 3.3 it is easily seen that adding an instance will never result inl
s((n/prime,m/prime)) =ls(n/prime). therefore, the implication still holds.
this concludes the proof by induction. 2
note that for instance graph projections, we also deﬁned the multi-choice as
a branching type (recall property 3.5). obviously, this is the case when the type
of branching is neither an exclusive choice, nor a parallel split. therefore, thereis no need to derive this property for aggregation graphs separately. note that
properties 3.10 and 3.11 also hold for their symmetric counter parts (input sets
rather than output sets).
after aggregating a set of instance graphs into an aggregation graph the
result has to be visualized. although the aggregation graph as shown in figure 7contains all the information needed, it is still hard for a human to understand.
therefore, we translate the graph into a format that is more intuitive. the
modeling language we use here is called event driven process chains (epcs).
the choice for epcs is based on the fact that it is a well known concept, and it
allows for all necessary routing constructs.
4 transformation into epcs
epcs are an intuitive modeling language to model business processes introduced
by keller, n¨ uttgens and scheer in 1992 [16]. the language was initially notintended to be a formal speciﬁcation of a business process [3]. an epc consists
of three main elements. combined, these elements deﬁne the ﬂow of a businessprocess as a chain of events. the elements used are:
functions
the basic building blocks are functions. a function corresponds to an activity
(task, process step) which needs to be executed.
events
events describe the situation before and/or after a function is executed.
functions are linked by events.
connectors
connectors can be used to connect functions and events. this way, the ﬂow
of control is speciﬁed. there are three types of connectors: ∧(and), ×(xor)
and∨(or).
functions, events and connectors can be connected with edges in such a way
that the following rules apply:
–events have at most one incoming edge and at most one outgoing edge.
–functions have precisely one incoming edge and precisely one outgoing edge.
–connectors have either one incoming edge and multiple outgoing edges, or
multiple incoming edges and one outgoing edge.
–in every path, functions and events alternate. no two functions are connected
and no two events are connected, not even when there are connectors in
between.
in this section, we will transform an aggregation graph as deﬁned in deﬁni-
tion 3.7 into an epc. in the labelled aggregation graph, the labels of the nodes
represent the number of times a task is executed in the log. the labels of theedges represent the number of times an edge is taken in some instance. it is
easily seen that there are three possibilities for the incoming as well as for the
outgoing edges of a node.
1. the sumover the labels of all incoming (outgoing) edges of some node equals
the label of the node. (recall property 3.10)
2.allthe labels of allincoming (outgoing) edges of some node equal the label
of the node. (recall property 3.11)
3.not all the labels of all incoming (outgoing) edges of some node equal the
label of the node, and the sumover the labels is greater than the label of
the node.
we use these three points to determine the type of connectors we use in the
transformation process to epcs. these points are symmetrical for ingoing and
outgoing edges at all nodes. therefore, if we talk about incoming edges, we alsomean the symmetrical case for outgoing edges. using property 3.10 and prop-
erty 3.11, transforming an aggregation graph into an epc is straightforward and
we only give a sketch of the translation algorithm.deﬁnition 4.1. (translation to epc) letsbe a set of instance graphs and
letag=(ns,es,ls) be the labelled aggregation graph over s. we deﬁne the
aggregated epc epc =(fepc,eepc,cepc,aepc,lepc) in such a way that:
–fepc=ns\{tf}is the set of functions,
–eepc={en|n∈ns}is the set of events,
–cepcis the set of connectors,
–aepcis the set of edges,
–lepc:cepc→{and,xor,or }is a function typifying the connectors.
the construction of the set of connectors, the set of edges and the labeling
function of this epc is deﬁned in figure 8.
et
tsts,y
z1zm...
c2
...et tf,yx1xn...
c1...
fs
ea
aayx1xn
z1zm...
...
c2c1...
...–if
/c8n
i=1(xi)=ythenc1=xor,
–if∀n
i=1(xi)=ythenc1=and ,
–elsec1=or.
–if
/c8m
i=1(zi)=ythenc2=xor,
–if∀m
i=1(zi)=ythenc2=and ,
–elsec2=or.
fig. 8. transformation rules from graph to epc (top:start/ﬁnal nodes, bottom: “nor-
mal” nodes).
figure 8 deﬁnes the transformation of the aggregation graph into an epc. these
rules are rather straightforward. first, each node nfrom the aggregation graph
is translated into a combination of an event enand a function nand an edge
is added in between. then, the incoming and outgoing edges at all nodes are
transformed into connectors. note that for connectors that have only one ingoingor outgoing arc, the type is ambiguous, since both andand xorcan be applied.
therefore, we remove all connectors that have only one ingoing and one outgoing
edge, and replace them with a normal edge. for the initial and ﬁnal nodes t
s
andtf, special rules are made. in figure 9 the result of this procedure is shown
for the aggregation graph of figure 7.
an important property of the resulting epc is that it is indeed capable of
reproducing all original instance graphs. this can easily be seen from the fact
that an epc is merely a syntactically diﬀerent representation of a labelled ag-
gregation graph. in property 3.9 we have show that each path in an instanceets
ts
b
c dh i
g
etfe feb
ehei
eced
eg
eeefaea
fig. 9. aggregated epc.
graph is also a path in an aggregation graph. therefore, it is also a path in an
aggregated epc. in properties 3.10 and 3.11 we have shown that the types of
splits and joins can be found in an aggregation graph. based on these properties,
the transformation into an epc is made. therefore, it is clear that for the ag-gregated epc the same properties hold. all the instance graphs that we started
with in the ﬁrst place are executions of the epc. however, the epc can allow
for more behavior, especially when or-connectors are used.
even though we have shown that the aggregated epc does represent all
instances it is still not the best result possible with this approach. the reason
for this is the fact that or-connectors appear in the epc. using the original
set of instances, it is possible that we can be more speciﬁc with respect to these
connectors. in order to be able to express this, we will use petri nets. in section 5
we will ﬁrst introduce a naive translation algorithm. then, in section 6 we willrestrict the behavior of the petri net generated to the original set of instance
graphs.
5 transformation into petri nets
in this section, we will transform an aggregated epc as deﬁned in deﬁnition 4.1
into a petri net. the translation will be naive, which means that we translateor-connectors into a large set of transitions. the result of this transformation
process will be a petri net with two types of transitions. the ﬁrst type of transi-
tions is formed by the so-called visible transitions. these transitions correspondthe functions in the original epc. the second type of transitions is formed by
the set of invisible transitions. these transitions correspond to connectors in theepc. we use a variant of the classic petri-net model, namely place/transition
nets. for an elaborate introduction to petri nets, the reader is referred to [10,
19, 20]. in this section, we will not consider soundness [1, 8] of the petri net.however, in section 6 we will show that it is easy to prove that the restricted
petri net is relaxed sound [8].
now we present a sketch of the actual transformation from an epc into a
petri net. just as for the translation of the aggregation graph onto the aggregated
epc, the translation of the epc onto the petri net is straightforward. note
that we do not consider subtle semantical problems of epcs as discussed in [3].instead we use the more pragmatic approach described in [8].
to explicitly state the diﬀerence between transitions that correspond to func-
tions and transitions that correspond to connectors, we will split up the set of
transitions tintot
v(visible transitions) and tiv(invisible transitions). how-
ever, the resulting net can be interpreted as an ordinary place/transition net(p,t
v∪tiv,f).
deﬁnition 5.1. (sketch of transformation algorithm)
letepc =(fepc,eepc,cepc,aepc,lepc) be an epc. we deﬁne the
petri net transformation of this epc as pn=(p,tv∪tiv,f). the construction
of this petri net is done in the following way:2
1. remove all events from the epc except etsandetf, and rebuild arcs.
for all events e∈e\{ets,etf}we ﬁnd n1,n2∈fepc∪cepcsuch
that{(n1,e),(e,n2)}⊆aepcand we change aepcin the following way:
aepc:= (aepc∪{(n1,n2)})\{(n1,e),(e,n2)}.
2. create a visible transition for each function except the function ts.tv:=
fepc\{ts}.
3. create an invisible transition for the function ts.tiv:={ts}.
4. create a place for each arc. p:={pa|a∈aepc}. note that here aepcis
the set created after the changes in the ﬁrst step.
5. for each andconnector in the epc, create an invisible transition. tiv:=
tiv∪{tc|c∈cepc∧lepc(c)=and}.
6. for each xorconnector in the epc, create a number of invisible transitions.
tiv:=tiv∪{tc,a,b|c∈cepc∧lepc(c)=xor∧(a,c)∈aepc∧(c,b)∈
aepc}.
7. for each orconnector in the epc, create a number of invisible transitions.
tiv:=tiv∪{tc,v,w |c∈cepc∧lepc(c)=or∧v⊆{a|(a,c)∈aepc}∧
v/negationslash=∅∧w⊆{b|(c,b)∈aepc}∧w/negationslash=∅}.
8. update all connections, i.e., construct fbased on the set of places p, the set
of transitions tv∪tivand the original connections in aepc. (a complete
formalization of the algorithm is beyond the scope of this paper.)
2note that in this paper we only give a sketch of the algorithm. note that the full
algorithm has been implemented in the prom framework described in section 7.the sketch of the algorithm presented in deﬁnition 5.1 shows the intuition be-
hind the translation. events are removed from the model since they were artiﬁ-cially added in the transformation from an instance graph to an epc and do not
provide information. this does not hold for the initial and ﬁnal event, since they
are transformed into places. functions are transformed into visible transitionsand these transitions are connected through places. an exception is made for
the function t
s. this function is translated into a invisible transition, since it
does not represent a task in the log ﬁle. furthermore, it is easily seen that theresulting petri net has exactly one place with no incoming arcs and exactly one
place without outgoing arcs.
the petri net we now have generated will allow for all instances to execute
for the same reasons the epc does. however, it allows for more behavior thanjust these instances. the reason for this is in the orsplit and join connectors. an
orsplit (join) with koutputs (inputs) allows for 2
k−1 transitions but not every
transition will be possible. moreover, speciﬁc splits will need to be matched tospeciﬁc joins. therefore, in section 6, we will restrict the behavior of the net
to the set of instance graphs it was generated from, by removing some invisible
transitions.
6 restricting petri nets to instances
in this section, we will restrict the behavior of an aggregated petri net by looking
at the instances it was generated from. these instances are mapped onto the
petri net by playing the “token game”. for each invisible transition is stored,whether it had to be ﬁred in any of the instances. if this isn’t the case, it will be
removed. in order to decide whether an invisible transition should be removed,
we need to deﬁne the in- and out-sets of invisible transitions. these sets representtheand-join/split that a transition represents.
deﬁnition 6.1. (in/out sets) letpn=(p,t
v∪tiv,f) be a petri net with
visible and invisible transitions. we deﬁne in:tiv→p(tv) as the function
giving the in-set and out:tiv→p(tv) as a function giving the out-set of an
invisible transition, where (note the recursion/ﬁxpoint)
–in(tiv): ={t∈tv|t•∪•tiv/negationslash=∅} ∪/uniontext
t/prime∈tiv
t/prime•∪•tiv/negationslash=∅in(t/prime)
–out(tiv): ={t∈tv|•t∪tiv•/negationslash=∅} ∪/uniontext
t/prime∈tiv
•t/prime∪tiv•/negationslash=∅out(t/prime)
informally the in and out-set of a transition can be explained as follows. if in
some execution sequence transition tﬁres, then this means that before, all the
transitions in the in-set have ﬁred and as a result all the transitions in the out-
set will become enabled eventually. however, after the ﬁring of the transitions in
the in set and before ﬁring the transitions in the out set, there can be ﬁrings ofother invisible transitions. more about these semantics can be found in [2], where
the invisible transitions are referred to as “silent transitions”. since the invisible
transitions introduced in the conversion of an epc belong to a connector that iseither a split or a join, either the corresponding in-set or out-set has cardinality
one respectively.
using in and out sets, we can restrict the petri net.
deﬁnition 6.2. (restricted petri net) letsbe a set of instance graphs and
letepc =(fepc,eepc,cepc,aepc,lepc) be the aggregated epc over s
(deﬁnition 4.1) and let pn=(p,tv∪tiv,f) be the petri net translation of epc
(deﬁnition 5.1). we deﬁne the restricted petri net as pnr=(p,tv∪t/prime
iv,f/prime)a s
follows:
–t/prime
iv={t∈tiv|∃(n,e,t,l )∈s∃n1⊆n
l(n1)=in(t)∃n2⊆n
l(n2)=out(t)∧∀n1∈n1
n2∈n2(n1,n2)∈e},
–f/prime=f∩((p∪t/prime
iv∪tv)×(p∪t/prime
iv∪tv)).
deﬁnition 6.2 removes invisible transitions that do not appear in any instance
graph. see figure 10 for pnrbased on the running example. note that these
transitions will always be translations of or-connectors. the reason for this is
that for each andconnector, there is only one invisible transition and prop-
erty 3.11 shows that this transition is present in at least one instance. for xor
connectors, there are multiple transitions, but from property 3.10 we know that
they all appear in at least one instance. for or-connectors, it is clear that we
do not remove too many transitions. in other words, we do not introduce placeswithout input or output arcs. furthermore, by deﬁnition, every invisible transi-
tion that is not removed is ﬁred in some instance.
a bc
de
f
gh
its
fig. 10. aggregated petri net based on figure 7 restricted to the instances.
without proof we mention that the resulting petri net is relaxed sound [8],
i.e., for every transition there is a sound ﬁring sequences leading from the initial
state (token in source place) to the ﬁnal state (token in sink place). note thatthe resulting petri net is not (strongly) sound [1] because of or-joins that do not
follow or-splits. by only looking at the sound ﬁring sequences (i.e., restricting
the behavior based on relaxed soundness, cf. [8]), we get an executable semantics
for the aggregated epcs and therefore also for the aggregation graphs .t h i sw a s
exactly the goal of our multi-phase mining approach. based on event logs we
derive an executable process model.7 tool support
process mining has many applications in industry. however, for the diﬀerent
techniques to be useful in industry, good tool support is essential. the work
presented in this paper is supported by two tools. in this section, we brieﬂydiscuss both tools. the main diﬀerence between the tools is that one of them is
freely available, while the second is a commercial tool. moreover, the latter tool
focuses on performance analysis and the generation of instances rather than theconstruction of an aggregated process model and it requires deep knowledge of
the process under consideration.
7.1 the prom-framework
the prom-framework is a framework for the implementation of process mining
techniques. the tool has been developed at the technical university of eind-
hoven and is freely available from www.processmining.org . the tool provides
support for a large number of process mining plug-ins at diﬀerent levels. it con-tains for example a component for the mining of social networks. it provides a
standard way for working with diﬀerent models such as petri nets and epcs as
well as components for the automatic layout of these models. the algorithms pre-sented in this paper are available in the prom framework under the name “multi
phase mining plug-in”. figure 11 shows a screenshot of the prom-framework,
showing the same epc as figure 9, only with a diﬀerent layout.
fig. 11. the prom-framework.
 fig. 12. the aris ppm client.
7.2 aris process performance monitor
the aris process performance monitor (ppm) of ids scheer is a commercial
tool for business process monitoring. the idea behind aris ppm is very similar
to the algorithms presented in this paper. in aris ppm, every case is repre-
sented as a so-called instance-epc (cf. instance graph). these instance-epcscan be aggregated into an aggregated epc in a similar way as described here.
however, this is not the main feature of this tool and the rules used are quitediﬀerent. the main focus of aris ppm is on the analysis of the performance of
processes. it can make nice graphical representations of all kinds of properties
on a case level, but also on an aggregated level. figure 12 shows a screenshot ofthe aris ppm client.
aris ppm can be considered to be the primary motivation for the research
presented in this paper and we expect that some of the ideas presented in thispaper will be adopted by aris ppm. in fact, ids scheer is currently in the
process of adding some functionality of the prom-framework to aris ppm.
8 related work
existing approaches for mining the process perspective [4–7, 14, 18, 22] are fun-
damentally diﬀerent from the approach presented in this paper, i.e., they onlyuse one mining phase (other than things like user-assisted process mining). it is
impossible to give an overview of the work op process mining. instead we refer
to [4, 5] which present an elaborate overview of process mining literature.
for the readers familiar with petri net theory, it is important to discuss the
relation between this work and the work on regions [13] and the work on runs
[9]. process mining is quite diﬀerent from constructing a petri net on the basisof regions because our notion of completeness is much weaker than the typical
assumption when using regions (i.e., a complete transition system) [13]. for
process mining one assumes that the log contains only a fraction of the possible
behavior. furthermore, it is important to mention that instance graphs can be
seen as runs [9] also known as occurrence nets or partially ordered petri netprocesses. however, runs are typically generated from a petri net rather than
used to construct a petri net. another problem is that approaches such as the
one described in [9] typically link places in the run to places in the original petrinet. when mining event logs there is no information about places. nevertheless
it is interesting to further investigate the relations between multi-phase mining
and synthesis problems in petri nets.
as indicated in the introduction, a short version of this paper has been sub-
mitted to the international conference on conceptual modeling (er 2005) [12].
however, in [12] the formal proofs the translation to petri nets are missing.
9 conclusion
in this paper, we introduced an algorithm to aggregate a number of instancegraphs. an instance graph can be seen as the representation of an execution
of a business process for a single case. such an execution may have concurrent
paths, but cannot contain any choices. commercial products such as aris ppmshow that it is interesting to inspect instance graphs. however, at the same time
there is the desire to aggregate sets of instance graphs. in this paper, we have
deﬁned an algorithm to support this. from a set of instance graphs, we ﬁrstbuild an aggregation graph. we provided translations for this graph into the
well-known modeling language of epcs. one of the most interesting results ofour eﬀorts is that the resulting epc actually represents all instances. moreover,
we can prove that for the resulting model a deadlock-free, executable semantics
exists for the model. via the translation to epcs, we can also aggregate instancegraphs into a petri net. the translation allows for too much behavior. however,
by restricting the petri net or assuming relaxed soundness as a control semantics,
the “abundance of behavior” can be removed.
acknowledgements
the authors would like to thank ids scheer for supporting the mining research
and for providing their aris process performance monitor (aris ppm).
references
1. w.m.p. van der aalst. the application of petri nets to workﬂow management.
the journal of circuits, systems and computers , 8(1):21–66, 1998.
2. w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. genetic
process mining. in proceedings of the 26th international conference on applica-
tions and theory of petri nets (to appear) , lecture notes in computer science.
springer-verlag, berlin, 2005.
3. w.m.p. van der aalst, j. desel, and e. kindler. on the semantics of epcs: a
vicious circle. in m. n¨ uttgens and f.j. rump, editors, proceedings of the epk
2002: business process management using epcs , pages 71–80, trier, germany,
november 2002. gesellschaft f¨ ur informatik, bonn.
4. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
5. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
6. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
7. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
8. j. dehnert and w.m.p. van der aalst. bridging the gap between business models
and workﬂow speciﬁcations. international journal of cooperative information
systems , 13(3):289–332, 2004.
9. j. desel. validation of process models by construction of process nets. in w.m.p.
van der aalst, j. desel, and a. oberweis, editors, business process management:
models, techniques, and empirical studies , volume 1806 of lecture notes in com-
puter science , pages 110–128. springer-verlag, berlin, 2000.
10. j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.11. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362–376. springer-verlag, berlin, 2004.
12. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: aggre-
gating instance graphs. in submitted to er 2005 , 2005.
13. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315–368, 1989.
14. j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
15. ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
16. g. keller, m. n¨ uttgens, and a.w. scheer. semantische processmodellierung auf
der grundlage ereignisgesteuerter processketten (epk). ver¨ oﬀentlichungen des
instituts f¨ ur wirtschaftsinformatik, heft 89 (in german), university of saarland,
saarbr¨ ucken, 1992.
17. g. keller and t. teufel. sap r/3 process oriented implementation . addison-
wesley, reading ma, 1998.
18. a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workﬂow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science ,p a g e s
389–406. springer-verlag, berlin, 2003.
19. t. murata. petri nets: properties, analysis and applications. proceedings of the
ieee, 77(4):541–580, april 1989.
20. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
21. a.w. scheer. business process engineering, reference models for industrial en-
terprises . springer-verlag, berlin, 1994.
22. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.