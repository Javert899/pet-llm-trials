symbolically aligning
observed and modelled behaviour
vincent bloemen
university of twente
enschede, the netherlands
v.bloemen@utwente.nljaco van de pol
university of twente
enschede, the netherlands
j.c.vandepol@utwente.nlwil m.p. van der aalst
rwth aachen university
aachen, germany
wvdaalst@pads.rwth-aachen.de
abstract ‚Äîconformance checking is a branch of process mining
that aims to assess to what degree a given set of log traces
and a corresponding reference model conform to each other.
the state-of-the-art approach in conformance checking is based
on the concept of alignments. alignments express the observed
behaviour in terms of the reference model while minimizing the
number of mismatches between the event data and the model.
the currently known best algorithm for constructing alignments
applies the a* shortest path algorithm for each trace of event
data.
in this work, we apply insights from the Ô¨Åeld of model
checking to aid conformance checking. we investigate whether
alignments can be computed efÔ¨Åciently via symbolic reachability
with decision diagrams. we designed a symbolic algorithm for
computing shortest-paths on graphs restricted to 0- and 1-cost
edges (which is typical for alignments).
we have implemented our approach in the lts min model
checking toolset and compare its performance with the a*
implementation supported by prom. we generated more than
4000 experiments (petri net model and log trace combinations)
by setting various parameters, and analysed performance and
related these to structural properties.
our empirical study shows that the symbolic technique is in
general better suited for computing alignments on large models
than the a* approach. our approach is better performing in cases
where the size of the state-space tends to blow up. based on our
experiments we conclude that the techniques are complementary,
since there is a signiÔ¨Åcant number of cases where a* outperforms
the symbolic technique and vice versa.
index terms ‚Äîconformance checking, process mining, model
checking, symbolic reachability, alignment, algorithm, graph
search
i. i ntroduction
process mining [1] is a Ô¨Åeld of study involved with the
discovery ,conformance checking , and enhancement of pro-
cesses, using event data recorded during process execution. in
process discovery, we aim to discover models based on traces
of executed event data. in conformance checking we assess
to what degree a process model (potentially discovered) is in
line with recorded event data. finally, in process enhancement
we aim at improving or extending the process based on facts
derived from event data.
modern information systems allow us to track, often in great
detail, the behaviour of the process it supports. moreover,
instrumentation and/or program tracing tools allow us to track
this work is supported by the 3tu.bsr project.the behavioural proÔ¨Åle of the execution of enterprise-level
software systems [2], [3]. such behavioural data is often
referred to as an event log, which can be seen as a multiset
of traces, i.e., sequences of observed events in the system.
however, it is often the case, due to noise or under/over-
speciÔ¨Åcation, that the observed behaviour does not form a
correct path through the model.
conformance checking assesses to what degree the event log
and model conform to each other. early conformance checking
techniques [4] are based on simple heuristics and therefore
may yield ambiguous/unpredictable results.
alignments [5], [6] were introduced to overcome the limita-
tions of early conformance checking techniques. alignments
map observed behaviour onto behaviour described by the
process model. as such, we identify four types of relations
between the model and log in an alignment:
1) we are unable to map observed behaviour in the event
log onto the model (a log-move ).
2) an action in the underlying model is needed, yet this is
not reÔ¨Çected in the log (a model-move ).
3) a synchronous move in which both the model and the
log perform the same event.
4) a silent-move in which the model performs a silent or
invisible action (denoted with ).
consider the example given in figure 1. the petri net
represents the product of an event log ha;c;e;bi(depicted
in orange) and the model, which is portrayed in blue (model-
moves) and grey (silent-moves). the green transitions illustrate
synchronous moves. an alignment is a path from the initial
marking on the product ( p0q0 ) to the Ô¨Ånal marking ( p7q4 ),
which is given by . here, the synchronous move ja
ajis Ô¨Åred
to obtain the marking p1q1 . this is followed by a model-
move,j
bj, to obtain the marking p2p3q1 . here,denotes
theskip action to indicate that nothing happens in the log. a
silent-move is given by j
jand the last pair is the log-move
jb
j, in which the model takes no action.
an alignment is optimal if it minimizes a given cost func-
tion. in the example, is optimal for the so-called standard-
cost function, which assigns a cost of 0 to synchronous and
silent-moves, and assigns a cost of 1 to model- and log-moves.
the goal is to search for optimal alignments, which is an np-
hard problem. in practice, an optimal alignment is found bymodellog
sync
fig. 1: example petri net model (blue) combined with a log trace (orange), with synchronous actions in green. the right part
shows the standard cost function and an optimal alignment using that cost function for the model and trace.
computing the shortest path on the state-space of the product
petri net.
the state-of-the-art technique uses an a* [7] approach to
Ô¨Ånd such optimal alignments. several optimizations are used to
improve the performance of the algorithm, such as computing
the state-space on-the-Ô¨Çy. the marking equation of petri nets is
exploited to prune the search space (remove states that cannot
reach the Ô¨Ånal state any more) and the marking equation can
also be used as a good heuristic function for a* [8].
however, searching for alignments in an explicit-state fash-
ion can still take a long time for large state-spaces. in the
Ô¨Åeld of model checking, such a ‚Äòstate-space explosion‚Äô is
a common and well-studied problem [9]. one of the tech-
niques to deal with large state spaces is to employ symbolic
model checking [10]. a symbolic representation in the form
of decision diagrams is used to efÔ¨Åciently store a set of
states. this is combined with operations such as intersect,
unite, and a symbolic next-state function to explore the state-
space. especially in structured models1, symbolic reachability
is generally able to explore state-spaces that are orders of
magnitudes larger than explicit techniques are capable of [10],
[11].
to the best of our knowledge, while there exist symbolic
algorithms for computing shortest paths [12], [13], there is as
of yet no symbolic algorithm to compute alignments. since
petri nets tend to have structured state-spaces, a symbolic
solution may be well-suited for computing alignments. in this
paper we present a symbolic algorithm for computing align-
ments and compare its performance on over 4,000 experiments
that exhibit various characteristics. we show that our symbolic
algorithm is favourable for larger models when compared to
the a* approach, especially in cases where the state-space of
the petri net tends to blow up.
1with a structured model, we mean that a model state can be encoded
in compact manner, by e.g., using few variables and exploiting locality and
symmetries. this keeps the decision diagrams small, which correspondingly
reduces the memory and time usage per operation compared to an unstructured
model.a. contributions
our contributions are as follows:
we present a novel algorithm for computing alignments
and shortest-paths symbolically, which is applicable for
all uniform-cost functions (that only assign a 0 or 1 as
edge-costs).
we generated a set of 4,320 benchmark experiments
(petri net models and log trace combinations) with vary-
ing parameters such that structural properties can be
analysed.
we implemented our approach in the lts min model
checking toolset and compare its performance with the
a* implementation from the process mining tool prom
on the benchmark instances.
‚Äìwe observe that when comparing average compute
times, the symbolic algorithm signiÔ¨Åcantly outper-
forms a*.
‚Äìfor smaller models, a* computes alignments faster
than the symbolic algorithm.
‚Äìwe observe that our algorithm is especially
favourable for larger instances, where the state-space
tends to blow up (e.g., due to parallel transitions, or-
branches, and increases in activities in the petri net
model).
‚Äìwe observe that our technique is complementary to
a*, since there are cases where a* signiÔ¨Åcantly
outperforms the symbolic technique and vice versa.
b. outline
the remainder of this paper is structured as follows. in
the next section, we introduce relevant preliminaries. in sec-
tion iii we present and discuss our algorithm. details on the
implementation are provided in section iv. in section v we
discuss the experimental results. the related work is discussed
in section vi and we conclude in section vii.
ii. p reliminaries
we assume that the reader is familiar with basic results from
automata theory and petri nets. we denote a trace or sequenceby=h0;1;:::;jj 1i, two sequences are concatenated
using the operation. given a sequence and a set of elements
s, we refer to nsas the sequence without any elements
froms, e.g.,ha;b;b;c;a;finfb;fg=ha;c;ai. log traces
are sequences, for which each element is called an event and
is contained in the alphabet , also called the set of events.
we globally deÔ¨Åne the alphabet , which does not contain
the skip event () nor the invisible action or silent event ( ).
given a set s, we denote the set of all possible multisets as
b(s), and its power-set by 2s.
a. preliminaries on petri nets
deÔ¨Ånition 1 (petri net, marking) .apetri net is a tuplen=
(p;t;f;;;m0;mf)such that:
p is a Ô¨Ånite set of places ,
t is a Ô¨Ånite set of transitions such that p\t=;,
f(pt)[(tp)is a set of directed arcs, called
theÔ¨Çow relation ,
is a set of activity events, with = [fg,
:t!is alabelling function for each transition,
m02b(p)is the initial marking of the petri net,
mf2b(p)is the Ô¨Ånal marking of the petri net.
amarking is deÔ¨Åned as a multiset of places, denoting where
tokens reside in the petri net. a transition t2tcan be Ô¨Åred if,
according to the Ô¨Çow relation, all places directing to tcontain
a token. after Ô¨Åring a transition, the tokens are removed from
these places and all places having an incoming arc from t
receive a token.
deÔ¨Ånition 2 (marking graph) .given a petri net n=
(p;t;f;;;m0;mf), the corresponding marking graph or
state-spacem= ( q;;;q 0;qf)is a non-deterministic
automaton such that:
qb(p)is the (possibly inÔ¨Ånite) set of vertices in m,
which corresponds to the set of reachable markings from
m0(obtained by Ô¨Åring transitions),
(qq)is the set of edges in m, i.e.,
(m;a;m0)2iff there is a t2t such that m0is obtained
by Ô¨Åring transition tfrom marking m and (t) =a,
q0=m0is the initial state of the graph,
qf=mfis the Ô¨Ånal state of the graph.
we call sequence of edges pan (accepting) path iff pstarts
from the initial state and ends in the Ô¨Ånal state, and for every
two successive edges, the endpoint of the Ô¨Årst edge is the
starting point of the second edge.
b. preliminaries on alignments
deÔ¨Ånition 3 (alignment) .let2be a log trace and
letnbe a petri net model, for which we obtain the marking
graphm= (q;;;q 0;qf). we refer to as the alphabet
containing skips: = [fg andas the alphabet
that also contains the silent event: = [f;g.
let2()be a sequence of log-model pairs.
for=h(0
0;1
0);(0
1;1
1);:::; (0
jj 1;1
jj 1)i, we deÔ¨Åne
`as`=h0
0;0
1;:::;0
jj 1infg andmbym=h1
0;1
1;:::;1
jj 1infg . we callanalignment if the
following conditions hold:
1)`=(the activities of the log-part, equals to ),
2)m0m
0  ! m0m
1  !:::m
jmj 1     ! mf(mforms a path),
3)8a;b2^a6=b: (a;b)=2(illegal moves),
4)(;)=2, (the ‚Äòempty‚Äô move may not exist in ).
deÔ¨Ånition 4 (alignment cost) .let2()be
an alignment for 2and the petri netn. we deÔ¨Åne the
cost function cfor pairs of ;c: ()!r0and
overloadcfor alignments; c:!r0, which we deÔ¨Åne as
follows:c() =pjj 1
i=0c(i).
we call an alignment under cost function coptimal iff
@0:c(0)< c(), i.e., there does not exist an alignment
with a smaller cost. we call a cost function uniform-cost iff
c: ()!f0;1g.
deÔ¨Ånition 5 (standard cost function) .the standard cost
functioncstis a uniform-cost function and is deÔ¨Åned for an
alignment pair as follows:
cst(`;m) =8
>>><
>>>:0`=andm=(-move, i.e., (;))
0`2andm2and`=m(e.g.,(a;a))
1`2andm=(e.g.,(a;))
1`=andm2 (e.g.,(;a))
for the remainder of the paper, we use the standard-cost
function, unless stated otherwise.
c. preliminaries on symbolic reachability
deÔ¨Ånition 6 (binary decision diagram) .an (ordered) binary
decision diagram (bdd) [14] is a rooted directed acyclic
graph that represents a boolean function. each decision node
is labelled by a boolean variable viand has two child nodes:
a low child and a high child, representing the assignment of
respectively false and true to vi. a bdd has two terminal
nodes, 0 and 1, and a path from the root to a 0 (or 1) terminal
{p0} {p1p2} {p0,p1p2}
fig. 2: from left to right: a simple petri net model, a bdd
representing the state p0, a bdd representing the state p1p2 ,
and a bdd representing the union of states p0andp1p2 .
here, green solid arrows represent assignments to true and
red dotted arrows are assignments to false.represents a variable assignment for which the represented
boolean function evaluates to false (or true, respectively).
a set of petri net markings can be represented as a bdd by
encoding the token count of each place as (possibly multiple)
boolean variables. figure 2 gives an example of how a simple
1-safe petri net (i.e., every place can have at most one token)
can be encoded as a bdd. here, a single boolean variable
is assigned for every place in the petri net. in case the petri
net is not 1-safe, multiple boolean variables are required for
representing a set of petri net markings.
the size (number of nodes) of a bdd is in the worst-case
exponential in the number of boolean variables. in practice, the
size greatly depends on the variable ordering, i.e., choosing to
decide on variable vibefore deciding vjmay greatly reduce
the bdd size as a result of locality or symmetries.
set operations such as a[bare possible with bdds, an
example of this is given in figure 2. it is also possible to
compute successors, by encoding a transition relation in the
form of a bdd. this relation then checks (part of) a variable
assignment and, by using auxiliary variable nodes, sets the
corresponding assignment for the successor. this makes it pos-
sible to perform reachability in a symbolic fashion. however,
note that most operations on bdds are expensive in the sense
that they have linear or quadratic complexity in the number of
nodes, and exponential in the number of variables.
iii. s ymbolic alignment
we Ô¨Årst discuss the main idea of our symbolic alignment
algorithm and an improvement to the base version. then, the
detailed algorithm is explained, an example of its usage is
given and we show its correctness.
a. general idea
the idea of the algorithm is to split up the petri net
transitions into two groups, a group that only consists of
0-cost moves (in the standard cost function: -moves and
synchronous moves) and 1-cost moves (in the standard cost
function: model-moves and log-moves). we call these groups
respectively t0andt1. note that this is only applicable for
uniform-cost functions, thus our algorithm is only applicable
in that setting.
a decision diagram is used to symbolically store a set of
markings. moreover, it is possible to apply transitions on such
sets to compute a new set that contains all successors for every
marking in the original set.
with the t0andt1groups, we can compute a shortest
path from the initial marking to the Ô¨Ånal marking by Ô¨Årst
considering all reachable markings when we repeatedly apply
t0transitions. we thus create a transitive closure with t0
operations, which we denote as t
0. after applying t
0on
the initial marking we obtain the set s1of all markings that
are reachable by only applying 0-cost steps. then, on the set
s1we apply a single t1step, for which we obtain the set s2.
ons2we again apply t
0to obtains3, which is the set of
markings that can be reached from the initial states with at
most 1 cost.
t0* t1 t0* t1 t0* t0* t1 t0* t1 t0*fig. 3: abstract representation for the procedure of algo-
rithm 1, where the green and red nodes respectively represent
the initial and Ô¨Ånal markings. coloured regions denote sets
of markings and the brown region is the intersection of the
forward and backward search.
the previous process is repeated until the smallest nsuch
thatsncontains the Ô¨Ånal marking. once this is reached, a
path can be constructed from the Ô¨Ånal marking to the initial
marking by reverting the symbolic operations. note that this
path is also a shortest path (with minimal cost) from the initial
marking to the Ô¨Ånal marking, where the cost equals the number
oft1transitions taken. also note that we assume that the Ô¨Ånal
marking is reachable via a Ô¨Ånitely many steps from the initial
marking, with the consequence that each set sicontains a
Ô¨Ånite number of markings.
b. bidirectional search
instead of just searching from the initial marking to the
Ô¨Ånal marking, we can also search from the Ô¨Ånal marking to
the initial marking by taking the transitions in the opposite
direction. when the forward and backward search have a
non-empty intersection, a shortest path can be constructed. a
shortest path is formed by selecting a marking from the non-
empty intersection and reverting the symbolic operations from
this marking to get back to the initial and Ô¨Ånal marking.
the illustration from figure 3 depicts the procedure. the
intuition for searching in both directions is that the total
number of visited states (which may relate to the number
of decision nodes) is reduced this way. in our preliminary
experiments we found that it is more time- and memory
efÔ¨Åcient to search bidirectionally compared to only searching
in the forward direction.
instead of switching search directions after each iteration,
preliminary experiments showed that it is more beneÔ¨Åcial to
continue searching on the set that has the smallest number of
nodes in the decision diagrams. the algorithm Ô¨Årst performs
at
0step in both directions, after which it applies a t1
transition followed by a t
0application on the set with the
smallest number of nodes. it then again performs a t1-t
0
step on the set with the smallest number of nodes until it
terminates. in general, the number of nodes in the decision
diagram correlates with the time required for performing a
symbolic operation.algorithm 1: symbolic alignment algorithm
1function dotrans (cur;tx;dir)
2 n:=;
3 forall t2txdo
4 ifdir=fwd then n:=n[next (cur;t)
5 else n:=n[prev (cur;t)
6 return n
7function t0closure (cur;t0;vfwd;vbwd;dir)
8 n:=cur
9 while n6=;^vfwd\vbwd=;do
10 n:=dotrans (cur;t0;dir)nvdir
11 vdir:=vdir[n
12 cur:=n
13 return vdir
14function symalign (init;final;t0;t1)
15 vfwd:=finitg;vbwd:=ffinalg// visited
16 vfwd:=t0closure (vfwd;t0;vfwd;vbwd;fwd)
17 vbwd:=t0closure (vbwd;t0;vfwd;vbwd;bwd)
18 ifvfwd\vbwd6=;then return trace
19 do
20 ifnc(vfwd)<nc(vbwd)then dir:=fwd
21 else dir:=bwd // dir2ffwd;bwdg
22 n:=dotrans (vdir;t1;dir)nvdir
23 vdir:=vdir[n
24 vdir:=t0closure (n;t0;vfwd;vbwd;dir)
25 ifvfwd\vbwd6=;then return trace
26 while n6=;
27 return no-trace
c. detailed algorithm
here we discuss algorithm 1. we Ô¨Årst discuss the auxiliary
functions dotrans , which computes the successors after
applying either a t0ort1transition, and t0closure , which
computes the transitive closure for t0transitions.
given a set of current states cur, the dotrans function
attempts to Ô¨Åre all transitions in tx(which is either t0ort1)
to form a set of successor or predecessor states n, which is
returned. the for loop in line 3-5 iterates over all transitions in
txand depending on the current direction ( dir) computes the
successors or predecessors from cur by attempting to Ô¨Åre the
transition ton all markings in cur. the set of all successors
is then stored in nand the union of all successors is returned.
thet0closure function repeatedly calls the dotrans
function to compute t
0, i.e., the transitive closure of applying
t0transitions. the set of successors nis computed in line 10
and used as the current set in the following iteration. note that
already visited states are removed (with the nvdiroperation)
and newly found states are added to vdir. the function returns
when either there are no new successors ( n=;) or when a
shortest path is found ( vfwd\vbwd6=;) which is discussed
later.
the main function, symalign works as follows. theforward and backward visited sets are initialized in line 15.
from the initial state, the t0closure is called to perform a
forward t
0application. the set vfwdnow contains all states
reachable from the initial state via t0transitions.
thet0closure is also called from the Ô¨Ånal state in the
backwards direction (line 17). it may be possible that an
optimal alignment exists with a total cost of 0, then the Ô¨Ånal
state should be included in vfwdand hence vfwd\vbwd6=;. if
this is the case, then a trace can be reconstructed and returned
(line 18). see section iv-c for more information on the trace
reconstruction.
in line 19-26 the algorithm continuously performs a t1
transition followed by a t
0application until it either found
and returned a shortest path or found no new states with a t1
transition.
in line 20-21 the algorithm decides on which direction to
search. the number of decision diagram nodes for vfwdand
vbwdare compared (with the ncfunction) and the one with
the fewest number of nodes is chosen for the current iteration.
thet1successors or predecessors are computed for all
states in vdirin line 22 (note that nonly contains new
states). the visited set is updated and a t
0application is
performed. if there is a non-empty intersection between the
forward and backward search, a shortest path is found and
returned (line 25). otherwise, the algorithm continues with a
next iteration.
if there is no path from the initial to the Ô¨Ånal state, the
entire state space gets explored (assuming this is Ô¨Ånite) and
no new states can be found, after which the loop ends and
the function returns no-trace. note that the two while-loops
always terminate on Ô¨Ånite state-spaces, either when a path to
the Ô¨Ånal marking is found, or when no new successors are
found after trying to Ô¨Åre transitions from t0ort1.
d. correctness
to show that algorithm 1 is correct, we prove that the
algorithm always returns a trace if there is a path from the
initial to the Ô¨Ånal marking (theorem 1), and that a returned
trace forms an optimal alignment (theorem 2).
theorem 1 (completeness) .given a marking graph m=
(q;;;q 0;qf)and a uniform-cost function c, if there is a
Ô¨Ånite path from q0toqf, then algorithm 1 returns a trace for
mandc.
proof. assume that there is a path from q0toqfand assume
that the algorithm does not return a trace. we consider two
cases: (1) the algorithm terminates and does not return a trace,
and (2) the algorithm does not terminate.
(1) the algorithm terminates, thus it has Ô¨Ånished exploring
the state-space. note that t0[t1forms the set of all transitions
and that the algorithm performs a t1andt
0application
in each step (aside from the Ô¨Årst one). therefore, both the
forward and backward search have visited the respective
forward and backward reachable state-spaces. since there is
a path from the initial to the Ô¨Ånal state, there must be a non-fig. 4: marking graph for the example of figure 1. the numbers in the nodes denote the order of exploring the marking graph
by algorithm 1. green nodes denote a forward search, red nodes denotes a backward search, and yellow nodes denote the
intersection between the forward and backward search.
empty intersection between these searches and a trace must be
reported.
(2) the algorithm does not terminate. since there is a Ô¨Ånite
path of length lfromq0toqf, the forward or backward search
must Ô¨Ånd this path after at most 2l+1steps. this consists of
two times the initial step, l 1times a forward (or backward)
step andltimes a backward (or forward) step. since all paths
with a length of lmust be included in this search, the path
from the initial to the Ô¨Ånal state must have been detected.
theorem 2 (soundness) .given a marking graph mand a
uniform-cost function c, if algorithm 1 returns a trace, it is
optimal formandc.
proof. assume that the total cost for an optimal trace is k.
note that an optimal trace in our setting minimizes the number
of 1-cost moves. by considering all possible states reachable
viat0transitions both before and after a single t1application
we consider every state reachable with a maximum cost of 1.
thus afterkiterations of applying a 1-cost move (note that
the directional changes do not affect the result) we must also
detect the states that form a shortest path, which is encountered
before any longer path.
from the above results, we can also conclude that algo-
rithm 1 needs at most 2 +k(2 initial t
0applications and
ktimes t1-t
0) steps to return an optimal alignment of cost
k.
e. example
figure 4 depicts the marking graph for the petri net of
figure 1 and the numbers in the nodes denote the explo-
ration order by algorithm 1. the initial and Ô¨Ånal states arerespectively m0andm37. algorithm 1 starts by Ô¨Årst computing
t
0from the initial state. it Ô¨Ånds m4via the synchronous
atransition. then, no more 0-cost moves are possible. the
same procedure is then started from the Ô¨Ånal state. no 0-cost
transitions can be taken to m37. in this example, for simplicity,
we assume that the number of markings equals the number of
decision nodes.
then, since the backward set contains fewer markings
(decision nodes), a t1transition is taken towards m37to obtain
states m35andm36. then t
0is computed. states m28andm34
are found in the Ô¨Årst iteration, then m23is encountered, then
m13, and Ô¨Ånally m3. after these t0iterations, no other 0-cost
transition can be taken from the backward set.
now, the forward set contains fewer decision nodes. a t1
transition is taken to obtain the states m1,m2,m8, andm9. after
applying t
0, we obtain m18. the forward set again contains
fewer decision nodes, thus we take a t1transition from the
forward set. we Ô¨Ånd states m3,m5,m12,m13,m14,m15,m23,
andm24.
since we now have a non-empty intersection between the
forward and backward search, we found a shortest path and
can compute the corresponding alignment. by taking the path
m0a  !m4b  !m8c  !m18d  !m23  !m28e  !m35b  !m37, we Ô¨Ånd
the optimal alignment as given in figure 1.
iv. i mplementation
a. decision diagrams
we implemented the decision diagrams using the multi-core
bdd package sylvan [11], [15]. instead of using bdds for
the implementation, we used a variant, called list decision
diagrams (ldds). here instead of a boolean node, a decisionnode represents a linked list of possible values for a variable.
unless the petri net is 1-safe, meaning that each place can
contain at most one token (e.g., see figure 2), it is difÔ¨Åcult
to decide how many boolean variables are required for repre-
senting a place. an ldd is extended on-the-Ô¨Çy and is better
suited for model checking [11].
for variable reordering, we experimented with various al-
gorithms that have been shown to perform well in practice
for symbolic reachability [16]. however, none of the variable
reordering algorithms we tested improved the overall perfor-
mance. we suspect this is due to the fact that we split up the
transitions into two groups, which is non-standard in symbolic
reachability.
b. evaluation of bidirectional search
we experimented with various alternatives for choosing
to search forward or backward. we only observed a slight
performance improvement from choosing the smallest deci-
sion diagram versus alternating in each step. however, when
compared to a strictly forward search, we found that the
(combined) ldd size of the bidirectional search is often
signiÔ¨Åcantly smaller than the one for the strictly forward
search. the performance of the bidirectional search is also
signiÔ¨Åcantly better.
c. trace construction
when a non-empty intersection is found, a trace is returned.
this is realized by storing the ldd after each operation during
the algorithm, which we call levels . we show how a trace is
reconstructed from the forward search. from the non-empty
intersection, a single state sis selected and the transition
relation is applied in the backward direction to obtain a set sof
predecessor states. we intersect swith the previous level from
the forward search and pick a state s0. the same procedure is
applied until the initial state is retrieved. the trace is combined
with the backward reconstruction (also starting from state s).
the trace reconstruction is efÔ¨Åcient in practice since the
transitions are only applied on single states (and thus also
small ldds). note that it is also possible to obtain allshortest
paths by selecting the entire intersection as a starting point and
by iteratively computing all possible predecessors2.
v. e xperiments
we implemented our algorithm in the lts min model
checking toolset [17] and compared its performance with
theaversion from the process mining toolkit prom [18].
we used rapidprom [19], an extension for the rapidminer
platform, to generate experiments and perform the aex-
periments. we performed all our experiments on an intel¬Æ
coretmi7-4710mq processor with 2.50ghz and 7.4gib mem-
ory, using 8 threads. the a* implementation uses multiple
cores for computing the heuristic function via integer linear
programming. our implementation makes use of the multi-
core bdd package sylvan [11], which parallelizes operations
2in the case for returning all shortest paths, algorithm 1 should be updated
to only return a trace after allt
0procedures have Ô¨Ånished.on decision diagrams. however, both for a* and the symbolic
algorithm we observed practically no performance difference
when compared to their single-threaded results. we argue that
there is plenty of room for improvement in terms of multi-core
scalability for the symbolic algorithm as future work.
a. model generation
using the ptandloggenerator [20] we generated petri net
models with speciÔ¨Åc characteristics, which we explain as
follows.
we specify the number of different activities in the petri
net to be on average 25, 50, or 75. this resulted in a
petri net containing on average respectively 89, 256, or
442 transitions and 84, 242, or 410 places.
we set the process operators to what is considered a
standard (std) setting [20]. the operators are as follows:
‚Äìthe probability for sequence operators: 45%,
‚Äìthe probability for xor operators: 20%,
‚Äìthe probability for parallel operators: 20%,
‚Äìthe probability for loop operators: 10%,
‚Äìthe probability for or operators: 5%.
we also consider variants, where sequence operators
occur 25% instead of 45% and with a 20% increase in
probability for one of the other operators (the total must
be 100%):
‚Äìthe probability for xor: 40% (+xor),
‚Äìthe probability for parallel: 40% (+par),
‚Äìthe probability for loop: 30% (+loop),
‚Äìthe probability for or: 25% (+or).
we also consider another variant (alt) with sequence,
parallel, xor, loop, and or respectively set to 46%,
35%, 19%, 0%, 0%, to resemble standard models without
loops [21], [22].
we also set additional features, for which the standard
(std) setting is as follows:
‚Äìthe probability for silent activities: 20%,
‚Äìthe probability for duplicate activities: 20%,
‚Äìthe probability for long-term dependencies: 20%.
for each of these parameters, we consider a variant
with one feature set to 0% (‚Äìsil, ‚Äìdup, ‚Äìlong) and
a variant with one feature set to 50% (+sil, +dup,
+long). we only use these variants for standard process
operators and use the standard additional features setting
when we change one of the process operator settings,
such that only one aspect is changed.
with the above we obtain 3(6+6) = 36 different settings. for
each setting, we generate four models and generate a single
random log trace per model. in the four log traces we add
10%, 30%, 50% and 70% noise by adding, removing, and
swapping events. we now have 364 = 144 different models
and log traces and we repeat this procedure 30 times to obtain
14430 = 4;320different experiments3.
3we could have used the same model in multiple experiments by for
instance generating multiple log traces, but by using different experiments we
eliminate the randomness of model and log generation as much as possible.table i: experimental results for the various types of experiments. from top to bottom it shows the total number of experiments
per category, the number of time-outs that occurred for respectively a* and the symbolic algorithm, the number of times that
a* was faster than the symbolic algorithm and vice versa, and Ô¨Ånally the relative time improvement of the symbolic algorithm.
activities process operators
25 50 75 +loop +or +par +xor alt std
experiments 1,440 1,440 1,440 360 360 360 360 360 2,520
a* time-out 30 366 653 58 192 137 64 93 505
sym time-out 2 78 263 23 29 35 12 34 210
# a*<sym 1,086 653 529 239 95 133 208 186 1,407
# sym <a* 354 739 733 109 242 201 146 147 981
a* / sym 2.77 2.40 1.69 1.45 3.13 2.65 2.59 1.85 1.69
additional features noise
‚Äìdup ‚Äìlong ‚Äìsil +dup +long +sil std 10% 30% 50% 70%
experiments 360 360 360 360 360 360 2,160 1,080 1,080 1,080 1,080
a* time-out 81 25 60 70 66 120 627 258 270 273 248
sym time-out 32 9 27 37 17 64 157 60 78 96 109
# a*<sym 182 211 217 228 208 171 1,051 549 562 560 597
# sym <a* 157 147 125 109 144 142 1,002 495 469 446 416
a* / sym 1.85 2.95 1.58 1.20 1.99 1.48 2.26 2.38 2.05 1.93 1.59
0510152025303540
25 50 75
# activitiestime (sec)algorithm
a*
sym
05101520253035
‚àídup‚àílong ‚àísil+dup+long +silstd
additional features %time (sec)051015202530354045
+loop +or +par +xor alt std
process operators %time (sec)
051015202530
10% 30% 50% 70%
noise %time (sec)
fig. 5: average times for the a* and symbolic algorithm on various types of experiments with 95% conÔ¨Ådence intervals.
b. experimental setup
for each of the 4,320 experiments, we execute the a*
algorithm with 8 cores and set a time-out of 60 seconds, and
do the same for our symbolic algorithm. the times include
the trace generation process to form the alignment. when
summarizing the results, we average the times and in case
of a time-out use 60 seconds for the time.c. results
the results of the experiments are depicted in figure 5
and table i. overall, the average time that a* requires
for computing an alignment is 95% more than that of the
symbolic algorithm. interestingly, in 2,268 experiments a*
outperformed the symbolic algorithm and the symbolic algo-
rithm outperformed a* only 1,826 times (in 226 cases both
algorithms did not compute an alignment within 60 seconds).it should also be noted that a* had a time-out in 1,049 cases
and the symbolic algorithm had 343 time-outs. from this, we
can conclude the following.
1) the symbolic algorithm is signiÔ¨Åcantly faster in com-
puting alignments when it comes to the average time.
2) a* was able to compute more experiments faster than
the symbolic algorithm than the other way around.
3) if the a* algorithm faced a time-out, in 78% of the
cases the symbolic algorithm was able to compute an
alignment, and in almost 34% of the cases a* was able
to compute an alignment when the symbolic algorithm
timed out. thus, the techniques are complementary.
in the results for our symbolic algorithm, we observed that
63% of the time is spent on the search procedure, and
the remaining 37% of the time is used for setting up the
model checker (i.e., parsing the petri net) and the trace
construction. with more optimizations we think it is possible
to reduce the trace construction time. all experiments and
results can be found online at https://github.com/utwente-
fmt/symbolicalign-acsd18.
a) results for increasing activities: the number of ac-
tivities in the petri net corresponds to the size of the model.
we can see that when the number of activities increases, both
algorithms take on average more time to compute alignments.
interestingly, the symbolic algorithm seems to perform rela-
tively better for the smaller class of models than for the larger
models. we argue that this is mainly due to the large inÔ¨Çuence
of the 60 second time-out penalties in the 25 activity cases.
when we compare the number of times that one algorithm
is faster than the other, we see that for smaller models a*
is better and for larger models the symbolic algorithm is
preferred.
b) results for various process operator settings: from
the results, we observe large differences when changing the
probabilities for various process operators. the symbolic al-
gorithm (relatively) performs exceptionally well for the +or,
+par and +xor cases. one similarity between these three
instances is that they all signiÔ¨Åcantly increase the size of
the marking graph. just as with the increase in activities,
we consider the symbolic algorithm better suited for larger
state-spaces that have a regular structure. this is supported
by the observed performance increase. another interesting
result is that when we increase the probability of loops, the
performance of the symbolic algorithm drops compared to a*.
loops may cause the symbolic algorithm to compute many
already visited states in next-state calls, which might explain
the result.
c) results for various additional feature settings: for
the additional features the most interesting result is when we
increase the number of duplicate activities. in this case, the
symbolic algorithm performs worst compared to a* (though
it‚Äôs average compute time is still lower). we argue that due to
this effect, there are more synchronous moves in the model,
which is bad for the symbolic algorithm as this could lead to
many t0operations. in the other instances, we do not observe
too many differences with the standard.d) results for increasing noise: for the increase in noise
we can see that the performance of a* stays relatively the
same while the performance of the symbolic algorithm drops.
we suppose this is a consequence of the fact that for a higher
amount of noise, the total cost for an optimal alignment
increases. when the alignment cost is high, the symbolic
algorithm has to perform more t1operations and thus more
symbolic operations.
vi. r elated work
we refer to [1] for an overview of different process mining
techniques. one of the earliest works in conformance checking
was from cook and wolf [23]. they compared log traces with
paths generated from the model.
token-based replay [4] is one technique to check for confor-
mance. the idea is to ‚Äòreplay‚Äô the event logs by trying to Ô¨Åre
the corresponding transitions, while keeping track of possible
missing and remaining tokens in the model. however, this
technique does not provide a path through the model. when
traces in the event log deviate a lot, the petri net may get
Ô¨Çooded with tokens and does not provide good insights any
more.
alignments were introduced [5], [24], [8] to overcome the
limitations from the token-based replay technique. alignments
formulate conformance checking as an optimization prob-
lem, i.e., minimizing the alignment cost-function. since its
introduction, alignments have quickly become the standard
technique for conformance checking. the ashortest path
algorithm [7] in combination with integer linear programming
(ilp) to prune the search space (i.e., the synchronous product
of the model and the log trace) is considered the state-of-the-
art in computing alignments [8].
for larger models, merely constructing alignments on the
synchronous product may quickly become too computationally
intensive to handle. several decomposition techniques have
been developed [25], [26], [27] that partition the petri net
into smaller subprocesses. for instance, fragments that have a
single-entry and single-exit node (sese) represent an isolated
part of the model [27]. this way, localizing conformance prob-
lems becomes easier in large models. such decompositions
may be combined with any conformance checking technique,
including our approach.
a different solution to deal with large instances is to no
longer guarantee optimality. several techniques exists [28],
[29] that can very efÔ¨Åciently compute ‚Äògood‚Äô, but not nec-
essarily optimal, alignments for large instances.
there are a number of existing algorithms for computing
the shortest path symbolically. symbolic versions of dijkstra‚Äôs
algorithm, bellman-ford, and a* exist [12], [13]. however
one of the main problems with the related approaches is the
overhead for bookkeeping or updating the shortest path info.
for instance, the symbolic a* implementation [13] tracks a
ghmatrix, where each cell represents the set of states that
have current cost gfrom the initial state and heuristic cost hto
the Ô¨Ånal state. our approach is designed in such a way that no
additional cost information needs to be stored directly for thedecision diagrams, with the downside that it is only suitable
for uniform-cost functions.
vii. c onclusion
we have designed and implemented a symbolic algorithm
for computing shortest paths on uniform-cost functions. we
have applied this algorithm in the context of computing
alignments and compared its performance with the state-of-
the-art approach for computing alignments. for the empirical
study we generated a set of over 4,000 experiments to test the
effect of various characteristics on performance.
from the experimental results we conclude that our sym-
bolic algorithm is well-suited for computing alignments. we
found that the symbolic technique is more robust in computing
alignments when compared to a*. we further observe that
the symbolic approach is especially favourable in computing
alignments for models with large state-spaces. however, a*
seems to perform better for smaller instances. the techniques
are complementary; due to the different underlying techniques,
instances for which a* takes a (too) long time to compute may
be solved quickly with the symbolic approach and vice versa.
one direction for future work is to compare performance
differences on industrial case studies. another direction is to
design an algorithm that analyses the petri net model and se-
lects the most appropriate algorithm for computing alignments.
we also think that the performance of our algorithm may be
further improved by e.g., improving the multi-core scalability,
experimenting with different variable orderings and improving
the trace construction performance.
references
[1] w. m. p. van der aalst, process mining: data science in action .
springer, 2016.
[2] c. liu, b. f. van dongen, n. assy, and w. m. p. van der aalst,
‚Äúcomponent behavior discovery from software execution data,‚Äù in 2016
ieee symposium series on computational intelligence, ssci 2016,
athens, greece, december 6-9, 2016 , pp. 1‚Äì8, 2016.
[3] m. leemans and w. m. p. van der aalst, ‚Äúprocess mining in software
systems: discovering real-life business transactions and process models
from distributed systems,‚Äù in 18th acm/ieee international conference
on model driven engineering languages and systems, models 2015,
ottawa, on, canada, september 30 - october 2, 2015 , pp. 44‚Äì53, 2015.
[4] a. rozinat and w. m. p. van der aalst, ‚Äúconformance checking of
processes based on monitoring real behavior,‚Äù information systems ,
vol. 33, no. 1, pp. 64 ‚Äì 95, 2008.
[5] w. m. p. van der aalst, a. adriansyah, and b. f. van dongen,
‚Äúreplaying history on process models for conformance checking and
performance analysis,‚Äù wiley interdisciplinary reviews: data mining
and knowledge discovery , vol. 2, no. 2, pp. 182‚Äì192, 2012.
[6] a. adriansyah, n. sidorova, and b. f. van dongen, ‚Äúcost-based
fitness in conformance checking,‚Äù in 11th international conference on
application of concurrency to system design, acsd 2011, newcastle
upon tyne, uk, 20-24 june, 2011 , pp. 57‚Äì66, 2011.
[7] p. e. hart, n. j. nilsson, and b. raphael, ‚Äúa formal basis for the
heuristic determination of minimum cost paths,‚Äù ieee transactions
on systems science and cybernetics , vol. 4, no. 2, pp. 100‚Äì107, 1968.
[8] a. adriansyah, aligning observed and modeled behavior . phd thesis,
eindhoven university of technology, the netherlands, 2014.
[9] a. valmari, ‚Äúthe state explosion problem,‚Äù in lectures on petri nets
i: basic models: advances in petri nets (w. reisig and g. rozenberg,
eds.), (berlin, heidelberg), pp. 429‚Äì528, springer berlin heidelberg,
1998.[10] j. burch, e. clarke, k. mcmillan, d. dill, and l. hwang, ‚Äúsymbolic
model checking: 1020states and beyond,‚Äù information and computa-
tion, vol. 98, no. 2, pp. 142 ‚Äì 170, 1992.
[11] t. van dijk and j. van de pol, sylvan: multi-core decision diagrams ,
pp. 677‚Äì691. berlin, heidelberg: springer berlin heidelberg, 2015.
[12] d. sawitzki, ‚Äúexperimental studies of symbolic shortest-path algo-
rithms,‚Äù in experimental and efÔ¨Åcient algorithms (c. c. ribeiro and
s. l. martins, eds.), (berlin, heidelberg), pp. 482‚Äì497, springer berlin
heidelberg, 2004.
[13] s. edelkamp and p. kissmann, ‚Äúoptimal symbolic planning with action
costs and preferences,‚Äù in proceedings of the 21st international joint
conference on artiÔ¨Åcal intelligence , ijcai‚Äô09, (san francisco, ca,
usa), pp. 1690‚Äì1695, morgan kaufmann publishers inc., 2009.
[14] r. e. bryant, ‚Äúgraph-based algorithms for boolean function manipu-
lation,‚Äù ieee trans. comput. , vol. 35, no. 8, pp. 677‚Äì691, 1986.
[15] t. van dijk, sylvan: multi-core decision diagrams . phd thesis, enschede,
2016. ipa dissertation series no. 2016-09.
[16] j. meijer and j. van de pol, bandwidth and wavefront reduction for
static variable ordering in symbolic reachability analysis , pp. 255‚Äì
271. lecture notes in computer science, springer international pub-
lishing, 2016. eemcs-eprint-27067.
[17] g. kant, a. laarman, j. meijer, j. van de pol, s. blom, and t. van dijk,
‚Äúltsmin: high-performance language-independent model checking,‚Äù
intools and algorithms for the construction and analysis of systems
(c. baier and c. tinelli, eds.), vol. 9035 of lecture notes in computer
science , pp. 692‚Äì707, springer berlin heidelberg, 2015.
[18] h. m. w. verbeek, j. c. a. m. buijs, b. f. van dongen, and w. m. p.
van der aalst, xes, xesame, and prom 6 , pp. 60‚Äì75. berlin, heidel-
berg: springer berlin heidelberg, 2011.
[19] w. m. p. van der aalst, a. bolt, and s. j. van zelst, ‚Äúrapidprom: mine
your processes and not just your data,‚Äù corr , vol. abs/1703.03740,
2017.
[20] t. jouck and b. depaire, ‚Äúptandloggenerator: a generator for artiÔ¨Å-
cial event data,‚Äù in proceedings of the bpm demo track 2016 co-
located with the 14th international conference on business process
management (bpm 2016), rio de janeiro, brazil, september 21, 2016. ,
pp. 23‚Äì27, 2016.
[21] m. kunze, a. luebbe, m. weidlich, and m. weske, towards under-
standing process modeling ‚Äì the case of the bpm academic initiative ,
pp. 44‚Äì58. berlin, heidelberg: springer berlin heidelberg, 2011.
[22] s. j. van zelst, a. bolt, and b. f. van dongen, ‚Äútuning alignment
computation: an experimental evaluation,‚Äù in proceedings of the
international workshop on algorithms & theories for the analysis of
event data, ataed 2017, zaragoza, spain, june 25-30, 2017. , pp. 1‚Äì
15, 2017.
[23] j. e. cook and a. l. wolf, ‚Äúsoftware process validation: quantitatively
measuring the correspondence of a process to a model,‚Äù acm trans.
softw. eng. methodol. , vol. 8, no. 2, pp. 147‚Äì176, 1999.
[24] a. adriansyah, b. f. van dongen, and w. m. p. van der aalst, ‚Äúcon-
formance checking using cost-based fitness analysis,‚Äù in 2011 ieee
15th international enterprise distributed object computing conference ,
pp. 55‚Äì64, 2011.
[25] w. m. p. van der aalst, ‚Äúdecomposing petri nets for process mining: a
generic approach,‚Äù distributed and parallel databases , vol. 31, no. 4,
pp. 471‚Äì507, 2013.
[26] w. m. p. van der aalst, a. kalenkova, v . rubin, and h. m. w.
verbeek, process discovery using localized events , pp. 287‚Äì308.
cham: springer international publishing, 2015.
[27] j. munoz-gama, j. carmona, and w. m. p. van der aalst, ‚Äúsingle-entry
single-exit decomposed conformance checking,‚Äù information systems ,
vol. 46, no. supplement c, pp. 102 ‚Äì 122, 2014.
[28] b. f. van dongen, j. carmona, t. chatain, and f. taymouri, ‚Äúaligning
modeled and observed behavior: a compromise between computation
complexity and quality,‚Äù in advanced information systems engineering
- 29th international conference, caise 2017, essen, germany, june
12-16, 2017, proceedings (e. dubois and k. pohl, eds.), vol. 10253 of
lecture notes in computer science , pp. 94‚Äì109, springer, 2017.
[29] f. taymouri and j. carmona, ‚Äúa recursive paradigm for aligning
observed behavior of large structured process models,‚Äù in business
process management - 14th international conference, bpm, 2016, rio
de janeiro, brazil, september 18-22, 2016. proceedings (m. l. rosa,
p. loos, and o. pastor, eds.), vol. 9850 of lecture notes in computer
science , pp. 197‚Äì214, springer, 2016.