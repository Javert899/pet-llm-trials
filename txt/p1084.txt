automated robotic process automation:
a self-learning approach
junxiong gao1, sebastiaan j. van zelst1;2, xixi lu3, and wil m.p . van der
aalst1;2
1chair of process and data science, r wth aachen university , aachen, germany
{jx.gao,s.j.v.zelst,wvdaalst}@pads.rwth-aachen.de
2f raunhofer institute for applied information t echnology (fit), sankt augustin,
germany
{sebastiaan.van.zelst, wil.van.der.aalst}@fit.fraunhofer.de
3department of information and computing sciences, utrecht university , utrecht,
the netherlands
x.lu@uu.nl
abstract. robotic process automation (rp a) recently gained a lot of
attention, in both industry and academia. rp a embodies a collection of
tools and techniques that allow business owners to automate repetitive
manual tasks. the intrinsic value of rp a is beyond dispute, e.g., automa-
tion reduces errors and costs and thus allows us to increase the overall
business process performance. however, adoption of current-generation
rp a tools requires a manual effort w.r.t. identification, elicitation and
programming of the to-be-automated tasks. at the same time, several
techniques exist that allow us to track the exact behavior of users in the
front-end, in great detail. therefore, in this paper, we present a novel
end-to-end approach that allows for completely automated, algorithmic
rp a-rule deduction, on the basis of captured user behavior. f urther-
more, our proposed approach is accompanied by a publicly available
proof-of-concept implementation.
keywords: robotic process automation; information systems; user
interaction; data mining; knowledge discovery
1 introduction
business process management [7] (bpm) revolves around the effective schedul-
ing, orchestration and coordination of the different activities and tasks that
comprise a (business) process. indisputably , the end goal, or even holy grail,
of any bpm practitioner is to design the most efficient process that achieves
the highest possible quality for the end product and/or service. a natural ques-
tion in this endeavor is related to automation , i.e., “what tasks are eligible for
automated execution by a computer, rather than a human?” .
within bpm, the challenge of accurately automating a business process is
known as business process automation (bp a) [ 15]. several researchers have2 gao et al.
fig. 1: positioning of candidate processes for rp a [ 2]. the application of rp a
is most effective in processes that comprise semi-similar execution flows.
studied bp a, leading to various methodologies and techniques that enable au-
tomation in business processes. t echniques in bp a typically focus on the au-
tomation of activities and tasks from a system perspective , i.e., it requires a
change of the configuration, or even redesign of, the information system sup-
porting the process [ 6][16]. therefore, applying bp a in practice is timely and
costly , and, if applied incorrectly , can have a huge negative impact as well.
f or decades, techniques have been developed that allow us to apply automa-
tion on the user interface (ui) level of computer systems . more recently , these
techniques were adopted by robotic process automation (rp a) [ 17], allowing
us to mimic user behavior within a process. since rp a operates on the user
interface level, rather than on the system level, it allows us to apply automation
without any changes in the underlying information system [ 4][19]. hence, the
entry barrier of adopting rp a in processes that are already in place, is lower
compared to conventional bp a [ 19]. f urthermore, as motivated in [ 2], there are
ample opportunities for the application of rp a in the context of (business) pro-
cesses. f or example, the application of rp a thrives in processes and process
instances that consist of a medium level of process similarity , cf. figure 1 .
current, (commercial) rp a techniques and products provide recorders and
modelers that allow manual construction of robotic behavior . however, they are
typically defined on low-level streams of user interactions (e.g., mouse clicks and
keyboard strokes) [ 13][18]. such techniques have three disadvantages: (1) they
require extensive domain knowledge to identify , from the low-level interactions,
which high-level tasks can be automated; (2) such manual identification is laborautomating robotic process automation 3
fig. 2: the f2r approach presented in this paper, consisting of three steps.
intensive [10]; (3) there is no support for (semi-)automated learning from these
user interactions.
in this paper, we propose a self-learning approach, i.e., the f orm-to-rule
(f2r) approach , which automatically detects high-level rp a-rules, from cap-
tured historical low-level user behavior. consider figure 2 , in which we schemat-
ically present the f2r approach. in the first step, (1) tasks are identified by ob-
serving the user’s interactions with the systems, on a collection of system forms
that are defined. next, it (2) deduces rules by learning relations between the
different tasks performed. such rules are defined as “ if ... then ... ” state-
ments [ 17], which is a widely adopted definition in rp a. finally , it (3) applies
the rules by instantiating rp a on the basis of the deduced rules . the “then”
part of the rule represents actions that can be automatically executed by the
rp a solution. hence, the rp a solution listens on forms , if certain triggering
action is observed, it activates and executes the suitable rule .
the f2r approach allows rp a solutions to continuously and automatically
learn from user behavior. hence, it overcomes the main bottlenecks of adopting
rp a, as mentioned before. a prototypical implementation of the f2r approach
and a corresponding screencast are publicly available via https://github.com/
frankbgao/f2r_approach_rpa .
the remainder of this paper is structured as follows. in section 2 , we review
related work. in section 3 , we present basic the notations used throughout the
paper. section 4 describes the core elements of the f2r approach. section 5
presents the corresponding algorithm and implementation for the f2r approach.
section 6 concludes the paper and provides directions for future work.4 gao et al.
2 related w ork
rp a has received much attention in recent work in the bpm community . here,
we provide a brief overview of related work in the field.
some techniques focus on the identification of tasks and/or process prop-
erties that are eligible to be automated using rp a, i.e., focusing on what to
automate . in [ 12], the authors of [ 12] propose to use natural language processing
techniques to identify candidate tasks for automation, based on business process
descriptions. in [ 8], the authors propose to leverage technology from the do-
main of process mining [ 1], i.e., a specific type of data analysis tailored towards
analyzing execution logs of business processes, for rp a candidate task identifi-
cation. in [ 10], the authors collect the mouse clicks and keyboard strokes of users
combined with simultaneous screen captures, which they define as an ui-log.
they use process discovery algorithms [1] on the ui-log to mine an end-to-end
process model, in order to help the business analyst to determine what tasks to
automate. in [ 5], the authors adopt ui-logs to automate the testing of rp a tool
deployment.
other work focuses more on the impact and/or application of rp a w.r.t. busi-
ness processes. in [ 3], a case study with a business process outsourcing provider
is presented. the authors divided employees, who performed similar tasks, into
two groups, the comparison group was working with rp a, whereas the control
group was without rp a. the comparison group showed a 21% productivity im-
provement. in [ 14], the authors reflect on the impact of rp a, alongside with
machine learning and blockchain technology , on the human perspective of busi-
ness processes. in particular, the impact on individual tasks is discussed, i.e.,
repetitive tasks are identified as most suitable for rp a as well as the impact on
the organizational/coordination perspective.4
the main deficiency of mainstream research in the domain of rp a is the lack
of focus on how to automate rp a itself. f urthermore, it is difficult to deduce
how to automate on the basis of the outcomes of the currently available studies.
in this research, we try to fix these deficiencies by empowering rp a with the
ability of self-learning.
3 notation
in this section, we present the basic notation used throughout the paper.
given an arbitrary set x,jxjreturns the size of set x, and, we let p(x)=fx′j
x′xgdenote its power set . a sequence is an enumerated collection of objects.
w e write a sequence as ⟨a; b; c; a; c ⟩, i.e., ais the first and fourth element of the
sequence, dis the second element, etc. w e write xto denote the set of all
possible sequence over an arbitrary set x.
4ref. [ 14] summarizes a panel discussion on the extent to which the emergence of
recent technologies will reduce the “‘human factor” in business process management.automating robotic process automation 5
fig. 3: the rp a lifecycle in the f2r approach: less human intervention in rp a
by adopting the f2r approach.
given arbitrary sets x1,x2, ..., xn, we let x1x2     xn=f(x1; x2; :::;
xn)jx12x1; x22x2; :::; x n2xngdenote the cartesian product over sets x1,x2,
...,xn, i.e., the set of all ordered pairs consisting of elements of x1,x2, ...,xn.
letx; y be two no-empty sets, f2x!y is a total function, the domain
dom (f)offisx, and the range rng(f)offis defined as rng(f) =ff(x)jx2
xg y.f2x↛y denotes a partial function, the domain of fis a subset of
x,dom (f)x.b=ftrue;false grepresents the set of boolean values, ? is
the null value, n is the set of natural numbers. a multiset allows its elements
to occur multiple times, e.g., [a2; b]consists of 2times element aand one time
element b. w e let b(x)represent the set of all possible multisets for x.
4 the f2r approach to automate rp a
in this section, we discuss the f2r approach in detail. section 4.1 describes the
life-cycle of adopting the f2r approach and provides a running-example which
is used in the remainder of this paper. section 4.2 describes how to deduce
user actions and tasks on the basis of inspecting form interactions. section 4.3
defines the notion of a rule and details on how to apply multiple enabled rules .
section 4.3 provides examples of instantiation for rule ’s components, it makes
the definition concrete.
4.1 the f2r lifecycle
by adopting the f2r approach, we enable rp a with an algorithmic self-learning
ability . consider figure 3 , in which we present the new basic f2r life-cycle. in
the life-cycle, there are only two points in which human interaction is required,
i.e., form definition and rule verification . the f orm definition step concerns
identifying forms in the it system, i.e., in order for f2r to be able to learn from
users interacting with these forms. the rule verification step concerns human
validation of the rules learned by f2r, i.e., to determine whether a newly learned
rule is in line with business/domain knowledge.
t o ease the overall understanding of f2r and its definitions, we use a running
example (the “sdap scenario”), on the basis of the f2r life-cycle. w e consider a6 gao et al.
“swivel chair” process, which concerns transferring information from one system
to another. such a process is a typical rp a adoption scenario [ 11]. consider an
imaginary company , sdap co., which has two systems for employment, i.e. an
interview system and an hr system . the main business process is as follows.
1. an interviewee fills in the interviewee f orm (fi) in the interview system.
f orm fihas 4 fields: “name”, “age”, “gender”,and “result” .
2. the human resource (hr) department of sdap co. evaluates the intervie-
wee, and updates the evaluation in interviewee f orm.
3. if the hr department’s evaluation equals “pass”, an employee of the hr
department subsequently fills in the new employee f orm (fn) in the hr
system. the fn from has 3 fields, i.e., “name”, “age”, “gender”, which the
employee copies from the fiform. if the hr department’s evaluation equals
“f ail”, the hr-department does not perform any action.
the conceptual description for adopting the f2r approach in the sdap
scenario is as follows:
1. define two forms fiandfn, and collect the user interactions (captured in
an input/output (io)-log ) on these two forms .
2. learn rules from the io-log. the rules represent statements of the form “ if
fi’s result field is updated to “pass”, then copy the content of fi’s tofn” .
3. an employee verifies the rule . if the rule is verified, it is adopted into the
rp a solution, i.e., the rule is applied automatically .
in the following sections, we provide more detailed descriptions and formal
definitions of the f2r approach. moreover, the algorithm for learning rules, i.e.
instantiating f2r, is presented as well.
4.2 t ask detection using f orms
the cornerstone concept of the f2r approach is the notion of a form . a form is an
abstracted and standardized representation of any it system’s data container.
f or example, consider a simple excel sheet, a web form, a form in sap , etc.,
all these data containers can essentially be seen as a form. a form instance
represents a filled form. a form can be filled multiple times, hence, a form can be
instantiated into one or multiple form instances . a form instance is distinguished
by its form instance identifier . a form state is the set of values of a form instance
at a point of time, i.e. it contains the filled information of the form instance. a
form action describes a manipulation of a form’s state, i.e. it describes two form
states, collected at the points in time in which the user is starting to edit (enter)
the form instance until the user closes (leaves) the form instance. finally , an
io-log represents a set of collected form actions. the f2r approach leverages
the notion of an io-log to find behavioral rules that are eligible for automation
through rp a.
as indicated, the notion of a form is the cornerstone of the f2r approach. f or
example, a purchase order form in sap , in essence, is a simple form. however,automating robotic process automation 7
fig. 4: t wo examples of a form, where frm points to the names of the forms and
fld to the fields.
the concept of a form is more general. not only the actual forms in an it system
are defined as a form, but also any ui which has a fixed structure and position
in the system, is represented by a form, e.g., tables, bi dashboards, etc.. any
form has two elements, i.e., a form name and a set of form fields . the form fields
refer to all the ui elements which are able to hold information.
definition 1 (f orm). letufrm denote the universe of form names andufld
the universe of form fields . a form f is a pair f= (frm; q )2u frmp(ufld),
where frm is the name of the form f andq u fld is a set of form fields. let
ufdenote the set of al l possible forms in the system, and id2u fld be the form
instance identifier, for which we enforce:
–8f= (frm; q )2 uf(id2q), i.e., every form has the form instance iden-
tifier in q.
–8f= (frm; q ); f′= (frm′; q′)2 uf(
frm =frm′=)q=q′)
, i.e., the
name of a form uniquely determines the set of fields associated with it.
figure 4 shows two examples of a form; figure 4 (a) is a management dash-
board, which is representable as a form, i.e., it is formalized as fmc = (mc;
fid; cr; qr; cashr; dr; er; der g).figure 4 (b) is a more classical form ,
which is formalized as fa= (alarm; fid; kpi; alarmtype g).
aform instance is a filled form with a unique id assigned to the omnipresent
field id . w e assume that there always exists a unique form instance id id2iid ,
which allows us to identify a single instance of a form. observe that, in some
cases, an it system readily defines an instance identifier for a form. in other
cases, such an instance identifier is derived, e.g., from the url of a web form.
definition 2 (f orm instance identifier, f orm instance). letuv al denote
the universe of possible form-field values and let iiduv al denote the set of al l
possible form instance ids. a form instance f= (f; id)2 ufiid of a form f8 gao et al.
fi=(i;fid; name; age; gender; result g)
  !f=ffi;
f(id;1);(result; estimating )g;
f(id;1);(name; frank );(age; 28);
(gender; male );(result; estimating )g;
9=19=2018 11: 30 ;9=19=2018 11: 35 ;
frank g
(1)
fig. 5: an example of form action, a form action captures two form states when
the user enters the form instance and leaves the instance.
is uniquely identified by id2iid . let idsfiid denote al l possible id values for
form f. w e assume 8f; f′2uf(f̸=f′=)idsf\idsf′=∅)
since users typically do not fill out an instance of a form in one go, i.e., the
user typically reopens the form and/or changes values, hence, the state of the
form changes over time. therefore, we define the notion of a form state ,i.e.,
representing the actual information contained in a form instance at a specific
point of time.
definition 3 (f orm state). letuv al denote the universe of possible form-field
values, and let utdenote the universe of time. let f=(frm; q )2ufbe a form, let
id2idsfand let t2ut. a state of the instance of a form f, identified by instance-
id id , at point tin time, is defined by a partial function ϕ(f; id;t):q↛uv al , for
which: ϕ(f; id;t)(id)= id;8t2ut, i.e., the instance-id is always present.
a form action (f a) records an interaction a user has performed on a form
instance. more specifically , it records two form states at the points of time when
the user is entering and leaving the form instance, respectively .
definition 4 (f orm action, io-log). letuu denote the universe of al l
possible users, let f= (frm; q )2uf be a form, let tb; tf2uts.t.tbtfbe two
timestamps, let u2uube a user and id2iid be an instance id. f urthermore, let
ϕ;^ϕ:q↛uv al . a form action  !f=(f;ϕ;^ϕ; tb; tf; u)describes a manipulation of
an instance of form f by user u, entering in the instance at time tband leaving
it at time tf. observe that ϕ(f; id;tb)=ϕandϕ(f; id;tf)=^ϕ. w e let u  !fdenote a
set of al l possible form actions. an io-log l u  !fis a set of form actions.
the first step in the sdap scenario is illustrated in figure 5 , with an ex-
ample of a form action. moreover, a complete example of the sdap scenario is
illustrated using the io-log shown in figure 6 .
4.3 defining and applying rules
as an io-log is a collection of f as, it records manipulations of form values
corresponding to the tasks executed by users. w e use the collection of f as toautomating robotic process automation 9
fig. 6: an example of io-log, it is a set of f as. this example describes that
an interviewee f rank filled his form. hr updated f rank’s result as “pass”, and
copied f rank’s information to an fn instance.
deduce their relations, i.e., we identify whether certain input(s)/modification(s)
in a form are likely to lead to other input(s)/modifications(s). w e define such
relations by using rules . f or the notion of a rule we adopt a widely accepted
rp a definition suggesting to describe rp a actions using “ if ... then ... ”
statements [ 17]. when the if condition of a rule holds for an observed f a,
our rp a solution applies the then part of the rule and generates a new f a as a
response. finally , the rp a solution translates this new f a into a sequence of low-
level movements (e.g., mouse clicks or keyboard strokes) on the corresponding
form instance.
a rule consists of two parts, a condition and a response. a condition checks
whether an f a satisfies some requirements, i.e., it defines a function that maps
an f a to true or false. f or example, in the sdap scenario, we have a condition
that requires the result field (of the interview form) to be changed into a “pass” .
the second f a shown in figure 6 satisfies this condition. based on the condition,
aresponse then generates a new f a, e.g., such an f a copies the current values in
the “name”, “age”, and “gender” fields to a form instance of the new employee
form. in the following, we formally define the conditions, responses, and rules.
definition 5 (condition). a condition cis a function c:u  !f!b. letucond
be the set of al l possible conditions .
definition 6 (response). a response ris a function r:u  !f! u   !f, which
generates a new f a based on the observed f a. let uresp be the set of al l possible
responses .10 gao et al.
definition 7 (rule). given a condition c2 ucond and response r2 uresp , let
urbe the set of al l possible rules , a rule r2 uris characterized as:
r:u  !f↛u  !f
  !f7!{
r(  !f) ifc(  !f)
? otherwise
essentially , the rp a solution of our f2r approach learns a set of rules , which
we refer to as a rule base . moreover, we define a mechanism for selecting a set of
suitable rules for one observed f a, this mechanism is called the rule selector . it
is possible that a single, observed f a satisfies multiple conditions and, therefore,
potentially triggers multiple rules present in a rule base. f or example, consider
the first f a of the sdap scenario in figure 6, which satisfies the following
two conditions: if the age field is filled in, or if the gender field is filled in.
therefore, we define a rule selector , which is a mechanism to select and apply a
rule.
definition 8 (rule selector). a rule selector :p(ur)u  !f↛u  !f, selects
and applies a rule present in a given rule base on an observed form action.
instantiating conditions using first-order logic in order to make the
concept of conditions more tangible, we provide a detailed example of how
the conditions can be formally instantiated using first-order logic conditions
(folc). a folc is a set of propositions linked by logic connectives. a folc
evaluates the values of the proposition variables and returns true or false .
in our case, the propositions are defined on the observed f a. each proposition
describes the range of values that is acceptable for an observed f a’s field value.
definition 9 (first-order logic condition). letf= (frm; q )2 u f,  !f= (f;ϕ;^ϕ; tb; tf; u)be an f a on an instance of form f; let1; :::;n;^1; :::;
^m be functions of the form q↛p(uv al)nf∅g . and, let
–ci8q2dom (i)(
q2dom (ϕ)^ϕ(q)2i(q))
, for 1in;
–^ci8q2dom ( ^i)(
q2dom (^ϕ)^^ϕ(q)2^i(q))
, for 1im.
an folc function is formed by a boolean expression over c1; :::;cn;^c1; :::; ^cm.
f or example, let us consider the third step in the sdap scenario, where an
f a, e.g., copying the field values, is performed, if the result field is changed
from an “estimating” to a “pass” value. a corresponding folc c′
for this if
condition is defined as follows. let fi= (i;fid; name; age; gender; result g)
be the interviewee form, and  !f′=(fi;ϕ;^ϕ; tb; tf; u)2u  !fbe an arbitrary f a on
afi’s instance. let =f(result; festimating g)gdenote the range of the
pairs of the fields and their values that are acceptable for the form-state ϕ, and
^=f(result; fpassg)gthe range of the pairs that are acceptable for ^ϕ. using
folc, we can define the if condition c′
as follows: c′
(  !f′) = ( ϕ(result )2
festimating g)^(^ϕ(result )2 fpassg).automating robotic process automation 11
instantiating responses using t ransform f unctions t o exemplify the
concept of responses, we discuss a detailed type of response, namely the trans-
form response. a transform response transforms, e.g., copies, the field values of
an observed f a into the corresponding fields of a newly created form instance.
t aking again the third step in the sdap scenario as an example, the transform
response in this case copies the “name”, “age”, and “gender” values into a new
form instance of the new employee form.
definition 10 (t ransform response). letf= (frm; q ); f′= (frm′; q′)2uf
be two forms, let :q↛q′be a field mapping, and, given q2q, letq:uv al!
uv al be the transform function. f urthermore, let  !f=(f;ϕ;^ϕ; tb; tf; u)2u  !fbe an
f a on an instance of form f. let ^ϕf′=f(q′; v)2q′uv alj 9q2dom () :(q)=q′^
q(^ϕ(q))=vg. let tr2 ut; tr> tf,id′2iid , the transform response function
rtf is characterized as:
rtf:u  !f! u  !f
(f;ϕ;^ϕ; tb; tf; u)7!(f′; ϕ(f′;id′; tf);^ϕf′; tf; tr;r):
in essence, the transform response creates a new form instance (f′; id′)of
the form f′. moreover, it creates two states: state ϕ(f′;id′; tf)is the default
form state of the new form instance, and state ^ϕf′is the state where its field
values are transformed. these two states are then embedded in the returned
f a. besides, the entering time of this f a is tf, which means it will be executed
right after observing the previous f a. the leaving time would be tf. hence,
the period between tfandtrallows the rp a solution to execute this new f a
and the system latency . w e use r to denote this new f a is done by the rp a
solution.
a special case of the transform response is the copy response. if the transform
function q:uv al! u v al returns the input itself for all fields q2q, it then
basically copies the input values, which we called a copy response.
considering the step 3 of the sdap scenario, where the information of name,
age, and gender is copied from the interview form into the new employee form,
this can now be performed by applying a copy response r′
tf. let fn= (n;
fid; name′; age′; gender′; result′g)be the new employee form. let tr2 ut
andtr> t fbe the two timestamps of the new f a. let id′2 iid be the
id of the new form instance. let =f(name; name′);(age; age′);(gender;
gender′)gbe the mapping. the response r′
tf(  !f′) = ( fn; ϕ(f′;id′; tf);f(q′;
v)j(q; q′)2^^ϕ(q) =vg; tf; tr;r)is a copy response. a concrete example is
shown by the second and the third f as in figure 6 , respectively as the input
and the output of this copy response.
simple rules w e have explained that a rule consists of a condition and a
response. w e have shown a concrete instantiation of the conditions using folc
and a concrete type of response defined as the transform response. based on the
sdap scenario shown in figure 6 , we can define a ruler′
c:rwhich given an input12 gao et al.
f a  !f’, it returns the new f a r′
tf(  !f′)(i.e., the result of the copy response) if the
condition c′
(  !f′)on the f a  !f′holds, i.e., r′
c:r=r′
tf(  !f′)ifc′
(  !f′). w e call
this type of rules, which comprise a folc as its condition and a copy response,
the simple rules .
5 learning simple rules from io-logs
as discussed above, an rp a solution operates based on a rule base (i.e., a set of
rules). t raining such an rp a solution is basically learning a rule base from the
io-log and building up such a rule base. in this section, we discuss an algorithm
to learn the simple rules. w e call it the simple rule learner (srl) .
the srl algorithm consists of two phases, first learning the conditions and
then learning the responses. next, we explain the learning of conditions and
responses in section 5.1 and 5.2, respectively . in section 5.3, we discuss how
to use the obtained responses and conditions to construct the rule base and
the rule selector for the rp a solution. in section 5.4, we briefly explain the
implementation of the rp a solution.
5.1 the condition learner in the srl algorithm
as discussed, based on the input io-log, we propose the srl algorithm to learn
a set of rules in order to obtain our rule base. as defined in def. 5, a condition of
a rule checks whether an f a meets some properties. f or learning such properties,
we provide an algorithm which consists of 5 steps. an overview of these steps
together with an example is shown in figure 7 .
in step (1), we simply sort the input io-log l2 p (u  !f)to obtain a sequence
s2lof f as which is ordered by the timestamps tbof the f as. as shown by
the output of step (1) in figure 7 , where each rounded rectangle represents an
f a, the sorted io-log comprises ⟨: : :  !fa;  !fi;  !fi;  !fn;  !fi;  !fi;  !fn; : : :⟩.
in step (2), we find cases from the sorted io-log s. a casecs2 u  !f u  !fis
a pair of f as. in this paper, we assume there is a form field which captures the
case identifier, i.e., the value in this field is the case id. every two f as, which
have the same case id, are paired as a case. w e define a function fc to find
the cases, i.e., fc :l u fld↛p(u  !f u  !f).
f or instance, in the sdap scenario, let fi= (i;fid; name; age; gender;
result g),fn= (n;fid; name; age; gender g)be the two forms, the name
field in fiandfn could be the case identifier. based on the values in the name
field, the second and the third f as in figure 6 are grouped into one case, because
they have the same name. in the output of step (2) in figure 7 , the cases are
highlighted in the original io-log. f or example, the third f a  !fiis paired with
the fourth f a  !fn.
in step (3), we use the set of cases to detect patterns . a pattern p2 uf uf
is a pair of forms. a pattern indicates that the f as happened on the pattern’s
forms are always paired as cases, and the order of these two f as in a case isautomating robotic process automation 13
fig. 7: adopting learning algorithm of condition functions at the sdap scenario.
corresponding with the pattern. f or example, in the sdap scenario, the pattern
could be p= (fi; fn), it means after an arbitrary f a  !f happened on fi, it is
often observed that another f a, which has the same case id with  !f, happened
onfn. the main points of this step are (i) extracting candidates of patterns
from cases; (ii) calculating the confidence for each candidate, if the confidence
passes a threshold, the candidate will be selected as a pattern.
f or the formal description, we define a function mop :p(u  !fu  !f)! b (p(uf
uf)) for transforming a set of cases to a multiset of the pairs of forms, and a
function mof :p(u  !f)! b (p(uf))for returning a multiset of forms by the same
giving io-log, which is adopted to generate the set of cases. let q2 u fld be
the case identifier, x=mop (fc(s; q)) be a multiset of the pattern candidates,
ifpc= (f; f′)2x is a pattern candidates, s.t. f2 u f; f′2 u f,f̸=f′.
lety=mof (l)be a multiset of forms; and let m be a multiset. the function14 gao et al.
count m:m!n+returns the counting number for an element in multiset m .
the function conf pt:uf u f![0;1] computes the confidence of a giving
pattern candidate, its formula is equation 2.
pc= (f; f′)
conf pt(pc) =count x(pc)
count y(f)(2)
if the pattern candidate’s confidence is greater than a certain threshold, it will
be a pattern, and this threshold is set by the user.
in step (4), we label f as by a certain pattern. a labeled f a lfa2 u  !fb
is a pair of an f a and a boolean value. firstly , we label cases by a pattern. if a
case’s the first f a and the second f a happened on the pattern’s corresponding
forms, the first f a will be signed the true label, otherwise, the false label, and
the second f a is ignored in the next step. secondly , we label all other f as that
do not belong to a case, by the same pattern. if the f a occurred on the pattern’s
first form, it is labeled as false , otherwise, it will be ignored in the next step
and the steps in the response learner. meanwhile, the first element of a case is
labeled as true by a pattern, we call this case is aligned with this pattern.
as shown by the output of step (4) in figure 7 , the rounded rectangle with
the green background is labeled as true by the pattern (fi; fn), the one with
rose color is labeled as false , and the one with white is ignored.
in step (5), we train a condition function from a sequence of labeled f as .
this is a typical supervised learning scenario, we adopt the decision t ree (dt)
[9] algorithm in this research. there are two points in this step, (i) we transform
the sequence of labeled f as to the input table of dt, the attribute columns are
the form fields in the “enter” and “leave” form states of f a, the label column is
the boolean label which is generated in step 4. (ii) w e train a dt model based
on the input table. the condition function will apply the trained dt model to
giving the boolean result if the input f a happened on the pattern’s the first
form; otherwise, it will return false . in this step, we not only gain the dt
model, but also the precision of the model. and the dt model’s precision is the
rule’s precision.
as illustrated in figure 7 , each row of the input table corresponds a labeled
f a in step (4). based on this input table, we train a dt model. in the sdap
scenario, the dt model should able to represent the logic of “it will return true
if the result field is changed from estimating to pass” .
5.2 the response learner in the srl algorithm
using the sdap scenario, we explained the copy response to illustrate one type
of the response function. a copy response means that the function in def.11 is
an identity function (i.e., the input equals to its output). the main issue of this
part is gaining the form field mapping , which is defined in def.11. there are
two steps in this part, and the learning process of the sdap scenario’s response
function could be illustrated as figure 8 .automating robotic process automation 15
fig. 8: adopting learning algorithm of response functions at the sdap scenario.
in step (1), given all the cases found by the condition learner, we retain
the set of cases that is aligned with a given pattern. let p= (f; f′)be a
pattern, and ac= (  !f ;  !f′)a case. case ac is aligned with pif and only if
f(  !f) =f^f(  !f′) =f′. the output is, thus, a set of cases ac u  !f u  !fthat are aligned with p(i.e.,8ac2ac :ac isaligned with p). f or instance, as
shown in figure 8 , the cases that are aligned with the given pattern p= (fi; fn)
are highlighted after the step (1).
in step (2), we detect the copy relation between the form fields of a set of
aligned cases. a copy relation cr2 u fld u fld is a pair of form fields, where the
values of these two fields are the same, i.e., is copied, and the two fields are not
in the same form. this step is similar with the step (3) in the condition learner,
which is for detecting the pattern. the two main substeps of this step are (i)
extracting candidates for the copy relation from the set of aligned cases and (ii)
computing a confidence for each candidate. if the confidence passes a threshold,
the candidate is said to be a copy relation. a set of copy relations together with
the identity function build a copy response.
f or substep (i), a candidate is extracted from an aligned case, the first element
of the candidate is a field in the aligned case’s the first f a’s “leave” state; simi-
larly , the second element of this candidate is a field in the aligned case’s the sec-
ond f a’s “leave” state. moreover, these two fields are holding the same value. w e
define a function fcr:p(u  !f u  !f)↛b(p(ufld u fld)) which detects the can-
didates. let  !f=(f;ϕ;^ϕ; tb; tf; u)2u  !f,  !f′=(f′;ϕ′;^ϕ′; t′
b; t′
f; u)2u  !fbe two arbi-
trary f as on f andf′. the multiset of candidates are generated as fcr(ac) =[
(q; q′)j(  !f ;  !f′)2ac^(q; q′)2dom (^ϕ)dom (^ϕ′)^^ϕ(q) = ^ϕ′(q′)]
. f or instance,
an output of the sdap scenario is [(name,age)2, (name,name)97, (name,gender)1].16 gao et al.
f or the substep (ii), we compute the confidence for each candidate to deter-
mine if it is a copy relation, by using the relative frequency of the candidate
in the obtained multiset. f or a formal description, let mc =fcr(ac)be a
multiset of the copy relation candidates; cc= (q; q′)2mc be a candidate;
conf cr:ufld u fld![0;1] be a total function for calculating the confidence,
its formula is in equation 3 .
cc= (q; q′)2mc
conf cr(cc) =count mc(cc)
jmcj(3)
if a candidate’s confidence is above a certain threshold, the candidate is se-
lected as a copy relation. meanwhile, this threshold is set by the user. f or exam-
ple, given the multiset returned by the previous step, conf cr (name,age)=0.02,
conf cr (name,name)=0.97, conf cr (name,gender)=0.01. if the user set the
confidence to 0.9. the (name,name) is selected as a copy relation.
as illustrated in figure 8 , the step (2) detects the copy relations from the
set of aligned cases. the values, which are holding by the fields “name”, “age”,
“gender” in the ”leave” state on fi’s f as, are always equivalent to the values,
which are in the fields “name”, “age”, “gender” of the ”leave” state in fn’s
f as. thus, these threes copy relations are detected. f urthermore, the set of these
threes copy relations is the field mapping , the identity function is the value
transfer function , they build the copy response function for the sdap scenario.
5.3 the rule base and the rule selector in the srl algorithm
in the rule selector, the rules are picked based on a certain criterion, in the srl
algorithm, we use the precision as the criterion. in principle, each rule classifies
an observed f a true or false ; since we are in the training phase, we know the
true positive and false positive, which we use to calculate the precision measure
[9]; as a result, if an observed f a satisfies multiple rules’ condition, we will select
the rule with the highest precision measures from the srl rule base.
5.4 implementation
the implementation is a proof of concept for the f2r approach and srl algo-
rithm, which supports the rp a solution to interact with web-pages. w e devel-
oped a chrome-extension (running in chrome’s back-end) that collects io-log
and a web-service that receives io-log from the chrome-extension, holds the rule
base, and runs the srl and the rule selector. w e adopted selenium (w eb-page
automation software) to translate each f a into a sequence of low-level move-
ments on ui. the code together with screencasts for the f2r approach is publicly
available at github ( https://github.com/frankbgao/f2r_approach_rpa ).automating robotic process automation 17
6 conclusion and f uture w ork
in conclusion, this research provides the skeleton for our future studies in the
area of rp a. w e discussed the limitations in the current rp a techniques. f or
solving these issues, we provide the f2r approach, it formalizes the critical no-
tions such as form, io-log, and rule. these notions allow the f2r approach to
automatically identify tasks, deduce rules, and apply rules. w e provided algo-
rithms to learn folc as the conditions of rules and copy responses. it makes
the concepts of the f2r approach much more concrete.
f or future work, we consider dropping certain assumptions that are made in
this paper. firstly , in the definition of f a, an f a consists of two form states
which are collected at the points in time at which the user enters and leaves the
form instance. in the future, we will define the running f as, which collects more
form states at different timestamps.
secondly , in the definition of t ransform response, we define :q↛q′;
q:uv al! u v al , which are two “one to one” mappings. w e plan to define other
types of and, i.e., “one to many” or “many to one” mappings.
thirdly , in learning simple rules, we assume there is a field that is the case
identifier. however, this assumption does not always hold. thus, detecting the
case without the identifier is a research topic for the future.
finally , in order to perform a response, we use the rule to check the condition
and return an f a. f or future work, we aim to develop a language to specify the
rule’s response. this language would extend the current definition of rule such
that it can describe more complex tasks. the rp a solution can then be trained
to execute this language to deliver more sophisticated f as.
references
1. van der aalst, w.m.p .: process mining - data science in action, second edition.
springer (2016). https://doi.org/10.1007/978-3-662-49851-4
2. van der aalst, w.m.p ., bichler, m., heinzl, a.: robotic process automation (2018)
3. aguirre, s., rodriguez, a.: automation of a business process using robotic pro-
cess automation (rp a): a case study . in: wea. pp. 65–71. springer (2017)
4. asatiani, a., penttinen, e.: t urning robotic process automation into commercial
success–case opuscapita. journal of information t echnology t eaching cases 6(2),
67–74 (2016)
5. chacón-montero, j., jiménez-ramírez, a., enríquez, j.: t owards a method for
automated t esting in robotic process automation projects. in: proceedings of
the 14th international w orkshop on ast. pp. 42–47. ieee press (2019)
6. cichocki, a., ansari, h.a., rusinkiewicz, m., w oelk, d.: w orkflow and process au-
tomation: concepts and t echnology , vol. 432. springer science & business media
(2012)
7. dumas, m., la rosa, m., mendling, j., reijers, h.a.: f undamentals of business
process management, second edition. springer (2018)
8. geyer-klingeberg, j., nakladal, j., baldauf, f., v eit, f.: process mining
and robotic process automation: a perfect match. in: bpm (disserta-
tion/demos/industry). pp. 124–131 (2018)18 gao et al.
9. han, j., pei, j., kamber, m.: data mining: concepts and t echniques. elsevier
(2011)
10. jimenez-ramirez, a., reijers, h.a., barba, i., del v alle, c.: a method to improve
the early stages of the robotic process automation lifecycle. in: caise. pp.
446–461. springer (2019)
11. lacity , m., willcocks, l.: robotic process automation: the next t ransformation
lever for shared services. london school of economics outsourcing unit w orking
papers 7, 1–35 (2015)
12. leopold, h., van der aa, h., reijers, h.a.: identifying candidate t asks for robotic
process automation in t extual process descriptions. in: enterprise, business-
process and information systems modeling. pp. 67–81. springer (2018)
13. linn, c., zimmermann, p ., w erth, d.: desktop activity mining - a new level of
detail in mining business processes. in: w orkshops of the informa tik 2018-
architekturen, prozesse, sicherheit und nachhaltigkeit (2018)
14. mendling, j., decker, g., richard, h., hajo, a., ingo, w., et al.: how do ma-
chine learning, robotic process automation, and blockchains affect the human
f actor in business process management? communications of the association for
information systems 43 (art. 19), 297–320 (2018)
15. scheer, a.w., abolhassan, f., jost, w., kirchmer, m.: business process automa-
tion. springer (2004)
16. t er hofstede, a.h., v an der aalst, w.m., adams, m., russell, n.: modern business
process automation: y a wl and its support environment. springer science &
business media (2009)
17. t ornbohm, c.: market guide for robotic process automation software. gart-
ner.com (2017)
18. t ripathi, a.m.: learning robotic process automation: create software robots
and automate business processes with the leading rp a t ool–uipath. packt pub-
lishing ltd (2018)
19. willcocks, l.p ., lacity , m., craig, a.: the it f unction and robotic process au-
tomation (2015)