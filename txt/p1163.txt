fundamenta informaticae xxi (2001) 1001–1040 1001
doi 10.3233/fi-2016-0000
ios press
discovering object-centric petri nets
wil m.p. van der aalst
alessandro berti
process and data science (pads), rwth aachen university, aachen, germany
fraunhofer institute for applied information technology, sankt augustin, germany
wvdaalst,a.berti@pads.rwth-aachen.de
abstract. techniques to discover petri nets from event data assume precisely one case identiﬁer
per event. these case identiﬁers are used to correlate events, and the resulting discovered petri net
aims to describe the life-cycle of individual cases. in reality, there is not one possible case notion,
but multiple intertwined case notions. for example, events may refer to mixtures of orders, items,
packages, customers, and products. a package may refer to multiple items, multiple products,
one order, and one customer. therefore, we need to assume that each event refers to a collection
of objects, each having a type (instead of a single case identiﬁer). such object-centric event logs
are closer to data in real-life information systems. from an object-centric event log, we want to
discover an object-centric petri net with places that correspond to object types and transitions
that may consume and produce collections of objects of different types. object-centric petri nets
visualize the complex relationships among objects from different types. this paper discusses a
novel process discovery approach implemented in pm4py. as will be demonstrated, it is indeed
feasible to discover holistic process models that can be used to drill-down into speciﬁc viewpoints
if needed.
keywords: process mining, petri nets, process discovery, multiple viewpoint models
1. introduction
the synthesis of “higher-level” process models from “lower-level” behavioral speciﬁcations has been
subject of active research for decades. examples of such “higher-level” process models are (col-
ored) petri nets, bpmn models, statecharts, etc. examples of “lower-level” behavioral speciﬁcations
serving as input for synthesis are transition systems, languages, partial orders, and scenarios. in the1002 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
context of petri nets, the “theory of regions” has been very inﬂuential. regions were introduced for
elementary nets and transition systems in the seminal paper [35]. the goal was to create a petri net
with a reachability graph that is isomorphic to the transition system used as input. the core idea has
been generalized in numerous directions. different classes of target models have been investigated
[15, 16, 32, 43], e.g., bisimilar place transition (p/t) nets [29], petri nets with arc weights [27, 26],
petri nets with a/sync connections [42], -nets [43], zero-safe nets [30], etc. typically, a transition
system is used as input. however, there are various region-based approaches taking as input lan-
guages [17, 51, 18, 33, 20, 54], partial orders/scenarios [53, 19, 52], or other “lower-level” behavioral
speciﬁcations.
process mining is related to the ﬁeld of synthesis (in particular language-based regions). however,
the assumptions and goals are very different. whereas classical synthesis approaches aim to obtain
a “higher-level” process model that compactly describes the behavior of a “lower-level” behavioral
speciﬁcation, process mining techniques face a more difﬁcult problem. the event logs used as input for
process discovery typically contain only a fraction of the possible behavior. traces in an event log can
be seen as examples. if there are loops, one cannot expect to see all possible traces. if a model contains
concurrency, one cannot expect to see all possible interleavings. if the model has multiple choices,
one cannot expect to witness all possible combinations. there have been many attempts to extend
region-based approaches to this setting [25, 17, 61, 63]. unfortunately, region-based techniques are
often computationally intractable, lead to overﬁtting models, and/or cannot discover process constructs
such as skipping and mixtures of choice and synchronization (e.g., or-joins). hence, several more
scalable and robust techniques have been developed. commercial tools typically still resort to learning
the so-called directly follows graph (dfg) which typically leads to underﬁtting process models [3].
when activities appear out of sequence, loops are created, thus leading to spaghetti-like diagrams
suggesting repetitions that are not supported by the data. the inductive mining techniques [45, 46]
and the so-called split miner [14] are examples of the state-of-the-art techniques to learn process
models. these techniques are able to generalize and uncover concurrency.
this paper focuses on process discovery. however, rather than presenting a new discovery tech-
nique for traditional event logs, we start from object-centric event logs [4]. in a traditional event log
each event is related to one activity, one timestamp, and one case (i.e., a process instance). we still
make the assumption that each event refers to an activity and a point in time. however, we do not
assume the existence of a single case notion. instead, an event may refer to any number of objects
and these objects may be of different types. this extends the reach of process mining dramatically.
the step is comparable to going from place transition (p/t) nets to colored petri nets. objects can be
viewed as colored tokens and object types can be seen as color sets (i.e., place types).
based on object-centric event logs, we aim to automatically discover object-centric petri nets .
such petri nets have typed places that refer to the object types in the event log. just like in colored
petri nets, a transition may consume or produce multiple tokens from a place during one execution. in
this paper, we present the ﬁrst technique to discover such nets. in the related work section (section 9),
we elaborate on the relation to earlier approaches such as the object-centric behavioral constraint
(ocbc) models [49], synchronized transitions systems [34, 62], and artifact-centric discovery ap-
proaches [37, 38, 56].
figure 1 illustrates the approach presented. object-centric event logs can be extracted from anyw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1003
each row corresponds to an event which 
refers to one activity and any number of 
objects of (possibly many ) different types .extract from 
data sources
one of the 21887 events : 
 activity :  package delivered
 time :  2019 -12-24 20 :46:47
 orders involved : {991119 ,991030 ,991209 ,991254 , 
991213 ,991206 }
 items involved : {884386 ,884020 ,884749 ,884930 , 
884926 ,884925 ,884766 ,884927 ,884736 }
 packages involved : {660784 }
 customers involved : {kefang ding }
 products involved : {ipad air ,echo dot ,macbook 
pro,ipad air ,kindle paperwhite ,ipad air ,ipad pro , 
ipad ,iphone 11 pro} 
 total price : € 6.829,99 
 total weight : 4,719 kgautomatically 
discovered object -
centric petri net object -centric event log
 object -centric petri net
figure 1. overview of the approach presented in this paper. object-centric event logs are used as an interme-
diate format in between the actual data sources and traditional event logs requiring a single case notion. using
this input, we discover object-centric petri nets that are able to describe multiple object types in a single model.
information system [4]. these logs can be seen as an intermediate format closer to the actual data
collected by today’s information systems. unlike traditional event logs (e.g., xes logs), an event
may refer to multiple objects and is not forced to be assigned to a single case. enterprise information
systems (eis), customer relationship management (crm) systems, healthcare information systems
(his), e-learning systems, production systems, supply chain systems, etc. typically store informa-
tion on a range of objects (customer, orders, patients, products, payments, etc.) in multiple tables
that refer to each other. figure 1 shows the objects related to one “package delivered” event. the1004 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
event refers to six orders, nine items, one package, one customer, and nine products. in total, there
are 22,367 events. figure 1 shows an object-centric petri net (not intended to be readable) discovered
while focusing on orders, items, and packages. the places and arcs are typed. the colors red, green,
and purple refer to respectively orders, items, and packages.
just like for traditional process mining approaches it is possible to ﬁlter and seamlessly simplify
the process model. by focusing on a particular object type, it is also possible to create traditional
events logs that can be analyzed using traditional process mining techniques.
the remainder of this paper is organized as follows. section 2 introduces event logs and process
models. object-centric event logs are introduced and motivated in section 3. given such logs, we
ﬁrst discuss techniques to learn process models for a single object type in section 4. in section 5,
we introduce object-centric petri nets, i.e., petri nets with places referring to object types. section 6
presents the main contribution of this paper: an approach to learn object-centric petri nets from object-
centric event logs. the discovery technique has been implemented in pm4py , an open-source process
mining platform written in python. section 7 presents the implementation and section 8 demonstrates
the feasibility of the approach. related work is discussed in section 9. section 10 concludes the paper
with a few ﬁnal remarks.
2. preliminaries
first, we introduce some preliminaries for people not familiar with process mining and accepting petri
nets. input for process mining is an event log. a traditional event log views a process from a particular
angle provided by the case notion that is used to correlate events . each event in such an event log
refers to (1) a particular process instance (called case), (2) an activity , and (3) a timestamp . there may
be additional event attributes referring to resources, people, costs, etc., but these are optional. with
some effort, such data can be extracted from any information system supporting operational processes.
process mining uses these event data to answer a variety of process-related questions. process mining
techniques such as process discovery, conformance checking, model enhancement, and operational
support can be used to improve performance and compliance [2].
each event in an event log has three mandatory attributes: case, activity, and timestamp. the
case notion is used to group events, e.g., all events corresponding to the same order number are taken
together. the timestamps are used to order the events and can be used to analyze bottlenecks, delays,
etc. there may be many additional attributes, e.g., costs, resource, location, etc. however, most
process discovery techniques ﬁrst learn a model where only the order of activities within cases matters.
once the control-ﬂow is clear, other attributes (e.g., time) can be added by replaying the event log on
the model [2]. therefore, we deﬁne a so-called “simple event log” that only records the ordering of
activities for each case. technically, an event log is a multiset of traces. b2b(x) =x!inis a
multiset over xwhere element x2xappearsb(x)times. for example, in b= [a5;b2;c],aappears
b(a) = 5 times,btwice, andconce.
deﬁnition 2.1. (simple event log)
letuactbe the universe of activity names. a trace 2u
actis a sequence of activities. l2b(u
act)
is an event log, i.e., a multiset of traces. usel=b(u
act)is the universe of simple event logs.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1005
for example, uact=fpo;pi;sh;in;sr;pa;co;:::gwhere podenotes activity place order ,pi
denotes activity pick item ,shdenotes activity ship item ,indenotes activity send invoice ,srdenotes
activity send reminder ,padenotes activity pay order , and codenotes activity mark as completed .
using this more compact notation we show three example traces: 1=hpo;in;pi;sr;sh;pa;coi,
2=hpo;pi;sh;in;pa;coi, and3=hpo;in;sr;sr;pi;sr;pa;sh;coi. obviously, multiple cases
can have the same trace. in an event log l= [1435;2366;3233;:::]the above three traces appear
respectively 435, 366, and 233 times. given such an event log, process discovery techniques are
able to learn a process model describing the observed traces. such techniques often take into account
frequencies, e.g., the model should cover the most frequent traces but may decide to abstract from
infrequent ones. figure 2 shows a process model discovered for event log l.
po
in pi
sr
pa sh
coplace 
order
pick 
item
ship 
itemsend 
invoice
pay 
order send 
reminder
mark as 
completedp2p1
p3
p4 p5
p6 p7
p8
figure 2. an accepting petri net composed of eight places and seven transitions.
the discovered process model in figure 2 is represented as an accepting petri net where the transi-
tions are labeled . we assume that the reader is familiar with standard petri nets notations, but provide
a few deﬁnitions to make the key notions explicit. we use petri nets with a labeling function andﬁnal
marking . this is driven by requirements from process mining. the labeling function is needed to
model skips and duplicate activities. the ﬁnal marking is needed because traces have a deﬁned start
and end.
deﬁnition 2.2. (labeled petri net)
a labeled petri net is a tuple n= (p;t;f;l )withpthe set of places, tthe set of transitions,
p\t=;,f(pt)[(tp)the ﬂow relation, and l2t6!uacta labeling function.
a petri net deﬁnes a directed graph with nodes p[tand edgesf. the state of a petri net, called1006 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
marking , is a multiset of places ( m2b(p)). a transition t2tisenabled in markingmof netnif
each of its input places t=fp2pj(p;t)2fgcontains at least one token. an enabled transition
tmay ﬁre, i.e., one token is removed from each of the input places tand one token is produced for
each of the output places t=fp2pj(t;p)2fg. assume that [p1]is the initial marking of
the petri net in figure 2. there are 11 markings reachable from this initial marking, including [p1],
[p2;p3],[p4;p7], and [p8].
note that the labeling function lmay be partial and non-injective. this means that multiple tran-
sitions may refer to the same activity and that there may be transitions that are “silent” and do not
correspond to an activity. any ﬁring sequence of a labeled petri net corresponds to a visible trace
obtained by mapping transitions onto activities using l. firing an unlabeled transition does not add an
activity to the trace. in figure 2, all transitions are visible and unique. 1,2, and3are examples of
visible traces (assuming the short names as activity labels).
for process mining, we often focus on so-called accepting petri nets that have an initial marking
and a ﬁnal marking. the reason is that we want to have a model that deﬁnes a language corresponding
to the process that was used to produce the event log.
deﬁnition 2.3. (accepting petri net)
an accepting petri net is a triplet sn= (n;m init;mnal)wheren= (p;t;f;l )is a labeled petri
net,minit2b(p)is the initial marking, and mnal2b(p)is the ﬁnal marking. uapn is the
universe of accepting petri nets.
in figure 2, the initial marking minit= [p1]and the ﬁnal marking mnal= [p8]are denoted
using the start and stop symbol.
deﬁnition 2.4. (language of an accepting petri net)
an accepting petri net sn= (n;m init;mnal)deﬁnes a language (sn)that is composed of all vis-
ibletraces (ignoring transition occurrences not having a label) starting in minitand ending in mnal.
the accepting petri net depicted in figure 2 has inﬁnitely many visible traces due to the loop
involving sr. without the loop, there would be six possible visible traces.
assuming the basic setting with simple event logs and accepting petri nets, we can now formally
deﬁne the notion of process discovery . for any event log, we would like to construct a corresponding
process model.
deﬁnition 2.5. (process discovery technique)
discovery technique disc is a function mapping simple event logs onto accepting petri nets, i.e.,
disc2usel!uapn.
what makes process mining very difﬁcult is that the event log only contains example behaviors.
if figure 2 represents the real process, we have the problem that no event log will contain all of its
traces (due to the loop). even when there are no loops, it is very unlikely to observe all possible traces
for real-life processes due to combinations of choices and the interleaving of concurrent activities.
typically, only a fraction of the possible process is observed. moreover, the event log may contain
noise and infrequent behaviors that should not end up in the process model. this leads to notions suchw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1007
as recall (also called ﬁtness), precision, generalization, and simplicity [2]. these are outside of the
scope of this paper. however, we abstractly deﬁne the notion of conformance checking .
deﬁnition 2.6. (conformance checking technique)
conformance checking technique conf is a function mapping a pair composed of an event log and an
accepting petri nets onto conformance diagnostics, i.e., conf2(useluapn)!udiag.
conf(l;sn)2udiagprovides diagnostics related to recall, precision, generalization, simplicity,
etc. an example would be the fraction of traces in the event log that can be replayed by the accepting
petri net: conf(l;sn) =j[2lj2(sn)]j=jlj. givenl0= [hpo;pi;sh;in;pa;coi8;hpo;
sh;pi;in;pa;coi2]andsnshown in figure 2, conf(l0;sn) = 0:8given this conformance notion.
many other measures and diagnostics are possible. however, we leave udiagdeliberately vague.
3. object-centric event logs
section 2 provided a basic introduction to process mining, assuming that there is a clear case notion.
in this section, we show that, for many applications, this assumption is not realistic (section 3.1).
next, we formalize the notion of object-centric event logs (section 3.2).
3.1. what if there is not a single case identiﬁer?
in many applications, there are multiple candidate case notions leading to different views on the same
process [4]. moreover, one event may be related to different cases ( convergence ) and, for a given case,
there may be multiple instances of the same activity within a case ( divergence ). to create a traditional
process model, the event data need to be “ﬂattened”. there are typically multiple choices possible,
leading to different views that are disconnected or inconsistent.
to introduce the problem, consider the event log shown in table 1. the table shows that each
order may correspond to multiple items that are picked and shipped separately. this is a more realistic
assumption (shops tend to allow customers to buy more than one product per order).
table 1 has a column for order identiﬁers and item identiﬁers. order 99001 corresponds to three
items (88124, 88125, and 88126), order 99002 corresponds to two items (88127 and 88128), order
99003 corresponds to one item (88129), and order 99004 corresponds to ﬁve items (88130, 88131,
88132, 88133, and 88134). the pick and ship activities are executed for individual items. an order is
marked as completed when all items have been picked and shipped and the order itself was paid. note
that the events place order andmark as completed for order 99001, both refer to four objects (one order
and three items). the latter number is variable. for example, the event place order for order 99003
refers to only two objects. this cannot be expressed using the accepting petri nets introduced before.
transitions need to consume and produce a variable number of tokens of different types. therefore,
we propose to use object-centric petri nets . note that we do notpropose such nets as a new modeling
language. it can be viewed as a subclass of colored petri nets, but our focus is on learning a model
describing the data in table 1. hence, we limit the modeling notation to what can be discovered for
such data.1008 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
table 1. a fragment of an event log: each line corresponds to an event, possibly referring to multiple objects
(i.e., orders and items).
activity timestamp order item
::: ::: ::: :::
place order 25-11-2019:09.35 f99001gf88124;88125;88126g
pick item 25-11-2019:10.35 ; f88126g
place order 25-11-2019:11.35 f99002gf88127;88128g
pick item 26-11-2019:010.25 ; f88124g
send invoice 27-11-2019:08.12 f99001g ;
send invoice 28-11-2019:09.35 f99002g ;
pick item 29-11-2019:09.35 ; f88127g
send reminder 29-11-2019:10.35 f99002g ;
pick item 29-11-2019:11.15 ; f88128g
ship item 29-11-2019:12.35 ; f88124g
pick item 29-11-2019:13.30 ; f88125g
send reminder 29-11-2019:14.35 f99001g ;
ship item 29-11-2019:15.15 ; f88125g
send reminder 29-11-2019:16.15 f99002g ;
ship item 29-11-2019:17.45 ; f88126g
ship item 29-11-2019:18.00 ; f88128g
send reminder 30-11-2019:09.35 f99002g ;
ship item 30-11-2019:10.05 ; f88127g
pay order 30-11-2019:11.45 f99002g ;
pay order 30-11-2019:12.55 f99001g ;
mark as completed 01-12-2019:09.35 f99001gf88124;88125;88126g
place order 02-12-2019:10.40 f99003g f88129g
mark as completed 04-12-2019:11.05 f99002gf88127;88128g
place order 06-12-2019:14.18 f99004gf88130;88131;88132;88133;88134g
::: ::: ::: :::
figure 3 shows the object-centric petri net we want to discover based on the event data in table 1.
there are now two types of places: the places that correspond to orders (colored green) and the places
that correspond to items (colored blue). transitions are colored based on the object types they refer
to. note that transitions poandcohave two colors. a transition may consume multiple tokens from
a place or produce multiple tokens for a place. the places and arcs involved in events that consume
or produce multiple objects have compound double arrows to highlight this. transition poin figure 3
consumes one order object from place o1and a variable number of items from place i1.poproduces
one order object for place o2and a variable number of items for place i2. transition piin figure 3
consumes one item object from place i2and produces one item object for place i3. the items are
also shipped individually. however, transition coin figure 3 consumes one order object from place
o4and all items corresponding to the order from place i4.
although existing discovery techniques cannot handle the event data in table 1, this is still a
relatively simple scenario since there is a one-to-many relationship between orders and items. in real-
life applications, there may also be many-to-many relationships. to illustrate this, consider the eventw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1009
po
in pi
sr
pa sh
coplace 
order
pick 
item
ship 
itemsend 
invoice
pay 
order send 
reminder
mark as 
completedo2o1
i2
o3 i3
o4 i4
o5i1
order
order
order
order
orderi5item
item
item
item
item
figure 3. an object-centric petri nets with two object types: order anditem .
table 2. a small fragment of a simple event log with three types of objects.
activity timestamp order item route
::: ::: ::: ::: :::
place order 25-11-2019:09.35 f99001gf88124;88125;88126g;
place order 25-11-2019:11.35 f99002gf88127;88128g;
::: ::: ::: ::: :::
start route 25-11-2019:11.35 ;f88124;88127gf66222g
end route 25-11-2019:11.35 ;f88124;88127gf66222g
::: ::: ::: ::: :::
start route 25-11-2019:11.35 ;f88125;88126;88128gf66223g
end route 25-11-2019:11.35 ;f88125;88126;88128gf66223g
::: ::: ::: ::: :::
mark as completed 01-12-2019:09.35 f99001gf88124;88125;88126g;
mark as completed 04-12-2019:11.05 f99002gf88127;88128g;
::: ::: ::: ::: :::
log fragment depicted in table 2 where we added routes. on any particular route, multiple items can
be delivered. the ship item activity is now replaced by the start route andend route activities that may
refer to items from different orders. as shown in table 2, route 66222 refers to two items (88124 and1010 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
88127) belonging to orders 99001 and 99002. route 66223 refers to three items (88125, 88126, and
88128) belonging to orders 99001 and 99002. again it is obvious that this cannot be modeled using
traditional process models that assume a single case notion.
po
in pi
sr
pa
coplace 
order
pick 
itemsend 
invoice
pay 
order send 
reminder
mark as 
completedo2o1
i2
o3
i3
o4i5
o5i1
order
order
order
order
orderi6item
item
item
item
itemststart 
route
enend 
route
r3
routeitem routerouter1
r2 i4
figure 4. an object-centric petri nets with three object types: order ,item , and route .
figure 4 shows the object-centric petri net discovered from the event log referred to by table 2.
there are now three types of places: order places (colored green), item places (colored blue), and route
places (purple). transition stin figure 4 consumes a variable number of item objects from place i3
and one route object from place r1.stproduces a variable number of item objects for place i4and
one route object for place r2. the coloring of the transitions and places and the two different types of
arcs show the behaviors observed in the event log.
the problem is that existing process mining techniques assume a “ﬂattened event log” where each
event refers to precisely one case. however, we would like to see process models such as the one
depicted in figure 4. one quickly encounters the problems described in this section when applying
process mining to erp systems from sap, oracle, microsoft, and other vendors of enterprise software.
3.2. formalizing object-centric event logs
tables 1 and 2 illustrate the type of data we use as input for discovery. such data are in-between
the real data in information systems (e.g., multiple tables in a relational database) and the traditionalw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1011
event data stored in the extensible event stream (xes) format [40]. whereas xes requires one case
identiﬁer per event, our format supports any number of objects of different types per event. to deﬁne
ourobject-centric event logs , we ﬁrst deﬁne several universes used in the remainder (based on [4]).
deﬁnition 3.1. (universes)
we deﬁne the following universes to be used throughout the paper:
•ueiis the universe of event identiﬁers,
•uactis the universe of activity names (also used to label transitions in an accepting petri net),
•utimeis the universe of timestamps,
•uotis the universe of object types (also called classes),
•uoiis the universe of object identiﬁers (also called entities),
•type2uoi!uotassigns precisely one type to each object identiﬁer,
•uomap =fomap2uot6! p (uoi)j 8ot2dom (omap )8oi2omap (ot)type(oi) = otgis the
universe of all object mappings indicating which object identiﬁers are included per type,1
•uattis the universe of attribute names,
•uvalis the universe of attribute values,
•uvmap=uatt6!uvalis the universe of value assignments,2and
•uevent=ueiuactutimeuomapuvmap is the universe of events.
an evente= (ei;act;time;omap;vmap )2uevent is characterized by a unique event identiﬁer
ei, the corresponding activity act, the event’s timestamp time , and two mappings omap andvmap
for respectively object references and attribute values.
deﬁnition 3.2. (event projection)
givene= (ei;act;time;omap;vmap )2uevent ,ei(e) =ei,act(e) =act,time(e) =time ,
omap(e) =omap , andvmap(e) =vmap .
omap(e)2uot6!p(uoi)maps a subset of object types onto sets of object identiﬁers for an event
e. consider for example the ﬁrst visible event in table 2 and assume this is e.omap(e)(order ) =
f99001g,omap(e)(item) =f88124;88125;88126g, andomap(e)(route ) =;. moreover,act(e) =
place order andtime(e) =25-11-2019:09.35. dom(vmap(e)) =;since no attribute values are men-
tioned in table 2. if the event would have a cost of 30 euros and location aachen, then vmap(e)(cost) =
30andvmap(e)(location ) =aachen .
anobject-centric event log is a collection of partially ordered events . event identiﬁers are unique,
i.e., two events cannot have the same event identiﬁer.
1p(uoi)is the powerset of the universe of object identiﬁers, i.e., objects types are mapped onto sets of object identiﬁers.
omap2uot6!p(uoi)is a partial function. if ot62dom(omap ), then we assume that omap (ot) =;.
2uatt6!uvalis the set of all partial functions mapping a subset of attribute names onto the corresponding values.1012 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
deﬁnition 3.3. (object-centric event log)
l= (e;e)is an event log with euevent andeeesuch that:
•edeﬁnes a partial order (reﬂexive, antisymmetric, and transitive),
•8e1;e22eei(e1) =ei(e2))e1=e2, and
•8e1;e22ee1ee2)time(e1)time(e2).
deﬁnition 3.3 allows for partially ordered event logs. however, in practice, we often use a total
order, e.g., events are ordered based on timestamps and when two events have the same timestamp
we assume some order. in the tabular format used before (e.g., table 2) we were also forced to use a
total order. however, there are process discovery techniques that take into account causalities [4, 55].
these can exploit such partial orders.
4. discovering petri nets for a single object type
object-centric event logs generalize the traditional event log notion where each event has precisely
one case identiﬁer. we can mimic such logs using a special object type case2uotsuch that
jomap(e)(case)j= 1 for any event e2e. since traditional process mining techniques assume
this, it is common practice to convert event data with events referring to a variable number of objects
to classical event logs by “ﬂattening” the event data. assume that we take a speciﬁc object type as a
case identiﬁer. if an event has multiple objects of that type, then we can simply create one event for
each object. if an event has no objects of that type, then we simply omit the event. if an event has
precisely one object of the selected type, then we keep that event. this can be formalized as follows.
deﬁnition 4.1. (flattening event logs)
letl= (e;e)be an object-centric event log and ot2uotan object type serving as a case notion.
the ﬂattened event log is lot= (eot;ot
e)with:3
•ei= ((ei(e);i);act(e);time(e);omap(e)(case;fig);vmap(e))for anye2eandi2
omap(e)(ot),
•eot=feije2e^i2omap(e)(ot)g, and
•ot
e=f(e0
i;e00
j)2eoteotje02e^i2omap(e0)(ot)^e002e^j2omap(e00)(ot)^
e0ee00^(e0=e00)i=j)g.
a ﬂattened event log is still an event log after removing and duplicating events.
lemma 4.2. letl= (e;e)be an object-centric event log and ot2uotan object type serving
as a case notion. the ﬂattened event log lot= (eot;ot
e)is indeed an event log as deﬁned in
deﬁnition 3.3.
3f0=f(x; y)is a function such that dom(f0) = dom(f)[fxg,f0(x) =yandf0(z) =f(z)forz2dom(f)nfxg.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1013
proof:
ot
edeﬁnes a partial order. for any ei2eot,eiot
eei(reﬂexive). if e0
iot
ee00
jande00
jot
ee0
i,
thene0=e00andi=j, and hence also e0
i=e00
j(antisymmetric). if e0
iot
ee00
jande00
jot
ee000
k, then
e0ee00,e00ee000,(e0=e00)i=j), and (e00=e000)j=k). hence,e0ee000(eis
transitive). if e06=e000, thene0
iot
ee000
kdue to the deﬁnition of ot
e. ife0=e000, thene0=e00and
e00=e000. hence,i=jandj=k(see above), and i=k. again we conclude that e0
iot
ee000
k
(transitive). if ei(e0
i) =ei(e00
j), then (e0;i) = (e00;j)making event identiﬁers unique. if e0
iot
ee00
j,
thene0ee00. hence,time(e0
i) =time(e0)time(e00) =time(e00
j)showing that time cannot go
backwards. u t
table 2 shows eight events (the rest is omitted). assume l= (e;e)is the log consisting of only
these eight events. the ﬂattened event log lorder= (eorder;order
e)has four events (the four middle
events in table 2 are removed). the ﬂattened event log litem= (eitem;item
e)has 20 events since all
original events are replicated two or three times. the ﬂattened event log lroute= (eroute;route
e)
has four events.
assume now that l= (e;e)is ﬂattened using object type otleading to event log lot=
(eot;ot
e). we then have a conventional event log with a selected case notion and can apply all exist-
ing process mining techniques. however, ﬂattening the event log using otas a case notion potentially
leads to the following problems.
•deﬁciency : events in the original event log that have nocorresponding events in the ﬂattened
event log disappear from the data set (i.e., omap(e)(ot) =;).
•convergence : events referring to multiple objects of the selected type are replicated, possibly
leading to unintentional duplication (i.e., jomap(e)(ot)j2).
•divergence : events referring to different objects of a type notselected as the case notion are
considered to be causally related. for example, two events refer to the same order but different
times or two events refer to the same route but different items.
deﬁnition 4.3. (deﬁciency, convergence, and divergence)
letl= (e;e)be an object-centric event log and lot= (eot;ot
e)the ﬂattened event log
based on object type ot2uot. evente2ehas a deﬁciency problem if omap(e)(ot) =;
(i.e., the event is ignored when using otas case notion). event e2ehas a convergence prob-
lem ifjomap(e)(ot)j2(i.e., the event is unintentionally replicated when using otas case no-
tion). event e2ehas a divergence problem if there exist another event e02eand object type
ot02uotsuch thatomap(e)(ot)6=;,omap(e0)(ot)6=;,omap(e)(ot0)6=;,omap(e0)(ot0)6=;,
omap(e)(ot) =omap(e0)(ot), andomap(e)(ot0)6=omap(e0)(ot0).
note that in case of divergence, there are two events eande0and two candidate case notions ot
andot0such that both events refer to objects of both object types and the events “agree” on otbut not
onot0.
consider again the eight events shown in table 2. when taking order orroute as the object type
used to ﬂatten the event log, half the events disappear (deﬁciency). when taking item as the object type
used to ﬂatten the event log, the ﬁrst event is replaced by three place order events, the second event is1014 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
replaced by two place order events, etc. this is misleading since these replicated events occurred only
once (convergence). to explain divergence, assume that an order consists of 10 items and object type
order is used to ﬂatten the event log. there will be 10 pick events that are executed in a given order.
although they are independent, they will seem to be causally related (same case) and most discovery
algorithms will introduce a loop, although there is precisely one pick event per item.
po
pi
coplace 
order
pick 
item
mark as 
completedi2
i3
i5i1
i6item
item
item
item
itemststart 
route
enend 
routeitemi4ststart 
route
enend 
route
r3
routerouterouter1
r2po
in
sr
pa
coplace 
order
send 
invoice
pay 
order send 
reminder
mark as 
completedo2o1
o3
o4
o5order
order
order
order
order100
100
100
10050
100 500
500500500500 10
10
10500
figure 5. three accepting petri nets discovered for the three ﬂattened event logs: (eorder;order
e )(left),
(eitem;item
e)(middle), and (eroute;route
e)(right). the numbers in red refer to the total number of tokens
produced or consumed per arc.
figure 5 shows three process models discovered for three ﬂattened event logs: lorder= (eorder;
order
e),litem= (eitem;item
e), andlroute= (eroute;route
e). for example, the accepting petri
net in the middle was discovered based on litem, i.e., the original event log ﬂattened using object type
item. assume that there are 100 orders with on average 5 items per order. this implies that there are
500 items. assume that each route consists, on average, of 50 items that need to be delivered, i.e.,
there are 10 routes in total. these numbers are depicted in figure 5. although the three accepting
petri nets look reasonable, they do not “ﬁt” together (the frequencies of the corresponding activities
are different). for example, in the left model (order) the place order activity is performed 100 times
and in the middle model (item) the same activity is executed 500 times (factor 5). in the right model
(route) the start route activity is performed 10 times and in the middle model (item) the same activity
is executed 500 times (factor 50). these mismatches illustrate the convergence problem. one could
argue that the accepting petri net in the middle is wrong because the frequencies of activities do not
match the frequencies in the original process model.
figure 6 sketches how the problem of incorrect activity frequencies can be resolved using variable
arcs, i.e., arcs that can be used to consume or produce multiple tokens in one step. such “multiset
arcs” are also possible in colored petri nets [12, 41]. when an event was replicated to produce the “ﬂatw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1015
po
pi
coplace 
order
pick 
item
mark as 
completedi2
i3
i5i1
i6item
item
item
item
itemststart 
route
enend 
routeitemi4
500
500500500500
500po
pi
coplace 
order
pick 
item
mark as 
completedi2
i3
i5i1
i6item
item
item
item
itemststart 
route
enend 
routeitemi4
100
100x5100x5 10x5010x50
1010x5010x50500500
500100100x5
100x5
10
500500500500500
500there were 500 item objects 
flowing from  i1 to i6.
activity place order  
occured 100 times .activity place order consumed 100 
times a variable number of  item 
objects from  i1. on average , 5 item 
objects were consumed per round . activity place order produced 100 
times a variable number of  item 
objects from  i1. on average , 5 item 
objects were produced per round . 
activity pick item occurred 
500 times each time 
consuming and producing 
precisely one item object .  activity start route occurred 10 times . 
each time a variable number of item 
objects was consumed from i3 and the 
same number was produced for  i4. on 
average , 50 item objects were 
produced /consumed per round . 
activity end route occurred 10 times . 
each time a variable number of item 
objects was consumed from i4 and the 
same number was produced for  i5. on 
average , 50 item objects were 
produced /consumed per round . activity mark as completed occurred 
100 times . each time a variable number 
of item objects was consumed from i5 
and the same number was produced for  
i6. on average , 5 item objects were 
produced /consumed per round . 
figure 6. the model on the left was discovered for litem= (eitem;item
e). because of ﬂattening, the
frequencies of activities are not correct. however, it is known which transition occurrences belonged to each
event and we can regroup them. this can be used to merge occurrences, leading to the process model on the
right.
model” (e.g., figure 5), we can merge the corresponding transition occurrences into one transition
occurrence that may consume and produce multiple tokens. see for example transition place order . in
the accepting petri net on the left, transition place order ﬁres 500 times when replaying the ﬂattened
event loglitem. however, we know exactly which transition occurrences belong together. this can be
used to reconstruct transition occurrences that consume and produce a variable number of tokens in one
step. for transition place order this means that 500 occurrences are merged onto 100 occurrences that,
on average, consume and produce 5 tokens per arc. to indicate this, we use compound double arrows
with the annotation 1005. next, consider transition start route . in the model on the left, transition
start route ﬁres 500 times. however, we know exactly which of these 500 transition occurrences
belong to the 10 routes. again these low-level transition occurrences can be merged into higher-
level transition occurrences that consume and produce a variable number of tokens in one step. for
transition start route this means that there are 10 occurrences that, on average, consumer and produce
50 tokens per arc. to indicate this, we use again compound double arrows, but now with the annotation
1050. only the occurrences of pick item did not change due to ﬂattening. hence, the corresponding
arcs did not change.
figure 6 sketches how we can create petri nets for one object type where the frequency of each
transition matches the actual number of corresponding events in the event log. these models can be
merged into more holistic process models showing the different object types as is shown next.1016 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
5. object-centric petri nets
as indicated in the previous sections, we need to be able to distinguish the different object types and a
single event (i.e., transition occurrence) may involve a variable number of objects (e.g., one order may
have any number of items). an obvious way to model such processes is to use colored petri nets where
places can have different types [12, 41]. figure 7 shows a screenshot of cpn tools while simulating
the scenario with 100 orders, 500 items, and 10 routes described before. the color sets order ,item,
androute are used to type the places. the ten arcs with the annotation orproduce or consume a
single order. the two arcs with the annotation itproduce or consume a single item. the four arcs
with the annotation rtproduce or consume a single route. there are eight arcs with the annotation its
which is a variable of type items , i.e., a list of items. these consume or produce a variable number of
item objects. the four guards determine the correspondence between orders, routes, and items. for
example, the guard [its=oi(or)]of transition place order speciﬁes the set of items itsinvolved in
a speciﬁc order or. the same guard is used for transition mark as completed . transitions start route
andend route use guard [its=ri(rt)]to determine the items itsinvolved in route rt.
figure 7. a colored petri net in cpn tools [12, 41] modeling the process depicted in figure 4 which was
discovered from the event data in table 2.
figure 7 shows that one can model processes involving multiple objects using colored petri nets
(or related formalisms). however, it is infeasible to discover an arbitrary colored petri net from an
(object-centric) event log. we need a representational bias that corresponds to the information in the
event log. therefore, we aim to discover a speciﬁc type of colored petri net. to simplify matters, we
also abstract from the matching between the different objects (i.e., the guards in figure 7). this allowsw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1017
us to use a more speciﬁc and more abstract representation called object-centric petri net .4
deﬁnition 5.1. (object-centric petri net)
anobject-centric petri net is a tuple on= (n;pt;fvar)wheren= (p;t;f;l )is a labeled petri
net,pt2p!uotmaps places onto object types, and fvarfis the subset of variable arcs.
figure 4 shows an object-centric petri net: p=fo1;:::;o 5;i1;:::;i 6;r1;r2;r3g,t=fpo;in;
pi;:::g,f=f(o1;po);(i1;po);(po;o2);(po;i2);:::g,l(po) =place order ,l(in) =send invoice ,
etc.,pt(o1) = order ,pt(i1) = item ,pt(r1) = route , etc., andfvar=f(i1;po);(po;i2);:::g.
note that the graphical notation in figure 4 fully deﬁnes the object-centric petri net.
deﬁnition 5.2. (well-formed)
leton= (n;pt;fvar)be an object-centric petri net with n= (p;t;f;l ). we introduce the
following notations:
•pl(t) =t[tare the input and output places of t2t,plvar(t) =fp2pjf(p;t);(t;p)g\
fvar6=;gare the input and output places connected through variable arcs, and plnv(t) =fp2
pjf(p;t);(t;p)g\(fnfvar)6=;gare the places connected through non-variable arcs.
•tpl(t) =fpt(p)jp2pl(t)g,tplvar(t) =fpt(p)jp2plvar(t)g, and tplnv(t) =fpt(p)jp2
plnv(t)gare the corresponding place types.
on iswell-formed if for each transition t2t:tplvar(t)\tplnv(t) =;.
in awell-formed object-centric petri net, the arcs should “agree” on variability, i.e., a combination
of an object type and transition has variable arcs or normal arcs but not both. for example, because
(i1;po)2fvaralso(po;i2)2fvar. because (o1;po)62fvaralso(po;o2)62fvar. this assumption
is reasonable when looking at an object-centric event log. per event eand object type ot,omap(e)(ot)
is given. therefore, it makes no sense to consider different sets of objects of the same type otper
transitiont. in the remainder, we limit ourselves to well-formed object-centric petri nets (without
explicitly stating this).
a token denoted by (p;oi)resides in place pand refers to object oi. a marking is a multiset of
such tokens. in the marking [(p1;666);(p2;666);(p2;555);(p3;555)] there are four tokens (place p2
has two tokens referring to objects 555 and 666).
deﬁnition 5.3. (marking)
leton= (n;pt;fvar)be an object-centric petri net with n= (p;t;f;l ).qon=f(p;oi)2
puoijtype(oi) =pt(p)gis the set of possible tokens. a marking mofon is a multiset of
tokens, i.e.,m2b(qon).
to describe the semantics of an object-centric petri net, we use the notion of bindings , similar to
the notion of bindings in colored petri nets. however, now the binding refers to the object references
of the corresponding event in the event log. a binding (t;b)refers to a transition tand a function b
4terms similar to “object petri nets” were already used by r ¨udiger valk, charles lakos, jinzhong niu, li-chi wang, daniel
moldt, and others. note that our nets are different and some overloading of terminology is unavoidable.1018 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
that maps a subset of object types to sets of object identiﬁers. the subset of object types corresponds
to the object types of the surrounding places (i.e., tpl(t)). moreover, for non-variable arcs the binding
should select precisely one object (i.e., jb(ot)j= 1 forot2tplnv(t)). consider transition tand one
of its input place p(i.e.,p2t). iftﬁres with binding (t;b), then pt(p)2dom(b)and the objects
b(pt(p))are removed from input place p. ifpis an output place of t(p2t), then the objects b(pt(p))
are added to output place p. therefore, binding (t;b)fully determines the new marking.
deﬁnition 5.4. (binding execution)
leton= (n;pt;fvar)be an object-centric petri net with n= (p;t;f;l ).b=f(t;b)2t
uomapjdom(b) =tpl(t)^ 8 ot2tplnv(t)jb(ot)j= 1gis the set of all possible bindings. (t;b)2b
is a binding and corresponds to the execution of transition tconsuming selected objects from the
input places and producing the corresponding objects for the output places (both speciﬁed by b).
cons(t;b) = [(p;oi)2qonjp2t^oi2b(pt(p))]is the multiset of tokens to be consumed
given binding (t;b).prod(t;b) = [(p;oi)2qonjp2t ^ oi2b(pt(p))]is the multiset of
tokens to be produced given binding (t;b). binding (t;b)isenabled in markingm2b(qon)if
cons(t;b)m. the occurrence of an enabled binding (t;b)in markingmleads to the new marking
m0=m cons(t;b) +prod(t;b).5this is denoted as m(t;b) !m0.
m(t;b) !m0implies that binding (t;b)is enabled in marking mand that the occurrence of this
binding leads to the new marking m0. it is also possible to have a sequence of enabled bindings
=h(t1;b1);(t2;b2);:::; (tn;bn)i2bsuch thatm0(t1;b1) !m1(t2;b2) !m2(t3;b3) !:::(tn;bn) !mn,
i.e., it is possible to reach mnfromm0innsteps. this is denoted m !m0. it is also possible to
map the transition names onto the corresponding activity names using lleading to the so-called visible
binding sequence v=h(l(t1);b1);(l(t2);b2);:::; (l(tn);bn)i(where (l(ti);bi)is omitted if tihas
no label). note that the visible binding sequence does not show silent steps (transitions with no label)
and cannot distinguish duplicate activities (two transitions with the same label).
it should be noted that deﬁnition 5.4 does not put any constraints on the binding other than that for
non-variable arcs precisely one token is consumed/produced. in the colored petri in figure 7 there are
four transitions with guards to link items to speciﬁc orders and routes. this is deliberately abstracted
from in deﬁnition 5.1 to enable the discovery of so-called accepting object-centric petri nets with an
initial and ﬁnal marking.
deﬁnition 5.5. (accepting object-centric petri net)
an accepting object-centric petri net is a tuple an= (on;minit;mnal)composed of a well-formed
object-centric petri net on= (n;pt;fvar), an initial marking minit2b(qon), and a ﬁnal marking
mnal2b(qon).
using the notion of a visible binding sequence, we can reason about all behaviors leading from
the initial to the ﬁnal marking.
5summation ( +), difference ( ), and inclusion () are deﬁned for multisets in the usual way, e.g., [a; b]+[b; c] = [a; b2; c],
[a; b2; c] [b; c] = [a; b], and[a; b][a; b2; c].w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1019
deﬁnition 5.6. (language of an object-centric petri net)
an accepting object-centric petri net an= (on;minit;mnal)deﬁnes a language (an) =fvj
minit !mnalgthat is composed of all visible binding sequences starting in minitand ending in
mnal.
note that the behavior of an accepting object-centric petri net is deliberately “underspeciﬁed”.
there are only typing and cardinality constraints. hence, objects of different types are unrelated.
compared to the colored petri net in figure 7, our process models do not use guards to relate objects
of different types. note that guards combine objects of different types that are only characterized by
an identiﬁer. using just the identiﬁers would lead to overﬁtting models. how to ﬁnd a rule telling
that order 99001 is composed of items 88124, 88125, and 88126? this is contained in the data and
cannot be handled by a precise and explicit rule. as mentioned in the conclusion, this a topic for future
research (cf. section 10).
6. discovering object-centric petri nets
first, we introduce a general approach to learn accepting object-centric petri nets from object-centric
event logs. then we discuss performance-related annotations of the models, model views, and ways
to combine these results with traditional process mining techniques.
6.1. generic approach
given an object-centric event log l= (e;e)(deﬁnition 3.3), we would like to discover an ac-
cepting object-centric petri net an= (on;minit;mnal)(deﬁnition 5.5). rather than deﬁning
one speciﬁc discovery algorithm, we present a general approach leveraging existing process discovery
techniques.
•step 1: given an object-centric event log l= (e;e), identify the object types otuot
appearing in the event log. then create a ﬂattened event log lot= (eot;ot
e)for each object
typeot2ot.
•step 2: discover an accepting petri net snot= (not;mot
init;mot
nal)withnot= (pot;tot;
fot;lot)for each object type ot2ot using the ﬂattened event log lot. for this purpose,
any conventional discovery technique can be used. the only assumption we need to make is
that there are no duplicated labels, i.e., labeling function lotis injective. however, we allow for
silent transitions, i.e., lotmay be partial.
•step 3: merge the accepting petri nets into a petri net n. to avoid name clashes, ﬁrst en-
sure that the place names and names of silent transitions in the different nets are different.
also, ensure that transitions that have the same label also have the same name (this is possible
because the labeling functions are injective). after renaming, create an overall labeled petri
netn= (p;t;f;l )with:p=s
ot2otpot,t=s
ot2ottot,f=s
ot2otfot, and
l=s
ot2otlot.1020 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
•step 4: assign object types to the places in the merged petri net n:pt(p) =otforp2pot
andot2ot. this is possible because the places for the different object types are disjoint.
•step 5: identify the variable arcs fvarf. this can be determined in different ways (e.g.,
using replay results or diagnosing the ﬂattening process). the goal is to identify the arcs where
multiple tokens need to be consumed or produced. an example would be fvar=f(p;t)2
f\(pt)jscore (l(t);pt(p))< g[f (t;p)2f\(tp)jscore (l(t);pt(p))< g
whereis a threshold (e.g., 0.98) and score2(uactuot)6![0;1]such that score (act;ot) =
jfe2ejact(e) =act^jomap(e)(ot)j= 1gj=jfe2ejact(e) =actgjis the fraction of
actevents that refer to precisely one object of type ot.
•step 6: combining the previous three steps allows us to create an object-centric petri net
on= (n;pt;fvar). the initial and ﬁnal markings are obtained by replicating the markings
of the accepting petri nets for each of the corresponding objects. minit= [(p;oi)2qonj
9ot2otp2mot
init^ 9e2eoi2omap(e)(pt(p))].mnal= [(p;oi)2qonj9ot2otp2
mot
nal^9e2eoi2omap(e)(pt(p))].
•step 7: return the accepting object-centric petri net an= (on;minit;mnal).
the above approach has two parameters: (1) the discovery technique used in step 2 and (2) the
selection of variable arcs in step 5 (e.g., threshold and function score ). for step 2 any discovery
technique that produces a petri net without duplicate labels can be used (e.g., region-based techniques
without label splitting or the inductive mining techniques). the scoring function described in step 5
is just an example. function score (act;ot)counts the fraction of actevents that refer to precisely
one object of type ot. if this is rather low (below the threshold ), then the corresponding arcs are
considered to be variable (i.e., these arcs can consume/produce any number of tokens). the approach
always returns a well-formed object-centric petri net because the selection of fvardepends on the
transition and place type only.
6.2. annotations, views, and extractions
the main novelty of the work presented in this paper is that we discover a single process model with
multiple object types allowing us to capture multiple one-to-many and many-to-many relationships in
event data. based on this, many ideas from traditional process mining can be converted to this more
realistic setting. in this section, we brieﬂy discuss a few.
it is rather straightforward to annotate process models with frequency information and time infor-
mation. for example, the right-hand side of figure 6 is already showing various frequencies and our
implementation provides much more diagnostics.
•transition annotations: the frequency of a transition shows how often the corresponding ac-
tivity occurred in the object-centric event log. it is also possible to add statistics about the
objects involved in the corresponding events (e.g., how many objects of a particular type were
involved on average ). if there is transactional information (start and complete), it is also pos-
sible to show information about the duration of the corresponding activity (average, median,
variance, minimum, maximum, etc.).w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1021
•place annotations: it is possible to show how many tokens have been consumed from and
produced for each place. these tokens correspond to objects. hence, it is also possible to show
how many unique objects visited the place and what the average number of visits per object
is. by taking the time difference between the moment a token is produced and consumed,
it is possible to show timing information (average, median, variance, minimum, maximum,
etc.). in case of compliance checking, one can also show missing and remaining tokens (see
implementation).
•arc annotations: there are two types of arcs: the variable arcs fvarand the non-variable
fnfvar. both can be annotated with frequency and time information. for variable arcs, we can
also show statistics about the numbers of tokens produced/consumed per transition occurrence.
see figure 6, where the annotations for variable arcs show averages. for example, annotation
1005shows that 100 times a multiset of tokens was moved along the arc and the average size
of this multiset was 5, indicating that 500 objects were moved along the arc.
next to adding annotations, it is also possible to select or deselect object types. the approach de-
scribed in section 6.1 ﬁrst identiﬁes the object types otuotappearing in the event log. however,
we can take any nonempty subset ot0ot. it is, for example, possible to leave out the object type
order and only use the types item androute . this way it is possible to create simpliﬁed views . every-
thing can also be combined with frequency-based ﬁltering, i.e., adding sliders to seamlessly remove
infrequent activities and arcs.
since most process mining techniques cannot handle object-centric event logs, it is valuable to be
able to generate classical event logs and apply traditional techniques. the holistic view provided by
the accepting object-centric petri net serves as a starting point for a more detailed analysis focusing on
one object type. deﬁnition 4.1 already showed that it is easy to ﬂatten event logs. it is also possible to
take as case identiﬁer combinations of object types. this can be combined with views and interactive
ﬁltering. of course, one should always be very careful when interpreting such results. due to the
convergence and divergence problems mentioned before the results may be misleading. however, the
overall accepting object-centric petri net helps to avoid misinterpretations.
7. tool support for object-centric petri nets
the concepts and techniques discussed have been fully implemented. in this section, we describe the
implementation, the functionalities supported, and evaluate the performance.
7.1. implementation
to support the discovery approach presented in this paper (including performance and conformance
analysis using token-based replay), we extended pm4py with an additional python library pm4py-
mdl .6the tool can be installed by using the python package installer (pip) (use the command pip
install pm4pymdl ). next to discovering object-centric petri nets, pm4py-mdl can also discover multi-
dimensional directly-follows graphs [21, 23].
6the software can be downloaded from www.pm4py.org andhttps://github.com/javert899/pm4py-mdl.git1022 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
our implementation follows the approach described in this paper. the discovery of an object-
centric petri net is based on the discovery of petri nets for the single object types. then, these petri
nets are merged and annotated. for the discovery of a petri net for each of the individual object types,
a sound workﬂow net is obtained by applying the inductive miner directly-follows process discovery
algorithm [47]. however, any discovery technique producing an accepting petri net can be used.
the token-based replay approach described in [22] is used to annotate the places and the perfor-
mance on the arcs. this approach improves the approach [59] and the implementation is considerably
faster. for each place, the number of producedp,consumedc,remainingr, and missingmtokens are
computed and displayed. these values are obtained by “playing the token game” using the ﬂattened
event loglotand accepting petri net snotfor each object type ot. this is possible because each
place has precisely one type. the numbers pandcrefer to the number of produced and consumed
tokens (reported per place). the number of missing tokens mrefers to situations where a token is not
present in the place although the log suggests that the output transition has ﬁred. the number of re-
maining tokens rrefers to the tokens that remain after replaying the event log. our token-based replay
approach is able to deal with silent transitions and duplicate transitions (i.e., the labeling function lis
partial or non-injective). see [59, 22] for details.
for performance-related annotations, the sets of delays based on differences between the produc-
tion times of tokens and the consumption times of tokens are used. based on these measurements,
minimum, maximum, average, variance, etc. can be calculated.
the annotations related to the transitions are derived directly from the event log (i.e., without
replaying the event log). this way we can add the frequencies of transitions, the average number of
objects involved, and the number of unique objects to the model.
7.2. functionalities of the tool
figure 8 shows two screenshots of our pm4py-mdl tool. the following functions are supported:
•importing andexporting of object-centric event logs in different formats. the currently sup-
ported formats are multi-dimensional logs (mdl), parquet and xoc (format connected to
ocbc models).
• a range of object-centric process discovery approaches are supported. there are also several
target formats next to the object-centric petri nets introduced in this paper. also multiple view-
point (mvp) models are supported. these are essentially directly follows graphs [3] with
colored arcs, see [21, 23]. the approach presented in the paper can be combined with different
low-level discovery techniques. in the examples, we use the inductive miner directly-follows
process discovery algorithm [47].
• it is possible to set various thresholds to inﬂuence the discovery process, e.g., the minimal
number of occurrences for activities and paths. it is also possible to specify, for each object
type, the activities that are considered for that type.
• several methods to explore the raw event data are provided (e.g., statistics on the number of
related objects per type and distribution of events over time). these annotations can be attached
to places, transitions, and arcs.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1023
figure 8. web interface that is supporting the functionalities offered by the pm4py-mdl library. the main
components are the process discovery (left) and event exploration (right) ones.
• token-based replay is supported for performance andconformance analysis. this allows for the
identiﬁcation of bottlenecks and deviating behavior.
• it is possible to ﬁlter based on activities, paths, number of related objects per type. also, time-
frame and attribute-based ﬁlters are supported.
• there is support for clustering and event correlation based on event graphs.
• at any point in time, it is possible to ﬂatten an object-centric event log onto a traditional event
logby selecting an object type. the resulting event log can be analyzed using conventional
process mining techniques.
the web interface is organized mainly in two different components: process discovery and event
exploration (see figure 8). the visualization is highly interactive. the nodes are clickable in such a
way that the statistics about the events of such activity can be inspected and ﬁltering options can be
set. the event exploration shows the events of the log in an interactive way. it is possible to interact
with the related objects and show all the events related to an object in another panel. this way the
understanding the lifecycle of objects is facilitated. next, we evaluate the scalability of the approach
and the implementation.
7.3. scalability of the approach and implementation
the aim of this subsection is to analyze the scalability of the discovery of object-centric petri nets as
implemented in the pm4py-mdl tool. we expect the discovery of object-centric petri nets to be scal-
able, because the steps that are involved have at most linear complexity, excluding the application of
the process discovery algorithm on the ﬂattened logs. moreover, we also support discovery techniques
that are linear in the event log (given a bounded number of activities).
to analyze scalability, we use variants of the “running-example” object-centric event log also used
in other parts of the paper. three different settings have been examined:
1. the execution time of the algorithm in terms of the number of events in the event log (while
keeping the number of unique activities and the number of objects per event constant).1024 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
2. the execution time of the algorithm in terms of the number of unique activities in the event log
(while keeping the number of events and the number of objects per event constant).
3. the execution time of the algorithm in terms of the number of objects per event (while keeping
the number of unique activities and the number of events constant).
7.3.1. increasing the number of events
figures 9 and 10(a) show the relationship between the overall execution time and the number of events
in the object-centric event log. figure 10(a) shows a linear relationship between the number of events
and the execution time. our initial “running-example” log contains 22,367 events. different subsets
of different sizes are taken such that the set of unique activities remains constant (we just consider
fewer orders). in other words, the process is observed over shorter time periods. analyzing the whole
log takes less than a minute. this may seem long for a relatively small event log. however, the
time needed for discovery is less than a second. figure 9 splits the analysis time into six different
components:
• the time needed for the log ﬂattening operations for all event logs ( log fl. ).
• the time needed for the process discovery operations ( disc. ). in these experiments, we use the
inductive miner.
0 0:5 1 1:5 2
10405101520
number of eventsexecution time (s)
log fl. disc. tr perf. stats vis.
figure 9. detailed analysis of the overall execution time of the approach when increasing the number of events
of the log. the measurements are grouped for the ﬁve sublogs. the columns inside a group represent event log
ﬂattening ( log fl. ), discovery ( disc. ), token-based replay ( tr), computing performance annotations ( perf. ),
computing statistics ( stats ), and visualization ( vis.).w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1025
• the time needed for the token-based replay operations ( tr).
• the time needed for computing the performance annotations based on the results of the token-
based replay ( perf. ).
• the time needed for the calculation of additional statistics from the log ( stats ).
• the time needed for the visualization ( vis.).
figure 9 clearly shows that most time is spent on the token-based replay operations ( tr) and the
computation of the performance annotations ( perf. ). the ﬁrst is done per control-ﬂow variant (to avoid
repeatedly solving the same problem) and the second one per object. this explains why perf. takes
more time than tr. also, the event log preprocessing ( log fl. ) takes substantial time. interestingly,
the discovery itself is very fast compared to the other components.
figures 9 and 10(a) show that the characteristics of our approach are similar to process mining on
classical event logs. it takes more time to replay the event log to collect conformance and performance
statistics than to discover the process model using techniques such as the inductive miner. this also
holds for traditional process mining techniques using a single case notion.
7.3.2. increasing the number of activities
figure 10(b) shows the execution time when increasing the number of unique activities. the event logs
used were created using activity ﬁltering while keeping the number of events constant. table 7.3.2
shows the number of activities, the number of events, and the overall time needed. in row k, thek
most frequent activities are retained and the event log is further ﬁltered to have precisely 8159 events.
the growth in overall computation time is explained by the fact that the most expensive operations
are the token-based replay and computing the performance annotations, and the complexity of these
operations grows linearly with the average length of the trace.7
table 3. the execution time while increasing the number of unique activities.
number of activities number of events execution time
1 8159 5.26
2 8159 6.74
3 8159 7.02
4 8159 9.25
5 8159 9.85
6 8159 10.34
7 8159 10.90
8 8159 12.18
9 8159 13.26
10 8159 13.56
11 8159 13.58
7token-based replay, in contrast to other approaches such as alignments, does not suffer from the increase of the size of the
trace, since decisions are made locally.1026 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
0 0:5 1 1:5 2
104010203040
number of eventsexecution time (s)
(a) execution time while increasing the num-
ber of events.0 2 4 6 8 10 1268101214
number of activitiesexecution time (s)
(b) execution time while increasing the num-
ber of activities.
2 4 6 8 1010203040
objects per eventexecution time (s)
c) execution time while increasing the num-
ber of objects per event.
figure 10. scalability assessment of the object-centric petri nets discovery algorithm. the different graphs
show the overall time (including replay and annotation) when varying of the number of events, the number of
activities, and the number of objects per event.
7.3.3. increasing the number of related objects per event
figure 10(c) shows the execution time when the number of related objects per event is increased. to
analyze such a setting, different subsets of the “running-example” event log were created in such a way
that the number of events and the number of different activities does not change. the set of related
objects is selected such that at least one related object (of any type) remains for each event. the linear
relation is as expected, since events are replicated for each object during analysis. experiments also
conﬁrm that there is a linear relationship between the overall analysis time and the number of object
types (not shown).w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1027
overall, the results are very encouraging. the approach scales linear in the number of events, the
number of unique activities, and the number of objects. the discovery times are negligible compared
to the time needed for conformance checking and performance analysis. hence, the approach can be
applied to real-world event data.
table 4. fragment of a larger object-centric event log with 22,367 events and ﬁve object types: orders ,items ,
products ,customers ,packages . there are 2000 different orders, 8159 items, 20 products, 17 customers, and
1325 packages. the table shows a few sample events and the ﬁrst three object types.
event activity event timestamp orders items products
place order 2019-05-20 09:07:47 [’990001’] [’880001’, ’880002’, ’880003’, ’880004’] [’echo show 8’, ’fire stick 4k’, ’echo’, ’echo...
place order 2019-05-20 10:35:21 [’990002’] [’880005’, ’880006’, ’880007’, ’880008’] [’ipad’, ’kindle’, ’ipad air’, ’macbook air’]
pick item 2019-05-20 10:38:17 [’990002’] [’880006’] [’kindle’]
conﬁrm order 2019-05-20 11:13:54 [’990001’] [’880001’, ’880002’, ’880003’, ’880004’] [’echo show 8’, ’fire stick 4k’, ’echo’, ’echo...
pick item 2019-05-20 11:20:13 [’990001’] [’880002’] [’fire stick 4k’]
place order 2019-05-20 12:30:30 [’990003’] [’880009’, ’880010’, ’880011’, ’880012’] [’ipad air’, ’iphone 11’, ’fire stick’, ’iphon...
conﬁrm order 2019-05-20 12:34:16 [’990003’] [’880009’, ’880010’, ’880011’, ’880012’] [’ipad air’, ’iphone 11’, ’fire stick’, ’iphon...
item out of stock 2019-05-20 13:54:37 [’990001’] [’880004’] [’echo studio’]
place order 2019-05-20 14:20:47 [’990004’] [’880013’, ’880014’] [’echo studio’, ’echo show 8’]
item out of stock 2019-05-20 15:19:49 [’990003’] [’880009’] [’ipad air’]
place order 2019-05-20 16:01:22 [’990005’] [’880015’, ’880016’] [’ipad pro’, ’ipad air’]
pick item 2019-05-20 16:56:02 [’990004’] [’880014’] [’echo show 8’]
pick item 2019-05-20 17:08:25 [’990002’] [’880008’] [’macbook air’]
place order 2019-05-20 17:22:31 [’990006’] [’880017’, ’880018’, ’880019’] [’echo show 8’, ’fire stick 4k’, ’iphone x’]
pick item 2019-05-20 17:51:15 [’990003’] [’880011’] [’fire stick’]
pick item 2019-05-20 18:15:00 [’990002’] [’880007’] [’ipad air’]
conﬁrm order 2019-05-20 18:36:37 [’990004’] [’880013’, ’880014’] [’echo studio’, ’echo show 8’]
place order 2019-05-20 19:04:49 [’990007’] [’880020’, ’880021’, ’880022’] [’echo show 8’, ’echo dot’, ’kindle paperwhite’]
::: ::: ::: ::: :::
8. example application
to illustrate the feasibility of the approach and corresponding pm4py-mdl implementation, we use
the larger example brieﬂy mentioned in the introduction (see figure 1). the object-centric event
log in csv format can be obtained from https://github.com/javert899/pm4py-mdl/blob/
master/example_logs/mdl/mdl-running-example.mdl . a small fragment of the log, showing
three selected object types, is visualized in table 4. it can be considered to be an extension of the
smaller examples used before. in total, there are 22,367 events. there are ﬁve object types: orders ,
items ,products ,customers ,packages . the event log contains information about 2000 different orders,
8159 items, 20 products, 17 customers, and 1325 packages. hence, the average number of items in
one order is 4.08 and the average number of items in one package is 6.16.
we can ﬁlter out speciﬁc “activity - object type” (a;ot)combinations. this corresponds to re-
moving objects related to activity aand object type ot. in table 4, we removed all objects related to
customers andpackages for all activities. this boils down to removing the columns with customer
and package information. we can also remove the rows related to certain activities. however, we can
also use more ﬁne-grained ﬁltering where we keep speciﬁc “activity - object type” combinations.
table 5 shows example statistics for the 22,367 events in the original object-centric event log.1028 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
table 5. the ﬁrst two columns show the “activity - object type” combinations used for analysis. for example,
place order events also had information about products and customers, but these object types were removed.
failed delivery events also had information about orders, products, and customers, but these were removed. etc.
the last three columns show statistics for the “activity - object type” combinations in the original event log
(only for the object types orders ,items , and packages ). the three values are reported: the minimum number of
objects / the average number of objects / the maximum number of objects.
activity retained object types orders per event items per event packages per event
place order orders, items 1 / 1.00 / 1 1 / 4.08 / 15 0 / 0.00 / 0
conﬁrm order orders, items 1 / 1.00 / 1 1 / 4.08 / 15 0 / 0.00 / 0
item out of stock items 1 / 1.00 / 1 1 / 1.00 / 1 0 / 0.00 / 0
reorder item items 1 / 1.00 / 1 1 / 1.00 / 1 0 / 0.00 / 0
pick item items 0 / 0.00 / 0 1 / 1.00 / 1 0 / 0.00 / 0
payment reminder orders 1 / 1.00 / 1 1 / 4.18 / 14 0 / 0.00 / 0
pay order orders 1 / 1.00 / 1 1 / 4.08 / 15 0 / 0.00 / 0
create package items, packages 1 / 3.32 / 9 1 / 6.16 / 22 1 / 1.00 / 1
send package items, packages 1 / 3.32 / 9 1 / 6.16 / 22 1 / 1.00 / 1
failed delivery items, packages 1 / 3.21 / 8 1 / 5.95 / 18 1 / 1.00 / 1
package delivered items, packages 1 / 3.31 / 9 1 / 6.16 / 22 1 / 1.00 / 1
for each activity, the minimum number of objects, the average number of objects, and the maximum
number of objects of a given type are indicated. for example, place order events always refer to
precisely one order object and a variable number of item objects (minimum=1, average=4.08, maxi-
mum=15) and send package events always refer to precisely one package object, a variable number
of item objects (minimum=1, average=6.16, maximum=22), and a variable number of order objects
(minimum=1, average=3.32, maximum=9).
for our running example, we considered the “activity - object type” combinations depicted in
table 5, i.e., we retain object types orders ,items , and packages , keep all activities, but remove less
relevant object types for some of the activities. starting from the event log in table 4 and the “activity
- object type” combinations in table 5, our discovery approach returns the object-centric petri net
shown in figure 11.
the overall ﬁgure is hardly readable. however, we can use the ﬁltering approaches discussed and
seamlessly simplify the model (e.g., removing infrequent activities and selecting fewer object types).
moreover, we can zoom in on the different aspects of the model.
figure 12 shows a fragment of the larger object-centric petri net in figure 11. the green source
place is of type orders . the red source place is of type items . activity place order occurred 2000
times, consuming precisely one token from the green place and a variable number of tokens from the
red place. the compound double arrow reﬂects this, and the inscription shows that on average 4.08
item objects were consumed.
figure 13 shows another fragment. the package delivered activity is the ﬁnal activity of the life-
cycle of both packages and items. the two compound double arrows denote that variable numbers of
item objects are consumed and produced. the mean number of item objects consumed and produced
bypackage delivered is 6.16. the annotations on the arcs tell that the average time from the previous
activity for packages to this activity is 18 hours. the average time from the previous activity for itemsw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1029
figure 11. object-centric petri net discovered based on the example log considering three object types: orders
(green), items (red), and packages (violet).1030 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
figure 12. fragment of the model showing the place order activity. there are 2000 unique orders in the log
andplace order occurs for each of them once. there are 8159 unique items distributed over the 2000 orders.
the diagnostics show that, on average, 4.08 item objects are consumed from the red place of type items .
figure 13. fragment of the model showing the package delivered activity. this activity corresponds to the
successful delivery of packages composed of multiple items. there are 8159 unique items distributed over 1325
packages. all packages were delivered as reﬂected by the frequency of package delivered . the mean number
of item objects consumed and produced by the transition is 6.16. the number of package objects consumed and
produced by the transition is always 1. also, the average times are reported.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1031
figure 14. fragment of the model showing the failed delivery activity. there were 391 failed deliveries, 261
packages had at least one failed delivery, and 1565 items out of the 8159 where involved in at least one failed
delivery. 87 packages containing 543 items had a failed delivery two or more times.1032 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
to this activity is 9 hours.
figure 14 zooms in on the failed deliveries. there were 391 failed deliveries involving 261 pack-
ages (87 failed multiple times) and 1565 items.
all the places in figure 11 also show replay information: pis the number of tokens produced for
the place,cis the number of tokens consumed, mis the number of tokens missing, ris the number of
tokens remaining (see section 7.1). in this example, the model ﬁts perfectly. therefore, m= 0 and
r= 0for all places.
from the discovered object-centric petri net, we can also generate simpler views, create tradi-
tional event logs, and deploy traditional process mining techniques for further analysis. moreover,
the example shows many insights that could not have been discovered using traditional approaches.
by ﬂattening the event log, the relations between different types of objects would be lost. moreover,
any attempt to look at different types of objects would result in non-existing loops and misleading
frequency/time diagnostics.
this section highlighted the main advantages of using our approach over traditional models using
a separate process model for each object type. to summarize:
• figure 11 (and the corresponding model fragments) provides an overview of the whole process
and the interactions between the different object types. when considering each object type as a
separate case notion, we get multiple disconnected models that do notshow these interactions.
•deﬁciency ,convergence , and divergence problems are avoided (cf. deﬁnition 4.3). all events
are taken into count precisely once, i.e., events do not disappear and are not replicated uninten-
tionally. moreover, artiﬁcial loops due to divergence are avoided.
• using token-based replay, we are able to project performance and conformance information
onto one overall model. most of the statistics would not be visible in the ﬂattened process
models (e.g., the average number of objects involved in an activity).
9. related work
this section discusses traditional process mining techniques using a single case notion, modeling
approaches dealing with multiple object types, and process mining approaches dealing with multiple
object types.
9.1. traditional process mining techniques using a single case notion
in the introduction, we mentioned several process discovery approaches based on classical event logs
using a single case notion [2]. many of these techniques discover classical petri nets (e.g., place
transition nets), e.g., region-based approaches can be used to derive places [15, 16, 17, 18, 20, 25,
26, 27, 29, 30, 33, 42, 43, 51, 52, 53, 54, 61, 63]. the region-based process discovery techniques
are just a subset of all approaches to derive process models from event logs. the inductive mining
techniques [45, 46] and the so-called split miner [14] are examples of the state-of-the-art techniques to
learn process models. commercial systems tend to use the directly follows graph (dfg) having thew.m.p . van der aalst and a. berti /discovering object-centric petri nets 1033
obvious limitations explained in [3]. all of the above approaches assume a single case notion. this is
consistent with traditional process models ranging from workﬂow nets [1, 8] and process trees [44] to
business process modeling notation (bpmn) models [58] and event-driven process chains (epcs)
[60] which assume a single case notion.
9.2. modeling techniques using multiple object types
although most process models use a single case notion, the problem that many processes cannot be
captured properly in this way was identiﬁed early on. ibm’s flowmark system already supported the
so-called “bundle” concept to handle cases composed of subcases [39]. this is related to the multiple
instance patterns , i.e., a category of workﬂow patterns identiﬁed around the turn of the century [9].
one of the ﬁrst process modeling notations trying to address the problem were the so-called proclets
[6, 7]. proclets are lightweight interacting workﬂow processes. by promoting interactions to ﬁrst-class
citizens, it is possible to model complex workﬂows in a more natural manner using proclets.
this was followed by other approaches such as the artifact-centric modeling notations [24, 28, 50,
57]. see [36] for an up-to-date overview of the challenges that arise when instances of processes may
interact with each other in a one-to-many or many-to-many fashion.
9.3. process mining techniques using multiple object types
most of the work done on interacting processes with converging and diverging instances has focused
on developing novel modeling notations and supporting the implementation of such processes. only
a few approaches focused on the problem in a process mining context. this is surprising since one
quickly encounters the problem when applying process mining to erp systems from sap, oracle,
microsoft, and other vendors of enterprise software. this problem was also raised in section 5.5 of
[2] which discusses the need to “ﬂatten” event data to produce traditional process models.
in [31] techniques are described to extract “non-ﬂat” event data from source systems and prepare
these for traditional process mining. the extensible event stream (xes) format [40] is the ofﬁcial
ieee standard for storing event data and supported by many process mining vendors. xes requires a
case notion to correlate events. next to the standard ieee xes format [40], new storage formats such
asextensible object-centric (xoc) [48] have been proposed to deal with object-centric data (e.g.,
database tables) having one-to-many and many-to-many relations. the xoc format does not require
a case notion to avoid ﬂattening multi-dimensional data. an xoc log can precisely store the evolution
of the database along with corresponding events. an obvious drawback is that xoc logs tend to be
very large.
the approaches described in [37, 38, 56] focus on interacting processes where each process uses its
own case identiﬁers. in [56] interacting artifacts are discovered from erp systems. in [37] traditional
conformance checking was adapted to check compliance for interacting artifacts.
one of the main challenges is that artifact models tend to become complex and difﬁcult to un-
derstand. in an attempt to tackle this problem, van eck et al. use a simpler setting with multiple
perspectives, each modeled by a simple transition system [34, 62]. these are also called artifact-
centric process models but are simpler than the models used in [24, 28, 37, 38, 50, 57, 56]. the state
of a case is decomposed onto one state per perspective, thus simplifying the overall model. relations1034 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
between sub-states are viewed as correlations rather than explicit causality constraints. concurrency
only exists between the different perspectives and not within an individual perspective. in a recent
extension, each perspective can be instantiated multiple times, i.e., many-to-many relations between
artifact types can be visualized [62].
the above techniques have the drawback that the overall process is not visualized in a single di-
agram, but shown as a collection of interconnected diagrams using different (sub-)case notions. the
so-called object-centric behavioral constraint (ocbc) models address this problem and also incor-
porate the data perspective in a single diagram [5, 10, 13, 49]. ocbc models extend data models with
a behavioral perspective. data models can easily deal with many-to-many and one-to-many relation-
ships. this is exploited to create process models that can also model complex interactions between
different types of instances. classical multiple-instance problems are circumvented by using the data
model for event correlation. activities are related to the data perspective and have ordering constraints
inspired by declarative languages like declare [11]. instead of ltl-based constraints, simpler cardi-
nality constraints are used. several discovery techniques have been developed for ocbc models [49].
it is also possible to check conformance and project performance information on such models. ocbc
models are appealing because they faithfully describe the relationship between behavior and data and
are able to capture all information in a single integrated diagram. however, ocbc models tend to
be too complex and the corresponding discovery and conformance checking techniques are not very
scalable.
the complexity and scalability problems of ocbc models led to the development of the so-
called multiple viewpoint (mvp) models , earlier named starstar models [21, 23]. mvp models are
learned from data stored in relational databases. based on the relations and timestamps in a traditional
database, ﬁrst, a so-called e2o graph is built that relates events and objects. based on the e2o graph,
an e2e multigraph is learned that relates events through objects. finally, an a2a multigraph is learned
to relate activities. the a2a graph shows relations between activities and each relation is based on
one of the object classes used as input. this is a very promising approach because it is simple and
scalable. the approach to discover object-centric petri nets can be seen as a continuation of the work
in [21, 23].
although commercial vendors have recognized the problems related to convergence and diver-
gence of event data, there is no real support for concepts comparable to artifact-centric models, object-
centric behavioral constraint (ocbc) models, and multiple viewpoint (mvp) models. yet, there are
a few initial attempts implemented in commercial systems. an example is celonis , which supports
the use of a secondary case identiﬁer to avoid “spaghetti-like” models where concurrency between
sub-instances is translated into loops. the directly-follows graphs in celonis do not consider inter-
actions between sub-instances, thus producing simpler models. another example is the multi-level
discovery technique supported by myinvenio . the resulting models can be seen as simpliﬁed mvp
models where different activities may correspond to different case notions (but one case notion per
activity). the problem of this approach is that, in reality, the same event may refer to multiple case
notions and choosing one is often misleading, especially since it inﬂuences the frequencies shown in
the diagram.
in spite of the recent progress in process mining, problems related to multiple interacting process
instances have not been solved adequately. one of the problems is the lack of standardized event dataw.m.p . van der aalst and a. berti /discovering object-centric petri nets 1035
that goes beyond the “ﬂattened” event data found in xes. hence, process mining competitions tend
to focus on classical event logs. in earlier papers [4, 21, 23], we already stressed the need for object-
centric process mining. in this paper, we provided a concrete, but at the same time generic, discovery
approach to learning object-centric petri nets from object-centric events logs.
10. conclusion
when looking at data models or database schemas, there are often one-to-many and many-to-many
relations between different types of objects relevant for a process. since mainstream process modeling
and process mining approaches enforce the use of a speciﬁc case notion, the modeler or analyst is
forced to select a speciﬁc perspective. this problem can be partly addressed by extracting multiple
event logs to cover the different case notions and considering one model per case notion. it would be
better to have one, more holistic, process model that is showing the interactions between the different
types of objects. moreover, the need to pick one or more speciﬁc case notions for analysis leads to the
divergence and convergence problems discussed in this paper.
therefore, this paper uses object-centric event logs as a representation in between the actual data
in the information system and traditional event logs (e.g., based on xes). object-centric event logs do
not depend on a case notion. instead, events may refer to arbitrary sets of objects. one event may refer
to multiple objects of different types. next to using a different input format, we also use a different
target language: object-centric petri nets . these nets are a restricted variant of colored petri nets
where places are typed, tokens refer to objects, and transitions correspond to activities. unlike other
mainstream notations, a transition can consume and produce a variable number of objects of different
types. we presented a concrete, but also generic, approach to discover object-centric petri nets from
object-centric event logs. the approach has been implemented in pm4py and various applications
show that the approach provides novel insights and is highly scalable (linear in the number of objects,
object types, events, and activities). therefore, the ideas are directly implementable in commercial
tools and the existing software can be used to analyze real-life event data in larger organizations.
this is the ﬁrst paper that aims to learn object-centric petri nets from object-centric event logs.
our ﬁndings show lots of opportunities for further research. these include:
• we aim to develop conformance checking techniques based on object-centric petri nets and
object-centric event logs. next to checking whether the event log can be replayed on the process
model, it is interesting to detect outliers using the cardinalities. in the current implementation,
we already report missing and remaining tokens, but these are based on the ﬂattened event logs.
• the approach presented is generic and can embed different process discovery algorithms inde-
pendently working on ﬂattened events logs (inductive miner, region-based techniques, etc.). the
results are then folded into object-centric petri nets. it is interesting to compare the different
approaches and develop more integrated approaches (e.g., ﬁrst discover a process model for one
object type and then iteratively add the other object types). moreover, it would be good to have
dedicated quality measures (e.g., complexity and precision).
• object-centric petri nets in their current form can be seen as “over-approximations” of the actual1036 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
behavior. it is interesting to think of ways to make the model more precise (e.g., automatically
detecting guards or relating splits and joins). for example, in figure 4, transition marked as
complete should join the same set of objects earlier involved in an occurrence of transition place
order . similarly, we would like to add stochastics to the model (e.g., a probability distribution
for the number of items in an order).
• the current object-centric event logs only contain object identiﬁers and no properties of objects.
if an object identiﬁer refers to a patient or customer, we do not know her age, weight, address,
income, etc. if an object identiﬁer refers to an order or machine, we do not know its value,
the absence of object attributes automatically leads to the “over-approximations” mentioned.
hence, we are developing extended object-centric event logs.
• we also plan to investigate more sophisticated forms of performance analysis that go beyond
adding timing a frequency diagnostics to transition, places, and arcs. how do the different object
types inﬂuence each other? next to analyzing the interactions between objects, we would like
to better support the link to cpn tools for “what if” analysis (e.g., replaying the event log on
an improved process).
• we also aim to create a comprehensive, publicly available, set of object-centric event logs.
acknowledgments : we thank the alexander von humboldt (avh) stiftung for supporting our re-
search.
references
[1] w.m.p. van der aalst. the application of petri nets to workﬂow management. the journal of circuits,
systems and computers , 8(1):21–66, 1998.
[2] w.m.p. van der aalst. process mining: data science in action . springer-verlag, berlin, 2016.
[3] w.m.p. van der aalst. a practitioner’s guide to process mining: limitations of the directly-follows
graph. in international conference on enterprise information systems (centeris 2019) , volume 164 of
procedia computer science , pages 321–328. elsevier, 2019.
[4] w.m.p. van der aalst. object-centric process mining: dealing with divergence and convergence in
event data. in p.c. ¨olveczky and g. sala ¨un, editors, software engineering and formal methods (sefm
2019) , volume 11724 of lecture notes in computer science , pages 3–25. springer-verlag, berlin, 2019.
[5] w.m.p. van der aalst, a. artale, m. montali, and s. tritini. object-centric behavioral constraints:
integrating data and declarative process modelling. in proceedings of the 30th international workshop
on description logics (dl 2017) , volume 1879 of ceur workshop proceedings . ceur-ws.org, 2017.
[6] w.m.p. van der aalst, p. barthelmess, c.a. ellis, and j. wainer. workﬂow modeling using proclets. in
o. etzion and p. scheuermann, editors, 7th international conference on cooperative information systems
(coopis 2000) , volume 1901 of lecture notes in computer science , pages 198–209. springer-verlag,
berlin, 2000.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1037
[7] w.m.p. van der aalst, p. barthelmess, c.a. ellis, and j. wainer. proclets: a framework for lightweight
interacting workﬂow processes. international journal of cooperative information systems , 10(4):443–
482, 2001.
[8] w.m.p. van der aalst, k.m. van hee, a.h.m. ter hofstede, n. sidorova, h.m.w. verbeek, m. v oorhoeve,
and m.t. wynn. soundness of workﬂow nets: classiﬁcation, decidability, and analysis. formal aspects
of computing , 23(3):333–363, 2011.
[9] w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros. workﬂow patterns. dis-
tributed and parallel databases , 14(1):5–51, 2003.
[10] w.m.p. van der aalst, g. li, and m. montali. object-centric behavioral constraints. corr ,
abs/1703.05740, 2017.
[11] w.m.p. van der aalst, m. pesic, and h. schonenberg. declarative workﬂows: balancing between flexi-
bility and support. computer science - research and development , 23(2):99–113, 2009.
[12] w.m.p. van der aalst and c. stahl. modeling business processes: a petri net oriented approach . mit
press, cambridge, ma, 2011.
[13] a. artale, d. calvanese, m. montali, and w.m.p. van der aalst. enriching data models with behavioral
constraints. in s. borgo, editor, ontology makes sense (essays in honor of nicola guarino) , pages 257–
277. ios press, 2019.
[14] a. augusto, r. conforti, m. marlon, m. la rosa, and a. polyvyanyy. split miner: automated discovery
of accurate and simple business process models from event logs. knowledge information systems ,
59(2):251–284, may 2019.
[15] e. badouel, l. bernardinello, and p. darondeau. petri net synthesis . texts in theoretical computer
science. an eatcs series. springer-verlag, berlin, 2015.
[16] e. badouel and p. darondeau. theory of regions. in w. reisig and g. rozenberg, editors, lectures on
petri nets i: basic models , volume 1491 of lecture notes in computer science , pages 529–586. springer-
verlag, berlin, 1998.
[17] r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on regions of languages. in
g. alonso, p. dadam, and m. rosemann, editors, international conference on business process manage-
ment (bpm 2007) , volume 4714 of lecture notes in computer science , pages 375–383. springer-verlag,
berlin, 2007.
[18] r. bergenthum, j. desel, r. lorenz, and s. mauser. synthesis of petri nets from finite partial languages.
fundamenta informaticae , 88(4):437–468, 2008.
[19] r. bergenthum, j. desel, r. lorenz, and s. mauser. synthesis of petri nets from scenarios with viptool.
inapplications and theory of petri nets (petri nets 2008) , volume 5062 of lecture notes in computer
science , pages 388–398. springer-verlag, berlin, 2008.
[20] r. bergenthum, j. desel, s. mauser, and r. lorenz. synthesis of petri nets from term based represen-
tations of inﬁnite partial languages. fundamenta informaticae , 95(1):187–217, 2009.
[21] a. berti and w.m.p. van der aalst. starstar models: using events at database level for process analysis.
in p. ceravolo, m. van keulen, and m.t. gomez lopez, editors, international symposium on data-driven
process discovery and analysis (simpda 2018) , volume 2270 of ceur workshop proceedings , pages
60–64. ceur-ws.org, 2018.1038 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
[22] a. berti and w.m.p. van der aalst. reviving token-based replay: increasing speed while improving
diagnostics. in proceedings of the international workshop on algorithms and theories for the analysis of
event data (ataed 2019) , volume 2371 of ceur workshop proceedings , pages 87–103. ceur-ws.org,
2019.
[23] a. berti and w.m.p. van der aalst. discovering multiple viewpoint models from relational databases. in
p. ceravolo, m. van keulen, and m.t. gomez lopez, editors, postproceedings international symposium
on data-driven process discovery and analysis , volume 379 of lecture notes in business information
processing , pages 24–51. springer-verlag, berlin, 2020.
[24] k. bhattacharya, c. gerede, r. hull, r. liu, and j. su. towards formal analysis of artifact-centric
business process models. in g. alonso, p. dadam, and m. rosemann, editors, international conference
on business process management (bpm 2007) , volume 4714 of lecture notes in computer science , pages
288–304. springer-verlag, berlin, 2007.
[25] j. carmona, j. cortadella, and m. kishinevsky. a region-based algorithm for discovering petri nets
from event logs. in business process management (bpm 2008) , pages 358–373, 2008.
[26] j. carmona, j. cortadella, and m. kishinevsky. new region-based algorithms for deriving bounded
petri nets. ieee transactions on computers , 59(3):371–384, 2010.
[27] j. carmona, j. cortadella, m. kishinevsky, a. kondratyev, l. lavagno, and a. yakovlev. a symbolic
algorithm for the synthesis of bounded petri nets. in applications and theory of petri nets (petri nets
2008) , pages 92–111, 2008.
[28] d. cohn and r. hull. business artifacts: a data-centric approach to modeling business operations and
processes. ieee data engineering bulletin , 32(3):3–9, 2009.
[29] j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets from finite transition
systems. ieee transactions on computers , 47(8):859–882, august 1998.
[30] p. darondeau. on the synthesis of zero-safe nets. in concurrency, graphs and models , volume 5065 of
lecture notes in computer science , pages 364–378. springer-verlag, berlin, 2008.
[31] e. gonz ´alez l ´opez de murillas, h.a. reijers, and w.m.p. van der aalst. connecting databases with
process mining: a meta model and toolset. in r. schmidt, w. guedria, i. bider, and s. guerreiro,
editors, enterprise, business-process and information systems modeling (bpmds 2015) , volume 248 of
lecture notes in business information processing , pages 231–249. springer-verlag, berlin, 2016.
[32] j. desel and w. reisig. the synthesis problem of petri nets. acta informatica , 33(4):297–315, 1996.
[33] b.f. van dongen, j. desel, and w.m.p. van der aalst. aggregating causal runs into workﬂow nets. in
k. jensen, w.m.p. van der aalst, m. ajmone marsan, g. franceschinis, j. kleijn, and l.m. kristensen,
editors, transactions on petri nets and other models of concurrency (topnoc vi) , volume 7400 of
lecture notes in computer science , pages 334–363. springer-verlag, berlin, 2012.
[34] m.l. van eck, n. sidorova, and w.m.p. van der aalst. guided interaction exploration in artifact-centric
process models. in ieee conference on business informatics (cbi 2017) , pages 109–118. ieee com-
puter society, 2017.
[35] a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2. acta informatica ,
27(4):315–368, 1989.
[36] d. fahland. describing behavior of processes with many-to-many interactions. in s. donatelli and
s. haar, editors, applications and theory of petri nets 2019 , volume 11522 of lecture notes in computer
science , pages 3–24. springer-verlag, berlin, 2019.w.m.p . van der aalst and a. berti /discovering object-centric petri nets 1039
[37] d. fahland, m. de leoni, b. van dongen, and w.m.p. van der aalst. behavioral conformance of artifact-
centric process models. in a. abramowicz, editor, business information systems (bis 2011) , volume 87
oflecture notes in business information processing , pages 37–49. springer-verlag, berlin, 2011.
[38] d. fahland, m. de leoni, b. van dongen, and w.m.p. van der aalst. many-to-many: some observations
on interactions in artifact choreographies. in d. eichhorn, a. koschmider, and h. zhang, editors, pro-
ceedings of the 3rd central-european workshop on services and their composition (zeus 2011) , ceur
workshop proceedings, pages 9–15. ceur-ws.org, 2011.
[39] ibm. ibm mqseries workﬂow - getting started with buildtime . ibm deutschland entwicklung gmbh,
boeblingen, germany, 1999.
[40] ieee task force on process mining. xes standard deﬁnition. www.xes-standard.org, 2013.
[41] k. jensen and l.m. kristensen. coloured petri nets . springer-verlag, berlin, 2009.
[42] j. kleijn, m.koutny, and m. pietkiewicz-koutny. regions of petri nets with a/sync connections. theoret-
ical computer science , 454:189–198, 2012.
[43] j. kleijn, m.koutny, m. pietkiewicz-koutny, and g. rozenberg. applying regions. theoretical computer
science , 658:205–215, 2017.
[44] s.j.j. leemans, d. fahland, and w.m.p. van der aalst. discovering block-structured process models from
event logs: a constructive approach. in j.m. colom and j. desel, editors, applications and theory of
petri nets 2013 , volume 7927 of lecture notes in computer science , pages 311–329. springer-verlag,
berlin, 2013.
[45] s.j.j. leemans, d. fahland, and w.m.p. van der aalst. discovering block-structured process models
from event logs containing infrequent behaviour. in n. lohmann, m. song, and p. wohed, editors,
business process management workshops, international workshop on business process intelligence (bpi
2013) , volume 171 of lecture notes in business information processing , pages 66–78. springer-verlag,
berlin, 2014.
[46] s.j.j. leemans, d. fahland, and w.m.p. van der aalst. scalable process discovery with guarantees. in
k. gaaloul, r. schmidt, s. nurcan, s. guerreiro, and q. ma, editors, enterprise, business-process and
information systems modeling (bpmds 2015) , volume 214 of lecture notes in business information
processing , pages 85–101. springer-verlag, berlin, 2015.
[47] s.j.j. leemans, d. fahland, and w.m.p. van der aalst. scalable process discovery and conformance
checking. software and systems modeling , 17(2):599–631, 2018.
[48] g. li, e. gonz ´alez l ´opez de murillas, r. medeiros de carvalho, and w.m.p. van der aalst. extracting
object-centric event logs to support process mining on databases. in j. mendling and h. mouratidis,
editors, information systems in the big data era, caise forum 2018 , volume 317 of lecture notes in
business information processing , pages 182–199. springer-verlag, berlin, 2018.
[49] g. li, r. medeiros de carvalho, and w.m.p. van der aalst. automatic discovery of object-centric
behavioral constraint models. in w. abramowicz, editor, business information systems (bis 2017) ,
volume 288 of lecture notes in business information processing , pages 43–58. springer-verlag, berlin,
2017.
[50] n. lohmann. compliance by design for artifact-centric business processes. in s. rinderle, f. toumani,
and k. wolf, editors, business process management (bpm 2011) , volume 6896 of lecture notes in com-
puter science , pages 99–115. springer-verlag, berlin, 2011.1040 w.m.p . van der aalst and a. berti /discovering object-centric petri nets
[51] r. lorenz, r. bergenthum, j. desel, and s. mauser. synthesis of petri nets from finite partial languages.
in t. basten, g. juh ´as, and s.k. shukla, editors, international conference on application of concurrency
to system design (acsd 2007) , pages 157–166. ieee computer society, 2007.
[52] r. lorenz, j. desel, and g. juhas. models from scenarios. in k. jensen, w.m.p. van der aalst, g. balbo,
m. koutny, and k. wolf, editors, transactions on petri nets and other models of concurrency (topnoc
vii), volume 7480 of lecture notes in computer science , pages 314–371. springer-verlag, berlin, 2013.
[53] r. lorenz and g. juhas. towards synthesis of petri nets from scenarios. in s. donatelli and p.s. thia-
garajan, editors, application and theory of petri nets 2006 , volume 4024 of lecture notes in computer
science , pages 302–321. springer-verlag, berlin, 2006.
[54] r. lorenz and g. juh ´as. how to synthesize nets from languages: a survey. in s.g. henderson, b. biller,
m. hsieh, j. shortle, j. d. tew, and r. r. barton, editors, proceedings of the wintersimulation conference
(wsc 2007) , pages 637–647. ieee computer society, 2007.
[55] x. lu, d. fahland, and w.m.p. van der aalst. conformance checking based on partially ordered event
data. in f. fournier and j. mendling, editors, business process management workshops, international
workshop on business process intelligence (bpi 2014) , volume 202 of lecture notes in business infor-
mation processing , pages 75–88. springer-verlag, berlin, 2015.
[56] x. lu, m. nagelkerke, d. van de wiel, and d. fahland. discovering interacting artifacts from erp
systems. ieee transactions on services computing , 8(6):861–873, 2015.
[57] a. nigam and n.s. caswell. business artifacts: an approach to operational speciﬁcation. ibm systems
journal , 42(3):428–445, 2003.
[58] omg. business process model and notation (bpmn). object management group, formal/2011-01-03,
2011.
[59] a. rozinat and w.m.p. van der aalst. conformance checking of processes based on monitoring real
behavior. information systems , 33(1):64–95, 2008.
[60] a.w. scheer. business process engineering: reference models for industrial enterprises . springer-
verlag, berlin, 1994.
[61] m. sol ´e and j. carmona. process mining from a basis of state regions. in j. lilius and w. penczek,
editors, applications and theory of petri nets 2010 , volume 6128 of lecture notes in computer science ,
pages 226–245. springer-verlag, berlin, 2010.
[62] m.l. van eck, n. sidorova, and w.m.p. van der aalst. multi-instance mining: discovering synchronisa-
tion in artifact-centric processes. in f. daniel, q.z. sheng, and h. motahari, editors, business process
management workshops, international workshop on business process intelligence (bpi 2018) , volume
342 of lecture notes in business information processing , pages 18–30. springer-verlag, berlin, 2018.
[63] s.j. van zelst, b.f. van dongen, w.m.p. van der aalst, and h.m.w verbeek. discovering workﬂow nets
using integer linear programming. computing , 100(5):529–556, 2018.