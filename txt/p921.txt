object-centric behavioral constraints
wil m.p. van der aalst1, guangming li1, and marco montali2
1eindhoven university of technology, p.o. box 513, 5600 mb, eindhoven, the netherlands.
w.m.p.v.d.aalst@tue.nl, g.li.3@tue.nl
2free university of bozen-bolzano, piazza domenicani 3, i-39100, bolzano, italy.
montali@inf.unibz.it
abstract. today’s process modeling languages often force the analyst or mod-
eler to straightjacket real-life processes into simplistic or incomplete models that
fail to capture the essential features of the domain under study. conventional busi-
ness process models only describe the lifecycles of individual instances (cases)
in isolation. although process models may include data elements (cf. bpmn),
explicit connections to real data models (e.g. an entity relationship model or a
uml class model) are rarely made. therefore, we propose a novel approach that
extends data models with a behavioral perspective . data models can easily deal
with many-to-many and one-to-many relationships. this is exploited to create
process models that can also model complex interactions between different types
of instances. classical multiple-instance problems are circumvented by using the
data model for event correlation. the declarative nature of the proposed language
makes it possible to model behavioral constraints over activities like cardinal-
ity constraints in data models. the resulting object-centric behavioral constraint
(ocbc) model is able to describe processes involving interacting instances and
complex data dependencies . in this paper, we introduce the ocbc model and
notation , providing a number of examples that give a ﬂavour of the approach.
we then deﬁne a set-theoretic semantics exploiting cardinality constraints within
and across time points. we ﬁnally formalize conformance checking in our set-
ting, arguing that evaluating conformance against ocbc models requires diag-
nostics that go beyond what is provided by contemporary conformance checking
approaches.
1 introduction
techniques for business process modeling (e.g., bpmn diagrams, workﬂow nets,
epcs, or uml activity diagrams) tend to suffer from two main problems:
–it is difﬁcult to model interactions between process instances , which are in fact
typically considered in isolation. concepts like lanes, pools, and message ﬂows
in conventional languages like bpmn aim to address this. however, within each
(sub)process still a single instance is modeled in isolation.
–it is also difﬁcult to model the data-perspective and control-ﬂow perspective in a
uniﬁed and integrated manner . data objects can be modeled, but the more power-
ful constructs present in entity relationship (er) models and uml class models
cannot be expressed well in process models. for example, cardinality constraints
in the data model must inﬂuence behavior, but this is not reﬂected at all in today’s
process models.arxiv:1703.05740v1  [cs.db]  14 mar 2017because of these problems there is a mismatch between process models and the
data in (and functionality supported by) real enterprise systems from vendors such as
sap (s/4hana), microsoft (dynamics 365), oracle (e-business suite), and sales-
force (crm). these systems are also known as enterprise resource planning (erp)
and/or customer relationship management (crm) systems and support business func-
tions related to sales, procurement, production, accounting, etc. these systems may
contain hundreds, if not thousands, of tables with information about customers, orders,
deliveries, etc. for example, sap has tens of thousands of tables. also hospital in-
formation systems (his) and product lifecycle management (plm) systems have in-
formation about many different entities scattered over a surprising number of database
tables. even though a clear process instance notion is missing in such systems, main-
stream business process modeling notations can only describe the lifecycle of one type
of process instance at a time. the disconnect between process models and the actual
processes and systems becomes clear when applying process mining using data from
enterprise systems. how to discover process models or check conformance if there is
no single process instance notion?
the problems mentioned have been around for quite some time (see for example
[11]), but were never solved satisfactorily. artifact-centric approaches [7,12,14,16] (in-
cluding the earlier work on proclets [3]) attempt to address the above problems. how-
ever, these approaches tend to result in models where
–the description of the end-to-end behavior needs to be distributed over multiple
diagrams (e.g., one process model per artifact),
–the control-ﬂow cannot be related to an overall data model (i.e., there is no explicit
data model or it is separated from the control-ﬂow), and
–interactions between different entities are not visible or separated (because artifacts
are distributed over multiple diagrams).
within an artifact, proclet, or subprocess, one is forced to pick a single instance notion .
moreover, cardinality constraints in the data model cannot be exploited while specifying
the intended dynamic behavior. we believe that data and process perspectives can be
uniﬁed better, as demonstrated in this paper.
fig. 1. object-centric behavioral con-
straint (ocbc) models connect data
constraints (like in a uml class dia-
gram), behavioral constraints (like in
a process model or rule set), and real
event data. this allows for novel forms
of conformance checking.
observed events
data
constraints
behavioral 
constraints
this paper proposes the object-centric behavioral constraint (ocbc) model as a
novel language that combines ideas from declarative, constraint-based languages like
declare [4], and from data/object modeling techniques (er, uml, or orm). cardi-
nality constrains are used as a unifying mechanism to tackle data and behavioral depen-
dencies, as well as their interplay (cf. figure 1). the primary application considered in
2create 
order
pick
item
order line
 order
 delivery1
wrap
item
deliver
items
product
customer11
11
1
1
 2
 3
 4
5
6
7
8
9
 1
1
1
1
1..*
 1..*
1
1
1
*
 *
 *
0..1
fig. 2. a small object-centric behavioral constraint (ocbc) model.
this paper is conformance checking [2,8,13,18]. deviations between observed behavior
(i.e., an event log) and modeled behavior (ocbc model) are diagnosed for compliance,
auditing, or risk analysis. unlike existing approaches, instances are not considered in
isolation and cardinality constraints in the data/object model are taken into account.
hence, problems that would have remained undetected earlier, can now be detected.
figure 2 shows an ocbc model with four activities ( create order ,pick item ,wrap
item, and deliver items ) and ﬁve object classes ( order ,order line ,delivery ,product ,
andcustomer ). the top part describes the ordering of activities and the bottom part the
structuring of objects relevant for the process. the lower part can be read as if it was
a uml class diagram. some cardinality constraints should hold at any point in time as
indicated by the 2(“always”) symbol. other cardinality constraints should hold from
some point onwards as indicated by the }(“eventually”) symbol. consider for example
the relation between order line anddelivery . at any point in time a delivery corresponds
to one of more order lines (denoted 21::) and an order line refers to as most one
delivery (denoted 20::1). however, eventually an order line should refer to precisely
one delivery (denoted }1). always, an order has one or more order lines, each order
line corresponds to precisely one order, each order line refers to one product, each order
refers to one customer, etc. the top part shows behavioral constraints and the middle
part relates activities, constraints, and classes.
the notation used in figure 2 will be explained in more detail later. however, to
introduce the main concepts, we ﬁrst informally describe the 9 constructs highlighted
in figure 2. 1there is a one-to-one correspondence between order objects and cre-
ate order activities. if an object is added to the class order , the corresponding activity
needs to be executed and vice versa. 2there is a one-to-one correspondence between
order line objects and pick item activities. 3there is also a bijection between order
lineobjects and wrap item activities. the}1annotations next to pick item andwrap
item indicate that these activities need to be executed for every order line. however,
they may be executed some time after the order order line is created. 4there is a one-
to-one correspondence between delivery objects and delivery items activities. 5each
3create order activity is followed by one or more pick item activities related to the same
order. 6each pick item activity is preceded by precisely one corresponding create
order activity. 7each pick item activity is followed by one wrap item activity corre-
sponding to the same order line. each wrap item activity is preceded by one pick item
activity corresponding to the same order line. 8each wrap item activity is followed
by precisely one corresponding deliver items activity. 9each deliver items activity is
preceded by at least one corresponding wrap item activity. a deliver items activity is
implicitly related to a set of order lines through the relationship between class order
lineand class delivery . the notation will be explained later, however, note that a single
order may have many order lines that are scattered over multiple deliveries. moreover,
one delivery may combine items from multiple orders for the same customer.
the process described in figure 2 cannot be modeled using conventional notations
(e.g., bpmn) because (a) three different types of instances are intertwined and (b) con-
straints in the class model inﬂuence the allowed behavior. moreover, the ocbc model
provides a fullspeciﬁcation of the allowed behavior in a single diagram , so that no
further coding or annotation is needed.
the contribution of this paper is threefold:
1. we introduce the ocbc model and notation , providing a number of examples that
give a ﬂavour of the approach;
2. we deﬁne a set-theoretic semantics for ocbc models, exploiting cardinality con-
straints within and across time points;
3. we formalize conformance checking in our setting, arguing that evaluating confor-
mance against ocbc models requires diagnostics that go beyond what is provided
by contemporary conformance checking approaches.
the remainder is organized as follows. section 2 focuses on behavioral constraints
between tasks, showing in particular that declarative control ﬂow constraints a l `a de-
clare can be modeled as cardinality constraints over sets of events (i.e., task occur-
rences). section 3 focuses on data modeling, ﬁrst focusing on the intentional level of
classes and relationships, then tackling the extensional level of objects and tuples. both
aspects are integrated in section 4, where the ocbc model is introduced. section 5
provides the semantics for ocbc models in terms of cardinality constraints over sets
of events, and demonstrates that novel forms of conformance checking are possible.
section 6 concludes the paper.
2 modeling behavioral cardinality constraints
in this paper, a process is merely a collection of events without assuming some case or
process instance notion. each event corresponds to an activity and may have additional
attributes such as the time at which the event took place, the resource executing the cor-
responding event, the type of event (e.g., start, complete, schedule, abort), the location
of the event, or the costs of an event. each event attribute has a name (e.g., “age”) and
avalue (e.g., “49 years”). moreover, events are atomic and ordered. for simplicity, we
assume a total order . to model the overlapping of activities in time one can use start
and complete events.
4deﬁnition 1 (events and activities). ueis the universe of events , i.e., things that
happened.uais the universe of activities .
–function act2ue!uamaps events onto activities.
–events can also have additional attributes (e.g., timestamp, cost, resource, or
amount).uattr is the universe of attribute names .uvalis the universe of attribute
values .attr2ue!(uattr6!u val)maps events onto a partial function assign-
ing values to some attributes,3
–relationueuedeﬁnes a total order on events.4
unlike traditional event logs [1] we do notassume an explicit case notion. normally,
each event corresponds to precisely one case, i.e., a process instance. in the object-
centric behavioral constraint models (ocbc models) described in section 4 we do
not make this restriction and can express complex interactions between a variety of
objects in a single diagram . however, to gently introduce the concepts, we ﬁrst deﬁne
constraints over a collection of ordered events .
deﬁnition 2 (event notations). lete uebe a set of events ordered by and
related to activities through function act. for any event e2e:
–e(e) =fe02eje0egare the events before andincludinge.
–e(e) =fe02ejee0gare the events after andincludinge.
–e(e) =fe02eje0egare the events beforee.5
–e(e) =fe02ejee0gare the events aftere.
–@a(e) =fe02ejact(e0) =agare the events corresponding to activity a2ua.
a process model can be viewed as a set of constraints . in a procedural language
like petri nets, places correspond to constraints: removing a place may allow for more
behavior and adding a place can only restrict behavior. in this paper, we employ a
graphical notation inspired by declare [4]. speciﬁcally, we provide a formalization of a
subset of declare in terms of behavioral cardinality constraints . this allows us to rea-
son about behavior and data in a uniﬁed manner, since both use cardinality constraints.
the following cardinality notion will be used to constrain both data and behavior.
deﬁnition 3 (cardinalities). ucard =fxi njx6=;gdeﬁnes the universe of all
possible cardinalities. elements of ucard specify non-empty sets of integers.
cardinalities are often used in data modeling, e.g., entity-relationship (er) models
and uml class models may include cardinality constraints. table 1 lists a few short-
hands typically used in such diagrams. for example, “ 1::” denotes any positive integer.
in line with literature, we adopt the notation in table 1 for cardinality constraints
over data. for behavioral cardinality constraints, we adopt a different notation, but very
similar in spirit. given some reference event ewe can reason about the events before
3f2x6!yis a partial function with domain dom(f)x.
4a total order is a binary relation that is (1) antisymmetric, i.e. e1e2ande2e1implies
e1=e2, (2) transitive, i.e. e1e2ande2e3implies e1e3, and (3) total, i.e., e1e2
ore2e1.
5e0eif and only if e0eande06=e.
5table 1. some examples of fre-
quently used shorthands for ele-
ments ofucard.notation allowed cardinalities
1f1g
1::kf1;2;:::;kg
f0;1;2;:::g
1::f1;2;:::g
a1
 a2
 a3
c1 c2
fig. 3. two behavioral cardinality constraints: constraint c1speciﬁes that all a2events should
be preceded by precisely one a1event and constraint c2speciﬁes that all a2events should be
succeeded by at least one a3event.
eand the events aftere. we may require that the cardinality of the set of events corre-
sponding to a particular activity before or after the reference event lies within a partic-
ular range.
consider for example the two constraints depicted in figure 3. assume a set of
eventseue. the reference events forc1are alla2events, i.e., all events ec1
ref=
@a2(e). this is indicated by the black dot connecting the c1arrow to activity a2. now
consider a reference event eref2ec1
ref. the single-headed arrow towards the black
dot indicates that erefshould be preceded by precisely one a1event. thea1events
are called target events (counterpart of erefwhen evaluating the constraint). formally,
constraintc1demands thatjeref(@a1(e))j= 1, i.e., there has to be precisely one a1
event before eref.
the reference events for c2are also all a2events, i.e., ec2
ref=@a2(e). again,
this is visualized by the black dot on the a2-side of the constraint. the double-headed
arrow leaving the black dot speciﬁes that any eref2ec2
refshould be followed by at
least onea3event. the target events in the context of c2are alla3events. formally:
jeref(@a3(e))j1, i.e., there has to be at least one a3event aftereref.
the two constraints in figure 3 are just examples. we allow for any constraint that
can be speciﬁed in terms of the cardinality of preceding and succeeding target events
relative to a collection of reference events . therefore, we deﬁne the more general notion
ofconstraint types .
deﬁnition 4 (constraint types). uct=fxi ni njx6=;gdeﬁnes the universe
of all possible constraint types. any element of uctspeciﬁes a non-empty set of pairs of
integers: the ﬁrst integer deﬁnes the number of target events before the reference event
and the second integer deﬁnes the number of target events after the reference event.
table 2 shows eight examples of constraint types. constraint c1is a unary-
precedence constraint and constraint c2is a response constraint. the graphical represen-
tations of the eight example constraint types are shown in figure 4. as a shorthand, one
arrow may combine two constraints as shown in figure 5. for example, constraint c34
states that after placing an order there is precisely one payment and before a payment
there is precisely one order placement.
6table 2. examples of constraints types (i.e., elements of uct), inspired by declare . note that a
constraint is deﬁned with respect of a reference event eref.
constraint formalization
responsef(before ;after )2i ni njafter1g
unary-response f(before ;after )2i ni njafter = 1g
non-response f(before ;after )2i ni njafter = 0g
precedence f(before ;after )2i ni njbefore1g
unary-precedence f(before ;after )2i ni njbefore = 1g
non-precedence f(before ;after )2i ni njbefore = 0g
co-existencef(before ;after )2i ni njbefore +after1g
non-co-existencef(before ;after )2i ni njbefore +after = 0g
before ≥ 0 and after ≥ 1
before ≥ 0 and after = 1
before ≥ 0 and after = 0
before ≥ 1 and after ≥ 0
before = 1 and after ≥ 0
before = 0 and after ≥ 0
before + after ≥ 1
before = 0 and after = 0
(response )
(unary -response )
(non -response )(precedence )
(unary -precedence )
(non -precedence )(co-existence )
(non -coexistence )
fig. 4. graphical notation for the example constraint types deﬁned in table 2 (example elements
ofuct). the dot on the left-hand side of each constraint refers to the reference events .target
events are on the other side that has no dot. the notation is inspired by declare , but formalized
in terms of cardinality constraints rather than ltl.
abehavioral constraint (bc) model is a collection of activities and constraints (cf.
figure 3).6
deﬁnition 5 (behavioral constraint model). abehavioral constraint model is a tuple
bcm = (a;c; ref;tar;type), where
–auais the set of activities (denoted by rectangles),
–cis the set of constraints ( a\c=;, denoted by various types of edges),
–ref2c!adeﬁnes the reference activity of a constraint (denoted by a black
dot connecting constraint and activity),
–tar2c!adeﬁnes the target activity of a constraint (other side of edge), and
–type2c!u ctspeciﬁes the type of each constraint (denoted by the type of
edge).
figure 3 deﬁnes the bc model bcm = (a;c; ref;tar;type)witha=
fa1;a2;a3g,c=fc1;c2g,ref(c1) =a2,ref(c2) =a2,tar(c1) =a1,
6note that bc models depend on the classical instance notion, i.e., the model describes the
lifecycle of single instance. ocbc models do not assume a single instance notion. however,
we introduce behavioral constraint models to gently introduce the concepts.
7equalsregisterplay musicc12place orderpayc34equalsregisterplay musicc1place orderpayc3c2c4fig. 5. an arrow with two reference events ( ) can be used as a shorthand. constraint c12(c34)
corresponds to the conjunction of constraints c1andc2(resp. c3andc4).
tar(c2) =a3,type(c1) =f(before;after )2i ni njbefore = 1g(unary-
precedence), and type(c2) =f(before;after )2i ni njafter1g(response).
given a set eof events, we can check whether constraints are satisﬁed (or not), thus
providing a natural link to conformance checking.
deﬁnition 6 (constraint satisfaction). letbcm = (a;c; ref;tar;type)be a bc
model, andeuea set of events.
–event setesatisﬁes constraintcif and only if
(jeref(@tar(c)(e))j;jeref(@tar(c)(e))j)2type(c)for alleref2@ref(c)(e)
–event setesatisﬁes bcm if and only if esatisﬁes each constraint c2c.
the reference activity of a constraint deﬁnes the corresponding set of reference
eventsec
ref. for each reference event it is checked whether the cardinality constraint
is satisﬁed. eref(@tar(c)(e))are all target events before the reference event eref.
eref(@tar(c)(e))are all target events after the reference event eref. consider, e.g.,
c1in figure 3. all a2events are reference events and all a1events are target events.
for this example eref(@tar(c1)(e))is the set ofa1events before the selected a2event
(eref). the cardinality of this set should be precisely 1.
in traditional process modeling notations a constraint is deﬁned for one process
instance (case) in isolation. this means that the set ein deﬁnition 6 refers to all events
corresponding to the same case. as discussed before, the case notion is often too rigid.
there may be multiple case-notions at the same time, causing one-to-many or many-
to-many relations that cannot be handled using traditional monolithic process models.
moreover, we need to relate events to (data) objects. all these issues are discussed next.
3 modeling data cardinality constraints
next to behavior as captured through events, there are also objects that are grouped
in classes. objects may be related and cardinality constraints help to structure depen-
dencies. entity-relationship (er) models [6], uml class models [9], and object-role
models (orm) [10] are examples of notations used for object modeling, often referred
to as data modeling. in this paper, we use the simple notation shown in figure 6(a) to
specify class models . the notation can be viewed as a subset of such mainstream no-
tations. the only particular feature is that cardinality constraints can be tagged as “al-
ways” ( 2) or “eventually” (}). for example, for every order order line there is always
8at most one delivery ( 20::1) and eventually (i.e., from some point in time onwards)
there should be a corresponding delivery( }1).
r1 r2
r3
r1r2
r3(a) class model
(b) object model1
1 11
1
1
1
1..*
 1..*
 1
1
*
 *
 *
0..1
r4 r5
order line order delivery
product
customerr4
r5
order line
 order
 delivery
product
customer
ol1
ol2
ol3
ol4
ol5
ol6
ol7
o1
o2
o3
d1
d2
p1
p2
p3
 p4
p5
c1
c2
c3
c4
r5r4 r4r1
r1
r1
r1
r1r2
r2
r2
r2
r3r3r3 r3 r3r3r1
fig. 6. example of a class model and corresponding object model.
deﬁnition 7 (class model). aclass model is a tuple clam = (oc;rt;1;2;]2
src;
]}
src;]2
tar;]}
tar),where
–oc is a set of object classes,
–rtis a set of relationship types ( oc\rt=;),
–12rt!oc gives the source of a relationship,
–22rt!oc gives the target of a relationship,
–]2
src2rt! ucard gives the cardinality of the source of a relationship (the
constraint should hold at any point in time as indicated by 2),
–]}
src2rt! ucard gives the cardinality of the source of a relationship (the
constraint should hold from some point onwards as indicated by }),
–]2
tar2rt! ucard gives the cardinality of the target of a relationship (the
constraint should hold at any point in time as indicated by 2), and
9–]}
tar2rt! ucard gives the cardinality of the target of a relationship (the
constraint should hold from some point onwards as indicated by }).
the class model clam = ( oc;rt;1;2;]2
src;]}
src;]2
tar;
]}
tar)depicted in figure 6(a) has ﬁve object classes oc =
forder;order line;delivery;customer;productgand ﬁve relationship types
rt =fr1;r2;r3;r4;r5g. relationship type r1is connecting classes order
andorder line :1(r1) = order and2(r1) = order line . for the other relationships
types, we have: 1(r2) = order line ,2(r2) = delivery ,1(r3) = order line , and
2(r3) = product , etc.
the notation of table 1 is extended with 2(“always”) or}(“eventually”) to
specify the cardinalities in figure 6(a). ]2
src(r1) =f1g, i.e., for each object in class
order line there is always precisely one corresponding object in order . this is indi-
cated by the “ 21” annotation on the source side (i.e., the order side ofr1) in fig-
ure 6(a).]2
tar(r1) =f1;2;3;:::g, i.e., for each object in class order there is always at
least one corresponding object in order line . this is indicated by the “ 21::” annota-
tion on the target side (i.e., the order line side) ofr1. not shown are ]}
src(r1) =f1g
(“}1”) and]}
tar(r1) =f1;2;3;:::g(“}1::”) as these are implied by the “always”
constraints. one the target side of r2in figure 6(a) there are two cardinality constraints:
]2
tar(r2) =f0;1gand]}
tar(r2) =f1g. this models that eventually each order line
needs to have a corresponding delivery (“ }1”). however, the corresponding delivery
may be created later (“ 20::1”). we only show the “eventually” ( }) cardinality con-
straints that are more restrictive than the “always” ( 2) cardinalities in the class model.
obviously,]}
src(r)]2
src(r)and]}
tar(r)]2
tar(r)for anyr2rtsince constraints
that always hold also hold eventually.
objects can also have attributes and therefore in principle the class model should
list the names and types of these attributes. we abstract from object/class attributes in
this paper, as well as from the notions of hierarchies and subtyping, but they could be
added in a straightforward manner.
a class diagram deﬁnes a “space” of possible object models , i.e., concrete collec-
tions of objects and relations instantiating the class model.
deﬁnition 8 (object model). uois the universe of object identiﬁers. an object model
for class model clam = (oc;rt;1;2;]2
src;]}
src;]2
tar;]}
tar)is a tuple om =
(obj;rel;class ), where:
–objuois the set of objects,
–relrtobjobj is the set of relations,
–class2obj!oc maps objects onto classes.
uomis the universe of object models.
figure 6(b) shows an object model om = ( obj;rel;class ). the ob-
jects are depicted as grey dots: obj =fo1;o2;o3;ol1;ol2;:::; ol7;d1;d2;
c1;:::; c4;p1;:::; p5g. there are three objects belonging to object class oc1, i.e.,
class (o1) =class (o2) =class (o3) =order . there are seven relations correspond-
ing to relationship r1, e.g., (r1;o1;ol1)2reland(r1;o2;ol5)2rel.
10note that objects and events are represented by unique identiﬁers. this allows us to
refer to a speciﬁc object or event. even two events or objects with the same properties
are still distinguishable by their identity.
the cardinalities speciﬁed in the class model should be respected by the object
model. for example, for each object in class order line there is precisely one corre-
sponding object in order according to r1. avalid object model complies with the
“always” ( 2) cardinalities in the class model. a valid model is also fulﬁlled is also the
possibly stronger “eventually” ( }) cardinality constraints are satisﬁed.
deﬁnition 9 (valid object model). letclam = (oc;rt;1;2;]2
src;]}
src;]2
tar;
]}
tar)be a class model and om = (obj;rel;class )2 u om be an object model.
om is valid for clam if and only if
–for any (r;o1;o2)2rel:class (o1) =1(r)andclass (o2) =2(r),
–for anyr2rtando22@2(r)(obj), we have that7
jfo12objj(r;o1;o2)2relgj2]2
src(r);and
–for anyr2rtando12@1(r)(obj), we have that
jfo22objj(r;o1;o2)2relgj2]2
tar(r)
a valid objected model is also fulﬁlled if the stronger cardinality constraints hold (these
are supposed to hold eventually):
–for anyr2rtando22@2(r)(obj), we have that
jfo12objj(r;o1;o2)2relgj2]}
src(r);and
–for anyr2rtando12@1(r)(obj), we have that
jfo22objj(r;o1;o2)2relgj2]}
tar(r)
the object model in figure 6(b) is indeed valid. if we would remove relation
(r1;o1;ol1), the model would no longer be valid (because an order line should al-
ways have a corresponding order). adding a relation (r1;o2;ol1)would also destroy
validity. both changes would violate the “ 21” constraint on the source side of r1. the
object model in figure 6(b) is not fulﬁlled because the “ }1” constraint on the target
side ofr2does not hold. order lines ol2andol4do not (yet) have a corresponding
delivery. adding deliveries for these order lines and adding the corresponding relations
would make the model fulﬁlled.
deﬁnition 9 only formalizes simple cardinality constraints involving a binary rela-
tion and abstracting from attribute values. in principle more sophisticated constraints
could be considered: the object model om is simply checked against a class model
clam . for example, the object constraint language (ocl) [17] could be used to de-
ﬁne more reﬁned constraints.
7@oc(obj) =fo2objjclass (o) =ocgdenotes the whole set of objects in class oc.
114 object-centric behavioral constraints
in section 2, we focused on control-ﬂow modeling and formalized behavioral con-
straints without considering the structure of objects. in section 3, we focused on struc-
turing objects and formalized cardinality constraints on object models (i.e., classical
data modeling). in this section, we combine both perspectives to fully address the chal-
lenges described in the introduction.
4.1 object-centric event logs
first, we formalize the notion of an event log building on the event notion introduced in
deﬁnition 1. an event log is a collection of events that belong together, i.e., they belong
to some “process” where many types of objects/instances may interact. next to scoping
the log, we also relate events to objects. note that the same event may refer to multiple
objects and one object may be referred to by multiple events.
deﬁnition 10 (event log). anevent log is a tuplel= (e;act;attr;eo;om;),
where
–eueis a set of events,
–act2e!uamaps events onto activities,
–attr2e!(uattr6!u val)maps events onto a partial function assigning values
to some attributes,
–eoeuorelates events to sets of object references,
–om2e!u ommaps each event to the object model directly after the event took
place, and
–eedeﬁnes a total order on events.
in the context of an event l, each event eis associated with object model ome=
(obje;rele;classe) =om(e). in the remainder, we refer directly to obje,rele,classe
fore2eif the context is clear.
o1
e1
o5
o1
e2
o2
o5
o1
o3
e3
o2
o5
o1
o3
e4
o2
o4
o5
o1
o3
e5
o2
o4
o5
fig. 7. each event erefers to the object model right after eoccurred: om e=
(obje;rel e;class e) =om(e).
figure 7 illustrates the evolution of the object model. after the occurrence of some
eventeobjects may have been added (we assume monotonicity), and relationships may
12have been added or removed. event emay refer to objects through relation eo and
these objects need to exist, i.e., for all (e;o)2eo:o2obje. we assume that objects
cannot be removed at a later stage to avoid referencing non-existent objects. objects
can be marked as deleted but cannot be removed (e.g, by using an attribute or relation).
the event log provides a snapshot of the object model after each event . this triggers
the question: can the object model be changed in-between two subsequent events? if
no such changes are possible, then the object model before an event is the same as the
object model after the previous event. if we would like to allow for updates in-between
events, then these could be recorded in the log. events referring to some artiﬁcial activ-
ityupdate could be added to signal the updated object model. we could also explicitly
add a snapshot of the object model just before each event. in the remainder, we only
consider the snapshot omeafter each event e2e.
note that deﬁnition 10 calls for event logs different from the standard xes format .
xes ( www.xes-standard.org ), which is supported by the majority of process
mining tools, assumes a case notion (i.e., each event refers to a process instance) and
does not keep track of object models.
4.2 ocbc models
next, we deﬁne object-centric behavioral constraint (ocbc) models. through a
combination of control-ﬂow modeling and data/object modeling, we relate behavior
and structure. the bc models from section 2 are connected to the class models of
section 3 to provide the integration needed.
t1
pay
ticket1..*0..1
1
t2
p1
t1
 t2
t3
p23
t1
 t2
t3
p3
payment event
that refers to tickets 
t2 and t 3
object model directly after
the payment event (having 
three ticket objects )  
fragment of larger 
ocbc model
activity
object class
every payment 
refers to one or 
more tickets 
every ticket 
always refers to at 
most one payment
eventually every
ticket refers to precisely 
one payment
t4
fig. 8. illustrating cardinality constraints ]2
a,]}
a, and]oc.
a key ingredient is that events and objects are related as illustrated in figure 8.
payment activity p1refers to ticket t1, activity p23 refers to tickets t2andt3, and
activity p3refers to ticket t4. figure 8 shows three example constraints: “ 20::1” (every
ticket always refers to at most one payment), “ }1” (eventually every ticket refers to
precisely one payment), and “ 1::” (every payment refers to one or more tickets).
13deﬁnition 11 (object-centric behavioral constraint model). an
object-centric behavioral constraint model is a tuple ocbcm =
(bcm;clam;aoc;]2
a;]}
a;]oc;crel), where
–bcm = (a;c; ref;tar;type)is a bc model (deﬁnition 5),
–clam = (oc;rt;1;2;]2
src;]}
src;]2
tar;]}
tar)is a class model (deﬁnition 7),
–a,c,ocandrtare pairwise disjoint (no name clashes),
–aocaoc is a set of relations between activities and object classes,
–]2
a2aoc!u card gives the cardinality of the source of a relation linking an
activity and an object class (activity side, the constraint should hold at any point in
time as indicated by 2),
–]}
a2aoc!u card gives the cardinality of the source of a relation linking an
activity and an object class (activity side, the constraint should hold from some
point onwards as indicated by }),
–]oc2aoc!u card gives the cardinality of the target of a relation linking an
activity and an object class (object-class side), and
–crel2c!oc[rtis the constraint relation satisfying the following conditions
for eachc2c:
 f(ref(c);oc);(tar(c);oc)gaoc ifcrel(c) =oc2oc, and
 f(ref(c);1(r));(tar(c);2(r))g  aoc orf(ref(c);2(r));(tar(c);
1(r))gaoc ifcrel(c) =r2rt.
a1
 a2
 a3
oc2
 oc1
 oc31 1..* 1..2 0..*1
11..*
1 1..*0..10..*1
1
r1 r2c1 c2
activity
constraint
object class
each a 1 event 
refers to precisely 
one oc 1 object
relationship 
between activities 
and classes
indicating the 
reference event
constraint relation
(used to determine target events related 
to the reference event )
0..*
each oc 2 object 
refers to at least 
one a 1 activity
1
 1..*
fig. 9. an example model illustrating the main ingredients of an ocbc model.
anobject-centric behavioral constraint model (ocbc model) includes a behav-
ioral constraint model (to model behavior) and a class model (to model objects/data).
these are related through relation aoc and functions ]2
a,]}
a,]oc, and crel. we use
figure 9 to clarify these concepts.
14aoc relates activities and object classes. in figure 9, aoc =f(a1;oc1);
(a1;oc2);(a2;oc2);(a3;oc2);(a3;oc3)g. for example, a1may potentially refer to
oc1 andoc2 objects, but not to oc3 objects because (a1;oc3)62aoc . recall that
in an event log lthere is a many-to-many relationship between events and objects
(eoeuo) constrained by aoc .
functions]2
a,]}
a, and]ocdeﬁne possible cardinalities, similar to cardinality con-
straints in a class model. functions ]2
aand]}
adeﬁne how many events there need to be
for each object. since the object model is evolving, there are two types of constraints:
constraints that should hold at any point in time from the moment the object exists ( ]2
a)
and constraints that should eventually hold]}
a. function]ocdeﬁnes how many objects
there need to be for each event when the event occurs (speciﬁed by eo).
as indicated by the “ 21” annotation on the a1-side of the line connecting ac-
tivity a1and object class oc1, there is precisely one a1event for each oc1 object
(from the moment it exists): ]2
a(a1;oc1) =f1g. as indicated by the “ }1::” on
thea1-side of the line connecting activity a1and object class oc2, we have that
]}
a(a1;oc2) =f1;2;:::g. this means that eventually eachoc2object refers to at least
onea1activity. note that an oc2object does not need to have a corresponding a1event
when it is created. however, adding a new oc2object implies the occurrence of at least
one corresponding a1event to satisfy the cardinality constraint “ }1::”, i.e., an obli-
gation is created. if the annotation “ 21::” would have been used (instead of “ }1::”),
then the creation of any oc2 object needs to coincide with a corresponding a1event,
because the cardinality constraints should always hold ( 2) and not just eventually ( }).
as indicated by the “ 1” annotation on the oc2-side of the line connecting activity
a1and object class oc2, we then have that ]oc(a1;oc2) =f1g. this means that each
a1activity refers to precisely one oc2object.
let’s now consider relation (a2;oc2)2aoc . there should be at most one a2
event for each oc2 object from the moment it exists: ]2
a(a2;oc2) =f0;1g. eventu-
ally there should be precisely one a2event for each oc2object:]}
a(a2;oc2) =f1g.
]oc(a2;oc2) =f1;2;:::gindicates that each a2event refers to at least one oc2ob-
ject.
annotations of the type “ }0::” and “ 20::” are omitted from the diagram because
these impose no constraints. also implied constraints can be left out, e.g., “ 21::”
implies “}1::”.
function crel deﬁnes the scope of each constraint thereby relating reference events
to selected target events. crel(c)speciﬁes how events need to be correlated when eval-
uating constraint c. this is needed because we do not assume a ﬁxed case notion and
different entities may interact. as illustrated by figure 10 we basically consider two
types of constraints. in both cases we navigate through the object model to ﬁnd tar-
get events for a given reference event. figures 11 and 12 illustrate how to locate target
events. for each reference event we need the set of all target events in order to check
the cardinality constraint.
ifcrel(c) =oc2oc, then the behavioral constraint is based on object class oc. in
figure 9, crel(c2) =oc2. this means that the target events for constraint c2need to
be related to the reference events through objects of class oc2. leterefbe the reference
15a1
 a2
occ
a1
 a2
oc1
 oc2rc
(a) the reference event and target events are 
related through common objects(b) the reference event and target events are 
related through relations in the object modelfig. 10. two types of constraint relations: (a) crel(c) =oc2oc, i.e., the target events are
related to the reference event through shared objects of the class oc, (b)crel(c) =r2rt, i.e.,
the target events are related to the reference event through relations of type r(in any direction).
a1 a2
occa1
e4e3a2
e8
e5
e10e2
o1
o7
oce1
e6
e9e7
o5
o4o6
o2
o3e6, e7, and e9 are the target 
events corresponding to 
reference event e1assume e1 is the 
reference event we 
are interested in
reference events are related to 
target events through the object 
model : a1 events are related to oc 
objects that are related to a2 events 
fig. 11. given a reference event for a constraint with crel(c) =oc2oc we navigate to the
target events through shared object references.
event for constraint c2.erefrefers to 1 or more oc2objects. the target events of eref
forc2are those a3events referring to one of these objects.
ifcrel(c) =r2rt, then the target events are related to the reference event through
relations of type rin the object model. relation rcan be traversed in both directions.
in figure 9, crel(c1) =r1indicating that reference events are related to target events
through relationship r1. leterefbe the reference a1event for constraint c1.erefrefers
tooc1objects that are related to oc2objects through r1relations. the target events of
erefforc1are those a2events referring to one of these oc2objects.
we have now introduced all the modeling elements used in figure 2. note that cre-
ate order activities are related to pick item activities through the relationship connecting
class order with class order line .
16a1 a2
oc1 oc2rca1 a2
oc1 oc2re4e3e8
e5
e10e2
e1
e6
e9e7
o1
o2
o309o10
o7
o8o4
o5o6assume e1 is the 
reference event we 
are interested ine6, e7, and e9 are the target 
events corresponding to 
reference event e1
reference events are related to target events 
through the object model : a1 events are 
related to oc1 objects that are related to oc2 
objects (via r)  that are related to a2 events fig. 12. given a reference event for a constraint with crel(c) =r2rtwe navigate to the target
events through relation rin the object model.
4.3 discussion
the graphical notation introduced (e.g., like in figure 2) fully deﬁnes an ocbc model.
to illustrate this let us consider a completely different example.
figure 13 models a hiring process. an organization may create a position. people
can apply for such a position, but need to register ﬁrst. applications for a position are
only considered in the period between opening the position and closing the application
process for the position. an application may be followed by at most ﬁve reference
checks and at most two interviews. in the end one person is selected and subsequently
hired for the position.
there are four object classes in the ocbc model: person ,application ,position ,
andemployee . the cardinality constraints in figure 13 show that: each application al-
ways refers to precisely one person and one position, each person eventually applies for
some position, for every position there will eventually be an application, each employee
refers to precisely one application and position, each application refers to at most one
employee, and each position will eventually refer to one employee.
there is a one-to-one correspondence between registrations (activity register ) and
persons (class person ). activities apply , check reference , and interview each refer to the
class application . activity apply creates one new application object. activities open
pos., check close pos. , and select each refer to the class position . activity open pos.
creates one new position object. there is also a one-to-one correspondence between
hirings (activity hire) and employees (class employee ).
let us now consider the constraints in more detail:
–constraintc1speciﬁes that every reference check should be preceded by precisely
one corresponding application (unary-precedence constraint).
–constraintc2speciﬁes that every interview should be preceded by precisely one
corresponding application (unary-precedence).
17register
application
 person
 position1
employee1
1
1
1..*
0..1
r1 r2
r31
 1..*
1
1
r4
open pos .
close pos .
select
 hire
apply
check 
reference
interview
1
110..2
11
111
1
1
0..5
11c1
c2c3
c4c5
c6
c7 c8fig. 13. an ocbc model modeling a hiring process.
–constraintc3combines a unary-response and a unary-precedence constraint stating
that the opening a a position should be followed by the closing of the application
process and the closing should be preceded by the opening of the position.
–constraintc4also combines a unary-response and a unary-precedence constraint
stating that the two activities are executed in sequence.
–constraintc5speciﬁes that applications for a position need to be preceded by the
opening of that position.
–constraintc6speciﬁes that after closing a position there should not be any new
applications for this position (non-response constraint).
–constraintc7speciﬁes that every hire needs to be preceded by at least one interview
with the candidate applying for the position (precedence constraint).
–constraintc8again combines a unary-response and a unary-precedence constraint
stating that the two activities are executed in sequence.
it is important to note that the constraints are based on the object model and that
there is not a single instance notion. to illustrate this consider the bpmn model in fig-
ure 14 which models the lifecycles of persons, positions, applications, and employees
in separate diagrams. the bpmn model looks very simple, but fails to capture depen-
dencies between the different entities. consider for example constraints c5,c6,c7, and
c8in the ocbc model of figure 13. the bpmn model does notindicate that there
is a one to many relationship between positions and applications, and does notshow
that one can only apply if the corresponding position is opened but not yet closed. the
bpmn model does notindicate that only one person is hired per position and that the
person to be hired should have registered, applied, and had at least one interview. the
bpmn model does notindicate that employees are hired after the completion of the
18selection process. note that the same person could apply for multiple positions and
many people may apply for the same position. obviously this cannot be captured using
a single process instance (case) notion.
application
position
open pos .
 close pos .
 select
apply
check reference
interview
employee
hire
person
register
fig. 14. an attempt to capture the ocbc model of figure 13 in terms of four bpmn models. the
relations with the overall data model and interactions between the different entities are no longer
visible. for example, insights like “one can only apply if the corresponding position is opened
but not yet closed” and “only people that had an interview can be hired” get lost.
comparing figure 13 and figure 14 reveals that modeling the lifecycles of enti-
ties separately, like in artifact-centric approaches, is not sufﬁcient to capture the real
process. the individual lifecycles are simple, but fail to reveal the interplay between
persons, positions, applications, and employees.
it is essential to understand that the scoping of events considered in a constraint
is done through the object model. this provides a tight integration between behavior
and structure. moreover, the approach is much more general and more expressive than
classical approaches where events are correlated through cases. normally, process mod-
els (both procedural and declarative) describe the lifecycle of a process instance (i.e.,
case) in isolation. this implies that events are partitioned based on case identiﬁers and
different cases cannot share events. hence, one-to-many and many-to-many relation-
ships cannot be modeled (without putting instances in separate subprocesses, artifacts
or proclets). in fact, more complicated forms of interaction cannot be handled.
note that traditional single-instance modeling approaches can still be mimicked
by using an object model having one object class case andcrel(c) =case for each
constraintc. figure 15 sketches this situation and illustrates that the classical view on
process behavior is every limiting, since complex relationships cannot be captured, and
the link to data/object models is missing.
5 conformance checking using ocbc models
given an event log, an object model, and an object-centric behavioral constraint model,
we want to check whether reality (in the form of an event log land an object model
19a1
 a2
 a3
oc
case110..* 0..*c1 c2
0..*
1
fig. 15. an ocbc model mimicking the classical situation where behavior needs to be straight-
jacketed in isolated process instances (i.e., cases).
om) conforms to the model ocbcm . we identify nine types of possible conformance
problems. most of these problems are not captured by existing conformance checking
approaches [2,8,13,18].
first, we implicitly provide operational semantics for ocbc models by deﬁning a
conformance relation between event log and model.
deﬁnition 12 (conformance). let ocbcm = ( bcm;clam;aoc;]2
a;
]}
a;]oc;crel)be an ocbc model, with bcm = (a;c; ref;tar;type)and
clam = (oc;rt;1;2;]2
src;]}
src;]2
tar;]}
tar). letl= (e;act;attr;eo;om;)
be an event log.
event loglconforms to the object-centric behavioral constraint model ocbcm
if and only if:
–there are no type i problems (validity of object models): for anye2e: object
model ome= (obje;rele;classe)is valid for clam (this includes checking the
2-cardinality constraints that should always hold as stated in deﬁnition 9),
–there are no type ii problems (fulﬁlment): there is an event ef2e(e)such
that for any e02ef(e):ome= (obje;rele;classe)is also fulﬁlled (this in-
volves checking the }-cardinality constraints that should eventually hold as stated
in deﬁnition 9),
–there are no type iii problems (monotonicity): for anye1;e22esuch that
e1e2:obje1obje2andclasse1classe2(objects do not disappear or
change class in-between events).
–there are no type iv problems (activity existence): fact(e)je2ega(all
activities referred to by events exist in the behavioral model),
–there are no type v problems (object existence): for all (e;o)2eo:o2obje
(all objects referred to by an event exist in the object model when the event occurs),8
–there are no type vi problems (proper classes): f(act(e);classe(o))j(e;o)2
eogaoc (events do not refer to objects of unrelated classes).
–there are no type vii problems (right number of events per object): for any
(a;oc)2aoc ,e2e, ando2@oc(obje):
8combined with the earlier requirement, this implies that these objects also exist in later object
models.
20for anye02e(e):jfe002@a(e0(e))j(e00;o)2eogj2]2
a(a;oc)(each
objectoof class ochas the required number of corresponding aevents),
there exists a future event ef2e(e)such that for any e02ef(e):jfe002
@a(e0(e))j(e00;o)2eogj2]}
a(a;oc)(each object oof class oceventually
has the required number of corresponding aevents),
–there are no type viii problems (right number of objects per event): for any
(a;oc)2aoc ,e2@a(e):jfo2@oc(obje)j(e;o)2eogj2]oc(a;oc)
(each eventecorresponding to activity ahas the required number of corresponding
objects of class oc).
–there are no type ix problems (behavioral constraints are respected): for each
constraintc2cand reference event eref2@ref(c)(e): there exists a future event
ef2esuch that for any e02ef(e):(jeref(etar)j;jeref(etar)j)2type(c)
where
etar=fetar2@tar(c)(e)j9o2@oc(obje0)f(eref;o);(etar;o)g eogif
crel(c) =oc2oc,
etar=fetar2@tar(c)(e)j9o1;o22obje0(f(r;o1;o2);(r;o2;o1)g\rele06=
;)^f(eref;o1);(etar;o2)geogifcrel(c) =r2rt.
any event log lthat exhibits none of the nine problems mentioned is conforming
toocbcm . therefore, one can argue that deﬁnition 12 provides operational seman-
tics to ocbc models. however, the ultimate goal is not to provide semantics, but to
check conformance and provide useful diagnostics. by checking conformance using
deﬁnition 12, the following four broad classes of problems may be uncovered:
–type i, ii, and iii problems are related to the object models attached to the events
(e.g., object models violating cardinality constraints).
–type iv , v , and vi problems are caused by events referring to things that do not
exist (e.g., non-existing activities or objects).
–type vii and viii problems refer to violations of cardinality constraints between
activities and object classes.
–type ix problems refer to violations of the behavioral constraints (e.g., a violation
of a response or precedence constraint).
the ﬁrst two categories (type i-vi problems) types are more of a bookkeeping
nature and relatively easy to understand. the two categories (vii, viii, ix problems)
are related to the more subtle interplay between activities, objects, relations, and the
behavior over time. these are more interesting, but also quite difﬁcult to understand.
therefore, we elaborate on type vii, viii, ix problems.
figure 16 shows a situation with problems of type vii and type viii. object t3
has twee corresponding payment events ( p1andp2), thus violating the “ 20::1” an-
notation. object t5has no corresponding payment events, thus violating the “ }1”
annotation (assuming there is no corresponding payment in the future). event p3has no
corresponding payment events, thus violating the “ 1::” annotation. note that the object
model is evolving while the process is executed. this is not shown in figure 16, i.e., the
diagram should be viewed as a snapshot of the process after four payment events.
figure 17 shows a situation with problems of type ix. all a2events should have
precisely one preceding a1event that is related through relation r. note that in principle
the object model is evolving, but let us assume that all seven events have the object
21activity pay (events )
p3
p1
t1
t2t3
pay
ticket1..*0..1
1
class ticket (objects )p2 p4
t4t5there cannot be a payment event 
without any corresponding ticket 
(type viii problem )
there cannot be a ticket 
with two related payment 
events  (type vii problem )
eventually every ticket 
needs to have a 
corresponding payment 
event  (type vii problem )fig. 16. an illustration of type vii and viii problems (all related to violations of cardinality
constraints between activities and object classes).
a1 a2
oc1 oc2rc
a1
oc1 oc2r
for simplicity we assume that 
the object model does not 
change in this example 11
11
1
 1..*
a2time
e7e1
o1
o2
o3o4
o6
o5 o7
o8e2 e5 e6e4
e3reference event  e6 has no target 
events and therefore the 
precedence constraint is violated
reference event e3 has one target event 
(e4) but this target event is executed 
after the reference event and  therefore 
the precedence constraint is violated
fig. 17. an illustration of type ix problems. the a1anda2events are executed in the order in-
dicated (from left to right). the object model is assumed to remain invariant during the execution
of the events (to simplify the explanation). constraint cis violated for two of the ﬁve reference
events: both e3ande6have no corresponding a1event that occurred earlier.
model shown at the lower part of figure 17. as stated in deﬁnition 12, there should be
an eventefafter which the constraint holds for any event e0and corresponding object
model ome0. note that the two cases in the last condition of deﬁnition 12 correspond
to the two constraint relations depicted in figure 10. for each reference event eref, the
corresponding set of target events etaris determined by following the links through
the object model. for each eref, the cardinalities are checked: (jeref(etar)j;jeref
(etar)j)2type(c). hence, it is possible to identify the reference events for which the
constraint is violated.
for the situation depicted in figure 17: type(c) =f(before;after )2i ni nj
before = 1g, i.e., there should be precisely one target ( a1) event preceding each refer-
ence (a2) event related through r. considere2 =erefas reference event: etar=fe1g
and target event e1occurs indeed before e2. hence, no problem is discovered for e2.
next we consider e3 =erefas reference event: etar=fe4g, but target event e4occurs
22aftere3. hence,e3has no preceding target event signaling a violation of constraint c
for reference event e3. if we consider e5 =erefas reference event, we ﬁnd no prob-
lem because etar=fe1gand target event e1occurs indeed before e5. if we consider
e6 =erefas reference event, we ﬁnd again a problem because etar=;, so no target
event occurs before e6. if we consider e7 =erefas reference event, we ﬁnd no problem
becauseetar=fe4gand target event e4occurs before after e7. hence, we ﬁnd two
reference event ( e3ande6) for which constraint cin figure 17 does not hold.
deﬁnition 12 not only provides operational semantics for the graphical notation in-
troduced in this paper, but also characterizes a wide range of conformance problems.
following the classiﬁcation of problems used in deﬁnition 12, we mention some pos-
sible diagnostics:
1.diagnostics for type i problems (validity of object models): highlight the 2-
cardinality constraints that make the object model invalid.
2.diagnostics for type ii problems (fulﬁlment): highlight the}-cardinality con-
straints that do not hold at the end of the log.
3.diagnostics for type iii problems (monotonicity): report objects that disappear
or change class over time.
4.diagnostics for type iv problems (activity existence): list the activities appear-
ing in the log and not in the model and highlight the corresponding events in the
event log.
5.diagnostics for type v problems (object existence): highlight all references to
non-existing objects.
6.diagnostics for type vi problems (proper classes): highlight the events that
refer to classes they should not refer to. this can also be shown at the model level,
e.g., counting how many times an event corresponding to activity aincorrectly
refers to class oc.
7.diagnostics for type vii problems (right number of events per object): high-
light the (a;oc)connection if objects in ocdo not (eventually/always) have the
required number of aevents. one can count the number of violations and annotate
the connections. these violations can also be shown in the event log.
8.diagnostics for type viii problems (right number of objects per event): high-
light the (a;oc)connection if aevents do not refer to the speciﬁed number of
objects in class oc. one can count the number of violations and annotate the con-
nections. the corresponding events can also be highlighted in the event log.
9.diagnostics for type ix problems (behavioral constraints are respected):
highlight the constraints that are violated. per constraint one can count the number
of reference events for which the constraint is violated. these reference events can
also be highlighted in the event log.
the types diagnostics and checks needed are very different from existing confor-
mance checking approaches. most of the conformance checking approaches [2,8,18]
only consider control-ﬂow and are unable to uncover the above problems. recently,
conformance checking approaches based on alignments have been extended to also
check conformance with respect to the data perspective [13]. however, these do not
consider a data model and focus on one instance at a time.
23constraints may be temporarily violated while the process is running [4,15]. con-
sider for example a response constraint involving activities aandb: after executing
activityathe constraint is temporarily violated until activity bis executed. this notion
exists in any modeling language where process instances need to terminate and is not
limited to declarative languages. interestingly, the addition of an object may also cre-
ate temporarily violated and permanently violated constraints. consider figure 2 again.
adding an order line object without creating a corresponding order results in a per-
manent violation. however, adding an order line while also creating an order creates a
cascade of obligations: the obligation to have a delivery object, the obligation to have a
pick item event, and the obligation to have a wrap item event. the corresponding three
“}1” cardinalities are temporarily violated, but can still be satisﬁed in the future. im-
plicitly, there is also the obligation to have a corresponding deliver items event in the
future.
interestingly, conformance over ocbc models can be checked very efﬁciently. in
particular, each of the requirements in deﬁnition 12 can be formalized as a boolean,
sql-like query over the input log. the ﬁnal result is obtained by conjoining all the
obtained answers. this means that the data complexity of conformance checking9is
inac0. recall that ac0is strictly contained in l ogspace , and corresponds to the
complexity of sql query answering over a relational database, measured in the size of
the database only.
6 conclusion
in this paper, we proposed object-centric behavioral constraint (ocbc) models as an
integrated approach that merges declarative process modeling and data modeling. car-
dinality constraints are used to specify structure and behavior in a single diagram . in
existing approaches, there is often a complete separation between data/structure (e.g.,
a class model) and behavior (e.g., bpmn, epcs, or petri nets). in ocbc models, dif-
ferent types of instances can interact in a ﬁne-grained manner and the constraints in the
class model guide behavior.
ocbc models are particularly suitable for conformance checking. many deviations
can only be detected by considering multiple instances and constraints in the class
model. in this paper, we identiﬁed nine types of conformance problems that can be
detected using ocbc models.
the integration of data and control-ﬂow constraints gives raise to sophisticated pat-
terns that cannot be captured in contemporary process modeling approaches. in this
light, we want to identify typical behavioral (anti-) patterns that involve multiple in-
stances or interaction between structure and behavior. figure 18 shows an example
pattern. along this line, we plan to study the effect of introducing subtyping in the data
model, a constraint present in all data modeling approaches. the interplay between be-
havioral constraints and subtyping gives rise to other interesting behavioral patterns. for
example, implicit choices may be introduced through subtyping. consider a response
constraint pointing to a payment class with two subclasses credit card payment andcash
9that is, the complexity measured in the size of the log only, assuming that the ocbc model
is ﬁxed.
24end parent
 end child
child
 parent1 1..*1
1 11
r1c1
start parent1
1
start child
c2
c3
c4
11
fig. 18. example pattern. after start-
ing the parent, all kchildren (as de-
ﬁned by r1) need to start. after all k
children ended, the parent ends.
payment . whenever the response constraint is activated and a payment is expected, such
an obligation can be fulﬁlled by either paying via cash or credit card.
finally, we also want to investigate how the notions of consistency andconstraint
conﬂict/redundancy , well-known in the context of declare [4], and the corresponding
notions of consistency andclass consistency , well-known in data models [5], can be
suitably reconstructed and combined in our setting. in this respect, we are currently
studying how to formalize ocbc models using temporal description logics, on the
one hand to obtain a logic-based semantics for our approach, and on the other hand
to derive techniques and decidability/complexity insights on consistency checking and
other reasoning tasks.
references
1. w. aalst. process mining: discovery, conformance and enhancement of business processes
- 2nd edition . springer, 2016.
2. w. aalst, a. adriansyah, and b. dongen. replaying history on process models for confor-
mance checking and performance analysis. wires data mining and knowledge discovery ,
2(2), 2012.
3. w. aalst, p. barthelmess, c. ellis, and j. wainer. proclets: a framework for lightweight
interacting workﬂow processes. international journal of cooperative information systems ,
10(4), 2001.
4. w. aalst, m. pesic, and h. schonenberg. declarative workﬂows: balancing between flexi-
bility and support. computer science - research and development , 23(2), 2009.
5. d. berardi, d. calvanese, and g. de giacomo. reasoning on uml class diagrams. artif.
intell. , 168(1-2), 2005.
6. p. chen. the entity-relationship model - toward a uniﬁed view of data. acm transaction
on database systems , 1(1), 1976.
7. d. cohn and r. hull. business artifacts: a data-centric approach to modeling business
operations and processes. ieee data engineering bulletin , 32(3), 2009.
8. d. fahland, m. leoni, b. dongen, and w. aalst. behavioral conformance of artifact-centric
process models. in business information systems (bis 2011) , volume 87 of lnbip . springer,
2011.
9. o. m. group. omg uniﬁed modeling language 2.5 . omg, 2013.
10. t. halpin and t. morgan. information modeling and relational databases . morgan kauf-
mann publishers inc., san francisco, ca, usa, 2008.
2511. k. hee. information system engineering: a formal approach . cambridge university press,
1994.
12. r. hull et al. business artifacts with guard-stage-milestone lifecycles: managing artifact
interactions with conditions and events. in international conference on distributed event-
based systems (debs 2011) . acm, 2011.
13. m. leoni, w. aalst, and b. dongen. data- and resource-aware conformance checking of
business processes. in business information systems (bis 2012) , volume 117 of lnbip .
springer, 2012.
14. n. lohmann. compliance by design for artifact-centric business processes. in business
process management (bpm 2011) , volume 6896 of lncs . springer, 2011.
15. f. maggi, m. montali, m. westergaard, and w. aalst. monitoring business constraints with
linear temporal logic: an approach based on colored automata. in bpm 2011 , volume
6896 of lncs . springer, 2011.
16. a. nigam and n. caswell. business artifacts: an approach to operational speciﬁcation.
ibm systems journal , 42(3), 2003.
17. omg. object constraint language - version 2.4, 2014. available at: http://www.omg.
org/spec/ocl/2.4/pdf .
18. a. rozinat and w. aalst. conformance checking of processes based on monitoring real
behavior. information systems , 33(1), 2008.
26