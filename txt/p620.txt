conceptual model for on line auditing
wil van der aalst, kees van hee, jan martijn van der werf
department of mathematics and computer science, technische universiteit eindhoven,
p.o. box 513, 5600 mb eindhoven, the netherlands
akhil kumar
smeal college of business, penn state university, university park, state college pa
16802.
marc verdonk
deloitte, netherlands
abstract
the independent veri¯cation of the right applications of business rules in
an information system is a task for auditors. the increasing complexity of
information systems, and the high risks associated with violations of business
rules, have created the need for on line auditing tools. in this paper we
sketch a conceptual design for such a tool. the components of the tool are
described brie°y. the focus is on the database and the conformance checker,
which are described in detail. the approach is illustrated with an example
and some preliminary case studies from industry.
key words: information assurance, auditing, architecture, conceptual
model, constraints, business rules, conformance checking
email addresses: w.m.p.v.d.aalst@tue.nl (wil van der aalst), k.m.v.hee@tue.nl
(kees van hee), j.m.e.m.v.d.werf@tue.nl (jan martijn van der werf),
akhilkumar@psu.edu (akhil kumar), mverdonk@deloitte.nl (marc verdonk)
preprint submitted to elsevier october 12, 20091. introduction
organizations are executing business processes to reach their goals. these
business processes need to be executed within certain boundaries . these
boundaries are de¯ned by business rules coming from di®erent sources. some
rules are enforced by law and the authorities, others by the shareholders.
but contracts with business partners like customers and suppliers also create
boundaries. moreover, the board of an organization itself de¯nes boundaries,
e.g. in a code of conduct. note that \staying within the boundaries" involves
much more beyond avoiding fraud. so we consider fraud as an example of
rule violation and therefore we do not treat it separately.
information systems play a major role in executing the business pro-
cesses, either in cooperation with employees or autonomously. this results
in the need to implement business rules in both the information system and
working instructions for employees. as information systems become more
and more complex, in many situations it becomes very hard to manage the
whole system. since the management of an organization is responsible for
the execution of the business processes and accountable for staying within
the boundaries, there is a need for checking whether the business rules are
being followed on a continuous basis. management has the prime respon-
sibility to assess the operating e®ectiveness of \their" business rules, and
must monitor the execution of the business processes closely. independent
veri¯cation is also needed. this is typically the job for auditors who provide
assurance to stake holders. auditors can be either internal or external. an
internal audit veri¯es adherence to both the internal and external bound-
aries (and can focus on both e®ectiveness and e±ciency of the processes
and the business rules), whereas an external audit typically only focusses
2on the adherence to external boundaries and the e®ectiveness of processes
and business rules. all auditors should be independent in their research
approach and in their judgement.
for ¯nancial statements we have the ¯nancial audit performed by the
cpas (certi¯ed public accountants). they verify if ¯nancial statements of
organizations are in accordance with external boundaries like the generally
accepted accounting principles (gaap) and sarbanes oxley (sox) legis-
lation. but business rules concern much more than the ¯nancial reporting
process and, therefore, there are numerous types of audits, e.g. iso audits,
food safety audits, basel2 audits, information security audits, and opera-
tional audits. one thing all audits have in common is that they often are
very laborious and expensive. moreover an audit always looks at a period
in the past to conclude if the business rules were adhered to in the period
under review, while the management's main interest lies in the future.
in the ideal situation we would have a continuous auditing process that
gives us realtime insights into violations of business rules. clearly this is
not feasible if done manually. therefore, there is an urgent need for bet-
ter techniques and software tools that make it possible to check arbitrary
business rules automatically and in near realtime. one of the approaches
used today is to embed controls in the information system. a control is
an automated task in the information system aiming at the prevention of
violations of certain business rules. these controls are strongly related to
the functions of the information system. often business rules are generic,
i.e. not bound to a speci¯c business context. an example is the four-eyes
principle that says that \two tasks for the same case should be handled by
di®erent agents".
since the information systems become too complex to oversee them, it
3may seem paradoxical that another information system is needed to check
the ¯rst one. however, that is what we propose. our solution is not a type of
theorem prover that veri¯es if the code of the information system correctly
implements the business rules. since people and organizations cannot be for-
mally speci¯ed and may deviate at runtime, we envision a separate system
that monitors therelevant activities of the information system and which
independently checks if these activities conform to business rules. we call
such a system an on line auditing tool or olat for short. consequently,
the information system should be equipped with a logging mechanism and
the olat should be connected to the information system. the envisioned
olat can work in two modes: it can report violations of business rules in
the form of a report to the management of the organization, or it can send
amessage to the information system that can be used to exercise a control .
thus, the olat can also be considered as an external control mechanism
for the information system. in the latter mode we have to be careful since
it looks as if the olat becomes part of the information system and there-
fore it could lose its independent status. however, the olat tool is only
used to detect a (potential) violation and this information can be used in
the information system to prevent the violation or to enact a compensation
action. although some techniques already exist to automate small parts of
the audit process, a system integrating and combining these techniques does
not yet exist.
in this paper we sketch a \full blown" olat. this paper shows the possibil-
ities and capabilities of such a tool, and gives insights into the architecture
and functionality of such a system. some components do not yet exist, and
are ill-de¯ned or even speculative. although we call the tool set \on line",
we do not mean they are all active in a realtime mode. only the conformance
4checking can be done realtime. however, the structure of the olat allows
for reporting on a regular basis, thus providing near realtime information.
we present the components of the olat here to give an impression of the
ideal tool in the future and to sketch the context of the components we are
concentrating on in this paper. these components are the database and the
conformance checker . in fact, we propose an approach that can be realized
with proven o® the shelf database techniques.
the organization of this paper is as follows. rather than focussing on
modeling techniques for data and processes, we focus on the architecture of
a system that can handle any business process. therefore, we focus more
on the meta model of processes and business data. we are not interested in
modeling the business processes of an organization, but only those aspects
that are relevant for the business rules to be monitored. however, we need
these techniques in order to express and check the business rules. therefore,
we present in section 2 some preliminaries, i.e., basic techniques for data
modeling, process modeling and the language to express business rules. in
section 3 we de¯ne the concepts that are related to auditing in an informal
way. in section 4 we give a high-level architecture of an olat. there
we also describe software components for which we do not have a concrete
solution yet. in section 5 we describe a conceptual data model for the olat.
this model can be considered as an abstract design for the database of the
olat. this database will record all data facts from the information system
that are relevant to verify the business rules: both the relevant details of
the business objects and the business processes. in section 6 we study the
business rules in detail. we have chosen to be as language independent
as possible. therefore we use standard predicate calculus to express these
rules. here we also give templates of business rules, among which are several
5well-known rules, and we show how they can be expressed in the constraint
language for the conceptual data model. section 7 gives a concrete example
to illustrate our approach. in section 8 we describe practical experience
with the business rule evaluation in some real life cases. full validation of
the approach is out of scope. section 9 discusses related work and ¯nally,
the last section gives a conclusion and our plan for future work.
2. preliminaries
here we explain techniques for data modeling, process modeling and the
predicate language to express rules. although the focus of this paper is on
the architecture and meta modeling of our olat tool, we need these tech-
niques to illustrate the use of the tool. as we prefer to be as independent
as possible from industry languages, we use plain predicate calculus for the
business rules. they are expressed in terms of the data model. to facilitate
this, we use a restricted form of the er-model with some shorthand nota-
tions. for process models there are many options, but we have chosen petri
nets as a formalism that is well-understood, meaning it has clear behav-
ioral semantics and it is very concise compared to more industrial process
languages, like bpmn or uml-activity diagrams, which are very close to
petri nets. note that we do not intend to present a new modeling approach,
rather we need a consistent combination of di®erent modeling frameworks.
for modeling approaches there exist good literature, cf. [11, 15, 27, 30, 44].
to be self-contained we present a more formal treatment of these modeling
frameworks in appendix b.
6figure 1: a simple petri net
2.1. petri nets
for modeling of business processes we use petri nets [37]. a petri net
consists of transitions (drawn as squares) which represent tasks that can
be performed in a process , and places (drawn as circles), which de¯ne the
conditions when a transition can be executed. places and transitions are
connected by arcs. places that have an arc to (from) a transition tare called
theinput (output) places oft. the state of a petri net, also called a marking
is a distribution of objects, called tokens , over the places. a transition is
enabled if in each of its input places there is at least one token. in that
case it can ¯rewhich means that it consumes a token from each of its input
places and produces a token in each of its output places. the behavior
of a petri net is characterized by the set (in fact graph) of markings that
are reachable by transitions from an initial marking. consider the example
of figure 1. transition ais enabled, since ihas a token. after ¯ring of
transition a, places pandqboth have a token. transitions bandcare
enabled since place pand place qrespectively have a token. after ¯ring
transition b, place rhas a token, but as place shas no token, transition e
is not enabled. only after ¯ring transition c,shas a token, thus enabling
7transition e. transitions eanddare in con°ict, as they share a marked
input place. firing of transition dremoves the token from place r, and
therefore, transition eis not enabled anymore.
2.2. data models
a database consists of entities , i.e., the elements or records stored in
tables. all entities together form an instance of the database. the ¯elds
of a table are called the attributes of the entity. between these entities,
associations exist. on the schema level, entities belong to an entity type ,
associations belong to a relationship . the entity type de¯nes also the type
of attributes of an entity. an entity-relationship diagram (erd) [16] de-
scribes the type of the entities and the relationships between them. entity
types are drawn as rectangles. inside the rectangle, the entity type is given,
together with its attributes. relationships are traditionally drawn as dia-
monds and they are connected to entity types with arcs. we consider only
binary relationships and most of them are functional relations. a func-
tional relationship can be represented as a (possibly partial) function from
one entity type to another. for functional relationships we drop the dia-
mond notation and we represent them directly by an arc from the source
entity type to the target entity type. if at the arrow head a vertical bar is
drawn, the function is total, i.e. for all entities in the instance, the function
returns the associated entity. otherwise, it is a partial function. a non-
functional relation is a many-to-many relation, or a set-valued function. for
non-functional relationships we use the standard diamond notation where
the arrow indicates the direction of the relation. a relationship is uniquely
identi¯ed by the source entity type and the name of the relationship. i.e.,
names for the relationships are only unique for the source entity; from the
8figure 2: a simple data model
context it is always clear which relationship is meant. consider the data
model of figure 2. in this data model, there are three entity types: `task',
`process' and `transition', two functional relationships: `h' and `f', and a
non-functional relationship `tp'. the entity type `task' has a single attribute
`name'. the arrow on relation `tp' indicates that tpµtask£process , i.e.,
`tp' is a many-to-may relation from `task' to `process'. the relationship in-
dicates that an entity of type `task' can have many associations to entities
of type `process', and entities of type `process' can have many associations
to entities of type `task'. now consider the functional relation `h'. it points
from `transition' to `task', indicating that each entity of `transition' is
connected to at most one entity of `task'. the functional relation `f' has
source `transition' and target `process'. the vertical bar at the arrow head
indicates that `f' is a total function.
on data models we use predicate calculus with logical and set operations
and quanti¯ers over domains of entity types, relations and sets. if in a
database instance two entities x; yare in a relationship r, we write ( x; y)2r.
ifris a functional relationship, we write r(x) = yfor (x; y)2r. for
example, we can formalize the constraint that states that if two entities of
type `transition' have an association to the same entity of type `task' and to
the same entity of type `process', these entities are identical, to the following
9formula:
8t1; t22transition : (h(t1) =h(t2)^f(t1) =f(t2)))t1=t2
note that h(t1) indicates the unique entity that is related to t1by functional
relation h. soh(t1) is a term that can be used to for a predicate, for instance
h(t1) =h(t2).
most predicates can be translated into standard sql (cf. [36]), all pred-
icates can be checked using sql augmented with stored procedures. any
constraint can be checked by translating its predicate into a standard sql
query and checking whether the result of the translated query is empty .
in this case, the query would look like: select * from transition t1,
transition t2 where t1.task = t2.task and t1.process = t2.process
and t1.id <> t2.id; . if the result of this query is empty, then the con-
straint holds. this provides a practical approach to implement a confor-
mance checker for business rules: translate the rules into sql queries and
if they evaluate to the empty set, the rule holds.
3. concepts
an auditor will look for assurance that the business processes have per-
formed within the boundaries determined by the business rules, by either
auditing the design , i.e., the implementation and e®ectiveness of controls , or,
alternatively, by looking substantively at the data generated by the system.
the last approach is considered as very costly if done in the traditional way.
we propose in fact a new and e±cient way for substantive data checking.
our proposal is to do it for speci¯c business rules only, in an automated way
and in near realtime.
10since the audit applies to a business process, we brie°y review the basic
process terminology (cf. [4]). a business process is a collection of tasks
with (potentially complex) coordination requirements among them. a task
represents a set of activities in the real world that is considered as one
atomic action performed by an agent , or it is automated. a task is uniquely
associated to a form which is a collection of entities1. an instance of a
business process is called a case. a case has its own case data associated
with it and is stored in a database. when a task is executed for a speci¯c
case, the case data of that case is shown. in the business process a task
can be any kind of activity, however in the information system the execution
of a task boils down to reading, writing or updating these entities. as a
task ¯nishes, the coordination requirements determine the set of tasks that
can be executed. eventually, when no tasks are executable for a case, the
case is closed. the modeling of business processes as petri nets is very well
understood and supported by tools (cf. [4]). remember that we only model
those aspects of business processes that are relevant for the business rules
we are interested in.
agents usually work in a certain role. a roleis a generic identi¯er for
a category of agents in an organization, e.g., a manager, director, vice-
president, etc. are all generic roles. thus, agents joe and mike might be
managers, sue a vice-president, and so on. we further assume that roles are
organized in a hierarchy (i.e. a tree) in which, the ceo is the top node and
each link between nodes represents a boss-employee relation. in general,
every organization has a di®erent hierarchy. there are di®erent ways in
1note that we only use the term \form" as a metaphor, we do not assume a particular
form-based implementation
11which agents can be assigned to roles, but for now we will assume that
an initial assignment of agents to roles is given. an agent a1can grant a
permission to agent a2to perform (a) a speci¯c task, (b) all tasks belonging
to a process, (c) all tasks belong to a case, or (d) a speci¯c task belonging to
a speci¯c case. the agent is only allowed to grant a permission if it possess
this permission itself, either by its role, or through a permission obtained
from another agent.
certain tasks are used to detect or prevent violations of business rules.
these tasks are called controls . there are di®erent types of controls and
many di®erent ways of classifying them. for the purpose of this research we
will classify them in the way they are used to respond to an exception that
occurs on a business rule.
1.detective : this type of control is only able to detect that a violation
to the business rule has occurred. an example: an employee has just
transferred 1 million dollars to his account.
2.corrective : this type of control is like the detective control, but has
the added functionality to (attempt to) correct the violation to the
business rule directly. an example: an employee has just transferred 1
million dollars to his account and the control is preparing to transfer
it back.
3.preventive : this type of control prevents business rules from being
violated. an example: in the current payment run there is 1 million
dollars going to be transferred to the bank account of an employee, but
the payment run will not be processed for this reason. a special case of
preventive controls is a prospective control, which gives a warning if it
is possible to break a business rule based on other actions performed.
12we consider only two kinds of events: a task event and a permission
event. the ¯rst is the execution of a task, the second is the granting of a
permission.
4. top-level architecture
in figure 3 the top-level architecture of the olat is presented. we
distinguish data sets (displayed by drums) and program modules (displayed
by rectangles). some of these modules already have an implementation in
tools like prom [3]. however, to our knowledge, no tool exists that integrates
these techniques into a single information system for auditing purposes.
note that we have more modules in the architecture than we actually will
describe in detail. in this paper we only focus on the conformance checker
and the risk interpreter. for the other modules we only give a high-level
speci¯cation.
the data sets form the database of the olat. the conceptual model
of the database is presented in the next section. the database consists
of three types of data: runtime data, dejure models, and defacto models.
the runtime data collects the data from the monitored information system.
the dejure models are the o±cial models of the desired organization. in
fact, the runtime data should conform to the dejure models. if not, there
is a violation. the defacto models are models derived from the runtime
data by discovery techniques and can di®er from the dejure models.
4.1. runtime data
the runtime data contains the data from the information system. it is
in fact the system log in which all (relevant) events of the information sys-
tem are recorded. so the runtime data concerns the events in the business
13worlddejure - models 
defacto - models inconsistencies 
deviations / 
exceptions risk interrupter
discovery 
programs conformance 
checker 
rule promoterinformation systemdata difference 
analyzer interrupt 
potential risks potential risk 
detector improve 
business 
data process 
models organization 
 structure business 
 rules business 
data process 
models organization 
 structure business 
 rules 
runtime data figure 3: a top level architecture of an online auditing tool
processes such as activities or tasks, and events in the authorization pro-
cesses such as the granting of permissions. this data is needed to perform
analysis by the conformance checker, di®erence analyzer and potential risk
detector.
4.2. dejure and defacto models
the dejure models describe the desired or o±cial situation, whereas the
defacto models are derived from the runtime data, and thus describe the
actual observed situation / behavior. the dejure models are made for the
design of the information system. in the ideal situation these models are
really implemented. both the dejure models and defacto models concern
process models with tasks and their ordering, business data together with
the forms data of the tasks, and the organizational data with the agents and
their roles. last but not least, business rules are also examples of dejure
14and defacto models. business rules are expressed in standard predicate
logic. except for the business rules, these other data sets are collected in
one (relational) database. as the dejure models describe the desired or
o±cial behavior, business rules in the dejure models should not be violated,
whereas business rules in the defacto models are discovered (as will be
discussed later) in the runtime data. the dejure models are loaded from
the information system or directly from the organization, while the defacto
models are obtained by discovery techniques. they may be less complete
than the dejure models. the defacto and dejure models share the same
database schema as presented in the next section (see figure 4).
4.3. conformance checker
the conformance checker checks whether the runtime data conforms
to the dejure models, in particular the dejure business rules. this does not
only include the control °ow behavior, but also data °ow, authorizations and
business rules. since the business rules are expressed in predicate logic, they
can be translated into queries (cf. [36]). the queries run on the database
(i.e. the dejure models plus the runtime data). if the result of the query
is the empty set, the rule is not violated. if a rule is violated, an excep-
tion report is generated based on the returned query containing the counter
examples. this exception report needs to be analyzed by management and
/ or auditors and can lead to either a remedial action or to the conclusion
that the situation should be allowed. in the latter case the rule promoter
can be used to add the newly discovered model to the de-jure models. this
conformance check, i.e. by executing the translated queries, can be run at
any moment in time, thus providing a way to continuously audit the system.
154.4. discovery programs
di®erent from the conformance checker, discovery programs try to de-
rivemodels out of the runtime data. many kinds of existing data mining
andprocess mining techniques and tools can be used to discover not only
control °ow, but also authorization rules, business data models, organiza-
tional models and business rules [5, 38, 39]. in general, mining techniques
try to deduce patterns and rule from facts. in our case the facts are stored
as events in the runtime data set. to discover a process model we look at
the actual execution order of tasks for the cases and from this we can infer
a process structure (for example a petri net) (cf. [2]). for the structure of
business data we could look at data in the form of forms that are used in
the events to derive entities and relationships. for organizational models
we could look at the permission events (in which an agent is granted a per-
mission by another agent). as these rules are derived from the runtime
data, the models obtained by discovery are defacto models. while detailed
discussion of these techniques is beyond the scope of the current work, the
kind of tools we have in mind are included in the well-known process mining
toolset prom [3].
4.5. rule promoter
the rule promoter represents functionality to convert a discovered de-
facto model into a dejure model, speci¯cally if it concerns business rules.
for this, it needs to be able to abstract from the speci¯c instance informa-
tion. in the ¯rst run, the module is used to tune the con¯guration of the
dejure models to the actual situation. later on it may be part of a process of
continuous improvement; e.g. when exceptions are discovered, analyzed and
16accepted, these exceptions are added to the dejure models thus eliminating
`false positives' in the conformance checker.
to the best of our knowledge, there are today no methods or software
for this task. therefore, we assume this to be a human task.
4.6. risk interrupter
the risk interrupter takes input from the dejure models and the run-
time data in a way similar to the conformance checker. the di®erence is that
the risk interrupter interrupts the information system to prevent further
processing of the case under consideration until issues are resolved and the
risk is mitigated. hence, the risk interrupter serves as an external guard
for tasks in an information system. in fact the risk interrupter can be seen
as an external control based on the conformance checker.
4.7. di®erence analyzer
the di®erence analyzer compares the dejure and defacto models. it
also checks whether business rules, process models and organization struc-
ture are not con°icting between the dejure and defacto models. this check
can be seen as a quality check for the models and therefore a check for
the functioning of the whole concept. prototypes of such a tool have been
designed [20].
4.8. potential risk detector
this module is able to detect potential risks by analyzing the runtime
data, the defacto and the dejure models. for instance, if a dejure model
di®ers from a defacto model, we could use it to see if a violation of a dejure
business rule could occur. this information is considered as a warning. in
17the prom toolset ([3]) several tools are available that could be used to realize
this module.
4.9. remarks on the implementation of the olat
we do not consider the implementation of the olat in detail in this
paper. however we note that the heart of the olat is the database that
contains all data. the conformance checker as well as the risk interrupter,
can be based on a standard sql engine. so the part of the system we focus
on can be realized using a standard database management system. of course
the olat needs coupling with the information system to collect events of the
information system and perhaps sends interrupts to the information system.
it also needs a reporting facility. since we aim at a generic olat we should
be able to con¯gure the olat for speci¯c information systems, but this in
fact involves the construction of a standard data-intensive application. for
the other modules, like the discovery programs, we can use existing tools
that use the database. hence, the implementation is a serious engineering
e®ort but does not require new scienti¯c insights.
5. conceptual model
the heart of the olat is the database. this section describes a concep-
tual model for all the datasets needed for the olat. figure 4 depicts the
conceptual model, using the techniques described in section 2. the concep-
tual model consists of a data model, which is explained in section 5.1, and
consistency constraints that should hold for any organization. these con-
straints are explained in detail in section 5.2. note that if these constraints
are violated, the database becomes inconsistent, which is not the same as
18a violation of a business rule. conformance of business rules is treated in
section 6.
5.1. data model
figure 4 depicts the conceptual model. it is arranged into four com-
ponents: the process de¯nition, the business data de¯nition, the organiza-
tional de¯nition and runtime. we ¯rst explain the conceptual model, and
then show how, using predicate logic, all kinds of business rules can be for-
mulated on this model. remember that we do notdistinguish between the
dejure and defacto models here: they share the same data model. also,
note that we sometimes introduce transitive closures of relations (i.e., h¤,u¤
andprev¤). these transitive closures are assumed to be updated explicitly
in the database, which is easy to perform. we use them to avoid recursive
de¯nitions in constraints (i.e. queries), thus allowing us to to implement the
conformance checker with a sql engine.
5.1.1. business data de¯nition
processes involve business data, e.g., entities like invoices, products and
customers. to describe the type of business data and the relationships
between these data elements, we introduce the business data de¯nition. it
stores the entity types of business data and the binary relationship between
them. in fact, this component stores general data models as introduced in
section 2. however, we link them via form links to tasks.
5.1.2. process de¯nition
the process de¯nition component describes the processes monitored in
olat. note that we store the process models in the form of a data model.
aprocess contains tasks that can be executed for that process. processes
19figure 4: conceptual model for olat
are often hierarchical. parts of the process are either reusable or are re¯ned
using sub processes. in our conceptual model, this is modeled by relation
u. if two processes xandyare related via u, then process xuses process y,
i.e.yis a sub process of x. (in the instance (see appendix b) of the data
model this means that ( x; y)2u.) to avoid recursion and to be able to
use queries, we also store the irre°exive transitive closure of uin a relation
named u¤. tasks can be shared by di®erent processes. as stated in the
introduction, a task is identi¯ed with a form providing the necessary data
to execute that task. a task typically reads and writes entities. the entity
20formlink models the relation of the entity types that are used in a form
to perform a task. its attribute type de¯nes whether the entity is read,
written or both. to express conditions on the order in which tasks occur,
we use labeled petri nets. a transition is labeled with the process (relation
f) and the task (relation h) it represents. the conceptual model allows that
transitions which are connected via a place, do not need to be in the same
(sub) process. however we assume that all places connected to a transition
belong to the same process. this way, places can be shared by two or more
processes, thus providing the possibility to de¯ne compositions of processes,
rather than only °at processes. the initial tokens of a place are an attribute
of the place. note that although we use labeled petri nets, any other process
notation could be used to de¯ne the order in which tasks can occur. also
note that we have no direct runtime information of the ¯ring of transitions
or the marking of a place. however it is possible to derive this information
ifhis a bijection (see e.g. [38, 39]).
5.1.3. organizational de¯nition
tasks can be executed by di®erent roles. roles are placed in a hierarchy.
if a role is higher in the hierarchy, it means that this role can execute all
the tasks of its subordinates. the hierarchy is expressed using relation h:
ifaandbare related by h(i.e. ( a; b)2hin the instance) then bis the
supervisor of a. again, we add the transitive and re°exive closure of the
hierarchy relation, h¤.
agents are assigned to roles via an assignment . this assignment can be
for all processes or for a single process, which is depicted by the optional
relation p. to indicate the time interval in which this assignment holds, the
entity assignment has two attributes: start and end, indicating the start
21and end times of the interval.
5.1.4. runtime
the runtime component stores all events and associated data from the
information system. there are two type of events: events that indicate that
something has been done for a speci¯c task (the entity event in the model)
and and the granting of permissions by agents (the entity permission ). the
data associated with an event is business data, i.e. the content of the forms
¯lled in. the entities entity andassociation store the business data de¯-
nition. each entity belongs to an entity type . an association associates
two entities and belongs to some relationship .
acase is an instance of a process, and it proceeds through event s that
are raised whenever a task is executed. an event is always executed by some
agent for a task in a process. the occurrences of events form a partial order.
this partial order is represented by the relation prev. the relation prev¤is
the transitive closure of relation prev, and is used for formulating business
rules. typically, an event for a task in a case also involves entities in the
business data which are created or updated. this information is stored in
updateentity .entity contains the latest version of the entity, updateentity
stores the changes.
if an agent aauthorized another agent bto perform a part of its work,
agent bacquires a permission from agent ato perform some work. a
permission is always for a time interval and it can apply to a role, a process,
a case, a task, or any combination of thereof. by obtaining a role permission,
agent bcan perform all tasks of that role, given that ahas that role in
the ¯rst place. a permission can also apply to a speci¯c process or case,
indicating that agent bcan do anything acan do for that process or case.
22if the permission is for a task, agent bcan execute that task as well. a
permission is only allowed if agent ahas the proper permissions for the work
he delegates. note that it is not always detectable in which role an agent
executes a task, only whether it has the right authorization.
5.2. constraints on the data model
there are two types of constraints that can be de¯ned on the process
model: logical consistency constraints which do not depend on any business
context, i.e. constraints to maintain the consistency of the data model, and
conformance constraints which ensure the conformance of the data model
within the business context. there is a simple distinction between the two:
consistency constraints do not use any speci¯c attribute value, while busi-
ness rules do. the latter are described in the next section. for the business
data, there are no separate constraints, as it is a general schema for an erd.
in the remainder of this section we explain some of the most important con-
sistency constraints. we classify the constraints according to the component
of the entity types they address. we ¯rst describe the constraints in natural
language, their formalization can be found in appendix a.
5.2.1. consistency constraints for the process de¯nition
the conceptual model allows for sub processes. although a process can
be nested arbitrarily deep, cycles in the process hierarchy are of course not
allowed. this can be expressed using two constraints. first, the relation u
should be irre°exive, i.e. processes cannot depend on themselves. secondly,
asu¤is the transitive closure of u, and we do not want any cyclic references,
u¤needs to be irre°exive as well. for the purpose of discovery algorithms,
we require that the task and process uniquely identi¯es a transition. this
gives rise to the following constraints:
23p1:relation u¤is the transitive closure of relation u.
p2:relations uandu¤are irre°exive.
p3:if a transition belongs to a certain process and represents a task, this
task should be a task of that process.
p4:the combination of a task and a process uniquely identi¯es a transition.
to formalize p4, this statement is identical to stating that if for two tran-
sitions t1andt2the related task and process are the same, the transitions
are the same:
8t1; t22transition : (h(t1) =h(t2)^f(t1) =f(t2)))t1=t2
the formalization of all the constraints can be found in appendix a.
5.2.2. consistency constraints for the organizational de¯nition
consistency constraints for the organizational de¯nition are related to
the de¯nition of the role hierarchy and the granting of permissions. permis-
sions can be granted to act in a certain role, to perform a task, or to be
involved in a process or case, or any combination thereof. an agent is only
allowed to give a permission to another agent for a role if that agent has the
proper authorization. the agent has this authorization if either it is allowed
to assume that role, or it possesses the permission explicitly. this leads to
the following (non-exhaustive) set of constraints.
o1:relation h¤is the transitive closure of relation h.
o2:relation h¤is re°exive.
o3:the start time of an assignment is strictly smaller than its end time.
o4:the start time of a permission is strictly smaller than its end time.
24o5:an agent can only grant a permission for a role if it is assigned to that
role, or if it has a permission for that role itself.
o6:an agent can only raise an event for a task in a case if it has a role
assignment to execute that task, or it has a permission to execute it.
5.2.3. consistency constraints for the runtime
the main consistency constraints for the run time are concerned with
the correctness of events: the events should happen in the right order, i.e.
the timestamp of events in the relation prev should conform to the ordering.
also, the storage of business data should be according to the schema. this
leads to the following set of constraints.
r1:the relation prev¤is the transitive closure of relation prev.
r2:if an event yoccurs after event x, then the time stamp of xshould be
at most the time stamp of y.
r3:the source and target entities an association relates to, should be of the
correct type speci¯ed by the relationship the association belongs to.
r4:if an event in a case occurs, the task should be in the process of which
the case is an instance
r5:if an entity is updated by an event, it should be of an entity type that
is in the form of the task the event is of
r6:if a permission is both for a process and a case, the process of the case
should be the same process as the permission is for.
r7:if an agent performs a task, and it is authorized by an assignment, this
assignment is unique.
256. business rules
in this section we present business rules. since it is in principle impos-
sible to list all possible business rules, we only consider some characteristic
examples that occur frequently. remember that a business rule is a con-
straint on the data model involving business data as parameters . therefore,
we are able to express business rules as parameterized constraints. further,
note that we can check them by query processing. so the implementation
of the conformance checker could be based on a standard database engine.
it is not only possible to express business rules for a single process or case,
but it is also possible to express business rules involving several processes or
cases.
in general, business rules concern the following aspects:
²ordering based , i.e. about the execution order of tasks in cases;
²agent based , i.e. about the involvement of a role or agent in cases and
processes;
²value based , i.e. in forms belonging to a task.
in business rules these aspects may be combined. in this section, we show
examples for each of the aspects. in some examples we need the set of
attributes ¤ and the set of values v. we use the notation e:a=vto express
that attribute aof entity ehas value v.
6.1. examples of ordering based rules
ordering based rules express constraints concerning the ordering of events
and tasks in processes. below we use the same function names as in the con-
ceptual model of figure 4.
26task always precedes a task a task t2should always be performed be-
fore task t1in any case of process u.
b1:taskalwaysbeforetask (u:process ;t1;t2:task) :=
8x12event : (p(c(x1)) =u^t(x1) =t1))
9x22event :t(x2) =t2^c(x1) =c(x2)^(x2; x1)2prev¤
restrict update operation after task uis performed in a case, no entity
of type xcan be updated anymore in that case. for example, an
employee cannot change the travel expense form (or entity) after it
has been approved.
b2:restrictupdate (u:task;x:entitytype ) :=
8e1; e22event :c(e1) =c(e2)^t(e1) =u^(e1; e2)2prev¤
^ :(9y2updateentity :p(y) =e2^t(e(y)) =x)
limit number of repetitions of a task in cases of a process in any case
of process ptaskucannot be executed more than ntimes.
b3:limitnroftasks (u:process ;z:task) :=
8w2case :p(w) =u) jfx2event jc(x) =w^t(x) =zgj ·n
6.2. examples of agent based rules
role or agent based business rules express constraints about the involve-
ment of roles and agents in processes.
4-eyes principle two tasks t1andt2in the same case should always be
executed by di®erent agents.
b4:4eyesprinciple (t1;t2:task) :=8x; y2event :
(c(x) =c(y)^t(x) =t1^t(y) =t2))execby (x)6=execby (y)
27mutually exclusive agents two agents a1anda2should never appear
together in a case.
b5:mutualexclusiveagents (a1;a2:agent ) :=:9u1; u22event :
u16=u2^c(u1) =c(u2)^execby (u1) =a1^execby (u2) =a2
task limit on an agent an agent acannot do more than ntasks in any
case of process u.
b6:tasklimitonagent (u:process ;a:agent ;n:nat) :=
8w2case : (p(w) =u))
jfx2event jc(x) =w^execby (x) =agj ·n
forbidden to write an agent a1is not allowed to update any entity in a
process u.
b7:forbiddentowrite (a:agent ;u:process ) :=8x2event :
(execby (x) =a^p(c(x))=u)) :(9y2updateentity :p(y) =x)
6.3. examples of value based business rules
value based business rules concern the values of business data. typically,
these constraints can have the following form:
²two values should be equal,
²one value should be larger then another value, or
²a value should be within some given set (i.e. within some limits).
limit on entity attribute value for an agent an agent ais not allowed
to write an entity of type bwith value of attribute xlarger than n.
28b8:limitentagent (a:agent ;b:entitytype ;x:¤;n:v):=
8z2event ; y2updateentity : (p(y) =z^t(e(y)) =b
^execby (z) =a))e(y):x·n
limit on entity attribute value for a case for each entity of type b
written in case w, the value of attribute xis lower than n.
b9:limitentincase (w:case;b:entitytype ;x:¤;n:v) :=
8y2event ; z2updateentity :c(y) =w^t(e(z)) =b^p(z) =y
^e(z):x< n
approval limit an agent acan only perform task uin a case if for each
entity of type bwritten in that case, attribute xis lower than value
n. e.g., a bank vice-president can approve a loan up to a limit of
$500,000.
b10:apprlim (a:agent ;u:task;b:entitytype ;x:¤;n:v):=
8y2event : (execby (y) =a^t(y) =u)
)limitentincase (c(y); b; x; n )
note that limitentincase is de¯ned in rule b9.
three way match in each case of process n, if task uis executed, then
entities of types a,bandcbelonging to the case should have the same
value. e.g., the price of the invoice should match the price on the
quotation and on the delivery notice.
b11:threewaymatch (u:task;a;b;c:entitytype ) :=
8w2case; v2event ; x; y; z 2updateentity :
29(t(v) =u^c(p(x)) =c(p(y)) =c(p(z)) =c(v) =w)
)(e(x):value = e(y):value = e(z):value
^t(e(x)) =a^t(e(y) =b^t(e(z)) =c)
7. example
in the previous section we have shown how in our conceptual model
business rules can be expressed in predicate logic, and thus can be checked
by transforming these predicates into queries and running them on the
database. as these predicates are parameterized, they can be ¯lled in for
a speci¯c process, by specifying the parameters of the business rules. in
this way, end users and process owners are not confronted with predicate
logic, but rather express business rules on their processes by picking these
predicates and assigning values to the parameters of the rules.
as an example to illustrate the framework, figure 5 shows an administer
account transfer process. in this petri net, if a transition is connected to a
task, the transition is labeled with the name of that task. the petri net has
three unlabeled silent steps, which are needed for routing the process. the
petri net has 20 transitions, the business process consists of 17 tasks; three
transitions are in fact "silent steps" only added for control °ow purposes.
the process starts with a customer representative receiving (task t1) an ac-
count transfer instruction from a client, who records the transfer instruction
(task t2). next, a ¯nancial clerk validates the instructions (task t3). if the
validation reveals a problem, communication details of the invalid instruc-
tion are extracted (task t5). otherwise, a ¯nancial accountant checks the
transaction limit of the transaction (task t4). if the transaction is higher
30than the limit for the customer, the process starts the authorization sub
process, in which the ¯nancial accountant requests an authorization, which
is either authorized or not by the ¯nancial manager (tasks t8aandt8b). if
the limit is not reached, or the transaction is authorized, the banking spe-
cialist checks the available funds. if this check fails, communication details
are derived from the account unit (task t9). if the check is successful, the
accounting entry sub process is started, which applies the accounting entry
and calculates a fee for it. in all cases, the results are collected in a report
(task t15), and after approving it (task t16), the customer is noti¯ed (task
t18). if the report is not approved, it is changed (task t17).
the process also involves the role of the senior ¯nancial manager , who is
in charge of the ¯nancial manager . the ¯nancial manager is head of a team
consisting of a ¯nancial accountant and a ¯nancial clerk. table 1 shows the
assignment of roles to tasks. note that by the hierarchy, e.g., the senior
¯nancial manager can do everything a ¯nancial clerk can do.
the organization has the following agents: agent-joe, agent-sue, agent-
eric and agent-beth. these agents ful¯ll the roles within the organization.
on this organization, we de¯ne the business rules that need to hold on
the process. firstly, it is not allowed to update the entity ` cust-account '
after task t11has been executed. secondly, agent-joe and agent-sue are not
allowed to work together in any case. agent-eric is not allowed to execute
more than 4 tasks, and agent-beth cannot do more than one task. last,
tasks t7andt8ain a case may not be executed by the same agents, and this
also applies to tasks t7andt8b, and for tasks t10a andt10b. to set up the
conformance checker of olat, we need to implement these business rules
in the system. given the set of prede¯ned business rules in the previous
section, the process owner only has to specify the following functions:
31figure 5: example of an account transfer process
32table 1: task-role matrix
roles
task senior
customer banking financial financial financial financial
representative specialist manager manager accountant clerk
task t1 x
task t2 x
task t3 x
task t4 x
task t5 x
task t6 x
task t7 x
task t8a x
task t8b x
task t9 x
task t10a x
task t10b
task t11
task t15 x
task t16 x
task t17
task t18 x
e1:restrictupdate (t11;cust-account )
e2:mutualexclusiveagents (agent-joe ;agent-sue )
e3:tasklimitonagent (agent-eric ;4)
e4:tasklimitonagent (agent-beth ;1)
e5:4eyesprinciple (t7; t8a)
e6:4eyesprinciple (t7; t8b)
e7:4eyesprinciple (t10a; t10b)
most of these rules apply to all processes in the system; however, it is
also possible to associate a process parameter with a rule in order to apply
it speci¯cally to a process or a subprocess.
338. practical experience with business rules
asdata analytics becomes more a®ordable, there are more applications
of it in auditing. the big four audit ¯rms are all venturing into this space
and embedding their principles into the audit approach. in recent years we
have seen a shift from introducing more controls in the information system to
substantive data analytics, to validation of business rules. the main bene¯t
of this type of audit is that there is a shift from identifying the riskfrom
violation of a business rule towards detection of the violation. in practice
we still see a combination of both: a control is tested, it fails and then
the whole population of data has to be validated against the business rules.
while we have not yet developed a full blown olat, deloitte netherlands
used a preliminary version of it in o®-line mode for the validation of several
business rules on large log ¯les from real information systems. we mention
one example in each of the rule classes we have identi¯ed. in all cases, we
could feed the log to the application and execute the queries to check the
business rules in a small amount of time, thus providing an e±cient approach
to audit a complete business process. the outcome of these cases show that
it is feasible to check compliance on a regular basis without many e®ort.
ordering based rule
a utility company introduced the rule that invoices could only be paid
if there was a valid purchase order present in the system. this rule was
applicable for 3 months and was con¯gured in their system as an automated
control, which we veri¯ed to work correctly. however in the process an
invoice was registered in the system just before it was paid and the essence
of the rule was that the company wanted to prevent placing orders that were
not approved through the formal process. therefore it was decided to run
34the business rule \task t1 always precedes task t2" with t1 = \po approval"
and t2 = \invoice registration" against the complete population of invoices
of these 6 months. we found that in the ¯rst 3 months, a signi¯cant number
of invoices were paid without a po approval being present at all. in the last 3
months we noted that for all invoices paid a po had been approved, but that
this approval was in a signi¯cant number of cases occurred after registration
of the invoice.
agent based rule
at a large consumer products company we found that authorizations in
their sap system allowed for booking and approval of purchase orders across
business units. this was against company policy and also posed a risk for the
reliability of their ¯nancial statements. using an extension of the business
rule \forbidden to write" to distinguish between processes in business units
(a.k.a \company code" in sap) we found that on the total population of
1892 purchase orders there were 140 agents involved in 5 business units.
the business rule held for all but one agent that was involved in the process
of two business units. further inquiry about this exception with the agent
con¯rmed that our assessment was correct, but that there was a plausible
explanation for this fact.
value based rule
at a chemical company we found that the invoice veri¯cation option in
sap (which implements the 3-way match) was set to optional. a quick
sample drawn on the population showed that indeed the option had been
disabled for certain purchase orders that were in the selected sample. over-
ruling this option poses the risk that invoice amounts, goods received and
35goods ordered are not in accordance, but the actual impact of this risk is
hard to quantify. we used the business rule \3-way match" to verify the
whole population of purchase orders based on the amount and monetary
value. in this way we were able to assess the invoices that did not pass the
3-way match criteria. these invoices were followed up and some corrections
were made and credit notes requested from suppliers.
9. related literature
most business process modeling tools do not provide adequate support
for information assurance and this is often added in a piecemeal and rather
ad hoc manner. to the best of our knowledge there are few e®orts to de-
velop a comprehensive architecture and conceptual model for online audit-
ing, which is an important part of our contribution. however, there has been
signi¯cant research interest on various vocabularies and logic-based methods
for expressing business rules in the modeling of processes.
since the mid-nineties several groups have been working on techniques
for process mining, i.e., discovering process models based on observed events.
in [5] an overview is given of the early work in this domain. the idea to apply
process mining in the context of work°ow management systems was intro-
duced in [7]. the alpha algorithm was the ¯rst technique able to discover
concurrency [6]. process mining is not limited to discovery. for example,
in the context of prom [3] several approaches to conformance checking were
realized. the best developed technique is the petri-net-based conformance
checking technique by rozinat et al. [38, 39]. here an event log and a
process model are compared and deviations are measured and highlighted
in both the model and log. metrics such as ¯tness, appropriateness, etc.
36quantify conformance and the diagnostics allow for drilling down the prob-
lem. conformance checking is related to checking ¯tness and measuring the
quality of a process mining technique. for example, genetic process min-
ing techniques use a ¯tness function to remove weak candidates from the
current population of models [33]. in [21] negative events are inserted to
turn process mining into a classi¯cation problem, thus addressing problems
related to appropriateness [38, 39]. also related is the work by cook [18, 17]
where the event streams of a process model and a log are compared based
on string distance metrics. recently, several process mining techniques have
been adapted to provide operational support, i.e., process mining is not done
o®-line but on-line. examples are the recommendations provided in [42] and
the predictions given in [1, 19]. these papers illustrate that existing pro-
cess mining techniques can be used in a real-time setting. however, it is
impossible to give a complete review of process mining techniques here, see
www.processmining.org for more pointers to literature.
some related research in this direction is discussed in [22, 23]. here
the authors have developed a declarative approach for process modeling
using the sbvr (structured business vocabulary and rules) vocabulary
and created a new framework. the vocabulary is supported by a model
and allows process modeling and speci¯cation of access constraints in an
english-like language. they also support defeasible logic [9, 34] which is
a non-monotonic logic and can work with a set of inconsistent constraints.
another approach for handling compliance inspired by defeasible logic and
deontic logic [10] is discussed in [40]. these logics are more advanced than
predicate logic, and are based on notions of permissions, obligations and
prohibitions. they are applied in the context of the business contract
language (bcl) [31, 24] where the focus is on how to proceed when one
37party fails to meet its obligations. in such situations, the negligent party
is obliged to perform some other actions in order to make certain amends
for its failure as speci¯ed in bcl. a shortcoming of predicate logic is that
it does not allow description of such scenarios easily. in [2], the authors
have used temporal logic expressions to check whether a log corresponds to
constraints. they express their constraints in linear time logic (ltl) [28]
and use a tool called ltl checker to verify if certain desired properties of
the log are satis¯ed.
prior research has looked at the issue of information security from various
perspectives, e.g. at the network and operating system levels. however,
our focus is on security at the application level, and the stream of security
related research that is relevant here relates to role based access control
(rbac) [41]. the basic rbac framework consists of three entities: roles,
permissions and users. roles (such as manager, director, etc.) are assigned
permissions or rights (to hire an employee, approve a purchase, etc.) and
users (joe, lin, sue) are associated with roles. thus, users acquire certain
permissions to perform organizational tasks by virtue of their membership
in roles. the notion of separation of duties [29, 43], although it preexisted in
accounting and control systems, also reemerged in the context of rbac as
the idea that if task 1 is performed by role a, then task 2 must be performed
by role b, and membership of these roles must not intersect. there are two
types of separations of duty: static and dynamic. in recent years, rbac
has become the preferred access control model for most business enterprises.
this framework allows association of roles with tasks, and only users that
belong to a certain role can perform certain tasks. this is a useful framework
that has now been widely adopted in popular database management systems
from ibm and oracle.
38some related work on speci¯cation and enforcing role-based authoriza-
tions in work°ow systems is discussed in [13]. the main focus of this work is
on enforcement of constraints at run-time. the authors develop algorithms
to check whether, given a combination of tasks and users, it is possible to
¯nd a task assignment that will satisfy the collection of constraints and
available users. a formal model called w-rbac for extending rbac in
the context of work°ows using the notions of case and organizational unit
is described in [45]. a system architecture for enforcing rbac in a web-
based work°ow system is given in [8]. the approach in [14] is based on the
notions of con°icting roles, permissions, users and tasks. more sophisticated
algorithms for enforcing separation of duties in work°ows are developed in
[32]. finally, another stream of prior work that informs our research is the
literature on basic ¯nancial control principles, particularly as it relates to
the recent sarbanes-oxley legislation [12, 35, 25, 26].
10. conclusion
currently, the work of an auditor is mostly manual, and thus very la-
borious. many existing tools that can be used for auditing only focus on a
small part of the actual work of an auditor. in this paper, we argued the
need for on-line auditing of the business processes of an organization and
proposed an on-line auditing tool (olat). such an olat is connected to
the organizations information system but is not a part of it. the assump-
tion is made that all relevant events in the information system are passed
to the olat. in this way, the olat can build an independent image of
the state of a®airs in the business processes. based on this image auditing
processes can run continuously. although some tools and techniques exist,
39these techniques are not well integrated into a single information system.
we presented a high level architecture of such an olat and we studied in
more detail the database and the conformance checker. in fact, we designed
a conceptual data model with a set of consistency constraints in predicate
logic. the business rules are designed to realize this part of the olat by
a standard database management system in such a way that each business
rule is translated in a straightforward way into a query that can be executed
on the database. for the other components of the olat we have referred to
process mining techniques and tools. we have performed some real-life case
studies with the approach using a preliminary tool, however in an o®-line
mode. all studies performed show the realisability of the presented ap-
proach. together with an auditor ¯rm, we are building a prototype of such
an olat tool, integrating the currently available o® the shelf components.
there are several aspects of this work that need elaboration. first of all
we would like to build a prototype and to perform some on-line experiments
with it. secondly we should have the ability to insert business rules from
a library of business rules, i.e a set of prede¯ned predicates like the ones
presented in section 6. this would make it feasible for controllers and other
business experts to add business rules for conformance checking without the
help of computers scientists, by just ¯lling in the parameters. thirdly, we
plan to modify the conceptual model in order to make the delegation of
roles easier. we also intend to extend the conceptual model to incorporate
domain speci¯c knowledge, for instance olat for ¯nancial departments or
for health care systems. finally there are several unexplored components
in the olat architecture, such as the risk interrupter, the potential risk
detector and the di®erence analyzer. we have some rough ideas for them,
but there are many open questions. however, the most urgent activity is
40experimentation with a prototype, because the proof of the pudding is in
the eating.
a. consistency constraints of the data model
in this section, the constraints given in section 5. the relations and
entity types used in the constraints are de¯ned in the datamodel presented
in figure 4. let subperiod (x;y) :=x:start¸y:start^x:end·y:end, and
inperiod (x;y) :=x:start·y:timestamp ·x:end.
a.1. consistency constraints for the process de¯nition
p1:8p1; p22process : (p1; p2)2u¤: (p1; p2)2u
_(9p32process : (p1; p3)2u¤^(p3; p2)2u)
p2:8p2process : (p; p)62u^(p; p)62u¤
p3:8x2transition : (h(x); f(x))2tp
p4:8t1; t22transition : (h(t1) =h(t2)^f(t1) =f(t2)))t1=t2
a.2. consistency constraints for the organizational de¯nition
o1:8r1; r22role : (r1; r2)2h¤:
(r1; r2)2h_(9r32role : (r1; r3)2h¤^(r3; r2)2h)
o2:8r2role : (r; r)2h¤
o3:8x2assignment :x:start < x:end
o4:8x2permission :x:start < x:end
o5:8x2permission : (9z2role :r(x) =z) :
(9y2assignment :from(x) =a(y)^(r(x); r(y))2h¤
^p(x) =p(y)^subperiod (x; y))
_(9y2permission :from(x) =to(y)^t(x) =t(y)
^r(x) =r(y)^p(x) =p(y)^c(x) =c(y)
41^subperiod (x; y))
o6:8x2event :
(9y2assignment :execby (x) =a(y)^inperiod (y; x)
^(9z2role : (z; r(y))2h¤^(t(x); z)2tr)
^(9z2process :p(y) =z))p(y) =p(c(x)) )_
(9y2permission inperiod (y; x)
^(9z2task :t(y) =z))t(y) =t(x)
^(9z2case :c(y) =z))c(y) =c(x)
^(9z2process :p(y) =z))p(y) =p(x)
^(9z2role :r(y) =z))
(9z2role : (z; r(y))2h¤^(t(x); z)2tr)
)
a.3. consistency constraints for the runtime
r1:8e1; e22event : (e1; e2)2prev¤: (e1; e2)2prev
_(9e32event : (e1; e3)2prev¤^(e3; e2)2prev)
r2:8(x; y)2prev :x:timestamp ·y:timestamp
r3:8a2association :t(src(a)) =src(r(a))^t(tar(a)) =tar(r(a))
r4:8e2event : (t(e); p(c(e)))2tp
r5:8u2updateevent :9f2formlink :t(e(u)) =e(f)^t(p(u)) =t(f)
r6:8x2permission : (9y2process ; z2case :
p(x) =y^c(x) =z) :p(x) =p(c(x))
r7:8y2event ; x1; x22assignment :
(c(y) =a(x1) =a(x2)^(t(y); r(x1))2tr^(t(y); r(x2))2tr
^inperiod (x1; y)^inperiod (x2; y) ))x1=x2
42b. formalization of modeling framework
b.1. petri nets
a petri net [37] is a 3-tuple n= (p; t; f ) where (1) pandtare two
disjoint sets of places andtransitions respectively; (2) fµ(p£t)[(t£p)
is a°ow relation . we call the elements of the set p[tnodes ofn, elements
offare called arcs. places are depicted as circles, transitions as squares. for
each element ( n1; n2)2f, an arc is drawn from n1ton2. let n= (p; t; f )
be a petri net. given a node n2p[t, we de¯ne its preset²n=fn0j
(n0; n)2fg, and its postset n²=fn0j(n; n0)2fg. markings are states of
a net. a marking mofnis de¯ned as a function p!n. a pair ( n; m ) is
called a marked petri net . a transition t2tisenabled in a marking mif
and only if 8p2²t:m(p)>0. enabled transitions may ¯re. a transition
¯ring results in a new marking m0, denoted by ( n; m ) [ti(n; m0), with 8p2
p:m0(p) =m(p)¡âf(p; t)+âf(t; p), where âfis the characteristic function
off.
b.2. data model
a database consists of entities , elements or records, stored in tables.
between these entities, associations exist. entities belong to an entity
type, associations belong to a relationship between entity types. an entity-
relationship diagram (erd) [16, 36], describes the type of the entities and
the relationships between them. without loss of generality, we only consider
binary relationships, since non-binary relations can be mapped onto new en-
tities. the cardinality between a relationship rand an entity type ede¯nes
the number of associations of type ran entity of ecan have. in this paper
we limit the cardinality to the set of ranges c=f[0::¤);[1::¤);[0::1];[1::1]g.
43let ¤ be a label set. an entity-relationship diagram (erd) sis a 4-
tuple s= (e;a; r; c r), where (1) eis a set of entity types , (2)a:e ! p (¤)
de¯nes the attribute types for each entity type, (3) r: (¤£ e)! e is a
function de¯ning the relationships , i.e., given a source entity type xand
a name r,y=r(x; r) is the resulting entity type. we call xthesource
entity type of relationship randythetarget entity type ofr. and (4)
cr:r!c£cde¯nes the cardinalities for the relationships, where for a
relation r2randcr(r) = ( x; y), we call xthesource cardinality andy
thetarget cardinality .
the current state of a database is called an instance . letidenote the
universe of entities and vthe set of possible (attribute) values. an instance
consists of entities belonging to an entity type, and associations between
these entities. an instance isof a schema s= (e;a; r; c r) is a 3-tuple
is= (ie; ia; ir) where (1) ie:e ! p (i), returns for each entity type the
entities present; (2) ia:i £¤!vreturns for each attribute the attribute
values of each entity; and (3) ir:r! p(i£i ) returns for each relationship
the set of associations.
an instance is consistent if it satis¯es the erd, i.e., the erd satis¯es all
the constraints in the erd, including the cardinality constraints. this is ex-
pressed as follows. let s= (e;a; r; c r) be an erd, and is= (ie; ia; ir)
be an instance of this erd. the instance is consistent if:
²for all a; b2 esuch that a6=bholds ie(a)\ie(b) =;;
²for all ( i; l)2dom( ia) there exists an entity asuch that i2ie(a)
andl2 a(a); and
²for each relationship r= (a; l; b )2rholds ¼1(ir(r))µie(a),
¼2(ir(r))µie(b), for all a2ie(a) that jfbj(a; b)2ir(r)gj 2
44¼1(cr(r)) and for all b2ie(b) that jfaj(a; b)2ir(r)gj 2¼2(cr(r)).
the constraints are denoted by standard predicate calculus with logical
operators :;^;_;)and quantors 8;9with domains such as 8x2a:á(x)
where ais an entity type, a relationship or a de¯ned set. formulas are built
in a standard way with term symbols from the data model such as entity
types, relationships and attributes, variables like x; y; z and set theory op-
erations like f(x)2a,f¡1(y)µb,g(f(x)) = h(x) and f(x):a=g(y):b,
where aandbare attributes of the result of entity f(x) and g(y) respec-
tively2. for a functional relationship rwith source entity type xand target
entity type y, i.e. r(r; x) =y, we write r(x) =yforx2xandy2y.
otherwise, i.e., ris non-functional, we write ( x; y)2rforx2xandy2y.
references
[1]w.m.p. van der aalst. using process mining to generate accurate
and interactive business process maps. in a. abramowicz and d. fle-
jter, editors, business information systems (bis 2009) workshops , vol-
ume 37 of lecture notes in business information processing , pages 1{
14. springer-verlag, berlin, 2009.
[2]w.m.p. van der aalst, h.t. de beer, and b.f. van dongen. process
mining and veri¯cation of properties: an approach based on temporal
logic. in on the move to meaningful internet systems 2005: coopis,
doa, and odbase: otm confederated international conferences,
2a function could be a partial function. if it is applied outside its domain, the value
?(bottom) is returned.
45coopis, doa, and odbase , number 3760 in lncs, pages 130{147.
springer, 2005.
[3]w.m.p. van der aalst, b.f. van dongen, c.w. gä unther, r.s. mans,
a.k. alves de medeiros, a. rozinat, v. rubin, m. song, h.m.w. ver-
beek, and a.j.m.m. weijters. prom 4.0: comprehensive support for
real process analysis. in application and theory of petri nets and
other models of concurrency (icatpn 2007) , volume 4546 of lecture
notes in computer science , pages 484{494. springer-verlag, berlin,
2007.
[4]w.m.p. van der aalst and k.m. van hee. work°ow management: mod-
els, methods and systems . the mit press, cambridge, massachusetts,
2002.
[5]w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster,
g. schimm, and a.j.m.m. weijters. work°ow mining: a survey of
issues and approaches. data and knowledge engineering , 47(2):237{
267, 2003.
[6]w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow
mining: discovering process models from event logs. ieee transac-
tions on knowledge and data engineering , 16(9):1128{1142, 2004.
[7]r. agrawal, d. gunopulos, and f. leymann. mining process models
from work°ow logs. in sixth international conference on extending
database technology , pages 469{483, 1998.
[8]g.-j. ahn, sandhu. r.s., m.h. kang, and park.j.s. injecting rbac to
46secure a web-based work°ow system. in acm workshop on role-based
access control , pages 1{10, 2000.
[9]g. antoniou, d. billington, g. governatori, and m.j. maher. rep-
resentation results for defeasible logic. acm trans. comput. logic ,
2(2):255{287, 2001.
[10]g. antoniou, n. dimaresis, and g. governatori. a system for modal
and deontic defeasible reasoning. in ai 2007: advances in arti¯cial
intelligence , number 4830 in lecture notes in computer science, pages
609{613. springer-verlag, berlin, 2007.
[11]a. basu and r.w. blanning. a formal approach to work°ow analysis.
information system research , 11(1):17 { 36, 2000.
[12]d. berg. turning sarbanes-oxley projects into strategic business pro-
cesses. sarbanes-oxley compliance journal , november 2004.
[13]e. bertino, e. ferrari, and v. atluri. the speci¯cation and enforcement
of authorization constraints in work°ow management systems. acm
trans. inf. syst. secur. , 2(1):65{104, 1999.
[14]r.a. botha and j.h.p. elo®. separation of duties for access control
enforcement in work°ow environments. ibm syst. j. , 40(3):666{682,
2001.
[15]k. chari and j. perols. an ai-based approach for procurement fraud
detection. in proceedings of the workshop on information technologies
and systems , 2005.
[16]p.p. chen. the entity-relationship model: towards a uni¯ed view of
data. acm transactions on database systems , 1:9{36, jan 1976.
47[17]j.e. cook, c. he, and c. ma. measuring behavioral correspondence
to a timed concurrent model. in proceedings of the 2001 international
conference on software mainenance , pages 332{341, 2001.
[18]j.e. cook and a.l. wolf. software process validation: quantitatively
measuring the correspondence of a process to a model. acm trans-
actions on software engineering and methodology , 8(2):147{176, 1999.
[19]b.f. van dongen, r.a. crooy, and w.m.p. van der aalst. cycle time
prediction: when will this case finally be finished? in r. meersman
and z. tari, editors, proceedings of the 16th international conference
on cooperative information systems, coopis 2008, otm 2008, part
i, volume 5331 of lecture notes in computer science , pages 319{336.
springer-verlag, berlin, 2008.
[20]b.f. van dongen, r.m. dijkman, and j. mendling. measuring similarity
between business process models. in caise , pages 450{464, 2008.
[21]s. goedertier, d. martens, b. baesens, r. haesen, and j. vanthienen.
process mining as first-order classi¯cation learning on logs with
negative events. in a. ter hofstede, b. benatallah, and h.y. paik,
editors, bpm 2007 international workshops (bpi, bpd, cbp, pro-
health, refmod, semantics4ws) , volume 4928 of lecture notes in com-
puter science , pages 42{53. springer-verlag, berlin, 2008.
[22]s. goedertier, c. mues, and j. vanthienen. specifying process-aware
access control rules in sbvr . in advances in rule interchange and
applications , number 4824 in lncs, pages 39{52. springer, 2007.
[23]s. goedertier and j. vanthienen. declarative process modeling with
48business vocabulary and business rules. in on the move to meaningful
internet systems 2007: otm 2007 workshops , number 4805 in lncs,
pages 603{612. springer, 2007.
[24]g. governatori and z. milosevic. a formal analysis of a business con-
tract language. int. j. cooperative inf. syst. , 15(4):659{685, 2006.
[25]s. green. manager's guide to the sarbanes-oxley act: improving in-
ternal controls to prevent fraud . wiley, 2004.
[26]d.a. haworth and l. r pietron. sarbanes-oxley: achieving compli-
ance by starting with iso 17799. information systems management ,
23(1):73{87, 2006.
[27]k.m. van hee, j. keiren, r.d.j. post, natalia sidorova, and j.m.e.m.
van der werf. designing case handling systems. transactions on petri
nets and other models of concurrency , 5100:119{133, 2008.
[28]g. holzmann. spin model checker . addison wesley, 2003.
[29]d.r. kuhn. mutual exclusion of roles as a means of implementing
separation of duty in role-based access control systems. in rbac '97:
proceedings of the second acm workshop on role-based access control ,
pages 23{30, new york, ny, usa, 1997. acm.
[30]a. kumar and j.l. zhao. dynamic routing and operational controls in
work°ow management systems. management science , 45(2), 1999.
[31]p.f. linington, z. milosevic, j. cole, s. gibson, s. kulkarni, and
s. neal. a uni¯ed behavioural model and a contract language for ex-
tended enterprise. data knowl. eng. , 51(1):5{29, 2004.
49[32]d.-r. liu, m.-y. wu, and s.-t. lee. role-based authorizations for
work°ow systems in support of task-based separation of duty. j. syst.
softw. , 73(3):375{387, 2004.
[33]a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst.
genetic process mining: an experimental evaluation. data mining
and knowledge discovery , 14(2):245{304, 2007.
[34]d. nute. defeasible logic. handbook of logic in arti¯cial intelligence and
logic programming, volume 3: nonmonotonic reasoning and uncertain
reasoning , pages 353{395, 1994.
[35]committee of sponsoring organizations. internal control - integrated
framework.
[36]j. paredaens, paul de bra, m. gyssens, and d. van gucht. the struc-
ture of the relational database model . springer-verlag new york, inc.,
new york, ny, usa, 1989.
[37]w. reisig. petri nets: an introduction , volume 4 of monographs in
theoretical computer science: an eatcs series . springer-verlag,
berlin, 1985.
[38]a. rozinat and w.m.p. van der aalst. conformance testing: measur-
ing the fit and appropriateness of event logs and process models. in
bpm 2005 workshops (workshop on business process intelligence) ,
volume 3812 of lecture notes in computer science , pages 163{176.
springer-verlag, berlin, 2006.
[39]a. rozinat and w.m.p. van der aalst. conformance checking of
50processes based on monitoring real behavior. information systems ,
33(1):64{95, 2008.
[40]s. sadiq, g. governatori, and k. namiri. modeling control objectives
for business process compliance. in business process management ,
number 4714 in lecture notes in computer science, pages 149{164.
springer-verlag, berlin, 2007.
[41]r. sandhu, e. coyne, h. feinstein, and c. youman. role-based access
control models. ieee computer , 29(2):38{47, 1996.
[42]h. schonenberg, b. weber, b.f. van dongen, and w.m.p. van der
aalst. supporting flexible processes through recommendations based
on history. in m. dumas, m. reichert, and m.c. shan, editors, interna-
tional conference on business process management (bpm 2008) , vol-
ume 5240 of lecture notes in computer science , pages 51{66. springer-
verlag, berlin, 2008.
[43]r.t. simon and m.e. zurko. separation of duty in role-based environ-
ments. computer security foundations workshop, 1997. proceedings.,
10th, pages 183{194, jun 1997.
[44]wil m. p. van der aalst and kees m. van hee. work°ow management:
models, methods, and systems . mit press, 2002.
[45]j. wainer, a. kumar, and p. barthelmess. dw-rbac: a formal secu-
rity model of delegation and revocation in work°ow systems. inf. syst. ,
32(3):365{384, 2007.
51