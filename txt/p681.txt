repairing process models to reÔ¨Çect reality
dirk fahland and wil m.p. van der aalst
eindhoven university of technology, the netherlands
d.fahland@tue.nl, w.m.p.v.d.aalst@tue.nl
abstract. process mining techniques relate observed behavior (i.e., event logs)
to modeled behavior (e.g., a bpmn model or a petri net). processes models
can be discovered from event logs and conformance checking techniques can be
used to detect and diagnose di erences between observed and modeled behavior.
existing process mining techniques can only uncover these di erences, but the
actual repair of the model is left to the user and is not supported. in this paper
we investigate the problem of repairing a process model w.r.t. a log such that the
resulting model can replay the log (i.e., conforms to it) and is as similar as possible
to the original model. to solve the problem, we use an existing conformance
checker that aligns the runs of the given process model to the traces in the log.
based on this information, we decompose the log into several sublogs of non-
Ô¨Åtting subtraces. for each sublog, a subprocess is derived that is then added to
the original model at the appropriate location. the approach is implemented in
the process mining toolkit prom and has been validated on logs and models from
dutch municipalities.
keywords: process mining, model repair, petri nets, conformance checking
1 introduction
process mining techniques aim to extract non-trivial and useful information from event
logs [1, 14]. typically three basic types of process mining are considered: (a) process
discovery , (b) conformance checking , and (c) model enhancement [1]. the Ô¨Årst type of
process mining is process discovery , i.e., automatically constructing a process model
(e.g., a petri net or a bpmn model) describing the causal dependencies between activities.
the basic idea of control-Ô¨Çow discovery is very simple: given an event log containing a
set of traces, automatically construct a suitable process model ‚Äúdescribing the behavior‚Äù
seen in the log. however, given the characteristics of real-life event logs, it is notoriously
dicult to learn useful process models from such logs. the second type of process mining
isconformance checking [2, 4, 5, 8, 9, 13, 18, 19, 21, 23]. here, an existing process model
is compared with an event log of the same process. conformance checking can be used
to check if reality, as recorded in the log, conforms to the model and vice versa. the
conformance check could yield that the model does not describe the process executions
observed in reality : activities in the model are skipped in the log, the log contains events
not described by the model, or activities are executed in a di erent order than described
by the model.
here, the third type of process mining comes into play: to enhance an existing model
to reÔ¨Çect reality [3]. in principle one could use process discovery to obtain a modelpl32
pl34 pl37
pl46
pl49pl52
pl58
pl61
pl78
pl81
pl84
pl87
pl90pl93
pl102pl111
pl116
pl119 pl123
finalpl50pl53
pl56pl65
pl66
pl76
pl85
pl91pl94
pl97
pl113
pl132
pl141
pl178pl183pl206
pl211 pl215
pl233
pl242
pl256
pl269
pl275
pl285pl1
pl17pl20
pl67
pl77
pl82
pl86
pl98
pl150
pl68
pl151
pl191
pl196
pl202pl801_hoofd_120 (60)01_hoofd_010 (61)
01_hoofd_260 (62)05_eind_010 (63)
06_vd_010 (64)
01_hoofd_110 (65)
01_hoofd_510_1 (66)silent - and split (67)03_gbh_005 (68)
11_ah_ii_010 (69)09_ah_i_010 (70)01_hoofd_180 (71)01_hoofd_130 (72)
01_hoofd_520 (73)
01_hoofd_530 (74)01_hoofd_480 (75)01_hoofd_430 (76)01_hoofd_250 (77)07_ops_010 (78)silent - skip 05_eind_010 (79)silent - skip 03_gbh_005 (80)
01_hoofd_020 (81)
01_hoofd_030_1 (82)
01_hoofd_030_2 (83)14_vrij_010 (84) silent - skip 14_vrij_010 (85)
04_bpt_005 (86)
01_hoofd_065_1 (87)
01_hoofd_065_2 (88)
01_hoofd_090 (89)silent - niet regulier (90)
silent - skip 06_vd_010 (91)silent - skip 07_ops_010 (92)
01_hoofd_101 (93)silent - niet publiceren (94) silent - is regulier (95)
silent - and join (96)
silent - skip procedure verandering (97)
01_hoofd_195 (98)
01_hoofd_200 (99) silent - skip 01_hoofd_200 (100)
silent - and join & split (101)
01_hoofd_270 (102)
01_hoofd_330 (103)
01_hoofd_350_2 (104)silent - skip procedureverandering (105)
01_hoofd_370 (106)
12_ap_010 (107)
01_hoofd_400 (108)01_hoofd_380 (109)
01_hoofd_420 (110)silent - skip weigeringsgrond (111)
01_hoofd_440_2 (112)
01_hoofd_455 (113)
01_hoofd_460 (114)01_hoofd_451 (115)01_hoofd_450 (116)01_hoofd_446 (117)silent - skip bestreden beschikking aangetast (118)silent - skip niet regulier (119)
silent - skip zienswijzen vragen (120)
silent - skip mandaat (121)
10_uov_010 (122)
silent - skip aanhoudingsgrond (123)
silent - skip regulier (124)
silent - and split and join (125)
01_hoofd_510_2 (126)01_hoofd_490_2 (127)
pl32
pl34 pl37
pl46 pl49pl52
pl58
pl61
pl78
pl81
pl84
pl87
pl90pl93
pl102pl111
pl116
pl119pl123
finalpl50pl53
pl56pl65
pl66
pl76
pl85
pl91pl94
pl97
pl113
pl132
pl141
pl178pl183pl206
pl211
pl215 pl233
pl242
pl256
pl269
pl275
pl285pl1
pl17pl20
pl67
pl77
pl82
pl86
pl98
pl150
pl68
pl151
pl191
pl196
pl202pl801_hoofd_12001_hoofd_010
01_hoofd_26005_eind_010
06_vd_01001_hoofd_110
01_hoofd_510_1silent - and split03_gbh_005
11_ah_ii_01009_ah_i_01001_hoofd_18001_hoofd_130
01_hoofd_520
01_hoofd_53001_hoofd_48001_hoofd_43001_hoofd_25007_ops_010silent - skip 05_eind_010silent - skip 03_gbh_00501_hoofd_020
01_hoofd_030_1
01_hoofd_030_214_vrij_010
silent - skip 14_vrij_010
04_bpt_005
01_hoofd_065_1
01_hoofd_065_2
01_hoofd_090
silent - niet regulier
silent - skip 06_vd_010 silent - skip 07_ops_010 01_hoofd_101 silent - niet publiceren silent - is regulier
silent - and join
01_hoofd_200
silent - skip 01_hoofd_200
silent - and join & split
01_hoofd_270
01_hoofd_330
01_hoofd_350_2 silent - skip procedureverandering
01_hoofd_370
01_hoofd_40001_hoofd_380
01_hoofd_420silent - skip weigeringsgrond
01_hoofd_440_2
01_hoofd_455
01_hoofd_46001_hoofd_45101_hoofd_45001_hoofd_446silent - skip niet regulier
silent - skip zienswijzen vragen
silent - skip mandaat
10_uov_010
silent - skip aanhoudingsgrond
silent - skip regulier
silent - and split and join
01_hoofd_510_201_hoofd_490_2silent 01_hoofd_065_1
silent 01_hoofd_510_1silent 01_hoofd_195
silent 01_hoofd_446silent 01_hoofd_270
silent 12_ap_010silent 04_bpt_005
silent 01_hoofd_510_2silent 01_hoofd_030_1
silent 01_hoofd_030_2
silent 01_hoofd_330silent 01_hoofd_110p 3
fig. 1. original model (left), model (middle) obtained by repairing the original model w.r.t. a given
log, and model (right) obtained by rediscovering the process in a new model.
that describes reality. however, the discovered model is likely to bear no similarity
with the original model, discarding any value the original model had, in particular if
the original was created manually. a typical real-life example is the references process
model of a dutch municipality shown in fig. 1(left); when rediscovering the actual
process using logs from the municipality one would obtain the model in fig. 1(right). a
more promising approach is repair , that is change, the original model so that the repaired
model can replay the log and is as similar as possible to the original model . this is the
Ô¨Årst paper to focus on model repair with respect to a given log.
the concrete problem addressed in this paper reads as follows. we assume a petri
netn(a model of a process) and a log l(being a multiset of observed cases of that
process) to be given. nconforms to lifncan execute each case in l, i.e., ncan replay
l. ifncannot replay l, then we have to change nto a petri net n0s.t.n0can replay l
andn0is as similar to nas possible.
this problem is e ectively a continuum problem between conÔ¨Årming that ncan
replay landdiscovering a new model n0from lin case nhas nothing to do with
l. the goal is to avoid the latter case as much as possible. we solve this problem in
a compositional way: we identify subprocesses that have to be added in order repair
n. in more detail, we Ô¨Årst compute for each case l2lanalignment that describes at
which parts, nandldeviate. based on this alignment, we identify transitions of nthat
have to be skipped to replay land which particular events of lcould not be replayed
onn. moreover, we identify the location at which nshould have had a transition to
replay each of these events. we group sequences of non-replayable events at the same
location to a sublog l0ofl. for each sublog l0, we construct a small subprocess n0
2that can replay l0by using a process mining algorithm. we then insert n0innat the
location where each trace of l0should have occurred. by doing this for every sublog
of non-replayable events, we obtain a repaired model that can replay l. moreover, by
the way we repair n, we preserve the structure of ngiving process stakeholders useful
insights into the way the process changed. we observed in experiments that even in
case of signiÔ¨Åcant deviations we could identify relatively few and reasonably structured
subprocesses: adding these to the original model always required fewer changes to the
original model than a complete rediscovery. repairing the model of fig. 1(left) in this
way yields the model shown in fig. 1(middle).
the remainder of this paper is structured as follows. section 2 recalls basic notions
on logs, petri nets and alignments. section 3 investigates the model repair problem in
more detail. section 4 presents a solution to model repair based on subprocesses. we
report on experimental results in sect. 5 and discuss related work in sect. 6. section 7
concludes the paper.
2 preliminaries
this section recalls the basic notions on petri nets and introduces notions such as event
logs and alignments.
2.1 event logs
event logs serve as the starting point for process mining. an event log is a multiset of
traces . each trace describes the life-cycle of a particular case (i.e., a process instance ) in
terms of the activities executed.
deÔ¨Ånition 1 (trace, event log). letbe a set of actions. a trace l2is a sequence
of actions. l2i b()is an event log, i.e., a multiset of traces.
an event log is a multiset of traces because there can be multiple cases having the
same trace. if the frequency of traces is irrelevant, we refer to a log as a set of traces
l=fl1;:::; lng. in this simple deÔ¨Ånition of an event log, an event is fully described by
an action label. we abstract from extra information such as the resource (i.e., person or
device) executing or initiating the activity and the timestamp of the event.
2.2 petri nets
we use labeled petri nets to describe processes. we Ô¨Årst introduce unlabeled nets and
then lift these notions to their labeled variant.
deÔ¨Ånition 2 (petri net). a petri net (p;t;f)consists of a set pofplaces , a set t
oftransitions disjoint from p, and a set of arcs f(pt)[(tp). amarking
mofnassigns each place p2pa natural number m(p)oftokens . anet system
n=(p;t;f;m0;mf)is a petri net (p;t;f)with an initial marking m0and a Ô¨Ånal
marking m f.
3/mt99
/mt101/mt98/mt97 /mt100
/mt112/mt49/mt112/mt50
/mt112/mt51/mt112/mt52
/mt112/mt53/mt112/mt54fig. 2. a net system n.we writey:=fxj(x;y)2fgandy:=
fxj(y;x)2fgfor the pre-and the post-set
ofy, respectively. fig. 2 shows a simple
net system nwith the initial marking [ p1]
and Ô¨Ånal marking [ p6].nwill serve as our
running example.
the semantics of a net system nare
typically given by a set of sequential runs .
a transition tofnisenabled at a marking mofnim(p)1, for all p2t. ift
is enabled at m, then tmay occur in the step mt  !mtofnthat reaches the successor
marking mtwith mt(p)=m(p) 1 ifp2tnt,mt(p)=m(p)+1 ifp2tnt, and
mt(p)=m(p) otherwise, for each place pofn. a sequential run of nis a sequence
m0t1  !m1t2  !m2:::tk  !mfof steps miti+1  !mi+1;i=0;1;2;:::ofnbeginning in the
initial marking m0and ending in the Ô¨Ånal marking mfofn. the sequence t1t2:::tkis an
occurrence sequence ofn. for example, in the net nof fig. 2 transitions ais enabled at
the initial marking; abcd is a possible occurrence sequence of n.
the places and transitions of a petri net can be labeled with names from an alpha-
bet. in particular, we assume label 2denoting an invisible action. a labeled
petri net (p;t;f;`) is a net ( p;t;f) with a labeling function`:p[t!. ala-
beled net system n=(p;t;f;`;m0;mf) is a labeled net ( p;t;f;`) with initial marking
m0and Ô¨Ånal marking mf. the semantics of a labeled net is the same as for an un-
labeled net. additionally, we can consider labeled occurrence sequences of n. each
occurrence sequence =t1t2t3:::ofninduces the labeled occurrence sequence
`()=`(t1)`(t2)`(t3):::`(tk)jnfgobtained by replacing each transition tiby its label
`(ti) and omitting all ‚Äôs from the result by projection onto nfg. we say that ncan
replay a log lieach l2lis a labeled occurrence sequence of n.
2.3 aligning an event log to a process model
conformance checking techniques investigate how well an event log l2i b() and a
labeled net system n=(p;t;f;`;m0;mf) Ô¨Åt together. the process model nmay have
been discovered through process mining or may have been made by hand. in any case, it
is interesting to compare the observed example behavior in land the potential behavior
ofn. in case the behavior in lis not possible according to n(lcannot replay n), we
want to repair n.
in the following we recall a technique for identifying where landndeviate, and
hence where nhas to be repaired. it will allow us to determine a minimal set of changes
that are needed to replay lonn[2, 5, 4]. it essentially boils down to relate l2lto an
occurrence sequence ofns.t.landare as similar as possible. when putting land
next to each other, i.e., aligningandl, we will Ô¨Ånd (1) transitions in that are not part
ofland (2) activities of lthat are not part of [2].
for instance, a trace l=accd is similar to the occurrence sequence =abcd of the
net of figure 2 where trace ldeviates from by skipping over band having an additional
c.
4in order to repair nto Ô¨Åt trace l,nhas to allow to skip over transitions of the Ô¨Årst
kind and has to be extended to execute activities of the second kind. in [5, 4] an approach
was presented that allows to automatically align a trace lto an occurrence sequence of
nwith a minimal number of deviations in an e cient way. all of this is based on the
notion of an alignment and a cost function.
deÔ¨Ånition 3 (alignment). letn=(p;t;f;`;m0)be a labeled net system. let l=
a1a2:::ambe a trace over . amove is a pair (b;s)2([fg )(t[fg )nf(;)g.
analignment of l to n is a sequence =(b1;s1)(b2;s2):::(bk;sk)of moves, s.t.
1.the restriction of the Ô¨Årst component to actions is the trace l, i.e., (b1b2:::bk)j=l,
2.the restriction of the second component to transitions t,(s1s2:::sk)jt, is an occur-
rence sequence of n, and
3.transition labels and actions coincide (whenever both are deÔ¨Åned), i.e., for all
i=1;:::; k, if s i,;`(si),, and b i,, then`(si)=bi.
move ( bi;si) is called (1) a move on model ibi=^ si,, (2) a move on log i
bi,^ si=, and (3) a synchronous move ibi,^ si,.
for instance, for trace l=accd and the net of figure 2, a possible alignment would
be (a;a)(c;c)(;b)(c;)(d;d).
each trace usually has several (possibly inÔ¨Ånitely many) alignments to n. we are
typically interested in a best alignment, i.e., one that has as many synchronous moves as
possible. one way to Ô¨Ånd a best alignment is to use a cost function on moves and to Ô¨Ånd
an alignment with the least costs.
deÔ¨Ånition 4 (cost function, cost of an alignment). let:[t!ndeÔ¨Åne for each
transition and each action a positive cost (x)>1for all x2[t. the costof a move
(b;s)is(b;s)=1ib,,s,(b;s)=(s)ib=, and(b;s)=(b)is=.
the cost of an alignment =(b1;s1):::(bk;sk)is()=pk
i=1(bi;si).
in this paper, we abstract from concrete cost functions. however, we assume that desir-
able moves, i.e., synchronous moves ( b;s) with`(s)=band invisible moves on model
(;s) with`(s)=, have low costs compared to undesirable moves such as moves on
log (b;) and visible moves on model ( ;s) with`(s),.
deÔ¨Ånition 5 (best alignment). letn=(p;t;f;`;m0)be a labeled net system. let 
be a cost function over moves of nand. let lbe a trace over . an alignment (ofl
to n) is a bestalignment (wrt. ) ifor all alignments 0(of l to n) holds (0)().
note that a trace lcan have several best alignments with the same cost. a best alignment
of a trace lcan be found e ciently using an a?-based search over the space of all
preÔ¨Åxes of all alignments of l. the cost function thereby serves as a very e cient
heuristics to prune the search space and guide the search to a best alignment. see [5, 4]
for details.
using the notion of best alignment we can relate any trace l2lto an occurrence
sequence of n.
53 model repair: the problem
the model repair problem is to transform a model nthat does not conform to a log
linto a model n0that conforms to l. we review the state-of-the-art in conformance
checking and investigate the model repair problem in more detail.
3.1 conformance of a process model to a log
conformance checking can be done for various reasons. first of all, it may be used to
audit processes to see whether reality conforms to some normative or descriptive model.
deviations may point to fraud, ine ciencies, and poorly designed or outdated procedures.
second, conformance checking can be used to evaluate the results of process discovery
techniques. in fact, genetic process mining algorithms use conformance checking to
select the candidate models used to create the next generation of models [17].
numerous conformance measures have been developed in the past [2, 4, 5, 8, 21, 9,
13, 18, 19, 23]. these can be categorized into four quality dimensions for comparing
model and log: (1) Ô¨Åtness , (2) simplicity , (3) precision , and (4) generalization [1]. a
model with good Ô¨Åtness allows for most of the behavior seen in the event log. a model
has a perfect Ô¨Åtness if all traces in the log can be replayed by the model from beginning
to end. the simplest model that can explain the behavior seen in the log is the best model.
this principle is known as occam‚Äôs razor. a model is precise if it is not ‚ÄúunderÔ¨Åtting‚Äù,
i.e., the model does not allow for ‚Äútoo much‚Äù behavior. a model is general if it is not
‚ÄúoverÔ¨Åtting‚Äù, i.e., the model is likely to be able to explain unseen cases [1, 2].
the Ô¨Åtness of a model nto a log lcan be computed using the alignments of sect. 2.3
as the fraction of moves on log or move on model relative to all moves [2]. the aligned
event log can also be used as a starting point to compute other conformance metrics such
as precision and generalization.
3.2 repairing a process model to conform to a log
although there are many approaches to compute conformance and to diagnose deviations
given a log land model n, we are not aware of techniques to repair model nto conform
to an event log l.
there are two ‚Äúforces‚Äù guiding such repair. first of all, there is the need to improve
conformance. second, there is the desire to clearly relate the repaired model to the
original model, i.e., repaired model and original model should be similar. given metrics
for conformance and closeness of models, we can measure the weighted sum or harmonic
mean of both metrics to judge the quality of a repaired model. if the Ô¨Årst force is weak
(i.e., minimizing the distance is more important than improving the conformance), then
the repaired model may remain unchanged. if the second force is weak (i.e., improving
the conformance is more important than minimizing the distance), then repair can be
seen as process discovery. in the latter case, the initial model is irrelevant and it is better
to use conventional discovery techniques. put di erently, the model repair problem is
positioned in a spectrum of two extremes:
keep keep the original model because it is of high value and non-conformance is within
acceptable limits, e.g., 99.9% of all cases can be replayed.
6discover model and log are e ectively unrelated to each other, e.g., no case can be
replayed and alignments Ô¨Ånd few or no synchronous moves.
typically model repair is applied in settings in-between these two extremes. this creates
a major challenge: how to identify which parts of a model shall be kept, and which
parts of a model shall be considered as nonconformant to the log and hence changed,
preferably automatically? the latter is a local process discovery problem which requires
to balance the four quality dimensions of conformance as well.
3.3 addressing di erent quality dimensions
in this paper, we primarily focus on Ô¨Åtness which is often seen as the most important
quality dimension for process models. a model that does not Ô¨Åt a given log (i.e., the
observed behavior cannot be explained by the model) is repaired using the information
available in the alignments.
only for a Ô¨Åtting model precision can be addressed [18]; our particular technique
for model repair will cater for precision as well. the two other criteria of generalization
and simplicity may contradict these aims [1, 14]. generalization and precision can be
balanced, for instance using a post-processing technique such as the one presented
in [11].
similarity of the repaired model to the original model, as well as simplicity of the
repaired model in general, is harder to achieve. it may require tradeo s with respect to
the other quality dimensions. for model repair basically the same experiences apply as
for classical process discovery: while repairing, one should not be forced to extend the
model to allow for all observed noisy behavior ‚Äî it could result in overly complicated,
spaghetti-like models. therefore, we propose the following approach.
1.given a log land model n, determine the multiset lfof Ô¨Åtting traces and the
multiset lnof non-Ô¨Åtting traces.
2.split the multiset of non-Ô¨Åtting traces lnintoldandlu. according to the domain
expert the traces in ldshould Ô¨Åt the model, but do not. traces in lucould be
considered as outliers /noise (according to the domain expert) and do not trigger
repair actions.
3.repair should be based on the multiset l0=lf[ldof traces. l0should perfectly
Ô¨Åt the repaired model n0, but there may be many candidate models n0.
4. return a repaired model n0that can be easily related back to the original model n,
and in which changed parts are structurally simple.
the critical step of separating lninto ldandludoes not require manual inspection
of each case by a domain export. a number of standard preprocessing techniques can
help to Ô¨Ålter ln: by (1) including in ldonly cases with particular start and end events,
by (2) Ô¨Åltering infrequent events (that occur only rarely), and by (3) identifying events
that occur out of order using trace alignment [7]; see [6] for a comprehensive use of
preprocessing techniques in a case study.
in the remainder, we assume l0to be given, i.e., outliers luoflare removed. if an
event log is noisy and one includes also undesired traces lu, it makes no sense to repair
the model while enforcing a perfect Ô¨Åt as the resulting model will be spaghetti-like and
not similar to the original model.
7a c fc e d
a c b e b d
[p2,p3] [p4,p3] [p4,p5] [p4,p3] [p4,p5] [p6]
/mt99
/mt101/mt98/mt97 /mt100/mt112/mt50
/mt112/mt51/mt112/mt52
/mt112/mt53/mt112/mt54/mt99/mt102
after replaying acfca b c cf e d
a b c e b d
[p2,p3] [p2,p5] [p4,p5] [p4,p3] [p4,p5] [p6]
/mt99
/mt101/mt98/mt97 /mt100/mt112/mt50
/mt112/mt51/mt112/mt52
/mt112/mt53/mt112/mt54/mt99/mt102
after replaying abccf
fig. 3. alignments of log l=facfced;abccfedgto the net of fig. 2.
4 repairing processes by adding subprocesses
in the following, we present a solution to model repair. we Ô¨Årst sketch a naive approach
which completely repairs a model w.r.t. the quality dimension of Ô¨Åtness but scores poorly
in terms of precision . we then deÔ¨Åne a more advanced approach that also caters for
precision. improvements w.r.t. simplicity are discussed at the end.
4.1 naive solution to model repair ‚Äì fitness
alignments give rise to a naive solution to the model repair problem that we sketch in
the following. it basically comprises to extend nwith a-transition that skips over a
transition twhenever there is a move on model ( ;t), and to extend nwith a self-looping
transition twith label awhenever there is a move on log ( a;). this extension has to
be done for all traces and all moves on log /model. the crucial part is to identify the
locations of these extensions.
figure 3 illustrates how the non-Ô¨Åtting log l=facfced;abccfedgaligns to the net
nof fig. 2. the nets below each alignment illustrate the di erences between log l
of fig. 3 and net nof fig. 2. after replaying ac, the net is in marking [p4;p3]and
the log requires to replay fwhich is not enabled in the net. thus a log move ( f;) is
added. similarly, cis not enabled at this marking and log move ( c;) is added. then e
should occur, which requires to move the token from p3top5, i.e., a model move ( ;b).
correspondingly, the rest of the alignment, and the second alignment is computed. the
third line of the alignment describes the marking that is reached in nby replaying this
preÔ¨Åx of the alignment on n.
using this information, the extension w.r.t. a move on model ( ;t) is trivial: we just
have to create a new -labeled transition tthat has the same pre- and post-places as
t. the extension w.r.t. a move on log ( a;) provides various options that only require
that an a-labeled transition is enabled whenever this move on log occurs. we can use
the alignment to identify for each move on log ( a;) in which marking mofnit
should have occurred (the ‚Äúenabling location‚Äù of this move). in principle, adding an
a-labeled transition that consumes from the marked places of mand puts the tokens back
immediately, repairs nw.r.t. to this move on log. however, we improve the extension
by checking if two moves on log would overlap in their enabling locations. if this is
8/mt99
/mt101/mt98/mt97 /mt100
/mt112/mt49/mt112/mt50
/mt112/mt51/mt112/mt52
/mt112/mt53/mt112/mt54/mt102
/mt99
/mt99
/mt101/mt98/mt97 /mt100
/mt112/mt49/mt112/mt50
/mt112/mt51/mt112/mt52
/mt112/mt53/mt112/mt54/mt102
/mt99fig. 4. result of repairing the net of fig. 2 w.r.t. the log of fig. 4 by the naive approach (left) and
by adding subprocess (right).
the case, we only add one a-labeled transition that consumes from and produces on this
overlap only.
figure 4(left) shows how model nof fig. 2 would be repaired w.r.t. the alignment
of fig. 3. the move on model ( ;b) requires to repair nby adding a transition that
mimics bas shown in fig. 4. the move on log ( c;) occurs at two di erent locations
fp4;p3gandfp4;p5gin the di erent traces. they overlap on p4. thus, we repair n
w.r.t. ( c;) by adding a c-labeled transition that consumes from and produces on p4.
correspondingly for ( f;). the extended model that is shown in fig. 4(left) can replay
loglof fig. 3 without any problems.
4.2 identify subprocesses ‚Äì precision
the downside of the naive solution to model repair is that the repaired model has low
precision. for a log lwhere a best alignment contains only few synchronous moves,
i.e., ndoes not conform to l, many-transitions and self-loops are added. in fact,
we observed in experiments that self-looping transitions were often added at the same
location creating a ‚ÄúÔ¨Çower sub-process‚Äù of events 0lthat locally permitted arbitrary
sequences ( 0)to occur.
in the following, we turn this observation into a structured approach to model repair.
instead of just recording for individual events a2their enabling locations w.r.t. log
moves, we now record enabling locations of sequences of log moves . each maximal
sequence of log moves (of the same alignment) that all occur at the same location is
anon-Ô¨Åtting sub-trace . we group non-Ô¨Åtting subtraces at the same location qinto a
non-Ô¨Åtting sublog lqof that location. we then discover from lqasubprocess n(lq)
that can replay lqby using a mining algorithm that guarantees perfect Ô¨Åtness of n(lq)
tolq. we ensure that n(lq) has a unique start transition and a unique end transition. we
then add subprocess n(lq) tonand let the start transition of n(lq) consumes from q
and let the end transition of n(lq) produce on q, i.e., the subprocess models a structured
loop that starts and ends at q.
figure 4(right) illustrates this idea. the model depicted is the result of repairing
nof fig. 2 by adding subprocesses as described by the alignments of fig. 3. we can
identify two subtraces cfandfcthat occur at the same sublocation p4. applying process
discovery on the sublog fcf;fcgyields the subprocess at the top right of fig. 4(right) that
putscandfin parallel. the two grey-shaded silent transitions indicate the start and end
of this subprocess.
94.3 formal deÔ¨Ånitions
the formal deÔ¨Ånitions read as follows. for the remainder of this paper, let nbe a petri
net system, let lbe a log. for each trace l2l, assume an arbitrary but Ô¨Åxed best Ô¨Åtting
alignment(l) to be given. let (l)=f(l)jl2lgbe the set of all alignments of the
traces in lton.
locations. let=(a1;t1):::(an;tn) be an alignment w.r.t. n=(p;t;f;m0;mf;`).
for any move ( ai;ti), let mibe the marking of nthat is reached by the occurrence
sequence t1:::ti 1jtofn. for all 1in, if (ai;ti)=(ai;) is a log move, then the
enabling location of (ai;) is the set loc(ai;)=fp2pjmi(p)>0gof places that
are marked in mi. for example in fig. 3, loc(c;)=fp4;p3gin the Ô¨Årst alignment and
loc(c;)=fp4;p5gin the second alignment.
it is easy to check that extending nwith a new a-labeled transition twitht=
loc(ai;)=tturns the log move ( ai;) into synchronous move ( ai;t), i.e., repairs n
w.r.t. ( ai;). we now lift this local repair for one log move to a repair for all alignments
of a log to n.
subtraces. any two consecutive log moves have the same location as the marking
ofndoes not change. we group these moves into a subtrace. a maximal sequence
=(ai;):::(ai+k;) of consecutive log moves of is asubtrace of at location q
iloc(aj;)=loc(ai;)=q;iji+k, and no longer sequence of log moves has
this property. we write loc()=loc(ai;) for the location of subtrace . let(l) be the
set of all subtraces of all alignments (l) oflton.
for example, in fig. 4, fcis a subtrace of the Ô¨Årst alignment at location fp4;p3gand
cfis a subtrace of the second alignment at location fp4;p5g. we could repair the net by
adding two subprocesses, one that can replay fcatq1=fp4;p3gand one that can replay
cfatq2=fp4;p5g. however, we could instead just add one subprocess that can replay
fcandcfat location q1\q2=fp4g.
formally, we say that qis a sublocation of a subtrace =(a1;):::(ak;) i
qloc(). asublog (lq;q) of(l) at location qis a set of subtraces lq(l) s.t.
for all2lq,;,qloc(), that is, each trace in lqcan start at sublocation qof its
Ô¨Årst event.
sublogs. the entire set of subtraces (l) can be partitioned into several sublogs of
disjoint sublocation, though there are multiple ways of partitioning. we call a set
f(lq;1;q1);:::; (lq;k;qk)gof sublogs of (l)complete ilq;1[:::[lq;k=(l).
while completeness is enough to repair nw.r.t. l, one may want to have as few sublogs
at as few locations as possible, for instance, by merging two sublogs ( lq;1;q1) and
(lq;2;q2) to ( lq;1[lq;2;q1\q2) ifq1\q2,;. we callf(lq;1;q1);:::; (lq;k;qk)g
minimal iqi\qj=;for all 1i<jk. there may be multiple minimal complete
sets of sublogs of l. this allows us to conÔ¨Ågure the repair w.r.t. the locations and the
contents of the di erent sublogs, yielding di erent repair options.
we now have all notions to formally deÔ¨Åne how to repair model nw.r.t. log l. for
a complete set of sublogs of (l), we can repair nw.r.t.(l) by discovering for each
sublog ( lq;q) a process model nq, adding nqtonand connecting the start- and end
transition of nqtoq.
10deÔ¨Ånition 6 (subprocess of a sublog). letlbe a log, let nbe a petri net, let (l)be
an alignment of l to n, and let (lq;q)be a sublog of (l).
letl+
q=fstart a 1:::akendj(a1;):::(ak;)2lqgbe the sequences of events
described in l qextended by a start event and an end event (start ;end<l).
letmbe a mining algorithm that returns for any log a Ô¨Åtting model (i.e., a petri net
that can replay the log). let n q=m(l+
q). then (nq;q)is the subprocess of l q.
the mining algorithm mwill produce transitions labeled with the events in l+
qand
a start transition tnq
startwith label start and an end transition tnq
endwith label end. in the
following, we assume thattnq
start=;andtnq
end=;, i.e., that start and end transitions have
no pre- or post-places. in case mproduced pre- and post-places for start and end, these
places can be safely removed without changing that nqcan replay l+
q. when repairing
n, we connect tnq
startandtnq
endto the location qof the subprocess.
deÔ¨Ånition 7 (subprocess model repair). letlbe a log, let nbe a petri net. let (l)
be the alignments of the traces of l to n.
letf(lq;1;q1);:::; (lq;k;qk)gbe a minimal and complete set of sublogs of (l).
thesubprocess-repaired model ofnw.r.t.(l)is the net n0that is obtained from nas
follows.
‚Äìadd to na fresh transition t<tnwitht=tandt=t;`0(t)=ithere
exists an alignment 2(l)containing a visible model move (;t), and
‚Äìfor each sublog (lq;i;qi);i=1;:::; k, let(nq;i;qi)be the subprocess of lq;is.t.
nq;iandnare disjoint (share no transitions or places). extend nwith nq;i(add all
places, transition and arcs of nq;iton) and add arcs (q;tnq;i
start)and(tnq;i
end;q)for each
q2qi, and set labels `0(tnq;i
start)=and`0(tnq;i
end)=.
theorem 1. letlbe a log, let nbe a petri net. let (l)be the alignments of the traces
ofltonandf(lq;1;q1);:::; (lq;k;qk)gbe a minimal and complete set of sublogs of
(l). let n0be a subprocess-repaired model of nw.r.t. these subtraces. then each trace
l2l is a labeled occurrence sequence of n0, that is, n0can replay l.
proof (sketch). the theorem holds from the observation that each alignment =
(a1;t1):::(an;tn)2(l) ofltoncan be transformed into an alignment of lton0
having synchronous moves or model moves on invisible transitions only as follows.
every move on model ( ;ti) ofw.r.t. nis replaced by a model move ( ;ti;) w.r.t.
n0on the new invisible transition ti;;`(ti;)=which allows to skip over ti.
every move on log ( a;) w.r.t. nis part of a subtrace =(a1;):::(ak;) of
a sublog ( lq;i;qi). by adding the subprocess nq;iat location qi, the subtrace is
replayed by a sequence ( ;tnq;i
start)(a1;t1):::(ak;tk)(;tnq;i
end) of synchronous moves in the
subprocess nq;i. moves ( tnq;i
start;) and ( tnq;i
end;) are harmless because they are made
silent by relabeling tnq;i
startandtnq;i
endwith. u t
this theorem concludes the techniques for process model repair presented in this
paper. observe that original model nis preserved entirely as we only add new transitions
andnew subprocesses . by taking a best alignment (l) oflton, one ensures that
number of new -transitions and the number of new subprocesses (or of new self-looping
transitions) is minimal.
114.4 improving repair ‚Äì simplicity
the quality of the model repair step can be improved in some cases. according to def. 7,
each sublog ( lq;i;qi) is added as a subprocess nq;ithat consumes from and produces
on the same set qiof places, i.e., the subprocess is a loop. if this loop is executed in
each case of lonly once, then nq;iis also executed exactly once. thus, ncould be
repaired by inserting nq;iin sequence (rather than as a loop), by reÔ¨Åning the places
qi=fq1;:::; qkgto placesfq 
1;:::; q 
kgandfq+
1;:::; q+
kgwith
1.q 
j=qj;q 
j=ftnq;i
startg;j=1:::;k, and
2.q+
j=qj;q+
j=ftnq;i
endg;j=1:::;k.
also, the repaired model n0can structurally be simpliÔ¨Åed by removing those model
elements which are no longer used. consider for instance a transition twhich is never
executed because the alignment only includes moves on model ( ;t), where tis the
new transition to skip over t. in this case tis always bypassed by transition tandtcan
be removed from n0.
5 experimental evaluation
the technique for model repair presented in this paper is implemented in the process
mining toolkit prom 6 in the package, available from http://www.promtools.org/
prom6/ .
uma provides a plugin repair model that takes as input a petri net n, a log l, and a
best-Ô¨Åtting alignment (l) oflton. the alignment can be computed in prom 6 using
the conformance checker of [2, 5, 4]. the repair model plugin repairs nby extending
nwith subprocesses as deÔ¨Åned in sect. 4.3 and sect. 4.4. for this, it Ô¨Årst replays each
alignment on n, and identiÔ¨Åes all subtraces. then subtraces are grouped to sublogs at
the same location. the resulting sublogs are merged if they share the same location in
a greedy way (by merging sublogs with the largest overlap of places Ô¨Årst), until the
resulting set of sublogs is minimal (i.e., all locations are disjoint). each sublog is then
passed to the ilp miner [24] which guarantees to return a model that can replay the
sublog. the returned model is then simpliÔ¨Åed according to [11] and added to nas a
subprocess as deÔ¨Åned in def. 7.
we validated our implementation on real-life logs from a process that is shared by
Ô¨Åve dutch municipalities. figure 1(left) shows the reference base model that is used
in several municipalities. however, each municipality runs the process di erently as
demanded by the ‚Äúcouleur locale‚Äù. as a result, the process observed in each municipality
substantially deviates from the base model. to validate our technique, we repaired the
base model for each municipality based on the municipality‚Äôs log. in the following, we
report our Ô¨Åndings.
we obtained 5 raw logs (m1-m5) from the municipalities‚Äô information systems.
from these we created Ô¨Åltered logs (m1f-m5f) by removing all cases that clearly should
not Ô¨Åt the base model, for instance because they lacked the start of the process or were
incomplete (see sect. 3 for the discussion). table 1 shows the properties of these 10 logs
(over 44 di erent event classes) discussed in the following. the table lists the number of
12table 1. results on model repair for 10 logs from dutch municipalities.
log deviations subprocesses change to original
moves on per # added jtj totaljtj similarity-dist.
traces length model log case avg. max. add. rem. repair discover
m1 434 1-51 3327 310 1-26 7 7 21 69 3 0.144 0.476
m2 286 1-72 1885 323 1-41 5 10 23 65 3 0.147 0.486
m3 481 2-82 3079 1058 1-49 10 13 37 151 3 0.199 0.542
m4 324 1-37 2667 192 2-21 8 7 13 71 4 0.139 0.541
m5 328 2-43 3107 342 2-25 6 9 24 60 3 0.143 0.540
m1f249 24-40 681 229 1-12 2 6 9 25 4 0.074 0.473
m2f180 23-70 516 240 1-41 2 12 21 37 5 0.103 0.539
m3f222 22-82 465 598 1-49 7 10 26 87 5 0.164 0.543
m4f239 15-37 1216 180 2-17 6 7 13 60 4 0.124 0.542
m5f328 13-43 1574 280 2-16 4 9 23 51 3 0.111 0.541
traces, minimum and maximum length, and the properties of a best matching alignment
of the log to the model of fig. 1(left) as the total number of model moves, number of
log moves and the minimum and maximum number of deviations (log move or model
move) per case. none of the traces could be replayed on the base model, in some cases
deviations were severe.
repairing the base model of fig. 1(left) w.r.t. the Ô¨Åltered log m1fyields the model
of fig. 1(middle). repairing the same model w.r.t. the raw log m1 results in the model
shown in fig. 5(left). repairing the base model w.r.t. the Ô¨Åltered log m2fyields the
model of fig. 5(right). in each case, model repair requires only several seconds; a best-
Ô¨Åtting alignment (needed for repair) could be obtained in about a minute per log. we
checked all resulting models for their capability to replay the respective log and could
conÔ¨Årm complete Ô¨Åtness for all models.
moreover, we could re-identify the original model as a sub-structure of the repaired
model, making it easy to understand the made repairs in the context of the original
model. the original model had 68 transitions, 59 places, and 152 arcs. table 1 shows
for each log the number of added subprocesses, the average and maximal number of
transitions per subprocess, and the total number of added and of removed transitions
in the entire process. we can see that in the worst case, m3, the number of transitions
in the model is more than tripled. nevertheless, this large number of changes is nicely
structured in subprocesses: between 2 and 10 subprocesses were added per log, the
largest subprocess had 37 transitions, the average subprocess had 6-13 transitions. we
identiÔ¨Åed alternatives, concurrent actions, and loops in the di erent subprocesses. yet,
simpliÔ¨Åcation [11] ensured a simple structure in all subprocesses, i.e., graph complexity
between 1:0 and 2:0. model repair also allowed 25%-30% of the original transitions to
be skipped by new -transitions; only few original transitions could be removed entirely.
to measure similarity, we computed the graph similarity distance [10] between
repaired model and original model, and between a completely rediscovered model and the
original model. the rediscovered model was obtained with the ilp miner [24] (ensuring
Ô¨Åtness) and subsequently simpliÔ¨Åed by the technique of [11] using the same settings as
for subprocess simpliÔ¨Åcation. the similarity distance, roughly, indicates the fraction of
13pl32
pl34 pl37
pl46
pl49pl52
pl58
pl61
pl78
pl81
pl84
pl87
pl90pl93
pl102pl111
pl116
pl119pl123
finalpl50pl53
pl56pl65
pl66
pl76
pl85
pl91pl94
pl97
pl113
pl132
pl141
pl178pl183pl206
pl211
pl215 pl233
pl242
pl256
pl269
pl275
pl285pl1
pl17pl20
pl67
pl77
pl82
pl86
pl98
pl150
pl68
pl151
pl191
pl196
pl202pl801_hoofd_12001_hoofd_010
01_hoofd_26005_eind_010
06_vd_010 01_hoofd_110
01_hoofd_510_1silent - and split03_gbh_005
11_ah_ii_01009_ah_i_01001_hoofd_18001_hoofd_130
01_hoofd_520
01_hoofd_53001_hoofd_48001_hoofd_43001_hoofd_250
07_ops_010silent - skip 05_eind_010 silent - skip 03_gbh_00501_hoofd_020
01_hoofd_030_1
01_hoofd_030_214_vrij_010silent - skip 14_vrij_010
04_bpt_005
01_hoofd_065_1
01_hoofd_065_2
01_hoofd_090 silent - niet regulier
silent - skip 06_vd_010
silent - skip 07_ops_01001_hoofd_101 silent - niet publiceren silent - is regulier
silent - and join
silent - skip procedure verandering
01_hoofd_200 silent - skip 01_hoofd_200
silent - and join & split
01_hoofd_270
01_hoofd_330
01_hoofd_350_2 silent - skip procedureverandering
01_hoofd_370
01_hoofd_40001_hoofd_380
01_hoofd_420silent - skip weigeringsgrond
01_hoofd_440_2
01_hoofd_455
01_hoofd_46001_hoofd_45101_hoofd_45001_hoofd_446silent - skip niet regulier
silent - skip zienswijzen vragen
silent - skip mandaat
10_uov_010
silent - skip aanhoudingsgrond
silent - skip regulier
silent - and split and join
01_hoofd_510_201_hoofd_490_2silent 01_hoofd_065_2
silent 01_hoofd_260
silent 01_hoofd_510_1silent 01_hoofd_030_1silent 01_hoofd_010
silent 04_bpt_005
silent 01_hoofd_446silent 01_hoofd_065_1
silent 01_hoofd_370
silent 12_ap_010silent 09_ah_i_010
silent 01_hoofd_530silent 01_hoofd_270silent 01_hoofd_120silent 01_hoofd_030_2
silent 01_hoofd_195
silent 01_hoofd_490_2silent 01_hoofd_020
silent 01_hoofd_250
silent 01_hoofd_510_2silent 01_hoofd_110
silent 01_hoofd_380silent 01_hoofd_330
silent 01_hoofd_520
pl32
pl34pl37
pl46 pl49pl52
pl58
pl61
pl78
pl81
pl84
pl87
pl90pl93pl102pl111
pl116
pl119pl123
finalpl50pl53
pl56
pl65
pl66pl76
pl85
pl91pl94
pl97
pl113
pl132
pl141
pl178pl183pl206
pl211
pl215pl233
pl242
pl256
pl269
pl275
pl285pl1
pl17pl20
pl67
pl77
pl82
pl86
pl98
pl150
pl68
pl151
pl191
pl196
pl202pl801_hoofd_12001_hoofd_010
01_hoofd_26005_eind_010
06_vd_01001_hoofd_110
01_hoofd_510_1silent - and split
03_gbh_00511_ah_ii_01009_ah_i_01001_hoofd_18001_hoofd_130
01_hoofd_520
01_hoofd_53001_hoofd_48001_hoofd_43001_hoofd_250
07_ops_010silent - skip 05_eind_010
silent - skip 03_gbh_00501_hoofd_020
01_hoofd_030_1
01_hoofd_030_2
14_vrij_010 silent - skip 14_vrij_01004_bpt_005
01_hoofd_065_1
01_hoofd_065_2
01_hoofd_090 silent - niet regulier
silent - skip 06_vd_010
silent - skip 07_ops_01001_hoofd_101 silent - niet publiceren silent - is regulier
silent - and join
01_hoofd_200
silent - and join & split
01_hoofd_270
01_hoofd_330
01_hoofd_350_2 silent - skip procedureverandering
01_hoofd_370
01_hoofd_40001_hoofd_380
01_hoofd_420silent - skip weigeringsgrond
01_hoofd_440_2
01_hoofd_455
01_hoofd_46001_hoofd_45101_hoofd_45001_hoofd_446silent - skip niet regulier
silent - skip zienswijzen vragen
silent - skip mandaat
10_uov_010
silent - skip aanhoudingsgrond
silent - skip regulier
silent - and split and join
01_hoofd_510_201_hoofd_490_2silent 01_hoofd_270silent 04_bpt_005
silent 01_hoofd_446silent 12_ap_010silent 01_hoofd_195
silent 01_hoofd_490_2silent 01_hoofd_030_2
silent 01_hoofd_065_2
silent 01_hoofd_330
silent 10_uov_010silent 01_hoofd_030_1fig. 5. result of repairing fig. 1(left) w.r.t. m1 (left) and m2f(right).
the original model that has to be changed to obtain the repaired /rediscovered model, i.e.,
0:0 means identical models. we observed that original model is signiÔ¨Åcantly more similar
to the repaired models ( :074-:199) than the original model to the rediscovered models
(:473-:543). this indicates that model repair indeed takes the original model structure by
far more into account than model repair. the numbers also match the observations one
can make when comparing fig. 1(middle) to fig. 1(right). finally, the simpler models
and fewer changes required for the Ô¨Åltered logs compared to the raw logs indicate that
log preprocessing, as discussed in sect. 3, has a signiÔ¨Åcant impact on model repair.
6 related work
the model repair technique presented in this paper largely relates to two research streams:
conformance checking of models and changing models to reach a particular aim.
various conformance checking techniques that relate a given model to an event log
have been developed in the past. their main aim is to quantify Ô¨Åtness , i.e., how much the
model can replay the log, and if possible to highlight deviations where possible [2, 4, 5,
8, 21]. the more recent technique of [2, 4] uses alignments to relate log traces to model
executions which is a prerequisite for the repair approach presented in this paper. besides
Ô¨Åtness, other metrics [2, 9, 13, 18, 19, 23] ( precision ,generalization , and simplicity ) are
used to describe how good a model represents reality. precision and generalization are
currently considered in our approach only as a side-e ect and not a leading factor for
model repair. incorporating these measure into model repair is future work. simplicity is
considered in our approach in the sense that changes should be as tractable as possible,
which we could validate experimentally.
14a dierent approach to enforcing similarity of repaired model to original model
could be model transformation incorporating an edit distance. the work in [15] describes
similarity of process model variants based on edit distance. another approach to model
repair is presented in [12] to Ô¨Ånd for a given model a most similar sound model (using
local mutations). [16] considers repairing incorrect service models based on an edit
distance. these approaches do not take the behavior in reality into account. other
approaches to adjust a model to reality, adapt the model at runtime [22, 20], i.e., an
individual model is created for each process execution. this paper repairs a model for
multiple past executions recorded in a log. the approach of [11] uses observed behavior
to structurally simplify a given model obtained in process discovery.
7 conclusion
this paper addressed, for the Ô¨Årst time, the problem of repairing a process model w.r.t. a
given log. we proposed a repair technique that preserves the original model structure and
introduces subprocesses into the model to permit to replay the given log on the repaired
model. we validated our technique on real-life event logs and models and showed the
approach is e ective and the resulting model allows to understand the changes done to
the original model for repair.
our proposed technique of model repair covers the entire problem space of model
repair between conÔ¨Årming conformance and complete rediscovery. in case of complete
Ô¨Åtness, the model is not changed at all. in case of an entirely unÔ¨Åtting model (no
synchronous move), the old model is e ectively replaced by a rediscovered model. in
case of partial Ô¨Åtness, only the non-Ô¨Åtting parts are rediscovered. this allows to apply
our technique also in situations where the given model is understood as a partial model
(created by hand) that is then completed using process discovery on available logs.
the technique can be conÔ¨Ågured. the cost-function inÔ¨Çuences the best-Ô¨Åtting align-
ment found, grouping of traces into sublogs and identifying sublocations for inserting
new subprocesses allows for various solutions. any process discovery algorithm can be
used to discover subprocesses; the concrete choice depends on the concrete conformance
notion addressed.
in our future work we would like to consider other conformance metrics such as
generalization and precision. moreover, in our current approach we abstract from extra
logging information such as the resource executing or initiating the activity and the
timestamp of the event. we would like to incorporate this information when repairing
the model. for example, resource information can give valuable clues on for repair.
acknowledgements. we thank m. kunze and r.m. dijkman for providing us with an implementa-
tion of the graph similarity distance and the anonymous reviewers for their fruitful suggestions. the
research leading to these results has received funding from the european community‚Äôs seventh
framework programme fp7 /2007-2013 under grant agreement no257593 (acsi).
references
1.van der aalst, w.m.p.: process mining: discovery, conformance and enhancement of busi-
ness processes. springer (2011)
152.van der aalst, w.m.p., adriansyah, a., van dongen, b.: replaying history on process models
for conformance checking and performance analysis. wires data mining and knowledge
discovery 2(2), 182‚Äì192 (2012)
3.van der aalst, w.m.p., schonenberg, m.h., song, m.: time prediction based on process
mining. information systems 36(2), 450‚Äì475 (2011)
4.adriansyah, a., van dongen, b., van der aalst, w.m.p.: conformance checking using cost-
based fitness analysis. in: edoc 2011. ieee computer society (2011)
5.adriansyah, a., van dongen, b.f., van der aalst, w.m.p.: towards robust conformance
checking. in: bpm 2010 workshops. lnbip, vol. 66, pp. 122‚Äì133 (2011)
6.bose, r.p.j.c., van der aalst, w.m.p.: analysis of patient treatment procedures. in: bpm
workshops‚Äô11. lnbip, vol. 99, pp. 165‚Äì166 (2011)
7.bose, r.p.j.c., van der aalst, w.m.p.: process diagnostics using trace alignment: opportuni-
ties, issues, and challenges. inf. syst. 37(2), 117‚Äì141 (2012)
8.calders, t., guenther, c., pechenizkiy, m., rozinat, a.: using minimum description length
for process mining. in: sac 2009. pp. 1451‚Äì1455. acm press (2009)
9.cook, j.e., wolf, a.l.: software process validation: quantitatively measuring the correspon-
dence of a process to a model. acm transactions on software engineering and methodology
8(2), 147‚Äì176 (1999)
10. dijkman, r.m., dumas, m., garc ¬¥ƒ±a-ba Àúnuelos, l.: graph matching algorithms for business
process model similarity search. in: bpm. lncs, vol. 5701, pp. 48‚Äì63 (2009)
11.fahland, d., van der aalst, w.m.p.: simplifying mined process models: an approach based
on unfoldings. in: business process management (bpm 2011). lncs, vol. 6896, pp. 362‚Äì378.
springer (2011)
12.gambini, m., rosa, m.l., migliorini, s., ter hofstede, a.h.m.: automated error correction
of business process models. in: bpm 2011. lncs, vol. 6896, pp. 148‚Äì165. springer (2011)
13.goedertier, s., martens, d., vanthienen, j., baesens, b.: robust process discovery with
artiÔ¨Åcial negative events. journal of machine learning research 10, 1305‚Äì1340 (2009)
14.ieee task force on process mining: process mining manifesto. in: bpm workshops. lnbip,
vol. 99, pp. 169‚Äì194. springer (2012)
15.li, c., reichert, m., wombacher, a.: discovering reference models by mining process
variants using a heuristic approach. in: bpm 2009. lncs, vol. 5701, pp. 344‚Äì362. springer
(2009)
16.lohmann, n.: correcting deadlocking service choreographies using a simulation-based
graph edit distance. in: bpm 2008. lncs, vol. 5240, pp. 132‚Äì147. springer (2008)
17.medeiros, a., weijters, a., aalst, w.: genetic process mining: an experimental evaluation.
data mining and knowledge discovery 14(2), 245‚Äì304 (2007)
18.munoz-gama, j., carmona, j.: a fresh look at precision in process conformance. in: bpm
2010. lncs, vol. 6336, pp. 211‚Äì226. springer (2010)
19.munoz-gama, j., carmona, j.: enhancing precision in process conformance: stability,
conÔ¨Ådence and severity. in: cidm 2011. ieee, paris, france (april 2011)
20.reichert, m., dadam, p.: adeptÔ¨Çex-supporting dynamic changes of workÔ¨Çows without
losing control. jiis 10(2), 93‚Äì129 (march 1998)
21.rozinat, a., van der aalst, w.m.p.: conformance checking of processes based on monitoring
real behavior. information systems 33(1), 64‚Äì95 (2008)
22.sadiq, s.w., sadiq, w., orlowska, m.e.: pockets of Ô¨Çexibility in workÔ¨Çow speciÔ¨Åcation. in:
er‚Äô2001. lncs, vol. 2224, pp. 513‚Äì526 (2001)
23.weerdt, j.d., backer, m.d., vanthienen, j., baesens, b.: a robust f-measure for evaluating
discovered process models. in: cidm 2011. pp. 148‚Äì155. ieee (april 2011)
24.van der werf, j., van dongen, b., hurkens, c., serebrenik, a.: process discovery using
integer linear programming. fundamenta informaticae 94, 387‚Äì412 (2010)
16