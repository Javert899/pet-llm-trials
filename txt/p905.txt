using domain knowledge to enhance process mining
results
dixit, p.m.; buijs, j.c.a.m.; van der aalst, w.m.p.; hompes, b.f.a.; buurman, j.
published in:
data-driven process discovery and analysis
doi:
10.1007/978-3-319-53435-0_4
published: 01/01/2017
document version
publisher’s pdf, also known as version of record (includes final page, issue and volume numbers)
please check the document version of this publication:
• a submitted manuscript is the author's version of the article upon submission and before peer-review. there can be important differences
between the submitted version and the official published version of record. people interested in the research are advised to contact the
author for the final version of the publication, or visit the doi to the publisher's website.
• the final author version and the galley proof are versions of the publication after peer review.
• the final published version features the final layout of the paper including the volume, issue and page numbers.
link to publication
citation for published version (apa):
dixit, p. m., buijs, j. c. a. m., van der aalst, w. m. p., hompes, b. f. a., & buurman, j. (2017). using domain
knowledge to enhance process mining results. in p. ceravolo, & s. rinderle-ma (eds.), data-driven process
discovery and analysis : 5th ifip wg 2.6 international symposium, simpda 2015, vienna, austria, december
9-11, 2015, revised selected papers (pp. 76-104). (lecture notes in business information processing; vol.
244). dordrecht: springer. doi: 10.1007/978-3-319-53435-0_4
general rights
copyright and moral rights for the publications made accessible in the public portal are retained by the authors and/or other copyright owners
and it is a condition of accessing publications that users recognise and abide by the legal requirements associated with these rights.
            • users may download and print one copy of any publication from the public portal for the purpose of private study or research.
            • you may not further distribute the material or use it for any profit-making activity or commercial gain
            • you may freely distribute the url identifying the publication in the public portal ?
take down policy
if you believe that this document breaches copyright please contact us providing details, and we will remove access to the work immediately
and investigate your claim.
download date: 14. jan. 2018using domain knowledge to enhance process
mining results
p.m. dixit1,2(b), j.c.a.m. buijs2, wil m.p. van der aalst2, b.f.a. hompes1,2,
and j. buurman1
1philips research, eindhoven, the netherlands
{prabhakar.dixit,hans.buurman }@philips.com
2department of mathematics and computer science,
eindhoven university of technology, eindhoven, the netherlands
{j.c.a.m.buijs,b.f.a.hompes,w.m.p.v.d.aalst }@tue.nl
abstract. process discovery algorithms typically aim at discovering
process models from event logs. most algorithms achieve this by solely
using an event log, without allowing the domain expert to inﬂuence
the discovery in any way. however, the user may have certain domainexpertise which should be exploited to create better process models. in
this paper, we address this issue of incorporating domain knowledge to
improve the discovered process model. first, we present a veriﬁcationalgorithm to verify the presence of certain constraints in a process model.
then, we present three modiﬁcation algorithms to modify the process
model. the outcome of our approach is a pareto front of process modelsbased on the constraints speciﬁed by the domain expert and common
quality dimensions of process mining.
keywords: user guided process discovery
·declare templates ·domain
knowledge ·algorithm post processing
1 introduction
process mining aims to bridge the gap between big data analytics and traditional
business process management. this ﬁeld can primarily be categorized into (1)process discovery, (2) conformance checking and (3) enhancement [ 22]. process
discovery techniques focus on using the event data in order to discover process
models. conformance checking techniques focus on aligning the event data on
a process model to verify how well the model ﬁts the data and vice versa [ 2].
whereas enhancement techniques use event data and process models to repairor enrich the process model. process models can be represented by multiple
modeling notations, for example bpmn, petri nets, process trees, etc.
most often, the focus of process discovery techniques is on automatically
extracting information to discover models solely based on the event logs. hence,
in order to gain signiﬁcant outcomes, the event log should ideally contain all the
c/circlecopyrtifip international federation for information processing 2017
published by springer international publishing ag 2017. all rights reservedp. ceravolo and s. rinderle-ma (eds.): simpda 2015, lnbip 244, pp. 76–104, 2017.doi: 10.1007/978-3-319-53435-0
4using domain knowledge to enhance process mining results 77
necessary information required by the algorithm. however, in many real world
scenarios, the data contained in the event logs may be incomplete and/or noisy.this could in turn result in incorrect interpretations of the data. one of the
ways to circumvent the problems with insuﬃcient data could be to allow the
user to input certain expert knowledge. the domain knowledge could thus beused to overcome the shortcoming of the data; thereby improving the results.
in this paper, we address this challenge of incorporating domain knowledge in
traditional process discovery.
domain knowledge can be introduced in the discovery process at multiple
stages as shown in fig. 1. in this paper, we focus on post-processing an already
discovered process model to incorporate the user speciﬁed domain knowledge.the primary reason of introducing domain knowledge at the post-processing
stage is to keep the overall method generic and scalable. our approach can
be coupled with anydiscovery algorithm which generates models which can be
fig. 1. places where domain knowledge can be incorporated in the process discov-
ery approach. in this paper we focus on post-processing the model based on domain
knowledge (approach 3).78 p.m. dixit et al.
represented as process trees. alternatively, we can reﬁne (enhance) a pre-existing
model using our technique. we focus on a class of models represented as processtrees because the state of the art discovery algorithms such as the inductive
miner [ 16] and the evolutionary tree miner [ 5] discover block-structured process
models represented by process trees . furthermore, process trees are hierarchically
structured and sound by construction. the hierarchical nature of process trees
allows for a structured way to incorporate and validate the domain knowledge.
we use declare templates [ 18] as a way to input the domain knowledge.
declare templates belong to the class of declarative languages, which are used
to construct constraint based declarative process models. we abstract these tem-
plates as a way to specify domain knowledge eﬀectively in terms of constraints.declare provides a handy and eﬀective way of modeling protocols and rules. such
constrains are especially eﬃcient in many real life domains, such as healthcare
wherein the the clinical specialist are usually aware of certain protocols which
should hold in the process. using a subset of declare templates the user can
specify a set of constraints which must hold in the process.
in order to incorporate domain knowledge in the post-processing stage, we
primarily focus on addressing two main challenges. firstly, we introduce a ver-
iﬁcation algorithm, to determine whether a set of user speciﬁed constraints issatisﬁed in the model. we then introduce and evaluate three modiﬁcation tech-
niques in order to generate variants of the input process model based on the
constraints and event log. in [ 10], we introduced the veriﬁcation and a brute
force modiﬁcation approach. we extend that work and introduce two additional
modiﬁcation approaches: genetic and constraint speciﬁc modiﬁcation. all three
modiﬁcation algorithms output a number of process tree variants. each of thesevariants may satisfy the user speciﬁed constraint to a diﬀerent degree. the user
can choose the most appropriate model depending on the constraints satisﬁed,
along with the values of four quality dimensions (replay ﬁtness, precision, sim-plicity and generalization).
the remainder of the paper is structured as follows. in sects. 2and3,w e
provide a literature review of related work and the preliminaries respectively.
in sects. 4and5we explain the veriﬁcation and modiﬁcation algorithms. in
sect.6we evaluate our approach qualitatively as well as quantitatively based
on synthetic and real life event logs. in sect. 7we conclude and discuss future
research.
2 related work
although the ﬁeld of process discovery has matured in recent years, the aspect
of applying user knowledge for discovering better process models is still in itsnascent stages. conformance techniques in process mining such as [ 1,2,8] replay
event logs on the process model to check compliance, detect deviations and bot-
tlenecks in the model. these techniques focus on verifying the conformance ofevent logs with a process model, but do not provide any way of incorporating
domain knowledge to repair/improve the process model. [ 19]p r o v i d e sab a c k -
ward compliance checking technique using alignments wherein the user providesusing domain knowledge to enhance process mining results 79
compliance rules as petri-nets. the focus is on using petri-net rules for diag-
nostic analysis on the event log, rather than discovering a new process modelwith compliance rules. the conformance based repair technique suggested by
[11] takes a process model and an event log as input, and outputs a repaired
process model based on the event log. however, the input required for this app-roach is an end-to-end process model and a noise free event log. our approach
requires only parts of process models or constraints described using declarative
templates.
[12] and [ 21] propose approaches to verify the presence/absence of constraints
in the process model. however, these approaches do not provide a way to modify
the process models w.r.t. the constraints. in [ 17], the authors provide a way to
mine declarative rules and models in terms of ltl formulas based on event logs.
similarly, [ 7] uses declare taxonomy of constraints for deﬁning artful processes
expressed through regular expressions. [ 15] uses event logs to discover processes
models using inductive logic programming represented in terms of a sub-set
of sciff [ 3] language, used to classify a trace as compliant or non compliant.
in [6], the authors extend this work to express the discovered model in terms of
declare model. however, these approaches focus on discovering rules/constraints
from event log without allowing the users to introduce domain knowledge duringrule discovery.
in [20], authors suggest an approach to discover a control ﬂow model based
on event logs and prior knowledge speciﬁed in terms of augmented informa-tion control nets (icn). our approach mainly diﬀers in the aspect of gathering
domain knowledge. although declarative templates can also be used to construct
a network of related activities (similar to icn), it can also be used to providea set of independent pairwise constraints or unary constraints. [ 23]p r o p o s e sa
discovery algorithm using integer linear programming based on the theory of
regions, which can be extended with a limited set of user speciﬁed constraintsduring process discovery. in [ 13], the authors introduce a process discovery tech-
nique presented as a multi-relational classiﬁcation problem on event logs. their
approach is supplemented by artiﬁcially generated negative events(agnes),
with a possibility to include prior knowledge (e.g. causal dependencies, par-
allelism) during discovery. the authors of [ 14] incorporate both positive and
negative constraints during process discovery to discover c-net models. com-
pared to [ 13,14,23], our approach diﬀers mainly in two aspects. firstly, we do
not propose a new process discovery algorithm, but provide a generic approachto post process an already discovered process tree. secondly, our approach pro-
vides the user with a balanced set of process models which maximally satisfy
user constraints and score high on quality dimensions.
3 preliminaries
as mentioned in sect. 1, we primarily use process trees to represent the process
models and declare templates as a means to incorporate the domain knowledge.
this section provides a background and a brief description about process trees
and declare templates.80 p.m. dixit et al.
3.1 process trees
process trees provide a way to represent process models in a hierarchically struc-
tured way containing operators ( parent nodes ) and activities ( leaf nodes ). the
operator nodes specify control ﬂow constructs in the process tree. figure 2shows
an example process tree and its equivalent bpmn model. a process tree is tra-versed from left to right and top to bottom.
the order of child nodes is not important for and(∧),exclusive-or (×)
and inclusive-or (∨) operators, unlike sequence (→)a n d xor-loop (/clockwise) where
the order is signiﬁcant. in the process tree from fig. 2a, activities a and z are
always the ﬁrst and last activities respectively. for the /clockwiseoperator the left most
node is the ‘do’ part of the loop and is executed at least once. in fig. 2a, activity
d is the optional ‘re-do’ part of /clockwise, execution of which activates the loop again.
activities b and c occur in parallel and hence the order is not ﬁxed. the right
node of the loop is the escape node and it is executed exactly once. for the ×
operator, only one of either f or g is chosen. for the ∨operator both ×and
activity e can occur in any order, or only one of either two can occur.
3.2 declare templates
a declarative model is deﬁned by using constraints speciﬁed by a set of templates
[18]. we use a subset of declare templates as a way to input domain knowledge.
fig. 2. example process tree and its bpmn equivalent.using domain knowledge to enhance process mining results 81
table 1. declare constraints and their graphical and textual interpretations
template name graphical representation interpretation
response(a,b)
 activity b should (always)
eventually occur after activity a
precedence(a,b)
 activity b can occur only after theoccurrence of activity a
coexistence(a,b)
 activity a implies the presence of
activity b (and vice versa)
responded-existence(a,b)
 activity b should (always) occurbefore or after the occurrence ofactivity a
not-coexistence(a,b)
 activity a implies the absence of
activity b (and vice versa)
not-succession(a,b)
 activity a should never be followed
by activity b
existence(n1,n2,a)
 activity a should occur:•n1..n2 times
table 1provides an overview and interpretation of the declare constraints
that we consider [ 17,18]. binary templates provide ways to specify dependency
(positive and negative) between two activities. for example, response(a,b) spec-
iﬁes that activity a has to be eventually followed by activity b somewhere in the
process. we use six binary constraints as shown in table 1. we use one unary
constraint existence(n1,n2,a) , as a way to specify the range of occurrence of an
activity.
4 veriﬁcation
in this section, we present a novel veriﬁcation approach that takes a process tree
and a set of constraints as input, and returns the set of constraints satisﬁed by
the process tree as output. we recall from sect. 3.1that the order of children for
the operators ∨,×,a n d∧is not ﬁxed and the child nodes can be executed in any
order. however, for the remaining nodes, ( →,/clockwise) the order of navigation is ﬁxed
from left to right. we split the veriﬁcation procedure into three parts. first, wecheck if the positioning of the activities in the process tree is correct according to
the constraint. for example, for a constraint response (a, b), we check if all the
b’s are on the right side of a. next, we perform an additional check to verify
the common parent, addressed in subsect. 4.2. in the case of response (a, b),82 p.m. dixit et al.
algorithm 1. declare constraints veriﬁcation in a process tree
input : process tree, set of constraints
output : constraints categorized as veriﬁed orunveriﬁed
1begin
2 foreach constraint do
3 ifnot existence constraint then
4 compute collection of common sub-trees
5 foreach sub-tree do
6 verify common parent
7 verify position of activties
8 ifcommon parent or position veriﬁcation fails then
9 set constraint veriﬁcation unsuccessful
10 else if relations constraint &occurs(st a,b) is (always) then
11 set constraint veriﬁcation successful
12 else if negative relations constraint &occurs(st a,b) is (never)
then
13 set constraint veriﬁcation successful
14 else
15 set constraint veriﬁcation unsuccessful
16 else
17 consider full tree
18 check range from occurs(pt,a) tooccurs multiple times(pt,a)
19 return set of constraints marked as - veriﬁed or unveriﬁed
even if activity b is on the right side of activity a, the order isn’t ﬁxed if the
common parent between a and b is not →or/clockwiseand hence b is not guaranteed
to occur after a. finally, we calculate the occurrence possibilities of b w.r.t. the
common parent. in algorithm 1, we show the main sequence of steps used by
the veriﬁcation approach. in the following sub-sections, we detail the algorithm.
4.1 sub-tree computation and position veriﬁcation
in this sub-section we explain the sub-tree computation and position veriﬁcation
with respect to each of the binary constraints. sub-trees are sub-blocks contain-ing the ﬁrst common ancestor between the two activities of the binary (negative)
relation constraints. the same activity can be present at multiple locations in a
process tree which could result in multiple sub-trees for a single constraint. thetotal number of sub-trees is equal to the number of occurrences of the ‘primary’
activity from the constraint in the process tree. the primary activity is the activ-
ity w.r.t. which the constraint is speciﬁed. for e.g., for constraint response(a,b) ,
the primary activity is ‘a’. for constraint such as coexistence(a,b) , where both
the activities a and b are primary activities, the total number of sub-trees com-
puted is n+m , where nand mare the number of occurrences of activities ausing domain knowledge to enhance process mining results 83
and b in the process tree respectively. table 2provides the overview of primary
activities corresponding to each constraint.
table 2. primary activities corresponding to binary constraints
constraint primary activity
response(a,b) a
precedence(a,b) b
coexistence(a,b) a,b
responded-existence(a,b) a
not-succession(a,b) a
not-coexistence(a,b) a,b
for sub-tree calculation, we make use of the fact that a process tree is gen-
erally navigated from left to right for→and/clockwise, and that the ordering doesn’t
matter for other operators. this provides a good starting point to compare the
ordering of activities in a process tree with respect to the declare constraints.consider the constraint response(a,b) that should be veriﬁed for the process
tree from fig. 3a. as described in table 1, a response constraint states that every
occurrence of activity a should eventually be followed by activity b. in order to
verify that such constraint holds true in the process tree, we ﬁrst gather all the
locations within the process tree where activity a occurs. for each occurrence ofa in the process tree, we ﬁnd the ﬁrst common ancestor containing a and allthe
b’s which can be reached after executing activity a. as discussed earlier, all the
b’s that could occur after a have to be on the right side of a. figure 3bs h o w s
the sub-tree for constraint response(a,b) . since there is only one occurrence of
activity a in the process tree, there is only one sub-tree. the ﬁrst occurrence
fig. 3. sub-tree computation for the constraint response(a,b)84 p.m. dixit et al.
fig. 4. sub-trees computation for the constraint precedence(a,b) .a s4 br e s u l t si na
nullsub-tree, the constraint veriﬁcation for the constraint precedence(a,b) f ails w.r.t.
t h ee n t i r ep r o c e s st r e e .
of b from the original process tree is ignored as it is on the leftside of a, and
hence this b cannot be guaranteed to be executed afterexecuting activity a.
for the precedence(a,b) constraint; we are interested in ﬁnding all the com-
mon sub-trees with respect to b, containing all a’s on the left side of ( executed
before ) b. there are a total of 3 sub-trees corresponding to each b in the process
tree from fig. 4. the sub-trees for b 2and b 3are shown in fig. 4c and d respec-
tively. however, for b 1there is no sub-tree containing activity a prior to (i.e.
on the left side of) b. this results in a nullsub-tree as shown in fig. 4b, and
therefore the veriﬁcation fails.
relation constraints such as coexistence and responded-existence are
independent of the position of the other activity in the process tree.figure 5shows the sub-trees for constraints responded −existence (a, b)a n d
coexistence (a, b). the sub-tree in fig. 5d is calculated with respect to activ-
ity b and is only valid for the constraint coexistence (a, b). negative relations
constraints are more restrictive and the sub-trees can be calculated and derived
in a similar way to their respective relation constraints counterpart. for exam-
ple, for the constraint not−coexistence (a, b), the sub-trees can be computed
similar to coexistence (a, b). however, unlike relation constraints, for negative
relation constraints the absence of a sub-tree ( nullsub-tree) for each activity
from constraint implies satisfaction of the constraint in the process tree. sub-tree calculation is not necessary for unary constraints such as existence, wherein
we consider the entire process tree. the next step is to determine if the common
parent is valid as discussed in subsect. 4.2.using domain knowledge to enhance process mining results 85
fig. 5. sub-trees computation for constraints responded-existence(a,b) and coexis-
tence(a,b)
4.2 parent veriﬁcation
fig. 6. sub-tree violat-
ing constraint coexis-
tence(e,b)if sub-tree computation is successful, then the next
step is to verify the common parent. there are a set
ofallowable common parent operators for each type of
constraint. for example, if we have to verify the coexis-
tence(e,b) constraint on the process tree from fig. 3a,
then one of the sub-trees computed is shown in fig. 6.
as the common parent for this sub-tree is the choice
operator ×, both e and b will never occur together. hence the common parent
veriﬁcation for this particular sub-tree fails for constraint coexistence(e,b) .p a r -
ent veriﬁcation is not required for unary constraints, as there is only one activity.
table 3summarizes the valid common parents for all the binary constraints from
table 1.
4.3 activity occurrence veriﬁcation
for binary constraints the next step is checking the occurrence of the activity in the
sub-tree. in order to achieve this, we use the predicate occurs (st a,b), where a is
thenodewithrespecttowhichsub-treestiscomputedandbisthesecondactivity
of the binary constraint. for every ancestor of node a, we check the occurrence ofactivity b which can have the following values: always ,sometimes ornever.
figure 7b shows the occurrence of activity b, for the sub-tree from fig. 7a
which is computed with respect to activity a. for choice operators such as ×86 p.m. dixit et al.
table 3. valid common parents for each of the declare constraints
constraint valid common parent operator
response(a,b) →,/clockwise1
precedence(a,b) →,/clockwise1
coexistence(a,b) →,∧,/clockwise1
responded-existence(a,b) →,∧,/clockwise1
not-succession(a,b) ×
not-coexistence(a,b) ×
/clockwise1is valid only if node b (or a) is a child of the left (do)
or right (exit loop) part and notof middle(re-do) part
and∨, if activity b is present in allthe child nodes, then activity b occurs
always w.r.t. the operator node. if only few or none of the child nodes of the
choice operator have occurrence of activity b, then activity b occurs sometimes
ornever resp. similarly, if at least one child of →and∧is activity b, then activity
b occurs always w.r.t. this node. in case of /clockwiseif activity b is present only in
the re-do part of the loop (which may or may not be executed), then activityb occurs sometimes . if activity b is present in the loop or exit child of the /clockwise
operator, then activity b is guaranteed to occur always w.r.t. this node. starting
with the deepest occurrence of b in sub-tree, we annotate the ‘occurrence of b’w.r.t. each node recursively until the root of the sub-tree is reached as shown in
fig.7b. we check the occurrence of activity b, at every ancestor of activity a.
for binary relations constraint, if none of the ancestor(s) of activity a have theoccurrence of b as always , then the constraint is not satisﬁed. on the contrary
for negative relations constraints, if any of the ancestor(s) of activity a have the
occurrence of b as always orsometimes , then the constraint is not satisﬁed.
fig. 7. occurrence( st a,b) veriﬁcation for constraint response(a,b) (color ﬁgure
online)using domain knowledge to enhance process mining results 87
in case of an unary constraint, the predicate occurs multiple times(pt,a) is
calculated with possible values yesorno, where pt is the entire process tree and
a is the activity from the unary constraint. if any of the ancestor(s) of activity
a are children of the loop part or the re-do of /clockwiseoperator, then the multiple
occurrence of activity a is set to yes. otherwise, the multiple occurrence part of
activity a is set to no.occurs multiple times(pt,a) gives us the upper bound
of the range, and we combine this with occurs(pt,a) to calculate the lower
bound of the range. we evaluate the unary constraints at the root of the treedepending on the values of occurs(pt,a) and occurs
multiple times(pt,a) ,a s
shown in table 4.
for binary constraints, if either the sub-tree computation, position veriﬁca-
tion, common parent veriﬁcation or activity occurrence veriﬁcation fails, then
that constraint is marked as unsatisﬁed. if all these steps are successful for
all the corresponding sub-trees, then the constraint is marked as satisﬁed. for
unary constraints, if activity occurrence veriﬁcation is successful (within the
input range) then the constraint is marked satisﬁed, otherwise, it is marked asunsatisﬁed.
table 4. overview of possible ranges for existence constraint
occurs(pt,a) at the
root of ptoccurs multiple times(pt,a) at
the root of ptrange of occurrence
sometimes no 0..1
sometimes yes 0..n
always yes 1..n
always no exactly 1
never n.a exactly 0
5 modiﬁcation
following the description of the veriﬁcation algorithm, we now discuss three mod-
iﬁcation approaches in order to incorporate the user speciﬁed domain knowledge
in the process tree. figure 8gives a general overview of the overall approach,
independent of the modiﬁcation algorithm used. the three modiﬁcation algo-rithms proposed are: brute force modiﬁcation, genetic modiﬁcation, and con-
straint speciﬁc modiﬁcation. the brute force modiﬁcation approach used only a
process tree during modiﬁcation. the constraint speciﬁc modiﬁcation algorithmuses the user speciﬁed constraints along with the initial process tree during mod-
iﬁcation. the genetic modiﬁcation approach requires the initial process tree, user
speciﬁed constraints as well as the event log as during modiﬁcation. it should benoted that in order to compute the ﬁnal pareto front, all the three techniques
use the event log and the user speciﬁed constraints.88 p.m. dixit et al.
fig. 8. thegeneraloverviewcombiningtraditionalprocessdiscoverywithdomainknowl-
edge speciﬁed using constraints. the ﬁgure also shows the inputs required by each modi-ﬁcation approach - brute force modiﬁcation(bfm), genetic modiﬁcation(gm), and con-
straint speciﬁc modiﬁcation(csm). each of the modiﬁcation algorithms creates variants
of process trees, after which the best process trees are selected using a pareto front basedon the four quality dimensions of process mining and number of constraints satisﬁed.
all modiﬁcation algorithms produce a collection of candidate process trees as
output. each candidate process tree is evaluated against the four quality dimen-
sions of process mining (replay ﬁtness, precision, generalization and simplicity)
[5,22] and the number of user speciﬁed constraints veriﬁed by the tree. this
results in ﬁve quality dimensions. in order to evaluate the process trees based
on these dimensions we use a pareto front [ 5]. the general idea of a pareto front
is that all models are mutually non-dominating: a model is dominating with
respect to another model, if for all measurement dimensions it is at least equal
or better and for one strictly better. using the ﬁve dimensions, a pareto front ispresented to the user which contains the set of dominating process trees.
5.1 brute force modiﬁcation
the brute force modiﬁcation algorithm takes the discovered process tree as input
and generates a list of candidate trees using a brute force approach. this is
accomplished as shown in algorithm 2, elaborated in the following steps:
1. starting with the original input process tree, variants are created based on
three primary edit operations: add node ,remove node and modify node .
2. every node in the process tree is subject to each edit operation, resulting
in new variants of process trees. after each edit operation, the number of
edits for the process tree is incremented. it should be noted that, in caseusing domain knowledge to enhance process mining results 89
→
a ×
b c
(a) input process tree.
(number of edits: 0)→
a ×
b c×
b c
(b) remove node: removed
activity a. since →has
only one child, it can be re-duced. (number of edits: 1)×
a b c
(c) add node: added activ-
ity a as a child of ×(num-
ber of edits: 2)
×
→
a bc
(d) add node: added oper-
ator →as a child of ×;a n d
parent of a and b (number
of edits: 3)→
→
a bc →
a b c
(e) modify node: modiﬁed
operator ×to →; resulting
in a process tree with onlyone parent operator (num-
ber of edits: 4)→
a b c
(f) remove node: removed
operator →; resulting in an
empty process tree (number
of edits: 5)
fig. 9. example modiﬁcation operations on process tree.
algorithm 2. brute force modiﬁcation of a process tree
input :p r o c e s st r e e( pt), max nbr of edits( nmax)
output : candidate process trees collection(c)
1begin
2 create candidate process trees collection c
3 c={pt}∪ modifyprocesstree (pt,0,n max)
4 return c;
5function modifyprocesstree(pt,n, nmax)
6 initiate local process trees collection c/prime
7 ifn<n max then
8 foreach node ∈process tree ptdo
9 foreach edit operator do
10 create ˜ptfrom ptby using the edit operator for the chosen node
11 reduce tree ˜ptif possible
12 c/prime=c/prime∪{˜pt}
13 c/prime=c/prime∪modifyprocesstree (˜pt, n+1 ,n max)
14 return c/prime
of leaf nodes, allthe activities are used exhaustively for eachtype of edit
operation. for example, in fig. 9c, activity a is added as a left-most child
of×, resulting in a new process tree. similarly, activity b would also be90 p.m. dixit et al.
added as a left-most child, resulting in another process tree and same goes
for activity c. moreover, each activity is also added to every possible locationwithin the tree. for example in fig. 9c, activity a could be added in between
b and c resulting in a new process tree, as well as activity a would be added
after c ( right of c ) resulting in a new process tree. similarly, in case of
operator nodes, allthe other operator nodes are used exhaustively in each
edit operation.
3. after every edit operation, the newly created tree is reduced recursively until
no reductions are possible. the reduction primarily consists of the following
two actions:
•if an operator node contains only one child, then remove the operator
node and replace it with its child node. (e.g. fig. 9b)
•if a parent and a child are of the same operator type in →,∧,×or∨;
then the parent and child nodes can be collapsed into one operator. (e.g.
fig.9e)
4. each newly created variant of the process tree is further edited by iteratively
calling all the edit operations exhaustively (in all possible orders) on each
node using a “brute force” approach.
5. this process of creating process tree variants is repeated until all the nodes
of all the process trees are processed and/or the threshold for the number of
editoperations w.r.t. the process tree is reached.
6. every variant of the process tree is added to the pool of candidate process
trees. the candidate process trees might contain duplicates. the brute for
approach could be computationally expensive, hence adding further process-
ing to check for duplicates in a pairwise manner for all the candidate processtrees would further degrade the performance. therefore we do not remove the
duplicates. however, the pareto front presented to the user would take care
of these duplicates from the candidate process trees.
figure 9shows diﬀerent edit operations used by the modiﬁcation algorithm.
the modify node operation modiﬁes every node in the process tree and can be
classiﬁed into modify activity and modify operator depending on the type of
node selected. similarly, add node adds either an activity node or an operator
node (fig. 9c and d). an operator can be added below the parent node (fig. 9d)
and above the parent node (not shown in fig. 9) by exhaustively combining child
nodes. each edit operation results in a new process tree, which can be further
edited by other edit operations exhaustively until the threshold for edit distanceis reached. every process tree arising after each edit operation is added to the
pool of candidate process trees. by executing all edit operations in an iterative
way, we can ﬁnd an optimal sequence of operations to deduce any process tree.
it is important to carefully set the threshold for maximum number of edit
operations, as a high threshold could result in many changes and a small thresh-
old would only explore a few changes in the resultant process tree as compared tothe original process tree. although a high threshold would explore more possibil-
ities, it would result in a large number of variants of the process tree, and hence
it would also be very computationally intensive and ineﬃcient. therefore, theusing domain knowledge to enhance process mining results 91
threshold for number of edit operations should be chosen by the user depending
on the original (starting) process tree, and the number of unveriﬁed constraintsin the original process tree. that is, if the originally discovered process tree is
completely inappropriate according to the domain expert, and the number of
unveriﬁed constraints is high, then the threshold should be set high. contraryto this, if the domain expert agrees with major elements of originally discovered
process tree, and the number of unveriﬁed constraints is low, then the threshold
should be set low.
5.2 genetic modiﬁcation
the brute force approach from subsect. 5.1takes as input the process tree, and
creates variants of this process tree in a brute force way, without considering theconstraints or data. this approach takes into account the complete search space
within the threshold of the number of edits. however, this could be unnecessarily
time-consuming, as variants of process trees might be created iteratively which
do not satisfy any constraints at all, or variants of process trees which do not
describe the event log very well, or both. in order to overcome this, we present asecond modiﬁcation algorithm using a genetic approach. the creation of process
trees is guided by the event log using the four quality dimensions (replay ﬁtness,
precision, generalization and simplicity) along with the number of constraintsveriﬁed according to the veriﬁcation algorithm.
we extend the genetic approach for process trees discussed in [ 4] to include
an additional ﬁtness evaluator “number of constraints speciﬁed”, along withthe four standard quality dimensions. a number of factors such as crossover and
mutation probabilities, number of random trees in each generation etc. determine
the variation of process trees in each generation. the tree modiﬁcation processis guided to balance between the standard quality dimensions (determined by
the event log) and the number of constraints veriﬁed. the modiﬁcation of the
trees is stopped when the stopping criteria of the genetic algorithm are met. thestopping criteria could be the maximum number of generations, maximum time
taken, minimum number of constraints satisﬁed etc. the end result is a pareto
front containing the best process trees balanced on the ﬁve dimensions.
5.3 constraint speciﬁc modiﬁcation
the modiﬁcation approaches discussed in subsects. 5.1and5.2ﬁrst modify the
process trees (either in a brute force way or genetically), and then evaluate them
to check the compliance of user speciﬁed constraints on the modiﬁed trees. an
alternative to this approach would be to change the process trees according tothe type of constraint, rather than changing the trees ﬁrst and then verifying. in
order to achieve this, we introduce a constraint speciﬁc modiﬁcation approach
which iteratively changes the process trees for each constraint speciﬁed by theuser. the resulting process trees are subject to modiﬁcation with respect to the
next constraint considering all possible permutations. the current implementa-
tion of constraint speciﬁc modiﬁcation requires the input process tree to have92 p.m. dixit et al.
non-duplicate labels. in future we aim to overcome this issue of duplication by
taking in account all the combinations of each activity occurrence in the processtree, depending on the type of constraint. however due to the complexity and
search space, we limit the current implementation to non-duplicate labels. the
steps followed for constraint speciﬁc modiﬁcation are mentioned below:
1. as a ﬁrst step, all the possible permutations of the constraints given by the
user are computed. for example, if there are two constraints input by the user-response(a,b), precedence(c,d) then the set of possible permutations of
these constraints is - ( <response(a,b) ,precedence(c,d) >;<precedence(c,d) ,
response(a,b) >)
2. for each permutation, the process tree is modiﬁed with respect to each con-
straint in a sequential order as shown in fig. 10. hence, new variants of process
trees, are created and added to the output process trees pool. each new vari-
ant is again subject to further modiﬁcation, based on the next constraint inthe set. the modiﬁcation of process tree(s) based on the type of constraint is
performed using following step(s):
(a) for unary constraints, the activity from the constraint is mapped to the
activity in the process tree. as discussed previously, we assume that every
activity in a process tree is present at most once. next, according to
table 4ifoccurs(pt,a) of the activity is sometimes , then we introduce a
choice operator as one of the ancestor of activity a (if it doesn’t already
exist at any ancestors). each possible ancestor is changed, resulting in
fig. 10. high level representation of constraint speciﬁc modiﬁcation approach. start-
ing with initial process tree, multiple variants are created w.r.t. each constraint. every
edited process tree is subject to the next constraint, until all the constraints are con-sidered. this process is repeated for all the possible combinations of constraints. all
the process trees in each pt set are added to the ﬁnal output of candidate trees for
evaluation in the pareto front.using domain knowledge to enhance process mining results 93
creation of new process trees. each newly created process tree is added
to the pool of candidate process trees. similarly, if occurs(pt,a) of the
activity is always , then we replace every choice operator (one by one) with
allowable operators ( →,∧,/clockwise). each resulting process tree is added to the
pool of candidate process trees. similar steps are repeated depending onthe values of occurs
multiple times(pt,a) and the presence/absence of
loop operator in the ancestors of activity a. in case of binary constraints,
we follow steps (b) to (e).
(b) for binary constraints, two activities from the constraint are used to
create a process tree as shown in fig. 11a. the root shows the allow-
able operators as common ancestor. the operators on the edge show theallowable intermediate operators between the root and node b.
(c) the common ancestor between these activities is checked. if the common
ancestor between these activities is valid (as described in table 3), then
proceed to next the step. if the common ancestor of is not valid, then it
is changed to an allowable valid operator from table 3. this is done for
every allowable valid operator and results in a set of process trees. each
process tree created is subject to the next steps.
(d) the next step is to check the intermediate operators between common
parent and the secondary activity from the constraint in the process tree
as shown in fig. 11b. constraint such as co-existence(a,b) is decom-
posed into two constraints responded-existence(a,b) and responded-
existence(b,a) , which essentially add up to co-existence(a,b) . the allow-
able valid operators between common ancestor and secondary activity are
mentioned in table 5.
(e) in case the intermediate operator is not valid, it is replaced by each valid
intermediate operator from table 5. every replacement of the operator
results in a new process tree, which is added to the list of candidateprocess trees. figure 11shows the constraint speciﬁc modiﬁcation process
for the constraint response(a,b) . figure 11cs h o w s oneof the outcomes
of the constraint speciﬁcation modiﬁcation. it should be noted that some
constraints share similar properties.
table 5. valid intermediate operators for each of the declare constraints
constraint valid common parent operator
response(a,b) →,∧,/clockwise1
precedence(a,b) →,∧,/clockwise1
responded-existence(a,b) →,∧,/clockwise1
not-succession(a,b) ×,→,∧,/clockwise,∨(all operators)
not-coexistence(a,b) ×,→,∧,/clockwise,∨(all operators)
/clockwise1is valid only if node b (or a) is a child of the left (do)
or right (exit loop) part and notof middle(re-do) part94 p.m. dixit et al.
→| |*
a b→| |∧| |*
(a) process tree showing al-
lowable operators for con-
straint response(a,b) .×
∧
a d∧
→
c be
(b) process tree highlighted
with red as the common
parent operator. the red
area shows the intermediateoperators between commonparent and activity b.→
∧
a d∧
→
c be
(c) modiﬁed process tree,
satisfying the constraint
response(a,b) , formed by
combining process tree
from figure 11a and fig-ure 11b (by replacing ×
with →).
fig. 11. constraint speciﬁc modiﬁcation for response(a,b) - depicted as a process tree
ina on the process tree from b
3. finally, the best variants are chosen using a pareto front made of the number
of constraints satisﬁed and the four standard quality dimensions of process
mining. it should be noted that some of the constraints might share simi-lar properties or might be related. in such cases, for certain combinations,
modiﬁcation of a tree to satisfy a certain constraint might inherently also
lead to the satisfaction of another constraint. in such scenarios, there is nofurther modiﬁcation required, if there are no unsatisﬁed constraints remain-
ing for the current combination set. for example, the valid common opera-
tors as shown in table 3for response (a, b)a n d precedence (a, b) are same.
therefore if a process tree contains a single occurrence of activities a and
b, then the modiﬁcation to change the common parent for the constraint
response (a, b), would automatically contain the modiﬁcations for the con-
straint precedence (a, b) too. hence step (c) could be skipped when the mod-
iﬁcations for prcedence (a, b) are being performed.
6 evaluation
the outcomes of the three modiﬁcation approaches can be evaluated primarily
in two ways. one way is to qualitatively evaluate the diﬀerences in each modiﬁ-
cation approach in terms of conﬁguration, performance and output. the secondapproach is to quantitatively evaluate the outcomes of the three modiﬁcation
approaches, and to speciﬁcally determine the added beneﬁt that domain knowl-
edge brings in improving the process models. we ﬁrst compare and discuss thepeculiarities of the three modiﬁcation approaches qualitatively based on diﬀerent
parameters. next, we evaluate the outcomes of diﬀerent modiﬁcation approaches
quantitatively using a synthetic and a real life event log.using domain knowledge to enhance process mining results 95
6.1 comparison of approaches
multiple parameters determine the outcome of each technique. every algorithm
has various pro’s and con’s associated with it. that is, one technique might excel
in a certain scenario where another technique might fail and vice versa. thereforeit is important to ﬁrst carefully evaluate each approach qualitatively to analyze
and compare the properties associated with each. in this sub section we focus
on the qualitative comparison of the three modiﬁcation algorithms introducedin this paper.
conﬁguration. this section addresses the inputs and the conﬁgurable input
parameters required by the modiﬁcation techniques, which have a direct or indi-
rect impact on the outcome of the algorithm. as discussed previously, all the
three techniques require an event log, user speciﬁed constraints and a processtree as input. the constraint-speciﬁc modiﬁcation technique does not require
any additional inputs. the brute force modiﬁcation technique requires the user
to set the ‘threshold for # of edits’. this threshold sets the maximum spaceexplored by the algorithm, and hence has a big impact on the number of trees
discovered. the genetic approach requires additional parameters which are stan-
dard for a genetic algorithm such as - maximum population, elite size, mutationprobabilities etc. it should also be noted that the genetic algorithm is proba-
bilistic whereas brute force and constraint speciﬁc modiﬁcation techniques are
deterministic. table 6gives an overview of the inputs required by the three tech-
niques.
table 6. input and input parameters aﬀecting the discovery outcome for each modi-
ﬁcation approach.
constraint speciﬁc brute force evolutionary tree miner
event log event log event log
constraints constraints constraints
process tree process tree process tree
threshold for # of edits population size
elite count
max generations
max duration
cross over probability
mutation probability
event log usage. the way in which the information from event logs is used
by the three approaches varies. table 7shows the usage of event logs in each
approach. the brute force and the constraint speciﬁc modiﬁcation techniques96 p.m. dixit et al.
ﬁrst create a set of candidate process trees without using any information from
the event log. the event log is only used at a later stage to compute the qualityscores with respect to each process tree variant, which is in turn used to construct
a parteo front. the genetic algorithm on the other hand uses the event logs along
with the number of constraints veriﬁed as the guiding rule. each process treevariant created is subject to log alignments. the majority of the trees which make
it to the next generation score well in some (or all) of the quality dimensions.
table 7. usage of event logs of diﬀerent algorithms.
event log used during constraint speciﬁc brute force genetic
final evaluation /check /check /check
intermediate evaluation × × /check
time performance. the performance time of each algorithm varies depending
on the size of input process tree, size of the event logs and most importantly, the
individual algorithm settings. all the three modiﬁcation approaches are subjectto constraint veriﬁcation and event log alignments as ﬁnal evaluation to calcu-
late the quality of candidate process trees. it should be noted that in the case
of genetic modiﬁcation there are also intermediate event log alignments withrespect to every intermediate process tree. the genetic algorithm additionally
depends on the setting of various parameters. for example, if the parameters
such as population size and maximum generations are kept high, the geneticalgorithm may take a long time to complete. the time complexity in the case
of brute force modiﬁcation technique depends on the ‘threshold for maximum
number of edits’ and the number of nodes in the initial tree. however, the timecomplexity for constraint speciﬁc modiﬁcation approach is determined by the
number of constraints, the type of constraints and the depth of the initial tree.
that is, if the number of constraints are high, the constraints are unrelated andthe size of the initial tree is big then the constraint speciﬁc algorithm can take a
long time to complete. in a real life setting, the constraint speciﬁc modiﬁcation is
usually faster than the genetic approach, which in turn is faster than brute forcemodiﬁcation. this can be explained by the fact that constraint speciﬁc modi-
ﬁcation is primarily dependent on the number of constraints, hence is fastest.
the genetic approach discards the uninteresting candidates in each generation,
thereby converging faster than the brute force approach, which explores all the
variants within the given threshold. of course, as mentioned previously the indi-vidual parameters have a much higher impact on the performance time of each
of the approaches.
next, we focus on discussing the quantitative evaluation of the candidate
process trees from the pareto front. one method to evaluate the quality of out-
come from each modiﬁcation approach could be to present the domain expertusing domain knowledge to enhance process mining results 97
with a list of candidate process trees (or process models) to choose from. the
domain expert can choose the most appropriate process trees guided by the qual-ity scores for each process tree. for e.g., if the domain expert wants to focus on
process trees with high ﬁtness, then pareto front could be navigated to only look
at process trees with high ﬁtness. however this approach is highly subjective andwould depend entirely on the preference of the domain expert, and hence would
be diﬃcult to conduct in a scientiﬁc manner. another approach for evaluation
is to discover an expected model based on user speciﬁed constraints. in this app-
roach there is a certain expected model, which isn’t discovered by the traditional
process discovery techniques due to reasons such as data inconsistencies, discov-
ery algorithm biases etc. we use the latter approach for evaluation as it providesa ground truth that can be used to quantify results, and be used to evaluate
the results in a controlled way without depending on the high subjectivity of
the domain expert. we evaluate our approach based on both a synthetic log
and a real life log. the synthetic log demonstrates the usage of our approach on
small process trees. the real life event log is from a road traﬃc ﬁne managementprocess.
6.2 synthetic event log
we use a synthetic event log to demonstrate how our approach could improve
an incorrect model discovered due to algorithm bias and noisy event log. for
the event log l=[/angbracketlefta,b,c,d /angbracketright
90,/angbracketlefta,c,b,d /angbracketright90,/angbracketlefta,c,d,b /angbracketright90,/angbracketleftc,a,d,b /angbracketright90,
/angbracketleftc,a,b,d /angbracketright90,/angbracketleftc,d,a,b /angbracketright90,/angbracketleftc,d,b,a /angbracketright6,/angbracketleftc,b,a,d /angbracketright6,/angbracketleftd,a,c,b /angbracketright6], the induc-
tive miner infrequent (imi) [ 16] with default settings generates the process tree
with all four activities in parallel as shown in fig. 12a.
∧
a b c d
(a) original process tree as discovered
by inductive miner infrequent.∧
→
a b→
c d
(b) modiﬁed process tree present in the
output of all modiﬁcation approaches.
∧
a b →
c d
(c) modiﬁed process tree present in the
output of all modiﬁcation approaches.∧
→
a bc d
(d) modiﬁed process tree present in the
output of all modiﬁcation approaches.
fig. 12. original and modiﬁed process trees for event log l.98 p.m. dixit et al.
table 8. quality dimensions of the pareto front for process trees from fig. 12
tree constraints satisﬁed replay ﬁtness precision generalization simplicity
fig.12a0 1 0.833 0.957 1
fig.12b4 0.997 1 0.957 1
fig.12c2 0.999 0.900 0.957 1
fig.12d2 0.998 0.993 0.957 1
table 9. performance statistics for the modiﬁcation approaches from sect. 5
approach total # of trees
discoveredtotal # of treesin pareto front average computationtime for 5 runs (in ms)
brute force 8323 88 53232
genetic 50000a112b134689
constraint speciﬁc 481 4 295
a50000 is the maximum # of trees that could be produced (including duplicates).
b112 is the average number of trees in pareto front over ﬁve runs.
from the high frequent traces of the log we can deduce simple rules such
as activity ais always eventually followed by activity b; and activity bis
always preceded by activity a. similar relationship holds for activities cand d.
we use this information to deduce the following four constraints: response(a,b),
precedence(a,b), response(c,d), and precedence(c,d) . we use these constraints,
the process tree from fig. 12a discovered using imi [ 16] and the synthetic log (l)
as our input and perform the experiment with all three modiﬁcation approaches
discussed in sect. 5. for the genetic modiﬁcation approach, we set the stopping
condition of maximum generations to 500 generations. the population size in
each generation is set to 100. along with this, we add some additional conditions
restricting duplicate labels and guaranteeing minimum number of nodes. all the
other settings are kept as default as in the etm miner of [ 4]. in case of brute
force modiﬁcation, the maximum number of edits is set to 3.
table 9summarizes the performance statistics and output of each modiﬁca-
tion algorithm. the constraint speciﬁc modiﬁcation algorithm outperforms the
other approaches in terms of time taken, but also produces fewer process treescompared to the other two approaches. the genetic algorithm produces a pareto
front containing varying number of process trees in each new run. also, it takes
the longest time as every process tree created in each generation is subject toalignments, which is often time consuming. the brute force modiﬁcation is faster
than the genetic modiﬁcation as the number of nodes in the initial tree and the
number of activities is very low. figure 12shows the original process tree discov-
ered by imi (fig. 12a) and 3 modiﬁed process trees present in the pareto front
output of each modiﬁcation approach. table 8summarizes the dimension scores
of the process trees from fig. 12.using domain knowledge to enhance process mining results 99
the modiﬁed process tree from fig. 12b satisﬁes all the four constraints. the
tree from fig. 12b also has a higher precision value of 1, and a considerably high
replay ﬁtness score. this process tree is highly precise, thereby explaining the
high frequent traces of the event log much better and ignoring the infrequent
noisy traces. hence, if the user is interested the most in precision, then this isthe process tree that would be chosen. however, if the user is a little relaxed
w.r.t. to precision then process trees from fig. 12c and d might be interesting.
these process trees have a very high precision score along with very high ﬁtnessscores, outperforming the originally discovered process tree. however, only half
the constrains speciﬁed are present in these process trees. hence, if the user
decides that some constraint(s) can be relaxed/ignored, then these process treescould be chosen by the user. based on user’s preferences, the pareto front could
be navigated to select the most interesting process models.
6.3 real life event log
exceptional cases may dominate the normal cases, thereby leading to a process
model that is over-ﬁtting the data or that is too general to be of any value. thisprocess model could however be improved by incorporating domain knowledge.
in order to evaluate such a scenario, we use the following steps on a real-life
log containing the road traﬃc ﬁne management process with 11 activities and150,370 cases available at [ 9]:
1. use the complete event log to mine a process model using the heuristics miner.
learn domain rules based on this model and the log visualizers from prom.
2. filter the event log to select 1% of the cases having exceptionally deviating
behavior.
3. create a process tree based on the ﬁltered log using inductive miner infrequent
[16]. the bpmn representation of this process tree is shown in fig. 13.
4. use the domain rules learned in step 1, the process tree from the ﬁltered log
of step 3, in combination with the complete event log as input to each of the
modiﬁcation approaches.
we deduce 1 precedence, 1 response, 1 responded-existence and 1 not-
succesion rule from the complete event log using the heuristics miner and the
log visualizers from prom. these rules are shown in table 10. it should be noted
that these rules may or may not hold in the actual real life process model cor-
responding to the event log. however, all these rules have a high support and
conﬁdence according to the event log, and hence we consider them to be true.
for the genetic modiﬁcation approach, we set the stopping condition of max-
imum generations to 500 generations with the population size set to 100. all the
other settings are kept as default from the etm miner of [ 4]. therefore, in total
a maximum of 50000 trees are evaluated. in case of brute force modiﬁcation, themaximum number of edits is set to 3. furthermore, due to limited computing
resources, the maximum number of trees selected for pareto front evaluation in
both brute force modiﬁcation and constraint speciﬁc modiﬁcation approach was100 p.m. dixit et al.
fig. 13. bpmn model mined using imi with ﬁltered log containing infrequent traces
only.using domain knowledge to enhance process mining results 101
table 10. domain rules derived from the complete real life event log.
activity 1 constraint activity 2
insert fine notiﬁcation precedence send appeal to perfecture
receive result appeal
from perfectureresponded existence notify result appeal to oﬀender
appeal to judge not succession send appeal to perfecture
insert date appeal toperfecture response send appeal to perfecture
activities in bold are the primary activities.
limited to ﬁrst 5000 trees satisfying at least 50% of the constraints. that is, for
constraint speciﬁc modiﬁcation approach and brute force modiﬁcation approach,
the total number of trees kept in memory were 5000 each, which were then used
to populate the pareto front.
table 11. dimensions statistics for process trees based on real life event log
tree constraints
satisﬁedreplayﬁtness precision generalization simplicity
imi 0 0.74 0.52 0.84 1
alpha 0 0.74 0.72 0.96 1
ilp 0 1 0.37 0.99 1
constraint speciﬁc 4 0.99 0.64 0.99 1
genetic 4 0.82 0.71 0.98 1
brute force 4 0.83 0.68 0.99 1
in table 11we compare the evaluation outcomes of diﬀerent approaches in
terms of ﬁtness, precision, generalization and simplicity. since we considered
the original complete event log as the ground truth, in the discussion to follow
we primarily focus on the replay ﬁtness and precision dimensions, as these twodimensions give a very good description of the model in terms of the event log.
when the process model obtained from ﬁltered event log (fig. 13), is evaluated
against the complete event log, it features very poorly with very low ﬁtnessand precision scores of 0.74 and 0.52 respectively. furthermore, we used a few
of the automated process discovery algorithms to discover a model based on
the ﬁltered event log. each of these models were then evaluated against thecomplete event log, and the results presented in the table 11. model mined by
ilp miner returned a perfect ﬁtness score of 1, even against the complete event
log. however, many of the activities in the discovered model were completelyisolated. hence, it allowed for any behavior thereby ﬁtting the complete log very
well, but having extremely poor precision value of 0.34. the alpha algorithm102 p.m. dixit et al.
bfm csm gm00.20.40.60.81
(a) range of ﬁtness scores of all the
trees from the pareto front for each al-gorithm.bfm csm gm00.20.40.60.81
(b) range of precision scores of all the
trees from the pareto front for each al-gorithm.
fig. 14. range of ﬁtness and precision scores for process trees from pareto front output
based on real life event logs.
generated a model which had the same score (of 0.74) for replay ﬁtness as the
imi, and a much better precision value of 0.72.
as a next step we compare the outcomes of models mined using domain
knowledge against the models mined without domain knowledge. for this we
need to choose some models from the outputs of each of the modiﬁcationapproaches. all the three approaches contained at least 50 process trees in the
pareto fronts. as evident from fig. 14, the range of ﬁtness and precision values is
big, for process trees from the pareto front. in order to compare the outcome ofthe modiﬁcation approaches, we selected three process trees, one corresponding
to each modiﬁcation approach having a balanced high score of ﬁtness and pre-
cision, and satisfying all the four constraints. all the three models chosen havea considerably higher ﬁtness scored than the traditional techniques, except the
model mined by ilp miner. similarly, the precision scores of each of the selected
model were usually considerably higher than the traditional process automateddiscovery techniques. this makes the improvements after adding the domain
knowledge for post processing quite evident.
7 conclusions and future work
in this paper we introduced a way to incorporate the domain knowledge of
the expert in an already discovered process model. we primarily introducedtwo types of algorithms: veriﬁcation and modiﬁcation, in order to verify and
incorporate domain knowledge in the process model respectively. the proposed
veriﬁcation algorithm provides a comprehensive way of validating whether the
constraints are satisﬁed by the process tree. in the current approach we consider
a subset of declare templates. in the future this could be extended to include all
the declare templates. for modiﬁcation, we have proposed three algorithms. the
brute force approach exhaustively generates multiple process trees. however, theusing domain knowledge to enhance process mining results 103
brute force approach does not consider the user constraints during the modiﬁ-
cation process. in order to overcome this, we introduce a genetic approach toconsider both log and constraints during modiﬁcation. as shown in subsect. 6.3,
the guided genetic algorithm is considerably faster than the brute force app-
roach when the number of activity classes is high. however, individually bothbrute force and genetic approach are time and memory ineﬃcient. hence, we
introduced another modiﬁcation approach which changes the process model by
individually considering each user constraint. currently, underlying assumptionof this approach is that the process model does not contain duplicate labels.
each modiﬁcation approach has its own set of pro’s and con’s. for example,
brute force modiﬁcation and constraint speciﬁc modiﬁcation techniques resultin a consistent pareto front, on repetitive runs of experiments. however, in the
case of genetic approach, diﬀerent runs could result in diﬀerent process trees in
the pareto front. the constraint speciﬁc modiﬁcation approach performs a pre-
existing set of operations for modiﬁcation and does not consider log information
while modiﬁcation, hence is faster than other approaches but rather limited inthe number of process trees created. in the future, we would like to optimise the
modiﬁcation approach and/or ensure certain guarantees in the modiﬁed process
trees. another future direction could be to incorporate domain knowledge atdiﬀerent stages, for example when logging event data or during the discovery
phase.
references
1. adriansyah, a., van dongen, b.f., van der aalst, w.m.p.: conformance checking
using cost-based ﬁtness analysis. in: 15th ieee international enterprise distrib-
uted object computing conference (edoc), pp. 55–64. ieee (2011)
2. adriansyah, a., dongen, b.f., van der aalst, w.m.p.: towards robust conformance
checking. in: muehlen, m., su, j. (eds.) bpm 2010. lnbip, vol. 66, pp. 122–133.
springer, heidelberg (2011). doi: 10.1007/978-3-642-20511-8 11
3. alberti, m., chesani, f., gavanelli, m., lamma, e., mello, p., torroni, p. veriﬁ-
able agent interaction in abductive logic programming: the sciﬀ framework. acm
trans. comput. logic 9(4), 29:1–29:43 (2008)
4. buijs, j.c.a.m., van dongen, b.f., van der aalst, w.m.p.: a genetic algorithm for
discovering process trees. in: ieee congress on evolutionary computation (cec),
pp. 1–8. ieee (2012)
5. buijs, j., van dongen, b.f., van der aalst, w.m.p. quality dimensions in process
discovery: the importance of ﬁtness, precision, generalization and simplicity. int.
j. cooperative inf. syst., 23(1) (2014). doi: 10.1142/s0218843014400012
6. chesani, f., lamma, e., mello, p., montali, m., riguzzi, f., storari, s.: exploit-
ing inductive logic programming techniques for declarative process mining. in:
jensen, k., van der aalst, w.m.p. (eds.) topnoc ii. lncs, vol. 5460, pp. 278–295. springer, heidelberg (2009). doi: 10.1007/978-3-642-00899-3
16
7. ciccio, c., mecella, m.: mining constraints for artful processes. in: abramowicz,
w., kriksciuniene, d., sakalauskas, v. (eds.) bis 2012. lnbip, vol. 117, pp. 11–23.springer, heidelberg (2012). doi: 10.1007/978-3-642-30359-3
2104 p.m. dixit et al.
8. leoni, m., maggi, f.m., van der aalst, w.m.p.: aligning event logs and declarative
process models for conformance checking. in: barros, a., gal, a., kindler, e. (eds.)
bpm 2012. lncs, vol. 7481, pp. 82–97. springer, heidelberg (2012). doi: 10.1007/
978-3-642-32885-5 6
9. de leoni, m., mannhardt, f.: road traﬃc ﬁne management process. http://dx.
doi.org/10.4121/uuid:270fd440-1057-4fb9-89a9-b699b47990f5
10. dixit, p.m., buijs, j.c.a.m., van der aalst, w.m.p., hompes, b.f.a., buurman,
j.: enhancing process mining results using domain knowledge
11. fahland, d., van der aalst, w.m.p.: repairing process models to reﬂect reality. in:
barros, a., gal, a., kindler, e. (eds.) bpm 2012. lncs, vol. 7481, pp. 229–245.
springer, heidelberg (2012). doi: 10.1007/978-3-642-32885-5 19
12. giordano, l., martelli, a., spiotta, m., dupre, d.t.: business process veriﬁcation
with constraint temporal answer set programming. theory, pract. logic program.
13, 641–655 (2013). doi: 10.1017/s1471068413000409
13. goedertier, s., martens, d., vanthienen, j., baesens, b.: robust process discovery
with artiﬁcial negative events. j. mach. learn. res. 10, 1305–1340 (2009)
14. greco, g., guzzo, a., lupa, f., luigi, p.: process discovery under precedence
constraints. acm trans. knowl. discov. data 9(4), 2:1–32:39 (2015)
15. lamma, e., mello, p., riguzzi, f., storari, s.: applying inductive logic program-
ming to process mining. in: blockeel, h., ramon, j., shavlik, j., tadepalli, p. (eds.)ilp 2007. lncs (lnai), vol. 4894, pp. 132–146. springer, heidelberg (2008).
doi:10.1007/978-3-540-78469-2
16
16. leemans, s.j.j., fahland, d., van der aalst, w.m.p.: discovering block-structured
process models from event logs containing infrequent behaviour. in: lohmann, n.,
song, m., wohed, p. (eds.) bpm 2013. lnbip, vol. 171, pp. 66–78. springer,
heidelberg (2014). doi: 10.1007/978-3-319-06257-0 6
17. maggi, f.m., mooij, a.j., van der aalst, w.m.p.: user-guided discovery of declara-
tive process models. in: ieee symposium on computational intelligence and data
mining (cidm), pp. 192–199. ieee (2011)
18. pesic, m., schonenberg, h., van der aalst, w.m.p.: declare: full support for loosely-
structured processes. in: 11th ieee international enterprise distributed object
computing conference, edoc, p. 287. ieee (2007)
19. ramezani, e., fahland, d., van der aalst, w.m.p.: where did i misbehave? diag-
nostic information in compliance checking. in: barros, a., gal, a., kindler, e.
(eds.) bpm 2012. lncs, vol. 7481, pp. 262–278. springer, heidelberg (2012).doi:10.1007/978-3-642-32885-5
21
20. rembert, a.j., omokpo, a., mazzoleni, p., goodwin, r.t.: process discovery
using prior knowledge. in: basu, s., pautasso, c., zhang, l., fu, x. (eds.) icsoc2013. lncs, vol. 8274, pp. 328–342. springer, heidelberg (2013). doi: 10.1007/
978-3-642-45005-1
23
21. runte, w., el kharbili, m.: constraint checking for business process management.
in: gi jahrestagung, pp. 4093–4103 (2009)
22. van der aalst, w.m.p.: process mining - data science in action, 2nd edn. springer,
heidelberg (2016)
23. werf, j.m.e.m., dongen, b.f., hurkens, c.a.j., serebrenik, a.: process discovery
using integer linear programming. in: hee, k.m., valk, r. (eds.) petri nets2008. lncs, vol. 5062, pp. 368–387. springer, heidelberg (2008). doi: 10.1007/
978-3-540-68746-7
24