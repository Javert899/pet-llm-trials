ilp-based process discovery using hybrid regions
s.j. van zelst, b.f. van dongen, and w.m.p. van der aalst
department of mathematics and computer science
eindhoven university of technology, the netherlands
fs.j.v.zelst,b.f.v.dongen,w.m.p.v.d.aalst g@tue.nl
abstract. the language-based theory of regions , stemming from the area of
petri net synthesis , forms a fundamental basis for integer linear programming
(ilp)-based process discovery. based on example behavior in an event log, a pro-
cess model is derived that aims to describe the observed behavior. building on
top of the existing ilp-formulation, we present a new ilp-based process discov-
ery formulation that uniﬁes two existing types of language-based regions and,
additionally, we present a generalized ilp objective function that captures both
region-types and helps us to ﬁnd suitable process discovery results.
keywords: process mining, process discovery, integer linear programming, re-
gion theory
1 introduction
process mining [1] forms the connecting element between business process modeling
and data analysis. its main aim is to extract knowledge from business process execution
data originating from a variety of data sources, e.g., enterprise information systems, so-
cial media, embedded systems etc. within process mining, three main branches are dis-
tinguished being process discovery ,conformance checking andprocess enhancement .
within process discovery the aim is to, given an event log, reconstruct a process model.
within conformance checking the aim is to assess, given a process model and an event
log, the conformance of the event log to the process model. within process enhance-
ment the aim is to further improve and/or align existing process models by combin-
ing the two aforementioned disciplines, e.g., identiﬁcation and removal of bottlenecks
within business processes.
the area of petri net synthesis [2] is concerned with deciding whether there exists
a petri net that exactly describes a given sequential behavioral system description . a
subclass of synthesis techniques is the area of region theory which is both deﬁned on
transition systems, known as state-based region theory , and on languages, known as
language-based region theory .
language-based region theory forms a fundamental basis for ilp-based process
discovery [3]. within process discovery however, a process model is typically valued
w.r.t. four essential process mining quality dimensions being replay-ﬁtness ,precision ,
generalization andsimplicity [4]. applying traditional petri net synthesis techniques
in a process discovery context will result in models that have perfect replay-ﬁtness,
maximal precision, low generalization and often low simplicity.2
in this paper we propose a uniﬁed approach w.r.t. ilp-based process discovery,
based on the newly introduced concept of hybrid variable-based regions . hybrid variable-
based regions unite two existing language-based region deﬁnitions and allow us to vary
the number of variables used within the ilp problems being solved. therefore, we as-
sess the impact of using a different number of variables on the average computation
time of solving ilps during ilp-based process discovery. additionally we present a
new generalized ilp objective function that supports hybrid variable-based regions and
show that the objective function yields correct process discovery results.
the outline of this paper is as follows. in section 2 we present basic preliminaries.
in section 3 we present language-based regions. in section 4 we show how to adopt
language-based regions within process discovery using ilp. in section 5 we present
a brief evaluation of the performance of the approach. section 6 covers related work.
section 7 concludes the paper.
2 preliminaries
2.1 bags, sequences and vectors
letzdenote the set of integers, let ndenote the set of positive integers including 0
and let n+denote the set of positive integers excluding 0. letrdenote the set of real
numbers and let r+denote the set of positive real numbers excluding 0.
letsdenote a set. let us deﬁne a bagbas a function b:s!n. notation-wise
we write a bag as [en1
1;en2
2;:::;en3
3], whereei2s,ni2n+andeni
ib(ei) =ni. if
for some element e,b(e) = 1 , we omit its superscript. an empty bag is denoted as ;.
as an example let s1=fa;b;c;dgand letb1denote a bag consisting of 3a’s,5b’s,
1cand0d’s, i.e.b1= [a3;b5;c]. element inclusion applies to bags as well, i.e. given
e2sandb(e)>0then alsoe2b. thus we have a2b1whereasd =2b1.
asequenceis a function relating positions to elements e2s, i.e.:f1;2;:::;
kg!s. an empty sequence is denoted as . we write every non-empty sequence as
he1;e2;:::;eki. the set of all possible sequences over a set sis denoted as s. we deﬁne
concatenation of sequences 1and2as12, e.g.,ha;bihc;di=ha;b;c;di. if we
are given a set xof sequences over s, i.e.,xs, we deﬁnex’spreﬁx-closure as
x=f12sj922s(122x)g. letxs,xispreﬁx-closed ifx=x. let
xsand letbx:x!nbe a bag, we deﬁne bx’s preﬁx closure as bx:x!n
bx() =b() +x
hei2xbx(hei)
thus, for set x1=fha;bi;ha;cigwe havex1=f;hai;ha;bi;ha;cigwhereas for
bagb2= [ha;bi5;ha;ci3]we haveb2= [8;hai8;ha;bi5;ha;ci3].
letsbe a set on which we can pose some total order and let rrbe a range
of values. vectors are denoted as ~ z2rjsj, where~ z(e)2rande2s. a vector
~ zrepresents a column vector. for vector multiplication we assume vectors to agree
on their indices. thus, given a totally ordered set s=fe1;e2;:::;engand~ z1;~ z22
rjsjwe have~ z|
1~ z2=p
i2f1;2;:::;ng~ z1(ei)~ z2(ei).parikh vectors represent the number
of occurrences of a certain element within a sequence. a parikh vector is a function3
~ p:s!njsjwith~ p() = (e1;e2;:::;en)whereei=jfjj1jjj;
(j) =eigj. as an example consider s=fa;b;c;dg,1=ha;b;diand2=ha;c;di.
we have~ p(1)|= (1;1;0;1)and~ p(2)|= (1;0;1;1). note that1b= 1 whereas
2b= 0. given a parikh vector ~ p:s!njsjand a setqs, we deﬁne~ pq:s!
njqj. thus given s=fa;b;c;dgand1=ha;b;diwe have~ pfa;c;dg(1)|= (1;0;1).
2.2 event logs and petri nets
the main goal of process discovery is to describe the observed behavior within an
event log by means of a process model. thus, event logs act as the input of process
discovery whereas some process model acts as the output of process discovery. an
abstract example of an event log is presented in table 1. often more data attributes are
available in an event log, e.g., customer id ,credit balance etc. in this paper we focus on
the sequential ordering of activities w.r.t. cases , i.e. the control-ﬂow perspective .
deﬁnition 1 (event log). letabe a set of activities, an event log lis a bag of se-
quences over a, i.e.,l:a!n.1
a sequence of activities 2lis referred to as a trace . we assume that any given set
of activities ais totally ordered (or we are able to trivially pose a total ordering on a).
we consider petri nets to describe process models. a petri net is a bipartite graph
consisting of a set of vertices called places and a set of vertices called transitions . arcs
(directed edges) are connecting places and transitions and have an associated positive
weight.
deﬁnition 2 (petri net). a petri net is a 3-tuplen= (p;t;w ), wherepis a set of
places andtis a set of transitions with p\t=;.wis the weighted ﬂow relation of
n,w: (pt)[(tp)!n.
for a given node x2p[t, the pre-set of xinnis deﬁned asx=fyjw(y;
x)>0g. correspondingly x=fyjw(x;y)>0gdenotes the post-set of xin
n. graphically we represent places as circles and transitions as boxes . for every (x;
y)2(pt)[(tp)withw(x;y)>0we draw an arcfromxtoy. ifw(x;y)>1
table 1: an abstract example of an event log .
case id activity id resource id time-stamp
c1 a lucy 2015-01-05t09:13:37+00:00
c2 a john 2015-01-05t13:37:25+00:00
c2 b pete 2015-01-06t13:14:15+00:00
c2 d lucy 2015-01-06t15:27:18+00:00
c1 c pete 2015-01-07t14:28:56+00:00
c1 d john 2015-01-07t15:30:00+00:00
............
1in practice we extract an event log lfrom some information system. consequently ais
implicitly deﬁned by the event log, i.e., aonly consists of events that are actually present l.4
we denote the arc’s weight w(x;y)on top of the arc from xtoy. a petri net is pure
if it does not contain self-loops, i.e., if w(x;y)>0thenw(y;x) = 0 . an example
(pure) petri net is depicted in figure 1.
deﬁnition 3 (marked petri net). letn= (p;t;w )be a petri net. a marking of n
is a bag over n’s places, i.e. m:p!n. a marked petri net is a pair (n;m 0), where
m0representsn’s initial marking.
letn= (p;t;w )be a petri net and let mbe a marking of n. a transition t2t
isenabled , denoted (n;m )[ti, if and only if8p2t(m(p)w(p;t)). graphically
we represent a marking by drawing exactly a place’s marking-multiplicity number of
dots inside the place (e.g. p1in figure 1 with m0= [p1]). if a transition tis enabled
in(n;m ),tmay ﬁre, resulting in a new marking m0. whentﬁres, denoted as (n;
m)[ti(n;m0), we have8p2p(m0(p) =m(p) w(p;t) +w(t;p)). for example in
figure 1 we have (n1;[p1])[ai(n1;[p2]).
deﬁnition 4 (firing sequences). letn= (p;t;w )be a petri net and let (n;m 0)
be a corresponding marked petri net. sequence =ht1;t2;:::;tni2tis a ﬁring
sequence of (n;m 0), written as (n;m 0)[i(n;mn)if and only if for n=jjthere
exist markings m0;m 1;m 2;:::;mnsuch that (n;m 0)[t1i(n;m 1),(n;m 1)[t2i(n;
m2);:::;(n;mn 1)[tni(n;mn).
note that inﬁnitely many ﬁring sequences can exist given a petri net. some example
ﬁring sequences of the petri net depicted in figure 1 are: (n1;[p1])[haii(n1;[p2]),
(n1;[p1])[ha;bii(n1;[p3])and(n1;[p1])[ha;c;d;e;f;e;f;e;g ii(n1;;). the set of all
possible ﬁring sequences in a petri net nis calledn0slanguage, i.e., all sequences
2ts.t.(n;m 0)[i(n;mi).n’s language is denoted as l(n)tand is preﬁx-
closed.
consider figure 1 and event log l1= [ha;b;d;e;gi10;ha;c;d;e;gi9;ha;b;d;e;
f;e;gi11;ha;c;d;e;f;e;gi8]overa1=fa;b;c;d;e;f;gg. clearly we have l1
l(n1), and thus replay-ﬁtness of l1onn1is perfect. we will use n1,a1andl1
throughout the paper as a running-example.
3 regions
the concept of regions forms the basis of region theory within petri net synthesis. given
an event log lover a set of activities a, language-based regions are used to represent
p1a
p2b
cp3d
p4e
fp5g
fig. 1: a pure petri net n1= (p1;t1;w 1)withp1=fp1;p2;:::;p 5g;t1=fa;b;:::;
ggandw1(p1;a) =w1(a;p 2) =:::=w1(p5;g) = 1 .5
places in a resulting petri net n= (p;a;w ). a language-based region maps every
a2ato an integer representing arc-weight. for such mapping over ato be a region
we pose the restriction that the corresponding place p2pshould not block any 2l,
i.e.,2l)2l(n). we identify two basic deﬁnitions of language-based regions
which we classify as single variable-based regions anddual variable-based regions .
the main difference is the number of variables used to deﬁne a region.
deﬁnition 5 (single variable-based regions). letlbe an event log over a set of ac-
tivitiesa. letm2nand let~ v2zjaj. a pairr= (m;~ v)is a single variable-based
region iff:
82l(m+~ p()|~ v0) (3.1)
letrs(l)denote the set of all possible single variable-based regions of l. equation 3.1
generates a set of linear inequalities, i.e. applying equation 3.1 on l1yields:
m 0
m+~ v(a) 0hai
m+~ v(a) +~ v(b)0ha;bi
.........
m+~ v(a) +~ v(b) +~ v(d) + 2~ v(e) +~ v(f) +~ v(g)0ha;b;d;e;f;e;gi
m+~ v(a) +~ v(c) +~ v(d) + 2~ v(e) +~ v(f) +~ v(g)0ha;c;d;e;f;e;gi
single variable-based regions use one single decision variable for each a2a,
represented by ~ v2zjaj. expressing a single variable-based region r= (m;~ v)as
a placep2pin a marked net (n;m 0)withn= (p;a;w )is straightforward.
we havem0(p) =m, if~ v(a)>0thenw(a;p) =~ v(a), if~ v(a)<0thenw(p;
a) = ~ v(a)and if~ v(a) = 0 thenw(a;p) =w(p;a) = 0 . consider place p2depicted
in figure 1 which can be represented as a single variable-based region r= (m;(~ v(a);
~ v(b);:::;~ v (g))) = (0;(1; 1; 1;0;0;0;0)). note that for each inequality generated by
equation 3.1, place p2has a value of at least 0and hence is a member of rs(l).
single variable-based regions only allow us to synthesize/discover pure petri nets.
as a consequence we can not ﬁnd self-loops, i.e. we can not ﬁnd a place pin a resulting
netn= (p;a;w )s.t.p2a\a, for anya2a. a lot of workﬂow patterns [5] in fact
exhibit places that include self-loops, e.g. milestone patterns, mutual-exclusion patterns,
priority patterns etc. hence, we deﬁne dual variable-based regions which explicitly
allow us to distinguish between incoming and outgoing arcs.
deﬁnition 6 (dual variable-based regions). letlbe an event log over a set of activ-
itiesa. letm2nand~ x;~ y2njaj. a tripler= (m;~ x;~ y )is a dual variable-based
region iff:
8=0hai2l(m+~ p(0)|~ x ~ p()|~ y0) (3.2)
letrd(l)denote the set of all possible dual variable-based regions of l. like deﬁni-
tion 5, deﬁnition 6 generates a set of linear inequalities. applying deﬁnition 6 on l1
yields:
m ~ y(a) 0hai
m ~ y(a) +~ x(a) ~ y(b) 0ha;bi
m ~ y(a) +~ x(a) ~ y(c) 0ha;ci
.........
m ~ y(a) +~ x(a) ~ y(b) +~ x(b) ~ y(d) +~ x(d) 2~ y(e) + 2~ x(e) ~ y(f) +~ x(f) ~ y(g)0ha;b;d;e;f;e;gi
m ~ y(a) +~ x(a) ~ y(c) +~ x(c) ~ y(d) +~ x(d) 2~ y(e) + 2~ x(e) ~ y(f) +~ x(f) ~ y(g)0ha;c;d;e;f;e;gi6
dual variable-based regions use two decision variables per a2a, represented by
~ x;~ y2njaj. the variables allow us to distinguish between incoming arcs andoutgoing
arcs when translating regions to petri nets. expressing a dual variable-based region
r= (m;~ x;~ y )as a placep2pin marked net (n;m 0)withn= (p;a;w )is again
straightforward. we have m0(p) =m,w(a;p) =~ x(a)andw(p;a) =~ y(a). again
consider place p2depicted in figure 1 which can be represented as a dual variable-based
regionr= (m;(~ x(a);~ x(b);:::;~ x (g));(~ y(a);~ y(b);:::;~ y (g))) = (0;(1;0;0;0;0;0;0);
(0;1;1;0;0;0;0)). verify that for each linear in-equality generated by deﬁnition 6,
placep2has a value of at least 0and hence is a member of rd(l).
4 hybrid variable-based regions in process discovery
using dual variable-based regions allows us to express non-pure places, i.e, self-loops,
milestones etc. however, this type of regions uses roughly twice as many variables
compared with single variable-based regions. to balance the number of variables used,
though still enhance the possibility of ﬁnding non-pure petri net structures, we intro-
duce the new concept of hybrid regions, capturing both single and dual variable-based
regions.
deﬁnition 7 (hybrid variable-based regions). letlbe an event log over a set of
activitiesa. letas;adabe two sets of activities with as[ad=aandas\ad=
;. letm2n,~ v2zjasjand~ x;~ y2njadj. a quadruple r= (m;~ v;~ x;~ y )is a hybrid
variable-based region iff:
8=0hai2l(m+~ pas()|~ v+~ pad(0)|~ x ~ pad()|~ y0) (4.1)
given a set of activities aand two sets of activities as;adawithas[ad=aand
as\ad=;, we refer to a hybrid partition ofa. if we choose ad=a, equation 4.1
is equal to equation 3.2. if we choose as=a, equation 4.1 can be reformulated as:
82lnfg(m+~ p()|~ v0) (4.2)
equation 4.2 does not equal equation 3.1, however, as ~ p() =~0andm2n, the
equations are equivalent in this context.
note that the set of hybrid variable-based regions, i.e. the set of variable assignments
that adhere to deﬁnition 7 depends on the hybrid partition of aintoasandad. there-
fore, we letasact as a parameter for the set of feasible hybrid variable-based regions.
letrh
as(l)denote the set of all possible hybrid variable-based regions of lwhereas
represent a hybrid partition of a. noterh
a(l) =rs(l)andrh
;(l) =rd(l). region
r= (0;~0;~0;~0)is deemed the trivial region .
all three language-based region deﬁnitions, i.e. single, dual and hybrid variable-
based regions, provide means to accept and/or reject potential places in a to be con-
structed petri net. in classical petri net synthesis approaches, one keeps looking for
feasible places until either l=l(n), or if this is impossible, l(n)nlis minimized.
unfortunately, most models returned by classical petri net synthesis techniques result
in models that are unusable from a process discovery perspective. hence, we need to
relax the strict formal requirements posed on the relation between landl(n).7
deﬁnition 8 (hybrid variable-based process discovery ilp-formulation). letlbe
an event log over a set of activities aand letas;adabe a hybrid partition. let
ms;md;m0
dbe three matrices where msis anjljnfgasmatrix with ms(;
a) =~ p()(a)andmd,m0
dare twojljnfgadmatrices with md(;a) =~ p()(a)
andm0
d(;a) =~ p(0)(a)(where=0ha0i2l). letcm2r,~ cv2rjasjand
~ cx;~ cy2rjadj. the hybrid variable-based process discovery ilp-formulation, denoted
ilph
l, is deﬁned as:
minimizez=cmm+~ cv|~ v+~ cx|~ x+~ cy|~ yobjective function
such thatm~1 +ms~ v+m0
d~ x md~ y~0hybrid variable-based region
and ~ 1~ v~1i.e.~ v2f  1;0;1gjasj
~0~ x~1i.e.~ x2f0;1gjadj
~0~ y~1i.e.~ y2f0;1gjadj
0m1i.e.m2f0;1g
the ilp-fromulation presented in deﬁnition 8 uses the set of linear in-equalities
generated by equation 4.1 within its constraint body. the formulation however binds
~ vtof 1;0;1gjasjand~ x;~ ytof0;1gjadj, i.e. the formulation only allows for discover-
ing petri nets with arc weights restricted to f0;1g. additionally it deﬁnes an objective
function, i.e. z=cmm+~ cv|~ v+~ cx|~ x+~ cy|~ y, that maps each region to a real value,
i.e.z:rh
as(l)!r. in general we are free to choose whatever objective function
we like, however, using different objective functions will lead to different process dis-
covery results. choosing cm= 0 and~ cv=~ cx=~ cy=~1leads to arc minimization
whereas maximizing the same objective leads to arc maximization, resulting in differ-
ent places/regions found by the underlying ilp solver. the objective function proposed
in [3], being a minimization function, tries to minimize the number of incoming arcs
and maximize the number of outgoing arcs. the objective function can be deﬁned in
terms ofcm;~ cv;~ cxand~ cyascm=jlj,~ cv=p
2l~ pas(),~ cx=p
2l~ pad()and
~ cy= ~ cx, i.e.:
z(r) =x
2l(m+~ pas()|~ v+~ pad()|(~ x ~ y)) (4.3)
4.1 optimizing token throughput
the objective function used within [3], i.e. equation 4.3 is less generic as the one pro-
posed in deﬁnition 8. as shown in [3], it favors minimal regions. a minimal region is
a region that is not expressible as the sum of two other regions. the objective function
is solely based on the set-representation of the preﬁx-closure of an event log. however,
an event log is a bag of traces and thus consists of information on trace frequency. we
propose a generalized preﬁx-closure-based objective function that incorporates a word-
based scaling function . the scaling function is required to map all sequences in the
preﬁx-closure of the event log to some positive real value. the actual implementation
is up to the user, although we present an instantiation of that works well for process
discovery. we show that the proposed generalized weighted preﬁx-closure-based hybrid
region objective function favors minimal regions, given any scaling function .8
deﬁnition 9 (generalized weighted preﬁx-closure-based hybrid region objective
function). letlbe an event log over a set of activities aand letas;adabe a
hybrid partition. let r= (m;~ v;~ x;~ y )2rh
as(l)be a hybrid variable-based region and
letbe a scaling function over l, i.e.:l!r+. the generalized weighted preﬁx-
closure-based hybrid region objective function is instantiated as cm=p
2l(),
~ cv=p
2l()~ pas(),~ cx=p
2l()~ pad()and~ cy= ~ cx, i.e.:
z(r) =x
2l()(m+~ pas()|~ v+~ pad()|(~ x ~ y)) (4.4)
note that if we choose () = 1 for all2l, denoted1, we instantiate the gen-
eralized objective function as the objective function proposed in [3]. we denote this
objective function as z1, i.e. equation 4.3.
to relate the behavior in a given event log to the objective function deﬁned in deﬁ-
nition 9 we instantiate the scaling function making use of the frequencies of the traces
present in the event log, i.e. we let () =l()leading to:
zl(r) =x
2ll()(m+~ pas()|~ v+~ pad()|(~ x ~ y)) (4.5)
to assess the difference between z1and the newly proposed objective function zl,
consider the petri net depicted in figure 2. assume we are given some event log l=
[ha;b;di5;ha;c;di3]. letr1denote the hybrid variable-based region corresponding to
placep1, letr2correspond to p2and letr3correspond to p3. in this case we have
z1(r1) = 1 ,z1(r2) = 1 andz1(r3) = 2 . on the other hand we have zl(r1) =zl(r2) =
zl(r3) = 5+3 = 8 . thus, using zlleads to more intuitive objective values compared
to usingz1aszlevaluates to the absolute number of discrete time-steps a token would
remain in the corresponding place when replaying log lw.r.t. the place.
in [3] it is shown that the objective function used favors minimal regions. the proof
cannot directly be adapted to hold for hybrid variable-based regions. moreover it does
not provide means to show that any arbitrary instantiation of zfavors minimal hy-
brid variable-based regions. here we show that any instantiation of the generalized
weighted preﬁx-closure-based hybrid region objective function with some scaling func-
tion:l!r+favors minimal hybrid variable-based regions. we ﬁrst show that the
objective value of a non-minimal hybrid region equals the sum of the two minimal re-
gions deﬁning it after which we show that the given objective function maps each region
to some positive real value, i.e. rng(z)r+.
p1a
p2b
cp3d
fig. 2: a simple petri net nwithl(n) =f;hai;ha;bi;ha;ciha;b;di;ha;c;dig.9
lemma 1 (objective value composition of non-minimal regions). letlbe an event
log over a set of activities aand letas;adabe a hybrid partition. let r1= (m1;
~ v1;~ x1;~ y1),r2= (m2;~ v2;~ x2;~ y2)andr3= (m1+m2;~ v1+~ v2;~ x1+~ x2;~ y1+~ y2)withr1;
r2;r32rh
as(l). letz:rh
as(l)!rwherezis an instantiation of the generalized
weighted objective function as deﬁned in deﬁnition 9, then z(r3) =z(r1) +z(r2).
proof (by deﬁnition of z). let us denote z(r3):
x
2l()((m1+m2) +~ pas()|(~ v1+~ v2) +~ pad()|((~ x1+~ x2) (~ y1+~ y2)))
x
2l()(m1+~ pas()|~ v1+~ pad()|(~ x1 ~ y1)+m2+~ pas()|~ v2+~ pad()|(~ x2 ~ y2))
x
2l()(m1+~ pas()|~ v1+~ pad()|(~ x1 ~ y1)) +
x
2l()(m2+~ pas()|~ v2+~ pad()|(~ x2 ~ y2))
clearlyz(r3) =z(r1) +z(r2). 
lemma 1 shows that the value of zfor a non-minimal region equals the sum of the
zvalues of the two regions it is composed of. if we additionally show that zcan
only evaluate to positive values, we show that zfavors minimal hybrid variable-based
regions.
lemma 2 (range of zis strictly positive). letlbe an event log over a set of activ-
itiesaand letas;adabe a hybrid partition. let r= (m;~ v;~ x;~ y )be a non-trivial
region, i.e.,r2rh
as(l). if we letzbe any instantiation of the generalized weighted
objective function as deﬁned in deﬁnition 9, then z:rh
as(l)!r+.
proof (by showing z(r)>0;8r2rh
as(l)). letr= (m;~ v;~ x;~ y )be a non-trivial
hybrid variable-based region, i.e. r2rh
as(l). becauser2rh
as(l)we have
8=0hai2lnfg(m+~ pas()|~ v+~ pad(0)|~ x ~ pad()|~ y0) (4.6)
note that each parikh value of an activity a2agiven a sequence , i.e.~ p()(a),
is greater or equal than the parikh value of a, given’s preﬁx, i.e.,:
8=0ha0i2l;a2a(~ p()(a)~ p(0)(a)) (4.7)
using equation 4.7 we can substitute ~ pad(0)|~ xwith~ pad()|~ xin equation 4.6:
8=0hai2lnfg(m+~ pas()|~ v+~ pad()|(~ x ~ y)0) (4.8)
combiningrng()r+,~ p() =~0andm2nwith equation 4.8 we ﬁnd z(r)0:
x
2l()(m+~ pas()|~ v+~ pad()|(~ x ~ y))0 (4.9)10
ifm> 0then()(m+~ pas()|~ v+~ pad()|(~ x ~ y))>0. combined with equations 4.8
and 4.9 leads to z(r)>0.
observe that if m= 0 then forrto be a non-trivial hybrid variable-based region,
i.e.r2rh
as(l), either (i).9a2ass.t.~ v(a)>0or (ii).9a2ads.t.~ x(a)>0.
(i). letm= 0 anda2ass.t.~ v(a)>0. we know9=0hai2l. because
r2rh
as(l)(using equation 4.8) we have:
m+~ pas()|~ v+~ pad()|(~ x ~ y)0
if0=, we have~ pad() =~0and~ pas()|~ v=~ v(a)hence we deduce:
m+~ pas()|~ v+~ pad()|(~ x ~ y)>0
combining this with equations 4.8 and 4.9 yields z(r)>0.
if06=we have (using equation 4.8):
m+~ pas(0)|~ v+~ pad(0)|(~ x ~ y)0
observe that ~ pas()|~ v=~ pas(0)|~ v+~ v(a), together with ~ pad(0) =~ pad()leads us
to reformulate this to:
m+~ pas()|~ v ~ v(a) +~ pad()|(~ x ~ y)0
m+~ pas()|~ v+~ pad()|(~ x ~ y)~ v(a)
combining this with equations 4.8 and 4.9 yields z(r)>0.
(ii) letm= 0 anda2ads.t.~ x(a)>0. we know9=0hai2l. because
r2rh
as(l)(using equation 4.6) we have:
m+~ pas()|~ v+~ pad(0)|~ x ~ pad()|~ y0
observe that ~ pad()|~ x=~ pad(0)|~ x+~ x(a)and thus:
m+~ pas()|~ v+~ pad()|(~ x ~ y)~ x(a)
combining this with equations 4.8 and 4.9 yields z(r)>0. 
by combining lemma 1 and lemma 2 we can easily show that any instantiation of
zfavors minimal regions.
theorem 1 (any instantiation of zfavors minimal regions). letlbe an event log
over a set of activities aand letas;adabe a hybrid partition. let r1= (m1;
~ v1;~ x1;~ y1),r2= (m2;~ v2;~ x2;~ y2)andr3= (m1+m2;~ v1+~ v2;~ x1+~ x2;~ y1+~ y2)be
three non-trivial regions, i.e., r1;r2;r32rh
as(l). for anyz:rh
as(l)!rbeing an
instantiation of the generalized weighted objective function as deﬁned in deﬁnition 9:
z(r3)>z(r1)andz(r3)>z(r2).
proof (by composition of lemma 1 and lemma 2). by lemma 1 we know z(r3) =
z(r1) +z(r2). by lemma 2 we know that z(r1)>0,z(r2)>0andz(r3)>0.
thus we deduce z(r3)>z(r1)andz(r3)>z(r2). consequently, any instantiation
of the objective function as deﬁned in deﬁnition 9 favors minimal regions. 11
both objective functions presented, i.e. z1andzl, are expressible in terms of the more
general objective function zas presented in deﬁnition 9. as we have seen the two
objective functions may favors different regions. combining an objective function with
the ilp-formulation presented in deﬁnition 8 establishes means to ﬁnd petri net places.
however, solving one ilp only yields one solution and hence we need means to ﬁnd a
set of places, which together form a petri net that represents the input event log l.
4.2 finding several places
the most apparent technique to ﬁnd multiple places is the use of causal relations within
an event log. within the context of this paper we deﬁne a causal relation as follows.
deﬁnition 10 (causal relation). letlbe an event log over a set of activities a. a
causal relation lis a function l:aa!rwherel(a;b)denotes the causality
between activity aandbexhibited in l.
several approaches exist to compute causalities hence we refer to [6] for an overview of
the use of causalities within different process discovery approaches. as a consequence,
l(a;b)can have different meanings w.r.t. the causality between aandb. some ap-
proaches limit rng(l)tof0;1gwherel(a;b) = 1 means that there is a causal
relation between aandbwhereasl((a;b)) = 0 means there is no causal relation from
atob. other approaches map rng(l)to the real-valued domain ( 1;1)where a high
positivel(a;b)value (close to 1) indicates a strong causal relation from atoband a
low negative value (close to  1) indicates a strong causal relation from btoa.
when adopting a causal-based ilp process discovery strategy, we try to ﬁnd places
which will be added in the resulting petri net, each representing a causality found. a
ﬁrst step is to compute lvalues given some causal deﬁnition. depending on the actual
meaning of the l, whenever we ﬁnd a causal relation from atob(possibly because
l(a;b), whereis some threshold value), we enrich the constraint body for the
given causal constraint as follows:
m= 0and~ v(a) = 1 and~ v(b) = 1;ifa;b2as
m= 0and~ x(a) = 1 and~ v(b) = 1;ifa2ad;b2as
m= 0and~ v(a) = 1 and~ y(b) = 1;ifa2as;b2ad
m= 0and~ x(a) = 1 and~ y(b) = 1;ifa;b2ad
after the constraint body is enriched, we solve the ilp yielding a place having an opti-
mal value for the speciﬁc objective function chosen. we repeat the procedure for every
causal relation yielding a petri net.
5 performance
the hybrid variable-based ilp-formulation is implemented as a plug-in in the prom-
framework ( http://www.promtools.org ) [7]2. the plug-in allows the user to
2the source-code is available at https://svn.win.tue.nl/repos/prom/
packages/hybridilpminer/trunk12
specify parameters of ilp-based process discovery, e.g. several different objective func-
tions, additional constraints and causality based mining.
to test the performance of hybrid variable-based ilp process discovery we have
used the basic implementation within an experimentation framework3. the framework
allows for generating random process models and from these models generate event
logs. we have generated 40 models containing a minimum of 2 activities and a maxi-
mum of 12 activities. for each model we have generated 10 event logs, each containing
5000 traces. for each log we ran three different instantiations of the process discovery
formulation, one purely single variable-based, one hybrid variant and one purely dual
variable-based. the distribution of event classes in aoverasandadis depicted in
table 2. for the hybrid variant the size of aswas kept constant and independent of the
number of activities in a(as ofjaj3). we ran each instantiation 10 times per log
using causal relations as a process discovery strategy. for each run of an instantiation
we calculated the total time spend in solving all ilps based on the causalities present
in the event log. these times have been aggregated based on the number of activities
present in an event log. the results of the experiment, plotted on a logarithmic scale,
are depicted in figure 34.
as shown in figure 3, the average time to solve the hybrid formulation is in-between
the single and dual formulation. we additionally note the hybrid formulation to get
slightly closer to the dual formulation when jajincreases. this is as expected as the
number of single variables within the hybrid formulation is constant and hence the av-
erage time of solving the ilps within the formulation increases with respect to the single
variable formulation. figure 3 shows that reducing the number of variables used within
the ilp-formulation has an impact on the average time of solving ilps. the differences
are however marginal, which is to be expected as solving ilps is exponential by nature.
therefore the experiments show that using ilps for the aim of process discovery in
table 2: different settings used in performance measurements of the hybrid variable-
based ilp-formulation.
jaj 23456789101112
purely single variable-based variant
jasj 23456789101112
jadj 00000000000
hybrid variable-based variant
jasj 23333333333
jadj 00123456789
purely dual variable-based variant
jasj 00000000000
jadj 23456789101112
3all framework ﬁles and results can be found at https://svn.win.tue.nl/repos/
prom/packages/hybridilpminer/tags/papers/source_files/hybrid_
ilp_runtime_experiments.tar.gz
4the experiments where distributed over four servers (dell poweredge r520, intel xeon e5-
2407 v2 2.40ghz, 10m cache, 8 8gb rdimm, 1600mt/s memory), on each server a total
of 10 models and corresponding logs where generated.13
2 3 4 5 6 7 8 910 11 1210 1102105
jajavg. time of solving ilp0s(ms.)
pure single
hybrid
pure dual
fig. 3: average time in milliseconds to solve the three ilp-based process discovery
variants plotted on a logarithmic scale against the number of activities in the log.
a practical setting might need incorporation of more advanced techniques in order to
reduce the average time of solving the ilps signiﬁcantly.
6 related work
the concept of hybrid variable-based regions originates from language-based region
theory, which in turn originates from the area of petri net synthesis. we identify two
main branches of language-based region theory within petri net synthesis being the
separating regions approach [8–10] and the minimal linear basis approach [11, 12]. in
the separating regions approach, which uses single-variable based regions, behavior not
seen in a given preﬁx closed language is speciﬁed as being undesired. in the minimal
linear basis approach, given a preﬁx closed language, a polyhedral cone of integer points
is constructed based on dual variable-based regions. using the cone a minimal basis of
the set of regions is calculated which deﬁnes a minimal set of places to be synthesized.
both approaches try to minimize l(n)nl, wherenrepresents the resulting petri
net andlis a preﬁx-closed language. the approaches lead to petri nets with perfect
replay-ﬁtness. moreover precision is maximized . a side effect of this property is the
fact that the synthesized net nscores low on both the generalization and the simplicity
dimension.
in [3] a ﬁrst design of an ilp-formulation was presented based on the concept of
dual variable-based regions. the work presents objective function z1which we have
further developed in this work to zl, and more generally, z. the work also focuses on
formulation of several different net-types in terms of linear in-equalities which even go
beyond classical petri nets, e.g. reset- and inhibitor arcs.
an alternative approach is to use the concept of state-based regions for the purpose
of process discovery [13, 14]. within this approach an abstraction of the event log is
computed in the form of a transition system . regions are computed within the transition
system where, like in language-based region theory, each region corresponds to a place
in the resulting petri net.14
in [15] a process discovery algorithm is proposed based on the concept of numer-
ical abstract domains using parikh vectors as a basis. based on an event log, a preﬁx-
closed language is computed of which a convex polyhedron is approximated by means
of calculating a convex hull. the convex hull is then used to compute causalities within
the input log, by deducing a set of linear inequalities which represent places. the for-
mulation used to calculate these causalities is in essence based the concept of single
variable-based regions. the approach allows for ﬁnding pure petri nets with arc weights
and multiple marked places.
a multitude of other petri net-based process discovery approaches exist. for a de-
tailed description of these approaches we refer to [6].
7 conclusion
we presented a new breed of language-based regions, i.e. hybrid variable-based regions,
that captures the two existing region types being single and dual variable-based regions.
hybrid variable-based regions allow us to decide whether we want to use one or two
variables for an activity present in the input event log. this allows us to achieve gains
in terms of performance whilst maintaining the possibility to ﬁnd complex (workﬂow)
patterns. we have shown that within the hybrid variable-based ilp process discovery
formulation, using only one variable per activity a2aperforms optimal in terms of
the average time spent in solving the ilps constructed.
we presented a generalized weighted objective function and showed that any in-
stantiation of the objective function leads to ilps that favor minimal regions. as a
result, practitioners may vary the scaling function within the objective function under
the guarantee that the objective function favors minimal regions. we presented a log-
based scaling function that exploits trace frequencies available in the input log. using
the log based scaling function within the objective function assigns an objective value
to each region equal to the token throughput of the corresponding place, given the event
log. hence, as we have shown using the new objective function leads to more intuitive
objective values.
as an interesting direction for future work we identify the assessment of the impact
of ﬁltering, either a-priori or within the ilp itself, on the quality dimensions of the
resulting nets, i.e. are we able to leverage the perfect repaly-ﬁtness property? also,
an assessment of the impact of decomposition techniques [16] on the performance of
ilp-based approaches is an interesting direction for future work.
references
1. aalst, w.m.p.v.d.: process mining: discovery, conformance and enhancement of business
processes. 1st edn. springer publishing company, incorporated (2011)
2. desel, j., reisig, w.: the synthesis problem of petri nets. acta inf. 33(4) (1996) 297–315
3. werf, j.m.e.m.v.d., dongen, b.f.v., hurkens, c.a.j., serebrenik, a.: process discovery
using integer linear programming. fundamenta informaticae 94(3) (2009) 387–412
4. buijs, j.c.a.m., dongen, b.f.v., aalst, w.m.p.v.d.: on the role of ﬁtness, precision, gen-
eralization and simplicity in process discovery. in meersman, r., panetto, h., dillon, t.,15
rinderle-ma, s., dadam, p., zhou, x., pearson, s., ferscha, a., bergamaschi, s., cruz, i.f.,
eds.: on the move to meaningful internet systems: otm 2012. v olume 7565 of lecture
notes in computer science. springer berlin heidelberg (2012) 305–322
5. aalst, w.m.p.v.d., hofstede, a.h.m.t., kiepuszewski, b., barros, a.: workﬂow patterns.
distributed and parallel databases 14(1) (2003) 5–51
6. dongen, b.f.v., medeiros, a.k.a.d., wen, l.: process mining: overview and outlook of
petri net discovery algorithms. t. petri nets and other models of concurrency 2(2009)
225–242
7. dongen, b.f.v., medeiros, a.k.a.d., verbeek, h.m.w., weijters, a.j.m.m., aalst,
w.m.p.v.d.: the prom framework: a new era in process mining tool support. in ciardo,
g., darondeau, p., eds.: applications and theory of petri nets 2005. v olume 3536 of lec-
ture notes in computer science. springer berlin heidelberg (2005) 444–454
8. badouel, e., bernardinello, l., darondeau, p.: polynomial algorithms for the synthesis of
bounded nets. in mosses, p.d., nielsen, m., schwartzbach, m.i., eds.: tapsoft ’95: theory
and practice of software development. v olume 915 of lecture notes in computer science.
springer berlin heidelberg (1995) 364–378
9. badouel, e., darondeau, p.: theory of regions. in reisig, w., rozenberg, g., eds.: lectures
on petri nets i: basic models. v olume 1491 of lecture notes in computer science. springer
berlin heidelberg (1998) 529–586
10. darondeau, p.: deriving unbounded petri nets from formal languages. in sangiorgi, d.,
simone, r.d., eds.: concur’98 concurrency theory. v olume 1466 of lecture notes in
computer science. springer berlin heidelberg (1998) 533–548
11. bergenthum, r., desel, j., lorenz, r., mauser, s.: process mining based on regions of
languages. in alonso, g., dadam, p., rosemann, m., eds.: business process management.
v olume 4714 of lecture notes in computer science. springer berlin heidelberg (2007)
375–383
12. lorenz, r., mauser, s., juhas, g.: how to synthesize nets from languages - a survey. in:
simulation conference, 2007 winter. (dec 2007) 637–647
13. sol ´e, m., carmona, j.: process mining from a basis of state regions. in: applications and
theory of petri nets, 31st international conference, petri nets 2010, braga, portugal,
june 21-25, 2010. proceedings. (2010) 226–245
14. aalst, w.m.p.v.d., rubin, v ., verbeek, h.m.w., dongen, b.f.v., kindler, e., g ¨unther, c.w.:
process mining: a two-step approach to balance between underﬁtting and overﬁtting. soft-
ware and system modeling 9(1) (2010) 87–111
15. carmona, j., cortadella, j.: process discovery algorithms using numerical abstract domains.
ieee trans. knowl. data eng. 26(12) (2014) 3064–3076
16. aalst, w.m.p.v.d.: decomposing petri nets for process mining: a generic approach. dis-
tributed and parallel databases 31(4) (2013) 471–507