ontology-driven extraction of event logs
from relational databases
diego calvanese1, marco montali1, alifah syamsiyah1?, wil m.p. van der aalst2
1free university of bozen-bolzano, italy
{calvanese,montali}@inf.unibz.it,
alifah.syamsiyah@stud-inf.unibz.it
2eindhoven university of technology, the netherlands
w.m.p.v.d.aalst@tue.nl
abstract. process mining is an emerging discipline whose aim is to discover,
monitor and improve real processes by extracting knowledge from event logs
representing actual process executions in a given organizational setting. in this
light, it can be applied only if faithful event logs, adhering to accepted standards
(such as xes), are available. in many real-world settings, though, such event
logs are not explicitly given, but are instead implicitly represented inside legacy
information systems of organizations, which are typically managed through rela-
tional technology. in this work, we devise a novel framework that supports domain
experts in the extraction of xes event log information from legacy relational
databases, and consequently enables the application of standard process mining
tools on such data. differently from previous work, the extraction is driven by a
conceptual representation of the domain of interest in terms of an ontology. on
the one hand, this ontology is linked to the underlying legacy data leveraging
the well-established ontology-based data access (obda) paradigm. on the other
hand, our framework allows one to enrich the ontology through user-oriented log
extraction annotations , which can be ﬂexibly used to provide different log-oriented
views over the data. different data access modes are then devised so as to view
the legacy data through the lens of xes.
keywords: multi-perspective process mining, log extraction, ontology-based data ac-
cess, event data
1 introduction
process mining aims to discover, monitor and improve real processes by extracting
knowledge from event logs readily available in today’s information systems [ 13]. dozens
(if not hundreds) of process-mining techniques are available and their value has been
proven in various case studies [ 9]. process mining techniques can be used to discover the
real process, to detect deviations from some normative process, to analyze bottlenecks
and waste, and to predict ﬂow times [ 13]. normally, “ﬂat” event logs serve as the starting
point for process mining [ 13,14]. these logs are created with a particular process and
a set of questions in mind. an event log can be viewed as a multiset of traces . each
trace describes the life-cycle of a particular case (i.e., a process instance ) in terms of
?alifah syamsiyah was supported by the european master’s program in computational logic2 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
case id timestamp activity resource cost
654423 30-04-2014:11.02 register request john 300
654423 30-04-2014:11.06 check completeness of documents ann 400
655526 30-04-2014:16.10 register request john 200
654423 30-04-2014:11.18 prepare decision pete 400
  
table 1: a fragment of an event log: each line corresponds to an event
theactivities executed. often event logs store additional information about events. e.g.,
many process-mining techniques use extra information such as the resource (i.e., person
or device) executing or initiating the activity, the timestamp of the event, or data elements
recorded with the event (e.g., the size of an order). table 1 shows a small fragment of a
larger event log. each row corresponds to an event. the events refer to two cases (654423
and 655526) and have additional properties, e.g., the registration for case 654423 was
done by john at 11:02 on 30 april 2014 and the cost was 300 e. an event may also
contain transactional information, i.e., it may refer to an “assign”, “start”, “complete”,
“suspend”, “resume”, “abort”, etc. action. for example, to measure the duration of an
activity it is important to have a start event and a complete event. we refer to the xes
standard [10] for more information on the data possibly available in event logs. see [ 14]
for logging guidelines and details on getting event data from databases using redo logs.
it is apparent that a condition sine qua non for the application of process mining
is the availability of faithful event logs, adhering to accepted standards (such as xes)
and guaranteeing a certain quality level [ 15]. in many real-world settings, though, such
event logs are not explicitly given, but are instead implicitly represented inside legacy
information systems of organizations, which are typically managed through relational
technology. this calls for the need of suitable methodologies, techniques and tools for
extracting event logs from relational databases . this problem is extremely challenging,
as pointed out in chapter 4 of [ 13], which overviews the different problems encountered
when extracting event data. on the one hand, this extraction process spans across several
levels of abstractions: from the high-level, namely the domain-independent notions
which are characterized at the conceptual level by the so-called domain ontology , and
coming down to the concrete level at which data are effectively stored. on the other
hand, there is no such a notion of “single” event log, but multiple event logs can be
obtained by focusing on the dynamics of different domain entities. for example, in many
applications there is not a single instance (case) notion. this is addressed in the context
ofartifact-centric process mining [5].1various tools for event log extraction have been
proposed, e.g., xesame [ 16] and promimport [ 8]. moreover, commercial tools like
disco make it easy to convert a csv or excel ﬁle into a xes log. in [ 14] it is shown
how event data can be extracted from the redo-logs of a database. however, none of
the tools and approaches actually puts the domain ontology in the loop. as a result, the
extraction is often ad-hoc, data is duplicated for different views, and the semantics of the
resulting event log cannot be traced back. furthermore, the extraction cannot be driven
by experts of the domain who do not have any technical knowledge about the underlying
information systems and concrete storage mechanisms. some work has been done on
1cf. also the eu acsi project: www.acsi-project.euontology-driven extraction of event logs from relational databases 3
semantically annotated event logs [4]. however, these approaches do not consider the
extraction of event data. their focus is on exploiting ontological information during
analysis.
in this work, we overcome these issues by proposing a novel framework that supports
domain experts in the extraction of xes event log information from legacy relational
databases, and consequently enables the application of standard process mining tools
on such data. differently from previous work, the extraction is driven by a conceptual
representation of the domain of interest in terms of an ontology. this ontology is linked
to the underlying legacy data leveraging the well-established ontology-based data access
(obda) paradigm [ 11,1]. in this way, domain experts can focus on the ontological
level only, while the connection with the underlying data is automatically managed by
the obda system. notably, after more than a decade of foundational investigation [ 3],
obda systems relying on lightweight description logics [ 1] are now subject to extensive
implementation efforts [ 2,12], so as to make them able to manage huge amounts of
data [ 7]. to leverage obda in the context of event log data extraction and access,
our framework allows one to enrich the ontology through user-oriented log extraction
annotations , which can be ﬂexibly used to provide different log-oriented views over the
data. once these annotations are speciﬁed, we show how it is possible to automatically
construct a direct link from the raw relational data sources to a general-purpose ontology
that captures the xes standard. this, in turn, provides the basis for the process mining
algorithms to extract this information either by materializing it explicitly, or by accessing
it on-demand. the framework has been implemented in a prototype prom2plug-in that
relies on the state-of-the-art obda system ontop3. the full code with a tutorial and
examples, is available at http://tinyurl.com/op6y82s .
2 problem overview
to describe the problem we want to attack and introduce the main technical challenges
towards its solution, we informally discuss a real-world example. john, the owner of a
conference submission web portal, is interested in applying process mining techniques
on the historical system data. his goal is to better understand how the different users of
the system actually use it, and consequently take strategic decisions on how to restructure
the portal and improve its functionalities.
as it is typical in contemporary organizations, the relevant knowledge used by john
and the other members of his company to understand the application domain, is captured
through a conceptual schema (such as a uml class diagram). we call such a schema
adomain ontology . this ontology provides a high-level, shared conceptual view of
the domain. in john’s case, it contains the relevant concepts and relations that must
be captured in order to manage a conference. a fragment of this knowledge is shown
in figure 1 (for the moment, we ignore the colored annotations). however, the actual
data are not maintained at this level of abstraction, but are instead stored inside an
underlying relational information system. figure 2 provides the excerpt of a possible
relational database keeping track of papers and authors. at this level, data are hardly
understandable by john. first, the vocabulary and the organization of the data radically
2http://www.processmining.org/prom/start
3http://ontop.inf.unibz.it/4 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
1..**conferencecreation time:datetimereview requestinvitation time:datetimereviewsubmission time:datetimedecisiondecision time:datetimeoutcome: boolupload time:datetime
upload acceptedupload time:datetimesubmitted to1*organized byaccepted paper<<no time>>*reviewer
1110..1corresponds to*uhasp1*ahasu1*1forauthor1..**
by1usupload byucreator1*1*
uaupload byu1
*upload submittedpapercreation time:datetimeusercreation time:datetime
*phasd1*rhasr11eventtrace:activity:time:res.:type:follow uhasp“submit paper”upload timefollow usupload byucomplete
eventtrace:activity:time:res.:type:follow ahasu & corresponds to“submit ﬁnal paper”upload timefollow upload bycompleteeventtrace:activity:time:res.:type:follow has & for“get review”submission timefollow rhasr & reviewercompletetracesubmitted to = “bpm 2015”eventtrace:activity:time:res.:type:attrs.:follow has“decision”decision timefollow bycompleteoutcome
fig. 1. domain ontology of the conference submission portal in uml, with annotations to track
the dynamics of bpm 2015 papers
login
id user
5 alifah
6 marco
2 diego
3 willogin stats
user ct lastaccess
5 15.10.14 15.03.15
6 17.10.14 20.03.15
2 18.10.14 20.03.15
3 18.10.14 18.03.15pub
id title ct user conf type status
151 mining 09.11.14 5 5 fp r01
127 monitoring 10.02.15 3 32 sp a03
945 obda 13.03.15 2 21 fp s02
724 bpm 15.03.15 3 56 fm a02
fig. 2. excerpt of a possible instance of the conference submission information system
depart from that of the domain ontology, due to design and implementation choices made
by the it staff of the company. second, internal codes with an implicit semantics are
employed, like in the status column of the pub table (which tracks whether a publication
has been submitted, reviewed, accepted, . . . ) or in the type column of the same table
(which tracks whether the publication is a full/short paper, a front matter, or other).
this so-called impedance mismatch is a challenging problem that has been thorougly
investigated in the ﬁeld of intelligent data access and integration [11].
when john wants to apply process mining techniques on this complex information
system, he does not only face the impedance mismatch problem, but also the equally
challenging problem of “process-orientation”: the underlying data must be understood
through a conceptual lens that is different from the domain ontology, and that focuses on
the process-related notions of trace, event, resource, timestamp, and so on. in other words,
john needs to extract an event log that explicitly represents the dynamics john wants
to analyze. in this paper, we consider xes as the reference standard for representing
event logs. this problem becomes even more diffcult if one considers that, in general,
a plethora of different event logs may be extracted from the same data, by changing
perspective and by focusing on the evolution of different entities. for example, john
could decide to analyze his data by following the submission and review of papers within
or across conferences, or he could focus on users and the operations they execute to
submit and review papers.
in this light, supporting john requires to solve three technical problems: 1. how
can john overcomes the impedance mismatch between the domain ontology and the
underlying data? 2. how can john captures the connection of the domain ontology andontology-driven extraction of event logs from relational databases 5
1..**conferencecreation time:datetimereview requestinvitation time:datetimereviewsubmission time:datetimedecisiondecision time:datetimeoutcome: boolupload time:datetime
upload acceptedupload time:datetimesubmitted to1*organized byaccepted paper<<no time>>*reviewer
1110..1corresponds to*uhasp1*ahasu1*1forauthor1..**
by1usupload byucreator1*1*
uaupload byu1
*upload submittedpapercreation time:datetimeusercreation time:datetime
*phasd1*rhasr11
eventtrace:activity:time:resource:type:follow phasd & author“decision author”decision timefollow phasdcompleteeventtrace:activity:time:resource:type:attributes:follow by“decision chair”decision timefollow phasdcompleteoutcomeeventtrace:activity:time:resource:type:follow rhasr & reviewer“get review”submission timefollow rhasr & forcompleteeventtrace:activity:time:resource:type:follow usupload byu“submit paper”upload timefollow hascompletetrace
fig. 3. domain ontology annotations to track the dynamics of users
the representation of an event log, depending on the dynamics he wants to track? 3. how
can john ﬁnally obtains a view of the low-level data in terms of a corresponding event
log? in this work, we tackle this overarching problem by resorting to a novel combination
of techniques coming from intelligent data access and integration, extended and adapted
to the case of process mining and ﬂexible extraction of multi-dimensional event logs
from raw relational data. to attack the ﬁrst problem, we resort to the well-established
obda framework, which allows one to link the raw data to the domain ontology and
overcome the impedance mismatch [ 11,1]. to tackle the second challenge, we deﬁne an
event log ontology that mirrors xes, and provide an annotation language to the user,
which makes it possible to capture semantic links between the constitutive (combinations
of) elements in the domain ontology, and corresponding elements in xes. john could
employ this annotation language to enrich the domain ontology of figure 1, ultimately
producing the two schemas illustrated in figure 1 itself and in figure 3. in particular,
figure 1 declares that each trace is related to the evolution of a single paper submitted to
the bpm 2015 conference, and that meaningful events in a trace are paper submissions,
reviews, ﬁnal decisions, and upload of the camera-ready version. figure 3 declares
instead that each trace tracks the operations of a user, and that meaningful operations
are paper submissions, reviews, and ﬁnal decisions (to be listed both in the trace of the
person chair who took the decision, and the paper creator who received it). the third
problem is ﬁnally solved by automatically establishing a direct bridge from the low-level
relational data to the event log ontology, in a way that is completely transparent to the
user. the user can then access the event log with different modalities, and apply process
mining without knowing how traces, events, and attributes are concretely stored in the
underlying information system.
3 preliminaries
we introduce some necessary background material, namely the description logic (dl)
dl-liteaand the ontology-based data access (obda) framework. to capture domain
ontologies, we use the dl-litealanguage [ 1]. this allows for specifying concepts ,6 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
representing sets of (abstract) objects, roles , representing binary relations between
objects, and attributes , representing binary relations between objects and (domain)
values. the syntax of concept expressions (b) and role expressions (r) indl-liteais:
b !nj 9rj(u)r !pjp 
here,n,p, andurespectively denote a concept name , arole name , and an attribute
name , andp denotes the inverse of rolep. the concept9r, also called unqualiﬁed
existential restriction , denotes the domain of a roler, i.e., the set of objects that r
relates to some object. notice that 9p actually denotes the range of rolep. similarly,
the concept(u)denotes the domain of an attribute u.
adl-liteaontology is a pair (t;a), wheretis a tbox, i.e., a ﬁnite set of tbox
assertions , andais an abox, i.e., a ﬁnite set of abox assertions .dl-liteatbox
assertions have the following form:
b1vb2
b1v:b2r1vr2
r1v:r2u1vu2
u1v:u2(functr)
(functu)
in the ﬁrst three columns, assertions of the ﬁrst row denote inclusions between concepts,
roles, and attributes, respectively; assertions of the second row denote disjointness .
assertions of the last column denote functionality on roles and attributes, i.e., that every
object in the domain of r=u is related via r=u to at most one other object/value.
dl-liteaabox assertions are used to express extensional knowledge about speciﬁc
objects and values in the domain of interest. they have the form n(t),p(t;t0), or
u(t;v), wheretandt0denote individual objects and vdenotes a value.
the semantics of dl-liteais given in [ 1]. interestingly, dl-liteatboxes are
suitable to formally capture the semantics of uml class diagrams (with the exception of
covering constraints in a class hierarchy) [ 1]. consequently, whenever we talk about a
dl-liteadomain ontology, we can always imagine that the intensional knowledge of
such an ontology can be modelled and graphically rendered in uml.
example 1. letpaper anduser bedl-liteaconcepts, creator andauthor roles, and pct
anduct attributes (corresponding to the creation time of a paper and of a user respectively). the
following dl-liteatbox captures a portion of the uml domain ontology shown in figure 1:
9creatorvpaper
9creator vuser
paperv9creator
(funct creator )9authorvpaper
9author vuser
paperv9author(pct )vpaper
paperv(pct )
(uct )vuser
userv(uct )
the ﬁrst column captures the semantics of the creator uml association, where the ﬁrst two rows
capture the typing of the association, the third row the fact that every paper must have a creator,
and the fourth that every paper has at most one creator. collectively, the last two assertions capture
the1cardinality of the association from the perspective of the paper class. the second column
captures the semantics of the author uml association. the third column instead deals with the
creation time attributes for papers and users.
to interact with the domain ontology, we make use of queries . as typical in dls,
toquery adl-liteaontology we make use of conjunctive queries (cqs) and union
thereof (ucqs). cqs are ﬁrst-order queries that corresponds to the well-known spjontology-driven extraction of event logs from relational databases 7
(select-project-join) queries in sql. syntactically, we specify ucqs using sparql,
the standard ontology query language for the semantic web.
ontology-based data access. in an obda system, a relational database is connected
to an ontology that represents the domain of interest by a mapping, which explicitly
accounts for the impedance mismatch by relating database values with values and
(abstract) objects in the ontology (c.f. [1]).
technically, we consider a countably inﬁnite set vof values and a set of function
symbols, each with an associated arity. intuitively, function symbols are used to construct
an abstract object in the ontology from a combination of values in the underlying database.
we also deﬁne the set cof constants as the union of vand the setff(d1;:::;dn)jf2
andd1;:::;dn2vg ofobject terms .
formally, an obda system is a structure o=hr;t;mi, where: (i)r=
fr1;:::;rngis a database schema, constituted by a ﬁnite set of relation schemas;
(ii)tis adl-liteatbox; (iii)mis a set of mapping assertions, each of the form
(~ x) 	(~ y;~t), where: (a)~ xis a non-empty set of variables, (b) ~ y~ x, (c)~tis a set of
object terms of the form f(~ z), withf2and~ z~ x, (d)(~ x)is an arbitrary sql query
overr, with~ xas output variables, and (e) 	(~ y;~t)is a set of atoms over the variables
~ yand the object terms ~t, whose predicate symbols are atomic concepts, atomic roles,
and attributes oft. without loss of generality, we use the special symbol val=1to map
values from the relational layer to the range of attributes in the semantic layer.
each mapping assertion creates a link between the database and the ontology, ex-
pressing how instances of the involved concepts/roles are obtained from the answers of
queries posed over the database. we ground this deﬁnition to our running example.
example 2. consider an obda framework devised to link the database shown in figure 2 to the
ontology in figure 1. suitable mapping assertions must be devised so as to interconnect these two
information layers. we consider the deﬁnition of user andpaper , with their creation times. one
could argue that a paper can be extracted from the pubtable, by considering only those entries that
have type fporsp(respectively denoting full and short papers). this is captured by the following
mapping assertion ( p=1constructs a publication object from its identiﬁer in the database):
select id;ctfrom pubwhere ct=’fp’ or ct=’sp’
 fpaper (p(id));pct (p(id);val(ct))g
a user and his/her system creation time are extracted by joining login andlogin stats tables:
select l:user;s:ctfrom login l;login stats swhere l:id=s:user
 fuser (u(l:user ));pct (u(l:user );val(s:ct))g
where u=1constructs a user object from its username in the database.
a ucqqover an obda system o=hr;t;mi is simply a ucq over t. to
compute the answers of qoverowrt a database instance doverr, two approaches
can be followed. in the ﬁrst approach, which we call materialization , query answering
consists of two steps. in the ﬁrst step, an abox is explicitly materialized starting from
dand by applying the mapping assertions in a forward way. in particular, the abox
generated from dby a mapping assertion m=(x) 	(y;t)inmism(d) =s
v2eval (;d )	[x=v], where eval(;d)denotes the evaluation of the sql query over
d. then, the abox generated from dby the mappingmism(d) =s
m2mm(d).
in the second step, the query is posed directly over the domain ontology ht;m(d)i.8 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
extensionxes.version: xs:decimalxes.features: xs:token…logtraceevent1lcontaintst*1tcontainse*econtainsa1tcontainsalcontainsa*acontainsaedeclaresl*1edeclaresa10..1preﬁx: xs:stringuri: xs:stringkey: xs:stringtype: xs:stringscope: {event, trace}global attributeclassiﬁername: xs:stringkeys: xs:string1edeﬁnesc1..*cdeﬁnesg1..*attributekey: xs:stringvalue: xs:stringtype: xs:string1..*111**1*
fig. 4. general event ontology
in the second approach, which we call on-demand , the data are kept in dand no
further information is explicitly materialized. instead, the input query qis subject to
a multi-step reformulation approach, which: (i)compiles awayt;(ii)unfolds the
components of the obtained query by applying m. this produces a corresponding sql
query that can be posed directly over the underlying database [ 11]. the answers are then
computed and returned in the form of ontological objects. notably, the two approaches
yield the same answer, and can be therefore be interchangeably applied.
4 log extraction framework
our log extraction process is organized in two phases:
1.thedesign phase , in which a domain expert speciﬁes how to view the domain
ontology using the lens of an event ontology for xes;
2.thedata access phase , in which the result of the ﬁrst phase is applied over actual
data, so as to obtain a corresponding event log that is then accessed by domain
experts or process mining algorithms.
in this section, we focus on the design phase. data access is discussed in section 5.
the purpose of the design phase is to support a domain expert in the annotation of a
domain tbox given as input, so as to properly link it to the event ontology that captures
xes. notice that the domain expert is not required, in this phase, to employ actual data,
nor to have any speciﬁc knowledge about how such data are stored inside the company
information system.
speciﬁcally, we discuss how xes has been modeled as a dl-liteatbox, and then
focus on the language and modeling language to annotate the domain tbox, implicitly
establishing a link with the xes tbox.
the xes event log tbox. we carefully analyzed the documentation of xes [ 10],
and consequently derived the dl-liteatboxx, rendered in figure 4 as a uml class
diagram. this tbox is ﬁxed once and for all in our framework, and does not depend on
the modeled domain. beside the standard xes elements of trace ,event , andattribute ,
we also consider the following sandard extensions: (i)concept extension (to assign a
name to events); (ii)time extension (to assign a timestamp to events); (iii)lifecycle
extension (to link the event type to the xes transactional model); (iv)(optionally)
organizational extension (to link an event to its responsible resource).
annotations. annotations are deﬁned by a domain expert to link a domain-speciﬁc
dl-liteatboxtto the generic xes tbox x. intuitively, they take the form re-ontology-driven extraction of event logs from relational databases 9
ported in figures 1 and 3. technically, a log annotation overt, writtenlt, is
a pairhtr(t;l);ei, wheretr(t;l)is a trace annotation , i.e., a sparql query
expressing how to extract traces (and their corresponding log) from t, ande
is a set of event-attribute annotations . each event-attribute annotation is a tuple
hev(~ e;t);ts(ts;~ e);n(n;~ e);[1
a(v1;a1;c1;~ e);:::;k
a(vk;ak;ck;~ e)]iof sparql
queries overt, where: (i)queryev(~ e;t)is an event annotation , i.e., a sparql
query extracting events from t, together with the trace they belong to; (ii)queries
ts(ts;~ e)andn(n;~ e)bind events to the two mandatory attributes of timestamp and
activity name (and are consequently called timestamp andname annotations );(iii)each
queryi
a(vi;ai;ci;~ e)(withi2f1;:::;kg) is an attribute annotation that extracts
the value(s) viof an attribute of type aiand with key ci, binding it/them to event ~ e.
attribute annotations are optional. among all possible attributes, they can be used to
extract the responsible resource for an event, or its transactional lifecycle type (cf. the
xes organizational andlifecycle extensions). obviously, different guidelines and
constraints apply to the different queries in lt. we discuss this issue in the following.
note that each query in ltis centred around a concept/role/attribute of t. hence, it
is straightforward to ideally “attach” an annotation to the corresponding element in t.
trace annotations. a trace focuses on the evolution of an entity/object over time. in
figure 1, the focus is on the evolution of papers, whereas in figure 3 it is on users.
in general, a trace can be annotated only by selecting a concept in t, possibly adding
further conditions on which members of such concept give raise to a trace. technically,
this means that in tr(t;l),tmust be bound to a concept of t. for example, the trace
annotation in figure 1 can be formalized as:
select ?t "bpm15-papers-log"
where {?t a:paper; :submittedto ?conf.
?conf a:conference. filter regex(?conf,"bpm 2015","i").}
where "bpm15-papers-log" identiﬁes the log lwe are constructing.
event annotations. event annotations differ from trace annotations in two respects.
first of all, any element of tmay be subject of an event annotation: not only concepts,
but also relations and attributes. the arity of the corresponding sparql query then
depends on which element is targeted: if it is a concept, than a single event variable will
be used; it if is a relation or an attribute, two variables will be employed, matching with
the involved subject and object. second, to be a valid target, such an element must be
“timed”, i.e., either directly or undirectly univocally associated to exactly one timestamp
attribute, and have a unique name. to check whether this property is guaranteed or not,
one could pose its corresponding sparql query over the input obda system, and
verify that, for each event, exactly one timestamp and one name is returned. by referring
again to figure 1, the indication that a submission upload is an event is captured by:
select ?e ?t where {?e a:uploadsubmitted; :has? t. ?t a:paper.}
note that event annotations always have event and trace variables as distinguished
variables, establishing a correspondence between the returned events and their traces.
also notice that a single variable is used for the event, since it is extracted from a concept.
timestamp and name annotations. we consider two mandatory attributes: a times-
tamp and an activity name. both of them are distinguished variables in the sparql
query together with its event. as pointed out before, each event is required to be asso-
ciated with exactly one timestamp and exactly one name. obviously, in general many10 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
different possibilities exist. for example, in figure 1 it is apparent that the submission
time associated to a submission upload may be the upload time of the upload itself, or
the creation time borrowed either from user by navigating the uploadby relation, or
from paper by navigating the hasrelation. as for the activity name, the most typical
situation is the one in which the name is directly bound to an explicitly speciﬁed string.
however, in general one could construct such a name by navigating through tand even
composing the name by concatenating together strings and query results. as for the
timestamp, three annotation patterns typically emerge. we discuss each of them.
1. concept with single timestamp . the timestamp attests that the concept is directly
timed, and therefore the concept itself is marked as an event. this is the case, e.g., for
the submission upload in figure 1.
2. concept with pre-deﬁned multiple timestamps . this pattern emerges whenever there
are objects that ﬂow through different “phases” over time. for example, a cart may be
associated to a pre-deﬁned set of timestamps, such as the creation time, the ﬁnalization
time, and the payment time. each of such timestamps represent a speciﬁc phase transition,
and some of such timestamps may be null (this is the case, e.g., for a cart that has been
created but not ﬁnalized). each phase transition could be singled out as a relevant event,
by annotating the corresponding timestamp attribute.
3. variable crud timestamps . this situation arises whenever a certain concept/relation
is subject to many different operations over time, whose number is not known a priori.
for example, objects may have create ,read,update ,delete actions related to them, and
there can be any number of actions related to the same object, e.g., multiple updates.
similarly, there may also be create anddelete actions for relations. if we imagine to
have an “operation table”, containing the different operation types and the corresponding
object identiﬁers (each denoting the object over which an operation is applied), then
such a table will be annotated as an event, whose name depends on the operation type.
optional attribute annotations. optional attributes are annotated by using speciﬁc
sparql queries having, as distinguished variables: (i)the attribute type, (ii)its key,
(iii)its value, (iv)the variables of the corresponding event.
5 xes log extraction and access
in section 4, we have shown how a domain expert can annotate a domain dl-liteatbox
so as to express how to conceptually identify traces, events and their attributes starting
from the domain concepts, relations and attributes. we now show how such annotations
can be employed so as to make the framework operational. we assume to have, as input,
not only a domain tbox, but also an entire obda system, previously prepared to link
the domain tbox with the corresponding underlying relational database. this process is
completely independent from process mining-related interests. hence, the overall input
for our log extraction framework is an obda system o=hr;t;mi. after the design
phase, we also have a log annotation ltfort. to make the framework operational and
effectively get the data contained in a concrete instance dof the company database r,
we proceed in two steps: (i)the annotations are used to automatically create a new
obda system that links the company database rto the xes tboxx, according to
the semantics of annotations in lt.(ii)this obda system is exploited to access the
concrete data in dthrough the conceptual lens of x, following the materialization orontology-driven extraction of event logs from relational databases 11
the on-demand paradigm (cf. section 3). we focus on both aspects, discussing how
they have been implemented using prom as process mining infrastructre, openxes as
reference implementation for xes, and ontop for obda.
automatic generation of schema-to-xes mapping assertions. given an obda
systemo=hr;t;miand a log annotation ltfort, we automatically construct a
new obda system olog=hr;x;mlogithat directly links schema rto the xes tbox
x. this is done by iterating through the annotations present in lt, and by transforming
each annotation into a corresponding mapping assertion in mlog. intuitively, this is
done as follow. let (~ x)be the sparql query associated to one of the annotations
inlt. we ﬁrst reformulate (~ x)as a corresponding sql query q(~ x)directly posed
overr. we then construct a mapping assertion of the form q(~ x) 	(~ y;~t), where	
is a set of atoms over x, built according to the semantics of the annotation. since we
have 5 kinds of annotations (for trace, event, event timestamp, event activity name, event
attributes), 5 corresponding translation rules must be provided do as to generate such
mapping assertions. as an example, we consider the case of the trace annotation tr(t;l)
inlt. the corresponding mapping assertion to be inserted in mlogis:
q(t;l) 8
<
:lcontainst (log(l);tr(t));tcontainsa (tr(t);attr(t));
keyattribute (attr(t);"concept:name" );
value attribute (attr(t);t);typeattribute (attr(t);"literal" )9
=
;
whereq(t;l)is the sql query corresponding to tr(t;l), and speciﬁc unary function
symbols are used to contruct the abstract objects of log, trace, and attribute, out from the
ﬂat values for tandl. the ﬁrst line deﬁnes the relationships between the log log(l)and
the trace tr(t), as well as between tr(t)and an attribute generated for it. note that there
is no need to explicitly assert the concepts to which these three objects belong, as all
relations are typed in x. the features of the trace attribute are ﬁxed in the second and
third line, which model that value tis a literal that constitutes the name of tr(t).
data access. once the obda system hr;x;mlogihas been obtained, the data con-
tained inr(dhenceforth) can be “viewed” and accessed through the lens of the xes
ontologyxthanks tomlog. we support in particular two access modes, which have
been effectively implemented. the ﬁrst mode is the xes log materialization mode,
and consists in concretely materializing the actual event log in the form of the abox
mlog(d), using ontology-based data access procedure. this abox is then automati-
cally serialized into an xml ﬁle that is fully compliant with the xes standard. multiple
xes logs can be seamlessly obtained by just changing the annotations. this mode has
been implemented as a prom 6 plug-in. it currently supports only a textual speciﬁcation
of the ontology and the annotations, but we are working on a gui that exposes the
domain tbox as a uml class diagram, and allows the user to visually annotate it.
the second mode is the on-demand access . with this approach, do not use mlogto
concretely materialize the log, but we maintain the data in d, and reformulate queries
posed overxas sql queries directly posed over d. in this light, the xes log only
“virtually” exists: no redundant copy of the data is created, and log-related information is
directly fetched from d. since the caller does not perceive any difference when adopting
this strategy or the other one, process mining algorithms can seamlessly exploit both
techniques without changing a line of code. this mode has been realized by providing
a new implementation of the openxes interface, used to access xes logs from ja v a.
the implementation combines the on-demand obda approach with the well known12 d. calvanese, m. montali, a. syamsiyah, w.m.p. van der aalst
design pattern of lazy loading [6], which intutively indicates to defer the initialization
of an object to when it is needed. in particular, the ja v a side does not really maintain
in memory the whole log, but when a portion of the log is needed by the requester, it is
lazily constructed by issuing a query to the underlying database.
6 conclusions
we have proposed a novel methodology and technology to ﬂexibly extract event logs
from legacy, relational data sources, by leveraging the ontology-based data access
paradigm. this is especially useful for multi-perspective process mining, since event logs
reﬂecting different views of the same data can be obtained by just changing the ontology
annotations. our framework enables the materialization of event logs from legacy data, or
the possibility of maintaining logs virtual and fetch log-related information on-demand.
we are currently following three lines of research: (i)application of the framework
to real-world case studies; (ii)improvement of the framework with visuali interfaces;
(iii)benchmarking of the different data access strategies.
references
1.d. calvanese, g. de giacomo, d. lembo, m. lenzerini, a. poggi, m. rodríguez-muro, and
r. rosati. ontologies and databases: the dl-lite approach. in proc. of rw . springer, 2009.
2.d. calvanese, g. de giacomo, d. lembo, m. lenzerini, a. poggi, m. rodriguez-muro,
r. rosati, m. ruzzi, and d.f. savo. the mastro system for ontology-based data access.
semantic web j. , 2(1), 2011.
3.d. calvanese, g. de giacomo, d. lembo, m. lenzerini, and r. rosati. dl-lite : tractable
description logics for ontologies. in proc. of aaai , 2005.
4.a.k. alves de medeiros, w.m.p. van der aalst, and c. pedrinaci. semantic process mining
tools: core building blocks. in proc. of ecis , 2008.
5.d. fahland, m. de leoni, b. van dongen, and w.m.p. van der aalst. many-to-many: some
observations on interactions in artifact choreographies. in proc. of zeus , 2011.
6. m. fowler. patterns of enterprise application architecture . addison-wesley, 2003.
7. m. giese et al. scalable end-user access to big data. in big data computing . crc, 2013.
8.c. günther and w.m.p. van der aalst. a generic import framework for process event logs. in
proc. of bpi at bpm . springer, 2006.
9.ieee task force on process mining. process mining case studies. http://tinyurl.
com/ovedwx4 , 2013.
10.ieee task force on process mining. xes standard deﬁnition. http://www.
xes-standard.org/ , 2013.
11.a. poggi, d. lembo, d. calvanese, g. de giacomo, m. lenzerini, and r. rosati. linking
data to ontologies. j. on data semantics , 2008.
12.m. rodriguez-muro, r. kontchakov, and m. zakharyaschev. ontology-based data access:
ontop of databases. in proc. of iswc . springer, 2013.
13.w.m.p. van der aalst. process mining: discovery, conformance and enhancement of business
processes . springer, 2011.
14.w.m.p. van der aalst. extracting event data from databases to unleash process mining. in
proc. of bpm . springer, 2015.
15.w.m.p. van der aalst et al. process mining manifesto. in proc. of workshops at bpm .
springer, 2012.
16.h.m.w. verbeek, j.c.a.m. buijs, b.f. van dongen, and w.m.p. van der aalst. xes, xesame,
and prom 6. in information systems evolution . springer, 2010.