knowl inf syst
doi 10.1007/s10115-017-1060-2
regular paper
event stream-based process discovery using abstract
representations
sebastiaan j. van zelst1·boudewijn f. van dongen1·
w i lm .p .v a nd e ra a l s t1
received: 20 july 2016 / accepted: 27 april 2017
© the author(s) 2017. this article is an open access publication
abstract the aim of process discovery, originating from the area of process mining, is to
discover a process model based on business process execution data. a majority of process
discovery techniques relies on an event log as an input. an event log is a static source of
historical data capturing the execution of a business process. in this paper, we focus on process
discovery relying on online streams of business process execution events. learning process
models from event streams poses both challenges and opportunities, i.e. we need to handle
unlimited amounts of data using ﬁnite memory and, preferably, constant time. we propose
a generic architecture that allows for adopting several classes of existing process discovery
techniques in context of event streams. moreover, we provide several instantiations of the
architecture, accompanied by implementations in the process mining toolkit prom ( http://
promtools.org ). using these instantiations, we evaluate several dimensions of stream-based
process discovery. the evaluation shows that the proposed architecture allows us to lift
process discovery to the streaming domain.
keywords process mining ·process discovery ·event streams ·abstract representations
1 introduction
process mining [1] aims at understanding and improving business processes. the ﬁeld con-
sists of three main branches, i.e. process discovery ,conformance checking and process
enhancement . process discovery aims at discovering a process model based on event data.
b sebastiaan j. van zelst
s.j.v.zelst@tue.nl
boudewijn f. van dongen
b.f.v.dongen@tue.nl
wil m. p . van der aalst
w.m.p.v.d.aalst@tue.nl
1department of mathematics and computer science, eindhoven university of technology,
p .o. box 513, 5600 mb eindhoven, the netherlands
123s. j. van zelst et al.
conformance checking is concerned with assessing whether a process model and event data
conform to each other in terms of possible behaviour. process enhancement is concerned withimprovement of process models based on knowledge gained from event data, e.g. a processmodel is extended with performance diagnostics based on event data.
several process discovery algorithms exist [ 2–7]. these algorithms all use an event log
as an input. an event log is a static data source describing sequences of executed businessprocess activities recorded over a historical time span. as the number of events recorded foroperational processes is growing tremendously every year, so does the average event log size.conventional process discovery techniques are not able to cope with such large data sets, i.e.they fail when the data do not ﬁt main memory. moreover, events are being generated at highrates, e.g. consider data originating from sensor networks, mobile devices and e-businessapplications. since existing process discovery techniques use static data, they are not able tocapture the dynamics of such event streams in an adequate manner.
in this paper, we focus on process discovery using streams of business process events, i.e.
event streams , rather than event logs. applying process discovery on event streams allows
us to gain insights into the underlying business process in a live fashion. it furthermoreallows us to deal with situations where (1) event logs are too large to ﬁt main memory, (2)there is no time to access event data continuously, i.e. real-time constraints and (3) recentbehaviour is more important, i.e. concept drift. a large class of existing process discoveryalgorithms transforms the event log into an abstract representation , i.e. an abstraction of the
event log, which is subsequently used to discover a process model. to adopt these algorithmsin a streaming context, it sufﬁces to approximate the abstract representation based on theevent stream. using abstract representations has several advantages: (1) reusability :w e reuse
existing techniques by predominantly focusing on learning abstract representations fromevent streams. (2) extensibility : once we design and implement a method for approximating
a certain abstract representation, any (future) algorithm using the same abstract representationis automatically ported to event streams. (3) anonymity : in some cases, laws and regulations
dictate that we are not allowed to store all event data. some abstract representations ignorelarge parts of the data, effectively storing a summary of the actual event data, and thereforecomply to anonymity regulations.
we present the stream-based abstract representation (s-bar) architecture that describes
this mechanism in a generic way (fig. 1). an event stream
srepresents an (in)ﬁnite sequence
ofevents , emitted over time. an event is represented by a (c,a)-pair, stating that activity a
is executed in context of case c. we maintain a data structure ( dt) that represents the past
behaviour emitted onto stream s. each time a new event arrives the data structure is kept
up to date by updating its previous state based on the newly received event ( δdt). from the
data structure, an algorithm-speciﬁc abstract representation (at) is deduced ( λat
dt). after
fig. 1 schematic overview of the s-bar architecture
123event stream-based process discovery using abstract…
learning the abstract representation, we reuse existing translations borrowed from conven-
tional process discovery algorithms to return a process model (γat).
the s-bar architecture is instantiated by designing a data structure, a data structure
update mechanism and a data structure translation function. the actual implementation ofthe data structure and related update functions inﬂuences the behaviour described by thediscovered process model, e.g. using a time-decaying data structure versus a data structure thatapproximates the most frequent cases on the stream. several instantiations of the architecturehave been implemented in the process mining toolkits prom [ 8] and rapidprom [ 9,10].
using these implementations, we conduct empirical experiments w.r.t. the behaviour of thesealgorithms in an event stream setting. the experiments show that the algorithms are able tocapture the behaviour reﬂected by the event stream. moreover, the experiments show thatmemory usage and processing times of the algorithms have non-increasing trends.
the remainder of this paper is organized as follows. in sect. 2, we present background
information regarding business processes and process discovery. in sect. 3,w ep r e s e n te v e n t
streams and the notion of event stream-based process discovery. in sect. 4, we introduce the
s-bar architecture. in sect. 5, we provide several instantiations of the architecture. in sect. 6,
we present an empirical evaluation of several instantiations of the architecture. in sect. 7,w e
present related work. in sect. 8, we discuss general challenges in event stream-based process
discovery. section 9concludes the paper.
2 background
in this section, we present general notation used throughout the paper and background con-
cepts regarding business processes and process discovery.
ndenotes the set of positive integers, and n0includes 0. a multiset b over set xis a
function b:x→n0. we write a multiset as [ek1
1,ek2
2,..., eknn], where for 1 ≤i≤n
we have ei∈x,ki∈nand eki
i≡b(ei)=ki. if for element e,b(e)=1, we omit its
superscript. if for element e,b(e)=0, we omit efrom the multiset notation. an empty
multiset is denoted as []. element inclusion applies to multisets, i.e. if e∈xand b(e)> 0
then e∈b.
asequence σof length nrelates positions to elements e∈x, i.e.σ:{1,2,..., n}→ x.
an empty sequence is denoted as /epsilon1. we write every non-empty sequence as /angbracketlefte1,e2,..., en/angbracketright.
the set of all possible sequences over a set xis denoted as x∗.w ew r i t e concatenation of
sequences σ1andσ2asσ1·σ2.
letx,y,zand z/primebe sets and let f:x→yand g:y→z. function composition
offand gis deﬁned as g◦f:x→z, with x/mapsto→g(f(x))forx∈x. moreover, given
h:z→z/prime, we write h◦g◦fforh◦(g◦f), i.e. h◦g◦f:x→z/prime, with x/mapsto→h(g(f(x)))
forx∈x.
2.1 business processes, models and event logs
business processes represent the execution of related business activities leading to a business
goal. consider a bank offering loans to its customers. a business goal of the bank is to accept,reject or cancel a loan application. the bank’s employees and its enterprise informationsystem execute activities to achieve this goal, e.g. by checking a client’s credit history andassessing the loan risk.
123s. j. van zelst et al.
a business process pdeﬁnes a set of sequences over a set of activities a, i.e. p⊆a∗.
ifσ∈p, then the sequence of business activities σleads to a business goal and belongs
to the behaviour ofp. in this paper, we assume the execution of activities to be atomic and
abstract from data attributes such as resource and timestamp. hence, we only consider thesequential ordering of activities (the control-ﬂow perspective ).
updenotes the universe of
business processes. a process model mrepresents a business process and, like a process,
deﬁnes a set of sequences over a set of activities a, i.e. m⊆a∗.umdenotes the universe
of process models. in this paper, we consider process models that describe behaviour in adeterministic manner, e.g. petri nets [ 12], bpmn [ 13]a n dw o r k ﬂ o wn e t s[ 14]. consider
the bpmn model of a loan application handling process in fig. 2. it describes that after an
application is received, the ﬁrst activity to be executed is “check application completeness” .
depending upon the completeness of the application, the corresponding form is “returned
back to the applicant” , or the client’s “credit history is checked” and subsequently a “loan risk
assessment” is performed. the two aforementioned activities can be executed concurrently
with the “appraise property” activity. an “eligibility assessment” of the loan is performed,
eventually leading to a rejection ,cancellation orapproval of the loan.
today’s information systems track the execution of business processes within a company.
such systems store the execution of activities in context of a case , i.e. an instance of the
process. the data stored by the information system are often in the form of an event log .
consider table 1as an example. the execution of an activity in context of a case, e.g.
approve application executed for case 3, is referred to as an event . a sequence of events,
e.g. the sequence of events related to case 4,/angbracketleftcheck application form completeness, check
credit history, …, approve application /angbracketright,i sr e f e r r e dt oa sa trace (written /angbracketleftc
1,c2,..., a4/angbracketright
when using abbreviated activity names).
an event log lis a multiset of sequences over a set of activities a, i.e. l:a∗→n0,a n d
describes the execution of some p∈up.uldenotes the universe of event logs. an event
log is a sample of the underlying process. therefore, there might exist process behaviour
that is not present in the event log, e.g. caused by parallelism. in such case, an event log isincomplete . there might also exist traces in the event log that are not part of the process,
i.e.noisy traces. noisy traces can be caused by faulty execution of the process, incomplete
speciﬁcations or technical issues such as incorrect logging, system errors and mixed timegranularity.
2.2 process discovery
the goal of process discovery is to discover a process model based on an event log. severalprocess discovery algorithms exist [ 2–7]. these algorithms differ in terms of their underly-
ing computational schemes and data structures as well as their resulting process modellingformalism. we refer to [ 1,15,16] for a detailed overview of process discovery algorithms.
a process discovery algorithm γ
ldiscovers a process model based on an event log, i.e.
γl:ul→ um. the challenge is to design γlin such way that γl(l)is an appropriate
representation of the underlying process p. appropriateness of γ(l)depends on the aim of
the process discovery analysis, e.g. ensuring that all behaviour in the event log is present inthe model versus ensuring that the most frequent behaviour is present. given the differentaims of process discovery analyses, several quality measures are deﬁned in order to judgetheir resulting model’s appropriateness. ideally,
pis used as a basis to compute these metrics;
however, as lis the only tangible sample of p, we typically compute the quality of γl(l)
using l. the four essential process mining quality dimensions are replay ﬁtness ,precision ,
simplicity andgeneralization [1,17]. replay ﬁtness describes what fraction of the behaviour
123event stream-based process discovery using abstract…
fig. 2 bpmn model of a loan application process (adopted from [ 11])
123s. j. van zelst et al.
table 1 fragment of an event log
case activity resource timestamp
…… … …
3 approve application (a4) john 2015-05-08 08:45
4 check application completeness (c1) lucy 2015-05-08 09:13
5 check application completeness (c1) john 2015-05-08 09:145 return application to applicant (r1) pete 2015-05-08 10:115 receive updated application (r2) pete 2015-05-08 10:286 check application completeness (c1) lucy 2015-05-08 10:334 check credit history (c2) rob 2015-05-08 10:435 appraise property (a1) pete 2015-05-08 11:004 appraise property (a1) rob 2015-05-08 11:144 assess loan risk (a2) rob 2015-05-08 11:354 assess eligibility (a3) lucy 2015-05-08 11:555 check credit history (c2) john 2015-05-08 11:574 prepare acceptance pack (p1) lucy 2015-05-08 12:254 check insurance quote request present (c3) lucy 2015-05-08 12:234 send acceptance pack (s2) lucy 2015-05-08 12:285 assess loan risk (a2) john 2015-05-08 12:374 verify repayment agreement (v1) lucy 2015-05-09 13:054 approve application (a4) john 2015-05-09 14:15…… … …
present in lis also described by γl(l). precision describes what fraction of the behaviour
described by γl(l)is also present in l. simplicity describes the (perceived) complexity of the
process model. since it is unlikely that the event log contains all behaviour (incompleteness),generalization describes how well the process model generalizes for behaviour not presentinl. due to noise, an algorithm guaranteeing perfect replay ﬁtness, i.e. all behaviour in
the event log is present in the discovered model, captures behaviour that is not part of theprocess. in practice, this leads to very complex models that are impossible to be interpreted bya human analyst. hence, a process discovery algorithm needs to strike an adequate balance
between the four essential quality dimensions.
3 event stream-based process discovery
existing process discovery techniques discover process models in an a posteriori fashion,i.e. they provide a historical view of the data. however, most information systems allow usto capture the execution of activities at the moment they occur. discovering and analysingprocess models from such continuous streams of events allows us to get a real-time view ofthe process under study. such view paves the way for new types of process mining analysis,i.e. we are able to answer more advanced questions such as “what is the current status ofthe process?” and “what running cases are likely to cause problems?”. it also allows us toinspect and visualize recent behaviour and evolution of behaviour in the process, i.e. conceptdrift.
123event stream-based process discovery using abstract…
there are several other advantages of studying streams of events rather than event logs.
trends such as big data anddata science signify the spectacular growth and omnipresence
of data. typically, real event logs do not ﬁt main memory. since we assume event streamsto be potentially inﬁnite, analysing them enables us to handle event data of arbitrary size. inother cases, we do not have the time or are not allowed to access event data continuouslyand, hence, need to analyse events at the moment they occur.
in this section, we formalize event streams and event stream-based process discovery .
additionally, we quantify high-level requirements for the design of event stream- basedprocess discovery algorithms.
3.1 event streams
an event stream is a continuous stream of events executed in context of an underlying businessprocess. we represent an event stream as a sequence of pairs consisting of a case identiﬁer
and an activity . hence, for each event we know what activity was performed in context of
what process instance. when comparing event streams to event logs, we identify two maindifferences: (1) an event stream is potentially inﬁnite , and (2) behaviour seen for a case is
incomplete , i.e. in the future new events may be executed in context of a case.
deﬁnition 1 (event stream )l e t abe a set of activities and let cdenote the set of all possible
case identiﬁers. an event stream
sis a sequence over c×a, i.e. s∈(c×a)∗.
ap a i r (c,a)∈c×arepresents an event, i.e. activity awas executed in context of case
c.s(1)denotes the ﬁrst event that we receive, whereas s(i)denotes the ith event. consider
stream s1in fig. 3as an example, where event (3,a4)is emitted ﬁrst ( s1(1)=(3,a4)),
event(4,c1)is emitted second and event (5,a1)is the eight and last event emitted onto the
stream up until now . we receive multiple events related to the same case at different points
in time, e.g. the second and seventh event on s1are related to case 4. hence, handling such
type of data needs new types of data structures and event processing techniques compared toconventional process discovery.
3.2 process discovery
the goal of event stream- based process discovery is to discover a process model using anevent stream as an input. a ﬁrst step is to approximate, based on
s, the presence of some
σ∈pand possibly σ’s frequency w.r.t. s. given such approximation, the next step is to
deploy a process discovery algorithm onto the approximation in order to obtain a processmodel.
a naive approach is to construct an event log based on the event stream by using a data
structure that stores case-sequence pairs (c,σ)∈c×a
∗.f o re v e r ye v e n t (c,a)we receive,
we check whether the data structure contains entry (c,σ/prime). if so, we update this entry to
(c,σ/prime·/angbracketlefta/angbracketright).i fn o t ,w ei n s e r tn e we n t r y (c,/angbracketlefta/angbracketright). whenever we want to discover a new process
model based on the current state of the event stream, we transform the data structure intoan event log and provide it to any conventional process discovery algorithm. observe that,since the stream is potentially inﬁnite, this procedure needs inﬁnite memory . moreover, the
approach includes redundancy , i.e. several (partial) traces that were already analysed in a
fig. 3 example event stream s1
123s. j. van zelst et al.
fig. 4 example “ﬂower” model
previous call to a discovery algorithm, and are still in memory at the next call, are analysed
twice. hence, we want the data structure to either represent, or be easily translatable to, someminimal form of data needed in order to discover a process model.
an example of an algorithm using a minimal data representation is the ﬂower miner .
the ﬂower miner produces a process model that allows for every possible sequence overthe observed activities. reconsider example stream
s1(fig. 3) which consists of activities
labelled a1,a4,c1,c2,r1and r2.i nf i g . 4, we depict a ﬂower model, in terms of a petri
net [ 12], that allows for all activities on s1.
to ensure that the ﬂower miner uses ﬁnite memory, we just need to deploy any ﬁnite
memory-based data structure that keeps track of the activities seen on the stream. a widevariety of such data structures exits, e.g. count-based frequent item data structures [ 18],
reservoirs [ 19,20] and time-decay-based models [ 21]. whenever we receive a new event
(c,a), we just add ato the data structure. translating the data structure to a process model
is trivial, i.e. every activity present in the data structure is adopted in the ﬂower model.
the ﬂower miner works, yet it has deﬁciencies from a process discovery perspective. it
generalizes the behaviour represented by the event stream as much as possible. the resultingprocess model very likely allows for much more behaviour than actually present in the
underlying process. hence, we need techniques that are more precise .
the event log-based approach and the ﬂower miner represent two extremes. storing the
event stream as an event log requires us to reuse a large part of the data several times. theﬂower miner on the other hand neglects a large quantity of information carried by the eventstream and greatly overgeneralizes the stream’s behaviour. we therefore need a scheme thatis in the middle of both extremes, i.e. it does not store the complete event log, yet it storesenough data to provide meaningful output.
4 the s-bar architecture
when analysing conventional process discovery algorithms, we observe that a majority sharesa common underlying algorithmic mechanism. the event log is transformed into an abstract
representation , which is subsequently used to construct a resulting process model. moreover,
several algorithms use the same abstract representation. in example 1, we illustrate the
directly follows abstraction ,u s e db yt h e α-miner [3].
example 1 (the directly follows abstraction and the α-miner) consider event log l=
[/angbracketlefta,b,c,d/angbracketright,/angbracketlefta,c,b,d/angbracketright].t h eα-miner computes a directly follows abstraction based on the
event log. activity ais directly followed by b, written as a>b, if there exists some sequence
σ∈lof the form σ=σ
/prime·/angbracketlefta,b/angbracketright·σ/prime/prime.i nc a s eo fe v e n tl o g l, we deduce a>b,a>c,
123event stream-based process discovery using abstract…
b>c,b>d,c>b,c>d. using these relations as a basis, the α-miner constructs a petri
net.
as example 1shows, the event log is translated into a directly follows abstraction ,w h i c hi s
subsequently used to construct a process model. other discovery algorithms like the inductiveminer [ 5] and the ilp miner [ 7]u s e the same mechanism to discover a process model. to
adopt these algorithms to an event stream context, it sufﬁces to determine whether we areable to learn the corresponding abstract representation from the event stream and, if possible,design a data structure that supports this.
in the remainder of this section, we formalize the notion of abstract representations.
subsequently, we introduce the stream-based abstract representation (s-bar) architecture
that captures the notion of event stream-based abstract representation computation in a genericmanner.
4.1 abstract representations in conventional process discovery
we reﬁne conventional process discovery by splitting γlinto two steps. in the ﬁrst step, the
event log is translated into the abstraction used by the discovery algorithm. in the secondstep, the abstraction is translated into a process model. in the remainder, we let tdenote
an abstract representation type.
atdenotes an abstract representation of type t,a n d uat
denotes the universe of abstract representations of type t.
deﬁnition 2 (abstraction function—event log )l e t tdenote an abstract representation type.
an abstraction function λat
lis a function mapping an event log to an abstract representation
of type t.
λat
l:ul→ uat (1)
using deﬁnition 2, we deﬁne process discovery in terms of abstract representations.
deﬁnition 3 (process discovery algorithm—abstract representation )l e t tdenote an
abstract representation type. an abstract representation-based process discovery algorithm
γatmaps an abstract representation of type tto a process model.
γat:uat→ um (2)
every discovery algorithm that uses an abstract representation internally can be expressed
as a composition of λat
landγat. thus, given event log l∈uland abstract representation
type t,w eo b t a i n γl=(γat◦λat
l)(l). for example, consider fig. 5depicting the α-miner
in terms of γatandλat
l.
4.2 abstract representations in event stream-based process discovery
in this section, we present the s-bar architecture which captures the use of abstract repre-
sentations in an event stream context in a generic manner. in fig. 6, the s-bar architecture is
fig. 5 theα-miner in terms of its abstract representation
123s. j. van zelst et al.
fig. 6 detailed overview of the s-bar architecture
depicted schematically. the s-bar architecture conceptually splits event stream-based pro-
cess discovery into three components, highlighted in grey in fig. 6. we explain the purpose
of each component, i.e. δdt,λat
dtandγat,b ym e a n so fa ne x a m p l e .
consider maintaining the directly follows abstraction, introduced in example 1,o na
stream. to do this, we need a data structure that tracks the most recent activity for eachcase. given such data structure, if we receive new event (c,a), we check whether we already
received an activity a
/primefor case cor whether ais the ﬁrst activity received for case c.i fw e
already received activity a/primefor case c,w ed e d u c e a/prime>a. subsequently, we update our data
structure such that it now assigns ato be the last activity received for case c.
the ﬁrst component, i.e. δdt, maintains and updates a (collection of) data structure(s)
that together form a sufﬁcient representation of the behaviour entailed by the event stream. in
context of our example, the ﬁrst component is mainly concerned with keeping track of pairs
of activities that are in a a/prime>arelation. the second component, i.e. λat
dt, translates the data
structure to an abstract representation. in context of our example, this consists of translatingthe pairs of activities that are in a a
/prime>arelation into the directly follows abstraction. the
third component, i.e. γat, translates the abstract representation to a process model and is
inherited from conventional process discovery.
in the remainder, given an arbitrary data structure type t,w el e t udtdenote the universe
of data structures of type t. a data type tmight refer to an array or a (collection of) hash
table(s), yet it might also refer to some implementation of a stream-based frequent itemapproximation algorithm such as lossy counting [ 22]. we assume any
dt∈udtto use
ﬁnite memory.
deﬁnition 4 (data structure update function )l e t abe a set of activities and let cdenote
the set of all possible case identiﬁers. we deﬁne a data structure update function δdtas:
δdt:udt×c×a→ udt (3)
the data structure update function δdtallows us to update a given data structure dt∈
udtbased on any newly arrived event. in practice, the function typically consists of two
components. one component keeps track of the cases that were already active before and
123event stream-based process discovery using abstract…
maps them in some way to a second (collection of) data structure(s). such second component
allows us to construct the abstract representation. thus, when abstracting this mechanism,given some event stream-based data structure, we need a mechanism to translate the datastructure, i.e. the range of δ
dt, to an abstract representation.
deﬁnition 5 (abstraction function—data structure ) an abstraction function λat
dtis a func-
tion mapping a data structure of type tto an abstract representation of type t.
λat
dt:udt→ uat (4)
ideally, translating the data structure is computationally inexpensive. however, in some cases
translating the data structure to the intended abstract representation might be expensive. thisis acceptable, as long as we (re)-compute the abstraction in a periodic fashion or at the user’srequest.
assume that we have seen i≥0e v e n t so na ne v e n ts t r e a m
sand let dt
i∈udtdenote the
data structure that approximates the behaviour in the event stream safter receiving ievents.
when new event (c,a)∈c×aarrives, we are able to discover a new process model mi+1
by applying/parenleftbig
γat◦λat
dt◦δdt/parenrightbig/parenleftbig
dt
i,c,a/parenrightbig
. in practice, δdtis applied continuously and
whenever, after receiving a new ith event, we are interested in ﬁnding a process model we
apply/parenleftbig
γat◦λat
dt/parenrightbig/parenleftbig
dt
i/parenrightbig
to obtain the process model.
the main challenge in instantiating the framework is designing a data structure dt∈udt
that allows us to approximate an abstract representation together with accompanying δdt
andλat
dtfunctions.
5 instantiating s-bar
in this section, we show the applicability of the s-bar framework by presenting several
instantiations for different existing process discovery algorithms. a large class of algorithms,e.g. the α-miner [ 3], the heuristics miner [ 6,23] and the inductive miner [ 5], is based on
the directly follows abstraction. therefore, we ﬁrst present how to compute this abstraction.subsequently, we highlight, for each algorithm using the directly follows abstraction as abasis, the main changes and/or extensions that need to be applied w.r.t. the basic scheme.to illustrate the generality of the architecture, we also show a completely different class ofdiscovery approaches, i.e. region-based techniques [ 2,7]. these techniques work fundamen-
tally different compared to the aforementioned class of algorithms and use different abstractrepresentations.
5.1 directly follows abstraction
the directly follows abstraction describes pairs of activities (a,b), written as a>b,i f
there exists some sequence σ∈lof the form σ=σ/prime·/angbracketlefta,b/angbracketright·σ/prime/prime. to approximate the
relation, we let data structure dt∈udtconsist of two internal data structures dcand
da. within dc, we store (case, activity)-pairs, i.e. (c,a)∈c×a, that represent the last
activity aseen for case c. within da, we store (activity, activity)-pairs (a,a/prime)∈a×a,
where (a,a/prime)∈da⇔a>a/prime. the basic scheme works as follows. when a new event
(c,a)arrives, we check whether dcalready contains some pair (c,a/prime).i fs o ,w ea d d (a/prime,a)
toda, remove (c,a/prime)from dcand add (c,a)todc. if not, we just add (c,a)todc.da
represents the directly follows abstraction by means of a collection of pairs; thus, function
123s. j. van zelst et al.
algorithm 1: dc(space saving)
input :k∈n,s∈(c×a)∗,da
begin
1 x←∅ ;i←0;
2 while true do
3 i←i+1;
4 (c,a)← s(i);
5 if∃(c/prime,a/prime)∈x(c/prime=c)then
6 vc←vc+1;
7 da/unionmulti{(a/prime,a)};
8 x←(x∪{(c,a)})\{(c,a/prime)};
9 else if |x|<kthen
10 x←x∪{(c,a)};
11 vc←1;
12 else
13 (c/prime,a/prime)← arg min
(c/prime,a/prime)∈x(vc/prime);
14 vc←vc/prime+1;
15 x←(x∪{(c,a)})\{(c/prime,a/prime)};algorithm 2: dc(lossy)
input :k∈n,s∈(c×a)∗,da
begin
1 i,/delta1←0;x←∅ ;
2 while true do
3 i←i+1;
4 (c,a)← s(i);
5 if∃(c/prime,a/prime)∈x(c/prime=c)then
6 vc←vc+1;
7 da/unionmulti{(a/prime,a)};
8 x←(x∪{(c,a)})\{(c,a/prime)};
9 else
10 x←x∪{(c,a)};
11 vc←/delta1;
12 if⌊i/k⌋/negationslash=/delta1then
13 foreach (c/prime,a/prime)∈xdo
14 ifvc/prime≤/delta1then
15 x←x\(c/prime,a/prime);
16 /delta1←⌊ i/k⌋;
algorithm 3: da(frequent)
input :k∈n,sa∈(a×a)∗
begin
1 x←∅ ,i←0;
2 while true do
3 i←i+1;
4 (a,a/prime)← sa(i);
5 if(a,a/prime)∈xthen
6 v(a,a/prime)←v(a,a/prime)+1;
7 else if |x|<kthen
8 x←x∪{(a,a/prime)};
9 v(a,a/prime)←1;
10 else
11 foreach (x,y)∈xdo
12 v(x,y)←v(x,y)−1;
13 ifv(x,y)=0then
14 x←x\{(x,y)};
λat
dtconsists of translating dato the appropriate underlying data type used by the discovery
algorithm of choice.
as an example, consider algorithms 1and 2describing a design of dcb a s e do nt h e
spacesaving algorithm [ 24] and lossy counting [ 22], respectively.
both algorithms have three inputs, i.e. a maximum size k∈n, an event stream s∈
(c×a)∗and a ﬁnite memory data structure implementing da. the algorithms maintain
a set of (case, activity)-pairs x, initialized to ∅(line 1). for each case cpresent in x,a n
associated counter vcis maintained which is used for memory management. when a new
event(c,a)appears on the event stream, the algorithms check whether some pair (c/prime,a/prime)s.t.
c=c/primeis stored in x(line 5). if this is the case, c’s counter is increased, (a/prime,a)is added to
data structure da,a n d(c,a/prime)is replaced by (c,a)inx(lines 6–8). the algorithms differ
in the way they process events (c,a)for which ∄(c/prime,a/prime)∈x(c/prime=c). the space saving-based
123event stream-based process discovery using abstract…
algorithm (algorithm 1) either adds the element to xif|x|<kor replaces pair (c/prime,a/prime)∈x
with the lowest corresponding counter ( vc/prime) value (algorithm 1, lines 9–15). the lossy
counting- based algorithm cleans up its x-set after each block of kconsecutive events and
removes all those entries that have a counter value lower than variable /delta1(lines 9–16).
both algorithms insert a new element in data structure dain line 7. conceptually, the
algorithms generate a stream of (activity, activity)-pairs. hence, in algorithm 3we present
a basic design for dabased on the frequent algorithm [ 25,26] which uses an activity pair
stream sa∈(a×a)∗as an input. thus, da/unionmulti{(a/prime,a)}in line 7 of algorithms 1and 2
represents adding pair (a,a/prime)at the end of stream sa.
the algorithm stores pairs of activities in its internal set x. whenever a new pair (a,a/prime)
arrives, the algorithm checks whether it is already present in x, if so, it updates the corre-
sponding counter v(a,a/prime). if the pair is not yet present in x, the size of xis evaluated. if
|x|<k, the new pair is added to xand a new counter is created for the pair. if |x|≥ k,
the new pair is not added; moreover, each counter is decreased by one and if a counter getsvalue 0 the corresponding pair is removed.
the general mechanism of algorithm 3is very similar to algorithm 1. the main difference
consists of how to update xwhen|x|≥k. all three algorithms use a parameter kwhich, in
a way, represents the (maximum) size of x. hence, when we write |
dc|,|da|, respectively,
we implicitly refer to the value of k. it should be clear that we are also able to implement
dcbased on the frequent algorithm, i.e. we just adopt a different updating mechanism for
x. likewise, we are also able to design dabased on the space saving/lossy counting
algorithm. moreover, for dcwe are able to use other types of stream-aware data structures,
i.e. techniques adopting a different scheme to ensure ﬁnite memory. examples of such typesof techniques are reservoir sampling [ 19], and/or decay- based schemes [ 21]. in the next
sections, we brieﬂy explain how the α-miner, heuristics miner and inductive miner use the
directly follows abstraction and what changes to the base scheme must be applied in orderto adopt them in a streaming setting.
5.1.1 the α-miner
theα-miner [ 3] transforms the directly follows abstraction into a petri net. when adopt-
ing the α-miner to an event stream context, we directly adopt the scheme described
in the previous section. however, the algorithm explicitly needs a set of start and
end activities .
approximating the start activities seems rather simple, i.e. whenever we receive a new
case, the corresponding activity represents a start activity. however, given that we at somepoint remove (case, activity)-pairs from
dc, we might designate some activities falsely as
start activities, i.e. a new case may in fact refer to a previously removed case. approximatingthe end activities is more complex, as we are often not aware when a case terminates. apotential solution is to apply a warm-up period in which we try to observe cases that seem to
be terminated, e.g. by identifying cases that have long periods of inactivity or by assumingthat cases that are dropped out of
dcare terminated. however, since we approximate case
termination, using this approach may lead to falsely select certain activities as end activities.
we can also deduce start and end activities from the directly follows abstraction. a start
activity is an a∈awith∄a/prime∈a(a/prime/negationslash=a|a/prime>a), and an end activity is an a∈a
with∄a/prime∈a(a/prime/negationslash=a|a>a/prime). this works if these activities are only executed once at the
beginning, respectively, the end, of the process. in case of loops or multiple executions ofstart/end activities within the process, we potentially falsely neglect certain activities as beingeither start and/or end activities. in sect. 8.2, we discuss this problem in depth.
123s. j. van zelst et al.
5.1.2 the heuristics miner
the heuristics miner [ 6,23,27] is designed to cope with noise in event logs. to do this, it
effectively counts the number of occurrences of activities, as well as the >-relation. based
on the directly follows abstraction, it computes a derived metric a⇒b=|a>b|−|b>a|
|a>b|+|b>a|+1
that describes the relative causality between two tasks aandb(|a>b|denotes the number
of occurrences of a>b). the basic scheme presented in sect. 5.1sufﬁces for computing
a⇒b, as long as daexplicitly tracks or approximates, the frequencies of its elements (in
the scheme this is achieved by the internal counters).
5.1.3 the inductive miner
the inductive miner [ 5], like the α-miner, uses the directly follows abstraction and start
and end activities. it tries to ﬁnd patterns within the directly follows abstraction that indicatecertain behaviour, e.g. parallelism. using these patterns, it splits the event log into severalsmaller logs and repeats the procedure. due to its iterative nature, the inductive miner guaran-tees to ﬁnd sound workﬂow nets [14]. the inductive miner has also been extended to handle
noise and/or infrequent behaviour [ 28]. this requires, like the heuristics miner, to count the
>-relation. in [ 29], a version of the inductive miner is presented in which the inductive steps
are directly performed on the directly follows abstraction. in context of event streams, thisis the most adequate version to use as we only need to maintain a (counted) directly followsabstraction.
5.2 region theory
several process discovery algorithms [ 2,7,30–32]a r eb a s e do n region theory which solve the
petri net synthesis problem [ 33]. classical region theory techniques ensure strict formal prop-
erties for the resulting process models. process discovery algorithms based on region theoryrelax these properties. we identify two different region theory approaches, i.e. language-
based andstate-based region theory, which use different forms of abstract representations.
5.2.1 language-based approaches
algorithms based on language-based region theory [ 7,30]r e l yo na preﬁx closure of the input
event log, i.e. the set of all preﬁxes of all traces. it is trivial to adapt the scheme presentedto compute the directly follows abstraction (sect. 5.1) to preﬁx closures. in stead of storing
(case, activity)-pairs in
dc,w es t o r ep a i r s (c,σ)∈c×a∗. we additionally use a data
structure dpcwhich approximates the preﬁx closure. whenever we receive an event (c,a),
we look for a pair (c,σ)∈dc. if such pair exist, we subsequently add σ/prime=σ·/angbracketlefta/angbracketrighttodpc
and update (c,σ) to(c,σ/prime). if there is no such pair (c,σ),w ea d d /epsilon1and/angbracketlefta/angbracketrighttodpcand
(c,/angbracketlefta/angbracketright)todc.i nc a s eo f[ 7], which uses integer linear programming where (an abstraction
of) the preﬁx closure forms the constraint body, we simply store the constraints in dpc,r a t h e r
than the preﬁx closure.
5.2.2 state-based approaches
within process discovery based on state-based regions [ 2], a transition system is constructed
based on av i e w of a trace. examples of a view are the complete preﬁx of the trace, the
multiset projection of the preﬁx, etc. the future of a trace can be used as well, i.e. given an
123event stream-based process discovery using abstract…
event within a trace, the future of the event are all events happening after the event. however,
future-based views are not applicable in an event stream setting, as the future is unknown.
as an example of a transition system based on a simple event log l=[ /angbracketleft a,b,c,d/angbracketright,
/angbracketlefta,c,b,d/angbracketright], consider fig. 7.i nf i g . 7a states are represented by a multiset view of the
preﬁxes of the traces, i.e. the state is determined by the multiset of activities seen before.activities make up the transitions within the system, i.e. the ﬁrst activity in both traces is a;
thus, the empty multiset is connected to multiset [a]by means of a transition labelled a.i n
fig. 7a, we do not limit the maximum size of the multisets. figure 7b shows a set view of
the traces with a maximum set size of 1. again the empty set is connected with set {a}by
means of a transition labelled a. for trace /angbracketlefta,b,c,d/angbracketrightfor example, the second activity is a
b, and thus, state {a}has an outgoing transition labelled bto state {b}. this is the case, i.e. a
connection to state {b}rather than {a,b}, due to the size restriction of size 1.
consider the following scheme, similar to the scheme presented in sect. 5.1.g i v e na
view type v, e.g. a set view, we design
dcto maintain pairs (c,vc),s . t .vcis the last view
constructed for case c. moreover, we maintain a collection of views dv. updating dvis
straightforward. given new event (c,a), based on vcwe compute some new view v/prime
c, add it to
dvand update (c,vc)to(c,v/prime
c)indc, e.g. updating the size-1 set view means that the new
view based on new event (c,a)is simply the set {a}. however, just maintaining size-1 sets
indvdoes not sufﬁce as the relations between those sets, i.e. the transitions in the transition
system, are not present in dv.
the problem is ﬁxed by maintaining the transition system in memory, rather than dv,
and updating it directly when we receive new events. given some latest view vcfor case c,
i.e.(c,vc)∈dc, activity aof new event (c,a)represents the transition from vcto the newly
derived v/prime
c. without a limit on the view size, translating the transition system into a petri net
is rather slow. hence, in a streaming setting we limit the maximum size of the views. this, in
turn, causes some challenges w.r.t. dcand translation function λat
dt. consider the case where
we maintain a multiset/set view of traces with some arbitrary ﬁnite capacity k. moreover,
given k=2, assume we receive event (c,a)and(c,{a/prime,a/prime/prime})∈dc. the question is whether
the new view for cis{a,a/prime}or{a,a/prime/prime}? only if we store the last two events observed for c,i n
order, we are able to answer this question, i.e. if (c,/angbracketlefta/prime,a/prime/prime/angbracketright)∈dcwe deduce the new view
to be{a,a/prime/prime}. finally note that when we aim at removing paths from the transitions system,
for example when we remove cases from cfrom dc, we need to store the whole trace for c
in order to be able to reduce all states and transitions related to case c.
(a) (b)
fig. 7 example transition systems based on l=[ /angbracketleft a,b,c,d/angbracketright,/angbracketlefta,c,b,d/angbracketright],amultiset abstraction
(unbounded), bset abstraction (max. set size 1)
123s. j. van zelst et al.
6 evaluation
in this section, we present an evaluation of several instantiations of the architecture. we
also consider performance aspects of the implementation. all ﬁve algorithms, i.e. α-miner,
heuristics miner, inductive miner, ilp (language- based regions) and transition systemminer (state-based regions), have been implemented using the schemes presented in sect. 5
in the prom [ 8] framework ( http://www.promtools.org ). prom is the de facto standard aca-
demic toolkit for process mining algorithms and is additionally used by practitioners in theﬁeld. some of the implementations are ported to rapidprom [ 9](http://www.rapidprom.
org), i.e. a plugin of rapidminer ( http://www.rapidminer.com ), which allows for designing
large-scale repetitive experiments by means of scientiﬁc workﬂows [ 10]. source code of
the implementations is available via the stream -related packages within the prom code base,
i.e.streamabstractrepresentation ,streamalphaminer ,streamheuristicsminer ,streamilp-
miner ,streaminductiveminer andstreamtransitionsystemsminer (code for a package x is
located at http://svn.win.tue.nl/repos/prom/packages/x ). experiment results, event streams
and generating process models used, are available at https://github.com/s-j-v-zelst/research/
releases/download/kais1/2016_kais1_experiments.tar.gz .
6.1 structural analysis
as a ﬁrst visual experiment, we investigate the steady-state behaviour of the inductive
miner [5]. for both dcand da, we use the lossy counting scheme (sect. 5.1). to create an
event stream, we created a timed coloured petri net [ 34] in cpn tools [ 35] which simulates
the bpmn model depicted in fig. 2and emits the corresponding events. the event stream and
all other event streams used for experiments are free of noise. the model is able to simulatemultiple cases being executed simultaneously. the prom streaming framework [ 36,37]i s
used to generate an event stream out of the process model.
in fig. 8, we show the behaviour of the inductive miner over time, conﬁgured with
|
dc|= 75,|da|= 75, based on a random simulation of the cpn model. initially (model 1),
the inductive miner only observes a few directly follows relations, all executed in sequence.after a while (model 2), the inductive miner observes that there is a choice between prepare
acceptance pack and reject application . in model 3, the ﬁrst signs of parallel behaviour
of activities appraise property ,check credit history andassess loan risk become apparent.
however, not enough behaviour is emitted onto the stream to effectively observe the parallelbehaviour yet. in model 4, we identify a large block of activities within a choice construct.moreover, an invisible transition loops back into this block. the inductive miner tends toshow this type of behaviour given an incomplete directly follows abstraction. finally, afterenough behaviour is emitted onto the stream, model 5 shows a petri net version of exampleprocess model of fig. 2.
figure 8shows that the inductive miner is able to ﬁnd the original model based on the event
stream. we now focus on comparing the inductive miner with other algorithms described inthe paper. all discovery techniques discover a petri net or some alternative process modelthat we can convert to a petri net. the techniques however differ in terms of guarantees w.r.t.
the resulting process model. the inductive miner guarantees that the resulting petri nets aresound , whereas the ilp miner and the transition system miner do not necessarily yield
sound process models. to perform a proper behavioural comparative analysis, the soundnessproperty is often a prerequisite. hence, we perform a structural analysis of all the algorithmsby measuring structural properties of the resulting petri nets.
123event stream-based process discovery using abstract…
fig. 8 visual results of applying the inductive miner on a stream
using the ofﬂine variant of each algorithm, we ﬁrst compute a reference petri net. we
generated an event log lwhich contains enough behaviour such that the discovered petri
nets describe all behaviour of the bpmn model of fig. 2. based on the reference petri net, we
create a 15-by-15 matrix in which each row/column corresponds to an activity in the bpmnmodel. if, in the petri net, two labelled transitions are connected by means of a place, thecorresponding cells in the matrix get value 1. for example, given the ﬁrst petri net of fig. 8,
the labels start andcheck_application_completeness (in the ﬁgure this is “check_appl”) are
connected by means of a place. hence, the distance between the two labels is set to 1 in thecorresponding matrix. if two transitions are not connected, the corresponding value is setto 0.
using an event stream based on the cpn model, after each newly received event, we
use each algorithm to discover a petri net. for each petri net, we construct the 15-by-15matrix. we apply the same procedure as applied on the reference model. however, if ina discovered petri net a certain label is not present, we set all cells in the correspondingrow/column to −1, e.g. in model 1 of fig. 8there is no transition labelled end; thus, the
corresponding row and column consist of −1 values. given a matrix mb a s e do nt h es t r e a m i n g
variant of an algorithm, we compute the distance to the reference matrix m
ras:dm,mr=/radicalbig/summationtext
i,j∈{1,2,...,15}((m(i,j)−mr(i,j))2. for all algorithms, the internal data structures used
were based on lossy counting, with size 100.
123s. j. van zelst et al.
since the inductive miner and the α-miner are completely based on the same abstrac-
tion, we expect them to behave similar. hence, we plot their corresponding results togetherin fig. 9a. interestingly, the distance metric follows the same pattern for both algorithms.
initially, there is a steep decline in the distance metric after which it becomes zero. thismeans that the reference matrix equals the matrix based on the discovered petri net. thedistance shows some peaks in the area between 400 until 1000 received events. analysingthe resulting petri nets at these points in time showed that some activities were not present inthe resulting petri nets at those points. the results for the transition systems miner (ts), theilp miner and the heuristics miner are depicted in fig. 9b. we observe that the algorithms
behave similar to the α- and inductive miner, which intuitively makes sense as the algo-
rithms all have the same data structure capacity. however, the peeks in the distance metricoccur at different locations. for the heuristics miner, this is explained by the fact that ittakes frequency into account and thus uses the directly follows abstraction differently. thetransition system miner and the ilp miner use different abstract representations and havea different update mechanism than the directly follows abstraction, i.e. they always updatetheir abstraction whereas the directly follows abstraction only updates if, for a given case,we already received a preceding activity.
6.2 behavioural analysis
although the previous experiments provide interesting insights w.r.t. the functioning of thealgorithms in a streaming setting, they only consider structural model quality. a distance valueof 0 in fig. 9indicates that the resulting model is very similar to the reference model. it does
not guarantee that the model is in fact equal or entails the same behaviour as the referencemodel. hence, in this section we focus on measuring quantiﬁable similarity in terms ofbehaviour . we use the inductive miner as it provides formal guarantees w.r.t. initialization
and termination of the resulting process models. this in particular is a requirement to measurebehavioural similarity in a reliable manner. we adapt the inductive miner to a streamingsetting by instantiating the s-bar framework, using the scheme described in sect. 5.1,
combined with the modiﬁcations described in sect. 5.1.3 . for ﬁnding start and end activities,
we traverse the directly follows abstraction and select activities that have no predecessor, or,successor, respectively. we again use lossy counting [ 22] to implement both
dcand da
(algorithm 2, sect. 5.1).
we assess under what conditions the inductive miner instantiation is able to discover a
process model with the same behaviour as the bpmn model in fig. 2. in the experiment,
after each received event, we query the miner for its current result and compute replay ﬁtness
(a) (b)
fig. 9 distance measurements for the α-miner, inductive miner (im), ilp miner (ilp), transition systems
miner (ts) and heuristics miner, adistances for αand im, bdistances for ts, ilp and hm
123event stream-based process discovery using abstract…
and precision measures based on a complete corresponding event log. in fig. 10, the results
are presented for varying capacity sizes of the underlying data structure (lossy counting).
for the smallest data structure sizes, i.e. fig. 10a, we identify that the replay ﬁtness does
not stabilize. when the data structure size increases, i.e. fig. 10b, we identify the replay ﬁtness
to reach a value of 1 rapidly. the high variability in the precision measurements present infig. 10c suggests that the algorithm is not capable of storing the complete directly follows
abstraction. as a result, the inductive miner tends to create ﬂower-like patterns, thus greatlyunder-ﬁtting the actual process. the stable pattern present in fig. 10d suggests that the sizes
used within the experiment are sufﬁcient to store the complete directly follows abstraction.given that the generating process model is within the class of re-discoverable process models
of the inductive miner, both a replay ﬁtness and a precision value of 1 indicate that the modelis completely discovered by the algorithm.
in the previous experimental setting, we chose to use the same capacity for both
dcand
da. here we study the inﬂuence of the individual sizes of dcand da.i nf i g . 11we depict
the results of two different experiments in which we ﬁxed the size of one of the two datastructures and varied the size of the other data structure. figure 11a depicts the results for
aﬁ x e dv a l u e |
dc|= 100 and varying sizes |da|= 10,20,..., 50. figure 11b depicts the
(a) (b)
(c) ( d)
fig. 10 replay ﬁtness and precision measures based on applying the stream inductive miner: increasing
memory helps to improve ﬁtness and precision, a|dc|= 25,|da|= 25,b|dc|= 75,|da|= 75,
c|dc|= 25,|da|= 25,d|dc|= 75,|da|= 75
(a) (b)
fig. 11 replay fitness measures for the stream inductive miner, a|dc|= 100,|da|= 10,20,..., 50,
b|dc|= 10,20,..., 50,|da|= 100
123s. j. van zelst et al.
results for a ﬁxed value |da|= 100 and varying sizes |dc|= 10,20,..., 50. as the results
show, the lack of conversion to a replay ﬁtness value of 1 mostly depends on the size of da
and is relatively independent of the size of dc. intuitively, this makes sense as we only need
one entry (c,a)∈dcto deduce a>b, given that the newly received event is (c,b).e v e ni f
case cis dropped at some point in time, and reinserted later, still information regarding the
directly follows abstraction can be deduced. however, if not enough space is reserved forthe
dadata structure, then the data structure is incapable of storing the complete directly
follows abstraction.
6.3 concept drift
in the previous experiments, we focused on a process model that describes observed steady-
state behaviour, i.e. the process model from which events are sampled does not change
during the experiments. in this section, we assess to what extend the inductive miner-basedinstantiation of the framework is able to handle concept drift [38,39]. we focus on gradual
drift , i.e. the behaviour of the process model changes at some point in time, though the change
is only applicable for new cases, already active cases follow the old behaviour. in order toobtain a gradual drift, we manipulated the cpn simulation model of the process modelpresented in fig. 2. the ﬁrst ﬁve hundred cases that are simulated follow the original model.
all later cases are routed to a model in which we swap the parallel and choice structureswithin the model (fig. 12).
figure 13depicts the results of applying the inductive miner on the described gradual
drift. in fig. 13a, we depict the results using data structure sizes |
dc|= 100 and |da|= 50
(lossy counting). the blue solid line depicts the replay ﬁtness w.r.t. an event log containing
fig. 12 changes made to the business process model presented in fig. 2,aparallel to choice, bchoice to
parallel
123event stream-based process discovery using abstract…
(a) (b)
fig. 13 replay fitness measures for the stream inductive miner, given an event stream containing concept
drift, a|dc|= 100,|da|= 50,b|dc|= 100,|da|= 100
behaviour prior to the drift, the red dashed line represents replay ﬁtness w.r.t. an event log
containing behaviour after the drift. we observe that the algorithm again needs some time
to stabilize in terms of behaviour w.r.t. the pre-drift model. interestingly, at the moment thatthe algorithm seems to be stabilized w.r.t. the pre-drift model, the replay ﬁtness w.r.t. thepost-drift model ﬂuctuates. this indicates that the algorithm is not able to fully rediscoverthe pre-drift model, yet it produces a generalizing model which includes more behaviour,i.e. even behaviour that is part of the post-drift model. the ﬁrst event in the stream relatedto the new execution of the process is the 6 .415th event. indeed, the blue solid line drops
around this point in fig. 13a. likewise, the red dashed line rapidly increases to value 1.0.
finally, around event 15 .000 the replay ﬁtness w.r.t. the pre-drift model stabilizes completely,
indicating that the prior knowledge related to the pre-drift model is completely erased fromthe underlying data structure. in fig. 13b, we depict results for the inductive miner using
sizes|
dc|= 100 and |da|= 100. in this case, we observe more stable behaviour, i.e. both
the pre- and post-model behaviour stabilizes quickly. interestingly, due to the use of a biggerk-value of the lossy counting algorithm, the drift is reﬂected longer in the replay ﬁtness
values. only after roughly the 30 .000th event the replay ﬁtness w.r.t. the pre-drift model
stabilizes.
6.4 performance analysis
the main goal of the performance evaluation is to assess whether memory usage and process-ing times of the implementations are acceptable. as the implementations are of a prototypicalfashion, we focus on trends in processing time and memory usage, rather than absolute per-
formance measures. for both processing time and memory usage, we expect stabilizingbehaviour, i.e. over time we expect to observe some non-increasing asymptote. if the pro-cessing time/memory usage keeps increasing over time this implies that we are potentiallyunable to handle data on the stream or need inﬁnite memory.
within the experiment we measured the processing time and memory usage for handling
the ﬁrst 25.000 events emitted onto the stream. we again use the inductive miner with lossycounting and varying window sizes (parameter k):|
dc|= 25 and |da|= 25,|dc|= 50
and|da|= 50 and |dc|= 75,|da|= 75 (represented in the ﬁgures as 25 ×25, 50 ×50
and 75 ×75, respectively). we measured the time the algorithm needs to update both dcand
da. the memory measured is the combined size of dcand dain bytes. the results of the
experiments are depicted in fig. 14. both ﬁgures depict the total number of events received
on the xaxis. in fig. 14a, the processing time in nanoseconds is shown on the yaxis, whereas
in fig. 14b, the memory usage in bytes is depicted. the aggregates of the experiments are
depicted in table 2.
123s. j. van zelst et al.
(a) (b)
fig. 14 performance measurements based on the stream inductive miner, aprocessing times in nanoseconds,
bmemory usage in bytes
table 2 aggregate performance measures for the stream inductive miner
25×25 50 ×50 75 ×75
avg. processing time (ns.) 4.168 3 .866 3 .519
stdev. processing time (ns.) 3.245 2 .589 2 .691
avg. memory usage (byte) 75.392 81 .014 84 .696
stdev. memory usage (byte) 75.392 1 .230 1 .725
as fig. 14a shows, there is no observable increase in processing times as more events have
been processed. the average processing time seems to slightly decrease when the window
size of the lossy counting data structure increases (see table 2). intuitively this makes
sense as a bigger window size of the lossy counting algorithm implies less frequent cleanupoperations.
like processing time, memory usage of the lossy counting data structures does not show
an increasing trend (fig. 14b). in this case however, memory usage seems to increase when
the window size of the lossy counting algorithm is bigger. again this makes sense, as lesscleanup operations implies more active members within the data structures, and hence, ahigher memory usage.
7 related work
for a detailed overview of process mining, we refer to [ 1]. for an overview of models,
techniques and algorithms in stream-based mining and analysis, e.g. frequency approximationalgorithms, we refer to [ 40–42]. little work has been done on the topic of stream-based
process discovery and stream-based process mining in general. the notion of streams of events
is not new, i.e. several ﬁelds study aspects related to streams of (discrete) events. comparedto the ﬁeld of complex event processing (cep) [ 43], the s-bar architecture can be seen as an
event consumer , i.e. a decoupled entity that processes the events produced by the underlying
system. however, whereas the premise of cep is towards the design of event- based systems
and architectures, this work focuses on the behavioural analysis of such systems. the area of
event mining [ 44] focuses on gaining knowledge from historical event/log data. although the
input data are similar, i.e. streams of system events, the assumptions on the data source aredifferent. within event mining, data mining techniques such as pattern mining [44,c h p t .4 ]
are used as opposed to techniques used within this paper, i.e. techniques discovering end-to-end process models with associated execution semantics. also, event mining includes
123event stream-based process discovery using abstract…
methods for system monitoring, whereas the s-bar architecture can serve as an enabler for
business process monitoring and prediction.
to the best of the author’s knowledge, this paper is the ﬁrst work that presents a generic
architecture for the purpose of event stream- based process discovery. as such, the workmay be regarded as a generalization and standardization effort of some of the related workmentioned within this section.
in [45], an event stream-based variant of the heuristics miner is presented. the algorithm
uses three internal data structures using both lossy counting [ 22] and lossy counting with
budget [ 46]. the authors use these structures to approximate a causal graph based on an
event stream. the authors additionally present a sliding window-based approach. recently,an alternative data structure has been proposed based on preﬁx trees [ 47]. in this work, the
authors deduce the directly follows abstraction directly from a preﬁx tree which is main-tained in memory. the main advantage of using the preﬁx trees is the reduced processingtime and usage of memory. in [ 48], redlich et al. design an event stream-based variant of
the ccm algorithm [ 49]. the authors identify the need to compute dynamic footprint infor-
mation based on the event stream, which can be seen as the abstract representation used byccm. the dynamic footprint is translated to a process model using a translation step calledfootprint interpretation . the authors additionally apply an ageing factor to the collected
trace information to fade out the behaviour extracted from older traces. although the authorsdeﬁne event streams similarly to this paper, the evaluation relies heavily on the concept ofcompleted traces .i n[ 50], burattin et al. propose an event stream-based process discovery
algorithm to discover declarative process models. the structure described to maintain eventsand their relation to cases is comparable with the one used in [ 45]. the authors present several
declarative constraints that can be updated on the basis of newly arriving events instead ofan event log consisting of full traces.
8 discussion
in this section, we discuss interesting phenomena observed during experimentation whichshould be taken into account when adopting the architecture presented in this paper and inevent stream-based process discovery in general. we discuss limitations w.r.t. the complex-ity of abstract representation computation and discuss the impact of the absence of traceinitialization and termination information.
8.1 complexity of abstract representation computation
there are limitations w.r.t. the algorithms we are able to adopt using abstract representationsas basis. this is mainly related to the computation of the abstract representation within theconventional algorithm.
as an example, consider the α
+-algorithm [ 51] which extends the original α-miner
such that it is able to handle self-loops and length-1-loops. for handling self-loops, the
α+-algorithm traverses the event log and identiﬁes activities that are within a self-loop. subse-
quently, it removes these from the log and after that calculates the directly follows abstraction.for example, if l=[ /angbracketleft a,b,c/angbracketright,/angbracketlefta,b,b,c/angbracketright], the algorithm will construct l
/prime=[ /angbracketleft a,c/angbracketright]and
compute directly follows metrics based on l/prime.
in a streaming setting, we are able to handle this as follows. whenever we observe some
activity ato be in a self-loop and want to generate the directly follows abstraction, then for
every(a/prime,a)∈daand(a,a/prime/prime)∈da,s . t . a/negationslash=a/primeanda/negationslash=a/prime/prime, we deduce that (a/prime,a/prime/prime)is part
123s. j. van zelst et al.
(a) (b)
fig. 15 two abstract representations, aevent log, bevent stream
of the directly follows abstraction whereas (a,a),(a/prime,a)and(a,a/prime/prime)are not. although this
procedure approximates the directly follows relation on the event stream, a simple exampleshows that the relation is not always equal.
imagine a process
p={ /angbracketleft a,b,b,c/angbracketright,/angbracketlefta,e,b,d/angbracketright}. clearly, any noise-free event log
over this process is just a multiset over the two traces in p. in case of the conventional
α+-algorithm, removing the b-activity leads to the two traces /angbracketlefta,c/angbracketrightand/angbracketlefta,e,d/angbracketright. con-
sider the corresponding directly follows abstraction, depicted in fig. 15a. observe that
all possible directly follows pairs that we are able to observe on any stream over p
are:(a,b), (a,e), (b,b), (b,c), (b,d), (e,b). applying the described procedure yields the
abstraction depicted in fig. 15b. due to the information that is lost by only maintaining
directly follows pairs, we deduce non-existing relations (a,d)and(e,c).
in general, it is preferable to adopt an abstraction-based algorithm that constructs the
abstract representation in one pass over the event log.
8.2 initialization and termination
for the deﬁnitions presented in this paper, we abstract from trace initialization and/or ter-
mination, i.e. we do not assume the existence of explicit start/end events. apart from thetechnical challenges related to ﬁnding these events, i.e. as described in sect. 5.1.1 regarding
start/end activity sets used by the α-miner and inductive miner, this can have a severe impact
on computing the abstract representation as well.
if we assume the existence and knowledge of unique start and end activities, adopting any
algorithm to cope with this type of knowledge is trivial. we only consider cases of whichwe identify a start event and we only remove knowledge related to cases of which we haveseen the end event. the only challenge is to cope with the need to remove an unﬁnished casedue to memory issues, i.e. how to incorporate this deletion into the data structure/abstractrepresentation that is approximated.
if we do not assume and/or know of the existence of start/end activities, whenever we
encounter a case for which our data structure indicates that we have not seen it before, thiscase is identiﬁed as being a “new case”. similarly, whenever we decide to drop a case froma data structure, we implicitly assume that this case has terminated. clearly, when there isa long period of inactivity, a case might be falsely assumed to be terminated. if the casebecomes active again, it is treated as a new case again. the experiments reported in fig. 11
show that in case of the directly follows abstraction, this type of behaviour has limited impacton the results. however, in a more general sense, e.g. when approximating a preﬁx closure onan event stream, this type of behaviour might be of greater inﬂuence w.r.t. resulting model.the ilp miner likely suffers from such errors and as a result produces models of inferiorquality.
in fact, for the ilp miner the concept of termination is of particular importance. to
guarantee a single ﬁnal state of a process model, the ilp miner needs to be aware of completed
traces . this corresponds to explicit knowledge of when a case is terminated in an event stream
123event stream-based process discovery using abstract…
setting. like in the case of initialization, the resulting models of the ilp miner are greatly
inﬂuenced by a faulty assumption on case termination.
9 conclusion
in this paper, we presented a generic architecture that allows for adopting existing processdiscovery algorithms in an event stream setting. the architecture is based on the observationthat many existing process discovery algorithms translate a given event log into some abstractrepresentation and subsequently use this representation to discover a process model. thus, inan event stream-based setting, it sufﬁces to approximate the abstract representation using theevent stream in order to apply existing process discovery algorithms to streams of events. theexact behaviour present in the resulting process model greatly depends on the instantiationof the underlying techniques that approximate the abstract representation.
several instantiations of the architecture have been implemented in the process mining
toolkits prom and rapidprom. we primarily focused on abstract representation approxima-tions using algorithms designed for the purpose of frequent item mining on data streams.we structurally evaluated and compared ﬁve different instantiations of the framework. froma behavioural perspective, we focused on the inductive miner as it grantees to producesound workﬂow nets. the experiments show that the instantiation is able to capture processbehaviour originating from a steady-state-based process. moreover, convergence of replayﬁtness to a stable value depends on parametrization of the internal data structure. in case ofconcept drift, the size of the internal data structure of use impacts both model quality andthe drift detection point. we additionally studied the performance of the inductive minerinstantiation. the experiments show that both processing time of new events and memoryusage are non-increasing as more data are received.
future work
within the experiments, we chose to limit the use of internal data structure to the lossycounting-based approach. however, more instantiations, i.e. frequent/space saving, arepresented and implemented. we plan to investigate the impact of several different designs ofthe internal data structures w.r.t. both behaviour and performance.
the architecture presented in this work focuses on approximating abstract representations
and exploiting existing algorithms to discover a process model. however, bulk of the workmight be performed multiple times, i.e. several new events emitted to the stream might notchange the abstract representation. we therefore plan to conduct a study towards a completelyincremental instantiation of the architecture, i.e. can we immediately identify whether newdata changes the abstraction or even the resulting model?
another interesting direction for future work is to go beyond control-ﬂow discovery,
i.e. can we lift conformance checking, performance analysis, etc. to the domain of eventstreams? moreover, in such cases we might need to store more information, i.e. store all
attributes related to events within cases seen so far. we plan to investigate the application
of lossless/lossy compression of the data seen so far, i.e. using frequency distributions ofactivities/attributes to encode sequences in a compact manner.
open access this article is distributed under the terms of the creative commons attribution 4.0 interna-
tional license ( http://creativecommons.org/licenses/by/4.0/ ), which permits unrestricted use, distribution, and
123s. j. van zelst et al.
reproduction in any medium, provided you give appropriate credit to the original author(s) and the source,
provide a link to the creative commons license, and indicate if changes were made.
references
1. van der aalst wmp (2016) process mining—data science in action, 2nd edn. springer, berlin. doi: 10.
1007/978-3-662-49851-4
2. van der aalst wmp , rubin v , v erbeek hmw, van dongen bf, kindler e, günther cw (2010) process
mining: a two-step approach to balance between underﬁtting and overﬁtting. softw syst model 9(1):87–111. doi: 10.1007/s10270-008-0106-z
3. van der aalst wmp , weijters t, maruster l (2004) workﬂow mining: discovering process models from
event logs. ieee trans knowl data eng 16(9):1128–1142. doi: 10.1109/tkde.2004.47
4. günther cw, van der aalst wmp (2007) fuzzy mining-adaptive process simpliﬁcation based on multi-
perspective metrics. in: business process management, 5th international conference, bpm 2007, brisbane,september 24–28, 2007, proceedings, pp 328–343. doi: 10.1007/978-3-540-75183-0_24
5. leemans sjj, fahland d, van der aalst wmp (2013) discovering block-structured process models from
event logs—a constructive approach. in: application and theory of petri nets and concurrency—34thinternational conference, petri nets 2013, milan, june 24–28, 2013, proceedings, pp 311–329
6. weijters ajmm, van der aalst wmp (2003) rediscovering workﬂow models from event-based data using
little thumb. integr comput aided eng 10(2):151–162
7. van der werf jmem, van dongen bf, hurkens caj, serebrenik a (2009) process discovery using integer
linear programming. fundam inf 94(3–4):387–412
8. van dongen bf, de medeiros aka, v erbeek hmw, weijters ajmm, van der aalst wmp (2005) the
prom framework: a new era in process mining tool support. in: applications and theory of petri nets2005, 26th international conference, ica tpn 2005, miami, june 20–25, 2005, proceedings, pp 444–454.doi:10.1007/11494744_25
9. van der aalst wmp , bolt a, van zelst sj (2017) rapidprom: mine your processes and not just your data.
corr abs/1703.03740
10. bolt a, de leoni m, van der aalst wmp (2015) scientiﬁc workﬂows for process mining: building blocks,
scenarios, and implementation. int j softw tools technol transf. doi: 10.1007/s10009-015-0399-5
11. dumas m, la rosa m, mendling j, reijers ha (2013) fundamentals of business process management.
springer, berlin. doi: 10.1007/978-3-642-33143-5
12. murata t (1989) petri nets: properties, analysis and applications. proc ieee 77(4):541–58013. object management group (2011) business process model and notation (bpmn). formal speciﬁcation
formal/2011-01-03, object management group
14. van der aalst wmp (1998) the application of petri nets to workﬂow management. j circuits syst comput
8(1):21–66. doi: 10.1142/s0218126698000043
15. van dongen bf, de medeiros aka, wen l (2009) process mining: overview and outlook of petri net
discovery algorithms. trans petri nets other models concurr 2:225–242
16. de weerdt j, de backer m, v anthienen j, baesens b (2012) a multi-dimensional quality assessment of
state-of-the-art process discovery algorithms using real-life event logs. inf syst 37(7):654–676. doi: 10.
1016/j.is.2012.02.004
17. buijs jcam, van dongen bf, van der aalst wmp (2014) quality dimensions in process discovery:
the importance of ﬁtness, precision, generalization and simplicity. int j cooper inf syst. doi: 10.1142/
s0218843014400012
18. cormode g, hadjieleftheriou m (2009) methods for ﬁnding frequent items in data streams. vldb j
19(1):3–20. doi: 10.1007/s00778-009-0172-z
19. aggarwal cc (2006) on biased reservoir sampling in the presence of stream evolution. in: proceedings of
the 32nd international conference on very large data bases, vldb’06. vldb endowment, pp 607–618
20. vitter js (1985) random sampling with a reservoir. acm trans math softw 11(1):37–57. doi: 10.1145/
3147.3165
21. cormode g, shkapenyuk v , srivastava d, xu b (2009) forward decay: a practical time decay model for
streaming systems. in: 2009 ieee 25th international conference on data engineering, pp 138–149. doi: 10.
1109/icde.2009.65
22. manku gs, motwani r (2002) approximate frequency counts over data streams. in: proceedings of the
28th international conference on very large data bases, vldb’02. vldb endowment, pp 346–357
23. weijters ajmm, ribeiro jts (2011) flexible heuristics miner (fhm). in: 2011 ieee symposium on
computational intelligence and data mining (cidm), pp 310–317. doi: 10.1109/cidm.2011.5949453
123event stream-based process discovery using abstract…
24. metwally a, agrawal d, abbadi a (2005) efﬁcient computation of frequent and top-k elements in data
streams. in: eiter t, libkin l (eds) proceedings of the 10th international conference on database theory,icdt’05, pp 398–412. springer, berlin. doi: 10.1007/978-3-540-30570-5_27
25. demaine ed, lópez-ortiz a, munro ji (2002) frequency estimation of internet packet streams with lim-
ited space. in: möhring rh, raman r (eds) algorithms—esa 2002, 10th annual european symposium,rome, september 17–21, 2002, proceedings, lecture notes in computer science , vol 2461, pp 348–360.
springer. doi: 10.1007/3-540-45749-6_33
26. karp rm, shenker s, papadimitriou ch (2003) a simple algorithm for ﬁnding frequent elements in
streams and bags. acm trans database syst 28:51–55. doi: 10.1145/762471.762473
27. weijters ajmm, van der aalst wmp , de medeiros aka (2006) process mining with the heuristics
miner-algorithm. beta working paper series wp 166, eindhoven university of technology
28. leemans sjj, fahland d, van der aalst wmp (2013) discovering block-structured process models from
event logs containing infrequent behaviour. in: business process management workshops-bpm 2013international workshops, beijing, august 26, 2013, revised papers, pp 66–78. doi: 10.1007/978-3-319-
06257-0_6
29. leemans sjj, fahland d, van der aalst wmp (2015) scalable process discovery with guarantees. in:
enterprise, business-process and information systems modeling—16th international conference, bpmds2015, 20th international conference, emmsad 2015, held at caise 2015, stockholm, june 8–9, 2015,proceedings, pp 85–101. doi: 10.1007/978-3-319-19237-6_6
30. bergenthum r, desel j, lorenz r, mauser s (2007) process mining based on regions of languages. in:
business process management, 5th international conference, bpm 2007, brisbane, september 24–28,2007, proceedings, pp 375–383. doi: 10.1007/978-3-540-75183-0_27
31. carmona j, cortadella j (2014) process discovery algorithms using numerical abstract domains. ieee
trans knowl data eng 26(12):3064–3076. doi: 10.1109/tkde.2013.156
32. van zelst sj, van dongen bf, van der aalst wmp (2015) avoiding over-ﬁtting in ilp-based process
discovery. in: business process management—13th international conference, bpm 2015, innsbruck,august 31–september 3, 2015, proceedings, pp 163–171. doi: 10.1007/978-3-319-23063-4_10
33. badouel e, bernardinello l, darondeau p (2015) petri net synthesis. texts in theoretical computer science.
an ea tcs series. springer. doi: 10.1007/978-3-662-47967-4
34. jensen k, kristensen lm (2009) coloured petri nets—modelling and validation of concurrent systems.
springer, berlin. doi: 10.1007/b95112
35. jensen k, kristensen lm, wells l (2007) coloured petri nets and cpn tools for modelling and validation
of concurrent systems. sttt 9(3–4):213–254. doi: 10.1007/s10009-007-0038-x
36. van zelst sj, burattin a, van dongen bf, v erbeek hmw (2014) data streams in prom 6: a single-node
architecture. in: proceedings of the bpm demo sessions 2014 co-located with the 12th internationalconference on business process management (bpm 2014), eindhoven, september 10, 2014, p 81
37. van zelst sj, van dongen bf, van der aalst wmp (2015) know what you stream: generating event streams
from cpn models in prom 6. in: proceedings of the bpm demo session 2015 co-located with the 13thinternational conference on business process management (bpm 2015), innsbruck, september 2, 2015,pp 85–89
38. bose rpjc, van der aalst wmp , zliobaite i, pechenizkiy m (2014) dealing with concept drifts in process
mining. ieee trans neural netw learn syst 25(1):154–171. doi: 10.1109/tnnls.2013.2278313
39. schlimmer jc, granger rh (1986) beyond incremental processing: tracking concept drift. in: proceedings
of the 5th national conference on artiﬁcial intelligence. philadelphia, august 11–15, 1986. v olume 1:science, pp 502–507
40. aggarwal cc (ed) (2007) data streams, advances in database systems, vol 31. springer, new y ork. doi: 10.
1007/978-0-387-47534-9
41. gama j (2010) knowledge discovery from data streams, 1st edn. chapman and hall, london. doi: 10.
1201/ebk1439826119
42. muthukrishnan s (2005) data streams: algorithms and applications. found trends theor comput sci.
doi:10.1561/0400000002
43. etzion o, niblett p (2010) event processing in action. manning publications company, greenwich44. li t (2015) event mining: algorithms and applications. chapman and hall, london45. burattin a, sperduti a, van der aalst wmp (2014) control-ﬂow discovery from event streams. in:
proceedings of the ieee congress on evolutionary computation, cec 2014, beijing, july 6–11, 2014, pp2420–2427
46. da san martino g, navarin n, sperduti a (2013) a lossy counting based approach for learning on streams
of graphs on a budget. in: ijcai 2013, proceedings of the 23rd international joint conference on artiﬁcialintelligence, beijing, august 3–9, 2013
123s. j. van zelst et al.
47. hassani m, siccha s, richter f, seidl t (2015) efﬁcient process discovery from event streams using
sequential pattern mining. in: 2015 ieee symposium series on computational intelligence, pp 1366–1373. doi: 10.1109/ssci.2015.195
48. redlich d, molka t, gilani w, blair g, rashid a (2014) scalable dynamic business process discovery
with the constructs competition miner, pp 91–107
49. redlich d, molka t, gilani w, blair g, rashid a (2014) constructs competition miner: process control-
ﬂow discovery of bp-domain constructs, pp 134–150. doi: 10.1007/978-3-319-10172-9_9
50. burattin a, cimitile m, maggi fm, sperduti a (2015) online discovery of declarative process models
from event streams. ieee trans serv comput 8(6):833–846. doi: 10.1109/tsc.2015.2459703
51. de medeiros aka, van dongen bf, van der aalst wmp , weijters ajmm (2005) process mining for
ubiquitous mobile systems: an overview and a concrete algorithm. in: baresi l, dustdar sm, gall hc,matera m (eds) ubiquitous mobile information and collaboration systems, lecture notes in computer
science , vol 3272. springer, berlin, pp 151–165
sebastiaan j. van zelst is a ph.d. candidate at the architecture of
information systems group at the department of mathematics and
computer science of the eindhoven university of technology. hisresearch focuses on the application and impact of stream-based anal-ysis techniques on process mining. his personal research interestsinclude process mining, data stream analysis and data mining.
boudewijn f. van dongen is an associate professor at the architec-
ture of information systems group at the department of mathematics
and computer science of the eindhoven university of technology. his
research focus is on process mining and speciﬁcally on conformancechecking, and since 2003, he has been a key player in the developmentof the process mining tool prom. furthermore, he is a member of theieee task force on process mining and he published extensively inthe process mining area, both in international conferences and in jour-nals (e.g. dke, eis, is, caise, a tpn, bpm, er, edoc). he servedin several program committees, among others for ieee edoc 2007,2008, 2009, 2010, bpi 2007–2016.
123event stream-based process discovery using abstract…
w i lm .p .v a nd e ra a l s t is a full professor of information systems at
the technische universiteit eindhoven (tu/e). at tu/e, he is the sci-entiﬁc director of the data science center eindhoven (dsc/e). since2003, he holds a part-time position at queensland university of tech-nology (qut). his personal research interests include process mining,petri nets, business process management, workﬂow management, pro-cess modeling and process analysis. he is also a member of the boardof governors of tilburg university and an elected member of the royalnetherlands academy of arts and sciences, the royal holland societyof sciences and humanities, and the academy of europe.
123