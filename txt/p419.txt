declare: full support for
loosely-structured processes
maja pesic
department of technology management
eindhoven university of technology
the netherlands
email: m.pesic@tue.nlhelen schonenberg
mathematics and computer science
eindhoven university of technology
the netherlands
email: m.h.schonenberg@tue.nlwil m.p. van der aalst
mathematics and computer science
eindhoven university of technology
the netherlands
email: w.m.p.v.d.aalst@tue.nl
abstract—traditional workﬂow management systems
(wfmss) are not ﬂexible enough to support loosely-structur ed
processes. furthermore, ﬂexibility in contemporary wfmss
usually comes at a certain cost, such as lack of support for us ers,
lack of methods for model analysis, lack of methods for analy sis
of past executions, etc. declare is a prototype of a wfms
that uses a constraint-based process modeling language for the
development of declarative models describing loosely-str uctured
processes. in this paper we show how declare can support
loosely-structured processes without sacriﬁcing importa nt
wfmss features like user support, model veriﬁcation, analy sis
of past executions, changing models at run-time, etc.
i. introduction
management of business processes automated by workﬂow
management systems (wfmss) is limited by properties of
these systems [2], [13], [19]. due to the rigidity of wfmss,
it is hard for organizations to maintain ﬂexible business
processes in wfmss. the issue of ﬂexibility in wfmss has
become one of the most frequently addressed problems within
this ﬁeld [4], [9], [14], [15], [18], [21], [23], [30]. these
research approaches typically focus on the central element
driving any wfms: the process model describing the ordering
or activities.
a process model deﬁnes a business process and determines
the way the cases (i.e., process instances) are handled in
an organization. therefore, the model heavily inﬂuences th e
degree of ﬂexibility of the wfms. in traditional wfms, rigid
modeling languages (e.g, bpmn, epcs, uml-ads, or more
formal languages such as petri nets [28] and pi calculus [24] ),
deﬁne a process model as a detailed speciﬁcation of a step-by -
step procedure that should be followed during the execution .
this approach is an imperative approach because it strictly
speciﬁes howthe process will be executed and yields highly-
structured processes . the major drawback of this approach
is the fact that users have limited inﬂuence on the process
under execution, since most decisions about the execution a re
already made during process modeling phase.
flexible systems aim at offering ﬂexibility to the user by
shifting decision making from the system to the user. as a
result,researchonﬂexibilityinwfmssfocussesonadiffer ent
notion of the process model. for instance, case-handling
systems [27] are wfmss that offer more ﬂexibility by adding
special actions that users can perform while working withimperative models. one example of a case-handling system is
flower [25], where users can “soften” the imperative nature
of models by re-doing past actions or skipping unnecessary
actions. adaptive systems [21] are another example of ﬂexib le
systems that use imperative models. systems like adept
[29] use powerful and complex mechanisms that allow users
to change process models (by inserting, moving or deleting
activities) during execution. although these solutions in crease
ﬂexibility to a great extent, the imperative nature of model s
remains, which can produce other burdens for users. for
example, in case-handling systems the user cannot choose to
re-do only one activity from the past – she will have to re-
do all successor activities. on the other hand, the adaptive
approach requires users to have modeling expertise to chang e
models for occurring deviations.
one of the key problems of existing workﬂow languages
is that they force or stimulate the designer to over-specify
things. for example, it is possible to model all kinds of
choices. however, it is not possible to simply state that two
activities should never occur together. instead, the user i s
forced to provide a detailed strategy to implement this simp le
requirement.
we believe that replacing the imperative approach with a
declarative one is essential for making wfmss more ﬂexible
while avoiding the problems mentioned above. therefore,
we propose a system for supporting declarative (loosely-
structured) process models: declare. declare is de-
veloped as a constraint-based system and uses a declarative
language grounded in temporal logic [20] for the developmen t
and execution of process models. even though it is a declar-
ative system, declare can offer most features that tradi-
tional wfmss have: model development, model veriﬁcation
(ﬁnding errors in models), automated model execution,chan g-
ing models at run-time (i.e., adaptivity), analysis of alre ady
executed processes, and decomposition of large processes.
in addition, declare can be used to overcome the ever-
lasting paradox/trade-off between user support and ﬂexibi lity
byprovidingtheuserwithhistorybasedrecommendationsdu r-
ing process execution. to achieve this, declare cooperates
with two other tools, as shown in figure 1: yawl [1] and
prom [11]. yawl is an open-source workﬂow management
system inspired by the well-known workﬂow patterns [3] andgoodathandlingstructuredworkﬂows.yawlanddeclare
work together in such as way that structured parts of the
process are handled by yawl while unstructured parts are
handled by declare, i.e., there can be an arbitrary nesting
of of yawl and declare processes. the process-mining
tool prom [11] is used for analysis of past executions of
declare models and recommendations. declare itself
consistsofthreetypicalcomponentsthateverywfms has:(1 )
a modelingcomponentcalled designer,that isused forsystem
settings and process model development, (2) a component for
process enactment, called framework which is also used for
communication with yawl and prom, and changing models
at run-time, and (3) a component for process execution, call ed
worklistwhich is a simple tool for users to execute processes
and see recommendations.
loguserrecommendation
execution
recommendation
imperative
processes
sub-processlanguage export
model export
declarative
processes
development
validation
enactment
adaptation
fig. 1. system architecture
the remainder of the paper is organized as follows. section
ii starts with the description of the constraint-based appr oach
and main features of declare. section iii describes how
declare cooperates with yawl [1]. analysis of past
executions of declare models with a process-mining tool
prom [11] is described in section iv. user support with
history based recommendations is presented in section v.
related work and future work are described in sections vi
and vii, while section viii concludes the paper.
ii. constraint basedapproach
as opposed to traditional imperative approaches to process
modeling, declare uses a constraint-based declarative ap-
proach. figure 2 shows the differences between the two ap-
proaches. an imperative model focuses on specifying exactl y
howtoexecutetheprocess,i.e.,allpossibilitieshavetoe ntered
into the model by specifying its control-ﬂow. a declarative
model speciﬁes a set of constraints, i.e., rules that should be
followed during the execution. in this way, the declarative
model implicitly deﬁnes the control-ﬂow as all possibiliti es
that do not violate any of the given constraints, as shown in
figure 2(a).
by deﬁning how to execute the process, imperative lan-
guages tend to over-specify the process model. consider, fo r
example, a situation where there are two activities “a” and“b” that exclude one another, i.e., if “a” is executed for a
particularcase (processinstance),then“b” cannotbeexec uted
for the same case and vice versa. using declare this can
be modeled easily as shown in figure 2(b), the connection
between “a” and “b” describes this constraint graphically.
imperative languages do not have such a construct.1as a
result, the requirement needs to be translated into lower le vel
constructs. in this case, the obvious approach is to add a
decision activity “x” which makes a choice between “a” and
“b” as shown in figure 2(c). the conditions “c1” and “c2”
shown in figure 2(c) need to be mutually exclusive. although
activity “x” did not play a role in the initial requirement,
the designer needs to specify this activity and decide when
it is executed. moreover, conditions “c1” and “c2” need to
be speciﬁed. clearly, such an approach leads to an over-
speciﬁcation of the desired behavior even though the initial
requirement was simple and unambiguous.
(a) declarative condec vs. imperative languages (b) a and b should not happen both
(c) over-specification in an 
imperative language a b
a
bxc1
c2forbidden 
behavior 
deviations from 
the prescribed 
modelimperative 
model condec condec 
condec condec 
fig. 2. imperative vs. declarative approach
we will use a simple process of renting rooms in a hotel
as an illustrative example to describe process modeling and
execution in declare. this process consists of seven activ-
ities: (1) “register client data” - enter client name, prefe rred
way of payment (e.g., cash or credit card ), identiﬁcation,
etc; (2) “bill” - altering the billing speciﬁcation with cos ts
for stay, room service, laundry service, etc (used to charge the
total price of the stay); (3) “room service” - register the ro om
service for client; (4) “laundry service” - register the lau ndry
service for client; (5) “additional cleaning” - although ro oms
arecleanedonaregularbasis,additionalcleaningissomet imes
necessary; (6) “charge” - client is charged with an amount fo r
received service(s); and (7) “check-out” - client checks ou t
at the reception. figure 3 shows a declare model (in the
designer component) for the hotel example containing all the
mentioned activities. actually, this is already a valid mod el in
declare that can be saved and executed. in this case, the
numberofpossibleexecutions(i.e.,processinstances,ca ses) is
inﬁnite; it is possible not to execute any activity, or to exe cute
each of the activities an arbitrary number of times (0..*, i. e.,
zero or more), and activities can be executed in any order.
1note that declare is not a single, ﬁxed language but allows fo r
the deﬁnition of multiple languages. one of the languages re alized using
declare is condec [26]. the notation shown in figure 2(b) is p art of
the condec language. we will elaborate on the subtle differe nce between
declare and condec later in this paper.fig. 3. activities in the hotel example
naturally, the hotel process needs to follow some simple
rules:
•(c.1) every process instance has to start with activity
“register client data”. data can also be altered at later
stages (e.g., the client changes payment details).
•(c.2) activity “bill” must be executed at least once, i.e.,
at least the number of nights will be billed. however, it
might be that the bill is altered multiple times for a given
case (e.g., room service during stay, damage in the room,
etc.).
•(c.3) every “room service” must be billed. however, it
is possible that several services are billed at once, instea d
of billing each service separately.
•(c.4) every“laundryservice” must be billed. however,it
is possible that several services are billed at once, instea d
of billing each service separately.
•(c.5) when the client “checks-out” the bill must be
“charged”. it might be the case that the bill was charged
before check-out, during check-out or even after check-
out (e.g., credit card payment). also, it must be possible
that the total amount is charged at several stages during
the stay.
note that this set of rules also allows for undesired but
unavoidable behavior. for example it is undesired that clie nts
leave the hotel without paying, i.e., cases where activity
“charge” is never executed. however, if the client forgets t o
“check-out” the system cannot enforce that the client pays
(activity “charge”). this situation and many other excepti onal
situations are covered by the hotel process, as long as the
previous ﬁve rules are followed. note that in a traditional
wfms there is a tendency to describe an ideal world where
these exceptional situations do not exist. however, in the r eal
world these exceptional situations do exist and need to be
handled.
figure 3 allows for any behavior involving the seven hotel
activities mentioned. declare offer the possibility to spe c-ify rules such as c.1-5asconstraints .
a. constraint templates
while traditional modeling languages offer a predeﬁned
set of types of relations between activities (sequence, cho ice,
parallelism,andloop),declareallowsforcustomizedspec -
iﬁcation of relation types, or as we call it constraint templates .
in our small, illustrative example there are two constraint s of
the same type. constraint ( c.3) and ( c.4) specify the same
type of relation between activities, namely every executio n of
“room service” ( c.3), or every execution of “laundry service”
(c.3) will eventually be followed by at least one execution of
“billed”. this type of relation is known as “response” and is
one of the many possible constraint templates supported by
declare.
in declare it is possible to create a constraint tem-
plate for a relation type. each constraint template has (1)
an unique name, (2) semantics speciﬁed in linear temporal
logic2(ltl) [20] and (3) graphical representation . ltl is a
special type of logic that uses (in addition to classical log ical
operators) several temporal operators: always ( 2), eventually
(3), until ( ⊔), and next time ( /circlecopyr⊔). the major beneﬁt of
constraint templates is that users do not have to be ltl
experts to work with the system; they work with a graphical
representationof templates, while the underlyingltl form ula
remains “hidden”.
figure 4 shows a screenshot of declare while deﬁning
a constraint template. here the deﬁnition of the “response”
template is shown. note that the “response” template is
deﬁned as a “binary” relation between two activities. the
graphical representation of any template is a line for which
the beginning, end and middle part can be deﬁned. figure 4
shows that the “response” template is graphically represen ted
by a single line with a ﬁlled circle next to the ﬁrst activity
(“parameter 1”), a ﬁlled arrow symbol next to the second
activity (“parameter 2”) and without a special symbol in the
middle.furthermoreatextualdescriptionandthe ltlformu la
for “response” are deﬁned.
deﬁned constraint parameters can be used in ltl ex-
pressions, as shown in the lower part of figure 4. in the
ltl expression 2(a⇒3(b))for the “response” template
parameters “a” and “b” are used in the template formula to
deﬁne the desired relation between the parameters. when use d
in the model, formal parameters of the template are replaced
by real activities in the model (e.g., parameter “a” is repla ced
with activity “room service” and parameter “b” with activit y
“bill”).if a parameteris speciﬁed to be “branched”,thiswo uld
allow the parameter to be replaced with a conjunction of
several activities.
the“response”templateisan exampleof a binarytemplate,
i.e., it speciﬁes a relation between two activities. clearl y, it is
also desirable to deﬁne non-binary templates. for example,
it is possible to deﬁne unary templates, which involve only
2declare has been developed in a way that it allows for impleme n-
tation of speciﬁcation languages other than ltl.fig. 4. constraint template “response”
one activity (e.g, specifying that an activity has to execut ed at
least two times). declare aims at using templates with an
arbitrary number of parameters to allow for complicated spl its
andjoins, e.g., the n-out-of-msplit/join. currently,dec lare
partially supports such constructs and is being extended to
support templates with an arbitrary number of parameters.
note that declare uses somewhat more granular ap-
proach to parameters than shown in figure 4. written as it
is, parameters “a” and “b” are replaced by “a.completed”
and “b.completed”, respectively. this means, that when use d
in our example, the “response” template between activities
“room service” and “bill” speciﬁes a relationship between
events “room service.completed” and “bill.completed”. ho w-
ever, it is possible for a template to specify relations betw een
events of starting or canceling activities (e.g., 2(a.started ⇒
3(b.started ))).
different application domains can require a different set o f
constraint templates. therefore, declare facilitates the de-
ﬁnition of sets of constraint templates, also called languages .
in other words, declare is not a ﬁxed language but allows
for the deﬁnition of different languages. each language has an
unique name and is deﬁned by a set of constraint templates.
condec[26]isoneofthelanguagescreatedusingdeclare.
decserflow [5] is another language created using declare
tailoredtowardsthe speciﬁcationofweb services.condeca nd
decserflow are very similar. however, declare could be
used to deﬁne completely different languages with differen t
constraint templates, symbols, etc.
figure 5 shows that declare indeed allows for the
deﬁnition of different languages. here the link between a
language (in this case condec) and constraint templates (in
this case the list starting with “response”) is established . note
that in this paper, we often use the term “declare” to refer
to the condec languagerealized usingthe declare system.
b. process modeling
in section ii-a we described ﬁve constraints: c.1-5. now
we add these constraints to the model of figure 3 by using
fig. 5. deﬁning a language
constraint templates. to do this we need to map the textual
descriptions given in section ii-a onto predeﬁned constrai nt
templates. a constraint can be added to the model of figure 3
by selecting the appropriate template from the drop-down li st
of templates, and dragging it between the related activitie s.
theresultisshowninfigure6.thedeclareprocessmodel
in figure 6 consists of activities and some constraints betw een
activities. each of the constraints in figure 6 represents o ne
of the hotel rules mentioned earlier ( c.1-5).
c.1c.2
c.4
c.5c.3list of templates 
fig. 6. constraints in the hotel example
the number of constraints in a model is arbitrary. as
indicated before, the model of figure 3, which did not contai n
any constraint, is already an executable model. by adding
constraints to the model, we impose rules that users have to
follow during execution. clearly, these rules limit the all owed
behavior. in the next paragraph we describe the semantics of
each constraint depicted in figure 6.
because of the constraint “init” on the activity “register
client data” (rule (c.1)), users have to start each execution
with the activity “register patient”. it is still possible t o
execute this activity multiple times and at any moment durin g
the execution to change client data at later stages (e.g., th epreferred way of paying is changed).
before adding the “1..*” constraint on the activity “bill”
(rule(c.2)) it was possible to never execute this activity and
still complete the case. after adding the constraint, it bec ame
necessary to execute this activity at least once. this const raint
enables the receptionist to add various items to the bill (e. g.,
room service, additional cleaning, etc.) at any moment duri ng
the execution.
with the “response” constraint between activities “room
service” and “bill” (rule (c.3)) it is obligatorythat after every
execution of the activity “room service” at least one execut ion
of the activity “bill” follows. the constraint allows execu tion
of other activities between activities and “room service” a nd
“bill”. for example, it is possible that after the “room serv ice”
ﬁrst “register client data” is executed and only afterwards
“bill”. the same holds for the “response” constraint betwee n
activities “laundry service” and “bill” (rule (c.4)). the two
“response” constraints also allow users to wait and “bill” a t
once several “room services” and “laundry services”.
constraint “respondedexistence”between activities“che ck-
out” and “charge” (rule (c.5)) speciﬁes that if “check-out”
was executed then “charge” must have been executed before
or must be executed after “check-out”. other activities can be
executed between activities “check-out” and “charge”.
a process model containing multiple constraints is deﬁned
as a conjunctionof the constraints, i.e., actions of users d uring
execution must fulﬁll all the constraints.
c. mandatory and optional constraints
declare supports two types of constraints: mandatory
andoptional constraints. the system forces its users to fol-
low all mandatory constraints in the model. in figure 6 all
constraints are mandatory constraints. in case of optional con-
straints users may decide whether to follow the correspondi ng
rule or to violate it.
for example, in the hotel example every “room service”
and “laundry service” is billed because they impose additio nal
costs for the hotel. although “additional cleaning” impose s
additional cost, it is not necessarily billed. suppose that
managementofthehotelnoticedthatinsomecases“addition al
cleaning” is a consequence of irresponsible behavior. if th is
is the case, then the costs of cleaning should be billed. it is
up to the receptionist to decide in which cases “additional
cleaning” should be billed and in which not. this rule can
be implemented as an optional“response” constraint between
activities “additional cleaning” and “bill”. figure 7 show s this
rule as an optional constraint. note that the line is dashed t o
indicate that it is optional.
optional constraints are not enforced by declare system
during execution. when a user is about to perform an action
that violates an optional constraint, a warning about the
violation is presented and the user can decide whether to
continue with the action and violate the constraint or to can cel
the action and follow the constraint. the text of the warning
can be speciﬁed in the deﬁnition of the constraint. figure 8
shows the form for deﬁning a constraint in declare.
fig. 7. mandatory and optional constraints
fig. 8. settings for optional constraint
the form contains the name of the constraint. by default
this is the name of the template,but this name can be changed.
also, a condition for the constraint can be speciﬁed (e.g., a
constraint should hold only if “ price<1000”). moreover, the
constraint is either mandatory or optional. if the constrai nt
is optional, the information presented to users needs to be
speciﬁed. groups of constraints represent policies and can be
deﬁned on the system level in declare by specifying a
nameand descriptionfor each group.forexample,therecoul d
be groups like “tourism ministry policy”, “hotel policy”,
“personnel policy”, “billing policy”, etc. the appropriat e
group needs to be selected for each optional constraint. the
importance of the constraint is given by the “level” on a scal e
1-10.thehigherthelevelis,themoredangerousitistoviol ate
the constraint. finally, a context-related message is spec iﬁed
that gives more detailed instructions to users.
figure 9 shows the warning that a user will get when she
is about to close a case where activity “additional cleaning ”was not followed by activity “bill”. this warning contains
information about the billing policy, the violation level a nd
an advising message to help the user to decide weather to
violate this constraint or not.
fig. 9. violation warning for optional constraint
d. process execution
a model in declare is mapped onto a set of ltl formu-
las. based on these ltl formulas, automata are automaticall y
generated [16] to support enactment. many algorithms that
generate automata from ltl formulas have developed and
these are widely used in the ﬁeld of model checking [20].
declare uses an algorithm that creates ﬁnite-words au-
tomata [17] from ltl formulas of the constraints that are
used. these automata are used both to drive the execution and
to monitor the state of each constraint.
after process model is loaded in the framework tool (cf.
figure 1), users can execute the model in their worklists.
figure 10(a) shows the initial worklist for the hotel exampl e.
a list of all running cases (process instances, assignments ) is
shown on the left side of the screen. the process model of the
selected case is shown on the right side of the screen. after
the user starts an activity by double-clicking it, the activ ity is
openedin the panelunderthe model.althoughthe structureo f
the process model is the same as in the designer, the worklist
uses some additional symbols and colors to help users to
understand the current state of the model, the activities an d
the constraints.
first, each activity contains “start” (play) and “complete ”
(stop) icons, that indicate if users can start/complete the
activity at the moment.the initial state of the processinst ance
in figure 10(a) shows that it is only possible to start activi ty
“register client data”, because the corresponding symbol i s
enabled. starting and completing any of the other activitie s is
not possible, as indicated by the disabled icons. in additio n
to the two icons, all currently disabled activities are colo red
grey. this initial state of the process instance is caused by the
“init” constraint on the activity “register client data”, i .e., this
activity is the ﬁrst activity to be executed.
second, each constraint is colored to indicate its state.
constraints are rules that should be fulﬁlled at the end of
the execution. however, it is not realistic to expect that ea ch
constraint is fulﬁlled at each moment of time duringthe whol e
execution. generally, at any moment each constraint can bein one of the following states: (1) fulﬁlled– constraint is
represented by a greencolor, (2) temporarily violated , i.e.,
it can be fulﬁlled in the future – constraint is represented b y
aorangecolor, and (3) permanently violated , i.e., it cannot
be fulﬁlled in the future – constraint is represented by a red
color. for example, when the process instance of the hotel
example is started (before executing any activity), constr aint
“1..*” on the activity “bill” is not fulﬁlled because “bill” was
never executed. however, it is only temporarily violated, i .e.,
it can be fulﬁlled later (when the activity “bill” is execute d for
the ﬁrst time). therefore, it presented using an orange colo r.
all other constraints are fulﬁlled at this moment, as can be
seen fromtheir greencolor.naturally,declare will preven t
users from permanently violating mandatory constraints, i .e.,
only optional constraints can be “red”.
figure10(b)showsthestateofthecaseafterstartingactiv ity
“register client data”. three observations can be made here .
first, the activity is now open in the panel under the model.
second, now it is possible to start other activities in the ca se.
third, only constraint “1..*” of the bill is not yet fulﬁlled and
coloredinorange.thisconstraintcanbe satisﬁed byexecut ing
activity “bill”. figure 10(c) shows the state of the case aft er
executing “room service”. the “response” constraint betwe en
this activity and activity “bill” becomes temporally viola ted,
since it requires the execution of activity “bill” in the fut ure.
this is indicated by coloring the constraint orange. execut ing
activity “bill” results in the fulﬁlment of two constraints : (1)
the “response” constraint between activities “room servic e”
and “bill” and (2) the “1..*” constraint on the activity “bil l”,
as shown in figure 10(d).
depending on the state of its mandatory constraints, a
process instance has its own state, as shown by the color of
the instance in the list on the right side of the four worklist
windows in figures 10. the process instance is in the “green”
state if all its mandatory constraints are “green”. if at lea st
one mandatory constraint is “orange”, the process instance is
also “orange”.
e. changing process during execution
adaptivity is an important feature of ﬂexible wfmss [29].
adaptive systems allow changing the process model during
its execution. adaptivity is one of the main features of
declare; it is possible to change its declarative process
models during execution. not only it is possible to add,
delete (together with relating constraints) and change (da ta
elements used in) activities, but it is also possible to add,
remove and change (e.g., make optional, change condition)
constraints. before conﬁrming an adaptation, declare ver-
iﬁesthecomplianceofthechangedmodelandinstancehistor y,
i.e., history based errors are detected (cf. section ii-f). after
the adaptation, the changed model is re-initiated with the
procedure that is also used to start the process instance. th e
required automata are again generated for the new set of
constraints and the history of the instance is replayed on th ese
new automata.(a) the initial state
 (b) the state after “client registration”.
(c) the state after “room service”.
 (d) the state after “bill”.
fig. 10. execution of the hotel example
f. veriﬁcation of process models
theadditionofconstraintstoaprocessmodelindeclare
may cause errors that lead to problems at run-time. therefor e,
declare veriﬁes process models against three types of
errors and ﬁnds a minimal set of constraints that causes the
error. all models can be veriﬁed against dead activities and
conﬂicting constraints . in addition to this, when a model is
altered during its execution, it can be veriﬁed against history-
based errors .
1) dead activities: a dead activity is an activity that can
never be executed in the model. figure 11 shows the hotel
example with one additional constraint – the “responded ab-
sence” constraint between activities “check-out” and “cha rge”
speciﬁes that if activity “check-out” is ever executed, the n
activity “charge” must never be executed (neither before or
after “check-out”). if activity “check-out” would be execu ted
in themodel,it wouldnotbepossibleto fulﬁll bothconstrai nts
“responded existence” and “responded absence” between ac-
tivities “check-out” and “charge”. therefore, activity “c heck-
out” is a dead activity, i.e., it will never be possible to exe cute
this activity.
declare will detect this error during veriﬁcation as
shown in figure 12. on the left part of the screen a list of
fig. 11. activity “check-out” is dead
detectederrorsis shown. in this case, one “dead activity” e rror
is detected for activity “check-out”. the list on the right s ide
of the screen shows the minimal set of constraints that cause sthe selected error.
fig. 12. veriﬁcation result for dead activity
2) conﬂicting constraints: a set of constraints is conﬂict-
ingifthereexistsnoexecutionthatwouldfulﬁllallconstr aints.
if a constraint specifying that activity “check-out” has to
be executed at least once would be added to the model
in figure 11, the result would be a process model with a
conﬂict, as shown in figure 13. this is because there exists
noexecutionthat wouldsatisfy the followingthreeconstra ints:
“1..*” on activity “check-out”,“responded existence” bet ween
activities “check-out” and “charge”, and “responded absen ce”
between activities “check-out” and “charge”.
fig. 13. conﬂict
figure 14 shows the conﬂicting error that was detected in
declare during veriﬁcation.
fig. 14. veriﬁcation result for conﬂict
3) history based violations: as described in section ii-e,
declare models can be changed during the execution.
changes(especiallyaddingnewconstraints)canbe conﬂict ingwiththehistoryofthecase.forexample,assumethatactivi ties
“register client data”, “bill”, and “check-out” are execut ed in
the current process instance. at this point the receptionis t
decides that client should not “check-out” before activity
“charge” is executed, and adds a “precedence” constraint
between activities “check-out” and “charge” (see figure 15 ).
fig. 15. history violation
this adaptation is in conﬂict with the history of the case,
because activity “check-out” is already executed before ac tiv-
ity “charge”. declare will detect this error and inform the
user that the new constraint causes a history-based error, a s
shown in figure 16.
fig. 16. veriﬁcation result for history violation
iii. combining declare andyawl
this section shows how declare and yawl can be
combined to support arbitrary mixtures of loosely-structu red
and highly-structured processes.
declare is not particularly suitable for modeling large
and/orhighly-structuredprocesses.inbothcases,adecla re
model would have many constraints, which can easily cre-
ate problems. first, errors can be easily introduced during
process development when the number of constraints is high.
second, it is hard for users to understand the whole model
during execution if the model has too many constraints. in
addition, the performance of the system is poot for models
with many constraints, because the automata become too
large to be handled efﬁciently. therefore, we propose using
the yawl [1] workﬂow management system in combinationwith declare. yawl can easily deal with large highly-
structured processes and its service-oriented architectu re al-
lows for an easy integration.
we propose yawl for highly-structured processes and
declare for loosely-structured ones. the decomposition
of processes using declare and yawl can be two-fold,
i.e., a declare model can be a sub-process or super-
process of yawl model(s). figure 17 shows an example
of a decomposition of a large hotel process. first, a highly-
structured global process for managing rooms in a hotel is
developed in yawl – on the ﬁrst level of decomposition a
room is “booked”, “cleaned”, “rented”, and then “cleaned”
again. at this level, we decompose the task3“rent” to our
hotel example in declare (the second level). within this
declare model,we can specifythat activity“roomservice”
should invoke another highly-structured process in yawl,
where after the “order” is taken, it is “prepared”, “deliver ed”
and “registered” (the third level).
interface b 
fig. 17. a declaremodel serving both asasub-process and sup er-process
for yawl
to achieve this decomposition, declare communicates
with yawl via its “interface b”. yawl is developed using
a service oriented architecture where a yawl process can
serve both as a service consumer and as a service provider.
tasks in yawl may be subcontractedto another service. this
way yawl acts as a service consumer. in the context of
yawl, several services have been developed. for example,
thedefaultworklisthandlerisanexampleofaservicethanc an
communicatewith yawlvia“interfaceb”. otherservicesare
the sms service, worklet service [7], etc. from the viewpoin t
of yawl, declare is just another service that yawl can
use. moreover, yawl can also act as a service provider for
declare, i.e., an activity in declare can be subcon-
tracted to yawl by initiating a new process instance. this
can be mixed an arbitrary ways, e.g., yawl may subcontract
a task to declare, in the correspondingdeclare process
an activity is subcontracted to yawl, in the corresponding
yawl process a task is subcontracted to the worklet service,
etc. this allows for arbitrary mixtures of highly-structur ed
3for clarity we use different terms for the smallest unit of wo rk in
yawl and declare. the term taskis used to denote the smallest unit of
work yawl, i.e., a task is not decomposed further in yawl but m ay refer
to a declare process. declare uses the term activityfor the smallest
unit of work.processes(yawl), loosely-structuredprocesses (declare ),
emerging/rule-based processes (e.g., worklets [7]), etc.
iv. analysis of pastexecutions
wfmss can execute a variety of process instances over
time. most systems record detailed logs about all completed
executions. data stored in such logs can be various: start-
ing cases; starting, completing, canceling activities; ch anging
value of data elements; deadline expiry, etc. these logs can be
used for discovering and analysis of executed process model s
–process mining [6]. process mining tools (e.g., prom [11])
use various techniques of log analysis to discover the proce ss
model, verify certain properties of the model, discover the
social network, etc.
declare storesall eventsrelatedtoactivitiesin executio n
logs using the mxml format [10]. this format is also used
by the prom tool and thus this export allows for all kinds
of analysis techniques ranging from locating bottlenecks i n
a process to constructing a social network for the actors
involved.amongst others,prom has a featurethat can be used
to verify various properties of executions stored in logs – t he
ltl checker . ltl checker enables veriﬁcation of logs against
properties speciﬁed in linear temporal logic. for example, it
is possible to verify if a “junior ofﬁcer has approved a claim
worth more than 10000 this year”. declare enables two
types of export to ltl checker readable ﬁles, as shown in
figure 18.
user
log declare prom 
analyst 
ltl 
property files ltl 
checker constraint templa
tesprocess 
mo
del
fig. 18. declare is able to export event logs, models, and con straint
templates to prom
first, constraint templates can be exported to ltl checker
ﬁles from declare. these ﬁles can be used to verify
properties in logs in an generic way, e.g., the “response”
property (template) can be checked against different pairs
of activities. second, a declare process model can be
exported to an ltl checker ﬁle. using this ﬁle, process logs
can be veriﬁed against constraints from the process model,
e.g., the “response” property (existing constraint) can on ly be
checked against existing activities “room service” and “bi ll”.
v. usersupport by recommendations
despite manybeneﬁts that ﬂexibility brings,its major draw -
back it the lack of supportthat users get in ﬂexible systems.
support of a wfms can be seen as an extension in which the
system is able to make decisions for the user. figure 19 shows
ﬂexibility and support as two opposing properties, i.e., ri gidsystems provide support by sacriﬁcing ﬂexibility, and ﬂexi ble
systems provide ﬂexibility by sacriﬁcing support. the vari ety
of options in ﬂexible systems makes it difﬁcult for users to
make the right decision. for example, an inexperienced user ,
or a user working on an exceptional case will ﬁnd it difﬁcult
to decide between many options, and would greatly beneﬁt
from support.
decision making low high 
flexibi
lity support
system 
user 
fig. 19. trade-off: ﬂexibility vs. support [10]
supportforﬂexiblesystemsshouldfocusonoffering recom-
mendations fordecisions,ratherthantakingthesedecisionsfor
the user. recommendations are generated based on past expe-
riences and a speciﬁc goal. declare stores past experiences
in mxml format. based on the goal of a user/organization,
past experiencescan be rated in terms of their desirability . for
example, the goal may be to minimize throughput time and,
therefore, cases which were handled quickly are considered
positive examples. the recommendation service of prom [11]
generates recommendationsfor declare based on the com-
parison of the current process instance ( partial instance ) with
past executions ( logs), while favoring those executions that
satisfy the speciﬁed goal, as shown in figure 20. currently,
various recommendation algorithms have been implemented
in prom but outside the scope of this paper.
user
log declare prom partial instance 
goalexecution 
recommendation recommendation 
fig. 20. prom as recommendation provider for declare
declare does not enforce recommendations to users.
on the contrary, recommendations are presented to users as
independent information, as shown on the right side of the
figure 21. the user can choose to follow or not to follow the
recommendation to “start activity bill”.
vi. relatedwork
manyapproachesaim at “relaxing”the rigid natureof tradi-
tional process modeling languages and workﬂow management
systems. these process models precisely prescribe how the
process should be executed and workﬂow systems force users
to execute these models step-by-step.
fig. 21. recommendation is to start activity “bill”
approacheslike case-handlingand adaptivesystems change
the way the system managesthe executionof rigid models.an
example of a case-handling system is flower [25]. flower
does not enforce a strict execution of process models, but
allows users to open tasks that should be executed later
(accordingtothemodel),re-dotasksthatwereexecutedbef ore
or even skip tasks that should be executed. when working
with adaptive systems like adept [29], users can change the
process model while executing the model by adding, moving
or deleting activities in the model. both approaches use
imperative models and they consider variations in executio ns
to be exceptions, which can have negative consequences. for
example, if a user of a case-handlingsystem wants to re-do an
activity that was already executed before, she will also hav e
to execute all activities that followed it. frequently chan ging
processmodelsinadaptivesystemsaretimeconsumingandre -
quireusersto be expertsin processmodeling.declare uses
a different approach that does not require users to redesign
the process to deviate from the normal ﬂow. deviations are
not seen as exceptions and are included the allowed behavior .
moreover, unlike case handling, there is not a ﬁxed set of
automatically included deviations (e.g., skip and redo).
loosely-structuredprocesscan be handled using declarati ve
languages, which “describe the dependency relationships b e-
tween tasks, rather than procedurally describing sequence s of
action” [12]. declare is not the ﬁrst attempt to use a more
declarative language [12], [23], [30]. instead of modeling a
detailed control-ﬂow, declarative languages propose mode ling
constraints that (as rules that should be followed) drive th e
model enactment [12], [23], [30]. constraints describe de-
pendencies between model elements and are speciﬁed using
pre and post conditions for target task [30], dependencies
between states of tasks (enabled, active, ready, etc.) [12] or
various model-related concepts [23]. declare distinguish es
itself from these earlier approaches in many respects. for
example, declare is based on ltl, it does not use a
ﬁxed language and users can extend the language, it supports
optional and mandatory constraints, it supports veriﬁcati on, it
can supportson-the-ﬂymodel changes,and it is equippedwit h
a recommendation service.
this paper builds on two papers: [26] and [5]. [26] presents
the condec language and [5] introduces the decserflow lan-guage. the ﬁrst language is tailored towards teamwork while
the second is tailored towards the speciﬁcation of services .
these two papers do not describe the declare tool in any
detail. in fact most of the functionality described in this p aper,
wasrealizedafterthepublicationof[5],[26].moreover,t hein-
novative features of declare in relation to process mining,
recommendation, veriﬁcation, optional constraints, and m odel
change have not been described before. this illustrates the
original contribution of the current paper.
vii. future work
currently, declare uses a simple constraint speciﬁcation
approach that considers only events regarding execution of
activities (the control-ﬂow). this can be extended by using
other process model elements (like user roles, data element s,
etc.) in the constraint speciﬁcation. for example, it can be
necessary to specify a constraint that prevents one user to
execute two crucial activities in the process model (the so-
called “four eyes principle”), e.g., it is not possible that the
same person who ﬁled a request for salary rase approves this
request. here these is also a link to the topic of semantical
correctness presented in [22].
another interesting extension would be adding deadlines
in declare process models. for example, the “response”
constrainttemplatecanbeextendedwithadeadline:“a”has to
be followed with “b” within ﬁve days. to introducedeadlines ,
a logic extended with time dimension and time automata can
be used (e.g., extended timed temporal logic [8]).
declare iscurrentlybeingextendedto supportconstraint
templateswith multiple parameters,instead of only one or t wo
parameters.thiswill enablecreatingmoreadvancedtempla tes
and constraints involving more that two activities.
viii. c onclusions
the declare system supports loosely-structured
processes without sacriﬁcing useful features that traditi onal
workﬂow management systems have. declare uses a
temporal logic (ltl) as a basis and combines this with
an extendible graphical language. in fact, declare can
support multiple languages in parallel and end users can mak e
domain speciﬁc languages. to support enactment, declare
automatically constructs automata to guide (or force) to us er.
declare connects to the workﬂow management system
yawl and the process mining tool prom. through yawl, it
becomes possible to support large processes containing mix -
tures of loosely-structured and highly-structured fragme nts.
the connection to prom allows for the analysis of processes
supported by declare. moreover, using prom’s recom-
mendation service it is possible guide users based on past
experiences. this way ﬂexibility and learning are combined
in a powerful manner.
the declare provides many innovative features and can
be downloaded from http://is.tm.tue.nl/staff/mpesic/de clare.
htm.references
[1] w.m.p. van der aalst, l. aldred, m. dumas, and a.h.m. ter h ofstede.
design and implementation of the yawl system. in a. persson a nd
j. stirna, editors, advanced information systems engineering, proceed-
ings of the 16th international conference on advanced infor mation
systems engineering (caise’04) , volume 3084 of lecture notes in
computer science , pages 142–159. springer-verlag, berlin, 2004.
[2] w.m.p. van der aalst and k.m. van hee. workﬂow management:
models, methods, and systems . mit press, cambridge, ma, 2002.
[3] w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszews ki, and a.p.
barros. workﬂowpatterns. distributed andparalleldatabases , 14(1):5–
51, 2003.
[4] w.m.p. van der aalst and s. jablonski. dealing with workﬂ ow change:
identiﬁcation of issuesand solutions. international journal ofcomputer
systems, science, and engineering , 15(5):267–276, 2000.
[5] w.m.p. van der aalst and m. pesic. decserflow: towards a t ruly
declarative service flow language. in m. bravetti, m. nunez , and
g. zavattaro, editors, international conference on web services and
formal methods (ws-fm 2006) , volume 4184 of lecture notes in
computer science , pages 1–23. springer-verlag, berlin, 2006.
[6] w.m.p. van der aalst, b.f. van dongen, j. herbst, l. marus ter,
g. schimm, and a.j.m.m. weijters. workﬂow mining: a survey o f
issues and approaches. data and knowledge engineering , 47(2):237–
267, 2003.
[7] m. adams, a.h.m.ter hofstede, d. edmond, and w.m.p.van d er aalst.
worklets: a service-oriented implementation of dynamic ﬂe xibility in
workﬂows. in r. meersman and z. tari et al., editors, on the
move to meaningful internet systems, otm confederated inte rnational
conferences, 14th international conference on cooperativ e information
systems (coopis 2006) , volume 4275 of lecture notes in computer
science, pages 291–308, berlin, 2006. springer-verlag.
[8] a. bouajjani, y. lakhnech, and s. yovine. model-checkin g for extended
timed temporal logics. in ftrtft ’96: proceedings of the 4th
international symposium on formal techniques in real-time and fault-
tolerant systems , pages 306–326, london, uk, 1996. springer-verlag.
[9] c.bussler,s.jablonski, and h.schuster. anewgenerati on ofworkﬂow-
management-systems: beyond taylorism with mobile. sigois bull. ,
17(1):17–20, 1996.
[10] b.f. van dongen and w.m.p. van der aalst. a meta model for process
mining data. in j. casto and e. teniente, editors, proceedings of the
caise’05 workshops (emoi-interop workshop) , volume 2, pages
309–320. feup, porto, portugal, 2005.
[11] b.f. van dongen, a.k. alves de medeiros, h.m.w. verbeek , a.j.m.m.
weijters, and w.m.p. van der aalst. the prom framework: a new era
in process mining tool support. in g. ciardo and p.darondeau , editors,
application and theory of petri nets 2005 , lecture notes in computer
science, pages 444–454. springer-verlag, berlin, 2005.
[12] p. dourish, j. holmes, a. maclean, p. marqvardsen, and a . zbyslaw.
freeﬂow: mediating between representation and action in wo rkﬂow
systems. in cscw ’96: proceedings of the 1996 acm conference on
computer supported cooperative work , pages 190–198, new york, ny,
usa, 1996. acm press.
[13] m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-
aware information systems . wiley & sons, 2005.
[14] d. georgakopoulos. teamware: an evaluation of key tech nologies and
open problems. distributed and parallel databases , 15(1):9–44, 2004.
[15] d. georgakopoulos, m. hornick, and a. sheth. an overvie w of work-
ﬂow management: from process modeling to workﬂow automatio n
infrastructure. distributed and parallel databases , 3:119–153, 1995.
[16] r. gerth, d. peled, m.y. vardi, and p. wolper. simple on- the-fly
automatic veriﬁcation of linear temporal logic. in proceedings
of the fifteenth ifip wg6.1 international symposium on prot ocol
speciﬁcation, testing and veriﬁcation xv , pages 3–18, london, uk,
1996. chapman & hall, ltd.
[17] d. giannakopoulou and k. havelund. automata-based ver iﬁcation of
temporalproperties onrunning programs. in ase’01:proceedings ofthe
16th ieee international conference on automated software e ngineering ,
page 412, washington, dc, usa, 2001. ieee computer society.[18] p. heinl, s. horn, s. jablonski, j. neeb, k. stein, and m. teschke. a
comprehensive approach to ﬂexibility in workﬂow managemen t systems.
inwacc ’99: proceedings of the international joint conferenc e on work
activities coordination and collaboration , pages 79–88, new york, ny,
usa, 1999. acm press.
[19] s.jablonski and c.bussler. workﬂow management: modeling concepts,
architecture, and implementation . international thomson computer
press, london, uk, 1996.
[20] e.m. clarke jr., o. grumberg, and d.a. peled. model checking . the
mit press, cambridge, massachusetts and london, uk, 1999.
[21] m. klein, c. dellarocas, and a. bernstein, editors. adaptive workﬂow
systems, volume 9of special issueofthejournal ofcomputer supported
cooperative work , 2000.
[22] l. thao ly,s. rinderle, and p. dadam. semantic correctn ess in adaptive
process management systems. in s. dustdar, j.l. fiadeiro, a nd a.p.
sheth, editors, business process management, 4th international confer-
ence, bpm 2006, vienna, austria, september 5-7, 2006, proce edings,
volume 4102 of lecture notes in computer science , pages 193–208.
springer, 2006.
[23] p. mangan and s. sadiq. on building workﬂow models for ﬂe xible
processes. in adc ’02: proceedings of the 13th australasian database
conference , pages 103–109, darlinghurst, australia, australia, 2002 .
australian computer society, inc.
[24] r. milner. communicating and mobile systems: the pi-calculus .
cambridge university press, cambridge, uk, 1999.
[25] pallas athena. flower user manual . pallas athena bv, apeldoorn,
the netherlands, 2002.
[26] m. pesic and w.m.p.van der aalst. a declarative approac h for flexible
business processes. in j. eder and s. dustdar, editors, business process
management workshops, workshop on dynamic process managem ent
(dpm 2006) , volume 4103 of lecture notes in computer science , pages
169–180. springer-verlag, berlin, 2006.
[27] h.reijers, j.rigter, and w.m.p.van der aalst. thecase handling case.
international journal of cooperative information systems , 12(3):365–
391, 2003.
[28] w. reisig and g. rozenberg, editors. lectures on petri nets i: basic
models, volume 1491 of lecture notes in computer science . springer-
verlag, berlin, 1998.
[29] s. rinderle, m. reichert, and p. dadam. flexible suppor t of team
processes by adaptive workﬂow systems. distrib. parallel databases ,
16(1):91–116, 2004.
[30] j. wainer and f. de lima bezerra. groupware: design, implementation,
and use, volume 2806, chapter constraint-based flexible workﬂows ,
pages 151 – 158. springer berlin / heidelberg, 2003.