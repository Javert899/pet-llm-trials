conformance analysis of asml’s test process
a. rozinat1, i.s.m. de jong2, c.w. g¨ unther1, and w.m.p. van der aalst1
1department of information systems, eindhoven university o f technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands
{a.rozinat,c.w.gunther,w.m.p.v.d.aalst }@tue.nl
2asml, p.o. box 324, nl-5500 ah, veldhoven, the netherlands
ivo.de.jong@asml.com
abstract. process mining allows for the automated discovery of proces s
models from event logs. these models provide insights and en able vari-
ous types of model-based analysis. however, in many situati ons already
some normative process model is given, and the goal is not to d iscover
a model, but to check its conformance. the process mining fra mework
prom provides a conformance checker able to investigate and quantify
deviations between the real process (as recorded in the even t log) and
the modeled process. the conformance checker is one of the fe w tools
available today that is able support regulatory compliance , i.e., ensuring
that organizations and people take steps to comply with rele vant laws,
regulations, and procedures. in this paper, we report on a ca se study
where the prom framework has been applied to the test process es of
asml (the leading manufacturer of wafer scanners in the worl d). in
this case study, we focus on the conformance aspect and compa re the
test process as it is really executed to the idealized refere nce model that
asml is using to instruct their test teams. this revealed tha t the real
process is much more complicated than the idealized referen ce process.
moreover, we were able to suggest concrete improvement acti ons for the
test process at asml.
keywords: process mining, conformance checking, case study
1 introduction
corporate scandals have triggered an increased interest in corporate governance,
risk management, and regulatory compliance. as a result new regulations such
as the sarbanes-oxley act, basel ii, hipaa, etc. were introd uced. some of the
key elements are: accountability, auditability, privacy, documentation, policy,
and manageability of information. in this paper, we focus on compliance. in
particular, we focus on the question “do organizations and people do what is
documented in process models?” . to address this question we conduct a case
study where we apply prom’s conformance checker [22] to one of the processes
of asml.
to position our work, we ﬁrst introduce process mining . the basic idea of
process mining is to discover, monitor and improve realprocesses by extracting2
knowledge from event logs. today many of the activities occu rring in processes
are either supported or monitored by information systems. c onsider for example
erp, wfm, crm, scm, and pdm systems to support a wide variety o f business
processes while recording well-structured and detailed ev ent logs. however, also
high-tech devices such as x-ray machines, web services, etc . record events. all of
these applications have in common that there is a notion of a process and that the
occurrences of activities are recorded in so-called event l ogs. assuming that we
are able to log events, a wide range of process mining techniques comes into reach.
the basic idea of process mining is to learn from observed exe cutions of a process.
process mining can be used to (1) discover new models (e.g., constructing a
petri net that is able to reproduce the observed behavior), ( 2) to check the
conformance of a model by checking whether the modeled behavior matches t he
observed behavior, and (3) to extend an existing model by projecting information
extracted from the logs onto some initial model (e.g., show b ottlenecks in a
process model by analyzing the event log). all three types of analysis have in
common that they assume the existence of some event log .
wafer scanner
(process)
modelevent
logsmodels
analyzes
discoveryrecords 
eventstest process
extensionconformancetest team
fig.1. based on the event logs of the wafer scanners, three classes o f process mining
techniques are possible: (1) “discovery”, (2) “conformanc e”, and (3) “extension”
in this paper, we focus on conformance checking and apply pro m’sconfor-
mance checker [22] to the test process of asml. asml is the world’s leading
manufacturer of chip-making equipment and a key supplier to the chip industry.
asml designs, develops, integrates and services advanced s ystems to produce
semiconductors, e.g., wafer scanners that print the chips. there is an ongoing
eﬀort to reduce the line width on silicon wafer to enhance the performance of
the manufactured semi-conductors. every new generation of wafer scanners is
balancing on the border of what is technologically possible . as a result, the test-
ing of manufactured wafer scanners is an important but also t ime-consuming
process. every wafer scanner is tested in the factory of asml . when it passes
all tests, the wafer scanner is disassembled and shipped to t he customer where3
the system is re-assembled. at the customer’s site, the wafe r scanner is tested
again. clearly, testing is a time-consuming process and tak es several weeks at
both sites. since time-to-market is very important, asml is involved in an on-
going eﬀort to reduce the test period. to assist asml in these eﬀorts, we applied
process mining techniques to their test processes. rather t han focusing on fault
detection, the subject of study is here the test process itse lf.
at any point in time, asml’s wafer scanners record events tha t can easily be
distributed over the internet. hence, any event that takes p lace during the test
process can be recorded easily. the availability of these ev ent logs and the desire
of asml to improve the testing process triggered the case stu dy reported in
[24]. using process discovery, we tried to answer the questi on “how are the tests
actually executed?”, i.e., based on the event logs we automa tically constructed
process models showing the ordering and frequency of test ac tivities. in this pa-
per, we then compared them to the idealized reference model. this revealed that
the real process is much more complicated than the idealized reference model
that asml is using to instruct the test teams. the reference m odel shows a
rather structured process while in reality the testing proc ess requires much more
ﬂexibility. using conformance checking techniques, we inv estigated this further
by answering the question “how compliant are the actual test executions to the
reference process?”. through conformance checking we were able to quantify
and pinpoint the deviations of the real test process from the idealized reference
model. for the case study we used our prom framework3. prom is open source
and uses a plug-able architecture, e.g., developers can add new process mining
techniques by adding plug-ins without spending any eﬀorts o n the loading and
ﬁltering of event logs and the visualization of the resultin g models [1]. version
5.0 of prom provides 230 plug-ins. for example, there are mor e than 15 plug-ins
to discover process models from event logs.
the remainder of this paper is organized as follows. section 2 reviews related
work both in process mining and the test process optimizatio n domains. next,
the context of the case study is described in more detail in se ction 3. section 4
presents the results of this study, and concrete improvemen t actions for the
asml test process are proposed in section 5. section 6 conclu des the paper.
2 related work
since the mid-nineties several groups have been working on t echniques for pro-
cess mining [3, 4,10], i.e., discovering process models bas ed on observed events.
in [2] an overview is given of the early work in this domain.
the paper builds on the conformance checking techniques pre sented in [22].
these techniques are inspired by the ﬁtness function used in genetic process
mining [20]. also related is the work by cook [9,8] where the e vent streams of
a process model and a log are compared based on string distanc e metrics.
process mining can be seen in the broader context of business process intel-
ligence (bpi) and business activity monitoring (bam). in [1 4,25] a bpi toolset
3prom can be freely downloaded from http://prom.sf.net/ .4
on top of hp’s process manager is described. the bpi toolset i ncludes a so-called
“bpi process mining engine”. in [21] zur m¨ uhlen describes t he pisa tool which
can be used to extract performance metrics from workﬂow logs . similar diag-
nostics are provided by the aris process performance manage r (ppm) [18].
it should be noted that bpi tools typically do not allow for pr ocess discovery
and conformance checking, and oﬀer relatively simple perfo rmance analysis tools
that depend on a correct a-priori process model [17]. in [5] i t is suggested that
database technology can play an important role in assisting compliance with the
internal control provisions of sox.
most of the work on conformance checking has been done on mode l anal-
ysis without taking into account event logs. for example, in [13] it is checked
whether business processes are compliant with business con tracts, and in [12] a
non-monotonic deontic logic of violations is used to detect all obligations that
will not necessarily be fulﬁlled by executing the model. in [ 19], the authors in-
troduce opal, a compliance-checking framework, and relate d tools, including a
static method to check business process models against comp liance rules. in [11]
semantically annotated process models and formal represen tations of compliance
requirements are compared for auditing bpmn process models for compliance
with legislative/regulatory requirements, and for explor ing alternative modiﬁ-
cations to restore compliance in the event that the processe s are found to be
non-compliant.
the conformance checking techniques used in this paper are g eneric and can
be applied to various types of processes. hence, it can be use d to analyze the logs
of erp, wfm, crm, scm, and pdm systems. however, in this paper we apply
our techniques to a particular type of process: testing asml ’s wafer scanners. see
[7, 6] for more information on testing and test design in this particular setting.
the case study reported in [24] already explores the applica bility of process
mining to improve asml’s test process, and, for example, ana lyzes idle times to
shorten the time-to-market. in this paper, we investigate t he diﬀerences between
the actual, executed test sequences and the planned test seq uences in more detail.
3 case study
this section introduces the case study where process mining was applied to the
test process of asml’s wafer scanners. after describing the test process of a
wafer scanner in more detail (section 3.1), we look at the log data recorded
during these tests (section 3.2). the event logs serve as inp ut for our process
mining techniques and the results of their analysis are desc ribed in section 4.
3.1 the test process
the whole test process of a waver scanner at asml consists of t hree phases: (1)
the calibration phase, (2) the test phase (the actual testin g), and (3) the ﬁnal
qualiﬁcation phase. the whole process takes several weeks. when ﬁnished, the
wafer scanner is partly taken apart and shipped to a customer . a part of the5
calibration and test phase is repeated at the customer site, after re-assembling
the wafer scanner.
why is this test process so important for asml? asml operates in a market
where the time-to-market of system enhancements and the tim e-to-market of
new system types is critical. wafer scanners are continuous ly enhanced. as a
result, the number of manufactured wafer scanners of a singl e type is typically
less than 50. with each new type, parts of the calibration and test phase are
adjusted. on average ﬁve diﬀerent system types are manufact ured in parallel.
the short time-to-market, the constant innovation, and the high value of wafer
scanners make testing very important. spending too much tim e on testing will
result in high inventory costs and lost sales. however, inad equate tests will result
in systems which are malfunctioning.
fig.2. example sequence of three job steps with a synchronization p oint
sets of calibration and test actions are grouped into so-cal ledjob steps . these
job steps are executed according to a certain sequence. only large changes in the
system design result in changes in the job step sequence, so t he job step sequence
can be considered a ﬁxed sequence across diﬀerent systems. s ome of these job-
steps can be executed independently of each other. an exampl e sequence of three
job steps is depicted in figure 2. note that in asml such struc tures are referred
to as “sequences”. however, strictly speaking these are pro cess models rather
than sequences. the synchronization point syncenforces that both job step a
and job step b must be ﬁnished before job step c can start. each calibration
action or test case can fail. some of the causes for test failu re can require a
replacement of a faulty hardware component. the duration of this replacement
can take up to hours or longer. if such a failing test is in the e xample job step
a, then the independent job step b can be started to ensure max imal progress.
when the replacement hardware becomes available, either jo b step b is ﬁnished
ﬁrst and then job step a is ﬁnished, or the other way around. jo b step c is
started when job step a and b are both ﬁnished. note that a fail ure in a test
case in job step c results in no activity on the system (idle ti me) until the
malfunctioning part of system is ﬁxed and testing can contin ue.6
some of the causes for a failure can be ﬁxed immediately. for e xample, some
parameters in the system can be out of speciﬁcation. this mea surement infor-
mation can now be used to adopt the control set-points in the s ystem. after a
second measurement, the parameters can be within speciﬁcat ion and the test
passes. most of the software which executes the tests is cons tructed such that
this fast-ﬁx loop is automated. testing, calibration and re testing is performed
in a single test. finally, a change in low-level machine para meters, because of
a hardware replacement, can cause a re-execution of a previo us job-step. for
instance, the proﬁle of some of the mirrors in a wafer scanner are measured and
stored in x,y and z directions. this proﬁle information is us ed in all positioning
calibrations, such that the errors caused by the non-ﬂat mir rors are minimized.
replacing these mirrors results in a new proﬁle. for this rea son, a large set of job
steps needs to be redone if a faulty mirror is replaced in one o f the last job steps
in the sequence. in summary, job steps are executed accordin g to a ﬁxed sequence
for a set of machine types. the sequence allows variation of t he detailed tests
within the limits of the synchronization points. the actual execution of tests
results in failing test cases, which can result in a lengthy r e-test of parts of the
sequence depending on the failure at hand. for asml, the goal is to minimize
the waiting time for a hardware ﬁx (idle time) and to reduce th e re-execution
of parts of the job-step sequence. this goal could be easily m et by testing all
components and building blocks thoroughly before and durin g system assembly.
however, the increase in test eﬀort would result in an increa se of the total test
duration and therefore an increase in time-to-market. this is the main reason
that testing everything thoroughly beforehand is not consi dered a solution, so
the main goal is a reduction of the duration of the test proces s and not cutting
costs.
3.2 log data and conversion
each wafer scanner in the asml factory produces a log of the so ftware tests
which are executed. the manual assembly and calibration act ions are not logged
and appear as idle time in this log. the wafer scanner is calib rated and tested
using calibration and performance software, indicated in t he logging as a four-
letter code. the logging contains the start and stop moment o f each test. the
idle time, i.e., the time between stop of the previous test an d the start of the next
test, is not speciﬁed in detail. this idle time has a number of causes, ranging
from inexperienced operators reading the procedures, the e nd of the automated
test queue during the night to diagnosing a problem, or waiti ng for additional
parts. some parts of the test sequence are executed in an auto mated fashion.
the operator starts a test queue which contains a set of test c ases which are
executed in a sequence. this test queue can also contain part of the recovery
and retry sequence for certain failing test cases. the recov ery or retry tests are
executed depending on the outcome of a test in the queue.
an example fragment of the test log of one of the wafer scanner s is depicted
in figure 3(a). each line corresponds to the execution of one test. the number
at the beginning of the line identiﬁes the machine (i.e., the wafer scanner) that is7
(a) fragment of the original log 
data. each line corresponds to 
a test execution with start and 
end time 
(b) log fragment in mxml 
format. a separate audit trail 
entry is created for the start 
and the end of each test1596,31-01-2006 17:33:13,31-01-2006 17:33:39,pola 
1596,31-01-2006 17:33:50,31-01-2006 17:34:46,oswl 
1596,31-01-2006 17:34:48,31-01-2006 17:35:10,ossp 
1596,31-01-2006 17:36:18,31-01-2006 17:36:49,ahzi 
1596,31-01-2006 17:42:18,31-01-2006 17:43:25,dsna 
1596,31-01-2006 17:43:39,31-01-2006 17:44:56,ahzi 
1596,31-01-2006 17:44:57,31-01-2006 17:59:10,svei 
1596,01-02-2006 07:15:37,01-02-2006 07:33:25,svei 
1596,01-02-2006 07:35:00,01-02-2006 07:53:24,scei 
1596,01-02-2006 07:53:25,01-02-2006 07:54:58,yhlh 
1596,01-02-2006 07:54:59,01-02-2006 07:57:41,ahhj 
1596,01-02-2006 07:57:42,01-02-2006 08:04:40,ahca <processinstance id="1596" description="test instan ce 1596">
  ... 
<audittrailentry>
<workflowmodelelement>oswl</workflowmodelelement>
<eventtype>start</eventtype>
<timestamp>2006-01-31t17:33:50.000+01:00</timestamp >
<originator>unknown</originator>
  </audittrailentry>
<audittrailentry>
<workflowmodelelement>oswl</workflowmodelelement>
<eventtype>complete</eventtype>
<timestamp>2006-01-31t17:34:46.000+01:00</timestamp >
<originator>unknown</originator>
</audittrailentry>
  ... 
</processinstance>
fig.3. converting the log into the mxml format
tested. afterwards the start time, the completion time, and the four-letter code
for the executed test are recorded.4
to analyze the log data with prom we had to convert them into th e mxml5
format. this was realized by a custom-built converter plug- in for the prom import
framework6. prom import facilitates log transformation tasks and provides con-
verter plug-ins for a wide variety of systems to the xml forma t used by prom
[15]. in the mxml format, a log is composed of process instanc es (i.e., cases)
and within each instance there are audit trail entries (i.e. , events) with various
attributes. these attributes refer to, for example, data ﬁe lds, timestamps, or
transactional information (i.e., whether the activity was scheduled, started, or
completed). depending on the kind of information that is in t he log, we may
be able to answer diﬀerent questions about the process. figu re 3(b) depicts the
mxml log fragment for the highlighted test from figure 3(a). one can see that
the start and the completion of the test are captured by separ ate audit trail en-
tries (including the corresponding timestamps), and that t he enclosing process
instance (i.e., the case) corresponds to the tested machine .
note that the logging takes place on the test-code level, and that there is
no reference to the job step in whose context the test is perfo rmed. however, in
addition to the log data and the job step reference sequence, asml also provided
us with an additional document specifying which test codes s hould be executed
in which job step. in this mapping, there are a number of tests that appear in
more than one job step (i.e., are executed in diﬀerent phases of the test process).
4 conformance analysis results
in the following, we provide a summary of the results from ana lyzing the test
process execution logs. (more details about the speciﬁc pro cess mining tech-
niques and used prom plug-ins can be found in our technical re port [23].) in
section 5, these results are then evaluated from an asml pers pective and con-
crete improvement actions are proposed.
in most domains, we usually see a large number of relatively s hort log traces,
i.e., many process instances with just a few events. for exam ple, when looking
4note that both the actual machine numbers and the four-lette r test codes have been
anonymized for conﬁdentiality reasons.
5the xml schema deﬁnition is available at http://www.processmining.org/ .
6promimport can be freely downloaded from http://promimport.sf.net/ .8
at processes related to patient ﬂows, insurance claims, tra ﬃc ﬁnes, etc., then
there are typically thousands of cases each containing less than 50 events. when
we examine the log, it becomes clear that this test process ha s very diﬀerent
characteristics, since there are just a few cases (i.e., mac hines) but for each
machine there may be thousands of log events. in the initial d ata set we faced
process instances that contained more than 50000 log events (each indicating
either the start or the completion of a speciﬁc test). as ment ioned earlier, the
test process of a wafer scanner lasts for several weeks and is partly repeated
after the machine has been re-assembled at the customer, thu s explaining the
huge number of events per machine. from a larger set of machin es we selected 24
machines that fulﬁlled our criteria: (1) the test process ne eded to be completed,
(2) only include the test period on the asml (and not the custo mer) site, (3)
belong to the same family (recall that typically not more tha n 50 wafer scanners
of the same type are produced), and (4) not be a pilot system (a s a pilot system
is used for development testing and not for manufacturing qu aliﬁcation). these
24 cases comprise 154966 log events in total, and the number o f log events per
process instance (i.e., the length of the executed test sequ ence) ranges from
2820 to 16250. finally, we can see that there are 720 diﬀerent types of audit
trail entries in the log, which corresponds to 360 diﬀerent f our-letter test codes
as each test is captured by both a ‘start’ and ‘complete’ even t.
furthermore, we are interested in analyzing the job steps, i .e., the test phases
that can be associated to the reference sequence. to be able t o analyze the log
on the job-step level, we ﬁrst have to apply certain ﬁltering techniques. recall
that there is no information about job steps recorded in the l og, but that we
have obtained a document specifying which tests need to be ex ecuted for each
job step. in this mapping, there are 184 out of the 360 detecte d test codes
associated to a job step. this means that 176 of the four-lett er codes cannot be
connected to a speciﬁc job step (in the remainder of this pape r we call them
“unmapped” codes). they mainly correspond to additional (m ore speciﬁc) tests
that are executed as part of the diagnosis process after a fai lure. at the same
time, there are 49 out of the 184 mapped test codes that are ass ociated to more
than one job step, i.e., they occur in diﬀerent phases of the t est process (in the
remainder we call them “multiple” codes). the rest of the fou r-letter codes (i.e.,
135 test codes) can be unambiguously mapped onto a speciﬁc jo b step.
in figure 4 we show as an example how a part of the log fragment f rom
figure 3 is transferred to the job-step level7using a combination of multiple log
ﬁlters. as a ﬁrst step, we mapped each of the unambiguous test codes onto their
corresponding job step identiﬁer, or the ‘multiple’ or ‘unm apped’ category if this
was not possible. for example, figure 4 shows that the tests ‘ oswl’, ‘ossp’,
and ‘ahzi’ are associated to the job step ‘e’, while the test ‘ dsna’ cannot be
mapped to any job step (i.e., ‘unmapped’). as a next step, we a bstracted from
all events that occurred between the ﬁrst and the last event b elonging to the
same job step in a row. for example, in figure 4 only the beginn ing of the ﬁrst
7note that, again, the actual job step names have been replace d by simple letter codes
for conﬁdentiality reasons.9
oswl
startossp
startahzi
startdsna
startoswl
completeossp
completeahzi
completedsna
completee
starte
completee
starte
completee
starte
completeunmapped
startunmapped
complete
oswl ossp ahzi dsnae unmapped
e
starte
completeunmapped
start
test-code leveljob-step level
unmapped
complete
remap 
filterrepetitions-
to-activity 
filter
012
fig.4. a combination of ﬁltering techniques was applied to bring th e log data from
the test-code level to the job-step level
occurrence of a test in job step ‘e’ (i.e., test ‘oswl’) and th e end of the last
occurrence in job step ‘e’ (i.e., test ‘ahzi’) is retained. n ote that using this
mapping, now also idle times within one job step are covered b y the overall job-
step duration (for example, the idle time between the comple tion of test ‘oswl’
and the start of test ‘ossp’). as a result, only changes betwe en job steps become
visible in the log, which we will use in the following for proc ess discovery on the
job-step level.
we now want to apply process discovery techniques to gain insight into the
actual ﬂow of the test process to ﬁnd out where re-executions were often nec-
essary. process discovery algorithms automatically const ruct a process model
based on the behavior that was observed in the event log. whil e it is interesting
to visualize dependencies on the test-code level, we also wa nt to analyze the
process on the job-step level to compare the discovered mode l to the existing
reference sequence. the translated reference sequence is d epicted in figure 5(a),
and it reﬂects the normal ﬂow of the test sequence if nothing g oes wrong (i.e.,
if no test fails). we already know that in reality parts of the test sequence need
to be repeated in certain occasions. this also becomes visib le in the discovered
model based on the log ﬁltered for job step executions (cf. figure 4), which is
depicted in figure 5(b). note that the discovered process mo del allows for con-
siderably more paths than the reference model. figure 6(a), shows the framed
part of the mining result in more detail, where one can easily recognize the repet-
itive nature of the real(as opposed to the ideal, i.e., reference) test process. not e
that the numbers next to the arcs show the importance of the di ﬀerent paths
(the lower number indicates how often this connection was ob served in the log,
while the upper number indicates the heuristic strength of t he corresponding
connection).
so far, we have seen that it is possible to automatically disc over models
which represent the behavior that was observed in the event l og. but how well
is the actual process represented by these models? and to whi ch extent does
the observed process comply with the behavior speciﬁed in th e reference model?10
(a) reference model (b) discovered process model
fig.5. translated reference sequence and discovered process mode l on job-step level
where in the process do most of the deviations occur? these ar e questions that
are addressed by conformance techniques. in the following we use conformance
checking [22] to analyze the conformance of both the referen ce model and the
discovered model on the job-step level (cf. figure 5) with re spect to our test log.
next to visualizing the discrepancies between an event log a nd a given process
model, conformance checking can also be used to measure the d egree of ﬁtness
based on the amount of missing and remaining tokens during lo g replay [22],11
table 1. fitness values ( f) indicating the degree of compliance for each of the test
instances with respect to both the reference model and a disc overed process model.
clearly, the discovered model ﬁts much better than the refer ence model
machine id reference model discovered model job-step events test-code events
0431 f= 0.309 f= 0.751 238 6504
0278 f= 0.385 f= 0.828 270 6136
0185 f= 0.376 f= 0.717 206 5710
0466 f= 0.356 f= 0.745 422 8162
0391 f= 0.384 f= 0.727 159 3902
1722 f= 0.334 f= 0.760 301 6270
1694 f= 0.397 f= 0.782 526 10408
1256 f= 0.410 f= 0.744 222 5722
1343 f= 0.399 f= 0.701 130 5360
1981 f= 0.357 f= 0.667 551 12670
1754 f= 0.402 f= 0.776 192 16250
1662 f= 0.414 f= 0.769 182 3830
1453 f= 0.405 f= 0.596 164 6410
1298 f= 0.378 f= 0.424 170 3852
1876 f= 0.356 f= 0.753 150 4538
1656 f= 0.368 f= 0.656 126 2820
1099 f= 0.424 f= 0.672 193 3946
1919 f= 0.337 f= 0.727 205 5048
1348 f= 0.410 f= 0.638 184 5240
1596 f= 0.410 f= 0.581 224 5784
1164 f= 0.376 f= 0.672 499 10860
1032 f= 0.324 f= 0.706 301 6896
1794 f= 0.394 f= 0.734 114 2972
1160 f= 0.405 f= 0.770 186 5676
average f = 0.375 f = 0.711 246.458 6456.917
i.e., it quantiﬁes to which degree the log traces comply with a given process
model. this ﬁtness analysis clearly indicates that the disc overed model is much
more representative for the observed test process than the r eference model (cf.
ﬁtness values in table 1). table 1 contains the ﬁtness values for each of the test
instances with respect to both the reference sequence and th e discovered model
on the job-step level as depicted in figure 5, whereas possib le values range from
0.0 (corresponds to the case where the model and the log do not ﬁt at all) to
1.0 (i.e., model and log ﬁt to 100%). furthermore, it shows how m any job step
executions were contained in the ﬁltered log for each machin e (column before the
last column in table 1), and how many test code events were ori ginally recorded
for this machine (last column in table 1). finally, in the bot tom row average
values are given for all the 24 machines. we can see that, alth ough the discovered
process model does not completely “match” the behavior obse rved in the log,
it clearly ﬁts much better than the reference sequence. this is not surprising
as we already know that—in contrast to the discovered model— the reference
model does not capture the possible repetitions in the proce ss at all, but it12
describes the ideal ﬂow of the process if nothing goes wrong. so, the discovered
model is a much better representation of the test process as i t took place, which
demonstrates that process mining can provide insight into h ow processes are
really executed.
5 evaluation from asml perspective
to identify concrete improvement suggestions, we evaluate d the presented pro-
cess mining results from an asml perspective. for this, the o rder of job steps
was analyzed. the job-step order is the sequence in which job steps are executed
in the factory. some variation is allowed, but not too much. w e investigated
whether—according to the discovered model as in figure 5—th e test process
followed the reference process (including the allowed vari ations).
when we investigated whether the real process followed the r eference pro-
cess, considering the allowed variations, we obtained thre e types of results: (1) job
steps that are actually executed on a diﬀerent place in the re ference sequence
(i.e., deviations from the process model shown in figure 5(a )), (2) groups of
highly connected job steps, and (3) job steps that are not in t he reference se-
quence but in the test log. in the following, we describe them in more detail.
(1) it appeared that job step ‘i’ was positioned in 81% of the c ases just after
the ‘zero’ job step, i.e., at the beginning of the discovered process model, while—
according to the reference sequence—it should be executed i n the middle of the
test process. while looking for possible root causes for thi s diﬀerence, we realized
that a newer version of the reference sequence was released i n the end of 2006.
the main change in the new reference sequence was that job ste p ‘i’ and ‘j’ were
positioned just after the ‘zero’ job step at the beginning of the test sequence.
the analyzed systems were build up according to the new seque nce for job step
‘i’. interestingly, job step ‘j’ was still found in the origi nal position. if job step
‘j’ is really to be executed in the beginning of the sequence, then active steering
should take place to align the test execution. note that we al so re-checked the
conformance of the test log with respect to the updated refer ence sequence, but
the ﬁtness values did not change signiﬁcantly (on average f≈0.45).
(2) two highly connected groups of job steps are included in t he discovered
process model. the ﬁrst group is depicted in figure 6(a), a st rong connection
between job step ‘f’ and a number of other job steps: ‘e’, ‘b’, ‘g’ and ‘o’. these
connections are bi-directional between ‘f’ and the other jo b steps. a reason for
this eﬀect could be that any execution of the job steps ‘e’, ‘b ’, ‘g’ and ‘o’ results in
a re-execution of job step ‘f’. job step ‘f’ is a relatively sh ort job step which can
be executed automatically. as a result, the entire test set i s executed. speciﬁc
parts of the test set in job step ‘f’ could be faster when job st ep ‘f’ needs to
be executed after job step ‘e’, ‘b’, ‘g’ and ‘o’ are executed. in general, speeding
up job step ‘f’ is beneﬁcial because it is executed multiple t imes in the entire
sequence.
the second highly connected group is centered around job ste ps ‘r’, ‘s’, ‘t’,
and ‘j’. the mined process showed the following pattern (see figure 6(b)). job13
(a) framed area in figure 5(b)
 (b) other group
fig.6. highly connected groups of job steps, which have been identi ﬁed based on the
process mining results presented in section 4
step ‘r’ and ‘t’ are bi-directionally connected. job steps ‘ r’, ‘j’ and ‘t’ are illu-
mination steps, while job step ‘s’ is a non-illumination ste p. the root cause of
a failure of job step ‘t’ is solved by job step ‘r’. a re-execut ion of job step ‘r’
causes a re-execution of job step ‘s’ (and possibly ‘j’). an i mprovement proposal
would be to introduce a more thorough test in job step ‘r’ (i.e ., add a similar
test to the one in job step ‘t’) which causes that, if the failu re occurs, it already
occurs in job step ‘r’ and can be immediately ﬁxed in job step ‘ r’. this prevents
the re-execution of job step ‘s’ (and possibly ‘j’).
(3) one of the feedback loops revealed that job step ‘d’ is exe cuted, although
it is not in the reference sequence. job step ‘d’ is currently not investigated to
be improved to decrease the cycletime, because this job step is not supposed to
be executed. the process mining results revealed that job st ep ‘d’ is executed as
part of a recovery plan. job step ‘d’ could be further investi gated for cycle time
reduction.
the above analysis illustrates that process mining can be ap plied to check
the conformance of processes, i.e., deviations can be detec ted and analyzed.
6 conclusion
using a test process in asml, we have illustrated the applica bility of prom’s
conformance checker. the case study clearly shows that, giv en an event log and a
process model as input, conformance checking can be used to d etect deviations.
the severity of these deviations can be qualiﬁed and possibl e causes can be
analyzed. hence, conformance checking is a useful tool in as sessing regulatory
compliance.
the case study is a bit a-typical, i.e., regulatory complian ce is often asso-
ciated with regulations such as the sarbanes-oxley act, bas el ii, and hipaa.
these regulations focus on banks, insurance companies, gov ernmental agencies,
hospitals, etc. however, prom’s conformance checker is gen eric and applicable
to any notation that can be mapped onto petri nets. moreover, the case study
within asml illustrates the trend that more and more devices are connected to14
the internet. another example is the “customercare remote s ervices net-
work” of philips healthcare (ph). this is a worldwide intern et-based private
network that links ph equipment to remote service centers. a ny event that oc-
curs within an x-ray machine (e.g., moving the table, settin g the deﬂector, etc.)
is recorded and can be analyzed [16]. the logging capabiliti es of the machines of
ph illustrate the increasing availability of event data. th e omnipresence of such
detailed logging will have dramatic eﬀects on compliance. w hile today many
processes are not auditable because vital information is mi ssing, it is clear that
much more audit data will be available in the near future.
acknowledgements
this research is supported by the technology foundation stw , eit, and the
tangram and iop programs of the dutch ministry of economic aﬀ airs. fur-
thermore, we want to thank asml for their cooperation.
references
1. w.m.p. van der aalst, b.f. van dongen, c.w. g¨ unther, r.s. mans, a.k. alves
de medeiros, a. rozinat, v. rubin, m. song, h.m.w. verbeek, a nd a.j.m.m.
weijters. prom 4.0: comprehensive support for real process analysis. in j. kleijn
and a. yakovlev, editors, proceedings of the icatpn 2007 , volume 4546 of lecture
notes in computer science , pages 484–494. springer-verlag, berlin, 2007.
2. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. marust er, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and ap proaches. data
and knowledge engineering , 47(2):237–267, 2003.
3. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
4. r. agrawal, d. gunopulos, and f. leymann. mining process m odels from work-
ﬂow logs. in sixth international conference on extending database tech nology ,
pages 469–483, 1998.
5. r. agrawal, c.m. johnson, j. kiernan, and f. leymann. tami ng compliance with
sarbanes-oxley internal controls using database technolo gy. in proceedings of the
22nd international conference on data engineering (icde 20 06), page 92. ieee
computer society, 2006.
6. r. boumen, i.s.m. de jong, j.m.g. mestrom, j.m. van de mort el-fronczak, and
j.e. rooda. integration and test sequencing for complex sys tems. ieee trans-
actions on systems, man, and cybernetics, part a , 39(1):177–187, 2009.
7. r. boumen, i.s.m. de jong, j.w.h. vermunt, j.m. van de mort el-fronczak, and
j.e. rooda. test sequencing in complex manufacturing syste ms.ieee transac-
tions on systems, man, and cybernetics, part a , 38(1):25–37, 2008.
8. j.e. cook, c. he, and c. ma. measuring behavioral correspo ndence to a timed
concurrent model. in proceedings of the 2001 international conference on soft-
ware mainenance , pages 332–341, 2001.
9. j.e. cook and a.l. wolf. software process validation: qua ntitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147–176, 1999.15
10. a. datta. automating the discovery of as-is business pro cess models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275–301,
1998.
11. a. ghose and g. koliadis. auditing business process comp liance. in b.j. kramer,
k.j. lin, and p. narasimhan, editors, fifth international conference on service-
oriented computing (icsoc 2007) , volume 4749 of lecture notes in computer
science , pages 169–180. springer-verlag, berlin, 2007.
12. g. governatori, j. hoﬀmann, s. sadiq, and i. weber. detec ting regulatory com-
pliance for business process models through semantic annot ations. in 4th inter-
national workshop on business process design , 2008.
13. g. governatori, z. milosevic, and s. sadiq. compliance c hecking between business
processes and business contracts. in 10th international enterprise distributed
object computing conference (edoc 2006) , pages 221–232. ieee computing
society, 2006.
14. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal , and m.c. shan. business
process intelligence. computers in industry , 53(3):321–343, 2004.
15. c.w. g¨ unther and w.m.p. van der aalst. a generic import f ramework for process
event logs. in j. eder and s. dustdar, editors, business process management
workshops, workshop on business process intelligence (bpi 2006), volume 4103
oflecture notes in computer science , pages 81–92. springer-verlag, berlin, 2006.
16. c.w. g¨ unther, a. rozinat, w.m.p. van der aalst, and k. va n uden. monitoring
deployed application usage with process mining. bpm center report bpm-08-
11, bpmcenter.org, 2008.
17. h. hess. monitoring, analyzing and optimizing corporat e performance: state of
the art and current trends. in agility by aris business process management ,
pages 235–250. springer-verlag, berlin, 2006.
18. ids scheer. aris process performance manager (aris ppm) : measure, ana-
lyze and optimize your business process performance (white paper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
19. y. liu, s. mueller, and k. xu. a static compliance-checki ng framework for
business process models. ibm systems journal , 46(2):335–361, 2007.
20. a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. va n der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245–304, 2007.
21. m. zur m¨ uhlen and m. rosemann. workﬂow-based process mo nitoring and con-
trolling - technical and organizational issues. in r. sprag ue, editor, proceedings
of the 33rd hawaii international conference on system scien ce (hicss-33) , pages
1–10. ieee computer society press, los alamitos, californi a, 2000.
22. a. rozinat and w.m.p. van der aalst. conformance checkin g of processes based
on monitoring real behavior. information systems , 33(1):64–95, 2008.
23. a. rozinat, i.s.m. de jong, c.w. g¨ unther, and w.m.p. van der aalst. process
mining of test processes: a case study. beta working paper se ries, wp 220,
eindhoven university of technology, eindhoven, 2007.
24. a. rozinat, i.s.m. de jong, c.w. g¨ unther, and w.m.p. van der aalst. process
mining applied to the test process of wafer steppers in asml. accepted for
publication in ieee transactions on systems, man, and cyber netics–part c , 2009.
25. m. sayal, f. casati, u. dayal, and m.c. shan. business pro cess cockpit. in pro-
ceedings of 28th international conference on very large dat a bases (vldb’02) ,
pages 880–883. morgan kaufmann, 2002.