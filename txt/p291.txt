modeling the case handling principles
with colored petri nets
christian w. g¨ unther and wil m.p. van der aalst
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands
{c.w.gunther, w.m.p.v.d.aalst }@tm.tue.nl
abstract. case handling is a new paradigm for supporting ﬂexible and
knowledge intensive business processes. it is strongly based on data as the
typical product of these processes. unlike workﬂow management, which
uses predeﬁned process control structures to determine what should be
done during a workﬂow process, case handling focuses on what canbe
done to achieve a business goal. while classical petri nets are a good the-
oretical foundation for workﬂow management, the data-intensive nature
of case handling does not allow for the abstraction of data. therefore,
we use colored petri nets (cpns) as a foundation for case handling.
this paper models the key principles of case handling in terms of cpns
and uses state-space analysis and simulation to validate the concepts.
moreover, we also link the cpn model to process mining and show that
it is possible to rediscover case handling processes based on the event log
of a cpn simulation.
1 introduction
although workﬂow management concepts and technology [3, 13, 20, 21] have been
applied in many enterprise information systems in the last decade, there appears
to be a severe gap between the promise of workﬂow technology and what sys-
tems really oﬀer. as indicated by many authors, workﬂow management systems
(wfmss) are too restrictive and have problems dealing with change [2, 5, 7, 9,
11, 12, 17, 18, 24].
most of the workﬂow management systems consider workﬂows to be produc-
tion processes, directly driven by structured process models. such an approach
is solely on the concept of routing, i.e., shifting work among resources based on
causal relationship between activities. in [6] it is argued that for some applica-
tions the approach is suitable, but that for many other applications the use of
control-ﬂow as the primary enactment mechanism may result in the following
four problems:
–distributed handling of work requires its being partitioned, or straight-
jacketed into activities . this fundamental principle, vital for the wfms,
can hardly ever comply with the way workers organize their tasks. usually
activities are performed at a far more ﬁne-grained level than proposed by a
process model.–typical wfmss make no distinction between authorization anddistribution
of work, i.e., a worker is always oﬀered to pick up any task he is authorized to
do. this property leads to e.g. overcrowded in-trays for employees in higher
positions, as their role typically includes many others.
–strong control-ﬂow orientation of wfm systems tends to blind out the con-
text of tasks to be performed, most notably data created at earlier points
in the process. this leads to the phenomenon of context tunneling , i.e., a
worker has only access to data deliberately provided, a handicap that hin-
ders eﬃciency and quality of work.
–thepush-oriented nature of routing leaves hardly any decision to the user, so
that he does not even have a means of making small ad-hoc adjustments to
the process. that way workﬂows become unnecessarily inﬂexible, and small
errors can spawn great problems.
to overcome this problem, we proposed case handling as a new paradigm
for supporting knowledge-intensive business processes [1, 6]. this paradigm has
proven its value in the tool flow er[1, 8, 22]. this tool is one of the most
successful products on the dutch workﬂow market and has demonstrated its
value in situations requiring more ﬂexibility. the core features of case handling
are:
–avoid context tunneling by providing all information available (i.e., present
the case as a whole rather than showing just bits and pieces),
–decide which activities are enabled on the basis of the information available
rather than the activities already executed,
–separate work distribution from authorization and allow for additional types
of roles, not just the execute role,
–allow workers to view and add/modify data before or after the corresponding
activities have been executed (e.g., information can be registered the moment
it becomes available).
since case handling is a combination of mechanisms, it is not easy to deﬁne
this new paradigm in a rigorous manner. the existing deﬁnitions given in [1, 6]
are too informal to allow for any form of analysis. the purpose of this paper is
to “formalize” the case handling concept in terms of colored petri nets (cpns)
[15, 19]. cpns are a natural extension of the classical petri net [23]. there are
several reasons for selecting cpns as the language for modeling the case han-
dling paradigm. first of all, cpns have formal semantics and allow for diﬀerent
types of analysis, e.g., state-space analysis and invariants [16]. second, cpns
are executable and allow for rapid prototyping, gaming, and simulation. third,
cpns are graphical and their notation is similar to existing workﬂow languages.
finally, the cpn language is supported by cpn tools1– a graphical environ-
ment to model, enact and analyze cpns. the model was created by one person,
having a software engineering background and basic knowledge about classical
petri nets, in about four man-weeks. a signiﬁcant amount of this time was spent
1cpn tools can be downloaded from wiki.daimi.au.dk/cpntools/.getting acquainted with cpn tools as an application in general, and standard
ml for e.g. functions in particular.
the remainder of this paper is organized as follows. first, the case han-
dling paradigm is introduced, emphasizing its speciﬁc features in contrast to
traditional workﬂow management. subsequently, section 3 introduces a cpn
model representing the basic case handling functionality in an abstract man-
ner, including the results of a state space analysis showing model correctness.
section 4 discusses the applicability of the presented model by inspecting its
alignment to an industrial case handling system and discussing limitations. fur-
ther, an extension to the model is presented that allows for generating artiﬁcial
enactment logs for process mining research, followed by a conclusion.
2 case handling
in contrast to the strongly process oriented view of production workﬂow, empha-
sizing the routing between atomic activities, the case handling paradigm focuses
mainly on the case itself. the case is the primary object to be manufactured
in any kind, e.g. the outcome of a lawsuit or the response to a customer re-
quest. resulting from that, single activities diminish in importance in favor of
the larger context. they are no longer considered atomic steps that have to be
performed in an “all or nothing” manner, but rather serve as logical partitions
of work between which a transition from one worker to another is possible.
as in traditional wfm there exists a set of precedence relations between
single activities making up a process, using well-known patterns [4] for that.
however the primary driver for progress is no longer the event of explicitly ﬁn-
ishing activities but the availability of values for data objects. while production
workﬂow clearly separates the process from associated data, case handling inte-
grates both far more closely, using produced data not only for routing decisions
but also for determining which parts of the process have already been accom-
plished. with case handling, each task has associated with it data objects for
three distinct purposes, while the ﬁrst association is between a task and all data
objects that are accessible while performing it. further on, all data objects that
aremandatory for a task have to be set (i.e., bound to a value) before the task
itself is considered to be accomplished by the system. finally, every data object
can have a random number of tasks to which it is restricted , meaning that it
can only be altered while performing one of these tasks. the mandatory and
restricted properties are independent from each other, however reason dictates
to have the last (in the sense of a causal chain) task featuring a data object as
restricted also declare it as mandatory (to make sure it will be provided). user-
interactive tasks are connected to a form , each providing access to a selection of
data objects. note that one form can be associated with multiple tasks; on the
other hand it is also possible to associate a form to the case itself, so that it can
be accessed at any point in time.
to introduce the case handling principles, figure 1 shows a simpliﬁed exam-
ple of a case type, the case handling analogy to a workﬂow process deﬁnition:fig. 1. simpliﬁed example case type
three tasks a,bandcare making up the process, sequentially chained by
causal relationships denoted by connecting arrows. their mandatory relation-
ships to the three data objects x,yandzbelow are denoted by curved arcs,
correspondingly they are associated with the forms mandnabove. as can be
seen in the illustration, tasks aandbshare the same form m, providing access
to data objects xandy. if a properly authorized worker now starts handling
taska, the associated form mwill open and he will start providing values for
the presented data objects. in a traditional wfms activity awould not be ﬁn-
ished before form mis closed, however the case handling system regards aas
ﬁnished as soon as a value for xhas been provided (and conﬁrmed appropri-
ately), automatically enabling task bin the background. if the worker would
now close form m, another employee could pick up the case where he left it,
starting task b, which would provide the same form mwithxhaving a value
ﬁlled in (that could now be changed again). another possibility is, however, that
the ﬁrst worker keeps on handling the form, providing also a value for y. this
would correspondingly trigger the auto-completion of task b(as all associated
mandatory data elements, in this case only y, have been provided) and activate
taskc. note that if a worker closes a form after ﬁlling out only parts of the
mandatory data ﬁelds of a task, despite the task not being considered ﬁnished
data already entered is not lost but will be presented to the person continuing
work on that task.
such closely intertwined relationship between data and process obviously
abandons their, often unnatural, separation so rigidly pursued in traditional
workﬂow management. with the status of case data objects being the primary
determinant of case status, this concept overcomes a great deal of the problems
described in the introduction:
–work can now be organized by those performing them with a far higher
degree of freedom. activities can either be performed only partly, without
losing intermediary results, or multiple related activities can be handled in
one go, surpassing the considerably weakened border between single tasks.
–the phenomenon of context tunneling can be remedied by e.g. providing
overview forms directly associated with the case. every authorized workercan consult such form at any point in time, ensuring he is aware of the
context where necessary.
–routing is no longer solely determined by the process model. case types can
be designed in such a way, that multiple activities become enabled concur-
rently, providing diﬀerent ways of achieving one goal. it is up to the user to
decide which way to go, with the system “cleaning up behind”, i.e., disabling
or auto-completing tasks that have not been chosen.
in addition to the execute role, specifying the subset of resources allowed
to handle a speciﬁc task, the case handling paradigm introduces two further
roles crucial for operation. the skip role allows workers to bypass a selected
task, which could be interpreted as an exception . when one thinks of real busi-
ness processes an exception, like skipping an activity that deals with thoroughly
checking the history of a client before granting a mortgage for well-known and
trusted clients, is likely to occur quite frequently. the ability to grant the skip
role to a senior worker renders the necessity for implementing such bypass ob-
solete, thus greatly simplifying the whole case type. it has to be noted that in
order to skip a task all preceding tasks that have not been completed yet have
to be skipped (or completed) beforehand. traditional workﬂow deﬁnitions use
loops for repeating parts of the process, e.g. because they have not yielded an
expected result. in a case handling system, such construct has been made obso-
lete as well by the introduction of a redo role, enabling its bearer to deliberately
roll the case’s state back and make a task undone. in doing so, the values pro-
vided for data objects during this task are not discarded but merely marked
asunconﬁrmed , so that they serve as kind of template when re-executing the
aﬀected task. similar to skipping, before a task can be redone all subsequent
tasks that have already been completed need to be rolled back as well before.
roles in a case handling system are case speciﬁc , i.e., having assigned the role
“manager” for a case type adoes not imply that one can play the same role for
another case b. they can be speciﬁed in form of a role graph , where single role
nodes are connected to each other by arcs, symbolizing is-a relationships; i.e.,
being authorized to play a role also implies the authorization to play all roles
connected as child nodes.
intertwining authorization with distribution of activities has been one major
ﬂaw of traditional workﬂow technology. in a case handling system, the former
in-tray , i.e., a list of all activities the user is authorized to perform and that he
can choose from, has been replaced by a sophisticated query mechanism . this
tool can be used to look for a speciﬁc case, based on certain features (e.g. case
data, or enactment meta-data like the start date of a case instance). moreover
it can be used to create predeﬁned queries tailored to each worker (or, group of
workers). a manager is no longer constantly ﬂooded with all possible activities
that he can perform, but only those which require a certain role, or e.g. case
instances of an order where the combined value exceeds $1000. obviously the
query mechanism can also be used to perfectly imitate a classic in-tray, be it
required.3 cpn model
this section introduces the cpn model of a case handling system, thus making
the case handling paradigm explicit. we ﬁrst discuss the color sets and then show
the top level view of the model. the top level model contains two substitution
transitions, which are also discussed. finally, the model is evaluated using the
state space tool of cpn tools.
3.1 color sets
before showing the top level view of the model, we present some of the color sets
used in the model (cf. figure 2). data elements are represented by the color set
datum which is composed of a string that denotes its (unique) name, a boolean
ﬂag symbolizing if it is enabled (i.e., if its value can currently be set or unset),
and a second boolean ﬂag representing whether the value has actually been set.
the place alldata contains complete information about all data elements as
one single token of color set datumlist , a list of datum instances, serving as
central repository and interface between all three parts of the model. color set
resource is composed of a string containing the unique name of the resource,
and a list of strings denoting the roles this resource can play. the most complex
color set within this model is the task , composed as follows: one string contains
the unique name of the task, followed by a list of strings representing the (names
of the) data elements that can be accessed and another list of strings representing
the mandatory data elements of this task (i.e., those that have to be set in order
to complete a task). two further string lists contain the names of preceding and
successive tasks, thus making up the control ﬂow of the case, and three strings
specify the respective roles necessary for executing, skipping and redoing the
task.
color stringlist = list string;
color datum = product
(* name *) string *
(* enabled *) bool *
(* isset *) bool;
color datumlist = list datum;
color role = string;
color resource = product
(* name *) string *
(* roles *) stringlist;
color mutex = unit with null;
color taskstate =
with initial | enabled | finished;color task = product
(* name *) string *
(* data *) stringlist *
(* mandatory *) stringlist *
(* previous *) stringlist *
(* successors *) stringlist *
(* exec role *) string *
(* skip role *) string *
(* redo role *) string;
color taskxresource =
product task * resource;
color taskentry = product
(* name *) string *
(* state *) taskstate;
color tasklist = list taskentry;
fig. 2. color set deﬁnition used in the cpn model3.2 top-level view
ready
task
active
taskxresourceresources
resource
all_data datumlistmutex
mutex
open_form
[canexec(r,t1)]close_form
data manipulation
data manipulationtask lifecycle
task lifecycle
t1
(t1,r)t1
(t1,r)
rr
openform(t1,l)l
closeform(t1,l)l() ()
fig. 3. top-level view of the model
all basic functionality available to the user of a case handling system is
included within the top level view. the ready place is the main interface to
one further part of the model describing the lifecycle of tasks; when a task is
ready to be handled it is transported to this place by the system, respectively
tasks whose postcondition has been satisﬁed get removed from this place by the
system. users are now able to activate tasks that are being located in place
ready for handling, which usually means opening the respective form in order to
change associated data. this activity corresponds to ﬁring transition open form ,
consuming a task from ready and a resource token from the central repository
place, both being stored intermediately in place active (as a product of both
colors). when ﬁred, open form will also consume the token from alldata and
set all data elements deﬁned in the opened task as enabled. subsequently ﬁring
transition close form will adversely disable all data elements speciﬁed by the
now closed task, transport the task token itself back into ready and free the
associated resource, i.e., put it back into the central resource repository. note
that opening and closing forms is the only way to enable or disable data elementsfor manipulation and, the other way round, apart from that no change in the
overall state is performed.
one thing that has to be noted is that case handling systems usually not
allow for real concurrency. to avoid context tunneling it will provide access to
all case data, and therefore limit parallel updates of data values. if several users
could open forms on one single case in parallel, the outcome of this would be
impossible to determine, as they could enter contradictory values for one data
ﬁeld on diﬀerent forms. this behavior is modeled by place mutex which contains
exactly one black token. once this token has been consumed by ﬁring open form ,
no further form can be opened unless ﬁring close form has produced a new
token in mutex .
to avoid context tunneling and provide to the experienced user a higher de-
gree of freedom, case handling systems allow to deﬁne forms that are associated
directly to the case (in contrast to task-associated forms). these forms can be
opened at any time and allow direct access to a random choice of case data ele-
ments. in this model, case forms are represented by tasks having no predecessor
and successor tasks and no mandatory data elements. they reside in the ready
place and will not leave it, due to their not being connected to other tasks from
a control-ﬂow point of view.
3.3 data manipulation
data_unset
stringdata_set
stringall_datadatumlist
i/o
set
[isenabled(s,l)]
unset
[isenabled(s,l)]ss
ssresetdatum(s,l,[])
l
lsetdatum(s,l,[])
fig. 4. data manipulation subsection of the case handling model
this part of the model represents the setting and unsetting of data values
dependent on their being enabled by currently open forms. single data elements
are represented by simple string tokens (containing their name) and can eitherreside in places data setordata unset , so that their state is symbolized by their
position within the model. a transition between the states of being set or unset
— i.e., between the two respective places — can be achieved by ﬁring transitions
setandunset . the precondition for ﬁring these transitions is, that for the data
element to be (un-)set the “enabled” ﬂag is set to true within place alldata ,
a condition checked by function isenabled . in eﬀect, ﬁring either set(unset )
executes function setdatum (resetdatum ), toggling the boolean ﬂag denoting
the value-bearing status of the respective data element within alldata .
3.4 task lifecycle
initial
taskfinaltaskall_taskstasklistresources
resourcei/o
all_data datumlist
i/oready
taski/oenable[allprefinished(t1,tal)]redo
[canredo(r,t1) andalso
allpostinitial(t1,tal)]
finish
[allmandatoryset(t1,l)
andalso isnoform(t1)]skip[canskip(r,t1)]t1setstatus(t1,finished,tal,[])
tal t1 t1
t1tal
t1setstatus(t1,enabled,tal,[])talsetstatus(t1,finished,tal,[])
t1
t1 t1rrrr
l
lsetstatus(t1, initial, tal, [])
tal
fig. 5. part of the model representing the task lifecycle
handling the lifecycle of tasks is essential to the case handling mechanism,
for this is possibly the point where such system diﬀers most substantially from
a conventional wfms. the model is built to reﬂect the current lifecycle status
of each task as its respective position in one of three places of type task (or
four, if you count the active place in the top view part). any task is either
in state (place) initial ,ready orfinal . one place alltasks serves as a
central repository for task state information, replicating this for the sake of
model readability2. state transitions for tasks are dependent on the states of
2it would have been possible to test multiple places as precondition for ﬁring a tran-
sition instead of just polling alltasks . however, by using this central replication of
state information it is possible to avoid a large amount of arcs crossing each other.their respective predecessor and successor tasks, as well as it is dependent on
the state of the case’s data elements, i.e., which of them have already been set.
when a case is started, all tasks contained will reside within place initial ,
waiting to be enabled by ﬁring transition enable . the precondition for that
is that all tasks that are direct predecessors have already been ﬁnished, it is
checked by function allprefinished which therefore retrieves the central token
from alltasks and puts it back, not before having changed the respective status
of the enabled task.
after having been enabled the task resides at the ready place, from which
basically three possibilities exist for progressing further. the task token can
transcend into the top-level part of the model by being activated, i.e., opening
its adjacent form and starting to change data values associated. this will, how-
ever, ﬁnally result in the form being closed again, returning the task into place
ready . if the user decides so and has suﬃcient rights (i.e., a resource having
the necessary role is available) he can deliberately skip a task (implemented
by a transition of that very name), transporting the respective token directly
into place final . this will adjust the task’s status within the central repository
alltasks and free the resource again immediately afterwards.
the usual way, however, for a task to progress from ready tofinal is by
ﬁring transition finish . this transition gets enabled as soon as all mandatory
data elements of a task have been set, further it is ensured that the respective
task is “real”, and not in fact a case form (by making sure it has predecessor and
successor tasks) and the task state is adjusted in alltasks . by solely depending
on the status of data elements for ﬁnishing tasks this transition also implements
the “autoskip” functionality of case handling systems, i.e., the possibility to ﬁnish
tasks without even having touched them, solely by satisfying their mandatory
data requirements otherwise (e.g. using case forms).
redoing tasks requires, opposite to enabling them, that all successors of the
respective task are in place initial (i.e., that they have previously been rolled
back). the redo transition checks this property, and further needs to acquire a
suitable resource that is freed immediately afterwards. the possibility to redo
tasks closes the circular lifecycle, allowing tasks to progress through this an
arbitrary number of times, under the sole premise that the basic (half-)ordering
of tasks be maintained.
3.5 evaluation
in order to both verify the correctness of the model and ensure alignment with
the case handling principles that were intended to be modeled, a state space
analysis of the model was performed within cpn tools. however, before such
analysis was feasible we were forced to reduce the size of the example case han-
dling process and abstract from forms. without these changes, cpn tools was
unable to construct the full state space. a token from place ready (symbolizing a
form directly associated with the case) was removed and the represented process
was simpliﬁed into a case handling process of only two consecutive steps task1
andtask2 , i.e., the initial state of place initial was changed and the token inplace alltasks was adjusted accordingly as well. however, the basic principles
of case handling remain untouched by these alterations. as a result, the analysis
in remainder remains relevant for other case handling processes.
place upper integer bound lower integer bound
active 1 0
alldata 1 1
mutex 1 0
resources 3 2
ready 1 0
data set 4 0
data unset 4 0
alltasks 1 1
ﬁnal 3 1
initial 3 1
table 1. integer bounds of simpliﬁed case handling model
boundedness properties — one property the state space analysis can yield
is the upper and lower integer bound of tokens per place, i.e., the maximum and
minimum number of tokens of the appropriate color each place can contain for
a given initial marking [14]. with respect to the scenario described above, the
results are documented in table 1. one ﬁrst property that can be noted is that
every place has an upper bound, i.e. the net is bounded. this corresponds to
our expectations, as the model is not intended to generate additional tokens, so
that the overall number of tokens contained within the complete net is expected
to remain unchanged by ﬁring any transitions3. further it can be observed that
places alltasks andalldata will always contain exactly one token, as these
are to serve as central information repositories which are not to be moved perma-
nently. the diﬀerence in upper and lower bounds for place resources of merely
1 corresponds to the upper bound of 1 for place active , emphasizing the nature
of a case handling system locking the complete case for exclusive access to one
user at a time. finally, the lower bounds of 1 for places initial andfinal are
due to the virtual start and endtokens of color task which remain in their
respective places inﬁnitely as guaranteed process boundaries.
home properties — the case handling paradigm allows for a maximal degree
of freedom with respect to navigating within a process. given that he has suﬃ-
cient permissions, the user can freely move back and forth within a case type’s
3an exception to this is place mutex , which is empty as long as an activity or form is
open.process model by executing, skipping and redoing tasks at will. as extreme ex-
amples consider at the one hand ﬁnishing a case by merely skipping all available
tasks, and on the other hand rolling an otherwise completed case completely
back by redoing the tasks contained in reverse order. this behavior, i.e., the
ability to reach any state from every other possible state, is reﬂected in the state
space analysis labeling all possible markings of the net as home markings, i.e.,
markings that it is always feasible to reach [14].
liveness properties — liveness denotes the remaining active of a set of
binding elements, i.e., every transition can become enabled by ﬁring an arbitrary
number of transitions[14]. in contrast to this, a dead marking denotes a state of
the net in which no transition is enabled. with respect to the model presented,
the only acceptable dead marking, i.e., a state in which no further action is
possible, would be a state in which the process is completely ﬁnished. however,
given the fact noted above that case handling provides unlimited navigation
within the process by means of skipping and redoing tasks, neither should there
exist dead markings nor dead transitions (i.e., single transitions that can become
permanently disabled by any ﬁring sequence) for the model. this expectation
has been acknowledged by the state space analysis, yielding no dead markings
and denoting all transition instances as live.
fairness properties — fairness is an indicator of how often diﬀerent bind-
ing elements occur[14]. for the given model, the state space analysis denotes
transitions enable andredo as fair, so an inﬁnite number of enablings for these
transitions implies an inﬁnite number of occurrences. this corresponds to the
intended behavior, as these transitions will actually remain enabled until ﬁred.
with the exception of close form , all further transitions are just, i.e., persistent
enabling of these implies an eventual occurrence. this property can be deduced
from the free-choice character of the model, i.e., choices between two concur-
rently enabled transitions depend solely on user decision and are also intended
to reﬂect these. finally, transition close form has no fairness. this is due to
the fact that, in case this transition is enabled, it is always possible to ﬁre set
andunset in an inﬁnite, alternating sequence, so that ﬁring close form can be
eﬀectively evaded. however, such behavior would correspond to a user having
one speciﬁc form open inﬁnitely long and keeping on changing values without
eventually closing it again. therefore this property reﬂects an intended model
behavior, and a real-life occurrence of such potential inﬁnite loop can safely be
ruled out by common sense.
4 applicability
the purpose of this section is to probe the real-life applicability and relevance
of the presented model. in order to more illustrate the concept of case handling,
and also to bridge the gap between the abstract model presented and real lifeapplication, the ﬁrst section compares the cpn model to the real case handling
system flow er[1, 8, 22]. the second part discusses limitations of the presented
model and discrepancies with respect to flow er, while the last part introduces
an extension of the model for creating enactment logs during simulation.
4.1 mapping to flow er
in order to more illustrate the concept of case handling, and also to bridge the
gap between the abstract model presented and real life application, this section
compares the cpn model to the real case handling system flow er.
fig. 6. process model (“plan”) in flow er
flow erfeatures a graphical process designer tool (flow erstudio), in
which so-called case types can be deﬁned, figure 6 shows a screenshot of this
application with a simple example process4. on the left side four rectangular
boxes can be seen, symbolizing the four data objects data1 todata4 used
in this case type. to the right, the process structure is depicted, showing the
tasks task1 totask4 as rectangular nodes, connected with arcs denoting causal
relations between them. the start and end of the process is marked with so-
called milestones , which are no real tasks but symbolize deﬁned states of the
process and have been included here to make a connection to the ﬁxed start
andendtokens within the cpn model.
apart from the relationships visible in figure 6, the following has been de-
ﬁned: all four tasks use the same form ( form1 ), providing access to all four
data objects; this form is also connected to the case type itself, i.e., it can be
accessed at any time during handling a case. task1 hasdata1 as mandatory,
task2 andtask3 both have data2 anddata3 speciﬁed as mandatory and task4
requires data4 respectively.
4in flow er, the process part of a case type is called a plan.fig. 7. user perspective of the flow ersystem
figure 7 shows the user interface of flow er. in the front, the single form
has been opened in reaction to executing task1 and a value has been provided
and acknowledged for data1 . the window in second order shows the main user
interface of flow erwhich provides an overview of the case currently handled
by the user. on the left, the single plan, i.e., process model, of the currently
handled plan has been selected, thus it is also displayed on the top third of
the right part. in the middle part of the right side the so-called wavefront is
displayed, which is mainly a vertical line. tasks that are being displayed on the
left of this line are not yet ready to be executed, enabled tasks are right on the
wavefront and completed tasks are shown to the right of it. thus, tasks “travel”
from left to right over the wavefront correspondingly to their lifecycle status
(and they move back to the left again when they are being redone). below the
wavefront part of the interface, form1 is explicitly depicted and can be opened
any time while handling this case.
as in this example a value has already been provided for data1 , the ﬁrst task
(task1 ) has already been ﬁnished (as data1 was the only mandatory data object
for this task) and has moved to the right of the wavefront. corresponding to this,
task2 andtask3 have been enabled and are positioned right on the wavefront.
a closer look at the opened form reveals red square icons to the left of the entry
ﬁelds for data2 anddata3 : both task2 andtask3 that are now enabled have
set these data objects as mandatory, thus the system now signals (by the squareindicators left to each input ﬁeld) that, by providing values for these ﬁelds, the
next step could be accomplished.
notice the non-intrusive nature of guiding user interaction performed by the
case handling system, which is not enforcing or suggesting any speciﬁc behavior
but rather presenting possible options. the user is not controlled by the system
in a push-oriented manner, but he potentially has a great degree of freedom in
his actions (depending on the design of the case type). meanwhile the system will
constantly observe which parts of the process have already been accomplished
and track progress, providing more of a help in direction than restricting to
predeﬁned paths.
table 2. model place contents in discussed state
place tokens
alldata 1‘[("data1", true, true), ("data2", true, false),
("data3", true, false), ("data4", true, false)]
alltasks 1‘[("start", finished), ("task1", finished), ("task2", enabled),
("task3", enabled), ("task4", initial), ("end", initial)]
initial 1‘("end", [], [], ["task4"], [], "", "", "")++
1‘("task4", ["data1", "data2", "data3", "data4"], ["data2", "data3",
"data4"], ["task2", "task3"], ["end"], "role3", "role3", "role2")
ready 1‘("task3", ["data1", "data2", "data3", "data4"], ["data2", "data3"],
["task1"], ["task4"], "role1", "role1", "role2")
active 1‘(("task2", ["data1", "data2", "data3", "data4"], ["data2", "data3"],
["task1"], ["task4"], "role2", "role2", "role3"),
("resource1",["role1","role2"]))
ﬁnal 1‘("task1", ["data1", "data2", "data3", "data4"], ["data1"],
["start"], ["task2", "task3"], "role1", "role1", "role2") ++
1‘("start", [], [], [], ["task1"], "", "", "")
resources 1‘("resource2",["role2","role3"]) ++ 1‘("resource3",["role3","role1"])
data set 1‘"data1"
data unset 1‘"data2" ++ 1‘"data3" ++ 1‘"data4"
if the example case type and situation as described above is translated into
the introduced cpn model, the marking of the net after executing task1 and
providing a value for data1 is given in table 2. in the token for alldata it can
be observed that all four data elements have been enabled (with their second
element, a boolean, set to true , while merely data1 has its third element set to
true , corresponding to its having been set. this last information is also explicitly
reﬂected in the distribution of tokens between data setanddata unset .4.2 limitations
the mapping performed in the last section shows that the presented cpn model
is suitable for introducing and analyzing the basic features of the case handling
paradigm, enabling the implementation and analytic enactment of simple case
types. however, compared to the presented commercial system flow erit has
several subtle discrepancies and limitations, which shall be discussed within this
section.
regarding case type design, the model does not allow for alternative branches
within the process structure. such feature would require the interpretation of
boolean statements on data objects, which is beyond the scope of the presented
model. another fundamental limitation is concerning process structure as well,
for constructs like arbitrarily instantiated sub-processes5cannot be represented
with this model. this does, however, have no inﬂuence on the correctness of the
model, for these can be interpreted as abstract tasks executed in parallel.
naturally, flow eras a commercial system allows for a much wider range
of task deﬁnitions beside form actions. tasks can also use database interactions,
arbitrary code execution and other non-interactive methods of data processing.
on the conceptual level of the model these diﬀerences are, however, completely
irrelevant — all task types available in flow ershare the same basic property
relevant for the scope of the model, i.e., they all access and potentially modify
case data objects.
other constructs present in flow ercan be seen as helpful abstractions,
which can be implemented using the model by breaking them down into more
low-level constructs. one example are role hierarchies; these are not supported
by the model, but can be implemented by granting every resource that has role r
also each child role of r. regarding the restricted feature of data objects, which is
also not directly implemented in the model, it is possible to make the respective
data object available only for those tasks to which it shall be restricted, resulting
in the very eﬀect.
one aspect in which the behavior of the presented model deviates signiﬁ-
cantly from that of flow eris concerning task lifecycle transition. while the
model treats task and associated form as unity, this association is implemented
much less coherent in flow er. while, after providing a value for data1 in the
example of the last section, task1 has already transitioned to the ﬁnal state, i.e.,
to the right of the wavefront, in the model this transition can only happen after
the form has been closed. this discrepancy extends onto the time of enabling
subsequent task2 and task3 , which is self-evident as they have to wait until
task1 is ﬁnished. while this diﬀerence shows in the delayed transition of tasks,
it has no inﬂuence on the general order of these transitions, such that the overall
behavior of the model is consistent with flow er. due to this property, results
gained from the model can be applied with little to no restriction.
5these serve for executing a speciﬁc subprocess multiple times in parallel, whereas the
number of subprocess instances is only determined during super-process enactment
(e.g., collecting witness statements for an accident).4.3 process log synthesis
the presented cpn model obviously does not directly represent a business pro-
cess, but it rather describes the abstract process of handling, or executing, such
business processes within a case handling system. the executed process is thus
not explicitly visible in this meta model, it is encoded in tokens of type task .
only when the model is executed, the handled process becomes observable.
to make such observation easier to achieve, and to allow for a more detailed
analysis of the handled processes, the model was enhanced with the logging
extensions of cpn tools[10]. these are three ml functions, createcasefile ,
addate andcalculatetimestamp , that create process enactment logs of a model
in mxml, the prom6format, when the model is simulated in cpn tools. an
extra transition has been added to the model, activating the logging function
createcasefile(int caseid) before each execution of the model. this will
create a new log ﬁle containing all events recorded for this particular simulation
run (i.e., case), while the parameter caseid has to be manually set to a unique
number in order to distinguish between diﬀerent cases.
the actual log events, describing the life-cycle change of the task in question,
are recorded by the function addate(int caseid, string transitionname,
listofstrings eventytype, stringtimestamp timestamp, string origin-
ator ,listofstrings data) , which is called when ﬁring transitions enable ,ﬁn-
ish,skip, and redo. parameter caseid is set according to the value provided in
createcasefile , while the value for transitionname corresponds to the task
name contained in the processed task token. the eventtype is determined by
the ﬁred transition, i.e. transition enable will set the event type to schedule ,
ﬁnish tocomplete and so on. notice that while the names are diﬀerent, this is
only due to a diﬀerent terminology between the case handling principle and the
mxml format, the semantics are perfectly in line. for setting the timestamp
parameter, the helper function calculatetimestamp is called, creating ascend-
ing, logical timestamps. finally, the originator parameter is set to the name of
theresource token used (if any, otherwise it is left blank), while the data
ﬁeld is left blank.
multiple simulations of the same process model can be aggregated into one
log ﬁle, using a plugin in the prom import framework6. this is an application
that allows for importing mxml logs from all sorts of process-aware informa-
tion systems. the aggregated log is then ready to be analyzed using the wide
palette of process mining techniques available within prom. figure 8 shows the
results of mining 20 simulation runs of the model with the alpha algorithm. the
process model encoded in the task tokens corresponds to the case type shown
in figure 6, except for one minor adaption: in order to ease mining and produce
a sound wf-net a task init has been prepended to the process. it cannot
be skipped and rolled back, thus ensuring exactly one deﬁned start condition
without incoming arcs.
6prom is the process mining framework. both prom and prom import can be freely
downloaded at http://www.processmining.org/.fig. 8. example process model mined from simulation logs
it is worthwhile pointing out that the mined process model, which is a wf-
net satisfying the soundness criteria, describes possible paths of execution in a
very concise and accurate manner. for each task a similar sub-process has been
discovered, showing the typical case handling lifecycle of a task with scheduling,
skipping or completing, and rolling back. this accuracy allows for the model
to be used for the sake of synthetic case handling log creation by simulation.
in order to research new methods for process mining in the ﬁeld of case han-
dling systems a wide variety of enactment logs is required, and log synthesis by
simulation can deliver these in a fast and automatized manner. notice further
that the prom import framework also includes a plugin for importing logs from
flow er. actual case handling processes can be remodelled in the cpn model
to research all potential enactment paths in synthesized logs, and the results can
be compared to those obtained from analyzing real flow erlogs.
5 conclusion
in this paper we have discussed the deﬁciencies contemporary workﬂow man-
agement systems suﬀer from and that hinder their wider application in industry,
boiled down to four crucial problems. subsequently, the case handling paradigm
has been presented as potential remedy to these structural problems. using the
technique of colored petri nets, an abstract model of case handling has beenintroduced, incorporating all signiﬁcant features of the way a case is being pro-
cessed in such system.
this model can on the one hand be employed to understand the functionality
of case handling and trace process enactment down to ﬁne-grained steps. on
the other hand, close alignment of the model to a real case handling system,
flow er, has been shown in all signiﬁcant aspects. together with a state space
analysis, proving basic correctness and expected behavior of the model, these
properties can be extended onto the principles of case handling as a whole.
taking into account the mentioned limitations of the model and its discrepancies
with respect to a real system like flow er, it can be employed to conduct
more thorough research on speciﬁc properties of case handling. especially the
extension of the model with logging capabilities can provide valuable artiﬁcial
logs, which are important for process mining research on case handling systems.
6 acknowledgements
this research is supported by the technology foundation stw, applied sci-
ence division of nwo and the technology programme of the dutch ministry of
economic aﬀairs.
the authors would like to thank kurt jensen for his support in the early
stages of this article and his comments, and ana karla alves de medeiros for
implementing the logging extensions to cpn tools. last but not least, the au-
thors would like to thank the anonymous reviewers for their useful remarks.
references
1. w.m.p. van der aalst and p.j.s. berens. beyond workﬂow management: product-
driven case handling. in s. ellis, t. rodden, and i. zigurs, editors, international
acm siggroup conference on supporting group work (group 2001) , pages
42–51. acm press, new york, 2001.
2. w.m.p. van der aalst, j. desel, and a. oberweis, editors. business process man-
agement: models, techniques, and empirical studies , volume 1806 of lecture notes
in computer science . springer-verlag, berlin, 2000.
3. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
4. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
5. w.m.p. van der aalst and s. jablonski. dealing with workﬂow change: identiﬁca-
tion of issues and solutions. international journal of computer systems, science,
and engineering , 15(5):267–276, 2000.
6. w.m.p. van der aalst, m. weske, and d. gr¨ unbauer. case handling: a new
paradigm for business process support. data and knowledge engineering ,
53(2):129–162, 2005.
7. a. agostini and g. de michelis. improving flexibility of workﬂow management
systems. in w.m.p. van der aalst, j. desel, and a. oberweis, editors, business
process management: models, techniques, and empirical studies , volume 1806 of
lecture notes in computer science , pages 218–234. springer-verlag, berlin, 2000.8. pallas athena. case handling with flower: beyond workﬂow . pallas athena
bv, apeldoorn, the netherlands, 2002.
9. f. casati, s. ceri, b. pernici, and g. pozzi. workﬂow evolution. in proceedings
of er ’96 , pages 438–455, cottubus, germany, oct 1996.
10. a.k. alves de medeiros and c.w. g¨ unther. process min-
ing: using cpn tools to create test logs for mining algorithms.
http://is.tm.tue.nl/research/processmining/tools/prom/cpntoolconverter.zip ,
2005.
11. c.a. ellis and k. keddara. a workﬂow change is a workﬂow. in w.m.p. van der
aalst, j. desel, and a. oberweis, editors, business process management: models,
techniques, and empirical studies , volume 1806 of lecture notes in computer
science , pages 201–217. springer-verlag, berlin, 2000.
12. t. herrmann, m. hoﬀmann, k.u. loser, and k. moysich. semistructured models
are surprisingly useful for user-centered design. in g. de michelis, a. giboin,
l. karsenty, and r. dieng, editors, designing cooperative systems (coop 2000) ,
pages 159–174. ios press, amsterdam, 2000.
13. s. jablonski and c. bussler. workﬂow management: modeling concepts, architec-
ture, and implementation . international thomson computer press, london, uk,
1996.
14. k. jensen. coloured petri nets. basic concepts, analysis methods and practi-
cal use . eatcs monographs on theoretical computer science. springer-verlag,
berlin, 1992.
15. k. jensen. coloured petri nets. basic concepts, analysis methods and practical
use. volume 1 . eatcs monographs on theoretical computer science. springer-
verlag, berlin, 1997.
16. k. jensen and g. rozenberg, editors. high-level petri nets: theory and applica-
tion. springer-verlag, berlin, 1991.
17. m. klein, c. dellarocas, and a. bernstein, editors. proceedings of the cscw-98
workshop towards adaptive workﬂow systems , seattle, washington, november
1998.
18. m. klein, c. dellarocas, and a. bernstein, editors. adaptive workﬂow systems ,
volume 9 of special issue of the journal of computer supported cooperative work ,
2000.
19. l.m. kristensen, s. christensen, and k. jensen. the practitioner’s guide to
coloured petri nets. international journal on software tools for technology
transfer , 2(2):98–132, 1998.
20. f. leymann and d. roller. production workﬂow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
21. d.c. marinescu. internet-based workﬂow management: towards a semantic
web, volume 40 of wiley series on parallel and distributed computing . wiley-
interscience, new york, 2002.
22. pallas athena. flower user manual . pallas athena bv, apeldoorn, the nether-
lands, 2002.
23. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
24. m. weske. formal foundation and conceptual design of dynamic adaptations in
a workﬂow management system. in r. sprague, editor, proceedings of the thirty-
fourth annual hawaii international conference on system science (hicss-34) .
ieee computer society press, los alamitos, california, 2001.