event interval analysis: why do processes take time?
suriadi suriadic,a,, chun ouyanga, wil m. p. van der aalstb,a, arthur h. m. ter hofstedea,b
aqueensland university of technology, gpo box 2434, brisbane, australia
beindhoven university of technology, eindhoven, the netherlands
cmassey university, albany, new zealand
abstract
through the application of process mining, valuable evidence-based insights can be obtained about business processes
in organisations. as a result, the eld has seen an increased uptake in recent years as evidenced by success stories
and increased tool support. however, despite this impact, current performance analysis capabilities remain somewhat
limited in the context of information-poor event logs. for example, natural daily and weekly patterns are not considered
but they are vital for understanding the performance of processes and resources. in this paper, a new framework for
analysing event logs is dened. our framework is based on the concept of event interval . the framework allows for a
systematic approach to sophisticated performance-related analysis beyond the capabilities of existing log-based analysis
techniques, even with information-poor event logs. the paper formalises a range of event interval types and then presents
an implementation as well as an evaluation of the proposed approach.
keywords: process mining, prom, data mining, business process management
1. introduction
process mining [21] aims to exploit the massive amount
of event data recorded by today's information systems
to gain valuable insights into business processes by un-
earthing, among others, actual process behaviour, model
deviations, performance characteristics, and bottlenecks.
the use of process mining in practice is becoming more
and more widespread as conrmed by the growing number
of success stories of its application [17, 9, 14, 25] and the
increasing number of tools oering process mining capa-
bilities [8] (e.g. prom [26], aris1, fluxicon2, bizclarity3).
corresponding author
email addresses: s.suriadi@massey.ac.nz, +64-9-414 0800
ext 43581 (suriadi suriadi), c.ouyang@qut.edu.au (chun
ouyang), w.m.p.v.d.aalst@tue.nl (wil m. p. van der aalst),
a.terhofstede@qut.edu.au (arthur h. m. ter hofstede)
1www.softwareag.com/corporate/products/aris_platform/
aris_controlling/aris_process_performance/overview/
2www.fluxicon.com/disco
3www.bizclarity.com.authe practical application of process mining is often
hampered by the limited information available in events
logs, especially in those logs which are not generated by
process-aware information systems. a typical problem is
that not both start and complete times are recorded for
activities. this information is expected by current pro-
cess mining software, such as the performance analysis
with petri nets and alignment-based performance analy-
sisplug-ins of the prom environment [7, 20, 18, 2] and
the performance analysis component of disco (a commer-
cial tool), in order to derive metrics such as waiting times
and case utilisation. the reliance on the existence of a
clean and simple process models to derive more detailed
performance information is also not very realistic as they
are often not realizable in practice. furthermore, existing
approaches, such as the fuzzy-mining-based performance
analysis approaches [23, 1, 5, 6, 16], and the temporal
trace language approach [13], analyse process performance
preprint submitted to decision support systems july 17, 2015separately from resource performance, thus preventing the
discovery of certain types of insight, such as idle periods
for processes and resources. our approach proposed in
this article, on the other hand, is able to combine these
two perspective, thus allowing us to extract insights about
the idle periods of processes. identifying idle periods of
processes is important as the ability to minimize them is
likely to lead to an increase in work throughput.
while existing data mining technology and spreadsheet
tools can, to a certain extent, derive performance metrics,
these tools and techniques do not take into account the
temporal and resource constraints that are inherent within
any type of process-based analysis (more details in sec-
tion 2.1). the approach proposed in this article is speci-
cally developed to extract performance insights that take
into account those constraints properly.
in summary, despite the proliferation of process min-
ing algorithms, especially in the area of process discovery,
emphasis in the eld has been on comparatively basic per-
formance metrics (e.g. throughput times, working times,
and waiting times) and not so much on analysis of more
advanced performance-related behaviour of processes (e.g.
resource productivity trends, correlation of performance
with log variables, workload estimation, and discovery of
and comparison between working patterns of resources).
this paper proposes a novel performance analysis frame-
work based on the concept of event intervals . an event
interval is a time interval between two adjacent events
that fulls certain conditions. by choosing the concept
of event interval as the building block of the approach and
by considering a variety of such intervals, problems with
varying degrees of information in logs (e.g. in relation to
time stamps) can be addressed in a systematic manner. a
range of dierent types of event intervals is distinguished
where the type is determined by attribute values of the
events for the case involved, the resource involved, and
the type of transaction (e.g. started, completed, sched-
uled). depending on the kind of information available ina log, some types of event intervals may or may not apply.
by taking into account both the case and the resource
perspectives, we are able to tackle more complex forms
of performance-related analysis, such as recurring work-
ing patterns of resources, waiting time distributions over
time, and resource performance comparison. in addition,
the framework allows the discovery of correlations between
event interval durations and attributes recorded in a log.
equally important, our approach has been implemented
in the open-source process mining analysis tool prom to
automate the various types of analyses just mentioned,
thus, delivering a dedicated framework, with tool-support,
for extracting sophisticated and rened process-related per-
formance information from information-poor logs .
this paper is structured as follows. section 2 describes
and formalizes the event interval analysis approach, while
section 3 describes an implementation of this approach as
a plug-in of prom [24]. section 4 details the evaluation of
the approach and section 5 compares our approach with a
number of existing performance analysis approaches. sec-
tion 6 summarises the paper and presents potential future
work.
2. approach
we start this section with an introduction to process
mining which is the background knowledge necessary to
understand the approach we propose in the paper. this
is then followed by discussions about the rationale and
the main ideas behind our approach and nally detailed
explanation and formalization of the approach.
2.1. background: process mining
the starting point of any process mining analysis is an
event log , a sample of which is shown at the top part of fig-
ure 1. an event log consists of a set of events and each row
in an event log corresponds to a single event. for illustra-
tion purposes, the log in fig. 1 captures the events related
to a purchase order process. a process can be interpreted
2as the execution of a sequence of activities that follow a
certain order to achieve a particular goal, e.g. to handle a
purchase order or an insurance claim. a process denition
is often specied in the form of a process model using a
well-dened modelling language. for example, the process
shown in the middle-left part of fig. 1 was described in
terms of a petri net. a case refers to one particular exe-
cution (or instance) of a process, which has or is assigned
a unique identier (`caseid'). in the sample event log in
fig. 1, we can see that there are three cases, each is made
up of 3-4 events. an event contains information concern-
ing the activity that is captured by the event, the resource
that performs an action which triggers the occurrence of
the event, the timestamp of the event, and the transaction
type of the event.
an event's transaction type captures the `state' of the
activity when the event occurred. examples include `cre-
ate' (when the activity becomes available to be executed),
`assign' (when the activity is given to a particular resource
to perform), `start' (when the assigned resource starts the
execution of the activity), and `complete' (when the re-
source completes the activity). the caseid, activity, re-
source, timestamp, and transaction type are often called
event attributes . finally, an instance of a particular ac-
tivity that belongs to a particular case is referred to as a
work item , and a list of work items is known as a worklist
which is usually associated with a particular resource.
process mining takes an event log to extract insights
about how the process was actually executed . with the
support of existing process mining techniques, an event
log can be used to extract temporal patterns formed by
the events in the log and thus to build (the structure of) a
process model (which is known as process discovery). for
example, the process model in fig. 1 may be discovered
from an event log of which a short snippet is shown in this
gure. performance analysis is another important area in
which process mining techniques have been proven to be
useful. an event log often contains information relatingto other perspectives such as the case, the time, and the
resource perspectives. mining such information, in the
context of business process, can provide insight into the
understanding of dierent perspectives. for example, log
data such as timestamps and frequencies of activities can
be used to identify bottlenecks, throughput, and eciency
of a process. furthermore, data about activities being
carried out by certain resources can be used to analyse
working behaviour of resources.
a distinct characteristic of the problems addressed by
process mining, which dierentiates the process mining
discipline from other types of data analysis, is the ex-
istence of concurrency and temporal constraints among
events, both from a case perspective and a resource per-
spective. the former restricts the types of work items that
can be executed at any given point in time (as they are
dependent on the completion of the preceding activities),
while the latter restricts the resources who can execute cer-
tain work items and the time at which the work items can
be executed, depending on task-resource assignment and
resource availability respectively. consequently, each row
in an event log (i.e. an event) has temporal relationships
with other events, through resource and case constraints.
this is in contrast to other types of logs typically used
in traditional data analytics (such as data mining or even
basic spreadsheet analysis) whereby the concept of case or
resource temporal constraint does not exist or is not taken
into account.
2.2. rationale: reasoning about time in processes
in this paper we are interested in process performance
analysis using event logs. the existing process mining
techniques focus on the analysis of basic performance met-
rics (e.g. working time, waiting time, and cycle time/through-
put) and assume that an event log contains sucient trans-
actional information, e.g. both `start' and `complete' infor-
mation, of activities. basically, working time of an activity
axis the time elapsed from the start to the completion of
3the activity ax, waiting time of axis the time elapsed from
the completion of the last activity that preceded axto the
start of the activity ax, and cycle time of axis comprised
of both the working time and waiting time of ax.
in reality an event log, however, often records limited
transactional information of an activity. for example, the
event log shown in fig. 1 only contains information about
activity completion, and we cannot see when the activity
started. with the existing process mining techniques, we
can only extract, from such a log, the information of cycle
time (i.e. the time interval between the completion of two
subsequent activities) with little knowledge of the working
time and waiting time. this prevents us from carrying
out a range of typical performance-related analyses, such
as analysis of process (cycle time) eciency and resource
utilisation. hence, the following question arises:
if an event log contains limited activity transactional
information, e.g. either `start' or `complete' infor-mation only, is it still possible to extract rich and
meaningful insights about process performance from
the log?
based on business process execution principles, we ex-
ploit an important observation that for a work item to
be executable in a case, two conditions must hold: 1) the
progress of the case must reach a state where the work
item itself is available for execution, and 2) the resource
responsible for carrying out the work item must be avail-
able. the former condition can be checked by focusing on
the case perspective, while the latter requires to take into
account the resource perspective.
again, consider the example in fig. 1. let's pick an
arbitrary timestamp, say 7 jan 2014 at 14:30:00.4on 7
jan 2014 at 14:30:00, we can deduce that the work item
4note that this timestamp is not among those listed in figure 1
because it is a rather `random' point in time. the log shown in
figure 1 only shows timestamps of completed work items.
 caseid  activity  timestamp  resource  transaction type  
c1 createpo  (cpo) 2014 -01-07 14:10:00  alice (a) complete  
approvepo  (apo) 2014 -01-07 14 :50:00 bob (b) complete  
terminatepo  (tpo) 2014 -01-07 15: 30:00 felix (f) complete  
c2 
 
 createpo  (cpo) 2014 -01-07 12:30: 00 alice (a) complete  
approvepo  (apo) 2014 -01-07 13:25:00 bob (b) complete  
modifypo  (mpo ) 2014 -01-07 14:25:00 donald  (d) complete  
confirmpo  (copo) 2014 -01-07 15:10:00 carol (c) complete   
c3 
 createpo  (cpo) 2014 -01-07 11:35:0 0 alice (a) complete  
approvepo  (apo) 2014 -01-07 12:45 :00 bob (b) complete  
modifypo  (mpo ) 2014 -01-07 13:20:00  donald  (d) complete  
confirmpo  (copo ) 2014 -01-07 14:3 5:00 carol (c) complete  resources‚Äô worklist s at: 
07/jan/2014 14:30:00
a b c d f
[c1, cpo]
[c2, cpo]
[c3, cpo] [c3, apo][c2, apo][c1, apo]
[c3, copo ][c2, copo ] [c2, mpo ]
[c3, mpo ]cpo start apo
approve poend
aa
b a
tpo
terminate pompo
modify po
confirm pocopo
create pod
cm[c1, apo]
workload trend (over time ) waiting time for process and 
resources (weekly trend )[c2, copo ]
[c3, copo ]
process load (over time )fprocess load at : 
07/jan/2014 14:30:00‚Äúevent log‚Äù
‚Äúevent attributes‚Äù
‚Äúan event‚Äù
‚Äúprocess model‚Äù[c1, cpo]legend
wi completed
[c2, copo ]resource 
waiting for wi
wi waiting 
for available
resource[c1, tpo]wi being 
executed[c1, apo](wi ‚Äì work item )
[c1, tpo][c1, tpo]
‚Äúa work item‚Äù
‚Äúa worklist (of a resource )‚Äù
no. of e vent int ervals
no. of e vent int ervals
averag e inte rval dur ation (in m i n utes )
figure 1: process mining: an example of event log, process model, resources' worklists, and performance analysis
4`approvepo' of case c1(i.e. [c1, apo]) is most likely being
executed because 1) it is available upon the completion of
the preceding work item `createpo' ([ c1, cpo]) at 14:10:00
and 2) the resource `bob' (b), who is responsible for `ap-
provepo', is available upon the completion of `approvepo'
in casec2([c2, apo]) at 13:25:00.
now let us discuss a couple of scenarios where the case
and resource constraints apply. firstly, since work item
[c1, apo] is still in progress at 14:30:00, none of the sub-
sequent activities (i.e. `modifypo', `conrmpo', or `ter-
minatepo') can be executed in case c1. as a result, re-
source `felix' (f), who is responsible for `terminatepo'
and is free at 14:30:00, has to wait until the completion
of work item [ c1, apo] at 14:50:00 before he can exe-
cute work item [ c1, tpo]. resource `carol' (c), who is
responsible for `conrmpo', is working on case c3(on work
item [c3, copo]) at 14:30:00 and thus is not available for
other cases. as a result, although work item `conrmpo'
of casec2([c2, copo]) has been available for execution
since 14:25:00 (when the preceding activity `modifypo'
was completed), it has to wait until `carol' completes work
item [c3, copo] at 14:35:00. in summary, the rst scenario
reveals that there is a waiting time of at least 20 minutes
for resource `felix' before he can execute [ c1, tpo] due to
a case constraint, while the second scenario reveals that
there is a waiting time of at least 10 minutes in case c2
before work item [ c2, copo] can actually be executed due
to resource constraints.
what we can learn from the above scenarios is that
even in the absence of activity start (or complete) infor-
mation, it is still possible to derive meaningful insights
about the waiting time and working time of a resource
or a process activity by examining the various points of
time in the log data and the intervals between these time
points from both the case and resource perspectives . this
nding provides the underlying rationale for the proposal
of a new log data analysis approach that can be used to
extract important information about process performancethat is hidden in an (information-poor) event log. fur-
thermore, we also hope to explore the potential of this ap-
proach for supporting sophisticated performance-related
analysis beyond the capabilities of current process mining
techniques. for example, by taking multiple `snapshots'
of both the process and resource load over time, we could
build a picture that describes the changes in the load of
the processes (see bottom-left graph in fig. 1) and the
resources (bottom-right graph). another example shown
in the bottom-middle graph of fig. 1 shows how we can
observe the variation of process waiting time and the re-
source waiting time over a recurring period of time (such
as a day or week) to discover the daily or weekly pattern
of the waiting times for both processes and resources.
2.3. approach: described in more detail
the central notion used in this paper is that of an event
interval . event intervals can be calculated from event logs .
in essence, an event interval is a period of time between the
occurrences of two events that satisfy certain conditions,
e.g. same transaction type (e.g. `start' or `complete'),
same case identier, and/or same resource identier. dif-
ferent types of event intervals can be derived by imposing
dierent set of conditions. furthermore, depending on the
conditions imposed, one can also derive meaningful inter-
pretation in terms of work performance by the collection
of event intervals that exist in an event log.
for example, one can dene a type of event interval
where the events involved concern activities which are per-
formed by the same resource. this type of event interval
is referred to as a resource interval . as an illustration
consider the interval between events e1ande2in fig. 2.
the gure depicts an elaboration of the second scenario
discussed in section 2.2, where the relevant events are dis-
played in ascending order along a timeline. events e1and
e2capture the completion of activity `conrmpo' by re-
source `carol' in two dierent casesc3andc2, respectively.
note that there is no event involving `carol' that occurred
5in between the occurrences of e1ande2. under the as-
sumption that a resource does not work on multiple activ-
ities at the same time, one can interpret the period repre-
sented by this event interval as the maximum time that it
could have taken `carol' to perform activity `conrmpo'
in casec2. this maximum would actually be realised if
`carol' started to work on `conrmpo' in case c2immedi-
ately after completing the activity in case c3, i.e. immedi-
ately after the occurrence of event e1. the example further
illustrates that even in the context of an information-poor
event log (only the completions of activities are recorded)
one can still derive meaningful information about resource
performance using the notion of a specic type of event
interval.
the main driver behind our approach is that the ex-
istence of various types of intervals in an event log may
reveal important information about process performance .
in fact, by displaying various types of intervals unearthed
from an event log over a timeline, information can be in-
ferred that cannot be obtained through the application of
current process mining approaches. to illustrate this phe-
nomenon, consider another type of event interval where
the timestamps of the events involved indicate the com-
pletion of their activities and where these activities belong
to the same case. this type of event interval is referred to
as acase interval . let's revisit fig. 2 where events e0
1(cap-
turing the completion of activity `modifypo' in case c2)
ande2form a case interval as both events belong to the
same case, c2, and there are no intermediate events be-longing to this case. given that e0
1occurred before e1, it
can be inferred that the time dierence between events e0
1
ande1corresponds to a waiting time for case c2. this
can be explained as follows. immediately after the occur-
rence of event e0
1, the next activity (`conrmpo') in case
c2could start were it not for the fact that this activity is
to be performed by `carol' who is still occupied with case
c3. the completion of `conrmpo' by `carol' in case c3is
signalled by the occurrence of event e1, hence case c2was
delayed after the occurrence of event e0
1till the occurrence
of evente1.
it should be noted that in the current version of event
interval analysis, as presented in this paper, we make a
couple of assumptions with regards to the way in which
work items are created and the way resources execute work
items. the analysis focuses on activities within a log that
have causal relationships, and considers resources work-
ing on one work item at any given time. in case that
these assumptions are violated, our event interval analysis
framework will still be able to deliver meaningful insights,
however, their interpretation would become more involved.
having created an intuition behind the notion of event
interval and having made explicit our assumptions, we are
in a position to lay the formal foundation for event in-
terval analysis by providing denitions for the notion of
event log and for ve basic types of event intervals, each
of which captures a dierent performance perspective. the
ve types of event intervals form the basic building blocks
of our approach to performance analysis. more types of
e1 e2
timestampww:w2014-01-07w14:25:00
casewwwwwwwwwwwww:wc2
resourcewwwww:wdonald
activitywwwwwww:wmodifypo
trans.wtypew:wcompletee'1resourcewintervalcasewinterval
waiting
timestampw:w2014-01-07w14:35:00
casewwwwwwwwwwwww:wc3
resourcewwwww:wcarol
activitywwwwwwww:wconfirmpo
trans.wtypeww:wcompletetimestampw:w2014-01-07w15:10:00
casewwwwwwwwwwwww:wc2
resourcewwwww:wcarol
activitywwwwwwww:wconfirmpo
trans.wtypeww:wcompletet
figure 2: an illustrative example of event intervals (in the context of the event log shown in fig. 1)
6intervals can be dened for event logs that capture more
transaction types (e.g. create, assign) leading to richer
forms of analysis. the approach can thus be seen as a
framework providing a range of analysis techniques tai-
lored to the type of information present in a log.
2.3.1. event log
anevent log (l) consists of a set of events . each
event (e) is associated with a range of attributes captur-
ing the information of caseid ( case(e)), activity ( act(e)),
timestamp ( time(e)), resource ( res(e)), transaction type
(type(e)), etc.5an event log can be partitioned into smaller
event logs based on an event attribute. for example, an
event-typed log (ltp) is the result of partitioning the origi-
nal event log based on transaction type tpand hence it con-
sists of events that have the same transaction type. also,
events are ordered by unique numbers, which are referred
to as event order identier s, that are related to their times-
tamps, and numbers take precedence over timestamps where
two events occur concurrently. below we formally dene
event and event log to avoid any ambiguity that may arise
when introducing the relevant concepts.
denition 1 (event). letcase be the set of case iden-
tiers, actthe set of activity identiers, time the set of
possible timestamps, resthe set of resource identiers and
type the set of transaction types (e.g. create, assign, start
and complete).
eis the set of events.
for anye2e:case(e)2case is the case identier
ofe,act(e)2actis the activity identier of e,time(e)2
time is the timestamp of e,res(e)2resis the resource
identier of eand type(e)2type is the transaction type
ofe. if an attribute is missing, a ?value is returned,
e.g., res(e) =?means that no resource is associated with
evente. 
5an event can have more attributes but these are not considered
in this paper.denition 2 (event log). an event logleis a set
of events. 
denition 3 (event-typed log). letlebe an event
log and let type be the set of transaction types. given
tp2type ,ltp=fe2lj type(e) =tpgis an event-typed
log of transaction type tp. 
denition 4 (event order identier). given an event
logle,id:l!f 1;:::;jljgis a bijective function that
maps each event e2lto a unique natural number where
8e1;e22l :id(e1)<id(e2) iftime(e1)<time(e2) and
e1e2if and only if id(e1)id(e2). 
2.3.2. event intervals
the general notion of an event interval (e1;e2) (or in-
terval for short) refers to the interval between any two
events in a log. more specically, we can identify ve ba-
sic types of event intervals.
case interval (cg).this is an interval between two ad-
jacent events of the same transaction type in the same
case. given an event e, the case interval cgecaptures the
maximum period the activity act(e) of case(e) becomes
available until it is completed.
consider the example of a case interval in fig. 3(a). at
the moment of time(e1), activity act(e1) of casec2is com-
pleted and the subsequent activity act(e3) is available for
execution. the latest this remains in the case is the mo-
ment when act(e3) is completed, which is time(e3). hence,
event interval ( e1;e3) denes case interval cge3.
a special scenario that should be considered is when
a case appears for the rst time, i.e. the starting point
of the case, in an event log. this is when an initial case
interval is dened. for example, in fig. 4, event e1signals
the starting point of case c2, and the initial case interval
ofc2, written cgi
e1, is formed by a pair comprising event e1
and itself, i.e. ( e1;e1). as another example, event interval
(e3;e3) denes the initial case interval of c3, written cgi
e3.
obviously, an initial interval has a zero time duration.
7resource interval (rg).this is an interval between two
adjacent events of the same transaction type that involve
thesame resource . given an event e, the resource interval
rgecaptures the maximum period the resource res(e) is
available for performing the activity act(e) incase(e) un-
der the assumption that a resource does not work on more
than one activity at a time.
consider the example of a resource interval in fig. 3(a).
at the moment of time(e2) when resource r2completes the
activity act(e2) of casec1,r2is then ready to carry out
activity act(e3) of casec2. the latest this holds true is
the moment of time(e3), whenr2completed act(e3) inc2.
hence, event interval ( e2;e3) denes resource interval rge3.
similarly to case interval, an initial resource interval
is dened when a resource appears for the rst time in
an event log. again, consider the illustration in fig. 4.
evente1indicates the rst appearance of resource r2, and
the initial resource interval of r2, written rgi
e1, is interval
(e1;e1); and for resource r1, the initial resource interval
rgi
e2is interval ( e2;e2).working interval (wg).given an event e, the working in-
terval wgecaptures the period the activity act(e) ofcase(e)
is performed by a specic resource res(e). it starts from
the moment when the activity and the resource are both
available for the execution of that activity, and nishes the
moment when the resource completes the activity.
a working interval is represented by either a case in-
terval or a resource interval depending on which becomes
available later, the activity or the resource. for example,
in fig. 3(a), though activity act(e3) of casec2is ready
to be performed at time(e1), resource r2is not available
until later at time(e2). hence, the event interval ( e2;e3)
denes working interval wge3as well as the corresponding
resource interval rge3. in fig. 3(b), on the other hand,
activity act(e3) of casec2becomes available later than re-
sourcer2, and thus working interval wge3is the same as
the corresponding case interval cge3.
in the situation when only completion s of activities
are recorded, a working interval provides us with 1) an
upper bound for the amount of time that the resource
(c2,r1) (c1,r2)e2 e1
wge3-e3
(c2,r2)
`complete' `complete' `complete'cge3-case interval
rge3-
cige1;e2-a b
(c1,r2) (c2,r1)e2 e1
wge3-e3
(c2,r2)
`complete' `complete' `complete'rge3-resource interval
cge3-
rige1;e2-
c1; c22case ;r1; r22rescase-waiting interval working interval working interval resource-waiting intervalresource interval case interval
c1; c22case ;r1; r22res
figure 3: illustration of ve basic types of event intervals in two dierent scenarios (a) and (b)
(c2,r2) (c2,r1)e2 e1 e3
(c1,r2)
`complete' `complete' `complete'e1is the rst event for case c2and resource r2
e2is the rst event for resource r1
rgi
e1cgi
e3cgi
e1rgi
e2
wge2
wge1wge3e3is the rst event for case c1
figure 4: illustration of initial case intervals, initial resource intervals, and the corresponding working intervals
8worked on the activity (the maximum occurs when the re-
source starts to work on the activity immediately after the
recorded completion of the previous activity), and 2) an
upper bound for the amount of time that the resource is
idle, i.e. able to work on the activity but not actually doing
so (this maximum occurs when the resource started work-
ing on the activity just before its completion is recorded).
a special scenario is, when either a case interval or a
resource interval is an initial interval, the corresponding
working interval is specied by that initial interval. ex-
amples can be seen as wge1,wge2, and wge3in fig. 4.
case waiting interval (cig).this captures the period an
activity of a certain case that is ready to be performed
waits for the availability of the corresponding resource. it
starts from the moment when only the activity is ready
and ends the moment when the resource is also ready.
in fig. 3(a) cige1;e2is an example of a case waiting
interval during which activity act(e3) of casec2waits for
resourcer2to become available (from case c1).
resource waiting interval (rig).this captures the period
that an available resource waits for the corresponding ac-
tivity of an expected case to be ready for its performance.
itstarts from the moment when only the resource is avail-
able and ends the moment when the activity in the corre-
sponding case also becomes available.
in fig. 3(b) rige1;e2is an example of a resource waiting
interval during which resource r2waits for activity act(e3)
of casec2to become available.
finally, it is possible that both the activity of a cer-
tain case and the required resource become available at
the same time. in this situation, case interval, resource
interval, and working interval all correspond to the same
event interval, and both case waiting interval and resource
waiting interval have a zero time duration.
formal denitions. below we formally dene the ve ba-
sic types of event intervals to avoid any ambiguity that
may arise in the above informal description.denition 5 (event interval). letlebe an event
log. lete1;e22 l withe1e2: (e1;e2) is an event
interval. g=f(e1;e2)2llj e1e2gis the set of
all possible event intervals, and dur(e1;e2) =time(e2) 
time(e1) is the (time) duration of interval ( e1;e2). 
denition 6 (case interval). letlebe an event
log andltpl(where tp2type ) be an event-typed log.
cg(ltp) =cgn(ltp)[cgi(ltp) is the set of case inter-
vals inlbased on transaction type tp, where 1)cgn(ltp) =
f(e1;e2)2l tpl tpje1< e2^case(e1) = case(e2)^
@e02ltp(e1<e0^e0<e2^case(e0) =case(e2))gare (nor-
mal) case intervals; and 2) cgi(ltp) =f(e;e)2ltpltp
j@e02ltp(e0< e^case(e0) = case(e))gare initial case
intervals (one for each case). 
we use the shorthand notation cge;tpto denote case
interval (e0;e)2cg(ltp), whereeis the end event of the
case interval and tpspecies the transaction type of e. it is
sucient to only use the end event (e.g. e) in the notation
to refer to a case interval since the start event (e.g. e0) can
easily be identied by the denition of a case interval. if
the transaction type ( tp) iscomplete , the notation cge;tp
is further simplied to cge.
denition 7 (resource interval). letl ebe an
event log andltp l (where tp2type ) be an event-
typed log.rg(ltp) =rgn(ltp)[rgi(ltp) is the set of
resource intervals in lbased on transaction type tp, where
1)rgn(ltp) =f(e1;e2)2ltpltpje1<e2^res(e1) =
res(e2)^@e02ltp(e1<e0^e0<e2^res(e0) =res(e2))g
are (normal) resource interval; and 2) rgi(ltp) =f(e;e)2
ltpl tpj@e02ltp(e0< e^res(e0) =res(e))gare initial
resource intervals (one for each resource). 
we use the shorthand notation rge;tpto denote resource
interval (e0;e)2rg(ltp), whereeis the end event of the
resource interval and tpis the transaction type of e. sim-
ilar to case intervals, the transaction type is dropped if it
iscomplete . this convention also applies to the remaining
types of event intervals.
9denition 8 (working interval). given an event log
leand an event-typed log ltpl(where tp2type ),
cg(ltp) is the set of case intervals and rg(ltp) is the
set of resource intervals that can be observed in lbased
on transaction type tp.wg(ltp) =f(e1;e2)2cg(ltp)[
rg(ltp)j@e32ltp(e1<e3^e3<e2^(res(e3) =res(e2)_
case(e3) =case(e2))gis the set of working intervals. 
similar to case intervals and resource intervals, we use
the shorthand notation wge;tpto denote working interval
(e0;e)2wg(ltp), which can be further simplied to wge
if only the transaction type complete is present.
denition 9 (case waiting intervals). letlebe
an event log and ltpl (tp2type ) be an event-typed
log. cig(ltp) =f(e1;e2)2l tpl tpj9e32ltp(e2
e3^(e1;e3)2cg(ltp)^(e2;e3)2rg(ltp))gis a set of
case waiting intervals. 
when only the transaction type complete is present,
we can use the shorthand notation cige0;eto denote case
waiting interval ( e0;e)2cig(ltp), wheree0is the starting
event of the corresponding case interval, eis the starting
event of the corresponding resource interval, and event e0
occurs no later than event e.
denition 10 (resource waiting intervals). letl
ebe an event log and ltpl (tp2type ) be an event-
typed log. rig(ltp) =f(e1;e2)2ltpltpj9e32ltp(e2
e3^(e2;e3)2cg(ltp)^(e1;e3)2rg(ltp))gis the set
of case waiting intervals. 
when only the transaction type complete is present,
we can use the shorthand notation rige0;eto denote re-
source waiting interval ( e0;e)2rig(ltp), wheree0is the
starting event of the corresponding resource interval, eis
the starting event of the corresponding case interval, and
evente0occurs no later than event e.
2.3.3. operations on event intervals
being able to identify the existence of various event in-
tervals is an important rst step in enabling event interval-based performance analysis. now it is time to introduce
a number of operations that can be subsequently applied
in order to derive useful performance-related information
from the event intervals identied.
grouping. it is obvious that an event interval on its own
only provides a micro-level view of the performance of a
process. in order to obtain a more complete and overall
understanding of a process' performance, it is necessary to
gather together the event intervals that share common fea-
tures useful to address specic performance-related analy-
sis questions. this can be realised via group by operation.
denition 11 (group by). a set of event intervals g
gcan be grouped by event attributes (e.g. case, resource,
activity). let attr be the set of values carried by a spe-
cic event attribute, gattrdenes the collection of inter-
vals grouped by that event attribute. a special case is
g?=f(?;g)g, where?represents the null attribute. 
the operation of grouping by event attributes supports
collecting individual event intervals into clusters of inter-
vals in a way that the intervals in each cluster carry the
same value in regard to a specic event attribute. for ex-
ample,gresrepresents the grouping of intervals by the
resource attribute of events. given any resource r2res,
gres(r) =f(e1;e2)2gj res(e2) =rgis the set of inter-
vals related to r. hereafter we use gx
attras a more com-
pact notation for gattr(x), e.g.gr
resmeansgres(r).
the group by operation can be applied to the various
types of event intervals. for example, grouping case inter-
vals by resource attribute yields clusters of case intervals,
where each cluster contains all the case intervals of which
the corresponding work items are executed by one partic-
ular resource. given an event log l,cg(l) is the overall
set of case intervals in l. the above clusters of case in-
tervals can be specied as cg(l)resand the cluster for
each resource r2resascg(l)r
res.
furthermore, the group by operation, when applied to a
specic value of an event attribute, yields a setof intervals
10(e.g.gr
res) and hence the operation can be applied again.
for example, this way one can obtain all intervals that
involve a certain resource rand a certain activity a, either
by writing (gr
res)a
actor (ga
act)r
res.
by choosing the right combination of an event interval
type and a group by event attribute, meaningful clusters
of event intervals can be derived for conducting analysis
operations which are to be introduced next.
analysis operations. eventually, the goal of dening, iden-
tifying, and grouping event intervals is to enable the ex-
traction of useful (and hopefully, representative) perfor-
mance information from an event log. this can be achieved
by applying a number of performance analysis operations
on the clusters of event intervals obtained through applica-
tion of the group by operation. in this paper, we propose
three dierent analysis operations: metrics analysis ,evo-
lution graph analysis , and decision tree analysis .
firstly, we dene metric functions that can be used
to compute performance measures, such as frequency and
time duration, of event intervals for metrics analysis.
denition 12 (metric functions). letgp(g) be
a set of grouped collections of event intervals where each
g 2gis a nite and non-empty set (e.g. gcan be
a set of collections of event intervals obtained from the
group by operation in denition 11). we introduce fas
a set of metric functions that have gas their domain, and
fmetric2f refers to any metric function in f. two con-
crete examples of fmetric , namely ffreqandfdur, are dened.
for any set of event intervals g2g,ffreq:g!ncom-
putes the number of the intervals in g, and fdur:g!r
computes the average duration of the intervals in g.
we can apply a metrics analysis to, theoretically, any
cluster of event intervals. for example, given an event log
land a resource r2res,fdur(wg(l)r
res) returns the av-
erage working time of any work items involving resource r
in case only activity completions are recorded. similarly,for any case c2case ,fdur(wg(l)c
case) returns the aver-
age working time of any work items that belong to case c.
next, we propose two dierent methods for counting
event intervals within a time window (i.e. a time interval).
the dierence lies in the way how event intervals that span
across multiple time windows are counted. one is called
theload (l) method in which intervals are counted as
long as they exist in a given time window. as a result, an
interval will be counted more than once if it spans across
multiple time windows. the other, namely the unique
(u) method, only counts those intervals that appear for
the rst time in a time window. as a result, each interval
will be counted exactly once.
denition 13 (count by time). letggbe a set
of event intervals. given t2time a point of time and
d2timeduration a (non-zero) time duration, [ t;t+di
denes a (valid) time window. the load method counts
all the intervals, gl
d(t) =f(e1;e2)2gj (time(e1)< t+
d^time(e2)>t)_(time(e1) =time(e2) =t)g, that exist
in [t;t+di. the unique method counts only the intervals,
gu
d(t) =f(e1;e2)2gjttime(e1)<t+dg, that appear
in [t;t+difor the rst time. 
both methods are valid in counting the number of event
intervals and for certain analysis questions one suits bet-
ter than the other. for example, we consider the load
method a more reasonable means to address the analy-
sis questions concerning case or resource occupancy, e.g.
how busy a resource is during a certain period, while the
unique method provides a better approach to incremental
analysis of performance, e.g. how much new work emerges
during a time window.
while the metrics analysis supports the computation
of metric measures in a static manner, it is often more
interesting to understand how performance metrics evolve
over a period of time. the results are usually represented
and visualised in the form of evolution graphs for analysis.
we consider two styles of time progression. one is the
11linear time progression which is quite common and often
used as a default style of time progression for analysis. the
other is the cyclic time progression which can be used to
exhibit the performance behaviour of a system in a period
relative to a recurring time window. for example, we may
be interested in what happens daily over a period of a
month or weekly over a period of a year.
denition 14 (evolution graph analysis). letg
gbe a set of event intervals, t2time a point of time, d2
timeduration a non-zero time duration, .2fl;ugthe
interval counting method, fmetric2fa metric function for
computing a certain metric measure over a set of intervals.
then, fmetric (g.
d(t)) computes a certain metric measure
over the group of intervals within time window [ t;t+di
over a linear time progression .
let!2timeduration (where! > d and!modulo
d= 0) be the duration of a time cycle, t02time the initial
point of time of !,f0;:::;nga set of integers, and 2
fmean,median ,max,min,sumgfor calculating average,
median, maximal, minimal, or total value over a set of
values. then, (fmetric (g.
d(^t+i!))), where t0^t <t0+!andi2f0;:::;ng, computes a certain metric measure
over the group of intervals within (recurring) time window
[^t;^t+diover a cyclic time progression . 
let's use an example to explain the evolution analysis
dened above. given an event log l, we want to observe
how the number ofnew resource intervals for a particular
resourcer, which exist in every time window [ t;t+diof
linear progression, evolves over a certain time period.
firstly, the group by operation is applied to collect the
set of resource intervals for resource r, i.e. rg(l)r
res.
next, the unique method is used to count the new re-
source intervals related to rthat appear in each time win-
dow [t;t+dioflinear progression, resulting in ( rg(l)r
res
)u
d(t). as the last step, the ffreqmetric function is applied
to compute the number of new resource intervals of rover
timet, thus ffreq(rg(l)r
res)u
d(t). the result can be plot-
ted into an evolution graph shown in fig. 5(a).
alternatively, by considering a daily (i.e. != 1 day)
cyclic progression, we can obtain an aggregation of evo-
lution graphs of ffreq(rg(l)r
res)u
d(^t+i!) as fig. 5(b)
shows, and then calculate the average number of new re-
after
hours
01/01/2011 01/01/2011 01/01/2011 01/01/2011 01/01/2011 01/01/2011
08:00:00 10:00:00 12:00:00 14:00:00 16:00:00 18:00:007
6
5
4
3
2
1
02/01/2011 02/01/2011 02/01/2011 02/01/2011 02/01/2011 02/01/2011
08:00:00 10:00:00 12:00:00 14:00:00 16:00:00 18:00:0089day 1
7
6
5
4
3
2
189
7.58
08:00:00 10:00:00 12:00:00 14:00:00 16:00:00 18:00:00
= 2 hours
= 1 day
day 2
day 2
08:00:00 10:00:00 12:00:00 14:00:00 16:00:00 18:00:007
6
5
4
3
2
189
day 1789
(a)
(b)(c)
                                     
=0
=1 
(day 1)(day 2)
figure 5: examples of evolution graphs: (a) evolution over linear time progression, (b) aggregation of evolutions over cyclic time progression,
and (c) average of evolutions over cyclic time progression.
12independent variables dependent variable
z }| { z }| {
case id activity day of the week resource duration duration category (rg)
102 createpo wednesday felix 20 mins short
102 approvepo thursday donald 3 mins short
84 createpo monday carol 37 mins long
80 createpo wednesday alice 18 mins long
79 approvepo tuesday bob 4 mins short
102 modifypo friday bob 53 mins long
table 1: an example of event data that can be used for conducting a decision tree analysis. the predictor variables are those attributes that
may explain the duration of intervals (which is, in turn, the response variable ). the duration of the intervals is classied based on domain
knowledge. in the table above, we classify the duration of an event interval as `long' if it lasts more than 30 minutes for activity `createpo',
5 minutes for activity `approvepo', and 25 minutes for activity `modifypo'
.
source intervals for rat each moment of ^tover cyclic time
progression, i.e. mean(ffreq(rg(l)r
res)u
d(^t+i!)). this
can be plotted into the graph shown in fig. 5(c), which ex-
hibits a daily pattern how average number of new resource
intervals of revolves, during a given time period.
denition 15 (decision tree). letggbe a set of
event intervals. then, dt(g) =f((case(e0);act(e0);time(e0);
res(e0);:::);durcategory (e;e0))j(e;e0)2gg denes a learn-
ing problem to identify the correlation between a set of
event attributes (including such as caseid, activity, times-
tamp, resource, and so on, which are known as independent
variables ) and the time duration of event intervals (known
asdependent variable ).
this analysis aims to discover the impact of certain
event attributes on interval duration through the applica-
tion of decision tree analysis or regression analysis. as the
dependent variable in this learning problem, durcategory
captures dierent categories of the intervals as a result of
classication of the intervals based on their duration. the
value of a dependent variable such as durcategory is al-
ways presented in a categorial (i.e. nominal) form.
table 1 lists an example of event data that can be
used for conducting a decision tree analysis. it helps to
nd out how each of the attributes, including the case
and the activity being executed, day of the week when aparticular activity being carried out, and the resource by
whom the activity being performed, aect the duration of
the resource intervals.
by now we have dened the concept of event inter-
vals and a new performance analysis framework that builds
upon various operations on the event intervals, which, as
currently proposed, include aggregation operation, met-
rics analysis, evolution of performance metrics over time
of linear or cyclic time progression, and decision tree anal-
ysis. discussion about tool implementation to support this
framework follows in the next section.
3. implementation
the approach detailed in section 2 has been imple-
mented as a plug-in of the prom tool [24], an open-source
process mining environment.6this section describes briey
the implemented plug-in.
3.1. interface
the input required by our plug-in is an xes/mxml [4,
22] log that satises the minimal requirements for process
mining analysis (i.e. the log contains activity information
6the name of the plug-in is event interval analysis and it can be
installed automatically via prom package manager or manually by
following the instruction available from https://www.dropbox.com/
s/lddagfz8i9yzwp0/installationinstructions.pdf
13related to a process, each activity can be linked to a pro-
cess instance, and the occurrences of the activities can be
ordered [19]). while the presence of resource information
in the log is essential, our approach is still applicable even
when such information is missing by, for example, assign-
ing a unique resource to each activity. furthermore, each
event in the log may be tagged with its transaction type
(e.g. schedule, allocate, start, complete, and/or others) in
accordance with the xes/mxml specication [4, 22]. if
such information is missing, it is trivial to add that using
existing tools (e.g. the disco tool can tag each event with
the event transaction type of `start' or `complete').
as shown in figure 6 (left), the implemented plug-in
allows users to choose the time frame within which the
extracted event intervals are to be analysed. furthermore,
given that our approach works with logs with a number of
dierent transaction types, users will have to specify the
transaction type that they would like to focus on in the
extraction of event intervals (see denition 3). finally,
we also allow users to specify the interval types that they
would like to consider in their analysis (as per denition 6
to denition 10 in section 2.3.2).
once a user has applied the necessary conguration
options, the plug-in will rstly extract all the applicable
event intervals that exist in the log. then it will display
an interactive window that consists of a set of congura-tion options on the left-hand side of the panel (for the
purposes of performing various analysis types as dened
in section 2.3.3) and a result visualisation panel on the
right-hand side of the panel (see fig. 6 - right). to make
the tool more usable, conguration options that are not
relevant for a particular analysis type are disabled. the
details of these panels are provided in the remainder of
this section.
3.2. interval analysis interface
figure 7 (left) shows a screenshot of the interactive
window through which users can conduct event interval
analyses interactively based on the extracted event inter-
vals. the conguration options panel allows users to spec-
ify a particular base analysis type , i.e. the combination of
ananalysis type ,interval type , and group by mechanism
(as per section 2.3.3).
decision tree. if one chooses dt(gattr) as the base anal-
ysis type (see denition 15), then the list of available at-
tributes that can be used as predictor variables , as present
in the log, is displayed in the drop-down box. users then
need to choose one or more predictor variables - see fig. 7
(right). the response variable in such an analysis is always
the duration of whichever interval type the user chooses.
furthermore, based on the chosen predictor variables,
a number of drop-down boxes is also displayed in the result
specify5a5specific
time5range5for
interval5analysis
choose5a5specific
event5lifecycle:
schedule,5assign,5start,5complete
select5the5type5of5event5
intervals5for5analysis:5
case5interval,5resource5interval,5
working5interval,5
case5waiting5interval,5
resource5waiting5interval
option5panel5
(detailed5in5fig.555and5fig.56)
result
panelinterval type
resource interval
secondary interval types:
figure 6: event interval analysis plug-in - conguration panel and visualisation panel overview.
14visualisation panel, one for each of the selected predictor
variables. these drop-down boxes allow users to specify
the data type for each of the selected predictor variables
(i.e. numeric, nominal, or string) - see fig. 7 (right). the
users also need to choose if the response variable, that
is, the duration of the selected interval type , is to be dis-
cretized based on the values themselves (that is, classes
will be equally split based on the minimum and maxi-
mum values seen) or the distribution of values (that is,
classes will be equally split based on the distribution of the
values). the former technique may result in imbalanced
classes, while the latter ensures that classes are balanced.
finally, users need to specify if the response variable is to
be discretized into two classes or into three.
the decision tree analysis type invokes the j.48 clas-
sication algorithm [15] from the weka library to pro-
duce one decision tree for each interval cluster (as deter-
mined by the group by parameter) to explain the correla-
tion between the selected predictor variables and the in-
terval duration. this analysis type produces two artifacts:
(1) the decision tree(s) with the corresponding `tness'
results mined from the data (one tree for each interval
cluster ), and (2) a set of weka data les (i.e. in arff -
compliant format) that users can directly use as input into
the weka tool for further data mining analysis (one lefor each interval cluster ). the mined decision tree(s) and
the corresponding results are displayed in a text format
as per the output from the weka library. an example
of the result of a decision tree analysis can be seen in the
evaluation section of this article (fig. 20 in section 4.2.3).
simple metrics. if one chooses fmetric (gattr) as the base
analysis type (see denition 12), then the only further
parameter to congure is whether the interval lter pa-
rameter should be set - see fig. 8. by specifying a interval
lter, we remove any event intervals that are made up from
a pair of events whose timestamps do not share the same
date. such a lter is sometimes needed to disregard in-
tervals that partially or wholly lay outside business hours.
the simple metrics base analysis type produces a bar graph
that displays the average, median, and standard deviation
metrics for each interval cluster . an example of the result
of a simple metric analysis is available in the evaluation
section of this article (fig. 16 in section 4.2.2).
evolution. if one chooses fmetric (gattr).
d(t) or
(fmetric (gattr).
d(^t+i!)) as the base analysis type (see
denition 14), further parameters need to be specied.
firstly, users may choose one or more `secondary' interval
types to be used in the analysis (see fig, 8), in addition to
the main interval type they have chosen earlier as part of
selectfanfeventfintervalftype
(casefinterval,fresourcefinterval,fworkingfinterval,f
casefwaitingfinterval,fresourcefwaitingfinterval)
selectfaf'groupfby'fmechanism
(case,fresource,factivity,fgroup,fall)
selectfanf'analysisftype'
(decisionftree,fsimplefmetric,
evolutionfgraph)
determinefthefdataftypeffor
fthefselectedfpredictorfvariables
(numeric,fnominal,fstring)
determinefhowfinterval
durationfisftofbefdiscretized
(byfvaluesforfbyfdistribution)
selectfthefnumberfof
classesfforfdecision
treefanalysisf(twoforfthree)
iff'decisionftree'fanalysisfisf
selected,fthenfusersfneedfto
selectfrelevantfpredictorfvariablesresource interval
secondary interval types:interval type
figure 7: option panel to congure base analysis type (left) and to set decision tree analysis options (right).
15thebase analysis type . in any case, the resulting evolution
graph contains one series for each possible interval cluster,
i.e. if users choose nsecondary interval types in addition to
the main interval type , and the chosen group by mechanism
hasminterval clusters , then by default the resulting graph
has (n+ 1)mseries.
other parameters (as dened in section 2.3.3) to choose
include (see fig. 8):
count method :loadorunique (as per denition 13),
graph type :duration (average interval duration) or
frequency (number of intervals) (i.e. fdurorffreqmet-
rics functions in denition 12),
window length : from 0.5 hour to 24 hours (i.e. the
value for parameter din denition 13),
timeline :linear time progression or daily,weekly ,
monthly , and year being the set of specic values of
cyclic time progression (i.e. the value for parameter
!in denition 14),
isintervalfiltered :yesorno, and
group by filter : no specic value ( none ) or a set
of chosen values ( x1;:::;x n) of an event attribute,
that is, each of the chosen value xi(i2f1;:::;ng)
corresponds to a particular interval cluster (i.e. group
of intervals)gxi
attr, and if none is chosen, then all
values will be used, i.e. gattr.
sample evolution graphs generated using two interval
types (case interval and resource interval), group by null,
using unique as the count method parameter, and dura-
tion as the graph type parameter are shown in fig. 9.
4. evaluation
to demonstrate the applicability of our approach, we
show that we can use event interval analysis frameworkto answer a number of typical performance-related ques-
tions detailed in section 2.2, such as the distribution of re-
sources' workload over time, the pattern in which resources
carry on their tasks, the utilisation rate of resources, com-
parison of resources performances, and working time esti-
mation.
the evaluation of our approach is performed on both
synthetic logs and a real-life log: the former logs are used
to demonstrate the correctness of our approach, while the
latter is used to demonstrate its usefulness in extracting
performance information from a real event log.
the evaluation of our approach focuses on the evolu-
tion graph analysis (that is, the analysis dened in def-
inition 14) as we nd it to be quite powerful in gaining
insights into the performance of resources and processes.
the simple metrics analysis is used, when needed, to pro-
vide an overview of interval duration statistics. evaluation
of the decision tree analysis is provided in section 4.2.3
when we attempt to nd correlations between duration of
intervals and other variables seen in the event logs used.
to simplify presentation, table 2 shows a number of
conguration parameters and the corresponding short-hand
notations for evolution graph analyses that we use in the
remainder of this section.
4.1. synthetic log
evaluating our approach with synthetic logs (which we
have generated ourselves) is needed to show that our ap-
proach can detect certain phenomena that we know exist
in the logs, which is essential to demonstrate the correct-
ness of our approach and the related implementation.
we have generated three synthetic logs7, each with a
distinctive trend in terms of resource working patterns and
process load:
log 1 - cyclic : new cases arrive at a regular pace,
and resources working patterns also follow a regular
7these logs can be obtained from https://www.dropbox.com/s/
0d5trj1f5qqlyuj/artificiallogs.zip
16trend dicated by the alternation between business-
hours and outside-hours cycle. this log is used to
represent a `normal' process load and resource work-
ing patterns.
log 2 - disturbance load : new cases arrive at a reg-
ular pattern most of the time but with a sudden
distinctive increase in the arrival of new cases over
a short period of time, hence causing an increase inthe workload as well. this log also captures a dis-
turbance that occurred when half of the resources
were not available for a period of two weeks. this
log is used to capture a one-o phenomena, e.g. the
occurrence of a natural disaster that causes a sud-
den spike in the number of new insurance claims, or
the onset of a school holiday period that results in a
number of resources taking leave.
ifc'intervalcevolution'canalysisciscselected,cthencuserscneedcto:
-cspecifycthec'windowclength'
-cspecifycthec'timeline'cstylec(cyclicc-cdaily,cweekly,cetccor
ccclinear)c
-cspecifycthec'count'cfunctionc(loadcvs.cunique)candc
ccc'graphctype'cc(durationcvs.cfrequency)
choosecifc'intervalcfilter'cisctocbecappliedc
(forc`simplecmetrics'candc'evolutioncgraph'canalyses)
forc'evolutioncgraph'canalysis,cusersccancchoosec
twocorcmorecintervalctypesctocbecdisplayedcincthecevolutioncgraph
selectioncofc'groupcby'cvaluesctocconsider
ascseriescincthecevolutioncgraphsecondary interval types:
figure 8: option panel for evolution graph analysis congurations.
y-axis
duration8in8minutes
x-axis
timelineinterval8types8888:8resource8interval8(red)8and8case8interval8(blue)
group8by888888888888:88null
count888888888888888888:8unique
graph8type88888888:8duration
window8length8:888hours
timeline8888888888888:8linear
isintervalfiltered:8no
group8by8filter888:8nonesecondary interval types:interval type
resource interval
figure 9: a sample output of evolution graphs for two interval types: case interval and resource interval .
17ref. expression of interval group count graph window timeline interval
id short notation type by method type size prog. filtered
ev1 ffreq(cg?)l
6hr(t) case null load freq. 6 hrs linear no
ev2 ffreq(rgres)l
6hr(t) resource res load freq. 6 hrs linear no
ev3 ffreq(cg?)l
8hr(t) case null load freq. 8 hrs linear no
ev4 ffreq(rgres)l
8hr(t) resource res load freq. 8 hrs linear no
ev5mean(fdur(cg?)l
1hr(^t+i1w)) case null load dur. 1 hr weekly yes
mean(fdur(rg?)l
1hr(^t+i1w)) resource null load dur. 1 hr weekly yes
mean(fdur(ag?)l
1hr(^t+i1w)) activity null load dur. 1 hr weekly yes
ev6 ffreq(rg?)l
8hr(t) resource null load freq. 8 hrs linear yes
ev7 ffreq(rgres)l
8hr(t) resource res load freq. 8 hrs linear yes
ev8mean(ffreq(rgres)l
1hr(^t+i1d)) resource res load freq. 1 hr daily yes
ev9mean(ffreq(rgres)l
1hr(^t+i1w)) resource res load freq. 1 hr weekly yes
ev10 ffreq(cg?)l
8hr(t) case null load freq. 8 hrs linear yes
ev11 ffreq(cgres)l
8hr(t) case res load freq. 8 hrs linear yes
ev12 fdur(rg?)u
12hr(t) resource null unique dur. 12 hrs linear yes
ev13 fdur(rgres)u
1hr(t) resource res unique dur. 1 hr linear yes
ev14mean(fdur(rgres)u
1hr(^t+i1w)) resource res unique dur. 1 hr weekly yes
ev15 fdur(cig?)u
8hr(t) case waiting null unique dur. 8 hrs linear yes
fdur(rig?)u
8hr(t) resource waiting null unique dur. 8 hrs linear yes
ev16mean(fdur(cig?)u
3hr(^t+i1w)) case waiting null unique dur. 3 hrs weekly yes
mean(fdur(rig?)u
3hr(^t+i1w))resource waiting null unique dur. 3 hrs weekly yes
table 2: conguration parameters for evolution graph analysis
log 3 - gradually-incrementing load : new cases ar-
rive at an increasing rate, causing a gradual increase
in the workload of resources as well. this log is used
to represent, e.g. a gradual take-up of a new insur-
ance product line.
all synthetic logs simulate cases that started within a
6-month period (that is, the starting date for all cases in
the log fall within a particular six-month period; however,
the total duration of the log is longer than six months as
some cases may take a few weeks to complete). there are
6 resources in the log and each of them can execute any
activity. each new work item is allocated to the earliest-
available resource, estimated from workload distribution
of all resources at the time the work item is scheduled.we have evaluated our approach using the three logs
described above. our tool managed to detect the trends
that we have built into the logs. furthermore, insights
related to resources' workload and utilization can also be
extracted. in this section, we only show results from log 2
(disturbance load) and log 3 (gradually-incrementing load).
we do not show results from our evaluation with the cyclic
log simply because the real-life log that we used for the
second evaluation round (detailed in section 4.2) already
contains such behaviour.
4.1.1. disturbance load
log 2 has two disturbance features built-in: (1) a sud-
den spike in the number of new cases in the rst-half period
of the log, and (2) the unavailability of half of the resources
18in the second-half period of the log. using our event in-
terval analysis approach, we expect these two phenomena
to be detected through the use of evolution graphs.
to capture process load, we can use ffreq(cg?)l
d(t)
as the base analysis type (as per denition 14). recall
that a case interval is dened by the time period between
the time when an event for a particular case was recorded
to the immediate following event belonging to the same
case. thus, by applying the above analysis, we can see,
for a given period of time, the total number of work items
in the process that will eventually become `active' and
be completed. furthermore, if we rene the analysis to
ffreq(cgres)l
d(t), then we essentially obtain the work-
load of each resource at any given point in time. simi-
larly, to detect how `busy' a resource has been, we can
useffreq(rgres)l
d(t) as the base analysis type to obtain,
at any given point in time, the average number of inter-
vals (or, in this context, work items) performed by a given
resource.
fig. 10 (top-left) shows an evolution graph generated
using conguration ev1 (see table 2). the gure shows
that there is a sudden spike of new case intervals in the
rst-half of the graph, thus demonstrating the ability of
our approach to make it easier for process analysts to dis-
cover the existence of such disturbance. here, it is worth
emphasizing that such a trend is made evident by exploit-
ing the building block of our approach, i.e. event interval,
from which the load of a process, and how it changes over
time, can be estimated. we contend that the systematic
approach proposed in this article facilitates the extraction
of such knowledge which would have been easily `hidden'
in the data otherwise.
the top-right graph in fig. 10 shows the result of a
similar evolution graph analysis using conguration ev2
with a focus on the resource `bob' who, as we can see, is
not available for a particular period of time, thus we can
see that there is no resource interval at all for a period
of two weeks. finally, fig. 10 (bottom-right) shows thesame evolution graph analysis with ev2 conguration, but
with a focus on another resource `eliza' who is available
throughout the whole period of the log. interestingly, the
absence of some resources for that two week period has an
impact on those resources who are available: their resource
intervals increase during that time period. furthermore,
for both resources `bob' and `eliza', they increase their
throughput as evidenced by an increase in the number of
case intervals during the spike period.
4.1.2. gradual increase of load
through the use of logs, we can demonstrate how our
approach and the related tool are able to detect a grad-
ual increase in the load of a process and of resources -
behaviours that are built into log 3. fig. 11 (left) shows
anevolution graph generated using conguration ev3 (see
table 2). in that gure, which we can see a gradual in-
crease in the number of case intervals over the duration of
the log.
the behaviour of resources in log 3 is such that they
attempt to increase the speed of their work as their work-
load increases. such resource behaviour is captured in
fig. 11 (right) whereby, through the use of an evolution
graph analysis based on conguration ev4 we can see a
gradual increase in the number of resource intervals. how-
ever, this gure also shows that the number of resource
intervals stabilizes towards the end of the graph - this can
be explained by the fact that a resource can only speed
up their work to the minimum amount of time required
to complete any work items - this forms the limit on the
number of maximum resource intervals that a resource can
possibly have within a period of time. in other words, at
full capacity, there is a limit on the maximum number of
work items that a resource can complete within a given
time period.
4.1.3. estimating the working time
it is a challenge to obtain an estimate of task working
times when we only have an event log with one event trans-
19a:sudden:spike:in:the:number:of:
new:cases.:resources:increased:
the:speed:of:their:work:accordingly
the:absence:of:some:
resources:forced:other:
resources:to:work:harder.configuration:ev1
interval:type::::::::case:interval
group:by::::::::::::::null
count::::::::::::::::::::load
graph:type:::::::::::frequency
window:length::::6:hours
timeline::::::::::::::::linear
isintervalfiltered::no
group:by:filter::::::noneconfiguration:ev2
interval:type:::::::resource:interval
group:by::::::::::::::resource
count::::::::::::::::::::load
graph:type:::::::::::frequency
window:length::::6:hours
timeline::::::::::::::::linear
isintervalfiltered::no
group:by:filter::::::bbobb
configuration:ev2
intervaltype::::::::resource:interval
group:by::::::::::::::resource
count::::::::::::::::::::load
graph:type:::::::::::frequency
window:length::::6:hours
timeline::::::::::::::::linear
isintervalfiltered::no
group:by:filter::::::belizabfigure 10: evolution graphs to detect disturbances in both process load and resource workload.
configuration4ev3
interval4types44444444:4case4interval
group4by4444444444444444:4null
count444444444444444444444:4load
graph4type4444444444444:4frequency
window4length4444444:484hours
timeline444444444444444444:4linear
isintervalfiltered444:4no
group4by4filter44444444:4noneconfiguration4ev4
interval4types4444444:4resource4interval
group4by4444444444444444:4resource
count444444444444444444444:4load
graph4type4444444444444:4frequency
window4length4444444:484hours
timeline444444444444444444:4linear
isintervalfiltered444:4no
group4by4filter44444444:4'eliza'
figure 11: evolution graphs to detect a gradual increase in process load and resource workload.
action type (e.g. complete). existing approaches (such as
the basic performance analysis [7]) attempt to do so by
calculating the duration between two events according to
our case interval denition. however, such an estimation
is most of the time too coarse, e.g. a work item related to a
case may be left untouched for an extended period due to
a variety of reasons (e.g. low importance or unavailability
of resources). by just using case intervals, the estimated
working time will also include the shelf-time of those work
items.
our approach attempts to arrive at a better estimate
of working time through the introduction of the concept
ofworking interval . by combining both case and resourceperspective (as captured by the denition of working in-
terval ), we can get a more accurate estimation of working
time even though we are still working with an information-
poor log. in particular, by reasoning about the earliest
time a work item is available and the earliest point in time
when a resource could possibly work on the work item,
we can increase the accuracy of our working time esti-
mate. this approach links back to our earlier discussion
(see section 2.2) about the uniqueness of process analysis
and, by extension, the event interval approach proposed
in this article.
fig. 12 shows an evolution graph derived from cong-
uration ev5 which shows the weekly trend of the inter-
20casewinterval
workingwinterval
actualwworking
time
configurationwev5
intervalwtypewwww:wcasewintervalw(green),
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwworkingwintervalw(blue),
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwactualwworkingwtimew(red)
groupwbywwwwwwwwwww:wnull
countwwwwwwwwwwwwwwww:wload
graphwtypewwwwwww:wduration
windowwlength:w1whour
timelinewwwwwwwwwwww:wweekly
isintervalfilteredw:wyes
groupwbywfilterww:wnone
wwwwwwwwwwwwwwwwwwwwwwwfigure 12: comparison of case interval duration and working interval duration with actual working time duration.
val duration of case intervals and working intervals , and
compares them with the actual working time of the cor-
responding work items.8as we can see, the distance be-
tween the working interval graph and the actual working
time graph is, on average, always lower than the distance
between the case interval graph and the actual working
time graph. this gure therefore demonstrates that we
can indeed obtain a more accurate picture of the working
time of variuos work items by exploiting the concept of
working interval .
furthermore, table 3 shows that the distance in the
interval duration is larger between the actual working du-
ration and the case interval duration than between the ac-
tual working duration and the working interval duration.
4.2. logs from industry
given that we have demonstrated that our tool behaves
as expected, we can now evaluate the tool using a real-
life event log. to this end, we use a log from suncorp,
8because we used a synthetic log that also contained start times-
tamp for each work item, we could obtain the actual working times
of all work items seen in the log (calculated as the duration between
the start of a work item to its completion), and use this to evaluate
the quality of our estimates.one of the largest insurance organizations in australia. in
particular, given the relatively long time-span of the data
(there are events from as early as 2008 to as late as august
2012 in the log), we only use events from the months of
january 2012 to april 2012. furthermore, we only use the
complete event transaction type in the evaluation.
4.2.1. workload
we can apply the same analysis to gauge the work-
load of resources by using the concept of resource interval .
fig. 13 (top) (generated using the conguration ev6 shows
typical resource behaviour over a number of weeks where
we can see that the workload of resources (as captured by
the total number of intervals within any 8-hour window)
reached their peaks about 5 times a week (i.e. one peak
per day). it is also interesting to note that we can clearly
see the impact of public holidays on resources' productiv-
ity from the graph as well, e.g. during new year's day,
australia day, and easter holidays there were hardly any
activities detected.
fig. 13 (bottom) shows another evolution graph de-
rived from conguration ev7 (for a particular resource rb
only). this graph shows the peculiarity of the resource's
working pattern, e.g. we can see that rbhad two periods
of leave, and that there were a number of weeks where this
21log type avg. duration std. dev
act. work time case interval work. interval act. work time case interval work interval
log 1 1036 8223 4662 9633 26571 20996
log 2 1247 18946 4842 11329 47850 21325
log 3 534 130559 4682 6930 197491 21224
table 3: average and standard deviation of actual working time duration vs. case interval and working interval durations.
configurationxevr
intervalxtypexxxxxxxxxx:xresourcexinterval
groupxbyxxxxxxxxxxxxxxxxx:xnull
countxxxxxxxxxxxxxxxxxxxxxxx:xload
graphxtypexxxxxxxxxxxxxx:xfrequency
windowxlengthxxxxxxx:x7xhours
timelinexxxxxxxxxxxxxxxxxxx:xlinear
isintervalfilteredxxx:xyes
groupxbyxfilterxxxxxxxx:xnoneexamplesxofxlnormallxweeklyxpeaksx-sxworkingxdaysdweek2
longxweekendxnx
easterxamjawxpeaksxinxaxweekxduexto
publicxholidays:
nxnewxyearxdayxnxmonxaxjanxamja
nxaustraliaxdayxnxthursxarxjanxamja
workingxonxsaturday
-rxweeklyxlocalxpeaks2
resourcexonxleavex-?2
resourcexonxleavexn
coincidingxwithxeaster
holidaysconfigurationxev?
intervalxtypexxxxxxxxxxx:xresourcexinterval
groupxbyxxxxxxxxxxxxxxxxx:xresource
countxxxxxxxxxxxxxxxxxxxxxxx:xload
graphxtypexxxxxxxxxxxxxx:xfrequency
windowxlengthxxxxxxx:x7xhours
timelinexxxxxxxxxxxxxxxxxxx:xlinear
isintervalfilteredxxxxxxxxxx:xyes
groupxbyxfilterxxxxxxxx:xresourcexb
figure 13: workload estimation using resource intervals.
resource also worked on saturday.
despite the occasional variations in the way resources
worked, we can `average out' the variations to obtain daily
and weekly patterns to extract long-term trends of re-
sources' working patterns. for example, from the dailyevolution graph analysis shown in fig. 14 (top) which is
derived from applying conguration ev8 it is quite evident
that resource a ( ra- identied with colour `blue') had a
lot more resource intervals at any given period of time,
which means that this `blue' resource completed many
22resourcemb resourcema resourcemc
resourcembresourcema
resourcemcconfigurationmev8
intervalmtypemmmmmmm:mresourceminterval
groupmbymmmmmmmmmmmmm:mresource
countmmmmmmmmmmmmmmmmmm:mload
graphmtypemmmmmmmmmm:mfrequency
windowmlengthmmmm:m1mhour
timelinemmmmmmmmmmmmmmm:mdaily
isintervalfiltered:myes
groupmbymfiltermmmmmm:mresourcema,
mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmresourcemb,
mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmresourcemc
configurationmev9
intervalmtypemmmmmmm:mresourceminterval
groupmbymmmmmmmmmmmmm:mresource
countmmmmmmmmmmmmmmmmmm:mload
graphmtypemmmmmmmmmm:mfrequency
windowmlengthmmmm:m1mhour
timelinemmmmmmmmmmmmmmm:mweekly
isintervalfilteredm:myes
groupmbymfiltermmmmmm:mresourcema,
mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmresourcemb,
mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmresourcemc
monday tuesday wednesday thursday friday saturday sundayfigure 14: daily (top) and weekly (bottom) resource interval evolution graph analysis for resource a (black), resource b (red), and resource
c (yellow).
work items. in contrast, resource b ( rb- identied with
colour `red') had the fewest resource intervals at any given
period of time. of course, a straightforward interpretation
would be to say that, assuming that all work items required
similar amount of eorts to complete, rawas considerably
more productive than rb. however, the lower number of
resource intervals for rbmay also be explained by the
fact thatrbworked on more dicult work items than
ra, hence, we see fewer work items being completed by
rb.additionally, we can see that ra, on average, started
work much earlier than any other resource (the rst non-
zero interval was recorded between 6 am and 7 am daily).
in contrast, resource c ( rc) was the last one to start
his/her working day (the rst non-zero interval was recorded
between 10 am and 11 am daily), although rcalso nished
the latest among the three (between 6 pm and 7 pm).
however, if we look at the weekly pattern shown on
fig. 14 (bottom) which is derived by applying congura-
tion ev9 we can obtain more detailed insights. while ra
23april
aprilconfigurationfev10
intervalftypeffffffff:fcasefinterval
groupfbyfffffffffffffff:fnull
countffffffffffffffffffff:fload
graphftypefffffffffff:ffrequency
windowflengthfff:f8fhours
timelinefffffffffffffff:flinear
isintervalfiltered:fyes
groupfbyffilterfffff:fnone
configurationfev11
intervalftypeffffffff:fcasefinterval
groupfbyfffffffffffffff:fresource
countffffffffffffffffffff:fload
graphftypefffffffffff:ffrequency
windowflengthfff:f8fhours
timelinefffffffffffffff:flinear
isintervalfiltered:fyes
groupfbyffilterfffff:fresourcefafigure 15: the case interval evolution graph analysis for the process (top) and for resource a (bottom).
still maintained a high number of resource intervals, rc
seemed to have more intervals than rabetween tuesday
to thursday; however, the productivity of rcseemed to
dip on friday. furthermore, we can also see that both ra
andrbconducted work on saturday, while this was not
the case for rc.
fig. 15 depicts the workload of resources seen in the
suncorp log. the top part of this gure shows the aggre-
gate workload of all resources (obtained by applying evolu-
tion graph analysis using conguration ev10 fig. 15 (bot-tom), derived from conguration ev11, shows the case in-
terval evolution for resource a. the shape of both graphs
shows that on average, the overall workload of the system
remains more or less constant, except towards the month
of april whereby there is a noticeable dip in the workload
for both the overall process and for resource a.
4.2.2. resource utilization
similar to workload analysis, we can apply a number
of event interval analyses to gauge the utilization of re-
24sources. for an overview, we can always start with a sim-
ple metric analysis, such as fmetric (rgres) (see fig. 16)
to get a sense of the amount of time taken by resources to
complete a work item. this gure shows that the longest
median resource interval duration was roughly 205 minutes
and it was performed by a particular resource x. further-
more, one can roughly say that 30 minutes seems to be a
good median for resource interval duration in general.
of course, to get a more detailed view, we can also
apply our evolution graph analysis. fig. 17(a) shows an
evolution graph derived from conguration ev12 whereby
we can see that on average, resources did not take too long
to complete a work item (as captured by the relatively
lowresource interval duration for all resources - about 15
minutes).
we can also focus closer on a number of resources to
compare their speed in completing work items. fig. 18(a)
shows the evolution graph (derived from conguration ev13)
for two resources: resource a and resource d. as can be
seen, on average, resource d took longer to complete work
items.
to check if it is true that resource d took longer to
complete work items, we can of course use a similar evo-
lution graph analysis, however this time, by using weekly
graph conguration (as derived by applying conguration
ev14 as shown in fig. 17(b). in this gure, the average
peak interval duration for resource a was around 10 min-
utes (with the exception of, interestingly, friday whereby
the average duration was higher on average). neverthe-
less, when we compare resource a and resource d, we can
see that on most days, notably mondays, tuesdays, and
wednesdays, resource a performed quicker than resource
d. the exceptions to this observation are for wednesdays
and fridays.
there is a very simple explantion to the phenomenon
just observed. fig. 18(b) shows a zoomed-in picture of
fig. 18(a) (the section bounded in a red-rectangle). from
this gure, if we look closely, we can see that resource dactually worked part-time and he/she often took wednes-
day as a non-working day (we can conclude this due to
the fact that there was no resource interval at all for many
wednesdays for resource d), thus, lowering the average
resource interval duration for wednesdays for resource d.
the phenomenon seen on fridays requires further investi-
gation and consultation with domain experts to be able to
explain it properly.
another aspect of utilization is the duration and fre-
quency of `waiting times' that both resources and cases
need to endure (higher waiting times often signal sub-
optimal scheduling and/or deployment of resources). we
can use both resource waiting interval (rig) and case
waiting interval (cig) to gauge resources and cases wait-
ing times respectively. fig. 19 (top) shows an evolution
graph derived by applying conguration ev15. this g-
ure shows that, most of the time, the case waiting times
(as deduced from case waiting interval ) were longer than
resource waiting times (from resource waiting interval ).
such a dierence becomes evident when we look at the
weekly pattern of the case- and resource- waiting times as
shown in fig. 19 (bottom) which was derived from con-
guration ev16. one possible interpretation of this phe-
nomenon is that the system was under-resourced, hence,
more often than not, cases needed to wait for resources to
be available.
4.2.3. explaining the interval duration
decision tree analysis is useful when we want to extract
factors that may inuence the length of the duration of
intervals. for example, we may want to nd out if the
combination of certain activity types and resources may
inuence the working time of work items (i.e. the duration
ofworking intervals ).
using the same log as the one used in section 4.2.1
and section 4.2.2, we applied our decision tree analysis
(using activity types and resources as the predictor vari-
ables ) to understand the impact of the predictor variables
25median 
(blue)
average
(red)
standard deviation
 (green)res. x res. y30 minutesfigure 16: simple metrics analysis fmetric (rgres).
on the length of the working interval durations.the work-
ing intervals used in this analysis were grouped by all (i.e.
wg?). the data types for both the predictor variables
were set to nominal. furthermore, we also used the tool
to automatically label the intervals in the data into two
classes (`long' and `short') based on the distribution of the
durations (that is, those intervals with durations shorter
than the median interval duration are labelled as `short',
and vice versa). an example of the labelled data produced
by the tool is provided in table 4.
using the labelled data, the tool performed a decision
tree analysis to check if the duration of working intervals
can be explained by activities and/or resources. the result
of the analysis is shown in fig. 20. in this case, the deci-
sion tree managed to correctly classify about three quar-
ters of all the working interval durations seen in the log
with the kappa statistics [3] of 0.5 (which is commonly in-
terpreted as having a `moderate' agreement that the clas-
sication result is not the result of pure chance). with-out domain knowledge, it is quite dicult to interpret if
this classication is `good' or `bad'; however, the interest-
ing point from this analysis is that we can extract insight
about the correlation between duration of event interval
with other factors, including the activity type and the re-
sources who executed them. for example, we can see that
activities ` follow up requested information ' and ` contact
assessor ' were likely to have relatively `short' interval du-
rations, while other activities, such as ` re-issue document '
and ` follow-up stakeholders (decline) ', were likely to have
`long' interval durations. for other activities, such as con-
sider closing claim , the working interval durations were de-
pendent on the resources who executed the activity. for
example, as shown in fig. 21, when resource k executed
the activity, the interval durations were likely to be `short',
however, when resource l orresource m executed the ac-
tivity, the durations were likely to be `long'.
by applying a decision tree analysis on event interval
durations, we can thus gain preliminary insights into those
2615hminutes
10hminutesfri
wedconfigurationhev12
intervalhtypehhhhhhh:hresourcehinterval
grouphbyhhhhhhhhhhhhhh:hnull
counthhhhhhhhhhhhhhhhhhh:hunique
graphhtypehhhhhhhhhh:hduration
windowhlengthhhh:h12hhours
timelinehhhhhhhhhhhhhhh:hlinear
isintervalfiltered:hyes
grouphbyhfilterhhhh:hnone
configurationhev14
intervalhtypehhhhhhh:hresourcehinterval
grouphbyhhhhhhhhhhhhhh:hresource
counthhhhhhhhhhhhhhhhhhh:hunique
graphhtypehhhhhhhhhh:hduration
windowhlengthhhh:h1hhour
timelinehhhhhhhhhhhhhhh:hweekly
isintervalfiltered:hyes
grouphbyhfilterhhhh:hresourcehah)blued
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhresourcehdh)redd(a)
(b)figure 17: resource interval duration for all resources (a), and weekly resource interval duration (b) for resource a and resource d.
resource activity label
resource j note received short
resource p follow up from repairer long
resource o review and approve new payment long
resource c follow up insured short
..... ....... ......
table 4: an example of labelled data produced from the event interval analysis tool.
factors that inuence the working or waiting times of var-
ious work items.
4.3. summary
as demonstrated, the event interval analysis proposed
in this article can be used to answer a variety of performance-related questions about resources as well as processes us-
ing event logs containing minimal information. using syn-
thetic logs that were built with particular characteristics
in mind, we have shown that the implementation of the
event interval analysis is correct in that expected insights
about process-related performance could be extracted suc-
27configurationrev13
intervalrtyperrrrrrr:rresourcerinterval
grouprbyrrrrrrrrrrrrrr:rresource
countrrrrrrrrrrrrrrrrrrr:runique
graphrtyperrrrrrrrrr:rduration
windowrlengthrrr:r1rhour
timelinerrrrrrrrrrrrrrr:rlinear
isintervalfiltered:ryes
grouprbyrfilterrrrr:rresourcerar(blue)
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrresourcerdr(red)(a)
resourcerdrdidrnotrhave
anyractivitiesronronerorrmore
daysrinrarweekr(oftenrwed
butrnotralways)(b)figure 18: resource interval duration for resource a and resource d (a), and the corresponding zoomed-in region (b).
cessfully. more importantly, by applying our event inter-
val analysis on a real-world information-poor event log, we
have shown that our tool is able to extract interesting in-
sights into the performance of an insurance organisation's
processes and their resources. in other words, we have
shown that the proposed event interval analysis is t for
the purpose of answering typical questions related to pro-
cess performance.
in particular, we have shown how the concept of work-
ing interval, which takes into account both the case and
resource perspectives, can be used to arrive at a more pre-
cise estimation of working time. through the use of evo-lution graph analysis, we can compare the throughput of
dierent resources over the same period of time, as well
as compare trends related to the way in which resources
carry out their tasks. through the use of resource- and
case-waiting intervals, we can discover idle periods in both
resources and processes. finally, we have shown that our
analysis approach allows one to learn correlation between
the duration of event intervals and other attributes that
exist in event logs.
28resource5waiting5interval
8red6case5waiting5interval
8blue6305minutes
resource5waiting5interval
8red6case5waiting5interval
8blue6 245minutes
25minutesconfiguration5ev15
interval5type5555555555555:5case5waiting5interval58blue6
55555555555555555555555555555555555555resource5waiting5interval58red6
group5by55555555555555555555:5null
count5555555555555555555555555:5unique
graph5type55555555555555555:5duration
window5length55555555555:585hours
timeline555555555555555555555:5linear
isintervalreset5555555555:5yes
group5by5filter555555555555:5none
configuration5ev16
interval5type55555555555555:5case5waiting5interval58blue6
555555555555555555555555555555555555555resource5waiting5interval58red6
group5by55555555555555555555:5null
count5555555555555555555555555:5unique
graph5type55555555555555555:5duration
window5length5555555555:535hours
timeline555555555555555555555:5weekly
isintervalfiltered555555:5yes
group5by5filter555555555555:5nonefigure 19: case and resource waiting times using case waiting intervals (cig) and resource waiting intervals (rig).
5. related work
in the domain of process mining, there have been a
number of research approaches that look at extracting per-
formance information from event logs. one of the earliest
pieces of work in this space includes the performance anal-
ysis with petri nets apprach by van der aalst and van don-
gen [20], later extended by hornix [7]. this work looks at
how one can replay an event log on a process model (ex-
pressed as a petri net) to extract performance information,
such as sojourn time, waiting time, and working time ofthe work items related to the process. essentially, the un-
derlying technique applied by this approach is similar to
the concept of case interval dened in this paper. fur-
thermore, this approach uses process models to compute
performance information; however, it is often impossible to
discover good process models due to infrequent behaviours
and/or incomplete log. our event interval analysis ap-
proach attempts to overcome this issue by not relying on
the existence of a process model in order to extract more
rened performance information.
29results2for2interval2pnalysis_hjwl:l_none
ssssssssssssss
correctly2classified2instances2222222hhhhh222222222222222jhn<lhh2m
incorrectly2classified2instances22222|-<-<222222222222222|ln/hlh2m
kappa2statistic22222222222222222222222222<nh|<j
mean2absolute2error2222222222222222222222<nl||2
root2mean2squared2error222222222222222222<nw<w|
relative2absolute2error22222222222222222hwnw-/w2m
root2relative2squared2error2222222222222:<n:w|h2m
coverage2of2cases2q<n/h2levelg2222222222//nh:h22m
mean2reln2region2size2q<n/h2levelg222222/hnjhjh2m
total2number2of2instances222222222222:jhjh22222
sss2confusion2matrix2sss
22222a22222b222xtt2classified2as
2lljw<2-<:lh2|22222a2s2low
2-<-jw2l|/|h2|22222b2s2high
jw:2pruned2tree
tttttttttttttttttt
activity2s2ci2t2contact2assessorf2low2q--n<xhn<g
activity2s2ci2t2follow2up2stakeholders2qdeclinegf2high2qwn<x-n<g
activity2s2xs2outstandingf2low2ql-jn<x//n<g
activity2s2review2pssignmentf2high2qln<x-n<g
activity2s2ci2t2pppoint2assessorf2low2qwn<x|n<g
activity2s2ci2t2follow2up2requested2informationf2low2qj-hn<x-l<n<g
activity2s2pssessment2report2receivedf2high2qhn<x-n<g
activity2s2ci2t2retissue2documentf2high2q--n<g
nnn
nnn
activity2s2confirm2interested2party2intentions2on2major2lossf2high2q-n<g
activity2s2sup2co2updatef2low2qwn<x|n<g
activity2s2ci2t2contact2third2party2x2insurerf2low2q-n<g
activity2s2consider2closing2claim
|222resource2s2resource2kf2low2q|n<x-n<g
|222resource2s2resoure2lf2high2q<n<g
|222resource2s2resource2mf2high2q<n<g
|222nnn
|222nnn
|222resource2s2resource2zf2high2q<n<g
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss222a22222222b2222xtt2classified2as
2lljw<2-<:lh2|22222a2s2low
2-<-jw2l|/|h2|22222b2s2higha2s2short2duration2qbottom2h<mg
b2s2long2duration2qtop2h<mgjhm2correctly2classified
|wm2incorrectly2classified
contact2assessor
follow2up2stakeholders2qdeclineg
follow2up2requested2information
retissue2documentfigure 20: decision tree analysis result detailing the correlation between working interval duration and activity types/resources.
activity
low high highresourcecontact
assessor
follow-up-
stakeholders
(decline)follow-uprequested-information
re-issue-documentlowconsider-closing
claim
low high highresource-kresource-lresource-m
figure 21: graphical representation of the decision tree
moreover, the performance analysis with petri nets ap-
proach does not exploit the concept of resource interval .
one can argue that the concept of resource interval can al-
ways be supported by the performance analysis with petri
nets approach by `re-tagging' the resource identier at-
tribute in an event log as the case identier. while thismay be the case, the performance analysis with petri nets
approach still does not support the consideration of both
the case and the resource perspectives simultaneously in
the manner proposed in this article. as a result, estima-
tion of waiting times can only be performed if the log con-
tains at least two event transaction types (either `sched-
30ule'/`start' or `start'/`complete').9
other approaches to performance analysis within the
domain of process mining exploit the `fuzzy mining' con-
cept [23, 1, 5, 6, 16]. these fuzzy-based approaches tend
to be rather intuitive as they use graphical cues to convey
performance information (e.g. the use of thicker edges to
represent highly-traversed paths and the use of colours to
reprsent high/low/medium throughput times). further-
more, the projection of performance information onto pro-
cess models improves the intuitiveness and understandabil-
ity of the performance information extracted. however,
these fuzzy-based approaches only consider case intervals ,
and the interplay between proces and resource perspectives
is not supported.
popova and sharpanskykh [13] propose the use of tem-
poral trace language to extract various process-related
properties (including conformance and performance met-
rics) from event logs. upon a closer look at the approach,
we can also see that this approach extracts performance
information strictly from the case perspective only.
adriansyah [18, 2] proposes a robust performance anal-
ysis approach by removing `deviant' events that cannot
be paired to form a proper `interval' for the purpose of
counting interval duration. this is achieved by `aligning'
a known process model with the events seen in the cor-
responding log. such an approach provides rather reli-
able performance information, assuming the existence of
the corresponding process model. nevertheless, similar to
other approaches discussed before, the use of alignment for
performance analysis only considers performance from the
case perspective and not in combination with the resource
perspective.
9the authors argued that their approach can estimate the upper
bound value for waiting times, sojourn times, and execution times
even when the log only contains one event transaction type, namely
`start' [7]. nevertheless, as stated in the documentation of this plug-
in in the prom 5.1 tool, the calculation of waiting times, sojourn
times, and execution times will overlap, thus we do not consider
such an approach to allow proper waiting time estimations.the work by nakatumba [12, 11] is the closest to the
event interval analysis framework proposed in this article.
this work extracts performance information from both the
case and resource perspectives. concepts equivalent to the
various types of intervals dened in this paper (e.g. case
interval ,resource interval , and working interval ) are de-
ned and manipulated to obtain deeper insights into not
only process performance, but also performance-related
behaviour (such as resources availability analysis). while
the base concepts applied in this work are similar to our
event interval analysis framework, our work diverges in
terms of how the concept of intervals can be used. in the
work of nakatumba, the concept of event intervals is ap-
plied to extract resource availability, as well as to repair
logs that miss certain event transaction timestamps. in
our work, however, we generalized the concept of event
intervals, and built a exible framework that allows the
manipulation of event intervals (through various group by
mechanisms and analysis types ) such that wider ranges of
insights can be extracted. moreoever, we are not aware
of any process mining techniques that extract daily and
weekly patterns of process behaviours.
finally, questions often arise regarding the dierence
between our approach and other forms of data analyt-
ics, including data mining and spreadsheet analysis. we
highlight here that the key distinguishing feature of our
approach boils down to the very nature of the event log
data and the type of problems that we address which re-
quire the application of process perspective to solve. in
section 2.1, we have elaborated the distinguishing feature
of an event log whereby there exists temporal constraints
between events in the log allowing the notion of a process
to be captured and analysed. here, we would also like to
argue the type of questions that our approach attempts
to address are process-related whereby dierent perspec-
tives (such as case and resource perspectives) need to be
considered. for example, to address questions such as the
changes in resources' workload over time, or the seasonal
31pattern of process loads, one needs to engage in a rather
elaborate data analysis to provide an accurate answer.
most importantly, such analysis is not readily support,
nor is it typically performed, by traditional data mining
or spreadsheet analysis.
6. conclusions and future work
in this article, we have proposed, formalised, imple-
mented, and evaluated a new framework for extracting
performance information from information-poor event logs.
in particular, we have shown how we can uncover various
types of event intervals from such a log and apply them in
various ways to extract useful insights about performance-
related behaviours from the perspectives of both process
and resources involved. as detailed in section 2.1, we
have highlighted the temporal constraints that one needs
to tackle in addressing process-related problems. exist-
ing data analytics (including data mining and spreadsheet
analysis) cannot extract the required insights from event
data.
the application of our framework to a real-life event
log (from suncorp) has demonstrated that our framework
can indeed extract interesting and useful insights that have
thus far previously dicult to extract. our analysis shows
that extracting cyclical process behaviours (e.g. daily or
weekly) provides us with interesting and valuable insights
about seasonal behaviours of resources as well as process
loads; yet this is rarely investigated because the majority
of current process mining techniques tend to focus on the
control-ow perspective. more importantly, the insights
obtained from the use of our event interval analysis are
invaluable for the purpose of making well-informed deci-
sions . for example, by understanding the weekly varia-
tions in employees' workload (obtained through the evo-
lution graph analysis), one can better manage employee's
working hours, especially those part-time workers. fur-
thermore, through decision tree analysis, one may gain
insights into the factors inuencing the existence of largechunks of idle periods for resources, thus, allowing one to
implement well-targeted remedial actions.
a key limitation of our framework is the assumption
that, within a case, all work items occurred sequentially.
this assumption has the unwanted eect of including inter-
vals with pairs of events that actually occurred in parallel.
for example, assume that the completion of an event eain
a casecatriggers a parallel execution of two events eband
ecwithin the same case. as recorded in the log, we see
the following ordering of events: ea< eb< ec. possible
case intervals that can be extracted from such a sequence
of events include ( ea;eb) and (eb;ec). as a result, the in-
terpretation of the time period between those intervals as
the maximum sojourn times for the corresponding work
items is misleading. obviously, the `correct' case intervals
in this scenario are ( ea;eb) and (ea;ec).
we argue that the above limitation is surmountable by
rening our denition of a interval with an additional re-
striction: any two events e0ande1(e0<e1) can only form
a interval if e0ande1have a direct causal relationship.
such relationships can be derived through the analysis of
input and output data as conducted by lu [10]. we can
also discover direct causal relationships by applying well-
established algorithms in the eld of process mining, such
as the alpha algorithm [20].
finally, our tool currently relies on human users to
identify interesting patterns in the analysis results (which
are often displayed as graphs). as part of the future work,
we plan to extend the tool to be able to automatically
highlight regions in the graphs that may capture inter-
esting process performance-related phenomenon (e.g. a
change in a user's throughput).
acknowledgement.. this work was supported by the
australian research council discovery project entitled
risk-aware business process management (dp110100091).
[1] arya adriansyah. performance analysis of business processes
from event logs and given process models. master's thesis, eind-
hoven university of technology, 2009.
32[2] arya adriansyah. aligning observed and model behavior . phd
thesis, eindhoven university of technology, 2014.
[3] jean carletta. assessing agreement on classication tasks: the
kappa statistic. comput. linguist. , 22(2):249{254, june 1996.
[4] technische universiteit eindhoven. xes standard denition ,
1.4 edition, october 2012.
[5] christian w. g unther. process mining in flexible environ-
ments . phd thesis, eindhoven university of technology, 2008.
[6] christian w. g unther and wil m.p. van der aalst. fuzzy
mining- adaptive process simplication based on multi-
perspective metrics. in gustavo alonso, peter dadam, and
michael rosemann, editors, business process management , vol-
ume 4714 of lncs , pages 328{343. springer, 2007.
[7] peter t.g hornix. performance analysis of business processes
through process mining. master's thesis, technische universiteit
eindhoven, 2007.
[8] teresa jones. identify abpd's business benets and understand
vendor strengths. gartner , (g00247367), may 2013.
[9] ruth liew. suncorp banks on data mining to slash claims.
australian financial review , 2013.
[10] xixi lu. artifact-centric log extraction and process dis-
covery. master's thesis, eindhoven university of technol-
ogy, 2013. http://www.processmining.org/_media/blogs/
pub2013/finalthesis_-_lu.pdf .
[11] joyce nakatumba. resource-aware business process manage-
ment: analysis and support . phd thesis, eindhoven university
of technology, 2013.
[12] joyce nakatumba and wil m. p. van der aalst. analyzing
resource behavior using process mining. in stefanie rinderle-
ma et al., editor, business process management workshops ,
volume 43 of lnbip , pages 69{80. springer, 2009.
[13] viara popova and alexei sharpanskykh. formal analysis of
executions of organizational scenarios based on process-oriented
specications. applied intelligence , 34(2):226{244, 2011.
[14] qpr software. from opportunity to delivery, end-to-
end process transparency for ruukki. 2013. http:
//www.win.tue.nl/ieeetfpm/lib/exe/fetch.php?media=:
casestudies:processmining_casestudy_ruukki_qpr.pdf . last
accessed 26 march 2014.
[15] john r. quinlan. c4.5: programs for machine learning . morgan
kaufmann publishers inc., san francisco, ca, usa, 1993.
[16] anne rozinat. disco user's guide . fluxicon, 2012. https://
fluxicon.com/disco/files/disco-user-guide.pdf . last ac-
cessed 28 march 2014.
[17] suriadi suriadi, moe t. wynn, chun ouyang, arthur h. m.
ter hofstede, and nienke j. van dijk. understanding process
behaviours in a large insurance company in australia: a case
study. in camille salinesi, moira c. norrie, and oscar pas-tor, editors, advanced information systems engineering , vol-
ume 7908 of lncs , pages 449{464. springer, 2013.
[18] wil m. p. van der aalst, arya adriansyah, and boudewijn f.
van dongen. replaying history on process models for con-
formance checking and performance analysis. wiley interdis-
ciplinary reviews: data mining and knowledge discovery ,
2(2):182{192, 2012.
[19] wil m. p. van der aalst et al. process mining manifesto. in
florian daniel, kamel barkaoui, and schahram dustdar, edi-
tors, business process management workshops , volume 99 of
lnbip , pages 169{194. springer, 2011.
[20] wil m. p. van der aalst and boudewijn f. van dongen. discov-
ering workow performance models from timed logs. in yanbo
han, stefan tai, and dietmar wikarski, editors, engineering
and deployment of cooperative information systems , volume
2480 of lncs , pages 45{63. springer, 2002.
[21] wil m.p. van der aalst. process mining - discovery, con-
formance and enhancement of business processes . springer,
2011.
[22] boudewijn van dongen. mxml - a meta model
for process mining data. presentation at enterprise
modelling and ontologies for interoperability workshop
2005, june 2005. http://www.processmining.org/_media/
presentations/miningmetamodelimoa2005.ppt - last accessed
27 feb 2014.
[23] boudewijn f. van dongen and arya adriansyah. process min-
ing: fuzzy clustering and performance visualization. in busi-
ness process management workshops , volume 43 of lnbip ,
pages 158{169. springer, 2009.
[24] boudewijn f. van dongen, ana k.a. de medeiros, h.m.w.
verbeek, a.j.m.m weijters, and wil m. p. van der aalst. the
prom framework: a new era in process mining tool support.
in gianfranco ciardo and philippe darondeau, editors, appli-
cations and theory of petri nets , volume 3536 of lncs , pages
444{454. springer, 2005.
[25] bram vanschoenwinkel. case study - process min-
ing: package delivery. 2012. http://www.win.tue.
nl/ieeetfpm/lib/exe/fetch.php?media=:casestudies:
ae_case_process_mining.pdf . last accessed 26 march 2014.
[26] h.m.w. verbeek, j.c.a.m. buijs, b.f. van dongen, and
w.m.p. van der aalst. xes, xesame, and prom 6. in infor-
mation systems evolution , volume 72 of lnbip , pages 60{75.
springer, 2011.
33