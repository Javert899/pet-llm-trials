recursion aware modeling and discovery for hierarchical
software event log analysis (extended)
leemans, m.; van der aalst, w.m.p.; van den brand, m.g.j.
published in:
arxiv
published: 17/10/2017
document version
publisher’s pdf, also known as version of record (includes final page, issue and volume numbers)
please check the document version of this publication:
• a submitted manuscript is the author's version of the article upon submission and before peer-review. there can be important differences
between the submitted version and the official published version of record. people interested in the research are advised to contact the
author for the final version of the publication, or visit the doi to the publisher's website.
• the final author version and the galley proof are versions of the publication after peer review.
• the final published version features the final layout of the paper including the volume, issue and page numbers.
link to publication
citation for published version (apa):
leemans, m., van der aalst, w. m. p., & van den brand, m. g. j. (2017). recursion aware modeling and
discovery for hierarchical software event log analysis (extended). arxiv, 1-14. [1710.09323v1].
general rights
copyright and moral rights for the publications made accessible in the public portal are retained by the authors and/or other copyright owners
and it is a condition of accessing publications that users recognise and abide by the legal requirements associated with these rights.
            • users may download and print one copy of any publication from the public portal for the purpose of private study or research.
            • you may not further distribute the material or use it for any profit-making activity or commercial gain
            • you may freely distribute the url identifying the publication in the public portal ?
take down policy
if you believe that this document breaches copyright please contact us providing details, and we will remove access to the work immediately
and investigate your claim.
download date: 14. jan. 2018recursion aware modeling and discovery
for hierarchical software event log analysis (ext.)
technical report version with guarantee proofs for the discovery algorithms
maikel leemans
eindhoven university of technology
eindhoven, the netherlands
email: m.leemans@tue.nlwil m. p. van der aalst
eindhoven university of technology
eindhoven, the netherlands
email: w.m.p.v.d.aalst@tue.nlmark g. j. van den brand
eindhoven university of technology
eindhoven, the netherlands
email: m.g.j.v.d.brand@tue.nl
abstract —this extended paper presents 1) a novel hierarchy
and recursion extension to the process tree model; and 2)
the ﬁrst, recursion aware process model discovery technique
that leverages hierarchical information in event logs, typically
available for software systems. this technique allows us to
analyze the operational processes of software systems under real-
life conditions at multiple levels of granularity. the work can be
positioned in-between reverse engineering and process mining.
an implementation of the proposed approach is available as a
prom plugin. experimental results based on real-life (software)
event logs demonstrate the feasibility and usefulness of the
approach and show the huge potential to speed up discovery
by exploiting the available hierarchy.
keywords -reverse engineering; process mining; recursion
aware discovery; event log; hierarchical event log; process
discovery; hierarchical discovery; hierarchical modeling
i. i ntroduction
system comprehension, analysis, maintenance, and evo-
lution are largely dependent on information regarding the
structure, behavior, operation, and usage of software systems.
to understand the operation and usage of a system, one has
to observe and study the system “on the run”, in its natural,
real-life production environment. to understand and maintain
the (legacy) behavior when design and documentation are
missing or outdated, one can observe and study the system in a
controlled environment using, for example, testing techniques.
in both cases, advanced algorithms and tools are needed to
support a model driven reverse engineering and analysis of
the behavior, operation, and usage. such tools should be able
to support the analysis of performance (timing), frequency
(usage), conformance and reliability in the context of a behav-
ioral backbone model that is expressive, precise and ﬁts the
actual system. this way, one obtains a reliable and accurate
understanding of the behavior, operation, and usage of the
system, both at a high-level and a ﬁne-grained level.
the above design criteria make process mining a good
candidate for the analysis of the actual software behavior .
process mining techniques provide a powerful and mature way
to discover formal process models and analyze and improve
these processes based on event log data from the system [46].
event logs show the actual behavior of the system, and could
be obtained in various ways, like, for example, instrumentation
techniques. numerous state of the art process mining tech-
niques are readily available and can be used and combinedthrough the process mining toolkit prom [53]. in addition,
event logs are backed by the ieee xes standard [22], [53].
typically, the run-time behavior of a system is large and
complex. current techniques usually produce ﬂat models that
are not expressive enough to master this complexity and are
often difﬁcult to understand. especially in the case of software
systems, there is often a hierarchical, possibly recursive,
structure implicitly reﬂected by the behavior and event logs.
this hierarchical structure can be made explicit and should be
used to aid model discovery and further analysis.
in this paper, we 1) propose a novel hierarchy and recursion
extension to the process tree model; and 2) deﬁne the ﬁrst,
recursion aware process model discovery technique that lever-
ages hierarchical information in event logs, typically available
for software systems. this technique allows us to analyze
the operational processes of software systems under real-life
conditions at multiple levels of granularity. in addition, the
proposed technique has a huge potential to speed up discovery
by exploiting the available hierarchy . an implementation of
the proposed algorithms is made available via the statechart
plugin for prom [30]. the statechart workbench provides an
intuitive way to discover, explore and analyze hierarchical
behavior, integrates with existing prom plugins and links back
to the source code in eclipse.
this paper is organized as follows (see figure 1). section ii
positions the work in existing literature. section iii presents
formal deﬁnitions of the input (event logs) and the proposed
novel hierarchical process trees. in section iv, we discuss
how to obtain an explicit hierarchical structure. two proposed
novel, hierarchical process model discovery techniques are
explained in section v. in section vi, we show how to ﬁlter,
annotate, and visualize our hierarchical process trees. the
approach is evaluated in section vii using experiments and
a small demo. section viii concludes the paper.
fig. 1. outline of the paper and our discovery approach.arxiv:1710.09323v1  [cs.se]  17 oct 2017table i
comparison of related techniques and the expressiveness of the resulting models ,divided into the groups from section ii.
author technique / toolkit input formalismexecution semantics
model qualityaggregate runs frequency infoperformance info
choiceloopconcurrencyhierarchynamed submodels
recursionstatic analysis[45] tonella object ﬂow analysis c++ source code uml interact. - n/a n/a - - - - - - - -
[27] kollmann java code structures java source code uml collab. - n/a n/a - - - - - - - -
[28] korshunova cpp2xmi, squadt c++ source code uml sd, ad - n/a n/a - -x x - - - -
[40] rountev dataﬂow analysis java source code uml sd 1n/a n/a - -x x - - - -
[4] amighi sawja framework java byte code cfg - n/a n/a - -x x - - - -dynamic analysis[3] alalﬁ php2xmi instrumentation uml sd 1- - - - - - - - - -
[39] oechsle ja v a vis java debug interface uml sd 1- - - - - -x - - -
[11] briand meta models / ocl instrumentation uml sd 1- - - -x x - - - -
[10] briand meta models / ocl instrumentation uml sd 1- - - -x x x - - -
[29] labiche meta models / ocl instrumentation + source uml sd 1- - - -x x - - - -
[44] syst ¨a shimba customized debugger sd variant 1- - - -x x - - - -
[55] walkinshaw mint log with traces efsm x xx - -x x - - - -
[8] beschastnikh csight given log, instrument cfsm x xx - -x x x - - -
[1] ackermann behavior extraction monitor network packets uml sd 1-x -xx x - - - -
[20] graham gprof proﬁler instrumentation call graphs - - - -x - - -x x8
[17] de pauw execution patterns program trace exec. pattern - - -x - -x -x x x
[7] beschastnikh synoptic log with traces fsm x xx x -x x - - - -
[23] heule dfasat log with traces dfa x xx - -x x - - - -grammar[38] nevill-manning sequitur symbol sequence grammar x - - - - - - -x - -
[41] siyari lexis symbol sequence lexis-dag x -x - - - - -x - -
[26] jonyer subduegl symbol graph graph grammar x - - - -x - -x -9process mining[49] van der aalst alpha algorithm event log petri net x -x x2x2x x x - - -
[48] van der aalst theory of regions event log petri net x -x x2x2x x x - - -
[56] weijters flexible heuristics miner event log heuristics net x -x x2x2x x x - - -
[50] werf, van der ilp miner event log petri net x xx x2x2x x x - - -
[52] zelst, s. j. van ilp with ﬁltering event log petri net x xx x2x2x x x - - -
[47] alves de medeiros genetic miner event log petri net x xx x2x2x x x - - -
[12] buijs etm algorithm event log process tree x xx x2x2x x x - - -
[35] leemans s.j.j. inductive miner event log process tree x xx x2x2x x x - - -
[21] g ¨unther fuzzy miner event log fuzzy model - -x x3-x x4-x - -
[25] bose two-phase discovery event log fuzzy model - -x x3-x x5-x - -
[15] conforti bpmn miner event log bpmn x xx22x x6x x - -
this paper recursion aware disc. event log h. process tree*x xx x2x2x x7x x x x
1formal semantics are available for uml sd variants.
2aligning an event log and a process model enables advanced performance,
frequency, and conformance analysis, as described in [2], [35].
3various log-based process metrics have been deﬁned which capture different
notions of frequency, signiﬁcance, and correlation [21].
4the hierarchy is based on anonymous clusters in the resulting model [21].5the hierarchy is based on abstraction patterns over events [24], [25].
6the hierarchy is based on discovered relations over extra data in the event log.
7the hierarchy is based on the hierarchical information in the event log.
8recursion is detectable as a cycle, but without performance analysis support.
9only tail recursion is supported.
*hierarchical process tree , as introduced in deﬁnition iii.3.
ii. r elated work
substantial work has been done on constructing models
from software or example behavior in a variety of research
domains. this section presents a brief comparison of various
approaches and focuses mainly on the design criteria from the
introduction. that is, the approach and tools should provide
a behavioral backbone model that is expressive, precise and
ﬁts the actual system, and ideally should be able to support
at least performance (timing) and frequency (usage) analysis.
table i summarizes the comparison.
a. groups and criteria for comparison
we have divided the related work into four groups. static
analysis utilizes static artifacts like source code ﬁles. dynamic
analysis utilizes runtime information through instrumentation
or tracing interfaces like debuggers. grammar inference relies
on example behavior in the form of abstract symbol sequences.process mining relies on events logs and is in that sense a more
implementation or platform agnostic approach.
for the comparison on design criteria, we deﬁne three sets
of features. firstly, a precise and ﬁt model should: a) have
formal execution semantics , and b) the underlying discovery
algorithm should either guarantee or allow the user to con-
trol the model quality . the quality of a model is typically
measured in terms of metrics like ﬁtness and precision , but
other qualities (e.g., simplicity and generalization) can also
be considered [46]. fitness expresses the part of the log (c.q.
system behavior) that is represented by the model; precision
expresses the behavior in the model that is present in the
log (c.q. system behavior). secondly, the model should be
used as the backbone for further analysis. at the very least,
frequency (usage) and performance (timing) analysis should
be supported. in addition, the analysis should be (statistically)
signiﬁcant, and hence the technique should be able to aggre-
gate information over multiple execution runs. thirdly, themodel should be expressive and be able to capture the type
of behavior encountered in software system cases. not only
should branching behavior like choices (e.g., if-then-else) and
loops (e.g., foreach, iterators) be supported, but also hierarchy
and recursion. furthermore, for hierarchies, meaningful names
for the different submodels are also important.
b. discussion of the related work
in general, static and symbolic analysis of software has
difﬁculty capturing the actual, dynamic behavior; especially in
the case of dynamic types (e.g., inheritance, dynamic binding,
exception handling) and jumps. in these cases, it is often
favorable to observe the actual system for the behavior. since
static techniques either unfold or do not explore function calls,
they lack support for recursive behavior. in addition, because
these techniques only look at static artifacts, they lack any
form of timing or usage analysis.
in the area of dynamic analysis, the focus is on obtaining
a rich but ﬂat control ﬂow model. a lot of effort has been
put in enriching models with more accurate choice and loop
information, guards, and other predicates. however, notions
of recursion or preciseness of models, or application of these
models, like for analysis, seems to be largely ignored. the
few approaches that do touch upon performance or frequency
analysis ([1], [17], [20]) do so with models lacking formal
semantics or model quality guarantees.
in contrast to dynamic analysis techniques, grammar infer-
ence approaches are actively looking for repeating sub patterns
(i.e., sources for hierarchies). the used grammars have a strong
formal basis. however, in the grammar inference domain,
abstract symbols are assumed as input, and the notion of
branching behavior (e.g., loops) or analysis is lost.
in the area of process mining, numerous techniques have
been proposed. these techniques have strong roots in petri
nets, model conversions, and alignment-based analysis [2],
[35] process mining techniques yield formal models directly
usable for advanced performance, frequency and conformance
analysis. there are only a few techniques in this domain
that touch upon the subject of hierarchies. in [21], [25], a
hierarchy of anonymous clusters is created based on behavioral
abstractions. the hierarchy of anonymous clusters in [15]
is based on functional and inclusion dependency discovery
techniques over extra data in the event log. none of these
techniques yields named submodels or supports recursion.
process mining techniques rely on event logs for their input.
these event logs can easily be obtained via the same tech-
niques used by dynamic analysis for singular and distributed
systems [34]. example techniques include, but are not limited
to, java agents, javassist [13], [14], aspectj [19], aspectc++
[42], aop++ [57] and the txl preprocessor [16].
iii. d efinitions
before we explain the proposed discovery techniques, we
ﬁrst introduce the deﬁnitions for our input and internal
representation. we start with some preliminaries in subsec-
tion iii-a. in subsection iii-b we introduce two types of eventlogs: “ﬂat” event logs (our input), and hierarchical event logs
(used during discovery). finally, in subsection iii-c and iii-d,
we will discuss the process tree model and our novel extension:
hierarchical process trees . throughout this paper, we will be
using the program given in listing 1 as a running example,
and assume we can log the start and end of each method.
1public class main {
2 public static void main( int argument) {
3 a inst = input(argument);
4 inst.process(argument);
5 output();
6 }
7 private static a input( int i) { ... }
8 private static void output() { ... }
9}
10 class a {
11 public void process( int i) { ... }
12 }
13 class bextends a {
14 public void process( int i) {
15 if(i <= 0) {
16 super .process(i);
17 }else {
18 steppre();
19 process(i - 1);
20 steppost();
21 }
22 }
23 private void steppre() { ... }
24 private void steppost() { ... }
25 }
listing 1. running example program code, logged at the method level.
a. preliminaries
1) multisets: we denote the set of all multisets over some
setaasb(a). note that the ordering of elements in a multiset
is irrelevant.
2) sequences: given a set x, a sequence over xof
lengthnis denoted asha1;:::;ani 2x. we deﬁne
ha1;:::;ani[i] =ai. the empty sequence is denoted as ".
note that the ordering of elements in a sequence is relevant.
we writeto denote sequence concatenation, for example:
haihbi=ha;bi, andhai"=hai. we write xito
denote sequence (tail) projection, where ha1;a2;:::;anii=
hai;:::;ani. for example:ha;bi0=ha;bi,ha;bi1=
hbi, andha;bi2=". we writeto denote sequence inter-
leaving (shufﬂe). for example: ha;bihc;di=fha;b;c;di;
ha;c;b;di;ha;c;d;bi;hc;a;b;di;hc;a;d;bi;hc;d;a;big.
b. event logs
1) “flat” event logs: the starting point for any process
mining technique is an event log , a set of events grouped
into traces , describing what happened when. each trace cor-
responds to an execution of a process; typically representing
an example run in a software context. various attributes may
characterize events, e.g., an event may have a timestamp,
correspond to an activity, denote a start or end, reference a
line number, is executed by a particular process or thread, etc.
2) hierarchical event logs: a hierarchical event log ex-
tends on a “ﬂat” event log by assigning multiple activities to
events; each activity describes what happened at a different
level of granularity. we assume a “ﬂat” event log as input.
based on this input, we will create a hierarchical event log fordiscovery. for the sake of clarity, we will ignore most event
attributes, and use sequences of activities directly, as deﬁned
below.
deﬁnition iii.1 (hierarchical event log):
letabe a set of activities. let l2 b ((a))be a
hierarchical event log, a multiset of traces. a trace t2l,
witht2(a), is a sequence of events. each event x2t,
withx2a, is described by a sequence of activities, stating
which activity was executed at each level in the hierarchy. y
consider, for example, the hierarchical event log l=
[hhg;ai;hg;bi;hcii]. this log has one trace, where the
ﬁrst event is labeled hg;ai, the second event is labeled
hg;bi, and the third event is labeled hci. for the sake of
readability, we will use the following shorthand notation:
l= [hg:a;g:b;ci]. in this example log, we have two levels
in our hierarchy: the longest event label has length 2, notation:
klk= 2. complex behavior, like choices, loops and parallel
(interleaved) behavior, is typically represented in an event log
via multiple (sub)traces, showing the different execution paths.
we write the following to denote hierarchy concatenation:
f:hg:a;g:b;ci=hf:g:a;f:g:b;f:ci. we generalize concate-
nation to hierarchical logs: f:l= [f:tjt2l].
we extend sequence projection to hierarchical traces and
logs, such that a ﬁxed length preﬁx is removed for all events:
hg:a;g:b;ci
0=hg:a;g:b;ci,hg:a;g:b;ci
1=ha;bi,
hg:a;g:b;ci
2=". for logs:l
i= [t
ijt2l].
in table ii, an example hierarchical trace is shown. here,
we used the class plus method name as activities. while
generating logs, one could also include the full package
name (i.e., a canonical name), method parameter signature (to
distinguish overloaded methods), and more.
c. process trees
in this subsection, we introduce process trees as a notation
to compactly represent block-structured models . an important
property of block-structured models is that they are sound by
construction ; they do not suffer from deadlocks, livelocks, and
other anomalies. in addition, process trees are tailored towards
process discovery and have been used previously to discover
block-structured workﬂow nets [35]. a process tree describes
a language; an operator describes how the languages of its
subtrees are to be combined.
deﬁnition iii.2 (process tree):
we formally deﬁne process trees recursively. we assume a
ﬁnite alphabet aof activities and a setnof operators to be
given. symbol  =2adenotes the silent activity.
awitha2(a[fg)is a process tree;
letp1;:::;pnwithn>0be process trees and let 
2nbe a process tree operator, then 
(p1;:::;pn)is a
process tree.
we consider the following operators for process trees:
!denotes the sequential execution of all subtrees
denotes the exclusive choice between one of the subtrees
	denotes the structured loop of loop body p1and alterna-
tive loop back paths p2;:::;pn(withn2)
^denotes the parallel (interleaved) execution of all subtrees
yto describe the semantics of process trees, the language of a
process tree pis deﬁned using a recursive monotonic function
l(p), where each operator 
has a language join function 
l:
l(a) =fhaigfora2a
l() =f"g
l(
(p1;:::;p n)) =
l(l(p1);:::;l(pn))
each operator has its own language join function 
l. the
language join functions below are borrowed from [35], [46]:
!l(l1;:::;l n) =ft1:::tnj81in:ti2lig
l(l1;:::;l n) =s
1inli
	l(l1;:::;l n) =ft1t0
1t2t0
2:::tm 1t0
m 1tm
j8i:ti2l1; t0
i2s
2jnljg
^l(l1;:::;l n) =
t02(t1:::tn)81in:ti2li	
example process trees and their languages:
l(!(a;(b;c))) =fha;bi;ha;cig
l(^(a;b)) =fha;bi;hb;aig
l(^(a;!(b;c)) =fha;b;ci;hb;a;ci;hb;c;aig
l(	(a;b)) =fhai;ha;b;ai;ha;b;a;b;ai;:::g
d. hierarchical process trees
we extend the process tree representation to support hierar-
chical and recursive behavior. we add a new tree operator to
represent a named submodel, and add a new tree leaf to denote
a recursive reference. figure 2 shows an example model.
deﬁnition iii.3 (hierarchical process tree):
we formally deﬁne hierarchical process trees recursively. we
assume a ﬁnite alphabet aof activities to be given.
any process tree is also a hierarchical process tree;
letpbe a hierarchical process tree, and f2a, then
of(p)is a hierarchical process tree that denotes the
named subtree, with name fand subtree p;
mfwithf2ais a hierarchical process tree. combined
with a named subtree operator of, this leaf denotes the
point where we recurse on the named subtree. see also
the language deﬁnition below.y
the semantics of hierarchical process trees are deﬁned
by extending the language function l(p). a recursion at a
leafmfis ‘marked’ in the language, and resolved at the level
of the ﬁrst corresponding named submodel of. function l
f
‘scans’ a single symbol and resolves for marked recursive calls
(see l
f(mf)). note that via  l
f, the languageol
fis deﬁned
recursively and yields a hierarchical, recursive language.
l(mf) =fhmfigforf2a
ol
f(l) =ff:(t0
1:::t0
n)jhx1;:::;x ni2l;
81in:t0
i2 l
f(xi)gforf2a
where l
f(") =f"g
 l
f(mf) =ol
f(l)forf2a
 l
f(mg) =fhmgigforg6=f^g2a
 l
f(a:x) =n
a:(t0)t02 l
f(x)o
fora2a;x2aexample hierarchical process trees and their languages:
l(of(!(a;b)) =fhf:a;f:big
l(of(!(a;og(b))) =fhf:a;f:g:big
l(of((!(a;mf);b)) =fhf:bi;hf:a;f:f:bi;
hf:a;f:f:a;f:f:f:bi;:::g
l(of(og((a;mf))) =fhf:g:ai;hf:g:f:g:ai;
hf:g:f:g:f:g:ai;:::g
l(of(og((a;mf;mg))) =fhf:g:ai;hf:g:g:ai;hf:g:f:g:ai;
hf:g:f:g:g:ai;hf:g:g:f:g:ai;:::g
omain.main()
!
main.input()ob.process()

a.process() !
b.steppre()mb.process() b.steppost()main.output()
fig. 2. the hierarchical process tree model corresponding to the hierarchical
event log with the trace from table ii. note that we modeled the recursion
atb.process() explicitly.
iv. h euristics for hierarchy
to go from “ﬂat” event logs (our input) to hierarchical
event logs (used during discovery), we rely on transforma-
tion heuristics. in the typical software system case, we will
use the nested calls heuristic, but our implementation also
provides other heuristics for different analysis scenarios. we
will discuss three of these heuristics for hierarchy next.
1)nested calls captures the “executions call stacks”.
through the use of the life-cycle attribute (start-end), we
can view ﬂat event logs as a collection of intervals, and
use interval containment to build our hierarchy. in fig-
ure 3, a trace from the event log corresponding to the
program in listing 1 is depicted as intervals. table ii
shows the corresponding “nested calls” hierarchical event
log trace. 2) structured names captures the static struc-
ture or “architecture” of the software source code. by
splitting activities like “ package.class.method() ” on “ .” into
hpackage;class;method()i, we can utilize the designed hi-
erarchy in the code as a basis for discovery. 3) attribute
combination is a more generic approach, where we can
combine several attributes associated with events in a certain
order. for example, some events are annotated with a high-
level and a low-level description, like an interface or protocol
name plus a speciﬁc function or message/signal name.
v. m odel discovery
a. discovery framework
our techniques are based on the inductive miner framework
for discovering process tree models. this framework is de-
scribed in [35]. given a setnof process tree operators, [35]legend
start event
end eventmain.main()
main.input() b.process() main.output()
b.steppre() b.process() b.steppost()
a.process()
fig. 3. a trace from the event log corresponding to logging the methods
in the program in listing 1, depicted as intervals. by using the nested call
heuristics, a hierarchical event log can be constructed from contained intervals,
see also table ii. for example, b.process() is contained in main.main().
table ii
asingle trace in an example event log corresponding to the
program in listing 1and the intervals in figure 3. e ach
column is one event ,and each row a level in the hierarchy .
main.main() main.main() main.main() main.main() main.main()
main.input() b.process() b.process() b.process() main.output()
b.steppre() b.process() b.steppost()
a.process()
deﬁnes a framework to discover models using a divide and
conquer approach. given a log l, the framework searches for
possible splits of linto sublogs l1;:::;ln, such that these
logs combined with an operator 
can (at least) reproduce l
again. it then recurses on the corresponding sublogs and
returns the discovered submodels. logs with empty traces or
traces with a single activity form the base cases for this frame-
work. note that the produced model can be a generalization
of the log; see for example the language of the structured loop
(	). in table iii, an example run of the framework is given.
table iii
example discovery on the log [ha;b;di;ha;c;d;e;di]. the rows
illustrate how the discovery progresses . the highlights
indicate the sublogs used ,and relate them to the
corresponding partial model that is discovered .
step discovered model event log
1!
? ? ?abd
acded
2!
a ? ?abd
acded
3!
a
bc?abd
acded
4!
a
bc	
deabd
acded
we present two adaptations of the framework described
above: one for hierarchy ( na¨ıve discovery , subsection v-b),
and one for recursions ( recursion aware discovery , subsec-
tion v-c). our adaptations maintain the termination guarantee,
perfect ﬁtness guarantee, language rediscoverability guarantee,and the polynomial runtime complexity from [35]. the details
of the above guarantees and runtime complexity for our adap-
tations are detailed in subsection v-d. in our implementation,
we rely on the (in)frequency based variant to enable the
discovery of an 80/20 model, see also subsection vi-a.
b. naive discovery
we generalize the above approach to also support hierarchy
by providing the option to split hierarchical event logs and use
hierarchical sequence projection.
using our generalized discovery framework, we deﬁne a
naive realization associated with the named subtree opera-
torof, and a slightly modiﬁed base case. the details are given
in algorithm 1. in table iv, an example run is given.
this algorithmic variant is best suited for cases where
recursion does not make much sense, for example, when we
are using a hierarchical event log based on structured package-
class-method name hierarchies.
algorithm 1: naive discovery ( naive )
input: a hierarchical event log l
output: a hierarchical process tree psuch thatlﬁtsp
description: extended framework, using the named subtree operator of.
naive (l)
(1) if8t2l:t="
(2) return // the log is empty or only contains empty traces
(3) else if9f2a:8t2l:t=hfi
(4) returnf // the log only has a single low-level activity
(5) else if9f2a: (8x2t2l:x[1] =f)^(9x2t2l:jxj>1)
(6) // all events start with f, and there is a lower level in the hierarchy
(7) returnof(naive (l
1))
(8) else
(9) // normal framework cases, based on the tree semantics (def. iii.2)
(10) split linto into sublogs l1;:::;l n, such that:
(11)9
2f!;;	;^g:l
l(l1;:::;l n)// see [35]
(12) return
(naive (l1);:::; naive (ln))
below are some more example logs and the models discov-
ered. note that with this naive approach, the recursion in the
last example is not discovered.
naive ([hf:a;f:bi;hf:ci]) =of(naive ([ha;bi;hci]))
=of((!(a;b);c))
naive ([hf:a;f:g:f:bi]) =of(naive ([ha;g:f:bi]))
=of(!(a;naive ([hg:f:bi])))
=of(!(a;og(of(b))))
naive ([hf:ai;hfi]) =of(naive ([hai;"]))
=of((a;))
c. recursion aware discovery
in order to successfully detect recursion, we make some
subtle but important changes. we rely on two key notions:
1) acontext path , and 2) delayed discovery . both are explained
below, using the example shown in table v.
this algorithmic variant is best suited for cases where
recursion makes sense, for example, when we are using an
event log based on the nested calls hierarchy (section iv).
to detect recursion, we need to keep track of the named
subtrees from the root to the current subtree. we call the
sequence of activities on such a path the context path , nota-
tionc2a. the idea is that whenever we discover a named
subtreeof, and we encounter another activity fsomewhere in
the sublogs, we can verify this recursion using f2c. sublogscollected during discovery are associated with a context path,
notationl(c). this approach is able to deal with complex
recursions (see examples at the end) and overloaded methods
(see the activity naming discussion in section iii-b2). in
table v, the current context path cat each step is shown.
table iv
example naive discovery on the log [hf:a;f:f:bi]. the rows
illustrate how the discovery progresses . the highlights
indicate the sublogs used ,and relate them to the
corresponding partial model that is discovered .
step discovered model event log sublog view
1of
?ff
af
b[hf:a;f:f:bi]
2of
!
aof
?ff
af
b[ha;f:bi]
3of
!
aof
bff
af
b[hbi]
table v
example recursion aware discovery on the log [hf:a;f:f:bi]
the rows illustrate how the discovery progresses . the
highlights indicate the sublogs used ,and relate them to the
corresponding partial model that is discovered .
step discovered model event log sublog view
1of
?ff
af
bl=
[hf:a;f:f:bi]
(context c =")
2of
!
amfxf
af
bl(hfi) =
[ha;f:bi]
(context c =hfi)
3of

b!
amfff
af
bl(hfi) =
[ha;f:bi;hbi]
(context c =hfi)
let’s have a closer look at steps 2 and 3 in table v. note
how the same subtree is discovered twice. in step 2, we detect
the recursion. and in step 3, we use the sublog after the
recursion part as an additional set of traces. the idea illustrated
here is that of delayed discovery . instead of immediately
discovering the subtree for a named subtree of, we delay
that discovery. the corresponding sublog is associated with
the current context path. for each context path, we discover
a model for the associated sublog. during this discovery,
the sublog associated with that context path may change. if
that happens, we run that discovery again on the extendedsublog. afterwards, we insert the partial models under the
corresponding named subtrees operators.
algorithm 2 details the recursion aware discovery algo-
rithm; it uses algorithm 3 for a single discovery run. in the
example of table v, we ﬁrst discover on the complete log
with the empty context path (alg. 2, line 2). in step 1, we
encounter the named subtree of, and associate l(hfi) =
[ha;f:bi], for context path c =hfi(alg. 3, line 12). in
step 2, we start discovery on c =hfiusing the sublog
l(hfi)(alg. 2, line 5). in this discovery, we encounter the
recursionf2c, and add [hbi]to the sublog, resulting in
l(hfi) = [ha;f:bi;hbi](alg. 3, line 8). finally, in step 3,
we rediscover for c =hfi, now using the extended sublog
(alg. 2, line 5). in this discovery run, no sublog changes
anymore. we insert the partial models under the corresponding
named subtrees operators (alg. 2, line 9) and return the result.
algorithm 2: recursion aware discovery ( rad )
input: a hierarchical event log l
output: a hierarchical process tree psuch thatlﬁtsp
description: extended framework, using the named subtree and recursion operators.
rad (l)
(1) // discover root model using the full event log ( c =")
(2) root=radrun (l; " )
(3) // discover the submodels using the recorded sublogs ( c6=")
(4) letmodel be an empty map, relating context paths to process trees
(5) while9c2a:l(c) changed domodel (c) =radrun (l(c);c)
(6) // glue the partial models model (c) and root model root together
(7) foreach nodepin process tree root (any order, including new children)
(8) let c =
fp0=offoreachp0on the path from root top
(9) if(9f:p=of)^c2model then setmodel (c) as the child of p
(10) return root
algorithm 3: recursion aware discovery - single run
input: a hierarchical event log l, and a context path c
output: a hierarchical process tree psuch thatlﬁtsp
description: one single run/iteration in the rad extended framework.
radrun (l;c)
(1) if8t2l:t="
(2) return // the log is empty or only contains empty traces
(3) else if9f2a:8t2l:t=hfi
(4) returnf // the log only has a single low-level activity
(5) else if9f2c :8x2t2l:x[1] =f
(6) // recursion on fis detected
(7) c0= c 1hfiwhere (c1hfic2) = c
(8)l(c0) =l(c0)[l
1 //l
1is added to the sublog for c0
(9) returnmf
(10) else if9f2a: (8x2t2l:x[1] =f)^(9x2t2l:jxj>1)
(11) // discovered a named subtree f, note thatf =2csince line 5 was false
(12)l(chfi) =l
1 //l
1is associated with c0= chxi
(13) returnof
(14) else
(15) // normal framework cases, based on the tree semantics (def. iii.2)
(16) split linto into sublogs l1;:::;l n, such that:
(17)9
2f!;;	;^g:l
l(l1;:::;l n)// see [35]
(18) return
(radrun (l1;c);:::; radrun (ln;c))
below are some more example logs, the models discovered,
and the sublogs associated with the involved context paths.
note that with this approach, complex recursions are also
discovered.
rad ([hf:a;f:g:f:bi]) =of((b;!(a;og(mf))))
wherel(hfi) = [hbi;ha;g:f:bi]
l(hf;gi) = [hf:bi]
rad ([hf:g:g:ai;hf:g:f:g:ai]) =of(og((a;mf;mg)))
wherel(hfi) = [hg:g:ai;hg:f:g:ai;hg:ai]
l(hf;gi) = [hg:ai;hf:g:ai;hai]
rad ([hf:fi]) =of((mf;))
wherel(hfi) = [hfi;"]d. termination, perfect fitness, language rediscoverability,
and runtime complexity
our na ¨ıve discovery and recursion aware discovery adap-
tations of the framework described [35] maintains the termi-
nation guarantee, perfect ﬁtness guarantee, language rediscov-
erability guarantee, and the polynomial runtime complexity.
we will discuss each of these properties using the simpliﬁed
theorems and proofs from [36].
1) termination guarantee: the termination guarantee is
based on the proof for [36, theorem 2, page 7]. the basis for
the termination proof relies on the fact that the algorithm only
performs ﬁnitely many recursions. for the standard process
tree operators in the original framework, it is shown that the
log split operator only yields ﬁnitely many sublogs. hence, for
our adaptations, we only have to show that the new hierarchy
and recursion cases only yield ﬁnitely many recursions.
theorem v .1: na¨ıve discovery terminates.
proof: consider the named subtree case on algorithm 1,
line 7. observe that the log lhas a ﬁnite depth, i.e., a ﬁnite
number of levels in the hierarchy. note that the sequence
projectionl
1yields strictly smaller event logs, i.e, the
number of levels in the hierarchy strictly decreases. we can
conclude that the named subtree case for the na ¨ıve discovery
yields only ﬁnitely many recursions. hence, the na ¨ıve dis-
covery adaptation maintains the termination guarantee of [36,
theorem 2, page 7].
theorem v .2: recursion aware discovery terminates.
proof: consider the named subtree and recursion cases in
algorithm 3 on lines 8 and 12. note that, by construction, for
all the cases where we end up in algorithm 3, line 8, we know
thatlis derived from, and bounded by, l(c0)as follows:
lfl0
ijl0l(c0)^0ikl(c0)kg. observe that
the loglhas a ﬁnite depth, i.e., a ﬁnite number of levels in the
hierarchy. note that the sequence projection l
1yields strictly
smaller event logs, i.e, the number of levels in the hierarchy
strictly decreases. hence, we can conclude that l(c0)only
changes ﬁnitely often. since cis derived from the log depth,
we also have a ﬁnitely many sublogs l(c0)that are being
used. hence, the loop on algorithm 2, line 5 terminates, and
thus the recursion aware discovery adaptation maintains the
termination guarantee of [36, theorem 2, page 7].
2) perfect fitness: as stated in the introduction, we want
the discovered model to ﬁt the actual behavior. that is, we
want the discovered model to at least contain all the behavior
in the event log. the perfect ﬁtness guarantee states that all
the log behavior is in the discovered model, and we proof
this using the proof for [36, theorem 3, page 7]. the ﬁtness
proof is based on induction on the log size1. as induction
hypothesis, we assume that for all sublogs, the discovery
framework returns a ﬁtting model, and then prove that the
step maintains this property. that is, for all sublogs l0we
have a corresponding submodel p0such thatl0l(p0). for
1formally, the original induction is on the log size plus a counter parameter.
however, for our proofs, we can ignore this counting parameter.our adaptations, it sufﬁces to show that the named subtree and
recursion operators do not violate this assumption.
theorem v .3: na¨ıve discovery returns a process model that
ﬁts the log.
proof: by simple code inspection on algorithm 1, line 7
and using the induction hypothesis on l
1, we can see that
for the named subtree operator we return a process model that
ﬁts the logl. since this line is the only adaptation, the na ¨ıve
discovery adaptation maintains the perfect ﬁtness guarantee
of [36, theorem 3, page 7].
theorem v .4: recursion aware discovery returns a process
model that ﬁts the log.
proof: consider the named subtree case on algorithm 3,
line 12. using the induction hypothesis on l(chfi) =l
1,
we know that model (chfi)will ﬁtl(chfi). by
algorithm 2, line 9, we know that model (chfi)will be
the child ofof. hence, for the named subtree operator we
return a process model that ﬁts the log l.
consider the recursion case on algorithm 3, line 8. since
f2c, we know there must exist a named subtree ofcorre-
sponding to the recursive operator mf. due to algorithm 2,
line 5 and the induction hypthesis, we know that at the end
model (c0)ﬁtsl(c0)(i.e.,l(c0)l(model (c0))). since,
by construction, we know l
1l(c0),model (c0)also ﬁts
l
1. by algorithm 2, line 9, we know that mfwill be in the
subtree ofof. hence, for the recursion operator we return a
process model that ﬁts the log l.
we conclude that the recursion aware discovery adaptation
maintains the perfect ﬁtness guarantee of [36, theorem 3,
page 7].
3) language rediscoverability: the language rediscover-
ability property tells whether and under which conditions a
discovery algorithm can discover a model that is language-
equivalent to the original process. that is, given a ‘system
model’pand an event log lthat is complete w.r.t. p(for
some notion of completeness), then we rediscover a model p0
such thatl(p0) =l(p).
we will show language rediscoverability in several steps.
first, we will deﬁne the notion of language complete logs.
then, we deﬁne the class of models that can be language-
rediscovered. and ﬁnally, we will detail the language redis-
coverability proofs.
a) language completeness: language rediscoverability
holds for directly-follows complete logs. we adapt this notion
of directly-folllows completeness from [36] by simply apply-
ing the existing deﬁnition to hierarchical event logs:
deﬁnition 1 (directly-follows completeness): letstart (l)
andend(l)denote the set of start and end symbols amongst
all traces, respectively. a log lis directly-follows complete
to a modelp, denoted as ldfp, iff:
1)h:::;x;y;:::i2l (p))h:::;x;y;:::i2l;
2)start (l(p))start (l);
3)end(l(p))end(l); and
4)(p)(l).
note that directly-follows completeness is deﬁned over all
levels of a hierarchical log.b) class of language-rediscoverable models: we will
prove language rediscoverability for the following class of
models. let (p)denote the set of activities in p. a modelp
is in the class of language rediscoverable models iff for all
nodes
(p1;:::;pn)inpwe have:
1) no duplicate activities: 8i6=j: (pi)\(pj) =;;
2) in the case of a loop, the sets of start and end activities
of the ﬁrst branch must be disjoint:

=	)start (l(p1))\end(l(p1)) =;
3) no taus are allowed: 8in:pi6=;
4) in the case of a recursion node mf, there exists a
corresponding named subtree node ofon the path
fromptomf.
note that the ﬁrst three criteria follow directly from the
language rediscoverability class from [36]. the last criteria
is added to have well-deﬁned recursions in our hierarchical
process trees.
c) language-rediscoverable guarantee: the language
rediscoverability guarantee is based on the proof for [36,
theorem 14, page 16]. the proof in [36] is based on three
lemmas:
[36, lemma 11, page 15] guarantees that any root process
tree operator is rediscovered;
[36, lemma 12, page 16] guarantees that the base cases
can be rediscovered; and
[36, lemma 13, page 16] guarantees that for all process
tree operators the log is correctly subdivided.
for our adaptations, we have to show:
1) our recursion base case maintains [36, lemma 12,
page 16]; and
2) our named subtree operator maintains [36, lemma 11,
page 15] and [36, lemma 13, page 16].
theorem v .5: na¨ıve discovery preserves language redis-
coverability.
proof: we only have to show that the introduction of the
named subtree operator maintains language rediscoverability.
first, we show for the named subtree operator that the root
process tree operator is rediscovered (lemma 11). assume a
process tree p=of(p1), for anyf2a, and letlbe a log
such thatldfp. since we know that ldfp, we know that
8x2t2l:x[1] =f, and there must be a lower level in the
tree. by simple code inspection on algorithm 1, line 7, we
can see that the na ¨ıve discovery will yield of.
next, we show for the named subtree operator that the log
is correctly subdivided (lemma 13). that is, lets assume: 1)
a modelp=of(p1)adhering to the model restrictions; and
2)l l(p)^ldfp. then we have to show that any
sublogliwe recurse upon has: li l(pi)^lidfpi.
for the named subtree operator, we have exactly one sublog
we recurse upon: l1=l
1. we can easily prove this using
the sequence projection on the inducation hypothesis: l
1
l(p)
1, after substitution: l
1l(of(p1))
1. by deﬁnition
of the semantics for of, we can rewrite this to: l
1l(p1).
the proof construction for lidfpiis analogous. hence, for
the named subtree operator that the log is correctly subdivided.we can conclude that the na ¨ıve discovery adaptation
preserves language rediscoverability guarantee of [36, the-
orem 14, page 16].
theorem v .6: recursion aware discovery preserves lan-
guage rediscoverability.
proof: the proof for the introduction of the named
subtree operator is analogous to the proof for theorem v .5,
using the fact that always l
1l(c0)for the corresponding
context path c0.
we only have to show that the introduction of the recursion
operator maintains language rediscoverability (lemma 12).
that is, assume: 1) a model p=mfadhering to the model
restrictions; and 2) ll(p)^ldfp. then we have to
show that we discover the model p0such thatp0=p.
since we adhere to the model restrictions, due to restric-
tion 4, we know there must be a larger model p00such that
the recursion node mfis a leaf of p00and there exists a
corresponding named subtree node ofon the path from p00
tomf. thus, we can conclude that lmust be the sublog
associated with a context path csuch thatf2c. by
code inspection on algorithm 3, line 5, we see that we only
have to prove that 8x2t2l:x[1] =f. this follows
directly from ldfp. hence, the recursion operator is correctly
rediscovered.
we can conclude that the recursion aware discovery adap-
tation preserves language rediscoverability guarantee of [36,
theorem 14, page 16].
4) runtime complexity: in [36, run time complexity,
page 17], the authors describe how the basic discovery frame-
work is implemented as a polynomial algorithm. for the
selection and log splitting for the normal process tree operators
(alg. 1, line 10, and alg. 3, line 16), existing polynomial al-
gorithms were used. furthermore, for the original framework,
the number of recursions made is bounded by the number
of activities: o(j(l)j). we will show that this polynomial
runtime complexity is maintained for our adaptations.
in our na ¨ıve discovery adaptation, the number of recursions
is determined by algorithm 1, lines 7 and 10. for line 7,
the number of recursions is bounded by the depth of the
hierarchical event log: o(klk). for line 10, the original
number of activities bound holds: o(j(l)j). thus, the total
number of recursions for our na ¨ıve discovery is bounded by
o(klk+j(l)j). hence, the na ¨ıve discovery adaptation has
a polynomial runtime complexity.
in one run of our recursion aware discovery, the number
of recursions is determined by algorithm 3, line 16. note
that the recursion and named subtree cases do not recurse
directly due to the delayed discovery principle. for line 16, the
original number of activities bound holds: o(j(l)j). thus,
we can conclude that algorithm 3 has a polynomial runtime
complexity.
for the complete recursion aware discovery, the runtime
complexity is determined by algorithm 2, lines 5 and 9. each
iteration of the loop at line 5 is polynomial. the number of
iterations is determined by the number of times an l(c) is
changed. based on algorithm 3, lines 8 and 12, the numberof times an l(c) is changed is bounded by the depth of
the hierarchical event log: o(klk). thus, the total number
of iterations is polynomial and bounded by o(klk). each
iteration of the loop at line 9 is polinomial in the named tree
depth, and thus bounded by o(klk). the number of iterations
is determined by the number of named subtrees, and thus also
bounded by o(klk). hence, the recursion aware discovery
adaptation has a polynomial runtime complexity.
vi. u sing and visualizing the discovered model
discovering a behavioral backbone model is only step one.
equally important is how one is going to use the model, both
for analysis and for further model driven engineering. in this
section, we touch upon some of the solutions we implemented,
and demo in subsection vii-c and figure 6.
a. rewriting, filtering and the 80/20 model
to help the user understand the logged behavior, we provide
several ways of ﬁltering the model, reducing the visible
complexity, and adjusting the model quality.
based on frequency information, we allow the user to
inspect an 80/20 model. an 80/20 model describes the main-
stream (80%) behavior using a simple (20%) model [35].
we allow the user to interactively select the cutoff (80% by
default) using sliders directly next to the model visualization,
thus enabling the “real-time exploration” of behavior. unusual
behavior can be projected and highlighted onto the 80%
model using existing conformance and deviation detection
techniques [2]. this way, it is immediately clear where the
unusual behavior is present in the model, and how it is
different from the mainstream behavior.
based on hierarchical information, we allow both coarse
and ﬁne grained ﬁltering. using sliders, the user can quickly
select a minimum and maximum hierarchical depth to inspect,
and hide other parts of the model. the idea of depth ﬁltering
is illustrated in figure 4. afterwards, users can interactively
fold and unfold parts of the hierarchy. by searching, users
can quickly locate areas of interest. using term-based tree
rewriting (see table vi), we present the user with a simpliﬁed
model that preserves behavior.
table vi
reduction rules for (hierarchical )process trees

(p1) =p1 for
2f!;;^g

(:::1;
(:::2);:::3) =
(:::1;:::2;:::3)for
2f!;^g

(:::1;;::: 2) =
(:::1;:::2) for
2f!;^g
(:::1;;::: 2) =(:::1;:::2) if"2l(:::1[:::2)
b. linking the model to event data and the source code
for further analysis, like performance (timing), frequency
(usage) and conformance, we annotate the discovered model
with additional information. by annotating this information
onto (parts of) the model, we can visualize it in the context of
the behavior. this annotation is based on the event log data
provided as input and is partly provided by existing algorithms
in the process mining toolkit prom. most notably, we 1) align
the discovered model with the event log, as described in [2],!
aox
!
boy
c!
!
bydiscovered model model after depth filtering
min depth
max depth
fig. 4. illustration of depth ﬁltering, where we hide everything above xand
belowy. the dashed arrows relate the altered nodes.
omain.main()
!
main.input()
a.f() b.f()
(a) hierarchical process treemain.input()
a.f() b.f()main.main()
(b) statechart
main a b
altmain()
main()input()
f()
f()
f()
f()
(c) sequence diagrammain.main()+start
main.input()+start
main.input()+end
a.f()+start
a.f()+endb.f()+start
b.f()+end
main.main()+end
(d) petri net
fig. 5. a hierarchical process tree, and its mapping to different formalisms.
and 2) link model elements back to the referenced source code
lines in eclipse that generated the logged events.
c. mapping and visualizing
for visualization and integration with existing techniques,
we implemented mappings to other formalisms. as noted
in [35], process trees represent a “block-structured” language.
hence, we can simply map each operator to a block-structured
concept in the target formalism, and preserve behavior by
construction. we support mappings to formalisms such as
statecharts, (data) petri nets, sequence diagrams, and bpmn
diagrams. some example mappings are given in figure 5.
vii. e valuation
in this section, we compare our technique against related,
implemented techniques. the proposed algorithms are im-
plemented in the statechart plugin for the process mining
framework prom [30]. in the remainder of this section, wewill refer to algorithm 1 as na¨ıve, and to algorithm 2 as rad
(short for recursion aware discovery). we end the evaluation
by showing example results in our tool.
a. input and methodology for comparative evaluation
in the comparative evaluation, we focus on the quantitative
aspects of the design criteria from the introduction. that is,
the approach and tools should provide a behavioral backbone
model that is precise and ﬁts the actual system. we measure
two aspects for a number of techniques and input event logs:
1) the running time of the technique, and 2) the model quality .
for the running time, we measured the average running
time and associated 95% conﬁdence interval over 30 micro-
benchmark executions, after 10 warmup rounds for the java
jvm. each technique is allowed at most 30 seconds for
completing a single model discovery. for the model quality,
we use ﬁtness and precision as described in [2], and set a
time limit of at most 5 minutes. in short, ﬁtness expresses
the part of the log that is represented by the model; precision
expresses the behavior in the model that is present in the log.
for these experiments we used a laptop with an i7-4700mq
cpu @ 2.40 ghz, windows 8.1 and java se 1.7.0 67 (64 bit)
with 12 gb of allocated ram.
we selected ﬁve event logs as experiment input, covering
a range of input problem sizes. the input problem size is
typically measured in terms of four metrics: number of traces,
number of events, number of activities (size of the alphabet),
and average trace length. the event logs and their sizes are
shown in table vii. the bpic 2012 [51] and bpic 2013 [43]
event logs are so called bpi challenge logs. these large
real-life event logs with complex behavior are often used
in process mining evaluations. the challenge logs are made
available yearly in conjunction with the bpm conference and
are considered sufﬁciently large and complex inputs to stress
test process mining techniques. the junit 4.12 [31], apache
commons crypto 1.0.0 [32], and nasa cev [33] event logs
are created using an extended version of the instrumenta-
tion tool developed for [34], yielding xes event logs with
method-call level events. the junit 4.12 software [18] was
executed once, using the example input found at [9]. for the
apache commons crypto 1.0.0 software [5], we executed the
cbcnopaddingcipherstreamtest unit test. for the nasa cev
software [37], we executed a unit test generated from the
source code, covering all of the code branches.
table vii
the event logs used in the evaluation ,with input sizes
event log # traces # events # acts avg. jtracej
[51] bpic 2012 13;087 262;200 24 20 :04
[43] bpic 2013 7;554 65;533 13 8 :70
[31] junit 4.12 1 946 182 946 :00
[32] crypto 1.0.0 3 241;973 74 80 ;657:67
[33] nasa cev 2;566 73;638 47 28 :70
we compare our discovery algorithms against a selection
of the techniques mentioned in section ii. unfortunately, we
could not compare against some of the related work due to in-
valid input assumptions or the lack of a reference implementa-table viii
running time for the different algorithms ,hierarchy heuristics ,paths frequency filter settings ,and event logs .
algorithm (heuristic) paths bpic 2012 bpic 2013 junit 4.12 crypto 1.0.0 nasa cev
[49] alpha miner 150:1
102
103
10473:5
102
1039:2
101
102
103183:1
100
102
10437:8
102
103
104[56] heuristics 840:2 278 :0 1349 :7  t359:6
[21] fuzzy miner 2858:5 827 :4 166 :8  t4148:2
[50] ilp miner  t6023:8  t t t
[52] ilp with ﬁltering 7234:3 4354 :7  t t t
[55] mint, redblue, k=1  t t243:9  t13426:0
[55] mint, redblue, k=2  t t582:0  t22213:4
[55] mint, redblue, k=3  t t751:8  t t
[55] mint, ktails, k=1  t t108:9  t t
[55] mint, ktails, k=2  t t371:6  t t
[55] mint, ktails, k=3  t t512:3  t t
[7] synoptic  t t t t t
[35] im (baseline) 1.0 3239:9 1351 :2 215 :7 10866 :1 911 :3
[35] im (baseline) 0.8 5111:6 947 :4 268 :5 5213 :9 912 :6our techniquesna¨ıve (no heuristic) 1.0 3588:1 1117 :8 278 :3 26804 :7 959 :5
na¨ıve (no heuristic) 0.8 2865:6 603 :4 298 :5  t1047:1
na¨ıve (nested calls) 1.0n/a n/a15:1 1544 :6 355 :9
na¨ıve (nested calls) 0.8n/a n/a12:6 1545 :6 341 :5
rad (nested calls) 1.0n/a n/a16:4 2186 :4 439 :0
rad (nested calls) 0.8n/a n/a14:6 2082 :8 373 :8
na¨ıve (struct. names) 0.8 2058:6 891 :1 23 :3  m1275:9
rad (struct. names) 0.8 2395:0 1028 :6 23 :7  m1452:3
avg. runtime (in milliseconds, with log scale plot), over 30 runs, with 95% conﬁdence interval
mout of memory exception (12 gb)ttime limit exceeded (30 sec.)n/aheuristic not applicable
tion. the inductive miner (im) [35] is our baseline comparison
algorithm, since our approach builds upon the im framework.
for the inductive miner and our derived techniques, we also
consider the paths setting. this is the frequency cutoff for
discovering an 80/20 model (see subsection vi-a): 1.0 means
all behavior, 0.8 means 80% of the behavior. the work
of [49], [56], [52], [50] provides a comparison with standard
process mining techniques. the fuzzy miner [21] provides
a comparison for hierarchy discovery. however, it yields
models without semantics, and hence the quality cannot be
determined. the mint algorithm (efsm inference) [55], [54]
provides a comparison with the well-known redblue andktails
dynamic analysis techniques. the synoptic algorithm [7], [6]
is an invariant based fsm inferrer.
for our techniques, we also consider the following heuris-
tics for hierarchy : 1) no heuristic (use log as is), 2) nested
calls, and 3) structured package.class.method names (struct.
names). note that the nested calls heuristic is only applicable
for software event logs, and not for the bpic logs.
b. comparative evaluation results and discussion
1) runtime analysis: in table viii, the results for the run-
time benchmark are given. as noted before, the nested calls
setup is not applicable for the bpic logs. we immediately
observe that the ilp, mint, and synoptic algorithms could
not ﬁnish in time on most logs. mint and synoptic have
difﬁculty handling a large number of traces. we also notice
that most setups require a long processing time and a lot of
memory for the apache crypto log. large trace lengths, such
as in the crypto log, are problematic for all approaches. our
techniques overcome this problem by using the hierarchy to
divide large traces into multiple smaller traces (see below).when we take a closer look at the actual running times,
we observe the advantages of the heuristics for hierarchy
and accompanied discovery algorithms. in all cases, using the
right heuristic before discovery improves the running time. in
extreme cases, like the apache crypto log, it even makes the
difference between getting a result and having no result at all.
note that, with a poorly chosen heuristic, we might not get
any improvements, e.g., note the absence of models for the
apache crypto plus structured names heuristics.
the speedup factor for our technique depends on an im-
plicit input problem size metric: the depth of the discovered
hierarchy. in table ix, the discovered depths are given for
comparison. for example, the dramatic decrease in running
time for the junit log can be explained by the large depth in
hierarchy: 25 levels in this case. this implies that the event log
is decomposed into many smaller sublogs, as per alg. 1, line 7,
and alg. 3, lines 8 and 12. hence, the imposed hierarchy
indirectly yields a good decomposition of the problem, aiding
the divide and conquer tactics of the underlying algorithms.
table ix
depth of the discovered hierarchy ,for the different event
logs ,hierarchy heuristics ,and algorithms
nested calls struct. names
event log na¨ıve rad na ¨ıve rad
[51] bpic 2012n/a n/a2 2
[43] bpic 2013n/a n/a2 2
[31] junit 4.12 25 18 9 9
[32] apache crypto 1.0.0 8 8n/a n/a
[33] nasa cev 3 3 3 3
n/ano model (see table viii)table x
model quality scores for the different algorithms ,hierarchy heuristics ,paths frequency filter settings ,and event logs .
scores range from 0.0 to1.0, higher is better . no scores are available for the fuzzy model and structured names hierarchy .
bpic 2012 bpic 2013 junit 4.12 crypto 1.0.0 nasa cev
algorithm (heuristic) paths fitness precision fitness precision fitness precision fitness precision fitness precision
[49] alpha miner  u u0:36 0:88 u u u u0:91 0:06
[56] heuristics 0:72 0:95 u u u u n/a n/a u u
[50] ilp minern/a n/a1:00 0:36n/a n/a n/a n/a n/a n/a
[52] ilp, ﬁltering 0:74 0:28 0:95 0:45n/a n/a n/a n/a n/a n/a
[55] mint, redblue, k=1n/a n/a n/a n/a0:00 r n/a n/a0:79 0:44
[55] mint, redblue, k=2n/a n/a n/a n/a0:48 0:17n/a n/a0:81 0:45
[55] mint, redblue, k=3n/a n/a n/a n/a0:13 0:06n/a n/a n/a n/a
[55] mint, ktails, k=1n/a n/a n/a n/a0:00 r n/a n/a n/a n/a
[55] mint, ktails, k=2n/a n/a n/a n/a0:43 0:16n/a n/a n/a n/a
[55] mint, ktails, k=3n/a n/a n/a n/a0:12 0:06n/a n/a n/a n/a
[7] synopticn/a n/a n/a n/a n/a n/a n/a n/a n/a n/a
[35] im (baseline) 1.0 1:00 0:37 1:00 0:62 1:00 0:34 1:00 0:35 1:00 0:55
[35] im (baseline) 0.8 0:98 0:49 0:95 0:64 0:90 0:30 0:88 0:41 0:91 0:53our techniquesna¨ıve (no heuristic) 1.0 1:00 0:37 1:00 0:62 1:00 0:34 1:00 0:35 1:00 0:55
na¨ıve (no heuristic) 0.8 0:98 0:49 0:95 0:64 0:90 0:30 0:88 0:41 0:91 0:53
na¨ıve (nested calls) 1.0n/a n/a n/a n/a1:00 0:84 1:00 0:45 1:00 0:80
na¨ıve (nested calls) 0.8n/a n/a n/a n/a0:90 0:87 0:99 0:45 1:00 0:81
rad (nested calls) 1.0n/a n/a n/a n/a1:00 0:83 1:00 0:45 1:00 0:80
rad (nested calls) 0.8n/a n/a n/a n/a0:89 0:84 0:99 0:45 1:00 0:81
ttime limit exceeded (5 min.)rnot reliable (ﬁtness = 0)uunsound modeln/ano model (see table viii)
2) model quality analysis: in table x, the results of the
model quality measurements are given. the fuzzy miner is
absent due to the lack of semantics for fuzzy models. for the
structured names heuristic, there was no trivial event mapping
for the quality score measurement.
compare the quality scores between the nested calls setup
with no heuristics and the related work. note that in all cases,
the nested calls setup yields a big improvement in precision,
with no signiﬁcant impact on ﬁtness. the drop in quality for
the junit - rad case is due to the limitations in translation of
the recursive structure to the input format of [2]. in addition,
our technique without heuristics, with paths at 1.0, maintains
the model quality guarantees (perfect ﬁtness). overall, we
can conclude that the added expressiveness of modeling the
hierarchy have a positive impact on the model quality.
fig. 6. screenshot of the workbench tool implementation [30]c. using the tool
in figure 6, we show some of the functionality and solutions
available via the workbench tool implementation in prom [30].
via the user interface, the analyst ﬁrst selects the desired
heuristic for hierarchy. afterwards, the analysis is presented
through a statechart visualization of the discovered model,
annotated with frequency information. with the sliders on the
right and the tree view and search box on the left, the analyst
can adjust parameters in real time and interactively explore
the model. the analyst can switch visualizations directly in
the workbench ui, and view the model as, for example, a
sequence diagram. thanks to a corresponding eclipse plugin,
the model and analysis results can be linked back to the source
code. a simple double-click on the model allows for a jump
to the corresponding source code location. in addition, we can
overlay the code in eclipse with our model analysis results.
viii. c onclusion and future work
in this paper, we 1) proposed a novel hierarchy and re-
cursion extension to the process tree model; and 2) deﬁned
the ﬁrst, recursion aware process model discovery technique
that leverages hierarchical information in event logs, typically
available for software system cases. this technique allows
us to analyze the operational processes of software systems
under real-life conditions at multiple levels of granularity. an
implementation of the proposed algorithm is made available
via the statechart plugin in the process mining framework
prom [30]. the statechart workbench provides an intuitive
way to discover, explore and analyze hierarchical behavior,
integrates with existing prom plugins and links back to the
source code in eclipse. our experimental results, based on
real-life (software) event logs, demonstrate the feasibility and
usefulness of the approach and show the huge potential to
speed up discovery by exploiting the available hierarchy .future work aims to uncover exceptional and error con-
trol ﬂows (i.e., try-catch and cancellation patterns), provide
reliability analysis, and better support multi-threaded and
distributed software. in addition, enabling the proposed tech-
niques in a streaming context could provide valuable real-time
insight into software in its natural environment. furthermore,
since (software) event logs can be very large, using a streaming
context means we do not have to use a large amount of storage.
references
[1] c. ackermann, m. lindvall, and r. cleaveland. recovering views of
inter-system interaction behaviors. in reverse engineering, 2009. wcre
’09. 16th working conference on , pages 53–61. ieee, oct 2009.
[2] a. adriansyah. aligning observed and modeled behavior . phd thesis,
technische universiteit eindhoven, 2014.
[3] m. h. alalﬁ, j. r. cordy, and t. r. dean. automated reverse engi-
neering of uml sequence diagrams for dynamic web applications. in
software testing, veriﬁcation and validation workshops, 2009. icstw
’09. international conference on , pages 287–294. ieee, april 2009.
[4] a. amighi, p. de c. gomes, d. gurov, and m. huisman. sound control-
ﬂow graph extraction for java programs with exceptions. in proceedings
of the 10th international conference on software engineering and
formal methods , sefm’12, pages 33–47, berlin, heidelberg, 2012.
springer-verlag.
[5] apache commons documentation team. apache commons crypto
1.0.0-src. http://commons.apache.org/proper/commons-crypto. [online,
accessed 3 march 2017].
[6] i. beschastnikh. synoptic model inference. https://github.com/
modelinference/synoptic. [online, accessed 31 august 2017].
[7] i. beschastnikh, j. abrahamson, y . brun, and m. d. ernst. synoptic:
studying logged behavior with inferred models. in proceedings of the
19th acm sigsoft symposium and the 13th european conference on
foundations of software engineering , esec/fse ’11, pages 448–451,
new york, ny , usa, 2011. acm.
[8] i. beschastnikh, y . brun, m. d. ernst, and a. krishnamurthy. inferring
models of concurrent systems from logs of their behavior with csight.
inproceedings of the 36th international conference on software engi-
neering , icse 2014, pages 468–479, new york, ny , usa, 2014. acm.
[9] s. birkner, e. gamma, and k. beck. junit 4 - getting started. https://
github.com/junit-team/junit4/wiki/getting-started. [online, accessed 19
july 2016].
[10] l. c. briand, y . labiche, and j. leduc. toward the reverse engineering
of uml sequence diagrams for distributed java software. software
engineering, ieee transactions on , 32(9):642–663, sept 2006.
[11] l. c. briand, y . labiche, and y . miao. towards the reverse engineering
of uml sequence diagrams. 2013 20th working conference on reverse
engineering (wcre) , page 57, 2003.
[12] j. c. a. m. buijs, b. f. van dongen, and w. m. p. van der aalst. on
the role of ﬁtness, precision, generalization and simplicity in process
discovery. in on the move to meaningful internet systems: otm 2012 ,
volume 7565 of lecture notes in computer science , pages 305–322.
springer berlin heidelberg, 2012.
[13] s. chiba. javassist – a reﬂection-based programming wizard for java.
inproceedings of oopsla’98 workshop on reﬂective programming in
c++ and java , page 5, october 1998.
[14] s. chiba. load-time structural reﬂection in java. in e. bertino, editor,
european conference on object-oriented programming 2000 – object-
oriented programming , volume 1850 of lecture notes in computer
science , pages 313–336. springer berlin heidelberg, 2000.
[15] r. conforti, m. dumas, l. garc ´ıa-ba ˜nuelos, and m. la rosa. bpmn
miner: automated discovery of bpmn process models with hierarchical
structure. information systems , 56:284 – 303, 2016.
[16] j. r. cordy. the txl source transformation language. science of
computer programming , 61(3):190 – 210, 2006. special issue on the
fourth workshop on language descriptions, tools, and applications
(ldta ’04).
[17] w. de pauw, d. lorenz, j. vlissides, and m. wegman. execution
patterns in object-oriented visualization. proc. coots , pages 219–
234, 1998.
[18] e. gamma and k. beck. junit 4.12. https://mvnrepository.com/artifact/
junit/junit/4.12. [online, accessed 19 july 2016].[19] j. d. gradecki and n. lesiecki. mastering aspectj. aspect-oriented
programming in java , volume 456. john wiley & sons, 2003.
[20] s. l. graham, p. b. kessler, and m. k. mckusick. gprof: call graph
execution proﬁler. in proceedings of the 1982 sigplan symposium on
compiler construction - sigplan ’82 , pages 120–126, new york, new
york, usa, 1982. acm press.
[21] c. w. g ¨unther and w. m. p. van der aalst. fuzzy mining – adaptive
process simpliﬁcation based on multi-perspective metrics. in business
process management , pages 328–343. springer, 2007.
[22] c. w. g ¨unther and h. m. w. verbeek. xes – standard deﬁnition. tech-
nical report bpm reports 1409, eindhoven university of technology,
2014.
[23] m. j. h. heule and s. verwer. exact dfa identiﬁcation using sat
solvers , pages 66–79. springer berlin heidelberg, berlin, heidelberg,
2010.
[24] r. p. jagadeesh chandra bose and w. m. p. van der aalst. abstractions
in process mining: a taxonomy of patterns , volume 5701 of lecture
notes in computer science , pages 159–175. springer berlin heidelberg,
berlin, heidelberg, 2009.
[25] r. p. jagadeesh chandra bose, e. h. m. w. verbeek, and w. m. p.
van der aalst. discovering hierarchical process models using prom ,
volume 107 of lecture notes in business information processing , pages
33–48. springer berlin heidelberg, berlin, heidelberg, 2012.
[26] i. jonyer, l. b. holder, and d. j. cook. mdl-based context-free graph
grammar induction. international journal on artiﬁcial intelligence
tools , 13(01):65–79, mar 2004.
[27] r. kollmann and m. gogolla. capturing dynamic program behaviour
with uml collaboration diagrams. in software maintenance and
reengineering, 2001. fifth european conference on , pages 58–67, 2001.
[28] e. korshunova, m. petkovic, m. g. j. van den brand, and m. r.
mousavi. cpp2xmi: reverse engineering of uml class, sequence,
and activity diagrams from c++ source code. in 2006 13th working
conference on reverse engineering , pages 297–298, oct 2006.
[29] y . labiche, b. kolbah, and h. mehrfard. combining static and
dynamic analyses to reverse-engineer scenario diagrams. in software
maintenance (icsm), 2013 29th ieee international conference on ,
pages 130–139. ieee, sept 2013.
[30] m. leemans. statechart plugin for prom 6. https://svn.win.tue.nl/repos/
prom/packages/statechart/. [online, accessed 15 july 2016].
[31] m. leemans. junit 4.12 software event log. http://doi.org/10.4121/uuid:
cfed8007-91c8-4b12-98d8-f233e5cd25bb, 2016.
[32] m. leemans. apache commons crypto 1.0.0 - stream cbc-
nopad unit test software event log. http://doi.org/10.4121/uuid:
bb3286d6-dde1-4e74-9a64-fd4e32f10677, 2017.
[33] m. leemans. nasa crew exploration vehicle
(cev) software event log. http://doi.org/10.4121/uuid:
60383406-ffcd-441f-aa5e-4ec763426b76, 2017.
[34] m. leemans and w. m. p. van der aalst. process mining in software
systems: discovering real-life business transactions and process models
from distributed systems. in model driven engineering languages and
systems (models), 2015 acm/ieee 18th international conference on ,
pages 44–53, sept 2015.
[35] s. j. j. leemans. robust process mining with guarantees . phd thesis,
eindhoven university of technology, may 2017.
[36] s. j. j. leemans, d. fahland, and w. m. p. van der aalst. discovering
block-structured process models from event logs - a constructive ap-
proach. in j. m. colom and j. desel, editors, application and theory of
petri nets and concurrency , pages 311–329. springer berlin heidelberg,
2013.
[37] nasa. jpf statechart and cev example. http://babelﬁsh.arc.nasa.gov/
trac/jpf/wiki/projects/jpf-statechart. [online, accessed 3 march 2017].
[38] c. g. nevill-manning and i. h. witten. identifying hierarchical
structure in sequences: a linear-time algorithm. journal of artiﬁcial
intelligence research , 7:67–82, aug 1997.
[39] r. oechsle and t. schmitt. ja v a vis: automatic program visualization
with object and sequence diagrams using the java debug interface (jdi).
in s. diehl, editor, software visualization , volume 2269 of lecture notes
in computer science , pages 176–190. springer berlin heidelberg, 2002.
[40] a. rountev and b. h. connell. object naming analysis for reverse-
engineered sequence diagrams. in proceedings of the 27th international
conference on software engineering , icse ’05, pages 254–263, new
york, ny , usa, 2005. acm.[41] p. siyari, b. dilkina, and c. dovrolis. lexis: an optimization frame-
work for discovering the hierarchical structure of sequential data.
gecco , pages 421–434, feb 2016.
[42] o. spinczyk, a. gal, and w. schr ¨oder-preikschat. aspectc++: an
aspect-oriented extension to the c++ programming language. in pro-
ceedings of the fortieth international conference on tools paciﬁc: ob-
jects for internet, mobile and embedded applications , crpit ’02, pages
53–60, darlinghurst, australia, australia, 2002. australian computer
society, inc.
[43] w. steeman. bpi challenge 2013, incidents. http://dx.doi.org/10.4121/
uuid:500573e6-accc-4b0c-9576-aa5468b10cee, 2013.
[44] t. syst ¨a, k. koskimies, and h. m ¨uller. shimba – an environment
for reverse engineering java software systems. software: practice and
experience , 31(4):371–394, 2001.
[45] p. tonella and a. potrich. reverse engineering of the interaction
diagrams from c++ code. in software maintenance, 2003. icsm 2003.
proceedings. international conference on , pages 159–168, sept 2003.
[46] w. m. p. van der aalst. process mining: data science in action .
springer-verlag, berlin, 2016.
[47] w. m. p. van der aalst, a. k. alves de medeiros, and a. j. m. m.
weijters. genetic process mining. in g. ciardo and p. darondeau,
editors, applications and theory of petri nets 2005 , volume 3536
oflecture notes in computer science , pages 48–69. springer-verlag,
berlin, 2005.
[48] w. m. p. van der aalst, v . rubin, h. m. w. verbeek, b. f. van dongen,
e. kindler, and c. w. g ¨unther. process mining: a two-step approach
to balance between underﬁtting and overﬁtting. software & systems
modeling , 9(1):87–111, 2010.
[49] w. m. p. van der aalst, a. j. m. m. weijters, and l. maruster.
workﬂow mining: discovering process models from event logs. ieee
transactions on knowledge and data engineering , 16(9):1128–1142,
2004.
[50] j. m. e. m. van der werf, b. f. van dongen, c. a. j. hurkens, and
a. serebrenik. process discovery using integer linear programming ,
pages 368–387. springer berlin heidelberg, berlin, heidelberg, 2008.
[51] b.f. van dongen. bpi challenge 2012. http://dx.doi.org/10.4121/uuid:
3926db30-f712-4394-aebc-75976070e91f, 2012.
[52] s. j. van zelst, b. f. van dongen, and w. m. p. van der aalst. avoiding
over-fitting in ilp-based process discovery , pages 163–171. springer
international publishing, cham, 2015.
[53] h. m. w. verbeek, j. c. a. m. buijs, b. f. van dongen, and w. m. p.
van der aalst. xes, xesame, and prom 6. in p. soffer and
e. proper, editors, information systems evolution , volume 72 of lecture
notes in business information processing , pages 60–75. springer berlin
heidelberg, 2011.
[54] n. walkinshaw. efsminferencetool. https://bitbucket.org/nwalkinshaw/
efsminferencetool. [online, accessed 19 july 2016].
[55] n. walkinshaw, r. taylor, and j. derrick. inferring extended ﬁnite
state machine models from software executions. empirical software
engineering , 21(3):811–853, 2016.
[56] a. j. m. m. weijters and j. t. s. ribeiro. flexible heuristics miner
(fhm). in 2011 ieee symposium on computational intelligence and
data mining (cidm) , pages 310–317, april 2011.
[57] z. yao, q. zheng, and g. chen. aop++: a generic aspect-oriented
programming framework in c++. in r. gl ¨uck and m. lowry, editors,
generative programming and component engineering , volume 3676
oflecture notes in computer science , pages 94–108. springer berlin
heidelberg, 2005.