towards process instances building for spaghetti
processes
claudia diamantini1, laura genga1, domenico potena1, and wil m.p. van der
aalst2
1information engineering department
universit√† politecnica delle marche
via brecce bianche, 60131 ancona, italy
{c.diamantini,l.genga,d.potena}@univpm.it
2faculty of mathematics and computer science
eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands
{w.m.p.v.d.aalst}@tue.nl
discussion paper
abstract. process mining techniques aim at building a process model
starting from an event log generated during the execution of the pro-
cess. classical process mining approaches have problems when dealing
with spaghetti processes , i.e. processes with little or no structure, since
they obtain very chaotic models. as a remedy, in previous works we pro-
posed a methodology aimed at supporting the analysis of a spaghetti
process by means of its most relevant subprocesses. such approach ex-
ploits graph-mining techniques, thus requiring to reconstruct the set of
process instances starting from the sequential traces stored in the event
log. in the present work, we discuss the main problems related to process
instances building in spaghetti contexts, and introduce a proposal for ex-
tending a process instance building technique to address such issues.
keywords: process mining; spaghetti processes; process instances building
1 introduction
process mining (pm) discipline involves a set of techniques aimed at extracting
a process schema from an event log generated during process execution [1]. such
techniques turned out to have several problems when addressing the so-called
spaghetti processes , i.e. processes with little or no structure, where the Ô¨Çow
of the activities mostly depends on the decisions taken by the involved people;
indeed,fortheseprocessespmtechniquesusuallyobtainverymessyandintricate
models, called spaghetti models , almost incomprehensible for a human analyst.
as a remedy, in previous works [2], [3] we introduced a methodology aimed at
supporting the analysis of spaghetti processes by extracting their most relevant
patterns, i.e. subprocesses, since we expect them to provide some interestinginsights about the overall process. such approach exploits a graph-based tech-
nique; more precisely, it requires to transform the event log of the process in a
set of graphs, each of them describing the execution of a certain process instance,
then extracting the subprocesses from these graphs. however, such conversion
is not trivial, since events in the log are stored according to their temporal or-
der of occurrence, thus hiding possible parallelisms, which instead should be
explicitly represented when modeling a process instance. few approaches have
been developed to face the process instances building issue; furthermore, they
present some limits when addressing spaghetti processes, either because they
require speciÔ¨Åc domain knowledge or because they obtain too general models. in
the present work, we discuss the problems related to process instances building
in spaghetti contexts, and outline a proposal for extending a process instance
building technique to deal with such issues.
the rest of this work is organized as follows. section 2 provides a brief
overview of related works; section 3 introduces some deÔ¨Ånitions used throughout
the paper; section 4 describes the process instances building procedure, with its
extension; Ô¨Ånally, section 5 draws some conclusions and delineates future works.
2 related works
previousworksaddressingprocessinstancesbuildingcanbegroupedintwomain
classes. for the Ô¨Årst group, we can mention for example tools like aris process
performance manager [5], which allows for the visualization, the analysis and
the aggregation of process instances, represented as instance epcs , where epc
is the ‚Äúevent driven process chain‚Äù, a common process modeling formalism (see
e.g. [1]). such techniques, however, require a well-deÔ¨Åned process model, from
which the instances are derived. instead, techniques of the second group use only
the event log, trying to derive the ordering relations of the events, and then using
such relations to build every single instance from the corresponding trace. for
example, [6] proposes a distinction between data annotated logs (dals) and
not annotated event logs. a dal is an event log in which each event has a set of
‚Äúinput‚Äù andasetof‚Äúoutput‚Äù attributes,i.e.attributeswhicharerespectivelyread
or written by the corresponding activity. ordering relations can be derived by
the data-Ô¨Çow; in fact, if an event ejhas as input an attribute agenerated by ei,
clearlyeihas to precede ejin every process instance. however, the generation
of a dal requires either a dedicated event log generation system, or the log
preprocessing by a domain expert. in the case of a not annotated event log, [6]
suggests to exploit domain knowledge about the process to establish its ordering
relations. a more general approach is proposed in [4], which derives the ordering
relations by means of a pm technique, without requiring neither special data
stored in the log, nor any additional knowledge about the process. however, it
is known to have several issues when applied to unstructured processes.
another work related with our proposal is [7], which deals with the process
repairtopic. given an event log and a process model which does not conform to
the log (i.e., which is not able to describe all the traces in the log), the goal isgenerating a new model which conforms the event log. in [7], however, the focus
is on repairing the overall process model, while our work is aimed at repairing
every single process instance.
3 deÔ¨Ånitions
inthissection,somedeÔ¨Ånitionsusedthroughoutthepaperareprovided,starting
with those related to the notion of ‚Äúprocess‚Äù.
process, process instance . aprocessconsists in a set of activities which
havetobeperformedbysomeactorstoreachacertaingoal.everytimeaprocess
is executed, a process instance is generated.
as an example, the management of a loan application in a Ô¨Ånancial institute
is a process involving activities like the submission of an application performed
by a customer, the approval of the request decided by some manager and so on.
diÔ¨Äerent applications are managed in diÔ¨Äerent process instances. a process can
be represented by means of a process schema , deÔ¨Åned as:
process schema . aprocess schema is a schema representing the control-
Ô¨Çow of the performed activities, i.e. their ordering relations.
the main elements of a process schema are activities, sequences of activities
(seq),parallelization(split)andmerging(join)operators.splitandjoin
operators are characterized by the kind of synchronization of Ô¨Çows; hence, for
example, a split-and means that the end of an activity starts all the linked
activities, while in a split-xor only one will be executed. many diÔ¨Äerent pro-
cess modeling formalisms exist; as an example, figure 1 shows a simple process
schema describing a possible loan process exploiting the bpmn standard3. the
process starts when a customer does a submit application (sa) activity, fol-
lowed by both the activities check financial situation (cfs) of the applicant
andcontact the applicant (ca) for additional information, performed by one or
more employees. when both the activities have been completed, a manger can
proceed with the analyze documents (ad) activity, to decide whether refusing
or approving the request, thus terminating the process. note that the last two
activities of the model (i.e., refuse application (ra) and approve application
(aa)) are involved in a xor construct, since only one of them can be executed
for each process instance.
fig.1: a bpmn model for a loan process.
3http://www.bpmn.org/figure 2a shows a possible process instance for the loan process, where the
application has been approved. note that the choice constructs, i.e. in this exam-
ple the xor operator, are not represented. indeed, also if the process involves
alternative paths, only some of these paths will be executed within an instance.
event, trace, log .aneventistheexecutionofacertainactivity,described
by a set of event attibutes. atraceis a Ô¨Ånite sequence of events 2, generated
during the execution of a certain process instance. an event log is a collection
of traces, such that each event appears at most once in the entire event log.
an example of trace which can be generated by the process of figure 1 is
t1=fsa;cfs;ca;ad;aa g4. it is noteworthy that in the spaghetti processes
cases, usually one does not have a schema as simple as the one represented
in figure 1. in these contexts, it is hard to detect the main process behavior;
moreover, also if one is able to actually detect a main behavior, typically a lot of
exceptions in the event log exist. as an example, let us assume that the process
in figure 1 actually represents the main behavior for a loan process, but the
actors are not strictly forced to follow the proposed structure, and can deviate
on the basis of their needs. table 1 represents a possible log for our example.
instanceid events
1 <sa, cfs, ca, ad, aa >
2 <sa, ca, cfs, ad, aa >
3 <sa, cfs, ad, ca, aa >
4 <sa, cfs, ca, aa >
5 <sa, ra >
table 1: event log for the loan process of figure 1.
while the Ô¨Årst two traces follow the proposed schema, the others show pro-
cess instances where the applicant has been contacted only shortly before ap-
proving the application (i.e., line 3), instances in which a manager approved an
application without analyzing the relative documents (i.e., line 4) and where an
application is rejected by default, without actually performing the process (i.e.,
line 5). these traces are called anomalous with respect to our model, since they
represent an ordering of occurrence of events which is not allowed by such model.
4 from event log to process instances
our goal consists in building for each trace in an event log the corresponding
process instance, describing the execution path of the performed activities. such
ataskisactuallynottrivial,sincepossibleparallelismsbetweeneventsarehidden
inthesequentialtraces.asanexample,ifweconsideronlytheÔ¨Årsttraceintable
4for the sake of simplicity, attributes which uniquely identify the events are omitted.1 we cannot derive that the activities cfs;ca have been executed in parallel,
unless having at disposal the process model, which is generally not the case.
to address this issue, here we refer to the approach proposed by [4], which is
developed in two steps. first, it extracts the set of causal dependencies from the
eventlogbymeansofapmtechnique,i.e.the -algorithm [10].then,itusessuch
dependencies to deÔ¨Åne for each trace a so-called instance graph (ig), that is a
graphrepresentingaprocessinstance.aniginvolvesanodeforeachentryinthe
event log; two nodes are linked by an edge only if a causal dependency between
their corresponding activities is deÔ¨Åned. [4] proposes an iterative procedure for
building the igs set. for each trace, it analyzes each pairs of events ( ei,ej) with
i < j, such that a causal dependency exists between them (i.e., between the
activities they represent), and links the corresponding nodes in the graph only
if between these events there is not neither another causal successor of ei, nor
a causal predecessor of ej. in other words, this procedure links each event only
with its closest causal successors. as an example, let us assume we want to build
the ig for the Ô¨Årst trace in table 1, by using the dependencies shown in figure
1 (e.g.sa!cfs,cfs !ad, etc.). we start from the pair (sa;cfs );
a causal dependency exists and there is not any other event between them.
therefore, we can link the corresponding nodes in the graph. then, we consider
(sa;ca ); also in this case a causal dependency sa!caexists, but we have
cfsbetween them, that is a causal successor of sa. however, there is not any
causal predecessor of ca, so we can anyway link the nodes corresponding to sa
andca. by analyzing in this way the entire trace, we obtain the corresponding
instance graph, shown in figure 2b. note that, since an ig explicitly represents
parallelisms, it can describe a set of traces, rather than a single one; as an
example, the ig we built can correspond both to the Ô¨Årst and the second trace
in the event log.
the discussed procedure presents some limits when applied to a spaghetti
process; such problems are discussed in the following subsection, where it is also
outlined our proposed extension to overcome them.
(a)
 (b)
fig.2: example of an instance for the loan application process (a) and its cor-
responding instance graph (b).4.1 dealing with noise
the-algorithm exploited by [4] is known to have problems in dealing with
spaghetti processes. this technique recognizes a causal dependency between two
eventsa;bif and only if aoccurred before b, andbnever occurred before a
in the log; otherwise, they are considered parallels. in the presence of excep-
tional behaviors, some problems arise. as an example, from the log in table
1 it returns a parallelism between caandadthat is clearly undesired. in a
spaghetti context, with such a logic we can expect to derive a very imprecise
model, with the result that the igs built by using its cr set will likely involve
too many parallelisms, thus signiÔ¨Åcantly overgeneralizing the process behavior.
to limit overgeneralization, some authors [8] proposed the generation of several
schemas, each representing a process variant, by clustering log traces. here we
adopt a diÔ¨Äerent approach, based on deriving the cr set using Ô¨Åltering tech-
niques. filtering techniques are a kind of pm techniques aimed at evaluating the
relevance of each detected dependency on the basis on some heuristic (e.g. fre-
quency), to build the Ô¨Ånal model by using only the most relevant dependencies.
a well-known example of Ô¨Åltering technique is the heuristic miner [9], aimed
at extracting only the most frequent dependencies; clearly, the graphs built by
using only such dependencies provide a much more precise description of the
process than the ones built by the -algorithm. however, the model obtained
by a Ô¨Åltering technique cannot describe all the traces in the event log. hence,
we will have a subset of anomalous traces, for which the ig building procedure
obtains again overgeneralizing graphs. as an example, let us consider the third
and fourth traces in table 1, hereafter indicated as t3;t4respectively. in t3, the
activitycaoccurred in a not allowed position, while in t4the activity addid
not occur. figure 3 shows the igs obtained for such traces, i.e. ig3andig4.
(a)ig3
 (b)ig4
fig.3: instance graphs for the anomalous traces t3andt4.
let us consider Ô¨Årst ig3. such graph introduces a signiÔ¨Åcant overgeneral-
ization, since the only execution constraint for cais to be performed after
sa; hence, it can occur in every order with respect to all the other events.
consequently, ig3can generate many other traces besides t3, providing a poor
representation for the corresponding process instance. the reason for such an
outcome is that the ig building procedure exploits the regular cr set to buildig3, while, being caoccurred in a not allowed position, those relations do not
hold for it. as regards ig4, due to the deletion of the activity adthe node
representing the activity aais not linked to anything, which means that such
activity is considered parallel to all the others.
to deal with mentioned issues, we propose an extension of [4], aimed at re-
pairingigs corresponding to anomalous traces, i.e. transforming them in graphs
capable of representing also the anomalous traces without overgeneralizing. to
this end, Ô¨Årst we need to recognize which are the anomalous traces in the event
log. this can be done by means of a conformance checking technique, i.e. a tech-
nique devoted to check whether or not an event log Ô¨Åts with a given process
model [11]. more precisely, we use the approach proposed in [12], which checks
if it is possible to replayevery trace tof the event log in a given process model
(typically a petri net), i.e. if exists a mapping between every event occurred in
tand a transition Ô¨Åred in the net. if tinvolves one or more anomalies, the reply
fails. among the several possible mappings between tand the net, [12] returns
the one involving as few anomalies as possible. such a mapping allows us to
identify the set of igs to repair, with precise indications about the positions and
the kinds of the anomalies. then, we can proceed with the repairing, applying
tailored rules for deleted and inserted events. for deleted events, the repairing
consists in identifying the disjunction points of the graph and properly connect-
ing them. for the insertion repairing, we have to change the edges connecting the
nodes corresponding to the event(s) before and the event(s) after the inserted
event, to connect such nodes with the node corresponding to the inserted event
in the graph. figure 4 shows the repaired graphs corresponding to ig3,ig4.
(a) repaired ig3
 (b) repaired ig4
fig.4: repaired graphs for anomalous traces t3,t4
we performed some preliminary tests on real event logs to validate our ap-
proach, which cannot be presented here for the lack of space. preliminary results
are promising, since we were actually able to build process instances also for less
structured processes, whose event logs involved quite heterogenous traces.
5 conclusion and future works
in the present work we addressed the issue of building process instances from
sequential traces stored in the event log in complex spaghetti contexts, whereit is hard to detect the ordering relations of the activities in the process. we
discussed about limits of previous approaches, and introduced an extension of
an ig building technique, aimed at overcoming such limits. preliminary results
suggest to explore further in this direction. in particular, we plan to complete
and extend the present experimentation.
in future works, we also plan to test other Ô¨Åltering pm approaches, to eval-
uate how the application of diÔ¨Äerent techniques can aÔ¨Äect results. furthermore,
we intend to apply the extended ig building procedure to the methodology
proposed in [2], to exploit such instances to extract meaningful subprocesses.
references
1. van der aalst, w.: process mining: discovery, conformance and enhancement of
business processes. springer (2011)
2. diamantini, c., genga, l., potena d., storti, e.: patterns discovery from innova-
tion processes. in: 2013th international conference of collaboration technologies
and systems, pp. 457-464. ieee (2013)
3. diamantini,c.,genga,l.,potena,d.,storti,e.:discoveringbehaviouralpatterns
in knowledge-intensive collaborative processes. in: appice, a., ceci, m., loglisci,
c., manco, g., masciari e., zbigniew w. (eds.) new frontiers in mining complex
patterns, lncs, vol. 8983, pp. 149-163. springer international publishing (2015)
4. van dongen, b., van der aalst, w. : multi-phase process mining : building in-
stance graphs. in: atzeni, p., chu, w., lu, h., zhou, s., ling, t. (eds.) concep-
tual modelling-er 2004, lncs, vol 3288, pp. 362-376. springer berlin heidelberg
(2004)
5. markus fischer: aris process performance manager. in: 14th gi/itg conference
- measurement, modelling and evalutation of computer and communication sys-
tems. (2008)
6. lu, x., fahland, d., van der aalst, w.: conformance checking based on partially
ordered event data. in: 10th international workshop on business process intelli-
gence. (2014)
7. fahland, d., van der aalst, w.: model repair - aligning process models to reality.
information systems 47, 220-243. (2015)
8. de medeiros, a. , guzzo, a., greco, g., van der aalst, w., weijters, a., van
dongen, b., sacc√†, d.: process mining based on clustering: a quest for precision.
in: ter hofstede, a., benatallah, b., paik, h. (eds.) business process management
workshops, lncs, vol 4928, pp. 17-29. springer berlin heidelberg (2008)
9. weijters,a.,vanderaalst,w.,demedeiros,a.:processminingwiththeheuristics
miner-algorithm. technische universiteit eindhoven, tech. rep. wp 166, pp 1-34.
(2006)
10. vanderaalst,w.,maruster,l.:workÔ¨Çowmining:discoveringprocessmodelsfrom
event logs. ieee transactions on knowledge and data engineering 16, 1128-1142.
(2004)
11. rozinat, a., van der aalst, w.: conformance checking of processes based on mon-
itoring real behavior. information systems 33 (1), 64-95. (2008)
12. adriansyah, a., boudewijn, f., van der aalst, w.: conformance checking using
cost-based Ô¨Åtness analysis. in: 15th ieee international enterprise distributed ob-
ject computing conference (edoc), pp. 55-64. ieee (2011)