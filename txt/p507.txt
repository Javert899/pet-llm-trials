informatik - forschung und entwicklung manuscript no.
(will be inserted by the editor)
w.m.p. van der aalst ¢m. pesic ¢h. schonenberg
declarative work°ows
balancing between flexibility and support
eingegangen: date / angenommen: date
zusammenfassung insert your german abstract here.
include up to ¯ve keywords.
schläusselw äorter first keyword ¢second keyword ¢
more
abstract today's process-aware information systems
tend to either support business processes orprovide °ex-
ibility. classical work°ow management systems o®er good
process support as long as the processes are structured
and do not require much °exibility. information systems
that allow for °exibility have a tendency to lack process-
related support. if systems o®er guidance, then they are
typically also inclined to \enforce guidelines" and are
perceived as in°exible. moreover, implementing °exible
systems is far from trivial. this paper will show that us-
ing a more declarative approach can assist in a better
balance between °exibility and support. this is demon-
strated by presenting the declare framework that aims
to take care of the full spectrum of °exibility while at the
same time support the user using recommendations and
other process-mining-based diagnostics.
keywords work°ow management ¢business process
management ¢flexibility ¢process mining
cr subject classi¯cation h.4.1 ¢d.2.2 ¢d.2.11
1 introduction
process-aware information systems (paiss) support ope-
rational business processes by combining advances in in-
formation technology with recent insights from manage-
ment science [21]. work°ow management systems (wfmss)
w.m.p. van der aalst ¢m. pesic ¢h. schonenberg
eindhoven university of technology, p.o. box 513, nl-5600
mb, eindhoven, the netherlands.
tel.: +31-40-2472733
fax: +123-40-2463992
e-mail: fw.m.p.v.d.aalst,m.pesic,h.schonenberg g@tue.nlare typical examples of such systems. however, many
other types of information systems are also \process awa-
re" even if their processes are hard-coded or only used
implicitly (e.g., erp systems). the shift from data ori-
entation to process orientation has increased the import-
ance of paiss. moreover, advanced analysis techniques
ranging from simulation and veri¯cation to process mi-
ning and activity monitoring allow for systems that sup-
port process improvement in various ways.
when backing business processes with it there is a
di±cult trade-o® to be made. on the one hand, there is
a desire to control processes and to avoid incorrect or
undesirable executions of these processes. on the other
hand, users want °exible processes that do not constrain
them in their actions. this apparent paradox has limited
the application of wfmss thus far, since, as indicated
by many authors, wfmss are too restrictive and have
problems when dealing with change [5].
flexibility support
pais spectrum
abb. 1 today's pais spectrum: systems o®er support or
°exibility but not both.2 w.m.p. van der aalst et al.
many approaches have been proposed to resolve the
apparent paradox illustrated by figure 1. some of them
try to avoid change, e.g. by generating implicit alterna-
tive paths [8; 12], or by deferring the selection of the de-
sired behavior [11]. others allow for changing the model
for a single instance and/or changing a process model
while migrating all instances [16; 22; 40; 48]. the mi-
gration of process instances from one model to another
introduces many interesting problems [5; 16; 40; 48]. for
example, the \dynamic change bug" originally described
in [22] shows that it may be impossible to put the process
instance into a suitable state of the new model without
skipping or repeatedly executing activities.
the goal of the paper is to demonstrate that by using
a declarative approach it is possible to balance between
support or °exibility . traditional approaches tend to use
procedural process models to explicitly (i.e., step-by-
step) specify the execution procedure. the declarative
approach presented in this paper is based on constraints ,
i.e., anything is possible as long as it is not explicitly
forbidden. constraint-based models, therefore, implicit-
ly specify the execution procedure by means of cons-
traints: any execution that does not violate constraints
is possible. we have implemented the declare frame-
work that provides for multiple constraint-based langua-
ges. by using such a declarative approach, di®erent types
of °exibility become possible as shown in the remainder
this paper is organized as follows. section 2 presents
a small \taxonomy of °exibility" using three basic types
of °exibility. moreover, the di®erent types of °exibility
are positioned in the overall life-cycle of a process. using
this as a basis, section 3 discusses the support ultimately
desired from a pais. section 4 introduces the decla-
reframework and explains the concept of constraint-
based work°ow models. section 5 relates declare to
the initial taxonomy presented in section 2. section 6
evaluates the support provided by declare and sec-
tion 7 discusses the limitations of the current approach
and implementation. section 8 presents related work and
section 9 concludes the paper.
2 flexibility
flexibility has become one of the major research topics
in the area of work°ow management [5]. today's wfmss
and many other paiss have problems providing for °exi-
bility [33; 47]. as a result, these systems are not used to
support dynamically changing business processes or the
processes are supported in a rigid manner, i.e., changes
are not allowed or handled outside of the system. these
problems have been described and addressed extensively
in literature [8; 10; 22; 35; 38; 40; 42; 48]. nevertheless,
many problems related to °exibility remain unsolved.
in this section, we provide an overview of the di®erent
types of °exibility using a taxonomy. this taxonomy isbased on [43]. see also [5; 9; 23; 26; 33; 39; 42; 47] for
other classi¯cations of °exibility.
to start, let us identify the di®erent phases of a pro-
cess (instance) in the context of a wfms:
{design time. at design time a generic process model
is created. this model cannot be enacted because it
is not connected to some organizational setting.
{con¯guration time. at con¯guration time a generic
model is made more speci¯c and connected to some
organizational context which allows it to be instan-
tiated.
{instantiation time. at instantiation time a process
instance is created to handle a particular case (e.g.,
a customer order or travel request).
{run time. at run time the process instance is execu-
ted according to the con¯gured model. the di®erent
activities are being enacted as speci¯ed.
{auditing time. at auditing time the process instance
has completed, however, its audit trail is still availa-
ble and can be inspected and analyzed.
flexibility plays a role in most of these phases. at
design time some modeling decisions can be postponed
to run time. at run time one can decide to deviate from
the model and at instantiation time one can change the
process model used for the particular instance. when it
comes to °exibility, we identify three °exibility mecha-
nisms :
{defer, i.e., decide to decide later. this °exibility me-
chanism deliberately leaves freedom to maneuver at a
later phase. examples are the use of a declarative pro-
cess modeling language which allows for the \under
speci¯cation" of processes and the use of late-binding,
i.e., the process model has a \hole" that needs to be
¯lled in a later phase.
{change, i.e., decide to change model. most resear-
chers have addressed °exibility issues by allowing for
change. decisions made at an earlier phase may be
revisited. for example, for premium customers the
process may be adapted in an ad-hoc manner. the
change may refer to the model for a single instance
(ad-hoc change ) or to all future cases ( evolutionary
change ). in both cases, a change can create inconsis-
tencies. for example, there may be process instances
that cannot be migrated properly when conducting
an evolutionary change [2; 16; 22; 38; 40; 48].
{deviate, i.e., decide to ignore model. the third me-
chanism is to simply deviate from the model, e.g.,
activities are skipped even if the model does not al-
low for this to happen. in many environments it is
desirable that people are in control, i.e., the system
can only suggest activities but not force them to hap-
pen.
figure 2 relates the two dimensions just mentioned.
based on the di®erent phases and the three mechanisms,
di®erent types of °exibility are classi¯ed. note that we
did not mention any examples of °exibility at auditingdeclarative work°ows 3
design timedefer
(decide to decide 
later)
configuration  time
instantiation  time
run  time
auditing  timechange
(decide to change 
model)deviate
(decide to ignore 
model)
e.g., defer to run-time by 
using late binding or
declarative modelingn/a n/a
n/a n/a n/ae.g., change model for
running instance or migrate
instance to new modeln/ae.g., skip or redo a task
while this is not specifiedn/ae.g., violate a configuration
constraint
e.g., modify model for a 
particular customere.g., remodel parts of the
process at configuration
timee.g., defer configuration
decisions
e.g., defer the selection of
parameters or process 
fragments
abb. 2 classi¯cation of the di®erent types of °exibility based on the phase and mechanism.
time. after the process instance completes, deferring,
changing, or deviating is not possible anymore or would
imply fraud. also note that the actual mechanism in dif-
ferent cells can be the same, e.g., deferring a choice to
run-time can be done at design time, con¯guration time
and instantiation time.
figure 2 can be used to characterize the support for
°exibility of a concrete wfms. unfortunately, today's
systems typically provide for only a few forms of °exibi-
lity. this is limiting the applicability of paiss since wi-
thin one organizations di®erent forms of °exibility may
be required.
in the remainder, we will show that it is relatively
easy to care for the various types of °exibility by using a
declarative approach. however, as indicated in the intro-
duction there may be a trade-o® between °exibility and
support. therefore, we ¯rst elaborate on the support de-
sired.
3 support
it is relatively easy to develop systems that that are ex-
tremely °exible while providing little process support. a
nice example is an e-mail program like outlook. outlook
is not forcing users to send e-mails at particular times or
in a particular order. so it can be seen as a very °exible
system as it allows users to execute activities (e.g., sen-
ding e-mails) in any way they want. however, outlook is
providing hardly any support and has no knowledge of
the processes users are involved in. in this paper, we only
consider paiss where some process model is used during
enactment. in fact, we focus on wfmss. these systems
use an explicit process design as a starting point. this
design is used at run time to control and support users.in this section we elaborate on support in the main two
phases depicted in figure 2: design time andrun time .
3.1 design-time support
at design time a model is constructed that will be used
to enact the work°ow at run time. besides providing a
good editor to design the work°ow process, the wfms
should also provide good analysis tools. here we elabora-
te on two types of analysis: veri¯cation andperformance
analysis .
veri¯cation the goal is to design processes that are cor-
rect, e.g., there should not be potential deadlocks, etc.
using veri¯cation techniques it is possible to discover
problems before the design is enacted. we distinguish
between syntactical veri¯cation and semantical veri¯ca-
tion. syntactical veri¯cation aims at the discovery of er-
rors that do not require domain analysis. for example,
a model that can deadlock is incorrect independent of
the intent of the process. similarly, it is not acceptable
to have processes that may not terminate or where some
activities can never be executed. the notion of soundness
[1] is a typical example of a correctness property checked
through syntactical veri¯cation. semantical veri¯cation
aims at the analysis of properties that can only be for-
mulated based on domain knowledge. for example, when
two drug types are incompatible, then it should not be
allowed to make a model in such a way that an instan-
ce (i.e., a patient) can receive both drug types during
execution. semantical constraints over processes express
domain knowledge. such knowledge is vital when provi-
ding more °exibility, e.g., end users should not modify
process models such that essential semantical constraints4 w.m.p. van der aalst et al.
get violated. see [31] for examples of semantical correct-
ness notions relevant when adapting processes.
performance analysis process models should be correct,
but also the performance of a process is relevant. the
°ow time may be too long or utilization levels and re-
sponse times can be unacceptable. to predict such situa-
tions and to support process improvement, techniques for
performance analysis can be used at design time. for ex-
ample, simulation can be used to predict key performan-
ce indicators and to evaluate redesigns. in this paper, we
will not elaborate on performance analysis. however, it
is important to realize that such functionality may be
important when justifying the use of a wfms.
3.2 run-time support
at run time, the model made at design time is enac-
ted. assuming that the model is correct and has a good
performance, we distinguish various types of run-time
support.
enforcing correct execution the wfms should use the
model made at design time to enforce the correct exe-
cution, i.e., work-items should be o®ered based on the
process model and the system should prevent the execu-
tion of activities that are not enabled according to the
model.
recommending e®ective execution the focus of classical
wfmss is on control, i.e., the system decides on the
ordering of activities. when systems allow for more °e-
xibility the decision freedom increases. for example the
defer °exibility type (\decide to decide later") may move
choices from design time to run time. to support users
when making decisions, the system may provide recom-
mendations. these recommendations may depend on ex-
plicit domain knowledge. however, it is also possible to
learn good strategies through process mining and then
use these for guidance [44]. for example, it is possible
to analyze choices made in the past with respect to °ow
time and then suggest for new cases the \fastest path"
through the process. the user can still decide to ignore
the recommendation, but at least some decision support
is given.
monitoring process instances the wfmss should also
support the monitoring of process instances. it should
be possible to follow speci¯c cases and to look at the
work°ow at a more aggregate level. users should be able
to get insight into the status of a single case, a group of
cases, and the whole work°ow.learning from processes the more °exible the system is,
the more variations are possible when conducting work.
therefore, it is interesting to use process mining [7] to
discover the real processes taking place. starting point
for process mining are the event logs, i.e., data on the ac-
tual execution of activities. the wfms should support
the recording of these events in a systematic manner and
the analysis tools of the wfms should be able to extract
knowledge from these logs. the more variability that is
possible, the more valuable such analysis is.
enforcing correct changes veri¯cation is not only rele-
vant at design time, but also at run time when changes
are applied. when using the °exibility type change (\de-
cide to change model"), errors can be introduced into the
model. hence, again syntactical and semantical veri¯ca-
tion need to be provided to ensure the correct operation
of the system.
note that the above summary of required design-time
and run-time support is far from complete. we empha-
sized aspects related to °exibility, e.g., the monitoring
of instances becomes more relevant when users are not
forced to work in a particular way.
4 declare
the goal of this paper is to show that a more declarative
approach to work°ow management makes it easier to ba-
lance between °exibility and support. we will show that
it is easy to provide for a wide variety of °exibility types
without loosing key functionalities at design and/or run
time.
to illustrate the advantages of declarative work°ows
we present a concrete framework: declare .declare
is a constraint-based wfms that provides for multi-
ple declarative languages (decserflow [6], condec [34],
etc.). in fact, declare is extendible and without any
programming it can be con¯gured to support additional
constraint-based languages. instead of explicitly de¯ning
the ordering of activities in models, declare models
rely on constraints to implicitly determine the possible
ordering of activities (any order that does not violate
constraints is allowed).
declare can be downloaded from [19]. the architec-
ture of the declare system is shown in figure 3. the
core of the system consists of the following basic com-
ponents: designer ,framework andworklist . the desi-
gner component is used for creating the so-called cons-
traint templates, to design concrete process models, and
to verify these model. the framework enacts instances of
process models. moreover, it also conducts ad-hoc chan-
ges of running instances. while the framework centrally
manages the execution of all instances, each user uses
his/her worklist component to access active instances.
also, a user can execute activities in active instances in
his/her worklist .declarative work°ows 5
declare
logs of executed instances framework 
instance enactment 
insatnce adaptation designer 
constraint templates 
constraint models 
model verification worklist 
instance execution 
constraint models 
 constraint templates worklist 
instance execution ...
abb. 3 the architecture of declare .
unlike most of the approaches, which o®er a prede¯-
ned set of constructs for de¯ning dependencies between
activities in process models (e.g., sequence, choice, paral-
lelism, loops, etc.), declare uses a customizable set of
arbitrary constructs called constraint templates . a decla-
rative language can be seen as a collection of constraint
templates. this explains why the declare system pro-
vides for multiple languages (e.g. decserflow [6] and
condec [34]). templates are de¯ned on the system le-
vel in the designer component. each template has (1)
a unique name, (2) a graphical representation, and (3)
a formal speci¯cation of its semantics in terms of line-
ar temporal logic (ltl) [17; 24]. ltl is a special type
of logic which, in addition to classical logical operators,
uses temporal operators such as: always ( ¤), eventually
(§), until ( t), and next time ( °) [17]. figure 4 shows
how the response template is de¯ed. this template is
graphically represented with a single line between two
activities aandb, with a ¯lled circle next to aand a
¯lled arrow next to b. the semantics of the template
is given as ltl formula ¤(a)§(b)), i.e., every time
activity ais executed, bhas to be executed afterwards
at least once.
abb. 4 constraint template response .
in this paper, we use condec [34] as the modeling
language. condec can be seen as a collection of cons-
traint templates. using these templates one can make
concrete models. in this paper, we will refer to such acondec model as \ declare model" or simply \model"
because we do not elaborate on the di®erent languages
supported by declare .
abb. 5 declarative model for handling patients using de-
clare .
in the remainder, we use the process for handling a
patient at the ¯rst aid department in a hospital with a
suspicion of a fracture as a running example. figure 5
shows the model constructed using declare . all acti-
vities are depicted as boxes, constraints are depicted by
relations (lines) between activities. the model contains
mandatory constraints (solid lines) and optional cons-
traints (dashed lines). for example, the dashed arrow in
figure 5 shows an application of the response template
de¯ned in figure 4. we use the following fonts to refer
to activity (task) names and constraint template names
respectively: task name andconstraint name .
initially, a specialist performs activity examination
(constraint init), if necessary, additional diagnosis is do-
ne by x-ray . depending on the absence, presence and
type of fracture, there are several types of treatment
available, such as sling,¯xation ,surgery and cast. ex-
cept for cast and ¯xation , which are mutually exclusi-
ve (constraint not co-existence ), the treatments can be
given in any combination and each patient receives at
least one treatment ( 1 of 4 constraint). additional dia-
gnosis ( x-ray ) is not necessary when the specialist dia-
gnoses the absence of a fracture during examination . wi-
thout this additional diagnosis, the patient can only re-
ceive the sling treatment. all other treatments require
x-ray to rule out the presence of a fracture, or to decide
how to treat the fracture (constraint precedence ). sim-
ple fractures can be treated just by cast. for unstable
fractures activity ¯xation may be preferred over activity
cast. for patients who undergo surgery the specialist is
advised to execute activity rehabilitation afterwards (op-
tional constraint response ). moreover, the specialist can
provide medication , e.g., pain killers or anticoagulants, at
any stage of the treatment. also additional examinations
and x-rays can be done during the treatment.6 w.m.p. van der aalst et al.
tabelle 1 ltl expressions for constraints in figure 5.
template formula constraint ltl expression
init(a) =a init examination
precedence (a; b) = (! b)wa precedence (!(surgery _¯xation _cast)wx-ray
response (a; b) =¤(a)(§b)) response ¤(surgery )(§rehabilitation ))
1of4(a; b; c; d ) =§(a_b_c_d) 1 of 4 §(surgery _¯xation _cast_sling)
not coexistence (a; b) =!((§a)^(§b))not-coexistence !((§¯xation )^(§cast))
note that init,precedence ,1 of 4 , and not co-existence
refer to constraint templates whose semantics are expres-
sed in terms of ltl. table 1 shows the relation between
the constraints shown in figure 5, the constraint tem-
plates, and ltl. the process should start with examina-
tion. this constraint is speci¯ed using the inittempla-
te. table 1 shows its de¯nition: init(a) =a. therefore,
init(examination ) =examination . note that in ltl-terms
this means that examination should be the current (i.e.,
¯rst) action. the precedence constraint template is de-
¯ned by the ltl formula precedence (a; b) = (! b)wa,
i.e.,bshould nothappen before ahas happened. no-
te that wis a temporal operator similar to t(until).
the \weak until" operator win \(! b)wa" says that
adoes not have to happen if bnever happens. in fi-
gure 5, the precedence constraint template is used with
three b's, i.e., (!( surgery _¯xation _cast)wx-ray de¯nes
the semantics of this particular constraint. this means
that the treatments surgery ,¯xation , and castall requi-
rex-ray to rule out the presence of a fracture. howe-
ver, x-ray is not needed if none of the treatment ac-
tivities ( surgery ,¯xation , and cast) occurs. table 1 al-
so de¯nes the 1 of 4 andnot co-existence constraints.
1of4(a; b; c; d ) =§(a_b_c_d) means that even-
tually ( §) at least one of the four activities should oc-
cur.not coexistence (a; b) =!((§a)^(§b)) means that
it cannot (!) be the case that eventually aoccurs ( §a)
and that eventually boccurs ( §b).
the process de¯ned by figure 5 allows for many
execution paths. unlike imperative languages, there is
no need to include these execution paths explicitly. for
example, the mutual exclusion constraint between cast
and¯xation is di±cult to express in imperative langua-
ges, especially since the moment of choice between these
two treatments is not ¯xed. in an imperative language
one would need to decide on the moment of choice, spe-
cify the loop behavior, and determine the people making
these choices. in declare one can simply use the not-
coexistence constraint with an intuitive graphical notati-
on. in declarative languages only the rules that constrain
the behavior need to be speci¯ed. therefore, there is no
need to enumerate the execution paths.
constraint response between activities surgery and
rehabilitation is optional as shown by the dashed arrow
in figure 5. figure 6 shows the de¯nition of the cons-
traint that is using the response template. note that for
optional constraints a level and a warning message can
be de¯ned. in this particular case a warning of level \5"
abb. 6 de¯ning the optional response constraint.
is generated when the user is about to violate the cons-
traint.
abb. 7 executing an instance.
figure 7 shows the worklist component containing
two active instances (active instances are presented in
the list on the left-hand side of the screen). after execu-
ting activity examination , the user is currently executing
activity medication for the second process instance. acti-
vities examination ,x-ray , and medication are enabled, i.e.,
can be executed. activities surgery ,¯xation , and castare
disabled, i.e., cannot be executed (indicated by the gray
color) due to the precedence constraint (activity x-ray is
not executed yet in this instance).declarative work°ows 7
the enabling and execution of activities is driven by
constraints: everything that does not violate the man-
datory constraints is enabled for execution and all man-
datory constraints must be satis¯ed at the end of the in-
stance execution. for an active instance, each constraint
is in one of three states: satis¯ed ,temporarily violated ,
orviolated . in the violated state there is no possible fu-
ture that will satisfy the constraint. in the satis¯ed state
there is no need to execute more activities to let the cons-
traint evaluate to true. for example, the init,precedence ,
andresponse constraints are satis¯ed in the instance pre-
sented in figure 7. in all other states, the constraint is
not (yet) satis¯ed, but it is still possible to satisfy the
constraint by executing the appropriate activities. these
states are called temporarily violated . for example, cons-
traint 1 of 4 istemporarily violated because none of the
activities surgery ,¯xation ,cast andsling are executed,
but executing one of these four activities will bring this
constraint into the state satis¯ed .
optional constraints may become violated. however,
this is not possible for mandatory constraints. in order
to enforce this, declare constructs an automaton for
each constraint [6; 34]. to achieve this we use an ap-
proach similar to [17; 24]. based on the automaton it is
possible to see whether the execution of some activity
will violate the constraint. since there is an automaton
per constraint, it is easy to see which constraints are vio-
lated by which actions. moreover, declare constructs
an overall automaton that is based on the conjunction of
all ltl-based constraints. this way it is possible to make
sure that mandatory constraints are either in state sa-
tis¯ed or state temporarily violated . optional constraints
can also be in state violated . however, when an optional
constraint is about to be violated the system issues a
warning (cf. figure 6).
so each constraint is translated into a ¯nite state au-
tomaton that exactly represents all words (i.e., all execu-
tions) that satisfy the corresponding ltl formula. for
each process instance, declare creates (1) one auto-
maton for the conjunction of ltl formulas of all cons-
traints in the instance, i.e., the so-called instance auto-
maton, and (2) one automaton for each constraint in the
instance. as mentioned before, these automata are used
for several purposes when executing the instance. first,
the instance automaton is used for driving the execu-
tion: executing an activity in the instance triggers one
or more transitions in the automaton and, thus, causes
the state change of the automaton. second, the instance
automaton is used to determine which activities are ena-
bled: only activities that can be triggered at the current
state of the automaton are enabled. third, the instance
automaton is used to determine the state of the instance:
if the current state of the automaton is accepting, then
the instance is satis¯ed ; if the current state of the auto-
maton is non-accepting, then the instance is temporarily
violated . fourth, the automaton created for each cons-
traint is used to determine the state of the constraint: ifthe current state of the automaton is accepting, then the
constraint is satis¯ed ; if the current state of the automa-
ton is non-accepting, then the constraint is temporarily
violated . details about the usage of automata for the exe-
cution of instances in declare are out of scope of this
paper. we refer the interested reader to [33].
5 flexibility with declare
in this section we show that declare cares for all three
°exibility types introduced in section 2, i.e., (1) defer ,
(2)change , and (3) deviate . to show that this is indeed
the case, we ¯rst summarize the main di®erences with
imperative/procedural languages using figure 8.
forbidden 
optional
allowed 
possible (a) forbidden, optional and allowed 
in business processes 
(b) traditional approach control-flow 
(c) constaint-based approachconstraints constraintsconstraintsconstraints
abb. 8 mandatory constraints restrict the set of possible
behaviors while optional constraints further guide the user.
since traditional approaches explicitly specify the possible
behaviors, declarative language tend to be more °exible [33].
the black oval in figure 8(b) represents the behavi-
oral boundary of a classical (i.e., imperative/procedural)
process model that is de¯ned using an \inside out" sty-
le of modeling where routing is modeled explicitly. the
black thick boundary in figure 8(c) represents the \out-
side in" style of modeling supported by declare and
the use of optional constraints. comparison of the two
approaches in figure 8 suggests that a declarative ap-
proach indeed allows for more °exibility.
5.1 defer (\decide to decide later")
declare facilitates °exibility by the possibility to ea-
sily defer choices to run time. consider for example the
not-coexistence constraint in figure 5. this constraint
speci¯es the mutual exclusion of the two activities cast
and¯xation . we only specify that if castis done, then
¯xation cannot occur and vice versa. hence, with little ef-
fort, many choices are deferred to run time. for example,
castand¯xation may both occur multiple times or not at
all. the only requirement is that for the same instance8 w.m.p. van der aalst et al.
they do no both happen. note that there is no explicit
choice between activities castand¯xation , i.e., there is
no activity inserted to make decisions on the number of
times each of these activities should be executed. specify-
ing such a constraint in an imperative language typically
results in an \over speci¯cation" of the desired behavior,
i.e., the user has to explicitly incorporate all execution
paths and identify explicit decision points determined at
design time.
figure 5 shows several other constraints that would
be di±cult to capture in traditional languages without
unnecessarily restricting the user at run time. for exam-
ple, in figure 5 a specialist can administer medication at
any moment. the decision how often andwhen this can
be done is deferred to run time and not included into the
design. the only thing that is speci¯ed is that medication
is an activity the specialist can execute in the fracture
process and that there are no constraints on this activity.
these examples show that declare de¯nitely sup-
ports the °exibility type \decide to decide later" descri-
bed in section 2.
5.2 change (\decide to change model")
declare allows for instance change at run time to sup-
port unforeseen situations or changed circumstances. the
change may refer to a single instance (ad-hoc change) or
all instances of a given process (evolutionary change).
to illustrate the functionality provided by declare , we
consider figure 5. suppose that new guidelines would
forbid specialists to prescribe the usage of sling without
the execution of x-ray . this can be achieved by adding
an additional branch to activity sling on the precedence
constraint as shown in figure 9. this branch can be ad-
ded to the instance in an ad-hoc manner, i.e., during the
execution of the instance. in addition, it is possible to re-
quest that the change should be applied to all instances
(evolutionary change). this implies that all running in-
stances of the model are migrated (if possible) from the
model in figure 5 to the model in figure 9. moreover,
all new instances would start in the new model. all of
this is possible in declare illustrating that a declara-
tive approach is able to address many of the problems
described in literature [2; 22; 40].
declare applies the change only to instances that
do not become violated because of the migration to the
new or adapted process, for example, assume that the
ad-hoc change presented in figure 9 is applied to an in-
stance of the model from figure 5 for which activities
examination ,sling, and medication have been executed.
because the added branch speci¯es that activity sling
can be executed only after activity x-ray was executed,
applying this change would lead to a violation because
activity sling is already executed before activity x-ray .
the instance automaton (cf. section 4) is used to check
whether an ad-hoc change is applicable for an instance.
abb. 9 the initial model is changed by extending the pre-
cedence constraint. this constraint now also includes activity
sling.
the change is applicable if and only if the instance histo-
ry can be \replayed" on the automaton generated for the
new model. if the new model is not consistent with the
instance history, then the automata generated for subsets
of constraints can be used to determine which minimal
combination of constraints in the new model prevents the
ad-hoc change. indeed, figure 10 shows that the prece-
dence constraint does not allow the change presented in
figure 9.
abb. 10 report for the ad-hoc change in figure 9 showing
that an instance cannot be migrated because of a violation
of the new precedence constraint.
5.3 deviate (\decide to ignore model")
as mentioned earlier, declare allows for optional cons-
traints. in figure 5 the response constraint is optional
as indicated by the dashed line. figure 6 showed the
de¯nition of this constraint indicating the warning that
will be given if a users tries to violate this constraint.
figure 8(c) shows the basic idea behind such optional
constraints, the user can deviate into the light-gray part
of the ¯gure and thus \decide to ignore model". one can
think of optional constraints as guidelines or \soft" cons-
traints. declare allows the designer to set a warningdeclarative work°ows 9
level to indicate the severity of such a deviation. this
waydeclare also provides provides for the third type
of °exibility identi¯ed in section 2.
abb. 11 a warning regarding the possible violation of the
optional response constraint.
figure 11 shows a warning shown to a user who is
about to violate the optional response constraint. this
constraint indicates that if surgery has been executed,
then rehabilitation has to be executed afterwards. it is not
enforced because when the patient is young and mobile
and the severity of fracture is minor this is not strict-
ly necessary. the instance presented in figure 11 corre-
sponds to a patient for which activity surgery is executed
but activity rehabilitation is not executed yet. therefore,
theresponse constraint is temporarily violated (shown
using the color orange). if the user would try to close
this instance at this moment, this would permanently
violate the response constraint. if this would be a man-
datory constraint, closing the instance would not be pos-
sible. however, since the constraint is optional, the user
gets an informative warning about the possible violation.
note that the warning shown in figure 11 is indeed the
warning de¯ned in figure 6.
6 support by declare
this section presents the support provided by declare
using the topics identi¯ed in section 3. first, we discuss
the design-time support o®ered by declare . then, we
elaborate on declare 's run-time support.
6.1 design-time support
6.1.1 veri¯cation
constraints in declare models can interfere in subtle
ways. this can cause two types of errors . first, it mightbe that an activity in the model can never be executed.
we refer to such an activity as a dead activity . second,
it might be that constraints are con°icting, i.e., it is not
possible to execute a model in such a way that all man-
datory constraints are satis¯ed . we refer to this kind
of error as a con°ict . each dead activity and con°ict
is caused by a certain combination of mandatory cons-
traints in the model (i.e., the so-called cause of error ).
through veri¯cation, declare can automatically detect
the existence of dead tacks and con°icts while explicit-
ly indicating the combination of mandatory constraints
that cause each error. consider, for example, the model
shown in figure 12. this model contains three errors.
first, ¯xation is dead because of the non co-existence
constraint and the 1..*constraint on activity cast, i.e.,
castshould be performed at least once and therefore ¯-
xation can never occur. second, castis dead because of
thenon co-existence constraint and the 1..*constraint
on activity ¯xation . third, there is a con°ict because the
combination of the non co-existence constraint, the 1..*
constraint on activity ¯xation , and the 1..*constraint on
activity castleads to a contradiction.
abb. 12 a model with a con°ict.
the three errors in the figure 12 and the combinati-
on of constraints that cause them can be detected using
the automata generated from ltl speci¯cations of cons-
traints. in order to ¯nd the cause of an error, an auto-
maton is generated for the conjunction of all subsets of
mandatory constraints. if an error is found in a minimal
subset of constraints, then the error is reported and the
root cause is given as a subset of constraints. because
transitions of an automaton enable the execution of ac-
tivities, a dead activity is detected as an activity that
cannot be triggered by any transition of the automaton.
because a model exhibiting a con°ict can never be exe-
cuted such that all related constraints are satis¯ed, this
error is detected by checking whether the corresponding
automaton is empty, i.e., if it has no states and no transi-
tions, then the model has a con°ict. declare uses this
automata-based method to detect errors and the cor-10 w.m.p. van der aalst et al.
responding root causes. figure 13 shows the veri¯cation
report of declare for the model presented in figure 12.
indeed, the three errors and combinations of constraints
that cause them are detected.
(a) activity castis dead
(b) a con°ict
(b) activity ¯xation is dead
abb. 13 veri¯cation result for the model in figure 12.
note that dead activities and con°icts correspond to
syntactical errors (cf. section 3.1). using ltl it is al-
so easy to check for semantical errors. as long as the
(un)desired property can be expressed in terms of ltl,
classical model checking techniques can be used to ¯nd
the error. note that this is not (yet) implemented in de-
clare . however, syntactical errors are veri¯ed both at
design time and run time (see also section 6.2).
6.1.2 performance analysis
declarative models are less suitable for performance ana-
lysis. the reason is that many execution paths are pos-
sible, i.e., there is a tendency to defer decisions to run
time. hence, arbitrary runs of declare may not be re-
presentative for actual user behavior. in a procedural
language, the users are driven by the process model and
it is easy to de¯ne the behavior of users as their degree
of freedom is limited. this implies that declare could
only support performance analysis if a lot of information
is added about the expected behavior of users. therefo-
re, no support for performance analysis at design time is
added.6.2 run-time support
6.2.1 enforcing correct execution
as explained in section 4, declare constructs an in-
stance automaton based on the conjunction of all man-
datory constraints. this automaton forces the users to
stay within the boundaries of the model. by adding lots
of restrictive constraints, the behavior of the declare
engine becomes similar to that of a classical work°ow
engine. however, it is also possible to have just a few
mandatory constrains and thus only force the users with
respect to these constraints. the run-time view of de-
clare shows the activities that are enabled and indica-
tes the status of each constraint (cf. figure 7). an ac-
tivity is not enabled if its execution would permanently
violate a mandatory constraint.
6.2.2 recommending e®ective execution
the link between the process mining tool prom [4]
anddeclare enables the guidance of users through re-
commendations [44]. declare records all events taking
place, e.g., starting or completing an activity. these re-
corded events are shared with prom .prom is able to
extract knowledge from declare 's event logs using pro-
cess mining techniques. for example, as shown in [44],
prom can ¯nd the paths that minimize costs, °ow ti-
me, response time, resource utilization, etc. based on this
prom provides a so-called recommendation service . for
each running instance, declare continuously asks the
recommendation service for suggestions, i.e., all the ena-
bled activities are ranked based on historic information.
note that users do not have to follow recommendations;
they merely serve as an advice to support the user. rela-
ted to the recommendation service is the prediction ser-
viceofprom that predicts when a case is ¯nished. this
information may also be used when selecting an enabled
activity.
6.2.3 monitoring process instances
the monitoring of instances is important to manage the
process and to make users aware of the context of their
work. many systems use work distribution mechanisms
that lead to \context tunneling", i.e., the user only sees
one particular work-item in isolation without seeing the
bigger picture. this is the reason that declare shows
the process model augmented with additional informa-
tion. using colors it is shown which constraints are sa-
tis¯ed and which activities are enabled (cf. figure 7).
as explained in section 4 multiple automata are used
to determine the state of an instance and states of all
constraints. declare relies on prom for monitoring
processes at a higher level [4]. in the future we also hope
to use the work-item visualization of yawl [29]. this
visualization allows for the de¯nition of several \maps"declarative work°ows 11
on which work-items may be projected. we believe that
the more °exible processes are, the more important it is
to visualize \work" while using contextual information.
6.2.4 learning from processes
declare can export historic event information (e.g.,
starting and completing activities) by creating so-called
mxml logs while executing instances and these can be
loaded into prom .prom provides numerous plug-ins
to extract knowledge from these declare logs [4]. for
example, prom can extract process models based on
the work that has actually been done or construct social
networks based on the interactions between people. mo-
reover, declare templates and constraints can be ex-
ported into the so-called ltl format readable by prom .
prom 's ltl checker can then verify properties speci¯ed
in ltl with respect to some event log [4].
a-posteriori analysis of instances of the model pre-
sented in figure 5 can provide information that can help
to improve the model. for example, it is possible to check
which instances violated the optional constraint in figu-
re 5. moreover, additional properties not speci¯ed in the
model can be checked. consider, for example, the veri-
¯cation of instances processed in the past against the
following two properties: (1) activity surgery was execu-
ted in the instance, and (2) activity rehabilitation was
executed after activity surgery in the instance. on the
one hand, veri¯cation could show that the ¯rst property
(1) holds in 80% of the instances processed in the pre-
vious year, while it holds in only 40% of the instances
processed in the year before. this can be an indicati-
on that the hospital should hire more surgeons. on the
other hand, veri¯cation could show that the second pro-
perty (2) does not hold in 90% of the instances, i.e., the
medical sta® violated the optional constraint from the
model shown in figure 5 in 90% of the instances. this
result may indicate that this constraint should either be
removed from the model or made mandatory.
in [28] it is shown that declare models can also
be discovered using inductive logic programming. this
makes it possible to discover the primary constraints by
just observing the process. the discovered models can
be loaded into declare .
6.2.5 enforcing correct changes
as shown in sections 4 and 5, it is possible to change
processes. for an ad-hoc change only one instance needs
to be migrated, while for an evolutionary change in prin-
ciple all running instances need to be migrated. in figu-
re 9 it is shown that after making a choice the new model
can be veri¯ed and that instances can be migrated. ve-
ri¯cation of the new model is done in the same way as
described in section 6.1.1. this way it can be enforced
that the new model is syntactically correct, i.e., free of
deadlocks, etc. moreover, using \replay" it is enforcedthat only those instances are migrated that actually ¯t
into the new model. hence, declare ensures syntactical
correctness even when processes are changing.
7 limitations
in this paper, we demonstrated that declarative work°ow
languages can assist in balancing between °exibility and
support. as a proof of concept, the declare system was
presented. however, the current approach also has some
shortcomings. these are characterized by the following
three limitations.
the ¯rst limitation is that a constraint-based ap-
proach is not very suitable for processes that are of a
strict procedural nature. this becomes clear when loo-
king at figure 8. if the desired control-°ow is highly pro-
cedural, it is easier to simply describe what should hap-
pen rather than describing the constraints that should
be satis¯ed. as shown in figure 8, the starting point of
our constraint-based approach is that anything is allowed
unless not explicitly forbidden. in traditional approaches
everything is forbidden unless explicitly speci¯ed. the
later is more suitable if the desired behavior is highly
restricted.
the second limitation is that declarative work°ow
speci¯cations may be less readable if many (interacting)
constraints are added. a well-known problem of rule-
based systems is the cognitive load on the designer if
rules interact in various ways. similar problems may be
encountered if our constraint-based approach is used.
however, these problems are (partly) addressed by our
graphical language and our veri¯cation techniques. un-
like rule-based systems, we provide a powerful graphical
notation which immediately shows possible interactions
between constraints. moreover, our veri¯cation techni-
ques can be used to easily detect con°icting constraints
(cf. section 6.1.1).
an alternative way to tackle some of the problems
associated to the ¯rst two limitations is to use compo-
sition and mixtures of various languages. in [3; 33] we
show that °exibility can be provided as a \service", i.e.,
using service-orientation various languages can be mixed.
for example, we have integrated yawl, worklets, and
declare using such an approach. moreover, compositi-
on can be used to de¯ne a hierarchy of simpler models
(\divide and conquer").
the third limitation is the e±ciency of the current
implementation. the current declare engine has pro-
blems dealing with large speci¯cations. this is due to
the complexity of the model-checking techniques used.
so far we have followed a rather straightforward imple-
mentation strategy and a much faster implementation is
possible, e.g., by a better encoding of the automaton and
by cashing results. moreover, the underlying constraint
language can be restricted to not use the full power of
ltl. by limiting the expressiveness more e±cient imple-12 w.m.p. van der aalst et al.
mentations come into reach. we expect that, based on
focussed research and development e®orts, highly perfor-
ming implementations are possible.
8 related work
many researchers have been trying to provide ways of
avoiding the apparent paradox where, on the one hand,
there is the desire to control the process and to avoid
incorrect or undesirable executions of the processes, and,
on the other hand, users want lots of °exibly and to feel
unconstrained in their actions [2; 5; 6; 8; 11; 12; 16; 22;
38; 40; 48].
see [5; 9; 23; 26; 33; 39; 42; 43; 47] for various taxo-
nomies/classi¯cations of work°ow °exibility. the taxo-
nomy in this paper is based on [43].
it is impossible to provide a complete overview of re-
lated work. therefore, we refer to only some of the most
related papers in this area. in [47] 18 \change patterns"
(e.g. inset/delete process fragments) and 7 \change sup-
port features" (e.g., correctness enforcement and instan-
ce migration) are identi¯ed. the case handling concept is
advocated as a way to avoid restricting users in their ac-
tions [8]. this is achieved by a range of mechanisms that
allow for implicit deviations that are rather harmless. in
[12] completely di®erent techniques are used, but also the
core idea is that implicit paths are generated to allow for
more °exibility. in [9; 11] pockets of °exibility are iden-
ti¯ed that are speci¯ed/selected later in the process, i.e.,
there is some form of \late binding" at run time. a simi-
lar approach was proposed in [42] where the process of
de¯ning a change is integrated in the process itself. many
papers look at problems related to ad-hoc and/or evolu-
tionary change [2; 16; 22; 38; 40; 48]. the problem of the
dynamic change bug was introduced in [22]. in [2] this
problem is addressed by calculating so-called change re-
gions based on the structure of the process. a particular
correctness property is described in [48] and the problem
of instance migration is also investigated in [16]. in the
context of the adept system the problem of work°ow
change has been investigated in detail (including data
analysis) [38; 39; 40]. in [41] a holistic approach is gi-
ven which combines the adept framework for process
change with cased-based reasoning technology to learn
from change. case based reasoning was also proposed
in [32] to reuse past experiences with change. here a
suspension mechanism was proposed that allows the de-
signer to modify suspended parts of the work°ow while
other parts continue to be executed.
another popular stream of research is applying rule-
based or constraint-based process modeling languages
[25; 20; 46] that are able to o®er multiple execution alter-
natives and, therefore, can enhance °exibility by design.
in [25], glance et al. use process grammars for de¯niti-
on of rules involving activities and documents. process
models are executed via execution of rules that triggereach other. the free°ow prototype presented in [20] uses
constraints for building declarative process models. free-
°ow constraints represent dependencies between states
(e.g., inactive, active, disabled, enabled, etc.) of di®e-
rent activities, i.e., an activity can enter a speci¯c state
only if another activity is in a certain state. some ap-
proaches consider process models based on dependencies
between events involving activities [18; 46]. for exam-
ple, the constraint-based language presented in [46] uses
rules involving (1) preconditions that must hold befo-
re an activity can be executed, (2) postconditions that
must hold after an activity is executed and (3) additio-
nal conditions that must hold in general before or af-
ter an activity is executed. a similar idea was presented
in [27] by joeris, who proposes °exible work°ow enact-
ment based on event-condition-action (eca) rules. in
[30], a temporal constraint network is proposed for busi-
ness process execution. the authors use thirteen tem-
poral intervals de¯ned by allen [13] (e.g., before ,meets ,
during ,overlaps ,starts ,¯nishes ,after, etc.) to de¯ne se-
lection constraints (which de¯ne activities in a process)
and scheduling constraints (which de¯ne when these ac-
tivities should be executed). several approaches propo-
se using intertask dependencies for speci¯cation of the
process models. in [14; 15], attie et al. propose using
computational tree logic (ctl) for the speci¯cation of
intertask dependencies amongst di®erent unique events
(e.g., commit dependency, abort dependency, conditional
existence dependency, etc.). dependencies are transfor-
med into automata, which are used by a central schedu-
ler to decide if particular events are accepted, delayed or
rejected. in [36; 37], raposo et al. propose a larger set
of basic interdependencies and propose modeling their
coordination using petri nets.
it is also interesting to mention some commercial
wfmss in this context. historically, inconcert of xerox
and ensemble of filenet were systems among the ¯rst
commercial systems to address the problem of change.
both supported ad-hoc changes in a rather restrictive
setting. several systems have been extended with some
form of late binding. for example, the sta®ware work-
°ow system allows for the dynamic selection of subpro-
cesses at run time. probably the most °exible commer-
cial system is flower of pallas athena [8]; this system
supports a variety of case handling mechanisms to ena-
ble °exibility at run time while avoiding changes of the
model.
this paper is based on the earlier work on declare
and related languages such as condec and decserflow
[6; 33; 34; 45; 35]. in [3] it is explained how declare
can be combined with other (not constraint-based) ap-
proaches.declarative work°ows 13
9 conclusion
in this paper, we advocated the use of declarative lan-
guage as a means to balance between °exibility and sup-
port. the ideas have been implemented which resulted
indeclare , an open source work°ow management sys-
tem.declare provides a wide range of °exibility me-
chanisms: defer (decide to decide later), change (decide
to change model), and deviate (decide to ignore model).
both ad-hoc and evolutionary change are supported and
models can be veri¯ed. as far as we know, there is no
other work°ow management system that supports such
a wide range of °exibility mechanisms. in this paper, we
also elaborated a bit on the link with process mining.
the connection between prom anddeclare enables
innovate means of analysis, e.g., users may get recom-
mendations based on historic information.
literatur
1.w.m.p. van der aalst. the application of petri nets to
work°ow management. the journal of circuits, systems
and computers , 8(1):21{66, 1998.
2.w.m.p. van der aalst. exterminating the dynamic
change bug: a concrete approach to support work-
°ow change. information systems frontiers , 3(3):297{
317, 2001.
3.w.m.p. van der aalst, m. adams, a.h.m. ter hofstede,
m. pesic, and h. schonenberg. flexibility as a service.
bpm center report bpm-08-09, bpmcenter.org, 2008.
4.w.m.p. van der aalst, b.f. van dongen, c.w. g äunther,
r.s. mans, a.k. alves de medeiros, a. rozinat, v. ru-
bin, m. song, h.m.w. verbeek, and a.j.m.m. weijters.
prom 4.0: comprehensive support for real process ana-
lysis. in j. kleijn and a. yakovlev, editors, application
and theory of petri nets and other models of concur-
rency (icatpn 2007) , volume 4546 of lecture notes in
computer science , pages 484{494. springer-verlag, ber-
lin, 2007.
5.w.m.p. van der aalst and s. jablonski. dealing with
work°ow change: identi¯cation of issues and solutions.
international journal of computer systems, science, and
engineering , 15(5):267{276, 2000.
6.w.m.p. van der aalst and m. pesic. decserflow: to-
wards a truly declarative service flow language. in
m. bravetti, m. nunez, and g. zavattaro, editors, in-
ternational conference on web services and formal me-
thods (ws-fm 2006) , volume 4184 of lecture notes in
computer science , pages 1{23. springer-verlag, berlin,
2006.
7.w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters,
b.f. van dongen, a.k. alves de medeiros, m. song, and
h.m.w. verbeek. business process mining: an indus-
trial application. information systems , 32(5):713{732,
2007.
8.w.m.p. van der aalst, m. weske, and d. gr äunbauer.
case handling: a new paradigm for business process
support. data and knowledge engineering , 53(2):129{
162, 2005.
9.m. adams. facilitating dynamic flexibility and excep-
tion handling for work°ows . phd thesis, queensland
university of technology, 2007.
10.m. adams, a.h.m. ter hofstede, w.m.p. van der aalst,
and d. edmond. dynamic, extensible and context-aware exception handling for work°ows. in f. cur-
bera, f. leymann, and m. weske, editors, proceedings
of the otm conference on cooperative information sys-
tems (coopis 2007) , volume 4803 of lecture notes in
computer science , pages 95{112. springer-verlag, ber-
lin, 2007.
11.m. adams, a.h.m. ter hofstede, d. edmond, and
w.m.p. van der aalst. worklets: a service-oriented im-
plementation of dynamic flexibility in work°ows. in
r. meersman and z. tari et al., editors, on the mo-
ve to meaningful internet systems 2006, otm con-
federated international conferences, 14th international
conference on cooperative information systems (coo-
pis 2006) , volume 4275 of lecture notes in computer
science , pages 291{308. springer-verlag, berlin, 2006.
12.a. agostini and g. de michelis. improving flexibili-
ty of work°ow management systems. in w.m.p. van
der aalst, j. desel, and a. oberweis, editors, business
process management: models, techniques, and empiri-
cal studies , volume 1806 of lecture notes in computer
science , pages 218{234. springer-verlag, berlin, 2000.
13.j.f. allen. maintaining knowledge about temporal in-
tervals. communications of the acm , 26(11):832{843,
1983.
14.p.c. attie, m.p. singh, e.a. emerson, a. sheth, and
m. rusinkiewicz. scheduling work°ows by enforcing in-
tertask dependencies. distributed systems engineering
journal , 3(4):222{238, december 1996.
15.p.c. attie, m.p. singh, a. sheth, and m. rusinkiewicz.
specifying and enforcing intertask dependencies. in
19th international conference on very large data ba-
ses (vldb) , pages 134{145, san francisco, ca, usa,
1993. morgan kaufmann publishers inc.
16.f. casati, s. ceri, b. pernici, and g. pozzi. work°ow
evolution. data and knowledge engineering , 24(3):211{
238, 1998.
17.e.m. clarke, o. grumberg, and d.a. peled. model
checking . the mit press, cambridge, massachusetts
and london, uk, 1999.
18.g. decker, a. grosskopf, and a. barros. a graphical no-
tation for modeling complex events in business proces-
ses. in proceedings of the 11th ieee international enter-
prise distributed object computing conference (edoc
2007) , pages 27{36. ieee computer society, 2007.
19.declare, 2008. http://declare.sf.net.
20.p. dourish, j. holmes, a. maclean, p. marqvardsen, and
a. zbyslaw. free°ow: mediating between representati-
on and action in work°ow systems. in proceedings of
the cm conference on computer supported cooperati-
ve work (cscw '96) , pages 190{198. acm press, new
york, ny, usa, 1996.
21.m. dumas, w.m.p. van der aalst, and a.h.m. ter hofs-
tede. process-aware information systems: bridging peo-
ple and software through process technology . wiley &
sons, 2005.
22.c.a. ellis, k. keddara, and g. rozenberg. dynamic
change within work°ow systems. in n. comstock,
c. ellis, r. kling, j. mylopoulos, and s. kaplan, editors,
proceedings of the conference on organizational compu-
ting systems , pages 10 { 21, milpitas, california, august
1995. acm sigois, acm press, new york.
23.d. georgakopoulos, m. hornick, and a. sheth. an over-
view of work°ow management: from process modeling
to work°ow automation infrastructure. distributed and
parallel databases , 3:119{153, 1995.
24.d. giannakopoulou and k. havelund. automata-based
veri¯cation of temporal properties on running pro-
grams. in ase '01: proceedings of the 16th ieee inter-
national conference on automated software engineering ,
page 412, washington, dc, usa, 2001. ieee computer14 w.m.p. van der aalst et al.
society.
25.n. glance, d. pagani, and r. pareschi. generalised pro-
cess structure grammars (gpsg) for flexible represen-
tations of work. in proceedings of the conference on
computer-supported cooperative work (cscw96) , pa-
ges 190{198. acm press, new york, ny, usa, 1996.
26.p. heinl, s. horn, s. jablonski, j. neeb, k. stein, and
m. teschke. a comprehensive approach to flexibility
in work°ow management systems. in g. georgakopou-
los, w. prinz, and a.l. wolf, editors, work activities
coordination and collaboration (wacc'99) , pages 79{
88, san francisco, february 1999. acm press.
27.g. joeris. decentralized and flexible work°ow enact-
ment based on task coordination agents. in b. wangler
and l. bergman, editors, proceedings of the 12th inter-
national conference on advanced information systems
engineering (caise00) , volume 1789 of lecture notes
in computer science , pages 41{62, stockholm, sweden,
september 2000. springer-verlag, berlin.
28.e. lamma, p. mello, m. montali, f. riguzzi, and s. sto-
rari. inducing declarative logic-based models from la-
beled traces. in g. alonso, p. dadam, and m. rosemann,
editors, international conference on business process
management (bpm 2007) , volume 4714 of lecture no-
tes in computer science , pages 344{359. springer-verlag,
berlin, 2007.
29.m. de leoni, w.m.p. van der aalst, and a.h.m. ter hofs-
tede. visual support for work assignment in process-
aware information systems. in m. dumas, m. rei-
chert, and m.c. shan, editors, international conference
on business process management (bpm 2008) , volume
5240 of lecture notes in computer science , pages 67{83.
springer-verlag, berlin, 2008.
30.r. lu, s. sadiq, v. padmanabhan, and g. governatori.
using a temporal constraint network for business pro-
cess execution. in in proceedings of the 17th australasi-
an database conference (adc '06) , pages 157{166, dar-
linghurst, australia, 2006. australian computer society,
inc.
31.l.t. ly, s. rinderle, and p. dadam. semantic correct-
ness in adaptive process management systems. in busi-
ness process management , volume 4102 of lecture no-
tes in computer science , pages 193{208. springer-verlag,
berlin, 2006.
32.m. minor, d. schmalen, koldeho®, and r. bergmann.
structural adaptation of work°ows supported by a sus-
pension mechanism and by case-based reasoning. in
proceedings of wetice 2007 , pages 370{375, 2007.
33.m. pesic. constraint-based work°ow management sys-
tems: shifting control to users . phd thesis, eindhoven
university of technology, may 2008.
34.m. pesic, h. schonenberg, and w.m.p. van der aalst.
declare: full support for loosely-structured proces-
ses. in m. spies and m.b. blake, editors, proceedings
of the eleventh ieee international enterprise distribu-
ted object computing conference (edoc 2007) , pages
287{298. ieee computer society, 2007.
35.m. pesic, m. h. schonenberg, n. sidorova, and w.m.p.
van der aalst. constraint-based work°ow models:
change made easy. in f. curbera, f. leymann, and
m. weske, editors, proceedings of the otm conference
on cooperative information systems (coopis 2007) , vo-
lume 4803 of lecture notes in computer science , pages
77{94. springer-verlag, berlin, 2007.
36.a.b. raposo and h. fuks. de¯ning task interdepen-
dencies and coordination mechanisms for collaborati-
ve systems. in m. blay-fornarino, a.m. pinna-dery,
k. schmidt, and p. zaratµ e, editors, cooperative systems
design , volume 74 of frontiers in arti¯cial intelligence
and applications , pages 88{103, amsterdam, the net-herlands, 2002. ios press.
37.a.b. raposo, l.p. magalhaes, i.l.m. ricarte, and h.
fuks. coordination of collaborative activities: a fra-
mework for the de¯nition of tasks interdependencies. in
proceedings of the 7th international workshop on group-
ware (criwg) , pages 170{179. ieee computer society,
2001.
38.m. reichert and p. dadam. adept°ex: supporting dy-
namic changes of work°ow without loosing control.
journal of intelligent information systems , 10(2):93{
129, 1998.
39.s. rinderle, m. reichert, and p. dadam. evaluation of
correctness criteria for dynamic work°ow changes. in
w.m.p. van der aalst, a.h.m. ter hofstede, and m. wes-
ke, editors, international conference on business process
management (bpm 2003) , volume 2678 of lecture no-
tes in computer science , pages 41{57. springer-verlag,
berlin, 2003.
40.s. rinderle, m. reichert, and p. dadam. correctness
criteria for dynamic changes in work°ow systems: a
survey. data and knowledge engineering , 50(1):9{34,
2004.
41.s. rinderle, b. weber, m. reichert, and w. wild. inte-
grating process learning and process evolution: a se-
mantics based approach. in w.m.p. van der aalst,
a.h.m. ter hofstede, and m. weske, editors, inter-
national conference on business process management
(bpm 2005) , volume 2678 of lecture notes in computer
science , pages 252{267. springer-verlag, berlin, 2005.
42.s. sadiq, w. sadiq, and m. orlowska. pockets of fle-
xibility in work°ow speci¯cation. in proceedings of the
20th international conference on conceptual modeling
(er 2001) , volume 2224 of lecture notes in computer
science , pages 513{526. springer-verlag, berlin, 2001.
43.h. schonenberg, r. mans, n. russell, n. mulyar, and
w.m.p. van der aalst. process flexibility: a survey of
contemporary approaches. in j. dietz, a. albani, and
j. barjis, editors, advances in enterprise engineering i ,
volume 10 of lecture notes in business information pro-
cessing , pages 16{30. springer-verlag, berlin, 2008.
44.h. schonenberg, b. weber, b.f. van dongen, and
w.m.p. van der aalst. supporting flexible proces-
ses through recommendations based on history. in
m. dumas, m. reichert, and m.c. shan, editors, in-
ternational conference on business process management
(bpm 2008) , volume 5240 of lecture notes in computer
science , pages 51{66. springer-verlag, berlin, 2008.
45.m.h. schonenberg, r.s. mans, n.c. russell, n.a. mu-
lyar, and w.m.p. van der aalst. towards a taxonomy
of process flexibility (extended version). bpm center
report bpm-07-11, bpmcenter.org, 2007.
46.j. wainer and f. de lima bezerra. constraint-based
°exible work°ows. in proceedings of the 9th internatio-
nal workshop on groupware: design, implementation,
and use (criwg 2003) , volume 2806, pages 151 { 158.
springer-verlag, berlin, 2003.
47.b. weber, m. reichert, and s. rinderle-ma. change pat-
terns and change support features: enhancing flexibi-
lity in process-aware information systems. data and
knowledge engineering , 66(3):438{466, 2008.
48.m. weske. formal foundation and conceptual design of
dynamic adaptations in a work°ow management sys-
tem. in r. sprague, editor, proceedings of the thirty-
fourth annual hawaii international conference on sys-
tem science (hicss-34) . ieee computer society press,
los alamitos, california, 2001.declarative work°ows 15
wil van der aalst is a full professor of information
systems at the technische universiteit eindhoven and
an adjunct professor at queensland university of tech-
nology. his research interests include work°ow manage-
ment, process mining, petri nets, business process ma-
nagement, process modeling, and process analysis. ma-
ny of his papers are highly cited (he has an h-index of
55 according to google scholar) and his ideas have in-
°uenced researchers, software developers, and standardi-
zation committees working on process support. for more
information about his work visit: www.work°owpatterns.com,
www.work°owcourse.com, www.processmining.org, www.yawl-
system.com, www.wvdaalst.com.
maja pesic studied information systems at universi-
ty of belgrade, serbia. she received a ph.d. degree in
2008 at eindhoven university of technology, the net-
herlands. her research in the ¯eld of work°ow manage-
ment systems aims at increasing the °exibility of these
systems. currently, she is working as a researcher (post-
doc) at the department of mathematics and computer
science at the eindhoven university of technology, the
netherlands.
helen schonenberg is currently working as ph.d. stu-
dent in the group of professor wil van der aalst at eind-
hoven university of technology, the netherlands. her
research focus is on supporting the execution of °exible
processes by means of recommendations and predictions,
using process mining techniques. schonenberg received
her master of science in computer science (ingenieur)
in 2006 from the university of twente, the netherlands.