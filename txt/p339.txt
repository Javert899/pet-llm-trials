decserflow: towards a truly declarative
service flow language
w.m.p. van der aalst and m. pesic
department of information systems, eindhoven university of technology, p.o.box
513, nl-5600 mb, eindhoven, the netherlands.
w.m.p.v.d.aalst@tm.tue.nl,m.pesic@tm.tue.nl
abstract. the need for process support in the context of web services
has triggered the development of many languages, systems, and stan-
dards. industry has been developing software solutions and proposing
standards such as bpel, while researchers have been advocating the
use of formal methods such as petri nets and ¼-calculus. the languages
developed for service °ows , i.e., process speci¯cation languages for web
services, have adopted many concepts from classical work°ow manage-
ment systems. as a result, these languages are rather procedural and
this does not ¯t well with the autonomous nature of services. therefore,
we propose decserflow as a declarative service flow language . dec-
serflow can be used to specify, enact, and monitor service °ows. the
language is extendible (i.e., constructs can be added without changing
the engine or semantical basis) and can be used to enforce or to check the
conformance of service °ows. although the language has an appealing
graphical representation, it is grounded in temporal logic.
key words : service °ows, web services, work°ow management, °exibility, temporal
logic.
1 introduction
the business process execution language for web services (bpel4ws, or
bpel for short) has become the de-facto standard for implementing processes
based on web services [7]. systems such as oracle bpel process manager,
ibm websphere application server enterprise, ibm websphere studio appli-
cation developer integration edition, and microsoft biztalk server 2004 support
bpel, thus illustrating the practical relevance of this language. although in-
tended as a language for connecting web services, its application is not limited
to cross-organizational processes. it is expected that in the near future a wide
variety of process-aware information systems [8] will be realized using bpel.
whilst being a powerful language, bpel is of a procedural nature and not very
di®erent from classical work°ow languages e.g., the languages used by systems
such as sta®ware, cosa, sap work°ow, and ibm websphere mq work°ow
(formerly know as flowmark). also other languages proposed in the context ofweb services are of a procedural nature, e.g., the web services choreography
description language (ws-cdl) [16]. in this paper, we will not discuss these
languages in detail. the interested reader is referred to [2, 3, 20] for a critical
review of languages like bpel. instead, we will demonstrate that it is possible
to use a more declarative style of speci¯cation by introducing decserflow : a
declarative service flow language .
to explain the di®erence between a procedural style and a declarative style
of modeling, we use a simple example. suppose that there are two activities
aandb. both canbe executed multiple times but they exclude each other,
i.e., after the ¯rst occurrence of ait is not allowed to do banymore and after
the ¯rst occurrence of bit is not allowed to do a. the following execution
sequences are possible based on this verbal description: [ ](the empty execution
sequence), [a],[b],[a,a] ,[b,b] , etc. in a procedural language it is di±cult to
specify the above process without implicitly introducing additional assumptions
and constraints. in a procedural language one typically needs to make a choice
with respect to whether no activities are to be executed, only aactivities are to
be executed, or only bactivities are to be executed. moreover, the number of
times aorbneeds to be executed also has to be decided. this means that one
or more decision activities need to be executed before the execution of \real"
activities can start. (note that this is related to the deferred choice pattern
described in [4].) the introduction of these decision activities typically leads
to an over-speci¯cation of the process. designers may be tempted to make this
decision before the actual execution of the ¯rst aorb. this triggers the following
two questions: (1) \how is this decision made?" and (2) \when is this decision
made?". the designer may even remove the choice altogether and simply state
that one can only do aactivities. using a more declarative style can avoid this
over-speci¯cation. for example, in linear temporal logic (ltl) [11{13] one can
write:(3a^3b). this means that it cannot be the case that eventually ais
executed and that eventually bis executed. this shows that a very compact ltl
expression ( :(3a^3b)) can describe exactly what is needed without forcing
the designer to specify more than strictly needed. unfortunately, languages like
ltl are di±cult to use for non-experts. therefore, we have developed a graphical
language (decserflow) that allows for the easy speci¯cation of processes in a
declarative manner. decserflow is mapped onto ltl. the innovative aspects of
our approach based on decserflow are:
{decserflow allows for a declarative style of modeling which is highly relevant
in the context of service °ows (unlike languages like bpel).
{through the graphical representation of decserflow this language is easy
to use and we avoid the problems of textual languages like ltl.
{we use ltl not only for the veri¯cation of model properties: we also use
the ltl formulas generated by decserflow to dynamically monitor services
and to realize an enactment engine .
{decserflow is an extendible language (i.e., we supply an editor to extend the
language with user-de¯ned graphical constructs without the need to modify
any part of the system).{decserflow can be used to specify two types of constraints: hard constraints
andsoftconstraints. hard constraints are enforced by the engine while soft
constraints are only used to warn before the violation takes place and to
monitor observed violations.
ac
b
ddecserflow
model containing
four activities
hard constraint
(response)
hard constraint
(not co-existence)
soft constraint
(responded
existence)[](a -> <>c)
not(<>a and  <>b)
<>d ->  <>bhard ltl
constraints
...
...soft ltl
constraintsenactment
engine
monitoring
toolweb
services/
soap
messagesoffer
enable
disable
start
complete
warn
register
design-time mapping run-timeinstance data
and states
fig. 1. overview of the role played by decserflow in supporting services °ows.
figure 1 provides an overview of the way we envision decserflow to be
used. at design-time, a graphical model is made using the decserflow notation.
(note that at design-time users can also add new modeling elements - types of
constraints.) the left-hand side of figure 1 shows a process composed of four
activities, a,b,c, and d. moreover, three constraints are shown. the connec-
tion between aandcmeans that any occurrence of ashould eventually be
followed by at least one occurrence of c(i.e.,2(a!3c) in ltl terms). the
connection between aandbmeans that it cannot be the case that eventually a
is executed and that eventually bis executed. this is the constraint described
before, i.e., :(3a^3b) in ltl terms. the last constraint connecting dand
bis a soft constraint. this constraint states that any occurrence of dimplies
also the occurrence of b(before or after the occurrence of d), e.g., [b,d,d,d,d] ,
[d,d,d,b] , and [b,b,b] are valid executions. the ltl formulation of this con-
straint is 3d!3b.
as figure 1 shows, it is possible to automatically map the graphical model
onto ltl formulas. these formulas can be used by the enactment engine to
control the service °ow, e.g., on the basis of hard constraints the engine can
allow or prohibit certain activities and on the basis of soft constraints warnings
can be issued. the soft constraints can also be used by the monitoring tool to
detect and analyze violations.currently, we have implemented a graphical editor and the mapping of the
editor to ltl. this editor supports user-de¯ned notations as described before.
we are currently investigating di®erent ways to enact ltl formulas and in this
paper we described our current e®orts. although we do not elaborate this this in
this paper, our implementation will also incorporate data as is show in figure 1.
data is used for routing purposes by making constraints data dependent, i.e., a
constraint only applies if its guard evaluates to true. moreover, in the context of
the prom (process mining) framework [6, 18] we have developed an ltl checker
[1] to compare actual behavior with speci¯ed behavior. the actual behavior can
be recorded by a dedicated process engine. however, it can also be obtained by
monitoring soap messages as described in [3].
the approach described in figure 1 is not limited to service °ows. it can
be applied in any context where autonomous entities are executing activities.
these autonomous entities can be other organizations but also people or groups
of people. this is the reason that decserflow has a \sister language" named
condec which aims at supporting teamwork and work°ow °exibility [17]. both
languages/applications share the same concepts and tools.
the remainder of this paper is organized as follows. section 2 introduces
the decserflow language. then, a non-trivial example is given in section 3.
section 4 discusses di®erent ways to construct an enactment (and monitoring)
engine based on decserflow. finally, section 5 concludes the paper by discussing
di®erent research directions.
2 decserflow: a declarative service flow language
languages such as linear temporal logic (ltl) [11{13] allow for the a more
declarative style of modeling. these languages include temporal operators such
as next-time ( °f), eventually ( 3f), always ( 2f), and until ( ftg). however,
such languages are di±cult to read. therefore, we de¯ne an extendible graphical
syntax for some typical constraints encountered in service °ows. the combina-
tion of this graphical language and the mapping of this graphical language to
ltl forms the declarative service flow (decserflow) language . we propose
decserflow for the speci¯cation of a single service, simple service compositions,
and more complex choreographies .
developing a model in decserflow starts with creating activities. the no-
tion of an activity is like in any other work°ow-like language, i.e., an activity
is atomic and corresponds to a logical unit of work. however, the nature of the
relations between activities in decserflow can be quite di®erent than in tradi-
tional procedural work°ow languages (like petri nets and bpel). for example,
places between activities in a petri net describe causal dependencies and can
be used to specify sequential, parallel, alternative, and iterative routing. using
such mechanisms it is both possible and necessary to strictly de¯ne how the
°ow will be executed. we refer to relations between activities in decserflow as
constraints . each of the constraints represents a policy (or a business rule). at
any point in time during the execution of a service, each constraint evaluates totrueorfalse. this value can change during the execution. if a constraint has the
value true, the referring policy is ful¯lled. if a constraint has the value false, the
policy is violated. the execution of a service is correct (according to the dec-
serflow model) at some point in time if all constraints (from the decserflow
model) evaluate to true. similarly, a service has completed correctly if at the end
of the execution all constraints evaluate to true. the goal of the execution of
any decserflow model is not to keep the values of all constraints true at all
times during the execution. a constraint which has the value false during the
execution is not considered an error. consider for example the ltl expression
2(a¡!3b) where aandbare activities, i.e., each execution of ais eventually
followed by b. initially (before any activity is executed), this ltl expression
evaluates to true. after executing athe ltl expression evaluates to false and
this value remains false until bis executed. this illustrates that a constraint
may be temporarily violated. however, the goal is to end the service execution
in a state where all constraints evaluate to true.
to create constraints in decserflow we use constraint templates . each con-
straint template consists of a formula written in ltl and a graphical represen-
tation of the formula. an example is the \response constraint", which is denoted
by a special arc connecting two activities aandb. the semantics of such an arc
connecting aandbare given by the ltl expression 2(a¡!3b), i.e., any
execution of ais eventually followed by (at least one) execution of b. we have
developed a starting set of constraint templates and we will use these templates
to create a decserflow model. this set of templates is inspired by a collection
of speci¯cation patterns for model checking and other ¯nite-state veri¯cation
tools [9]. constraint templates de¯ne various types of dependencies between ac-
tivities at an abstract level. once de¯ned, a template can be reused to specify
constraints between activities in various decserflow models. it is fairly easy
to change, remove and add templates, which makes decserflow an \open lan-
guage" that can evolve and be extended according to the demands from di®erent
domains.1in the initial set of constraint templates we distinguish three groups:
(1) \existence", (2) \relation", and (3) \negation" templates. because a tem-
plate assigns a graphical representation to an ltl formula, we will refer to such
a template as a formula.
before giving an overview of the initial set of formulas and their notation,
we give a small example explaining the basic idea. figure 2 shows a decserflow
model consisting of four activities: a,b,c, and d. each activity is tagged with a
constraint describing the number of times the activity should be executed, these
are the so-called \existence formulas". the arc between aandbis an example
of a \relation formula" and corresponds to the ltl expression discussed before:
2(a¡!3b). the connection between candddenotes another \relation
formula": 3d¡!3c, i.e., if dis executed at least once, cis also executed
at least once. the connection between bandcdenotes a \negation formula"
1note that we have developed a graphical editor for decserflow that supports the
creation of user de¯ned templates, i.e., the user can de¯ne the graphical representa-
tion of a generic constraint and give its corresponding semantics in terms of ltl.a b
c [](a -> <> b),
i.e., every a is
eventually
followed by b
d1..*2 0..*
0..*b is executed
twice
<> d, i.e., d is
executed at least
once<d> -> <>c, i.e.,
if d is executed
at least once, c
is also executed
at least once.if a is executed
at least once, c
is never
executed and
vice versa.a can be
executed an
arbitrary number
of timesfig. 2. a decserflow model showing some example notations.
(the ltl expression is not show here). note that it is not easy to provide a clas-
sical procedural model (e.g., a petri net) that allows for all behaviour modeled
figure 2.
existence formulas. figure 3 shows the so-called \existence formulas". these
formulas de¯ne the possible number of executions (cardinality) of an activity.
for example, the ¯rst formula is called existence . the name and the formula
heading are shown in the ¯rst column. from this, we can see that it takes one
parameter ( a), which is the name of an activity. the body of the formula is
written in ltl and can be seen in the second column. in this case the ltl
expression 3(activity == a) ensures that the activity given as the parameter
awill execute at least once. note that we write 3(activity == a) rather than
3(a). the reason is that in a state we also want to access other properties, i.e.,
not just the activity name but also information on data, time, and resources.
therefore, we need to use a slightly more verbose notation ( activity == a ). the
diagram in the third column is the graphical representation of the formula, which
is assigned to the template. parameter ais an activity and it is represented
as a square with the name of the activity. the constraint is represented by a
cardinality annotation above the square. in this case the cardinality is at least
one, which is represented by 1..*. the ¯rst group of existence formulas are of
the cardinality \n or more", denoted by n..*. next, the formula absence ensures
that the activity should never execute in the service. the group of formulas with
names absence nuses negations of existence nto specify that an activity can
be executed at most n-1times. the last group of existence formulas de¯nes an
exact number of executions of an activity. for example, if a constraint is de¯ned
based on the formula exactly 2, the referring activity has to be executed exactly
two times in the service.
relation formulas. figure 4 shows the so-called \relations formulas". while an
\existence formula" describes the cardinality of one activity, a \relation formula"
de¯nes relation(s) (dependencies) between two activities. all relation formulasi) existence formulas
2. absence
formula absence_a( a: activity )[]( activity != a );1. existence
formula existence( a: activity )<>(activity == a);
1.a. existence_2
formula existence2( a: activity )<>( ( activity == a /\ _o( existence(a) ) ) );
0
a2..*
a
1.b. existence_3
formula existence3( a: activity )<>( ( activity == a /\ _o( existence2(a) ) ) );3..*
a
n..*
a1.c. existence_n
formula existencen( a: activity )<>( ( activity == a /\ _o( existence_n-1(a) ) ) );
3.a. absence_2
formula absence2( a: activity )!( existence2(a) );
3.b. absence_3
formula absence3( a: activity )!( existence3(a) );0..2
a
0..n
a3.c. absence_n
formula absencen( a: activity )!( existencen+1(a) );0..1
a
2
a
n
a1
a4.a. exactly_1
formula exactly1( a: activity )( existence(a) /\ []( ( activity == a -> _o( absence(a) ) ) ) );
( existence(a) /\ ( activity != a _u( activity == a /\ _o( exactly1(a) ) ) ) );
( existence(a) /\ ( activity != a _u( activity == a /\ _o( exactlyn-1(a) ) ) ) );4.b. exactly_2
formula exactly2( a: activity )
4.c. exactly_n
formula exactlyn( a: activity )n..*
a
0..n
a
n
aa1..*
fig. 3. notations for the \existence formulas".ii) relation between events formulas 
3. response 
formula a_response_b( a: activity, b: activity ) []( ( activity == a -> existence(b) ) );
4. precedence 
formula a_precedence_b( a: activity, b: activity )( existence_a(b) -> ( !( activity == b ) _u activit y == a ) );
5. succession 
formula a_succession_b( a: activity, b: activity )( a_response_b(a,b) /\ a_precedence_b(a,b) );
9. chain response 
formula chain_a_response_b( a: activity, b: activit y )a_response_b(a,b) /\ []( ( activity == a -> _o( act ivity == b ) ) );
10. chain precedence 
formula chain_a_precedence_b( a: activity, b: activ ity ) ( a_precedence_b(a,b) /\ []( ( _o( activity == b )  -> activity == a ) ) );
11. chain succession 
formula chain_a_succession_b( a: activity, b: activ ity )( chain_a_response_b(a,b) /\ chain_a_precedence_b(a ,b) );1. responded existence 
formula existence_a_response_b( a: activity, b: act ivity )( existence_a(a) -> existencea(b) );
2. co-existence 
formula co_existence_a_and_b( a: activity, b: activ ity )( existence(a) <-> existence(b) );
6. alternate response 
formula a_alternate_response_b( a: activity, b: act ivity )( a_response_b(a,b) /\ b_always_between_a(a,b)*  );
7. alternate precedence 
formula a_alternate_precedence_b( a: activity, b: a ctivity )( a_precedence_b(a,b) /\ b_always_between_a(b,a)*  );
ababab
ab
ab
abab
ab
8. alternate succession 
formula a_alternate_succession_b( a: activity, b: a ctivity ) ( a_alternate_precedence_b(a,b) /\ a_alternate_res ponse_b(a,b) );ab
ab
ab
* subformula b_always_between_a( a: activity, b: ac tivity ) []( ( activity == a -> _o( a_precedence_b(b ,a) ) ) );fig. 4. notations for the \relation formulas".have two activities as parameters and two activities in the graphical representa-
tion. the line between the two activities in the graphical representation should
be unique for the formula, and re°ect the semantics of the relation. the re-
sponded existence formula speci¯es that if activity ais executed, activity balso
has to be executed either before or after the activity a. according to the co-
existence formula, if one of the activities aorbis executed, the other one has
to be executed also.
while the previous formulas do not consider the order of activities, formulas
response ,precedence andsuccession do consider the ordering of activities. for-
mula response requires that every time activity aexecutes, activity bhas to be
executed after it. note that this is a very relaxed relation of response, because b
does not have to execute immediately after a, and another acan be executed
between the ¯rst aand the subsequent b. for example, the execution sequence
[b,a,a,a,c,b] satis¯es the formula response . the formula precedence requires
that activity bis preceded by activity a. i.e., it speci¯es that if activity bwas
executed, it could not have been executed until the activity awas executed.
according to this formula, the execution sequence [a,c,b,b,a] is correct. the
combination of the response andprecedence formulas de¯nes a bi-directional ex-
ecution order of two activities and is called succession . in this formula, both
response andprecedence relations have to hold between the activities aandb.
thus, this formula speci¯es that every activity ahas to be followed by an ac-
tivity band there has to be an activity abefore every activity b. for example,
the execution sequence [a,c,a,b,b] satis¯es the succession formula.
formulas alternate response ,alternate precedence andalternate succession
strengthen the response ,precedence andsuccession formulas, respectively. if ac-
tivity bisalternate response of the activity a, then after the execution of an
activity aactivity bhas to be executed and between the execution of each two
activities aat least one activity bhas to be executed. in other words, after
activity athere must be an activity b, and before that activity bthere can not
be another activity a. the execution sequence [b,a,c,b,a,b] satis¯es the al-
ternate response . similarly, in the alternate precedence every instance of activity
bhas to be preceded by an instance of activity aand the next instance of ac-
tivity bcan not be executed before the next instance of activity ais executed.
according to the alternate precedence , the execution sequence [a,c,b,a,b,a]
is correct. the alternate succession is a combination of the alternate response
andalternate precedence and the sequence [a,c,b,a,b,a,b] would satisfy this
formula.
even more strict ordering relations formulas are chain response ,chain prece-
dence andchain succession , which require that the executions of the two activ-
ities ( aandb) are next to each other. in the chain response the next activity
after the activity ahas to be activity band the execution [b,a,b,c,a,b] would
be correct. the chain precedence formula requires that the activity ais the ¯rst
preceding activity before band, hence, the sequence [a,b,c,a,b,a] is correct.
since the chain succession formula is the combination of the chain response and
chain precedence formulas, it requires that activities aandbare always exe-cuted next to each other. the execution sequence [a,b,c,a,b,a,b] is correct
with respect to this formula.
negation formulas. figure 5 shows the \negation formulas", which are the
negated versions of the \relation formulas". the ¯rst two formulas negate the
responded existence andco-existence formulas. the responded absence formula
speci¯es that if activity ais executed activity bmust never be executed (not
before nor after the activity a). the not co-existence formula applies responded
absence from atoband from btoa. however, if we look at the responded
absence formula we can see that if existence of aimplies the absence of band
we ¯rst execute activity b, it will not be possible to execute activity aanymore
because the formula will become permanently incorrect. this means that the for-
mula responded absence is symmetric with respect to the input, i.e., we can swap
the roles of aandbwithout changing the outcome. therefore formula responded
absence will be skipped and we will use only the not co-existence formula. the
graphical representation is a modi¯ed representation of the co-existence formula
with the negation symbol in the middle of the line. an example of a correct exe-
cution sequence for the formula not co-existence is[a,c,a,a] , while the sequence
[a,c,a,a,b] would not be correct.
thenegation response formula speci¯es that after the execution of activity
a, activity bcan not be executed. according to the formula negation precedence
activity bcan not be preceded by activity a. these two formulas have the same
e®ect because if it is not possible to have activity bexecuted after activity
a, then it is not possible to have activity aexecuted before activity b. since
the formula negation succession combines these two formulas, it also has the
same e®ect and we will use only the negation succession formula. the graphical
representation of this formula is a modi¯ed representation of the succession
formula with a negation symbol in the middle of the line. the execution sequence
[b,b,c,a,c,a,a] is an example of a correct sequence, while [a,c,b] would be
an incorrect execution.
formulas negation alternate response ,negation alternate precedence andnega-
tion alternate succession are easy to understand. the formula negation alternate
response speci¯es that the activity bcan not be executed between the two sub-
sequent executions of the activity a. according to this formula the execution
sequence [b,a,c,a,b] is correct. in the case of the negation alternate prece-
dence activity acan not be executed between two subsequent executions of the
activity b. the execution sequence [a,b,c,b,a] is correct for negation alternate
precedence . the formula negation alternate succession requires both negation al-
ternate response andnegation alternate precedence to be satis¯ed. an example
of a correct execution sequence for the negation alternate succession formula
is[b,c,b,a,c,a] . graphical representations of these three formulas are similar
to the representations of alternate response ,alternate precedence andalternate
succession with the negation symbol in the middle of the line.
the last three formulas are negations of formulas chain response ,chain prece-
dence andchain succession . according to the formula negation chain response ,
activity bcan not be executed directly after the activity a. formula negationiii) negation relation between events formulas 
13.c. negation succession 
formula nota_succession_notb( a: activity, b: activ ity )( a_response_notb(a,b) /\ 
nota_precedence_b(a,b) );12.b. not co_existence 
formula existence_a_response_notb( a: activity, b: activity )( existence_a_response_notb(a,b) /\ 
existence_a_response_notb(b,a) ); ab
ab
17.c. negation chain succession 
formula chain_a_notsuccession_b( a: activity, b: ac tivity )( chain_a_response_notb(a,b) /\ 
chain_nota_precedence_b(a,b) ); ab12.a. responded absence 
formula existence_a_response_notb( a: activity, b: activity ) ( existence_a(a) -> absence(b) );
13.a. negation response 
formula a_response_notb( a: activity, b: activity )[]( ( activity == a -> absence(b) ) );
13.b. negation precedence 
formula nota_precedence_b( a: activity, b: activity  ) []( ( existence(b) -> activity != a ) );ab
abab
ab
ab
14. negation alternate reponse 
formula a_not_alternate_response_b( a: activity, b: activity )b_never_between_a(a,b)**;
15. negation alternate precedence 
formula 
a_not_alternate_precedence_b( a: activity, b: activi ty )b_never_between_a(b,a)**;
16. negation  alternate succession 
a_not_alternate_succession_b( a: activity, b: activit y )( a_not_alternate_precedence_b(a,b) /\ 
a_not_alternate_response_b(a,b) );ab
ab
ab
17.a.. negation chain response 
formula chain_a_response_notb( a: activity, b: acti vity ) []( ( activity == a -> _o( activity != b ) ) );  
17.b. negation chain precedence 
formula chain_nota_precedence_b( a: activity, b: act ivity )[]( ( _o( activity == b ) -> activity != a ) );ab
ab ab
** subformula b_never_between_a( a: activity, b: act ivity ) []( ( activity == a -> _o( ( <>( activity = = a ) -> ( activity != b _u activity == a ) ) ) ) ) ;
fig. 5. notations for the \negations formulas".chain precedence speci¯es that activity bcan never be directly preceded by
activity a. these two formulas have the same e®ect because they forbid the
activities aandbto be executed directly next to each other. since the formula
negation chain succession requires both negation chain response andnegation
chain precedence to be executed, these three formulas all have the same e®ect and
we will use only negation chain succession . the graphical representation of this
formula is a modi¯ed version of the representation of the chain succession for-
mula with the negation symbol in the middle of the line. the execution sequence
[b,a,c,b,a] is correct according to the negation chain succession formula, while
the sequence [b,a,b,a] would not be correct.
figures 4 and 5 only show binary relationships. however, these can easily
be extended to deal with more activities. consider for example the response
relationship, i.e., 2(a¡!3b). we will allow multiple arcs to start from the
same dot, e.g., an arc to b,c, and d. the meaning is 2(a¡!3(b_c_d)),
i.e., every occurrence of ais eventually followed by an occurrence of b,c, ord.
moreover, as indicated before, the set of formulas is not ¯xed and we also aim
at supporting data. in fact, we have de¯ned more formulas than the ones shown
in ¯gures 3, 4, and 5. for example, the mutual substitution relation formula
speci¯es that at least one of two activities should occur (i.e., 3(a_b)).
after this introduction to decserflow we specify a concrete example. the
interested reader is referred to a technical report with more information about
decserflow [5]. moreover, for more information on condec, the sister language
of decserflow aiming a teamwork and work°ow °exibility, we refer to [17].
3 modelling services with decserflow: the acme
travel example
in this section we use the \acme travel company case" to illustrate decserflow.
the description of the business process of the acme travel service is adopted
from [19] is as follows:
1.acme travel receives an itinerary from karla, the customer.
2.after checking the itinerary for errors, the process determines which
reservations to make, sending simultaneous requests to the appropri-
ate airline and hotel agencies to make the appropriate reservations2.
3.if any of the reservation activities fails, the itinerary is cancelled by
performing the \compensate" activity and karla is noti¯ed of the
problem.
4.acme travel waits for con¯rmation of the two reservation requests.
5.upon receipt of con¯rmation, acme travel noti¯es karla of the suc-
cessful completion of the process and sends her the reservation con-
¯rmation numbers and the ¯nal itinerary details.
2the original acme travel service business process consists of three possible book-
ings: airline, hotel and vehicle. however, for the simplicity, we consider only the
possibilities to book airline and hotel.6.once karla is noti¯ed of either the success or failure of her requested
itinerary, she may submit another travel request.
fig. 6. decserflow - acme travel company
figure 6 shows the decserflow model of the acme business process. we ¯rst
de¯ne the possible activities within the service to model the business process of
acme. in this case, we de¯ne eleven activities:
receive - a request for booking is received from the customer;
airline - a request for booking is sent to an airline reservation service;
hotel - a request for booking is sent to a hotel reservation service;
booked hotel - a hotel reservation service sends a positive response for a re-
quested booking, i.e., the hotel can be booked;
failed hotel - a hotel reservation service sends a negative response for a re-
quested booking, i.e., the hotel cannot be booked;
booked airline - an airline reservation service sends a positive response for a
requested booking, i.e., the airline can be booked;failed airline - an airline reservation service sends a negative response for a
requested booking, i.e., the airline cannot be booked;
compensation - the whole booking has failed;
notify failure - notify the customer that the booking has failed;
credit card - register and charge a successful booking; and
notify booked - notify the customer that the booking was successful.
in principle, a decserflow model consisting only of a set of activities is a correct
model. if a decserflow model consisting only of eleven activities would be im-
plemented in the acme service, it would be possible that the service executes any
of the eleven activities, an arbitrary number of times, in an arbitrary order. it
would also be possible not to execute any activity. to prevent such an \chaotic"
behavior of the service, we can add constraints to the service process model. a
constraint in service represents a rule that the service execution has to ful¯ll.
the acme decserflow model shown in figure 6 uses two of the three types of
constraint formulas mentioned before: \existence" and \relation" constraints.
in section 2, we presented several standard \existence" constraints. these
constraints de¯ne the possible number of executions of an activity in a service.
we refer to the possible number of executions of an activity in a service as the
cardinality of that activity. without any constraints in the service model, an
activity can be executed an arbitrary number of times - the activity has the
cardinality of (0..*). the \existence" constraints are graphically represented as
cardinalities above activities (cf. figure 6). activity receive has the constraint
exactly 1(cf. section 2), and speci¯es that this activity will be executed exactly
once in one instance (per one customer request) of the acme service. because the
booking request can succeed or fail, but not both, activities compensation ,notify
failure ,credit card , and notify booking have the constraint \absence 2", which
speci¯es that each of these activities will be executed at most once. we do not
de¯ne any \existence" constraints on activities hotel andairline and thus allow
these two activities to execute an arbitrary number of times in the acme service.
if the customer does not wish to book a hotel or an airline, the acme service will
not execute the corresponding activity. in case that a booking of a hotel or an
airline is requested, the booking request might be sent multiple times until the
booking succeeds or fails. a booking of a hotel or an airline will be followed with
a positive activity (i.e., booked hotel orbooked airline ) or a negative activity (i.e.,
failed hotel orfailed airline ). therefore, activities booked hotel ,booked airline ,
failed hotel andfailed airline also can be executed an arbitrary number of times
in the service.
the acme decserflow model as de¯ned so far - only consisting of a set of
activities and \existence" constraints - is a correct model. if this model would
be implemented in the acme service, the service could execute its activities in
an arbitrary order, complying with the execution cardinality of each activity, as
de¯ned with \existence" constraints.
to de¯ne relations between activities in the service (and implicitly their
possible order) we use the so-called \relation" constraints as de¯ned in section 2.
unlike \existence" constraints that were de¯ned for single activities (unary),\relation" constraints de¯ne relations between two or more activities (e.g., a
binary relationship).
after receiving the booking request from the customer, the request is checked.
the customer can request to book a hotel and an airline for a destination, or
only one of these. the constraint response from the activity receive is a so-called
branched constraint. it has two branches: one to the activity hotel and the other
to the activity airline . this branched response speci¯es that after the activity
receive is executed, eventually there will be at least one execution of one of the
activities hotel andairline . it is still possible that both of the activities hotel
andairline execute an arbitrary number of times, as long as at least one of them
executes after the activity receive . however, since it would not be desirable to
execute any of the activities hotel andairline before the activity receive , we
add two precedence constraints: (1) the precedence constraint between activities
receive andhotel speci¯es that the activity hotel cannot execute before the activ-
ityreceive executes, and (2) the precedence constraint between activities receive
andairline speci¯es that the activity airline cannot execute before the activity
receive executes. the branched constraint response and the two precedence con-
straints between activities receive ,hotel andairline specify that activities hotel
andairline will not execute until the activity receive executes, and that after
the activity receive executes, at least one of the activities hotel anairline will
execute. activities hotel andairline can an arbitrary number of times and in an
arbitrary order.
activities booked hotel andfailed hotel handle the possible responses of a
hotel reservation service on the request of acme service to book a hotel (which is
sent when the activity hotel is executed). with the branched response constraint
from the activity hotel we specify that after every execution of this activity, at
least one of the activities booked hotel andfailed hotel will execute. note that,
due to errors, this constraint allows for some requests for the hotel reservation to
remain without response. logically, with the two precedence constraints between
the activity hotel and activities booked hotel andfailed hotel we prevent that
either of the activities booked hotel andfailed hotel execute before the activity
hotel executes. this is necessary, since the response from the hotel reservation
service can not arrive before a reservation request is sent. the same constraints
are added between activities airline ,booked airline andfailed airline , because
the communication of the acme service with the airline service is the same like
the communication with the hotel reservation service.
only after receiving at least one of the two negative responses (activities
failed hotel andfailed airline ), the acme service can cancel the whole booking
by executing the activity compensation . this is speci¯ed by the branched prece-
dence constraint between the activity compensation and activities failed hotel
andfailed booking . after the compensation activity is executed, activities hotel
andairline can not execute again in the service, because the whole booking is
cancelled. the two not-response constraints between the activity compensation
and activities hotel andairline , make sure that after the activity compensation
executes, none of the activities hotel andairline can execute. the precedenceconstraint between activities notify failure andcompensation speci¯es that the
activity notify failure cannot execute before the activity compensate . note that
after the activity compensation executes, there might still be some responses
arriving from the reservation services. if an satisfactory booking response ar-
rives after the activity compensate is executed, the acme service can still decide
to accept the booking. this is why the activity notify failure does not always
necessarily execute after the activity compensate .
after at least one positive reservation response arrives, the acme service
can decide to accept and ¯nalize the whole booking. this is speci¯ed with the
branched precedence constraint between the activity credit card and activities
booked hotel andbooked airline . after the booking is charged, the new requests
will not be sent to the hotel and airline reservation services, i.e., the activities ho-
telandairline cannot execute after the activity credit card . this is achieved with
the two not-response constraints between the activity credit card and activities
hotel andairline . only and always after the booking is charged, the customer
will be noti¯ed about the successful booking. the succession constraint between
activities credit card andnotify booked speci¯es that the activity notify booked
cannot execute before the activity credit card and that it will have to execute
after the activity credit card .
to conclude the booking of a customer, the acme service will either accept
or decline the requested booking. this means that in the service either one of the
taksnotify failure andcredit card will execute. note that even after the activity
compensation , acme can still receive an positive reservation response and accept
the booking. the not co-existence constraint between activities credit card and
notify failure speci¯es that only one of these two activities can execute in the
service because it is not possible to both charge the booking and notify the
customer about failure. however, eventually one of the activities credit card or
notify failure will execute, as speci¯ed with the mutual substitution constraint
between these two activities.
note that the acme service model in figure 6 allows for many alternative
executions of the service. for example, it is possible to handle the both late and
lost reposes of reservation services. it is also possible to send requests to di®erent
reservation services regardless the order of the reception of responses. even after
the cancellation has started by executing the activity consumption, it is still
possible to receive a positive response and successfully ¯nalize the requested
booking.
it is important to note that figure 6 uses a declarative style of modelling. the
decserflow model allows for much more variability than a typical procedural
process model (e.g., a bpel speci¯cation). however, because the language is
extendible it is possible to add constructs one can ¯nd in traditional languages,
e.g., it is relatively easy to add the \place concept" from petri nets or the
\sequence concept" from bpel. as a result, decserflow can be applied using
di®erent styles ranging from highly procedural to highly declarative.4 enacting decserflow models of web services
every decserflow model consists of a set of activities and constraints. con-
straints de¯ne rules that the service has to ful¯ll. at the end of the service
execution all constraints should be ful¯lled. the semantics of a constraint is
de¯ned with the ltl formula that is assigned to it. we use these ltl formu-
las to execute a decserflow model. every ltl formula can be translated into
an buchi automaton [10]. there are several algorithms for translating ltl ex-
pressions into buchi automata. di®erent algorithms have been studied in the
¯eld of model checking [15]. the spin tool [14] is one of the most widely used
tools for model checking. using spin, one can develop a model of a system in
promela (process meta language) [14]. to check the model with respect to
some requirements, we can write these requirements as ltl expressions. spin
can automatically verify the correctness of the speci¯ed ltl requirements in the
developed promela model. for veri¯cation purposes, spin uses an algorithm for
translating ltl expressions to buchi automata [10].
a decserflow model typically has multiple constraints. all of the constraints
need to be taken into account at any moment of the service execution. for this
purpose we can take one of the two strategies: (1) we can construct an automaton
for each of the ltl expressions and then execute these automatons in parallel, or
(2) construct and execute a single automaton for the whole model (i.e., construct
an automaton for the conjunction of all ltl expressions).
when executing a service by executing referring buchi automaton(s), we have
to deal with two problems. first, the standard algorithms (e.g., the one presented
in [10]) construct a non-deterministic ¯nite automaton. a nondeterministic ¯nite
automaton is a ¯nite state machine where for each pair (state, input symbol)
there may be several possible next states. this means that for each pair (state
of a decserflow model, executed activity) there may be several possible next
states of the decserflow model. this is a problem because, given a execution
history, it is not always possible to pinpoint the current state in the automaton.
second, algorithms such as the one presented in [10] construct a ¯nite automaton
forin¯nite words . because we assume that a service will eventually ¯nish with
the execution, we have to use an automaton that can read ¯nite words.
4.1 executing a non-deterministic automaton
in this section we describe a simple algorithm that can be used to successfully
execute a non-deterministic automaton in the context of the execution of a dec-
serflow model. we use a simple example of a model with three activities, as
shown in figure 7(a). this model consists of activities curse ,pray, and bless
and a constraint response between activities curse andpray. all three activities
can be executed an arbitrary number of times because there are no \existence"
constraints to specify cardinalities of activities. constraint response between ac-
tivities curse andpray speci¯es that, every time a person curses, (s)he should
eventually pray after this.(a)  model (b) automaton p2p1 p2!curse 
pray pray true true
curse pray 
bless response fig. 7. a simple decserflow model.
for this model we construct the automaton [10], as shown in figure 7(b).
this automaton consists of two states: p1(accepting and initial state) and p2.
in the beginning we assume the automaton to be in the initial state p1. there
are three transitions possible from this state: (1) transition with the label pray is
applied when the activity pray is executed, (2) transition with the label !curse is
applied when activities pray orbless are executed, and (3) transition trueleads
to the state p2and is applied when any of the activities is executed. in the state
p2two transitions are possible: (1) transition with the label trueis applied when
any of the three activities are executed and (2) transition pray leads to the state
p1and is applied when the activity pray executes.
in a simpli¯ed case of a deterministic automaton, we would execute the
model by checking at which state the automaton currently is, i.e., we would
constantly store the information about the current state of the automaton. if
the automaton is in an accepting state, the constraint(s) are ful¯lled and vice
versa. when executing an activity, the automaton would simply move to the
next state by a transition that can be applied for that activity. when executing
an activity in the case of a non-deterministic automaton, there can be multiple
possible next states to move to. the automaton shown in figure 7(b) is a non-
deterministic automaton. take, for example, the situation when the automaton
is in the state p1and the activity pray executes. in this case (at the state p1),
we could apply any of the transitions pray (the automaton remains in the state
p1),!curse (the automaton remains in the state p1), or true (the automaton
changes the state to p2) - this is a non-deterministic situation. because we use
the current state of the automaton to determine if the constraint(s) are ful¯lled
or not and the next possible activities, the information about the current state
of the automaton is important.
a simple solution for the execution of a non-deterministic automaton is to
consider a set of possible current states3instead of a single current state. in
the situation described above (when the activity pray is executed in the state
p1) we would consider the automaton to transfer to the set of possible states
fp1,p2g. we take the optimistic approach and consider an automaton to be in
an accepting state if any of the states in the set of current possible states is an
accepting state of the automaton. figure 8 shows the algorithm for the execution
of a non-deterministic automaton. we use two data types: (1) state consists
3this set can have at most all states of the automaton.of an array of incoming transitions and an array of outgoing transitions and
(2)transition has a label (e.g., !curse ), source state and target state. function
nextstate generates an array of states (a set of possible next states) given the
array (set) of current possible states and the activity name. this function loops
through the array of current states. for each current state it loops through all
theoutgoing transitions. for each of the outgoing transitions it checks is the
label of the transition complies with the activity name. if (1) the activity is
accepted by the transition label and (2) the target state of the transition is not
in the array of the next states, the target state of the transition is added to the
array of the next states.
1  state[] nextstate(state[] current, string activit y){
2     state[] next;
3      for i = 0 to current.length - 1 do{         // look at all current possible states.
4         state curr = current[i];                   // for every current state 
5          for j = 0 to curr.out.length - 1 {       // look at all out-transitions.
6              transition out = curr.out[j];         // for every out-transition,
7              if (out.label parses  activity)          // if the out-transition suits the activity,
8               then if ( out.target not in   next )    // if the target state is not already i n the set of new possible states
9                            then next = next +  out.target; // add the target state to the set of new possible states.
10          } 
11       } 
12      return next;
13   } transition{
    string label;
    state source;
    state target; 
}state {
   transition[] in;
   transition[] out; 
}
fig. 8. execution of a non-deterministic automaton.
table 1 shows the execution of the automaton shown in figure 7 (b). at the
beginning, the set of possible states contains all initial states, which is in this
casefp1g. for example, if activity bless is executed in the initial state, then
the automaton could apply transition !curse (and stay in the state p1) or it
could apply transition true (and move to the state p2). thus, if the activity
bless is executed when the automaton is in a state in fp1g(i.e., the initial set
of possible states), the automaton can move to any state in the the set of new
possible states fp1,p2g. if the automaton is, for example, in the set of possible
states fp1,p2gand activity bless is executed, the automaton transfers to the
set of possible states fp1,p2gthat is formed as intersection of sets of possible
states for each of the starting states p1(fp1,p2g) and p2(fp2g). since p1is
the accepting state of the automaton in figure 7 (b), we consider the execution
of the decserflow model from figure 7 (a) to be correct (i.e., all constraints
are ful¯lled) if the set of current possible states contains the state p1. thus, we
consider the model to be executed correctly, if the set of current possible states
of the automaton is either fp1gorfp1,p2g.table 1. execution of the non-deterministic automaton in figure 7
automaton automaton
possible states possible states
nr. from activity to
1 fp1g bless fp1,p2g
2 fp1g curse fp2g
3 fp1g pray fp1,p2g
4 fp2g bless fp2g
5 fp2g curse fp2g
6 fp2g pray fp1g
7 fp1,p2g bless fp1,p2g
8 fp1,p2g curse fp2g
9 fp1,p2g pray fp1,p2g
4.2 executing finite traces
the algorithm presented in [10] is originally dedicated for model checking of con-
current systems. because these systems are not designed to halt during normal
execution, the resulting automaton is an automaton over in¯nite words (traces,
runs) . an in¯nite trace is accepted by the automaton [10] i®it visits an accept-
ing state in¯nitely often. this type of acceptance cannot be applied for the case
of service execution, because we require that such an execution will eventually
complete.
there are two strategies that can enable checking of the acceptance of an
¯nite trace in an automaton generated by [10]: (1) we can introduce special
invisible \end" activity and constraint in a decserflow model before the au-
tomaton is created or (2) we can adopt a modi¯ed version of this algorithm,
which reads ¯nite words (traces, runs) [11].
in the ¯rst strategy we use the original algorithm for the generation of au-
tomata, but we slightly change the decserflow model before creating the au-
tomaton. to be able to check if a ¯nite trace is accepting, we add one \invisible"
activity and one \invisible" constraint to every decserflow model and then
construct the automaton. with this we specify that each execution of the model
will eventually end. we introduce an \invisible" activity e, which represents
theending activity in the model. we use this activity to specify that the ser-
vice will end - the termination constraint. this constraint has the ltl formula
3e^(2(e¡!°e)), and it speci¯es that: (1) the service will eventually end -
the \invisible" activity ewill eventually be executed, and (2) after this activity,
no other activity will be executed but the activity eitself, in¯nitely often. take,
for example, a simple decserflow model with one constraint existence(receive) ,
(i.e.,3receive ), which speci¯es that the activity receive will execute at least
once. to execute this model we ¯rst add the termination constraint and con-
sider a conjunction of these two constraints: 3receive ^3e^(2(e¡!°e)).
this conjunction ensures that the trace will have the pre¯x required by the
original decserflow model and an in¯nite su±x containing only the \ending"activity e. the whole conjunction is then translated into an automaton using the
original algorithm [10]. we check the acceptance of the ¯nite trace (pre¯x) of
the original decserflow model by checking if the automaton is in a so-called end
state: (1) if the automaton is in an accepting state and (2) if from this moment
an accepting state can be visited in¯nitely often only by executing the \ending"
activity e. to prevent deadlocks, the automaton is purged (before the execution)
from the states from which none of the endstates is reachable.
as the second strategy, we can use a modi¯cation of the original algorithm.
the original algorithm for translating ltl formulas to buchi automatons [10] is
modi¯ed to be used for veri¯cation of ¯nite executions of software programs [11].
the algorithm for translating ltl formulas into automatons over ¯nite words
introduces a change into the acceptance criteria of the original algorithm [11].
however, this algorithm assumes that any program would have to start exe-
cuting, i.e., it does not consider empty traces. therefore, an initial state is not
accepting in some cases where it should be accenting for an empty trace. how-
ever, we assume that an \empty" execution of a decserflow model (that does
not violate any constraint) is in principle an accepting execution. therefore, we
introduce an \invisible" initial activity init. using ltl we require this to be the
¯rst activity. moreover, to any execution sequence we add a pre¯x containing
oneinitactivity, i.e., before the service can start, activity initis automatically
executed. after this, it is possible to determine if the state where no activities
have been executed (empty trace) is in an accepting state or not.
after completing the decserflow editor, we are currently experimenting with
di®erent ways in which we can build useful automatons for enactment. since we
are using ltl not just for analysis but as the care technology for the engine, we
also have to address issues such as performance and reliability.
5 conclusion
this paper advocated a more declarative style of modeling in the context of web
services. therefore, we proposed a new, more declarative language: decserflow.
although decserflow is graphical, it is grounded in temporal logic. it can be
used for the enactment of processes, but it is also suited for the speci¯cation of
a single service or a complete choreography.
besides being declarative , the language is also extendible , i.e., it is possible to
add new constructs without changing the core of the language. we have devel-
oped a graphical editor to support decserflow. this editor allows users to spec-
ify service °ows. moreover, the user can add user-de¯ned constraint templates
by simply selecting a graphical representation and providing parameterized se-
mantics in terms of ltl. currently, we are working on an engine that is able to
support enactment and monitoring. if a constraint is used for enactment, it is
impossible to permanently violate a constraint because the system will not allow
activities that violate this constraint. if a constraint is used for monitoring, the
system will allow the violation of this constraint. however, the engine will issue
a warning and log the violation. the automatic construction of an automatonsuitable for enactment and on-the-°y monitoring is far from trivial as shown in
section 4.
there is also a very interesting link between decserflow and process mining
[6]. in [3] we showed that it is possible to translate abstract bpel into petri
nets and soap messages exchanged between services into event logs represented
using our mxml format (i.e., the format used by prom www.processmining.
org). as a result, we could compare the modeled behavior (in terms of a petri
net) and the observed behavior (in some event log) using the conformance checker
[18]. a similar approach can be followed by using the ltl checker in prom [1].
using the ltl checker it is possible to check ltl formulas over event logs (e.g.,
monitored soap messages). in principle it is possible to use the ltl formulas
generated based on the decserflow speci¯cation and load them into the ltl
checker in prom. this allows the users of prom to specify constraints graphically
rather than using the textual language that is used now.
references
1.w.m.p. van der aalst, h.t. de beer, and b.f. van dongen. process mining and
veri¯cation of properties: an approach based on temporal logic. in r. meers-
man and z. tari et al., editors, on the move to meaningful internet systems
2005: coopis, doa, and odbase: otm confederated international conferences,
coopis, doa, and odbase 2005 , volume 3760 of lecture notes in computer sci-
ence, pages 130{147. springer-verlag, berlin, 2005.
2.w.m.p. van der aalst, m. dumas, a.h.m. ter hofstede, n. russell, h.m.w. ver-
beek, and p. wohed. life after bpel? in m. bravetti, l. kloul, and g. zavattaro,
editors, ws-fm 2005 , volume 3670 of lecture notes in computer science , pages
35{50. springer-verlag, berlin, 2005.
3.w.m.p. van der aalst, m. dumas, c. ouyang, a. rozinat, and h.m.w. verbeek.
choreography conformance checking: an approach based on bpel and petri
nets (extended version). bpm center report bpm-05-25, bpmcenter.org, 2005.
4.w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
work°ow patterns. distributed and parallel databases , 14(1):5{51, 2003.
5.w.m.p. van der aalst and m. pesic. specifying, discovering, and
monitoring service flows: making web services process-aware.
bpm center report bpm-06-09, bpm center, bpmcenter.org, 2006.
http://www.bpmcenter.org/reports/2006/bpm-06-09.pdf.
6.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
7.t. andrews, f. curbera, h. dholakia, y. goland, j. klein, f. leymann, k. liu,
d. roller, d. smith, s. thatte, i. trickovic, and s. weerawarana. business process
execution language for web services, version 1.1. standards proposal by bea
systems, international business machines corporation, and microsoft corpora-
tion, 2003.
8.m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.9.m.b. dwyer, g.s. avrunin, and j.c. corbett. patterns in property speci¯cations
for finite-state veri¯cation. in icse '99: proceedings of the 21st international
conference on software engineering , pages 411{420, los alamitos, ca, usa, 1999.
ieee computer society press.
10.r. gerth, d. peled, m.y. vardi, and p. wolper. simple on-the-fly automatic
veri¯cation of linear temporal logic. in proceedings of the fifteenth ifip wg6.1
international symposium on protocol speci¯cation, testing and veri¯cation xv ,
pages 3{18, london, uk, 1996. chapman & hall, ltd.
11.d. giannakopoulou and k. havelund. automata-based veri¯cation of temporal
properties on running programs. in proceedings of the 16th ieee international
conference on automated software engineering (ase'01) , pages 412{416. ieee
computer society press, providence, 2001.
12.k. havelund and g. rosu. monitoring programs using rewriting. in proceedings
of the 16th ieee international conference on automated software engineering
(ase'01) , pages 135{143. ieee computer society press, providence, 2001.
13.k. havelund and g. rosu. synthesizing monitors for safety properties. in pro-
ceedings of the 8th international conference on tools and algorithms for the con-
struction and analysis of systems (tacas 2002) , volume 2280 of lecture notes
in computer science , pages 342{356. springer-verlag, berlin, 2002.
14.g.j. holzmann. the spin model checker: primer and reference manual.
addison-wesley, boston, massachusetts, usa, 2003.
15.e.m. clarke jr., o. grumberg, and d.a. peled. model checking . the mit press,
cambridge, massachusetts and london, uk, 1999.
16.n. kavantzas, d. burdett, g. ritzinger, t. fletcher, and y. lafon. web services
choreography description language, version 1.0. w3c working draft 17-12-04,
2004.
17.m. pesic and w.m.p. van der aalst. a declarative approach for flexible business
processes management. in bpm 2006 workshops: international workshop on
dynamic process management (dpm 2006) , lecture notes in computer science.
springer-verlag, berlin, 2006.
18.a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,
bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 163{176. springer-verlag, berlin,
2006.
19.j. snell. automating business processes and transactions in web services: an
introduction to bpelws, ws-coordination, and ws-transaction. http://www-
128.ibm.com/developerworks/webservices/library/ws-autobp/, june 2006.
20.p. wohed, w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. analysis of
web services composition languages: the case of bpel4ws. in i.y. song, s.w.
liddle, t.w. ling, and p. scheuermann, editors, 22nd international conference
on conceptual modeling (er 2003) , volume 2813 of lecture notes in computer
science , pages 200{215. springer-verlag, berlin, 2003.