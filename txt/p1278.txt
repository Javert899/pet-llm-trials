clustering object-centric event logs
anahita farhang ghahfarokhi1, fatemeh akoochekian1, fareed zandkarimi2,
and wil m.p. van der aalst1
1process and data science, rwth aachen university, aachen, germany
2chair of enterprise systems, university of mannheim, mannheim, germany
farhang@pads.rwth-aachen.de
abstract. process mining provides various algorithms to analyze pro-
cess executions based on event data. process discovery, the most promi-
nent category of process mining techniques, aims to discover process
models from event logs, however, it leads to spaghetti models when work-
ing with real-life data. therefore, several clustering techniques have been
proposed on top of traditional event logs (i.e., event logs with a single
case notion) to reduce the complexity of process models and discover
homogeneous subsets of cases. nevertheless, in real-life processes, partic-
ularly in the context of business-to-business (b2b) processes, multiple
objects are involved in a process. recently, object-centric event logs
(ocels) have been introduced to capture the information of such pro-
cesses, and several process discovery techniques have been developed on
top of ocels. yet, the output of the proposed discovery techniques on
real ocels leads to more informative but also more complex models.
in this paper, we propose a clustering-based approach to cluster similar
objects in ocels to simplify the obtained process models. using a case
study of a real b2b process, we demonstrate that our approach reduces
the complexity of the process models and generates coherent subsets of
objects which help the end-users gain insights into the process.
keywords: clustering Â·object-centric process mining Â·convergence.
1 introduction
process mining is a eld of science bridging the gap between data-oriented anal-
ysis and process-oriented analysis, which aims to extract knowledge from event
logs [25]. process mining techniques are categorized into three types: process
discovery, conformance checking, and process enhancement. process discovery
extracts abstract process knowledge using visual process models. process dis-
covery techniques have been improved to handle complex and large event logs,
e.g., inductive miner [25]. however, the application of process discovery tech-
niques in exible environments such as product development leads to spaghetti
process models with an overwhelming number of connections [23]. one solution
is using clustering techniques to group the process instances with similar behav-
ior. several clustering techniques have been proposed on top of traditional event
logs [6, 7, 9, 10, 16, 18, 22, 23, 24, 26, 28, 29], nevertheless, in reality, multiplearxiv:2207.12764v1  [cs.ai]  26 jul 20222 anahita farhang ghahfarokhi et al.
table 1: informal representation of the events. each row shows an event that
has an identier, a timestamp, an activity, related objects, and attributes.
id activity timestamp batch order customer net price gross price
e1 order creation 2020-04-13 11:20:01.527+01:00 fg f o1g f c1g 146.8 154.8
e2print of production order 2020-04-15 08:21:01.527+01:00 fb1,b2g fo1g f c1g 285.8 301.3
e3 loading 2020-05-09 08:22:01.527+01:00 fb1,b3g fo1g f c1g 272.47 312.4
... ... ... ... ... ... ... ...
table 2: informal representation of the objects. each row shows the properties
of the objects, e.g, the treatment type for b1is painting.
id type treatment workplace
b1batch painting plant 1
b2batch polishing plant 1
o1order
... ... ... ...
objects interact with each other in a process [3, 4, 11, 12, 27], for example, con-
sidering a purchase-to-pay (p2p) process where orders ,items , and customers
are involved [14, 13]. several process discovery techniques have been developed
on top of event logs with multiple case notions [2, 8, 17, 19, 20, 21]. for example,
object-centric dfgs (oc-dfgs), used throughout this paper, are one of the
object-centric process models developed on top of object-centric event logs
(ocels). an oc-dfg is a directly-follows graph (dfg) where relations are
colored based on object types [2]. several examples of such models are shown in
the remainder.
in this paper, we present a clustering-based approach, shown in figure 1,
which uses the relations between objects and events in clustering. first, we ex-
tracted an ocel from a business-to-business (b2b) process. then, we enriched
the extracted ocel with a few graph-related attributes, e.g., centrality mea-
sures. afterward, we selected a clustering object type and applied data clustering
algorithms to group similar objects, i.e., clusters of objects. the challenge occurs
when we intend to assign events to the clusters. we propose two approaches to
address this challenge:
{existence : if we directly assign events to the clusters by considering that
the event should contain at least one of the objects in the cluster, then the
same event may appear in several clusters. for example, consider the b2b
celonis 
manufacturing 
event datacomplex object-
centric process modelenrich ocel with 
object and graph 
related attributesselect the
desired object
type for
clusteringclustering 
-agglomerative
-k-meansassigning events to the cluster 
-existence: the cluster contains 
at least one object that belongs 
to the event. 
-all: the cluster contains all the 
objects that belongs to the event.sub-ocelocel extactionclusteringassigning events to the cluster
sub-ocel
fig. 1: overview of the proposed framework.clustering object-centric event logs 3
ocel shown in tables 1 and 2, where customer ,order , and batch are the
possible case notions. when we apply clustering based on batch , then two
batches in the same event may end up in two dierent clusters. this results
in the duplication of that event. this is due to the convergence in ocels
where an event can contain multiple objects of the same type [14].
{all: in this approach, to avoid convergence, we assign an event to a cluster,
if the cluster contains all the objects that exist in that event. following this
approach, we miss the event whose objects are distributed in several clusters.
consider the process shown in tables 1 and 2, if b1andb2end up in dierent
clusters, then we miss e2, because all the batches of e2are not in the same
cluster. nevertheless, following this approach no duplication of events occurs.
to evaluate the quality of the discovered oc-dfgs, we provide initial com-
plexity measures for oc-dfgs. using the proposed clustering techniques and
quality measures, we achieved a set of meaningful oc-dfgs with almost the
same tness but less complexity in comparison with the initial model.
the remaining part of the paper is organized as follows. section 2 presents
the running example that is used throughout the paper. then, in section 3, we
present some preliminary concepts that will be used throughout the paper. in
section 4, we discuss the object prole extraction and enrichment. afterward, in
section 5, we describe our proposed clustering-based approach in ocels. then,
in section 6, we provide some experiments on the running example using our
approach where we obtain simplied process models. finally, section 7 concludes
the paper and provides future work.
2 running example
to evaluate our approach on real-world data, we have extracted ocel from a
b2b process, anonymized and stored in celonic process analytics workspace.
the respective industry performs surface treatment services such as coating and
polishing mainly for the automotive industry. figure 2 presents the generic pro-
cess routine and the associated object types (i.e., customer ,order , and batch ).
as shown in the gure, the process starts with the order creation activity. cus-
tomers send their order to the company and request for specic treatments. the
orders will be split into batches to t production machines. after applying the
requested treatments, respective batches of each order will be packed together
to be shipped back to the customers .
customer
order
batchcustomer
ordercustomer customer
ordercustomer
order
order creation treatments last delivery ticket last delivery
fig. 2: an abstract view of the extracted b2b process.4 anahita farhang ghahfarokhi et al.
to provide a comprehensive vision of the process, we have used ocel stan-
dard by considering three possible case notions. tables 1 and 2 show the ex-
tracted ocel where the full table 1 consists of 9004 events with dierent
treatment activities, that are anonymized in this data. moreover, the oc-dfg
extracted from the whole process is an unreadable spaghetti model that does
not give insights about the process. to derive simpler models, we can divide
the ocel into several sub-logs using clustering techniques. to apply clustering
methods on objects in the ocel, we need to extract object proles from ocel.
in the next section, we describe the extraction of object proles.
3 preliminaries
3.1 object-centric event logs
first we dene universes that are used throughout the paper:
denition 1 (universes).
{ueis the universe of event identiers, e.g., fe1;e2;e3gue
{uactis the universe of activities, e.g., fordercreation;lastdelivery guact
{uattis the universe of attribute names, e.g., fgross price;net price guatt
{uvalis the universe of attribute values, e.g., f200:0;302:0;paintingguval
{utypis the universe of attribute types., e.g., fstring;integer;float gutyp
{uois the universe of object identiers, e.g., fo1;b1guo
{uotis the universe of objects types, e.g., forder;batchguot
{utimest is the universe of timestamps, e.g., 2020-04-09t08:21:01.527+01:00 2utimest
using the universes above, we dene object-centric event logs.
denition 2 (object-centric event log). an object-centric event log is a
tuplel=(e;an;av;at;ot;o; typ;act;time;vmap;omap;otyp;ovmap;)
such that:
{eueis the set of event identiers, e.g., e1in table 1.
{anuattis the set of attributes names, e.g., gross price in table 1.
{avuvalis the set of attribute values, e.g., plant 1in table 2.
{atutypis the set of attribute types. for example, the type of the attribute
workplace in table 2 is string.
{otuotis the set of object types. for example, in table 2, for the rst
object, the type is batch.
{ouois the set of object identiers, e.g., o1in table 2.
{typ:an[av!atis the function associating an attribute name or value
to its corresponding type. for example, in table 1, typ(net price ) =float .
{act:e!uactis the function associating an event to its activity, e.g.,
act(e1) =order creation in table 1.
{time :e!utimest is the function associating an event to a timestamp,
e.g.,time(e1) =2020-04-13 11:20:01.527+01:00 in table 1.clustering object-centric event logs 5
{vmap :e!(an6!av)is the function associating an event to its attribute
value assignments, e.g., vmap(e1)(net price ) =146:8in table 1,
{omap :e!p (o)is the function associating an event to a set of related
object identiers, e.g., omap(e1) =fo1;c1gin table 1.
{otyp2o!otassigns precisely one object type to each object identier,
e.g.,otyp(o1) =order in table 2, .
{ovmap :o!(an6!av)is the function associating an object to its at-
tribute value assignments, e.g., ovmap (b1)(workplace ) =plan 1in table 2.
{is a total order (i.e., it respects the anti-symmetry, transitivity, and con-
nexity properties).
to summarize, an event log consists of information about events and objects
involved in the events. dealing with object-centric event logs starts from log
attening. therefore, by selecting an object type that we aim to cluster, we
transform an object-centric event log into a traditional event log.
denition 3 (ot-flattened log). letl= (e;an;av;at;ot;o; typ;act;
time;vmap;omap;otyp;ovmap;)be an ocel, and ot 2ot be an object
type. we dene ot-attened log as fl(l;ot) = (eot;ot
act;ot
time;ot
case;ot)where:
{eot=fe2ej9o2omap (e)otyp(o) =otg,
{ot
act=actjeot;i:e:;actwith the domain restricted to eot,
{ot
time=timejeot;i:e:;timewith the domain restricted to eot;
{fore2eot,ot
case(e) =fo2omap(e)jotyp(o) =otg, and
{ot=f(e1;e2)2 j9o2ootyp(o) =ot^o2omap(e1)\omap(e2)g
using the attened log, we extract object proles from ocels that will be
comprehensively described in section 4. to increase the number of features of
objects for clustering, we enrich the ocel with some graph-related attributes.
next, we describe the graph theory concepts that we used to enrich the ocels.
denition 4 (directed graph). a directed graph is a pair g= (v;e)where [1]:
{v is a set of vertices (nodes).
{ef(v1;v2)2vvjv16=v2gis a set of edges, which are ordered pairs
of distinct vertices. in a weighted directed graph each node is assigned to a
weight through the function f:e!r.
an example of a weighted graph is shown in figure 3.
denition 5 (path). a path in graph g= (v;e)is a sequence of vertices
p=hv1;:::;vni2v:::vsuch that (vi;vi+1)2efor1i<n .
example : in the graph in figure 3, there is p=ha;b;di.
denition 6 (shortest path). letg= (v;e)be a directed graph and v1;vn2
v. given a weight function f:e!r, the shortest path from v1tovnis the
pathsp=hv1;:::vnisuch that over all possible paths from v1tovnit minimizespn 1
i=1f(vi;vi+1).
example : in figure 3, the shortest path between node aand nodecin
weighted directed graph is p=ha;d;e;cisincef(a;d) +f(d;e) +f(e;c) = 7
while for example for paths p=ha;b;ciwe havef(a;b) +f(b;c) = 9 .6 anahita farhang ghahfarokhi et al.
ab c
d ef54
3
3
21
2
fig. 3: a directed graph.
the next denitions are related to centrality. in graph theory, centrality is a
number or ranking assigned to all nodes in a graph, indicating each node's posi-
tion in the graph. each type of centrality illustrates a certain type of importance
or inuence that a node can have.
denition 7 (in-degree centrality). letg= (v;e)be a directed graph
andv12v. then we dene degin(v1)as the number of incoming edges to v1,
i.e.,degin(v1) =jf(v;v0)2ejv0=v1gj:
example : in figure 3, degin(b) = 1 anddegin(c) = 2 .
denition 8 (out-degree centrality). letg= (v;e)be a directed graph
andv12v. then we dene degout(v1)as the number of outcoming edges from
v1, i.e.,degout(v1) =jf(v0;v)2ejv0=v1gj:
example : in figure 3, degout(a) = 2 anddegout(b) = 2 .
denition 9 (closeness centrality). letg= (v;e)be a directed graph
andv2v. then we dene closeness centrality of vas the reciprocal of the sum
of the length of the shortest paths between vand all other nodes in the graph.
normalized closeness centrality is dened as:
cc(v) =jvj 1p
y2vsp(v;y)(1)
wheresp(v;y)is the shortest path between vertices vandy. therefore, the
more central a node is, the closer it is to all other nodes.
denition 10 (harmonic centrality). letg= (v;e)be a directed graph
andv2v. harmonic centrality is dened as:
ch(v) =x
y2vnfvgjvj 1
sp(v;y)(2)
wheresh(y;x)is the shortest path between vertices vandy.
using described graph-related attributes, we enrich the object information.
in the next section, we describe how we comprise object proles and enrich them
using the graph-related features to apply clustering techniques.clustering object-centric event logs 7
4 object proles
clustering algorithms group sets of similar points. in clustering objects of the
ocel, the points to be clustered are object proles. to start clustering, we
preprocess the data and enrich it with some additional features for each object.
below, we describe how we enrich the object attributes with graph attributes.
first, we extract the related trace to an object using the attened log.
denition 11 (trace). given an ot-attened log fl= (eot;ot
act;ot
time;ot
case;
ot), we dene the following operations:
{ot
act(fl) =fot
act(e)je2eotg
{ot
case(fl) =[e2eotot
case(e)
{forc2ot
case(fl),caseot
fl(c) =he1;:::;eniwhere:
 fe1;:::;eng=fe2eotjc2ot
case(e)g
 81i<nei<ei+1
{givenc2ot
case(fl)andcaseot
fl(c) =he1;:::;eni,we dene
tracefl(c) =hot
act(e1);:::;ot
act(en)i
moreover, to provide derived attributes, we create a directed weighted graph
based on the sequence of activities of each object.
denition 12 (trace graph). letfl= (eot;ot
act;ot
time;ot
case;ot)be a
attened ocel and c2ot
case(fl)be an object. for the object trace trace fl(c) =
ha1;:::;ani, we dene the corresponding directed weighted graph of the trace as:
gtrace fl(c)= (v;e)with the weight function ot
freq:e!rwhere:
{v=fa1;:::;ang
{e=f(ai;ai+1)j1i<ng
{for(x;y)2e,ot
freq(x;y) =jf(a1;a2)2ej(a1;a2) = (x;y)gj
the graph for trace =ha;b;c;d;a;b;diis presented in figure 4. for each
object we calculate the trace graph and for each node in every graph we nd
in-degree centrality ,out-degree centrality ,closeness centrality , and harmonic cen-
trality , described in section 3. as an illustration, in figure 4 the node list is
v=fa;b;c;dgand the corresponding in-degree centrality vector is (1 ;1;1;2).
however, we need to assign a unique value to this object as the in-degree cen-
trality . thus, for each trace graph, the mean, variance, and standard deviation
ab
cd2
111
1
fig. 4: the graph of the trace trace fl(c).8 anahita farhang ghahfarokhi et al.
table 3: object proles extracted from an ocel.
object id trace treatment workplace ...in-degree
centrality meanin-degree
centrality stdin-degree
centrality var
b1 hprint of production order; loading ipainting plan 1... 0.50 0.50 0.25
b2 hprint of production order; :::; lubricate ipolishing plan 1... 1.00 0.00 0.00
b3 hloading; painting i painting plan 2... 0.50 0.50 0.25
of all vector elements are calculated and inserted in the object attribute. for
the mentioned in-degree centrality vector (i.e., (1 ;1;1;2)) the mean is 1.25, the
variance is 0.25, and the standard deviation is 0.5. these values are added to
the related object attributes as in-degree centrality means ,in-degree centrality
variance , and in-degree centrality standard deviation . for other features such as
closeness centrality , we follow the same procedure. using all these features, we
enrich the object attributes with graph related attributes. now, using object
attributes and object trace, we dene object prole which is used as an input
for clustering.
denition 13 (object prole). letfl= (eot;ot
act;ot
time;ot
case;ot)be a
attened ocel. we dene object prole function for o2owhereotyp(o) =ot
asop:uo!u
actuval:::uvalsuch thatop(o) = (tracefl(o);ovmap (o)(att1);
:::;ovmap (o)(attn))andatt1;:::;attn2dom(ovmap (o)):
an example of the extracted proles is shown in table 3 where the batch
proles are represented. for example for b1, the extracted trace, treatment ,
workplace , andin degree centrality mean are the object attributes that con-
stitute the prole for b1. to sum up, using the graph features, we enrich the
object proles and the output of the prole extraction step is the enriched pro-
les. based on this information, we apply clustering methods to the objects.
5 clustering in object-centric event logs
in this section, we present the clustering algorithm. first, we describe the dis-
tance measures that we used to nd the similarity between object proles. af-
terward, we describe the two clustering techniques that we used in this research.
5.1 distance measures
clustering results are aected by the distance measures that are used to measure
the distance between object proles. an example of object proles is shown in
table 3. as the table illustrates, an object prole consists of the object's control
ow and the attribute values which can be numerical or categorical. therefore,
dierent distance measures are needed to calculate the distance between object
proles. to calculate the distance between the attributes related to the con-
trol ow, numerical attributes, and categorical attributes we apply levenshtein,
euclidean, and string boolean distance that are described below, respectively.
we used levenshtein distance to measure the distance between two sets of
activities where we should transform one set of activities to another set of activ-
ities. therefore, a set of operations that are substitution, insertion, and deletionclustering object-centric event logs 9
are needed to be done on one of the sequences. the mathematical representation
of these edit distances is described in [7]. euclidean distance is used to measure
the distance between numerical values and string boolean distance is used to
measure the distance between categorical values. if the categorical values are the
same the distance is zero otherwise the distance is one.
using described distance metrics, we nd the distance of the objects from
each other to apply clustering algorithms. in the next section, we describe the
clustering algorithms that we utilized in this paper.
5.2 clustering algorithm
in this section, we shortly explain clustering algorithms, i.e., k-means and ag-
glomerative clustering. these clustering algorithms can be applied on the object
proles, described in section 4, to create clusters of homogeneous objects.
{k-means clustering: k-means technique is one of the most common cluster-
ing methods among partitioning methods. k-means algorithm clusters data
into k clusters based on minimizing within-cluster sum-of-squares criteria.
{hierarchical clustering: hierarchical clustering is used to cluster data based
on a hierarchy of clusters. there are main approaches in the hierarchical
clustering method: agglomerative (i.e., a bottom-up approach) and divisive
(i.e., a top-down approach). in this paper, we have applied agglomerative
clustering where generates clusters through merging the nearest objects, i.e.,
smaller clusters of objects are combined to make a larger cluster.
using each of the clustering techniques above, we map a set of objects with the
same type (e.g., batch) onto the clusters containing a set of objects:
denition 14 (clustering). letl= (e;an;av;at;ot;o; typ;act;time;
vmap;omap;otyp;ovmap;)be an ocel and otbe an object type which we
aim to do clustering for. clustering is a function cl:p(uo)!p(p(uo))such
thatcl(o) =fo1;o2;:::;ongwhere8o2o otyp(o) =otandsn
i=1(oi) =o.
by applying clustering methods on objects and using their proles, described
in denition 13, we obtain clusters of objects with the same type. in the next
section, we describe how we transform the results of clustering into an ocel.
5.3 transformation of the clustering results into ocel
to extract process models from the obtained clusters, we should assign the clus-
ters to the corresponding events. here, we propose two approaches based on the
state of the objects in the event.
{existence : in this approach, we assign an event to the cluster, containing at
least one object existing in that event. this approach leads to duplication
in events that is described in section 1. an example is shown in figure 5
wheree3is in both clusters, since b1andb3are in separate clusters. now,
we formalize the notion of existence approach as a function:10 anahita farhang ghahfarokhi et al.
b3 b4
b6b1 b2
b5
fig. 5: matching clusters with the events using existence approach.
b3 b4
b6b1 b2
b5
fig. 6: matching clusters with the events using allapproach.
denition 15 (existence). letl= (e;an;av;at;ot;o; typ;act;
time;vmap;omap;otyp;ovmap;)be an ocel and ocl be a set of ob-
jects in a cluster where ocl2cl(o). existence is a function ex:uo!ue
such thatex(ocl ) =fe2ejomap(e)\ocl6=;g.
{all: assuming we do clustering based on the objects with type ot, in this
approach, we assign an event to the cluster that contains all objects with the
typeotthat exist in that event. this may lead to the loss of some events that
can not be assigned to any of the clusters. in fact, there is no cluster that
contains all the objects of the type ot, existing in that event. an example is
shown in figure 6 where e3is missed, since b1andb3which are the batches
involved in e3are in dierent clusters. here, we formalize the allapproach:
denition 16 (all). letl= (e;an;av;at;ot;o; typ;act;time;
vmap;omap;otyp;ovmap;)be an ocel and ocl be a set of objects in a
cluster where ocl2cl(o). all is a function all:uo!uewhereall(ocl ) =
fe2ej8o2omap(e)otyp(o) =ot^o2oclg.
by applying the proposed clustering technique on ocels, we obtain sub-logs
for each cluster. however, the aim of this paper is to apply clustering techniques
to obtain less complex models. thus, in the following section, we dene tness,
size, density, and some comparative complexity measures on top of oc-dfgs.
5.4 quality metrics
to measure the quality of obtained models and compare them with the main
model, we should dene the quality metrics such as complexity. we rst dene
the discovery of an oc-dfg which is the basis of the rest of the denitions.
denition 17 (discovery of an ocdfg). letl= (e;an;av;at;ot;o;
typ;act;time;vmap;omap;otyp;ovmap;)be an ocel. then we dene
ocdfg (l) = (a;ot;f; freqn;freq)where:clustering object-centric event logs 11
{auactis the set of activities.
{otuotis the set of object types.
{f((f.g[a)(a[fg))otis the set of (typed) edges.
{freqn :a6!nis a frequency measure on the nodes.
{freq:f6!nis a frequency measure on the (typed) edges.
oc-dfgs are one of the state-of-the-art object-centric models where each object
type is shown with a specic color. to evaluate the quality of oc-dfgs, we use
the tness criteria described in [2]. however, we also dene other measures to
nd the complexity of the model. next, we dene the size and density of the
model. the smaller the graph, the simpler the structure.
denition 18 (size). given anocdfg = (a;ot;f; freqn;freq), we de-
ne the size of the ocdfg assize(ocdfg ) =jajjfj.
to measure the density of the process model, we have employed the density
measure of a graph introduced in [15]. the interpretation of the formula in
denition 19 is that the more dense the graph, the more complex the model is.
denition 19 (density). given anocdfg = (a;ot;f; freqn;freq), we
dene the density of the ocdfg asdensity (ocdfg ) =jaj=jfj.
the size and density capture the general information regarding complexity
in process models, however, to evaluate our approach we should compare the
complexity of the obtained process models from clusters with the main process
model. therefore, we dene the concepts related to improvements in size and
density. these measures are designed to compare the weighted average of the
size or density of all clusters with the size or density of the main process model.
denition 20 (improvement in size complexity). letfo1;:::;ongbe the
set of clusters obtained from l, andfl1;:::;lngbe the set of events assigned to
each cluster by applying existence or all approach, e.g., l1=ex(o1);:::;ln=
ex(on). we dene size complexity improvement csias
csi=size(ocdfg (l))
pn
i=1joijsize(ocdfg (li)pn
i=1joij
denition 21 (improvement in density complexity). letfo1;:::;ongbe
the set of clusters obtained from l, andfl1;:::;lngbe the set of events assigned
to each cluster by applying existence or all approach, e.g., l1=ex(o1);:::;ln=
ex(on). we dene size complexity improvement cdias
cdi=density (ocdfg (l))
pn
i=1joijdensity (ocdfg (li)pn
i=1joij
for the last two metrics, the values less than one mean that we obtained
more complex models, and the values greater than one indicate that less complex
models are achieved. in the next section, we evaluate our approach on a real b2b
process using the described evaluation metrics.12 anahita farhang ghahfarokhi et al.
6 evaluation
to validate the proposed approach for object clustering in ocels, we have
performed a case study using the b2b dataset described in section 2 representing
a treatment process. this dataset contains 9004 events and three object types,
namely customer ,order , and batch . an order stands for a specic treatment to
be applied on number of batches sent by a customer . the behavior of customer
and order are similar, i.e., each order belongs to only one customer . therefore,
we evaluated our approach using order and batch .
figure 4 shows the process model of the whole ocel which is a spaghetti-
like model and too complex to interpret. this process model is shown to the
domain expert and he failed to recognize the real process behind it. therefore,
we applied the proposed clustering technique, described in section 5, to discover
simplied process models for each cluster. to nd the optimal number of clusters
we have employed calinski-harabasz, and dendrogram for k-means and hierar-
chical clustering, respectively. the results conrm that at batch -level, three or
four clusters and at order -level, two or three clusters are the best choices. con-
sidering the optimal number of clusters, we have applied agglomerative and k-
means clustering techniques to nd the clusters of objects. both techniques were
eective, nevertheless, the results of the k-means algorithm are more promising.
by applying k-means clustering on the set of object proles, we got a set of ob-
jects in each cluster. afterward, using existence andallapproaches we managed
to assign events to the clusters. tables 5 and 6 report the complexity and tness
of the respective models of the resulted clusters. we evaluated the obtained pro-
cess models using the tness and complexity criteria described in section 5.4.
as the results show, the complexity of the obtained process models is reduced
with the same or higher tness. for example, the result of clustering based on
batch with four clusters and using allapproach is shown in figure 7.
besides the simplication of process models the discovered process models
per cluster show some interesting points:
{in three clusters (i.e., cluster 1, cluster 2, and cluster 3) the process has
started with order creation , however, in cluster 4 there is no order creation .
after discussion with the expert, we realized that cluster 4 shows the rework
process of the items that experienced failures in their previous treatment
process. therefore, no order creation is executed in these processes.
{there is a dierence between cluster 3 and two other clusters (i.e, cluster 1
and cluster 2). print of order production is followed by hanging pieces in
cluster 3 whereas it is followed by loading , in cluster 1 and cluster 2. we
recognized that the process, shown in cluster 3, refers to small items such
as nuts and bolts. therefore, we hang them to plate both sides of them.
table 4: some characterizations of the main model.
the main model properties
no. of nodes no. of edges fitness size density
25 118 0.83 2950 4.76clustering object-centric event logs 13
table 5: the clustering result using k-means and existence approach.
k-means
objects no. of clusters no. of nodes no. of edges fitness size density avg. fitness csicdi
order224 106 0.85 2544 4.420.85 1.22 7.3112 34 0.89 408 2.83
324 106 0.85 2544 4.42
0.85 1.23 6.69 12 27 0.86 324 2.25
10 20 0.98 200 2
batch320 80 0.81 1600 4
0.84 2.34 43.75 17 48 0.87 816 2.82
9 20 0.96 180 2.22
419 75 0.85 1425 3.95
0.87 3.19 44.619 20 0.96 180 2.22
7 16 0.87 112 2.29
11 34 0.89 374 3.09
table 6: the clustering result using k-means and allapproach.
k-means
objects no. of clusters no. of nodes no. of edges fitness size density avg. fitness csicdi
order224 106 0.85 2544 4.420.85 1.22 7.3112 34 0.89 408 2.83
324 106 0.85 2544 4.42
0.85 1.23 6.69 12 27 0.86 324 2.25
10 20 0.98 200 2
batch320 78 0.78 1560 3.9
0.82 2.38 43.74 17 49 0.88 833 2.88
9 21 0.98 189 2.33
419 73 0.86 1387 3.84
0.88 3.27 44.957 16 0.87 112 2.29
9 21 0.98 189 2.33
11 34 0.91 374 3.09
however, cluster 1 and cluster 2 represent the process of larger items such
as bottles that we should load to do the treatment.
{cluster 1 and cluster 2 illustrate the process of two dierent types of items
since the activities that are executed between loading andunloading are not
the same. for example, oil removing is executed in cluster 2 while golden
layer and surface securing are the common activities in cluster 1.
{the last delivery ticket activity shown in cluster 1 and cluster 2 shows
the delivery status. when an employee nishes an order which is usually
divided into several batches, the shipping process starts. each delivery in the
shipping process requires a delivery ticket. the last delivery ticket refers to
the last shipment of an order and its respective delivery ticket.
as we see the proposed technique can distinguish dierent processes that
exist in the initial ocel. to sum up, we have applied the proposed clustering
technique on a b2b process where multiple object types are involved. the initial
process model is complex to interpret, however, to derive simpler models, we
divided the ocel into several sub-logs using the proposed clustering techniques.
the obtained process models are simplied and meaningful process models that
can separate dierent processes and help the user gain insights into the process3.
3all the experiments are implemented in pm4py [5].14 anahita farhang ghahfarokhi et al.
order creation
e=89
print of production order
e=123
loading
e=825
preparing
e=780
polish
e=39
surface securing
e=704
drying
e=780
deactivating
e=764
unloading
e=809
sealing
e=261
counting
e=99
demagnetize
e=35
entry control
e=35
other checks
e=35
check outgoing parts
e=38golden layer
e=143
sticking jewels
e=45
tweaking
e=61last delivery ticket
e=89order
e=89
e=20
e=89
e=97
e=492e=128
e=143
e=26
e=23 e=24
e=45e=31
e=198e=45
e=662e
= e=33
e=48 e=348
e=43
e=76e=33
e=698
e=737 e=737e=123
e=26batch
e=609
e=81 e=130
e=520
e=143
e=32
e=663
e=32 e=85
e=45e=26
e=23 e=24
e=48
e=49e=698e=31e=45
e=27
e=719
e=38
e=24
e=49
e=172e=20
e=49e=248
e=50
e=33e=22e=22e=83e=59
e=22e=248
e=20e=38
e=31
e=27
e=33e=26
e=21 e=32
batch
e=20e=392ordere=718
(a) cluster 1.
order creation
e=52
print of production order
e=68
loading
e=283
polish
e=78
drying
e=159
unloading
e=282
preparing
e=111
sticking jewels
e=95
lubricate
e=127oil removing
e=32
last delivery ticket
e=52e=52
e=52
e=62e=234
e=68
e=49
e=23 e=76 e=141e=59
e=118e=77e=25
e=32e=50
e=40 e=126e=93
e=72e=32e=68
e=31
e=32e=103e=21 e=23e=50
e=76
e=119
e=126e=230
e=94
e=72order
batch
orderbatch
(b) cluster 2.
fig. 7: final result of the clustering of batch based on allapproach.clustering object-centric event logs 15
order creation
e=45
print of production order
e=73
hanging pieces
e=118
golden layer
e=123
packing
e=142
manual check
e=129
check outgoing parts
e=100e=45
e=35
e=115 e=26 e=22
e=37e=109
e=104
e=104
e=115
e=115
e=51order
batch
batche=77e=73
e=76e=45
(c) cluster 3.
hanging pieces
e=45
golden layer
e=57
packing
e=80
manual check
e=54loading
e=90
preparing
e=53
surface securing
e=53
drying
e=54
unloading
e=61e=22
e=33
e=45 e=34 e=26
e=37
e=53
e=53
e=28e=40batche=44
e=54
e=45 e=26 e=26
e=32
e=28e=53
e=53e=26e=25 (d) cluster 4.
fig. 7: final result of the clustering of batch based on allapproach.
7 conclusion
process mining techniques provide valuable insights about process executions,
however, most of the process mining techniques developed until now, focus on
traditional event logs (i.e, event logs with single case notion). in reality, there
exist processes with multiple interacting objects which are investigated in a
new branch of process mining called object-centric process mining. several pro-
cess discovery techniques such as artifact modeling and object-centric directly
follows graphs (oc-dfgs) discovery have been developed to discover process
models from object-centric processes, but the discovered models usually suer
from complexity. therefore, in this paper, we propose an approach to obtain
meaningful process models by clustering objects in an object-centric event log
(ocel). we introduce two approaches (i.e., alland existence ) and use them in
log extraction from the clusters. furthermore, we enriched the ocel with some
graph-related features such as centrality to enhance clustering results. more-
over, to measure the quality of the process models, we have introduced complex-
ity measures to evaluate the quality of oc-dfg models. we have applied our16 anahita farhang ghahfarokhi et al.
approach on a real-life b2b log of a manufacturing company applying surface
treatment operations (e.g., lubricating and polishing) on various items. the re-
sults are promising where discovered process models can distinguish the process
of dierent item types. for future work, we aim to evaluate the proposed ap-
proach on additional real data sets and use various quality metrics to evaluate
the quality of the obtained process models more precisely4.
4acknowledgments : we thank the alexander von humboldt (avh) stiftung for supporting our
research. funded by the deutsche forschungsgemeinschaft (dfg, german research foundation)
under germany's excellence strategy{exc-2023 internet of production { 390621612.bibliography
[1] e.a. bender and s.g. williamson. lists, decisions and graphs . s. gill
williamson, (2010).
[2] a. berti and w.m.p. van der aalst. extracting multiple viewpoint models
from relational databases. in simpda , pages 24{51. springer, 2018.
[3] alessandro berti. filtering and sampling object-centric event logs. arxiv
preprint arxiv:2205.01428 , 2022.
[4] alessandro berti, anahita farhang ghahfarokhi, gyunam park, and
wil mp van der aalst. a scalable database for the storage of object-centric
event logs. arxiv preprint arxiv:2202.05639 , 2022.
[5] alessandro berti, sebastiaan j van zelst, and wil van der aalst. process
mining for python (pm4py): bridging the gap between process-and data
science. arxiv preprint arxiv:1905.06169 , 2019.
[6] mathilde boltenhagen, thomas chatain, and josep carmona. generalized
alignment-based trace clustering of process behavior. in international con-
ference on applications and theory of petri nets and concurrency , pages
237{257. springer, 2019.
[7] r.p. bose and w.m.p. van der aalst. context aware trace clustering: to-
wards improving process mining results. in siam , pages 401{412. siam,
2009.
[8] d. cohn and r. hull. business artifacts: a data-centric approach to mod-
eling business operations and processes. ieee data eng. bull. , 32(3):3{9,
2009.
[9] pieter de koninck, klaas nelissen, seppe vanden broucke, bart baesens,
monique snoeck, and jochen de weerdt. expert-driven trace cluster-
ing with instance-level constraints. knowledge and information systems ,
63(5):1197{1220, 2021.
[10] chiara di francescomarino, marlon dumas, fabrizio maria maggi, and
irene teinemaa. clustering-based predictive process monitoring. ieee
transactions on services computing , 12(6):896{909, 2016.
[11] stefan esser and dirk fahland. multi-dimensional event data in graph
databases. journal on data semantics , 10(1):109{141, 2021.
[12] anahita farhang ghahfarokhi and wil mp van der aalst. a python tool
for object-centric process mining comparison. arxiv e-prints , pages arxiv{
2202, 2022.
[13] anahita farhang ghahfarokhi, alessandro berti, and wil mp van der aalst.
process comparison using object-centric process cubes. arxiv preprint
arxiv:2103.07184 , 2021.
[14] anahita farhang ghahfarokhi, gyunam park, alessandro berti, and
wil mp van der aalst. ocel: a standard for object-centric event logs. in
european conference on advances in databases and information systems ,
pages 169{175. springer, 2021.18 anahita farhang ghahfarokhi et al.
[15] e.l. lawler. combinatorial optimization: networks and matroids . courier
corporation, 2001.
[16] teemu lehto and markku hinkka. discovering business area eects to
process mining analysis using clustering and inuence analysis. in in-
ternational conference on business information systems , pages 236{248.
springer, 2020.
[17] xixi lu, marijn nagelkerke, dennis van de wiel, and dirk fahland. discov-
ering interacting artifacts from erp systems. ieee transactions on services
computing , 8(6):861{873, 2015.
[18] d. luengo and m. sep ulveda. applying clustering in process mining to nd
dierent versions of a business process that changes over time. in bpm ,
pages 153{158. springer, 2011.
[19] giovanni meroni, luciano baresi, marco montali, and pierluigi plebani.
multi-party business process compliance monitoring through iot-enabled
artifacts. information systems , 73:61{78, 2018.
[20] giovanni meroni, claudio di ciccio, jan mendling, et al. artifact-driven
process monitoring: dynamically binding real-world objects to running pro-
cesses. in caise 2017 forum , pages 105{112. ceur, 2017.
[21] e.h.j. nooijen, b.f. van dongen, and d. fahland. automatic discovery
of data-centric and artifact-centric processes. in bpm , pages 316{327.
springer, 2012.
[22] alexander seeliger, timo nolle, and max m uhlh auser. finding structure
in the unstructured: hybrid feature set clustering for process discovery. in
international conference on business process management , pages 288{304.
springer, 2018.
[23] m. song, c.w. g unther, and w.m.p. van der aalst. trace clustering in
process mining. in bpm , pages 109{120. springer, 2008.
[24] michelle taub, allison m banzon, tom zhang, and zhongzhou chen. track-
ing changes in students' online self-regulated learning behaviors and achieve-
ment goals using trace clustering and process mining. frontiers in psychol-
ogy, 13, 2022.
[25] w.m.p. van der aalst. data science in action. in process mining , pages
3{23. springer, 2016.
[26] g.m. veiga and d.r. ferreira. understanding spaghetti models with se-
quence clustering for prom. in bpm , pages 92{103. springer, 2009.
[27] philipp waibel, lukas pfahlsberger, kate revoredo, and jan mendling.
causal process mining from relational databases with domain knowledge.
arxiv preprint arxiv:2202.08314 , 2022.
[28] anton yeshchenko, claudio di ciccio, jan mendling, and artem
polyvyanyy. comprehensive process drift detection with visual analytics. in
international conference on conceptual modeling , pages 119{135. springer,
2019.
[29] f. zandkarimi, j.r. rehse, p. soudmand, and h. hoehle. a generic frame-
work for trace clustering in process mining. in icpm , pages 177{184. ieee,
2020.