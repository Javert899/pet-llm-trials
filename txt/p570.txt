process mining: a two-step approach to
balance between under¯tting and over¯tting
w.m.p. van der aalst1, v. rubin2;1, h.m.w. verbeek1, b.f. van dongen1,
e. kindler3, and c.w. gä unther1
1eindhoven university of technology,
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fw.m.p.v.d.aalst,h.m.w.verbeek,b.f.v.dongen,c.w.gunther g@tue.nl
2software design and management (sd&m ag),
o®enbach am main, germany.
vladimir.rubin@sdm.de
3technical university of denmark, informatics and mathematical modelling,
lyngby, denmark.
eki@imm.dtu.dk
abstract. process mining includes the automated discovery of pro-
cesses from event logs. based on observed events (e.g., activities being
executed or messages being exchanged) a process model is constructed.
one of the essential problems in process mining is that one cannot assume
to have seen all possible behavior . at best, one has seen a representative
subset. therefore, classical synthesis techniques are not suitable as they
aim at ¯nding a model that is able to exactly reproduce the log . existing
process mining techniques try to avoid such \over¯tting" by generalizing
the model to allow for more behavior. this generalization is often driven
by the representation language and very crude assumptions about com-
pleteness. as a result, parts of the model are \over¯tting" (allow only
what has actually been observed) while other parts may be \under¯t-
ting" (allow for much more behavior without strong support for it). none
of the existing techniques enables the user to control the balance between
\over¯tting" and \under¯tting". to address this, we propose a two-step
approach. first, using a con¯gurable approach, a transition system is
constructed. then, using the \theory of regions", the model is synthe-
sized. the approach has been implemented in the context of prom and
overcomes many of the limitations of traditional approaches.
1 introduction
more and more information about processes is recorded by information sys-
tems in the form of so-called \event logs". a wide variety of process-aware
information systems (paiss) [22] is recording excellent data on actual events
taking place. erp (enterprise resource planning), wfm (workflow manage-
ment), crm (customer relationship management), scm (supply chain man-
agement), and pdm (product data management) systems are examples of suchsystems. despite the omnipresence and richness of these event logs, most soft-
ware vendors use this information for answering only relatively simple questions
under the assumption that the process is ¯xed and known , e.g., the calculation
of simple performance metrics like utilization and °ow time. however, in many
domains processes are evolving and people typically have an oversimpli¯ed and
incorrect view of the actual business processes. therefore, process mining tech-
niques attempt to extract non-trivial and useful information from event logs.
one aspect of process mining is control-°ow discovery , i.e., automatically con-
structing a process model (e.g., a petri net) describing the causal dependencies
between activities [7, 8, 12, 16, 20, 21, 40]. the basic idea of control-°ow discov-
ery is very simple: given an event log containing a set of traces, automatically
construct a suitable process model \describing the behavior" seen in the log.
algorithms such as the ®-algorithm [7] construct a process model (in this case a
petri net) based on the identi¯cation of characteristic patterns in the event log,
e.g., one activity always follows another activity.
research on process mining started by analyzing the logs of wfm systems
[7, 8]. these systems have typically excellent logging facilities that allow for a
wide variety of process mining techniques. however, discovering the control-°ow
in such systems is less interesting because the process is controlled based on
an already known process model. moreover, wfm systems are just one type
of systems in a broad spectrum of systems recording events. to illustrate this,
we provide some examples of processes in non-work°ow environments that are
being recorded today:
{for many years, hospitals have been working towards a comprehensive elec-
tronic patient record (epr), i.e., information about the health history of
a patient, including all past and present health conditions, illnesses, and
treatments. although there are still many problems that need to be resolved
(mainly of a non-technical nature), many people forget that most of this
information is already present in today's hospital information systems. for
example, by dutch law all hospitals need to record the diagnosis and treat-
ment steps at the level of individual patients in order to receive payment.
this so-called \diagnose behandeling combinatie" (dbc) forces hospitals
to record all kinds of events.
{today, many organizations are moving towards a service-oriented architec-
ture (soa). a soa is essentially a collection of services that communicate
with each other. the communication can involve either simple data passing
or it could involve two or more services coordinating some activity. here,
technologies and standards such such as soap, wsdl, and bpel are used.
it is relatively easy to listen in on the message exchange between services.
this results in massive amounts of relevant information that can be recorded.
{increasingly, professional high-tech systems such as high-end copiers, com-
plex medical equipment, lithography systems, automated production sys-
tems, etc. record events which allow for the monitoring of these systems.
these raw event logs can be distributed via the internet allowing for bothreal-time and o®-line analysis. this information is valuable for (preventive)
maintenance, monitoring user adoption, etc.
{software development processes are supported by tools that record events
related to software artifacts. for example, software con¯guration manage-
ment (scm) systems such as cvs, subversion, sourcesafe, clear case, etc.
record the events corresponding to the commits of documents. the analy-
sis of such information may help to get more grip on the (often chaotic)
development processes.
{other examples can be found in the classical administrative systems of large
organizations using e.g. erp, crm, and pdm software. consider for exam-
ple processes in banks, insurance companies, local governments, etc. here
most activities are recorded in some form.
these examples illustrate that one can ¯nd a variety of event logs in today's
paiss. however, in most cases real processes are not as simple and structured as
the processes typically supported by wfm systems. most process mining algo-
rithms produce spaghetti-like diagrams that do not correspond to valid process
models (e.g., the models have deadlocks, etc.) and that do not provide useful
insights.
we have applied process mining in all of the areas mentioned above, e.g.,
our tool prom has been applied in several hospitals (amc and catherina hospi-
tals), banks (ing), high-tech system manufacturers (asml and philips medical
systems), software repositories for open-source projects, several municipalities
(heusden, alkmaar, etc.), etc. these experiences show that the main problem
is ¯nding a balance between \over¯tting" and \under¯tting". some algorithms
have a tendency to \under¯t", i.e., the discovered model allows for much more
behavior than actually recorded in the log. the reason for such over-generalizing
is often the representation used and a coarse completeness notion. other algo-
rithms have a tendency to \over¯t" the model. classical synthesis approaches
such as the \theory of regions" aim at a model that is able to exactly reproduce
the log. therefore, the model is merely another representation of the log without
deriving any new knowledge.
we aim at creating a balance between \over¯tting" and \under¯tting", there-
fore, we elaborate on these two notions. let lbe a log and mbe a model.
{mis over¯tting lifmdoes not generalize and is sensitive to particularities
inl. in an extreme case, mcould merely be a representation of the log
without any inference. a mining algorithm is producing over¯tting models
if the removal or addition of a small percentage of the process instances in
lwould lead to a remarkably di®erent model. in a complex process with
many possible paths, most process instances will follow a path not taken by
other instances in the same period. therefore, it is undesirable to construct
a model that allows only for the paths that happened to be present in the
log as this is only a fraction of all possible paths. if one knows that only
a fraction of the possible event sequences are in the log, the only way to
avoid over¯tting is to generalize and have a model mthat allows for more
behavior than recorded in l.{mis under¯tting lifmallows for \too much behavior" that is not sup-
ported by l. this is also referred to as \overgeneralization". it is very easy
to construct a model that allows for the behavior seen in the log but also
completely di®erent behavior. for example, assume a log lconsisting of
1000 cases. for each case ais followed by band there are no cases where b
is followed by a. obviously, one could derive a causal dependency between
aandb. however, one could also create a model mwhere aandbare in
parallel. the latter would not be \wrong" in the sense that the behavior seen
in the log is possible according to the model. however, it is very unlikely and
therefore one could argue that mis under¯tting l.
to illustrate the problem between over¯tting and under¯tting, consider some
process in a hospital. when observing such a process over a period of years it
is very likely that every individual patient follows a \unique process", i.e., seen
from the viewpoint of a particular patient it is very unlikely that there is another
patient that has exactly the same sequence of events. therefore, it does not make
sense to assume that the event log contains all possible paths a particular case can
take. in fact, it is very likely that the next patient will have a sequence of events
di®erent from all earlier patients. therefore, one cannot assume that an event
log is \complete" and one is forced to generalize to avoid over¯tting. however,
at the same time under¯tting (\anything is possible") should be avoided.
this paper will present a new type of process discovery which uses a two-step
approach: (1) we generate a transition system that is used as an intermediate
representation and (2) based on this we obtain a petri net constructed through
regions [9,10,14,15,23] as a ¯nal representation. transition systems are the most
basic representation of processes, but even simple processes tend to have many
states (cf. \state explosion" problem in veri¯cation). however, using the \theory
of regions" and tools like petrify [15], transition systems can be \folded" into
more compact representations, e.g., petri nets [17,34]. especially transition sys-
tems with a lot of concurrency (assuming interleaving semantics) can be reduced
dramatically through the folding of states into regions, e.g., transition systems
with hundreds or even thousands of states can be mapped onto compact petri
nets. however, before using regions to fold transition systems into petri nets,
we ¯rst need to derive a transition system from an event log. this paper shows
that this can be done in several ways enabling a repertoire of process discovery
approaches . di®erent strategies for generating transition systems are possible
depending on the desired degree of generalization, i.e., we will show that while
constructing the transition system it is possible to control the degree and nature
of generalization and thus allow the analyst to balance between \over¯tting" and
\under¯tting" .
the two-step approach presented in this paper has been implemented in
prom ( www.processmining.org ). prom serves as a testbed for our process min-
ing research [2]. for the second step of our approach prom calls petrify [15] to
synthesize the petri net.
the remainder of this paper is organized as follows. related work is discussed
in section 2. section 3 provides an overview of process mining and discussesproblems related to process discovery. section 4 introduces the approach by using
a real-life example. the ¯rst step of our approach is presented in section 5. here
it is shown that there are various ways to construct a transition system based on
a log. this results in a family of process mining techniques that assist in ¯nding
the balance between \over¯tting" and \under¯tting". the second step where
the transition system is transformed into a petri net is presented in section 6.
section 7 describes the implementation, evaluation, and application of our two-
step approach. section 8 concludes the paper.
2 related work
since the mid-nineties several groups have been working on techniques for pro-
cess mining [4, 7, 8, 12, 16, 20, 21, 40], i.e., discovering process models based on
observed events. in [6] an overview is given of the early work in this domain.
the idea to apply process mining in the context of work°ow management sys-
tems was introduced in [8]. in parallel, datta [16] looked at the discovery of
business process models. cook et al. investigated similar issues in the context
of software engineering processes [12]. herbst [26] was one of the ¯rst to tackle
more complicated processes, e.g., processes containing duplicate tasks.
most of the classical approaches have problems dealing with concurrency.
the®-algorithm [7] is an example of a simple technique that takes concurrency
as a starting point. however, this simple algorithm has problems dealing with
complicated routing constructs and noise (like most of the other approaches
described in literature). in [20, 21] a more robust but less precise approach is
presented.
in this paper we do not consider issues such as noise (cf. section 3.3). heuris-
tics [40] or genetic algorithms [3,31] have been proposed to deal with issues such
as noise. it appears that some of the ideas presented in [40] can be combined
with other approaches, including the one presented in this paper.
the second step in our approach uses the \theory of regions". in our approach
we use the so-called state-based regions as de¯ned in [9,10,14,15,23]. this way,
transition systems can be mapped onto petri nets using synthesis. initially, the
theory could be applied only to a restricted set of transition systems. how-
ever, over time the approach has been extended to allow for the synthesis from
any ¯nite transition system. in this paper, we use petrify [13] for this purpose.
the idea to use regions has been mentioned in several papers. however, only
recently people have been applying state-based regions to process mining [28].
it is important to note that the focus of regions has been on the synthesis of
models exactly reproducing the observed behavior (i.e., the transition system).
an important di®erence with our work is that we try to generalize and deduce
models that allow for more behavior, i.e., our approach supports the balancing
between \over¯tting" and \under¯tting". in our view, this is the most important
challenge in process mining research.
recently, some work on language-based regions theory appeared [11, 29, 30,
42]. in [11, 42] it is shown how this can be applied to process mining. theseapproaches are very interesting and directly construct a petri net. they are not
building an intermediate transition system. this has advantages, e.g., in terms
of e±ciency, but also disadvantages because the approach is less con¯gurable.
process mining can be seen in the broader context of business process in-
telligence (bpi) and business activity monitoring (bam). in [24, 38] a bpi
toolset on top of hp's process manager is described. the bpi toolset includes
a so-called \bpi process mining engine". in [33] zur muehlen describes the
pisa tool which can be used to extract performance metrics from work°ow
logs. similar diagnostics are provided by the aris process performance man-
ager (ppm) [27]. the tool is commercially available and a customized version
of ppm is the sta®ware process monitor (spm) [39] which is tailored towards
mining sta®ware logs. it should be noted that bpi tools typically do not allow
for process discovery and o®er relatively simple performance analysis tools that
depend on a correct a-priori process model. one of the few commercial tools that
supports process mining is the bpm jsuite of pallas athena. this tool is using
the ideas behind prom and integrates this into a bpm product.
an earlier version of this paper appeared as a technical report [5]. here addi-
tional examples are shown and the role of data/documents for state construction
is discussed in more detail.
3 process mining
this section introduces the concept of process mining and provides examples of
issues related to control-°ow discovery. it also discusses requirements such as
the need to produce correct models and to balance between models that are too
speci¯c or too generic.
3.1 overview of process mining
as indicated in the introduction, today's information systems are recording
events in so-called event logs. the goal of process mining is to extract infor-
mation on the process from these logs, i.e., process mining describes a family of
a-posteriori analysis techniques exploiting the information recorded in the event
logs. typically, these approaches assume that it is possible to sequentially record
events such that each event refers to an activity (i.e., a well-de¯ned step in the
process) and is related to a particular case (i.e., a process instance). further-
more, some mining techniques use additional information such as the performer
or originator of the event (i.e., the person / resource executing or initiating the
activity), the timestamp of the event, or data elements recorded with the event
(e.g., the size of an order).
process mining addresses the problem that most organizations have very
limited information about what is actually happening in their organization. in
practice, there is often a signi¯cant gap between what is prescribed or supposed
to happen, and what actually happens. only a concise assessment of the orga-
nizational reality, which process mining strives to deliver, can help in verifying
process models, and ultimately be used in a process redesign e®ort.models
analyzesrecords
events, e.g., 
messages,
transactions,
etc.specifies
configures
implements
analyzessupports/
controls
people machines
organizationscomponentsbusiness processesfig. 1. three types of process mining: (1) discovery, (2) conformance, and (3) exten-
sion.
the idea of process mining is to discover, monitor and improve real pro-
cesses (i.e., not assumed processes) by extracting knowledge from event logs. we
consider three basic types of process mining (figure 1):
{discovery : there is no a-priori model, i.e., based on an event log some
model is constructed. for example, using the ®-algorithm [7] a process model
can be discovered based on low-level events.
{conformance : there is an a-priori model. this model is used to check if
reality, as recorded in the log, conforms to the model and vice versa. for
example, there may be a process model indicating that purchase orders of
more than one million euro require two checks. another example is the
checking of the four-eyes principle. conformance checking may be used to
detect deviations, to locate and explain these deviations, and to measure
the severity of these deviations. an example, is the conformance checking
algorithms described in [37].
{extension : there is an a-priori model. this model is extended with a new
aspect or perspective, i.e., the goal is not to check conformance but to enrich
the model. an example is the extension of a process model with performance
data, i.e., some a-priori process model is used on which bottlenecks are pro-
jected. another example is the decision mining algorithm described in [36]
that extends a given process model with conditions for each decision.
today, process mining tools are becoming available and are being integrated
into larger systems. the prom framework [2] provides an extensive set of anal-
ysis techniques which can be applied to real process enactments while covering
the whole spectrum depicted in figure 1. aris ppm was one of the ¯rst com-
mercial tools to o®er some support for process mining. using aris ppm, one
can extract performance information and social networks. also some primitiveform of process discovery is supported. however, aris ppm still requires some
a-priori modeling. the bpm jsuite of pallas athena was the ¯rst commercial tool
to support process discovery without a-priori modeling. although the above tools
can already be applied to real-life processes, it remains a challenge to extract
suitable process models from event logs.
3.2 control-flow discovery
the focus of this paper is on control-°ow discovery , i.e., extracting a process
model from an event log. the event logs of various systems may look very di®er-
ent. some systems log a lot of information while other systems provide only very
basic information. in fact, in many cases one needs to extract event logs from
di®erent sources and merge them. tools such as our prom import framework
allows developers to quickly implement plug-ins that can be used to extract in-
formation from a variety of systems and convert this into the so-called mxml
format [25]. mxml encompasses timestamps (when the event took place), orig-
inators (which person or software component executed the corresponding ac-
tivity), transactional data, case data, etc. most of this information is optional,
i.e., if it is there, it can be used for process mining, but it is not necessary for
control-°ow discovery. the only requirement that we assume in this paper is
that any event needs to be linked to a case (process instance) and an activity .
assuming that only this information is available, an event is described by a pair
(c; a) where crefers to the case and arefers to the activity. in process mining,
one typically abstracts from dependencies between cases. hence, we assume that
each case is executed independently from other cases, i.e., the routing of one case
does not depend on the routing of other cases (although they may compete for
the same resources). as a result, we can focus on the ordering of activities within
individual cases . therefore, a single case ¾can be represented as a sequence of
activities, i.e., a trace ¾2a¤where ais the set of activities. consequently, a
log can be seen as a collection of traces (i.e., lµa¤).
ab
cd e
fig. 2. a log represented by sequences of activities and the process model that is
discovered using the ®-algorithm.figure 2 shows an example of a log and the corresponding process model
discovered using the ®-algorithm [7]. it is easy to see that the petri net is able
to reproduce the log, i.e., there is a good ¯t between the log and the discovered
process model.4note that the ®-algorithm is a very simple algorithm. unfortu-
nately, like many other algorithms, it has several limitations (cf. section 2).
as mentioned earlier, existing process mining algorithms for control-°ow dis-
covery typically have several problems. using the example shown in figure 2,
we can discuss these problems in a bit more detail.
the ¯rst problem is that many algorithms have problems with complex
control-°ow constructs . for example, the choice between the concurrent execu-
tion of bandcor the execution of just eshown in figure 2 cannot be handled
by many algorithms. most algorithms do notallow for so-called \non-free-choice
constructs" where concurrency and choice meet. the concept of free-choice nets
is well-de¯ned in the petri net domain [17]. however, in reality processes tend
to be non-free-choice. in the example of figure 2, the ®-algorithm is able to deal
with the non-free-choice construct. however, it is easy to think of a non-free-
choice process that cannot be discovered by the ®-algorithm. the non-free-choice
construct is just one of many constructs that existing process mining algorithms
have problems with. other examples are arbitrary nested loops, unbalanced splits
and joins, partial synchronization, etc. in this context it is important to note that
process mining is, by de¯nition, restricted by the expressive power of the target
language , i.e., if a simple or highly informal language is used, process mining is
destined to produce less relevant or over-simpli¯ed results.
the second problem is the fact that most algorithms have problems with
duplicates . the same activity may appear at di®erent places in the process or
di®erent activities may be recorded in an indistinguishable manner. consider for
example figure 2 and assume that activities aanddare both recorded as x
(or, equivalently, assume that aanddare both replaced by activity x). hence
the trace abcd in the original model is recorded as xbcx . most algorithms
will try to map the ¯rst and the second xonto the same activity. in some
cases this make sense, e.g., to create loops. however, if the two occurrences of
x(i.e., aandd) really play a di®erent role in the process, then algorithms
that are unable to separate them will run into all kinds of problems, e.g., the
model becomes more di±cult or incorrect. since the duplicate activities have the
same \footprint" in the log, most algorithms map these di®erent activities onto
a single activity thus making the model incorrect or counter-intuitive.
the third problem is that many algorithms have a tendency to generate
inconsistent models . note that here we do not refer to the relation between the
log and the model but to the internal consistency of the model by itself. for
example, the ®-algorithm may yield models that have deadlocks or livelocks
when the log shows certain types of behavior. when using petri nets as a model
to represent processes, an obvious choice is to require the model to be sound [1].
soundness implies that for any case: (1) the model can potentially terminate
4in this paper, we assume that the reader has a basic understanding of petri nets,
cf. [17,19,34].from any reachable state (option to complete), (2) that the model has no dead
parts, and (3) that no tokens are left behind (proper completion). see [1,7] for
details.
the fourth and last problem described here is probably the most important
problem: existing algorithms have problems balancing between \over¯tting" and
\under¯tting" . over¯tting is the problem that a very speci¯c model is generated
while it is obvious that the log only holds example behavior, i.e., the model
explains the particular sample log but a next sample log of the same process
may produce a completely di®erent process model. under¯tting is the problem
that the model over-generalizes the example behavior in the log, i.e., the model
allows for very di®erent behaviors from what was seen in the log. the problem
of balancing between \over¯tting" and \under¯tting" is related to the notion of
completeness assumed. this will be discussed in more detail in the next subsec-
tion.
the four problems just mentioned illustrate the need for more powerful algo-
rithms. see also [32] for a more elaborate discussion on these and other challenges
in control-°ow discovery.
3.3 notions of completeness
when it comes to process mining the notion of completeness is very important.
like in any data mining or machine learning context one cannot assume to have
seen all possibilities in the \training material" (i.e., the event log at hand). in
figure 2, the set of possible traces found in the log is exactly the same as the set
of possible traces in the model, i.e., fabcd; acbd; aed g. in general, this is
not the case. for example, the trace abecd may be possible but did not (yet)
occur in the log.
to de¯ne the concept of completeness assume that there is a model correctly
describing the process being observed. let lbe the set of traces in some event log
andlmthe set of all traces possible according to the model. clearly, lµlm.
ifl=lm, the log is trivially complete. however, as indicated above one can
never assume l=lmbecause, typically, jljis much smaller than jlmj. for a
model with lots of choices and concurrency jljis a fraction of jlmj. therefore,
it makes no sense to de¯ne completeness as jlj=jlmj. therefore, other criteria
are needed to describe how \complete" a log is. for example, the ®-algorithm [7]
assumes that the log is \locally complete", i.e., if there are two activities x
andy, and xcan be directly followed by ythis should be observed in the
log. other completeness notions are possible and based on these notions one can
reason about the correctness of a mining algorithm [7].
to illustrate the relevance of completeness, consider 10 tasks which can be
executed in parallel. the total number of interleavings is 10! = 3628800 (i.e.,
jlmj= 3628800). it is probably not realistic that each interleaving is present in
the log, since typically jlj<<jlmj. moreover, even if jljandjlmjare of the
same order of magnitude, it is still very unlikely that l=lm. to motivate this
consider the following analogy. in a group of 365 people it is very unlikely that
everyone has a di®erent birthdate (365! =365365). similarly, it is unlikely thatall possible traces will occur for process of some complexity. however, for local
completeness as assumed by the ®-algorithm [7] only 10(10 ¡1) = 90 di®erent
observations are needed.
ab
c
d estart end
fig. 3. the so-called \°ower petri net" allowing for any log containing a,b,c,d,
ande.
completeness is closely linked to the notions of over¯tting andunder¯tting
mentioned earlier. it is also linked to occam's razor, a principle attributed to the
14th-century english logician william of ockham. the principle states that \one
should not increase, beyond what is necessary, the number of entities required
to explain anything", to look for the \simplest model" that can explain what is
in the log. using this principle di®erent algorithms assume di®erent notions of
completeness.
process mining algorithms needs to strike a balance between \over¯tting" and
\under¯tting". a model is over¯tting if it does not generalize and only allows
for the exact behavior recorded in the log. this means that the corresponding
mining technique assumes a very strong notion of completeness: \if the sequence
is not in the event log, it is not possible.". an under¯tting model over-generalizes
the things seen in the log, i.e., it allows for more behavior even when there are no
indications in the log that suggest this additional behavior. an example is shown
in figure 3. this so-called \°ower petri net" allows for any sequence starting
with start and ending with endand containing any ordering of activities a,
b,c,d, and ein between. clearly, this model allows for the set of traces
fabcd; acbd; aed g(without the added start andendactivities) but also
many more, e.g., ddaa , without much evidence that they should be possible.
let us now consider another example showing that it is di±cult to balance
between being too general and too speci¯c. figure 4 shows two event logs and
two models. both logs are possible according to the model shown in (d), i.e.,
model (d) may have produced logs (a) and (b). however, log (b) is notpossible
according to the model shown in (c) because this model does not allow for ace
andbcd present in log (b). clearly, (c) seems to be a suitable model for (a),
and (d) seems to be a suitable model for (b). however, the question is whether
(d) is also a suitable model for (a). if the log consists of just two cases acd
andbce, then there is no reason to argue why (d) would not be a suitablea d
c
e b
a d
c
e b(a)
(b)(c)
(d)fig. 4. two logs and two models illustrating issues related to completeness (i.e., \over-
¯tting" and \under¯tting").
model (although (d) allows for more behavior). however, if there are 100 cases
following acd and 100 cases bce, then it is di±cult to justify (d) as a suitable
model. it would be very unlikely that ace andbcd never occurred in one of
the 200 cases and hence (c) seems more appropriate.
figure 4 shows that there is a delicate balance and that it is non-trivial to
compare logs and process models. in [35] notions such as ¯tness andappropri-
ateness have been quanti¯ed. an event log and petri net \¯t" if the petri net
can generate each trace in the log.5in other words: the petri net should be
able to \parse" (i.e., reproduce) every activity sequence observed. in [35] it is
shown that it is possible to quantify ¯tness as a measure between 0 and 1. the
intuitive meaning is that a ¯tness close to 1 means that all observed events can
be explained by the model. however, the precise meaning is more involved since
tokens can remain in the net and not all transactions in the model need to be
logged [35]. unfortunately, a good ¯tness alone does not imply that the model
is indeed suitable, e.g., it is easy to construct petri nets that are able to repro-
duce any event log (cf. the \°ower model" in figure 3). although such petri
nets have a ¯tness of 1, they do not provide meaningful information. therefore,
in [35] a second dimension is introduced: appropriateness . appropriateness tries
to answer the following question: \does the model describe the observed pro-
cess in a concise way?". this notion can be evaluated from both a structural
and a behavioral perspective. in [35] it is shown that a \good" process model
should somehow be minimal in structure to clearly re°ect the described behav-
ior, referred to as structural appropriateness , and minimal in behavior in order
to represent as closely as possible what actually takes place, which will be called
5it is important not to confuse ¯tness with over¯tting andunder¯tting . a model that
is over¯tting or under¯tting may have a ¯tness of 1.behavioral appropriateness . the prom conformance checker supports both the
notion of ¯tness and various notions of appropriateness, i.e., for a given log and
a given model it computes the di®erent metrics.
although there are di®erent ways to quantify notions such as ¯tness and
appropriateness, it is di±cult to agree on the de¯nition of an \optimal model".
what is optimal seems to depend on the intended purpose and even given a
clear metric there may be many models having the same score. since there is
not \one size ¯ts all", it is important to have algorithms that can be tuned to
speci¯c applications. therefore, we present an approach that allows for di®erent
strategies enabling di®erent interpretations of completeness to avoid over¯tting
and under¯tting.
linked to notions such as completeness, over¯tting, and under¯tting is the
issue of noise . the log may contain traces that one would like to refer to as noise,
e.g., incorrectly logged events (i.e., the log does not re°ect reality) and exceptions
(i.e., sequences of events corresponding to \abnormal behavior"). the fact that
a particular trace of events is observed does not automatically mean that the
model should be able to reproduce it. noise is typically tackled by cleaning the
log and setting thresholds [3, 31, 40]. this paper will not address issues related
to noise. however, existing ideas for dealing with noise [3, 31, 40] can easily be
combined with the approach presented here.
4 approach
in the previous section, we used rather academic examples to illustrate issues
related to completeness and the need to balance between over¯tting and under-
¯tting. however, it is important to realize that these issues are of the utmost
importance when applying process mining in a real-life setting. we have been
applying process mining in a wide variety of organizations and were often con-
fronted with spaghetti-like models when applying classical process mining ap-
proaches. these models where typically the result of over¯tting, i.e., the models
were a correct re°ection of reality, but not very useful.
to illustrate this we show some results based on an event log of the munici-
pality of heusden. the event log is based on the process \bezwaar woz". this
process handles objections (i.e., appeals) against the real-estate property valua-
tion or the real-estate property tax. we used an event log with data on 1982 ob-
jections handled by the municipality of heusden. the log contains 12726 events.
because the actual activity names are not relevant for our discussion here (and
because of reasons of con¯dentiality), we anonymized the process and replaced
names by letters.
figure 5 shows two petri nets. the spaghetti-like model was obtained by
applying a simple process mining algorithm where it is assumed that the state of
a case is determined by the sequence of activities that have taken place. the petri
net is able to reproduce the event log, i.e., all observed traces can be reproduced
and the model does not allow for any traces not present in the original event
log. so the model is de¯nitely \correct" but not very useful as it does not givefig. 5. two models discovered using an event log of the municipality of heusden.
although both models are based on the same log and provide information on the
same set of activities, they are very di®erent. the \spaghetti-like model" is clearly
over¯tting, di±cult to interpret, and, therefore, not very useful. the smaller model
is obtained after applying one of the abstractions proposed in this paper. this more
simple model provides better insights.much insight into the municipality's appeal process. the second (smaller) petri
net was obtained using the same log. however, it uses the abstraction that the
state of a case is determined by only the last activity that has taken place (if
any). this simpler petri net is able to reproduce the event log, i.e., all observed
traces can be generated by the net. however, the model also allows for traces
not present in the original log.
it should be noted that both models in figure 5 provide information on
identical sets of activities, i.e., the scope is not changed. both models are able to
reproduce the initial log and no noise or infrequent behavior has been removed
in the smaller model.
figure 5 convincingly shows the need for abstraction. although existing pro-
cess mining techniques are using some form of abstraction, the level and nature
of the abstraction cannot be controlled or adapted. therefore, we propose a two
step approach:
{in the ¯rst step (section 5), we construct a transition system. while con-
structing the transition system we can choose from various abstractions. we
will identify ¯ve abstractions, including the one used to simplify the model
in figure 5. moreover, as we will show, the set of abstractions can be easily
extended.
{in the second step (section 6), we transform the transition system into a
process model. this step is needed because the transition system is not able
to show concurrency and parallel branches typically result in an explosion
of states making the transition system unreadable. hence, the goal of the
second step is to provide a compact representation of the selected behavior.
in our approach we are generating a petri net using the theory of regions,
but in principle any representation with and/xor-splits/joins could be
used.
note that the ¯rst step is mainly concerned with abstraction, while the second
step is mainly concerned with representation issues. in the remainder, we present
the two steps in detail.
5 constructing a transition system (step 1)
after introducing the concept of control-°ow discovery and discussing the prob-
lems of existing approaches, we can now explain the ¯rst step of our approach.
an important quality of the ¯rst step is that, unlike existing approaches, it can
be tuned towards the application. depending on the desired properties of the
model and the characteristics of the log, the algorithm can be tuned to provide
a more suitable model.
5.1 preliminaries
to explain the di®erent strategies for constructing transition systems from event
logs, we need the following notations.f2a!bis a function with domain aand range b.f2a6!bis a partial
function, i.e., the domain of fmay be a subset of a.
amulti-set (also referred to as bag) is like a set where each element may occur
multiple times. for example, fa; b2; c3; dgis the multiset with seven elements:
onea, two b's, three c's, and one d.
i b(a) =a!i n is the set of multi-sets (bags) over a ¯nite domain a, i.e.,
x2i b(a) is a multi-set, where for each a2a:x(a) denotes the number of times
ais included in the multi-set. for example, if x=fa; b2; c3; dg, then x(b) = 2
andx(e) = 0. the sum of two multi-sets ( x+y), the di®erence ( x¡y), the
presence of an element in a multi-set ( x2x), and the notion of subset ( x·y)
are de¯ned in a straightforward way. for example, fa; b2; c3; dg+fc3; d; e2; f3g=
fa; b2; c6; d2; e2; f3g. moreover, we also apply these operators to sets, where we
assume that a set is a multiset in which every element occurs exactly once. the
operators are also robust with respect to the domains of the multi-sets, i.e., even
ifxandyare de¯ned on di®erent domains, x+y,x¡y, and x·yare
de¯ned properly by extending the domain where needed. jxj=p
a2ax(a) is
the cardinality of some multi-set xovera.set(x) transforms a bag xinto a
set:set(x) =fa2xjx(a)>0g.
p(a) is the powerset of a, i.e.,p(a) =fxjxµag.
for a given set a,a¤is the set of all ¯nite sequences over a. a ¯nite se-
quence over aof length nis a mapping ¾2 f1; : : : ; n g !a. such a sequence is
represented by a string, i.e., ¾=ha1; a2; : : : ; a niwhere ai=¾(i) for 1 ·i·n.
hdk(¾) =ha1; a2; : : : ; a kmin ni, i.e., the sequence consisting of the ¯rst kel-
ements (if possible). note that hd0(¾) is the empty sequence and for k¸n:
hdk(¾) =¾.tlk(¾) =ha(n¡k+1)max 1; ak+2; : : : ; a ni, i.e., sequence composed of
the last kelements (if possible). note that tl0(¾) is the empty sequence and for
k¸n:tlk(¾) =¾.¾"xis the projection of ¾onto some subset xµa, e.g.,
ha; b; c; a; b; c; d i " fa; bg=ha; b; a; b iandhd; a; a; a; a; a; a; d i " fdg=hd; di.
for any sequence ¾overa, the parikh vector par(¾) maps every element a
ofaonto the number of occurrences of ain¾, i.e., par(¾)2i b(a) where for
anya2a:par(¾)(a) =j¾" fagj.
later, we will use the parikh vector to count the number of times an activity
occurs in a log trace.
5.2 basic approach
although an event log can store transactional information, information about
resources, related data, timestamps, etc. we ¯rst focus on the ordering of activ-
ities. cases are executed independently from each other, and therefore, we can
simply restrict our input to the ordering of activities within individual cases. a
single case is described as a sequence of activities and a log can be described as
a set of traces6.
6note that we ignore multiple occurrences of the same trace in this paper. when
dealing with issues such as noise, it is vital to also look at the frequency of activities
and traces. therefore, an event log is typically de¯ned as a multi-set of traces rather
than a set. however, for the purpose of this paper it su±ces to consider sets.de¯nition 1 (simple trace, simple event log). letabe a set of activities.
¾2a¤is a (simple) trace andl2 p(a¤)is a (simple) event log .
the reason that we call ¾2a¤asimple trace and l2 p(a¤) asimple
event log is that we initially assume that an event only refers to the activity
being executed. in section 5.4 we will re¯ne this view and include attributes
describing other perspectives (e.g., data, time, resources, etc.).
the set of activities can be found by inspecting the log. however, the most
important aspect of process discovery is deducing the states of the operational
process in the log . most mining algorithms have an implicit notion of state,
i.e., activities are glued together in some process modeling language based on an
analysis of the log and the resulting model has a behavior that can be represented
as a transition system. in this paper, we propose to de¯ne states explicitly and
start with the de¯nition of a transition system.
in some cases, the state can be derived directly, e.g., each event encodes the
complete state by providing values for all relevant data attributes. however, in
the event log we typically only see activities and not states. hence, we need
to deduce the state information from the activities executed before and after
a given state. based on this, there are basically three approaches to de¯ne the
state of a partially executed case in a log:
{past, i.e., the state is constructed based on the history of a case,
{future , i.e., the state of a case is based on its future, or
{past and future , i.e., a combination of the previous two.
past futurecurrent state
past and future
fig. 6. three basic \ingredients" can be considered as a basis for calculating the \pro-
cess state": (1) past, (2) future, and (3) past and future.
figure 6 shows an example of a trace and the three di®erent \ingredients"
that can be used to calculate state information. given a concrete trace, i.e.,
the execution of a case from beginning to end, we can look at the state after
executing the ¯rst nine activities. this state can be represented by the pre¯x,
the post¯x, or both.
to explain the basic idea of constructing a transition system from an event
log, consider figure 7. here we start from the same log as used in figure 2. ifwe just consider the pre¯x (i.e., the past), we get the transition system shown
in figure 7(a). note that the initial state is denoted hi, i.e., the empty sequence.
starting from this initial state the ¯rst activity is always ain each of the traces.
hence, there is one outgoing arc labeled a, and the subsequent state is labeled
hai. from this state, three transitions are possible that lead to di®erent states,
e.g., executing activity bresults in state ha; bi, etc. note that in figure 7(a)
there is one initial state and three ¯nal states. figure 7(b) shows the transition
system based on post¯xes. here the state of a case is determined by its future.
this future is known because process mining looks at the event log containing
completed cases. now there are three initial states and one ¯nal state. initial
stateha; e; d iindicates that the next activity will be a, followed by eandd.
note that the ¯nal state has label hiindicating that no activities need to be
executed. figure 7(c) shows a transition system based on both past and future.
the node with label \ ha; bi,hc; di" denotes the state where aandbhave
happened and canddstill need to occur. note that now there are three initial
states and three ¯nal states.
the past of a case is a pre¯x of the complete trace. similarly, the future of a
case is a post¯x of the complete trace. this may be taken into account completely,
which leads to many di®erent states and process models that may be too speci¯c
(i.e., \over¯tting" models). however, many abstractions are possible as shown
below. the abstractions can be applied to pre¯xes, post¯xes, or both.
abstraction 1: maximal horizon ( h)the basis of the state calculation can
be the complete pre¯x (post¯x) or a partial pre¯x (post¯x). in the later case, only
a subset of the trace is considered. for example, instead of taking the complete
pre¯x ha; b; c; d; c; d; c; d; e ishown in figure 6, only the last four ( h= 4)
events could considered: hd; c; d; e i. in a partial pre¯x, only the hmost recent
events are considered as input for the state calculation. in a partial post¯x, also
a limited horizon is considered, i.e., seen from the state under consideration,
only the next hevents are taken into account. taking a complete pre¯x (post¯x)
corresponds to h=1.
abstraction 2: filter ( f)the second abstraction is to ¯lter the (partial)
pre¯x and/or post¯x, i.e., activities in fµaare kept while activities anfare
removed. filtering can be seen as projecting the horizon onto a set of activities
f. for example, if f=fc; dg, then the pre¯x ha; b; c; d; c; d; c; d; e ishown
in figure 6 is reduced to hc; d; c; d; c; d i. note that the ¯ltering is applied to
the sequence resulting from the horizon. it is also possible to ¯rst ¯lter the log,
but we consider this to be part of the preprocessing of the log and not part of
the mining algorithm itself. the occurrence of some activity a2fis considered
relevant for the state of a case. if a62f, then the occurrence of ais still relevant
for the process (i.e., it may appear on the arcs in the transition system) but is
assumed to be irrelevant for determining the state. if ais not relevant at all, it
should be ¯ltered out before and should not appear in l.abcd
acbd
aed
abcd
abcd
aed
acbd
...
(b) transition system based on postfix<>a<a> <a,e>e<a,e,d>d<a,b>
b<a,b,c>c<a,b,c,d>d
<a,c> <a,c,b>b<a,c,b,d>dc
<a,b,c,d>a<b,c,d>
<a,e,d> <e,d>
<a,c,b,d>a
a<c,b,d><d>e<c,d>
<b,d>b
cc
b<>d
<>
<a,b,c,d>a <a>
<b,c,d>
<>
<a,e,d><a>
<e,d>
<>
<a,c,b,d>a
a <a>
<c,b,d><a,e>
<d>e<a,b>
<c,d>
<a,c>
<b,d>b
c<a,e,d>
<>d
<a,c,b>
<d>b<a,b,c>
<d>c <a,b,c,d>
<>d
<a,c,b,d>
<>d
(c) transition system based on prefix and postfix(a) transition system based on prefixfig. 7. three transition systems derived from the log.abstraction 3: maximum number of ¯ltered events ( m)the sequence
resulting after ¯ltering may contain a variable number of elements. again one can
determine a kind of horizon for this ¯ltered sequence. the number mdetermines
the maximum number of ¯ltered events. consider the pre¯x ha; b; c; d; c; d; c
; d; eishown in figure 6. suppose that h= 6, then the ¯rst abstraction yields
hd; c; d; c; d; e i. suppose that f=fc; eg, then the second abstraction yields
hc; c; e i. suppose that m= 2, then the third abstraction yields hc; ei. note
that there is a di®erence between handm. ifh= 2, f=fc; eg, and m= 6,
then the result is heirather than hc; ei. note that m=1implies that no
events are removed by this third abstraction.
abstraction 4: sequence, bag, or set ( q)the ¯rst three abstractions yield
a sequence. the fourth abstraction mechanism optionally removes the order or
frequency from the resulting trace. for the current state it may be less interesting
to know when some activity aoccurred and how many times aoccurred, i.e., only
the fact that it occurs within the scope determined by the ¯rst three abstractions
is relevant. in other cases, it may be relevant to know how many times aoccurred
or it may be essential to know whether aoccurred before bor not. this suggests
that there are three ways of representing knowledge about the past and the
future:
{sequence , i.e., the order of activities is recorded in the state,
{multi-set of activities , i.e., the number of times each activity is executed
ignoring their order, and
{set of activities , i.e., the mere presence of activities.
consider again the pre¯x ha; b; c; d; c; d; c; d; e iand suppose that h=1,
f=a, and m=1, then the fourth abstraction step yields ha; b; c; d; c; d; c;
d; ei(sequence), fa; b; c3; d3; eg(multiset), and fa; b; d; e g(set). we will
denote this abstraction using the identi¯er q, i.e., q=seq(sequence), q=ms
(multiset), or q=set(set).
abstraction 5: visible activities ( v)the ¯fth abstraction is concerned with
the transition labels. activities in vµaare shown explicitly on the arcs while
the activities in anvare not shown. note that the arcs are not removed from
the transition system; only the label on the arc is suppressed. this abstraction
is particularly useful if there are many activities having a similar e®ect in terms
of changing states. rather than having many arcs from one state to another,
these are then collapsed into a single unlabeled arc.
figure 8 illustrates the abstractions. in figure 8(a) only the set abstraction is
used q=set. the result is that several states are merged (compare with fig-
ure 7(a)). in figure 8(b) activities bandcare ¯ltered out (i.e., f=fa; d; e g
andv=fa; d; e g). moreover, only the last non-¯ltered event is considered for
constructing the state (i.e., m= 1). note that the states in figure 8(b) refer
to the last event in fa; d; e g. therefore, there are four states: hai,hdi,hei,abcd
acbd
aed
abcd
abcd
aed
acbd
...{}a{a} {a,c}c{a,b}
b{a,b,c}c{a,b,c,d}d
{a,e} {a,d,e}de
(a) transition system based on setsb
<>a<a> <d>d<e>
e
(b) transition system abstracting from b and cdfig. 8. two transition systems using the following pre¯x abstractions: (a) h=1,
f=a(i.e., all activities), m=1,q=set, and v=a, and (b) h=1,f=fa; d; e g,
m= 1,q=seq, and v=fa; d; e g.
andhi. it is interesting to consider the role of bandc. first of all, they are
not considered for building the state ( f=fa; d; e g). second, they are also not
visualized ( v=fa; d; e g), i.e., the labels are suppressed. the corresponding
transitions are collapsed into the unlabeled arc from haitohai. ifvwould have
included bandc, there would have been two such arcs labeled brespectively
c.
the ¯rst four abstractions can be applied to the pre¯x, the post¯x, or both.
in fact, di®erent abstractions can be applied to the pre¯x and post¯x while the
last abstraction is applied to the resulting transition system. as a result of these
choices, many di®erent transitions systems can be generated. if more abstractions
are used, the number of states will be smaller and the danger of \under¯tting"
is present. if, on the other hand, fewer abstractions are used, the number of
states may be larger resulting in an \over¯tting" model. an extreme case of
over¯tting was shown in figure 7(c) where each trace is presented separately
without deducing control-°ow constructs. in fact, all of the abstractions used
in figure 7 will lead to over¯tting because the whole pre¯x and/or post¯x is
considered.
at ¯rst it may seem confusing that there are multiple process models that can
be deduced based on the same log, however, as indicated in the introduction itis important to provide a repertoire of process discovery approaches. depending
on the desired degree of generalization, suitable abstractions are selected and
in this way the analyst can balance between \over¯tting" and \under¯tting" in
a controlled way. existing approaches do not allow the analyst to control the
degree and nature of abstraction, i.e., the degree of generalization is ¯xed by the
method.
5.3 formalization basic approach
let us now further formalize the ideas presented so far. for this purpose, we ¯rst
take a broader perspective and then focus on the concrete abstractions discussed
thus far.
to determine the states of the transition system, we need to construct a so-
called state representation based on the ¯rst four abstractions and the choice of
pre¯x and post¯x.
de¯nition 2 (state representation). a state representation function state ()
is a function that, given a sequence ¾and a number kindicating the number
of events of ¾that have occurred, produces some representation r. formally,
state2(a¤£i n)6!rwhere ais the set of activities, ris the set of possible
state representations (e.g., sequences, sets, or bags over a), and dom (state) =
f(¾; k)2a¤£i nj0·k· j¾jg.
based on the notion of a state() function, we can de¯ne the transition system.
in this de¯nition we use a renaming function jvthat renames invisible activities
to¿:jv(a) =aifa2vandjv(a) =¿otherwise. such transitions are not
labeled in the diagram, e.g., see figure 8(b) where the bandclabels are not
shown.
de¯nition 3 (transition system). letabe a set of activities and let l2
p(a¤)be an event log . given a state ()function as de¯ned before and a set of
visible activities vµa, we de¯ne a labeled transition system ts= (s; e; t )
where s=fstate(¾; k)j¾2l^0·k· j¾jgis the state space, e=v[ f¿g
is the set of events (labels) and tµs£e£switht=f(state(¾; k); jv(¾(k+
1));state(¾; k+ 1))j¾2l^0·k <j¾jgis the transition relation. sstartµs
is the set of initial states, i.e., sstart=fstate(¾;0)j¾2lg.sendµsis the
set of ¯nal states, i.e., send=fstate(¾;j¾j)j¾2lg.
the set of states of the transition system is determined by the range of function
state() when applied to the log data. the transitions in the transition system
have a label in e=v[ f¿g. note that vis the set of visible activities and ¿
refers to activities made \invisible" in the transition system.
the algorithm for constructing a transition system is straightforward: for
every trace ¾, iterating over k(0·k· j¾j), we create a new state state(¾; k)
if it does not exist yet. then the traces are scanned for transitions state(¾; k¡1)jv(¾(k))¡! state(¾; k) and these are added if they do not exist yet7. recall that,
ifjv(¾(k)) =¿, then the label is not shown in the diagram.
so given a state() function and a set of visible activities vit is possible to
automatically build a transition system. this was already illustrated in figure 8
which shows two examples using the same log but di®erent choices for state()
andv.
let us now consider the construction of di®erent state() functions. to this
end, this we introduce some notations. first, we show how to obtain the past
and future of a case ¾after ksteps.
de¯nition 4 (past and future of a case). letabe a set of activities and
let¾=ha1; a2; : : : ; a ni 2a¤be a trace that represents a complete execution of
a case. the past of this case after executing ksteps ( 0·k·n) is hdk(¾). the
future of this case after executing ksteps ( 0·k·n) is tln¡k(¾). the past and
future are denoted as a pair: (hdk(¾);tln¡k(¾)).
note that ¾=hdk(¾)tln¡k(¾), i.e., the concatenation of past and future yields
the whole trace.
let us now consider the ¯rst four abstractions presented in section 5.2. for
simplicity, we ¯rst focus on the past of a case. let ¾0=hdk(¾) be the complete
pre¯x of some case ¾after ksteps.
the ¯rst abstraction presented in section 5.2 can be tackled using function
tl. recall that this abstraction sets a horizon of length h. assuming a horizon
h, the result of this ¯rst abstraction is ¾1=tlh(¾0). the second abstraction can
be tackled using the projection operator "de¯ned earlier. assuming a ¯lter f,
the result of this second abstraction is ¾2=¾1"f. the third abstraction sets
a maximum to the number of ¯ltered events to be considered. again function
tlcan be used. assuming a maximum m, the result of this third abstraction is
¾3=tlm(¾2). the fourth abstraction is based on q. recall that there are three
possible values: q=seq(sequence), q=ms(multiset), or q=set(set). hence,
we take the sequence ¾3resulting from the ¯rst three abstractions and use ¾3
(no abstraction), par(¾3) (i.e., construct a multi-set and remove the ordering)
orset(par(¾3)) (i.e., construct a set and remove both ordering and frequencies).
now we can formalize examples of state() functions. for example, consider
figure 8(a) where h=1,f=a,m=1,q=set. in this case, state(¾; k) =
set(par(tl1(tl1(hdk(¾))"a))). this can be simpli¯ed to state(¾; k) =set(par(
hdk(¾)"a)). in figure 8(b), where h=1,f=fa; d; e g,m= 1, and
q=seq, the function is state(¾; k) =tl1(tl1(hdk(¾))" fa; d; e g). using these
twostate() functions and the corresponding vvalues, the two transition systems
shown in figure 8 can be obtained by simply applying de¯nition 3.
the examples so far have focused on the past of a case (i.e., pre¯xes). a
similar approach can be used for post¯xes (i.e., future). in this situation ¾0=
tln¡k(¾) is the complete post¯x of some case ¾of length nafter ksteps. the ¯rst
abstraction presented in section 5.2 can be tackled using function hd. assuming
7note that the elements of tare often denoted as s1e!s2instead of ( s1; e; s 2).abcd
acbd
aed
abcd
abcd
aed
acbd
...{a}a{c} {d}c{b}
a b
{ }d
{e}eacbfig. 9. a transition system constructed based on the future of a case (post¯x) with
abstractions h=1,f=a(i.e., all activities), m= 1,q=set, and v=a.
a horizon h, is results in ¾1=hdh(¾0). assuming a ¯lter f, the result of the
second abstraction is ¾2=¾1"f. the third abstraction sets a maximum to the
number of ¯ltered events: ¾3=hdm(¾2) the fourth abstraction take is identical
to using a pre¯x, i.e., ¾3,par(¾3) orset(par(¾3)). figure 9 shows an abstraction
based on the post¯x and m= 1 (i.e., at most one ¯ltered event is considered).
if both the past and future are used, then for both pre¯x and post¯x an
abstraction needs to be selected and the state is then determined by pairing
both abstractions. for example, state(¾; k) = ( par(tl1(tl2(hdk(¾))" fa; bg));
set(par(hd2(hd1(tln¡k(¾))" fb; c; d g)))).
5.4 extensions
we have now introduced and formalized the basic approach to construct a transi-
tion system based on an event log. the next step is to transform this transition
system into a process model. however, before discussing the second step, we
¯rst discuss two types of extensions of the basic approach. to avoid an overkill
of notations, we only present these extensions informally.
massaging the transition system the ¯rst type of extensions is related to
\massaging" the transition system after it is generated. this is intended to \pave
the path" for the second step. for example, one may remove all \self-loops", i.e.,
transitions of the form sa!s(cf. figure 10(a)). the reason may be that one
is not interested in events that do not change the state or that the synthesis
algorithm in the second step cannot handle this. another example would be to
close all \diamonds", i.e., if s1a1!s2,s1a2!s3, and s2a2!s4, then s3a1!s4
is added (cf. figure 10(b)). the reason for doing so may be that because (1)
both a1anda2are enabled in s1and (2) after doing a1, activity a2is still
enabled, it is assumed that a1anda2can be executed in parallel. although the
sequence ha2; a1iwas not observed, it is assumed that this is possible and hence
the transition system is extended by adding s3a1!s4.s1
s2 s3
s4s1
s2 s3
s4a1 a2
a2a1 a2
a2 a1
(a) closing the “diamond”s
(a) removing self-loopsasfig. 10. two examples of modi¯cations of the transition system to aid the construction
of the process model.
incorporating other perspectives the second type of extensions is related
to the input, i.e., the \richness" of the event log. in de¯nition 1, a simple log
was assumed, i.e., a case is described as a sequence of activities and a log is
a set of such simple sequences. in reality, one knows much more about events.
most information systems do not just record the ordering of activities but also
timestamps and information about resources, data, transactional information,
etc.
de¯nition 5 (trace, event log). letebe a set of events. based on ethere
is a set of pproperties :fprop1; : : :proppg. each property is a function with a
particular range, i.e., for 1·i·p: propi2e!ri. given an event e2
e, propi(e)maps the event onto a particular property of the event, e.g., its
timestamp, the activity executed, the person executing the event, etc. based on e
and the set of properties, we de¯ne ¾2e¤as a (complex) trace andl2 p(e¤)
as a (complex) event log .
note that de¯nition 1 can be seen as a special case of the above de¯ni-
tion with only one property, being the activity itself. some examples of typical
property functions are:
{activity 2e!awhere ais the set of activities. activity (e) is the activity
thaterefers to.
{timestamp 2e!tswhere tsis the set of timestamps. timestamp (e) is
the time that eoccurred.
{performer 2e!pwhere pis the set of persons. performer (e) is the person
executing e.
{trans type2e! fenable ;start;complete ;abort ; : : :g.trans type(e) is the
type of transaction, e.g., if activity (e) =conduct interview andtrans type(e)
=start, then eis the start of the interview.
there may also be property functions describing data attributes of an event or
linking events to business objects.for convenience, we assume that all property functions are extended to se-
quences, i.e., if ¾=he1; e2; : : : ; e ni 2e¤, then propi(¾) =hpropi(e1);propi(e2);
: : : ;propi(en)i 2r¤
i.
the goal of the additional information captured in events is to provide for
more ways of extracting transition systems. one way would be to allow for state
functions of the form state2(e¤£i n)6!r, i.e., de¯ning dedicated abstractions
based on the various properties of a case. another approach would be to use the
abstractions de¯ned earlier (i.e., h,f,m,q, and v) and ¯rst project the complex
trace onto a simple trace. for example, transform the complex log l2 p(e¤)
into a simple log l0=factivity (¾)j¾2lgby projecting each event onto
its activity. in a similar way l0=fperformer (¾)j¾2lgcould be used to
explore the transfer of work from one person to another using the abstractions
de¯ned earlier. in our implementation described in section 7, we will show that
we essentially used the second approach. independent of the approach chosen,
this will result in a state() function that can be used to construct a transition
system as de¯ned in de¯nition 3.
6 synthesis using regions (step 2)
in this section, we present the second step of our approach. in this second step, a
process model is synthesized from the transition system resulting from the ¯rst
step. in this paper and our implementation, we use the well-known \theory of
regions" [15,18,23] to construct a petri net.
6.1 constructing petri nets using regions
thesynthesis problem is the problem to construct, for a given behavioral speci¯-
cation, a petri net such that the behavior of this net coincides with the speci¯ed
behavior (if such a net exists). there are basically two approaches to tackle
this problem. both use the notion of \regions". the state-based region the-
ory[15, 18, 23] uses a transition system as input, i.e., it attempts to construct
a petri net that is bisimilar to the transition system. hence both are behav-
iorally equivalent and if the system exhibits concurrency, the petri net may
be much smaller than the transition system. the language-based region the-
ory[11, 29, 30, 42] does not take a transition system as input but a language
(e.g., a regular language or simply a ¯nite set of sequences, i.e., a log). however,
the basic principle is similar.
given the fact that, in the ¯rst step, we construct, in a controlled manner,
a transition system, it seems most natural to use the state-based region theory.
there are many variants and extensions of this theory. however, to present the
basic idea we start with the classical de¯nition of a region .
de¯nition 6 (region). letts= (s; e; t )be a transition system and s0µs
be a subset of states. s0is aregion if for each event e2eone of the following
conditions hold:1.all the transitions s1e!s2enter s0, i.e. s1=2s0ands22s0,
2.all the transitions s1e!s2exits0, i.e. s12s0ands2=2s0,
3.all the transitions s1e!s2do not cross s0, i.e. s1; s22s0ors1; s2=2s0
figure 11 illustrates this notion and puts the idea in the context of this paper.
the log is converted into a transition system as shown earlier. the transition
system consists of 8 states. the set consisting of just state fgis a region because
alla-transitions leave this region and all other transitions never cross this region.
the set consisting of states fagandfa; bgis a region because all a-transitions
enter this region, all c-transitions leave this region, all e-transitions leave this
region, and all other transitions (i.e., bandd) never cross this region. figure 11
also shows a region consisting of three states: fa; bg,fa; b; c g, and fa; eg.
note that this region is shown by twoconnected areas in figure 11. all b-
transitions enter this region, all e-transitions enter this region, all d-transitions
leave this region, and all other transitions never cross this region. as figure 11
shows regions correspond to places in the petri net. the transitions that enter
a region rare input transitions of the corresponding rplace. transitions that
leave region rare output transitions of r. the transitions that do not cross rare
not connected to the corresponding place.
abcd
acbd
aed
abcd
abcd
aed
acbd
...{}a{a} {a,c}c{a,b}
b{a,b,c}c{a,b,c,d}d
{a,e} {a,d,e}deb
ab
cd e
p1p2
p3p4
p5p6step 1
step 2
fig. 11. a transition system based on pre¯xes and abstractions h=1,f=a,
m=1,q=set, and v=a, is converted into a petri net using the \theory of
regions". the six regions correspond to places in the petri net.any transition system ts= (s; e; t ) has two trivial regions: ;(the empty
region) and s(the region consisting of all states). since these hold no information
about the process, only non-trivial regions are considered. a region r0is said to
be a subregion of another region rifr0½r. a region risminimal if there is
no other non-trivial region r0which is a subregion of r. note that all regions in
figure 11 are minimal. region ris apreregion ofeif there is a transition labeled
with ewhich exits r. region ris apostregion ofeif there is a transition labeled
with ewhich enters r.
for petri net synthesis, a region corresponds to a petri net place and an
event corresponds to a petri net transition . thus, the main idea of the synthesis
algorithm is the following: for each event ein the transition system, a transition
labeled with eis generated in the petri net. for each minimal region ria place
piis generated. the °ow relation of the petri net is built the following way:
e2p²
iifriis a preregion of eande2²piifriis a postregion of e. an example
of a petri net synthesized from a transition system using this simple algorithm
is given in figure 11.
the ¯rst papers on the \theory of regions" only dealt with a special class of
transition systems called elementary transition systems . see [9,10,18] for details.
the class of elementary transition systems is very restricted. in practice, most
of the time, people need to deal with arbitrary transition systems that only by
coincidence fall into the class of elementary transition systems. in the papers
of cortadella et al. [14,15], a method for handling arbitrary transition systems
was presented. this approach uses labeled petri nets , i.e., di®erent transitions can
refer to the same event. for this approach it has been shown that the reachability
graph of the synthesized petri net is bisimilar to the initial transition system
even if the transition system is non-elementary.
to illustrate the problem of non-elementary transition systems, consider fig-
ure 12. the transition system is obtained by abstracting away bandc, e.g.,
useh=1,f=fa; d; e g,m= 1,q=seq, and v=fa; d; e glike in figure 8
and then remove the self loop. an isomorphic transition system can be obtained
by ¯ltering out bandc¯rst and then use pre¯xes of length 1 without any
further abstractions. this transition system is not elementary. the problem is
that there are two states haiandheithat are identical in terms of regions, i.e.,
there is no region such that one is part of it and the other is not. as a result,
the constructed petri net on the left hand side of figure 12 fails to construct
a bisimilar petri net. however, using label-splitting as presented in [14,15], the
petri net on the right hand side can be obtained. this petri net has two transi-
tions d1 and d2 corresponding to activity din the log. the splitting is based
on the so-called notions of excitation andgeneralized excitation region , see [14].
as shown in [14, 15] it is always possible to construct an equivalent petri net.
however, label-splitting may lead to larger petri nets.abcd
acbd
aed
abcd
abcd
aed
acbd
...step 1
step 2
(classical
region
theory)<>a<a> <d>d<e>
ed
a de
p1 p2 p3a d1e
p1 p2 p4d2p3step 2
(using
label
splitting)fig. 12. the transition system generated based on the log is not elementary. there-
fore, the generated petri net using classical region theory is not equivalent (modulo
bisimilarity). however, using \label-splitting" an equivalent petri net can be obtained.
6.2 more on regions
in this paper, we do not propose a new approach to construct regions. however,
we would like to re°ect on the application of region theory in the context of
mining.
generalization region theory aims at synthesis, i.e., the petri net should have
a behavior which is identical to the initial behavior speci¯ed. therefore, the petri
net shown on the left-hand side of figure 12 is considered to be a problem from
the synthesis point of view. this is the reason why label-splitting is used to
construct a bisimilar petri net if the net is not elementary, cf. right-hand side of
figure 12.
in this paper, we have used an approach where all generalizations take place
in the ¯rst step. this way the purpose of each step is clear: (a) step 1 is con-
cerned with selecting the desired behavior (i.e., abstraction and generalization),
and (b) step 2 is only concerned with generating the corresponding petri net rep-
resentation . this means that the analyst can in°uence the ¯rst step but not the
second. note that the petri net shown on the left-hand side of figure 12 is gen-
eralizing things in an uncontrolled manner . because of representation issues eis
suddenly allowed to execute an arbitrary number of times while in the log it was
never executed multiple times. this is undesirable and shows that region theorytends to yield over¯tting models but at the same time it may generalize things
in an uncontrolled manner, i.e., the generalization is driven by representational
issues rather than behavioral ones.
1
23
5
6
41
23
5
6
4
fig. 13. the left-hand side petri net can \parse" any log while the addition of place p
on the right-hand side imposes a constraint on the traces that can be parsed.
although in this paper and the implementation described in section 7 we
only generalize in the ¯rst step, it is interesting to note that existing synthesis
approaches can be ¯ne-tuned for mining [11,42]. such approaches are completely
di®erent from the main approach described in this paper and consist of only one
step that constructs a petri net while generalizing at the same time.
figure 13 shows the basic idea. suppose one has a log with activities a=
ft1; : : : ; t 6g. it is easy to see that the petri net on the left-hand side in figure 13
can \parse" this log, i.e., the model ¯ts any log containing activities a. the
addition of a place can be seen as adding a constraint. by adding place pin
figure 13 a constraint is introduced. suppose that ¾2l. let ¾1and¾2=¾1ht0i
(i.e., ¾1concatenated with some t0), be two pre¯xes of ¾. assume that phas
initially ktokens. then pcan only be added if k+par(¾1)(t1) +par(¾1)(t2) +
par(¾1)(t3)+par(¾1)(t4)¡par(¾2)(t3)¡par(¾2)(t4)¡par(¾2)(t5)¡par(¾2)(t6)¸
0.8hence, we can add any place such that above constraint holds for any ¾2
l. in [11, 29, 30, 42] several approaches are presented to add as few places as
possible while maximally constraining the net (without violating the constraints
mentioned above). it is obvious that any cost function can be associated to the
addition of a place. for example, there may a \penalty" for places that are
not easy to understand. such penalties can easily be combined with constraints
into an integer lineair programming problem [42]. this way regions can be used
directly to balance between over¯tting and under¯tting.
selecting the target format the goal of process mining is to present a model
that can be interpreted easily by process analysts and end-users. therefore,
complex patterns should be avoided. region-based approaches have a tendency
to introduce \smart places", i.e., places that compactly serve multiple purposes.
8recall that par(¾1)(t) is the number of times that toccurred in ¾1.such places have many connections and may have non-local e®ects (i.e., the same
place is used for di®erent purposes in di®erent phases of the process). therefore,
it may be useful to guide the generation of places such that they are easier to
understand. this is fairly straightforward in both state-based region theory and
language-based region theory. in [14,15] it is shown that additional requirements
can be added with respect to the properties of the resulting net. for example,
the net can be forced to be free-choice, pure, etc. figure 14 shows the petri
net obtained by using the approach in [14,15] while demanding the result to be
free-choice. note that in order to make the net free-choice the labels bandc
were split.
abcd
acbd
aed
abcd
abcd
aed
acbd
...step 1
step 2
{}a{a} {a,c}c{a,b}
b{a,b,c}c{a,b,c,d}d
{a,e} {a,d,e}deba db1
p1 p2 p6
b2 c1c2
ep3
p4p5
fig. 14. the techniques presented in [14,15] can be used to obtain a free-choice petri
net. note that labels bandcare split in order to achieve this.
the petri net in figure 14 is bisimilar to the transition system and the set
of possible traces of the model coincides with the initial log. however, other
approaches such as the one presented [42] do not aim at a model whose possible
traces of the model coincides with the initial log. in such an approach it is
possible to allow only the adding of places that have the desired properties. one
can use cost functions to decide on the addition of a place such as the one shown
in figure 13. using such an approach it is also possible to enforce that the model
is e.g. free-choice.
it is interesting to think about \cost models" in the context of process mining
to balance over¯tting and under¯tting. it may be that there is a simple model
that almost captures the behavior observed while all models that exactly capture
the behavior are much more complex. in such a case, it may be wise to show
the simple model to the user. the addition of a place has a \cost" in terms of
adding to the complexity of the result and potentially over¯tting. note that a
place with many input and output transitions is typically a sign of over¯tting.however, not adding a place has a \cost" in terms of under¯tting, i.e., allow for
too much behavior not present in the log. the notion of costs is also interesting
when dealing with noise (cf. section 3.3), i.e., a place may be added because the
majority of the cases suggest that this is natural while a small fraction of the
log cannot be reproduced because of this place.
7 implementation and evaluation
in the previous two sections, we presented a two-step approach. in section 5,
we showed how transition systems can be extracted in a controlled way while
balancing between over¯tting and under¯tting. section 6 showed that region
theory can be used to convert the result into an equivalent petri net, i.e., con-
currency is detected and moved to the net level. the ideas presented in this
paper have been fully implemented in the context of prom .9the prom serves
as a testbed for our process mining research [2] and can be downloaded from
www.processmining.org . starting point for prom is the mxml format. this
is a vendor-independent format to store event logs. similar to de¯nition 5, this
format allows for the recording of timestamps, data elements, performers, etc.
note that in this paper we focused on discovering petri nets and not models
in other notations. however, the resulting petri net can then be converted into
the desired notation, e.g., bpmn, epcs, uml activity diagrams, etc. this is
standard functionality of prom, therefore, we do not elaborate on this.
7.1 promimport
the promimport framework [25] allows developers to quickly implement plug-
ins that can be used to extract information from a variety of systems and convert
it into the mxml format (cf. promimport.sourceforge.net ). there are stan-
dard import plug-ins for a wide variety of systems, e.g., work°ow management
systems like sta®ware, case handling systems like flower, erp components
like peoplesoft financials, simulation tools like aris and cpn tools, middle-
ware systems like websphere, bi tools like aris ppm, etc. moreover, it has
been used to develop many organization/system-speci¯c conversions (e.g., hos-
pitals, banks, governments, high-tech systems, etc.).
7.2 prom
once the logs are converted to mxml, prom can be used to extract a variety
of models from these logs. prom provides an environment to easily add so-
called \plug-ins" that implement a speci¯c mining approach. although the most
interesting plug-ins in the context of this paper are the mining plug-ins, it is
important to note that there are in total ¯ve types of plug-ins:
9note that the described functionality is present in the so-called \nightly builds"
of prom and not yet in the released version (4.2). these nightly builds can also
be downloaded via www.processmining.org and all functionality will be present in
release 5.0 of prom.mining plug-ins which implement some mining algorithm, e.g., mining algo-
rithms that construct a petri net based on some event log, or algorithms
that construct a transition system or a social network from an event log.
export plug-ins which implement some \save as" functionality for some ob-
jects (such as graphs). for example, there are plug-ins to save epcs, petri
nets, spreadsheets, etc.
import plug-ins which implement an \open" functionality for exported ob-
jects, e.g., load petri nets that are generated by petrify or epcs from aris.
analysis plug-ins which typically implement some property analysis on some
mining result. for example, for petri nets there is a plug-in which constructs
place invariants, transition invariants, and a coverability graph.
conversion plug-ins which implement conversions between di®erent data for-
mats, e.g., from epcs to petri nets and from petri nets to yawl and bpel.
currently, there are more than 230 plug-ins [2]. one of these plug-ins is the
mining plug-in that generates the transition system that can be used to build
a petri net model. another plug-in is the conversion plug-in that uses petrify
to synthesize a petri net. petrify is embedded in prom and uses the algorithms
developed by cortadella et al. [14,15].
figure 15 shows the mining and conversion plug-in in prom. although the
notation is slightly di®erent, it is easy to see that the results of the two steps
are indeed as shown earlier in figure 11. what is more di±cult to see is that
the top window allows for all kinds of abstractions. the tabs model element ,
originator ,event type , and attributes refer to the type of information to be used.
this corresponds to the selection of properties used for building the transition
system (cf. the property functions mentioned in de¯nition 5). note that any
conjunction of these properties can be used, e.g., a state may be based on the
person that executed the last task and the name of the next activity. moreover,
all abstractions mentioned in this paper are available. in figure 15 the following
settings are used: pre¯xes with h=1,f=a,m=1, and q=set. under tab
visible the transition names to be shown one the arcs in the diagram can be
selected (i.e., the value of v). the modi¯cations tab allows for the extensions
mentioned in section 5.4.
as figure 15 illustrates, the ideas presented in this paper have been fully
implemented.
7.3 evaluation
in the introduction we mentioned that existing process mining approaches suf-
fer from the problems such as the inability to deal with advanced control-°ow
constructs (e.g., non-local dependencies, skips, duplicates, etc.), the inability to
guarantee the correctness of the model (e.g., absence of deadlocks, etc.), and in-
ability to balance between over¯tting and under¯tting. in this section, we show
that our approach can indeed overcome these problems.
in figure 5 where we already showed the e®ect of abstraction using a real-
life log. the di®erence between both models is in the horizon considered. forfig. 15. a screenshot of prom while analyzing the running example. the top window
shows the various abstractions that can be selected. the right window show the result
of step 1 and the left window shows the result of step 2.the smaller model h= 1 while for the spaghetti-like model h=1. figure 5
convincingly shows the practical relevance of our approach, but fails to provide
good insights into the way the simpli¯cations are achieved. therefore, we use a
smaller but non-trivial process (figure 16) to illustrate our approach in more
detail.
ab
ce h
f ijd
glk
m
fig. 16. thousand cases have been generated according to this process model. com-
plications are that gis invisible (see dashed transition) and that there is a non-local
dependency controlling the choice between kandl.
figure 16 shows a process modeled in terms of a petri net. note that this
model has two types of constructs that most process mining algorithms have
problems dealing with. the ¯rst construct is activity gthat is not being logged.
as a result fcan be skipped. since such a skip is not recorded, it is not trivial
to detect it. the second construct is the non-local dependency controlling the
choice between kandl. note that k(l) is only selected if also d(e) was
selected. however, there are always at least two activities in-between d(e) and
k(l) (activities handj). most process mining techniques have problems with
at least one of these two constructs. based on the model in figure 16, we have
randomly generated 1000 cases using the simulation tool cpn tools. the event
log of cpn tools is converted into mxml such that we can apply a wide variety
of process mining algorithms (including the one presented in this paper).
the 1000 cases have been generated randomly. the model allows for 80 dif-
ferent traces (assuming gis visible). however, only 66 of these traces actually
occur in the log . moreover, some traces appear frequent in the log (e.g., there is
a trace that is repeated 83 times in the log) while others are unique. this nicely
illustrates the discussion on completeness in section 3.3.
figure 17 shows the result when applying the ®algorithm [7]. note that
this model and its layout are automatically generated from the log without hu-
man intervention. (note that the prom plug-in constructing the petri net using
the®algorithm inserts transactional information. therefore, each transition is
classi¯ed as a \complete transition" in figure 17.) as can be seen, the model
is incorrect because it does not allow for the skipping of f. this is caused byk
complete
f
completei
completej
completeh
completee
completed
complete
c
completeb
complete
a
completem
complete
l
completefig. 17. the petri net discovered by the ®algorithm in prom. note that although
fcan be skipped in reality this is not possible in the model. moreover, the non-local
dependencies are not discovered.
the fact that gis invisible. moreover, there are no connections from the choice
between dandeto the choice between kandl.
some of the algorithms presented in literature can overcome these problems.
for example, the ®++algorithm presented in [41] and implemented in prom
can discover the non-local dependencies between d(e) and k(l). however,
it cannot handle the skipping of fleading to the same problem as shown in
figure 17. the multi-phase miner [20] (also implemented in prom) can handle
the skipping of fbut not the non-local dependencies. the genetic miner [3,31]
may be able to discover both types of constructs correctly. however, this takes a
lot of computation time and the end result is not guaranteed. older algorithms
such as [12] are not able to discover concurrency. therefore, figure 16 is a nice
benchmark example to evaluate our two-step approach.
figure 18 shows the transition system based the log containing 1000 cases
and function state(¾; k) =set(par(tl1(tl1(hdk(¾))"a))) = set(par(hdk(¾))),
i.e., we use pre¯xes and the abstractions h=1,f=a,m=1,q=set, and
v=a. the transition system in figure 18 can easily be converted into the petri
net shown in figure 19 using the \theory of regions". note that the petri net
and its layout are automatically generated using prom.
figure 19 captures the non-local dependencies and the skipping of fcor-
rectly. the two places between dandeandkandlcorrectly model the
dependencies present. the skipping is modeled by label-splitting, i.e., there are
two transition referring to activity i:i:1 and i. note that the notation gener-
ated by prom is slightly di®erent from the notation used in this paper. however,
the correspondence should be clear. also note that the output place of mis sup-
pressed. however, this is merely a technicality and not a limitation.
the above example shows that the two-step approach is able to discover
complex constructs and is capabele of delivering models that are guaranteed
to satisfy various correctness criteria. the reason is that the transition system
is acontrolled abstraction of the log and has guaranteed properties that are
preserved through the construction of the petri net. (recall that the petri net
is bisimilar.)
another property of the two-step approach is that it is con¯gurable, i.e., by
changing settings di®erent models can be constructed depending on the desired[[a, b, c, d, f, h, i, j]][[a, b, e, h]]
[[a, b, c, d, f, h, i]][[a, b, c, d, f, i]]
[[a, b, c, d, h, i, j, k, m]][[a, b, c, d, h, i, j, k]][[a, b, c, e, f]]
[[a, b, c, d, h, i, j]][[a, b, c, e]]
[[a, b, c, d, h, i]][[a, b, e]]
[[a, b, c, e, h, i, j, l, m]][[a, b, c, d, h]]
[[a, b, c, e, h, i, j, l]][[a, b, c, e, h, i, j]][[a, b, c, e, h, i]][[a, b, d, h]][[a, b, d]][[a, b]]
[[a, b, c, i]][[a]][[]]
[[a, b, c, e, f, h, i, j, l, m]][[a, b, c, e, f, h, i, j, l]][[a, b, c, e, i]]
[[a, b, c, e, f, h, i, j]][[a, b, c, f]]
[[a, b, c, e, f, h, i]][[a, b, c, e, f, i]][[a, c, i]]
[[a, b, c, d, f, h]][[a, b, c, d, f]]
[[a, b, c, d, f, h, i, j, k, m]][[a, b, c]]
[[a, b, c, d, f, h, i, j, k]][[a, b, c, e, h]] [[a, b, c, f, i]][[a, c, f, i]][[a, c, f]][[a, c]]
[[a, b, c, d, i]][[a, b, c, d]]
[[a, b, c, e, f, h]]
ic
hc
hi
hb
e
i
jib
h
h
ki
lh
ld
h
md
db
if
ea
fc
c
c
ie
i h if
jf
j
jd
h f
kb e
ei
i
mb d
mh
c
mfifig. 18. the transition system constructed by prom.
abstraction/generalization. this way one can balance between over¯tting and
under¯tting in a controlled way. figure 20 shows an alternative process model
constructed using the same log but a di®erent abstraction. in this case, we
again use pre¯xes and h=1,m=1,q=set, and v=a. however, now
f=fa; b; d; e; g; h; j; k; l; m g. this means that we tell the algorithm not
to use c,f, and ifor constructing the state but to still include the activities in
the process model. as figure 20 shows c,f, and ican be executed in-between
aandj. however, because these activities are not used in the state information,
the process model only indicates that they can be executed without indicating
an order or frequency.k
j
ih
fed
cb
a
i._1m
lfig. 19. the petri net constructed by prom based on the transition system of fig-
ure 18.
kj
ih
fe
dcb
a ml
fig. 20. another petri net constructed using the abstraction f =
fa; b; d; e; g; h; j; k; l; m g.
b._1ml
kj
he
db
a
j._1
fig. 21. a petri net constructed by ¯ltering the log and building states based on
post¯xes using abstraction m= 1.figure 21 shows yet another alternative process model. this example has
been added to show the use of post¯xes and a limited horizon. in this case,
h=1,f=a,m= 1, q=set, and v=a. moreover, activities c,f, and i
have now been ¯ltered out of the log before applying the algorithm. hence, they
do not appear in the model at all (i.e., also not on the arcs like in figure 20).
it is interesting to note that the non-local dependency is deliberately abstracted
from by setting m= 1. moreover, since the state is based on the future (i.e.,
next activity), activities bandjare split. the reason is that using this state
function, the next step is already known after executing borj. therefore, the
moment of choice is moved to an earlier point.
figures 19, 20, and 21 show that based on the same log di®erent models
can be constructed based on the desired abstraction/generalization. as far as we
know, this is the only algorithm described in literature able to balance between
over¯tting and under¯tting in a controlled way.
8 conclusion
this paper presented a new two-step process mining approach. it uses innovative
ways of constructing transition systems and regions to synthesize process mod-
els in terms of petri nets. using this approach, it is possible to discover process
models that adequately describe the behavior recorded in event logs. these logs
may come from a variety of information systems e.g., systems constructed using
erp, wfm, crm, scm, and pdm software. the application is not limited to
repetitive administrative processes and can also be applied to development pro-
cesses and processes in complicated professional/embedded systems. moreover,
process mining is suitable for the monitoring of interacting web services.
existing approaches typically provide a single process mining algorithm, i.e.,
they assume \one size ¯ts all" and cannot be tailored towards a speci¯c applica-
tion. unlike existing approaches, we allow for a wide variety of strategies, and,
as a side-e®ect, overcome some of the problems of existing approaches. select-
ing the right state representation aids in balancing between \over¯tting" (i.e.,
the model is over-speci¯c and only allows for the behavior that happened to
be in the log) and \under¯tting" (i.e., the model is too general and allows for
unlikely behavior). the relation between the log and the transition system is
much more direct than in existing approaches. therefore, it is easier to control
the abstraction/generalization and it is clear which properties are preserved. for
the transformation of a transition system into a petri net we use regions. the
idea is that, in this second step, the behavior is not changed, i.e., using regions
we look for concurrency and move this to the net level. as a result the model
becomes more compact and can easily be translated to other process modeling
languages (epcs, bpmn, uml activity diagrams, etc.).
the approach has been fully implemented in prom and the resulting process
mining tool can be downloaded from www.processmining.org .
future work is aiming at a better support for strategy selection and new
synthesis methods. the fact that our two-step approach allows for a varietyof strategies makes it very important to support the user in selecting suitable
strategies depending on the characteristics of the log and the desired end-result.
practical experiments point out the need for better synthesis methods. existing
region-based approaches implemented in tools such as petrify have severe per-
formance problems and typically lead to less intuitive models. the \theory of
regions" aims at developing an equivalent petri net while in process mining a
simple less accurate model is more desirable than a complex model that is only
able to reproduce the log. hence it is interesting to investigate \new theories of
regions" tailored towards process mining. some initial work in this direction has
already been presented in [11,42].
9 acknowledgements
this research is supported by eit, nwo-ew, and the technology foundation
stw. moreover, we would like to thank the many people involved in the devel-
opment of prom.
references
1.w.m.p. van der aalst. the application of petri nets to work°ow management.
the journal of circuits, systems and computers , 8(1):21{66, 1998.
2.w.m.p. van der aalst, b.f. van dongen, c.w. gä unther, r.s. mans, a.k. alves
de medeiros, a. rozinat, v. rubin, m. song, h.m.w. verbeek, and a.j.m.m.
weijters. prom 4.0: comprehensive support for real process analysis. in j. kleijn
and a. yakovlev, editors, application and theory of petri nets and other models of
concurrency (icatpn 2007) , volume 4546 of lecture notes in computer science ,
pages 484{494. springer-verlag, berlin, 2007.
3.w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. genetic
process mining. in g. ciardo and p. darondeau, editors, applications and theory
of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
48{69. springer-verlag, berlin, 2005.
4.w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters, b.f. van dongen, a.k.
alves de medeiros, m. song, and h.m.w. verbeek. business process mining: an
industrial application. information systems , 32(5):713{732, 2007.
5.w.m.p. van der aalst, v. rubin, b.f. van dongen, e. kindler, and c.w. gä unther.
process mining: a two-step approach using transition systems and regions.
bpm center report bpm-06-30, bpmcenter.org, 2006.
6.w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. work°ow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
7.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
8.r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
°ow logs. in sixth international conference on extending database technology ,
pages 469{483, 1998.9.e. badouel, l. bernardinello, and p. darondeau. the synthesis problem for ele-
mentary net systems is np-complete. theoretical computer science , 186(1-2):107{
134, 1997.
10.e. badouel and p. darondeau. theory of regions. in w. reisig and g. rozenberg,
editors, lectures on petri nets i: basic models , volume 1491 of lecture notes in
computer science , pages 529{586. springer-verlag, berlin, 1998.
11.r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on
regions of languages. in g. alonso, p. dadam, and m. rosemann, editors, inter-
national conference on business process management (bpm 2007) , volume 4714
oflecture notes in computer science , pages 375{383. springer-verlag, berlin,
2007.
12.j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
13.j. cortadella, m. kishinevsky, a. kondratyev, l. lavagno, and a. yakovlev.
petrify: a tool for manipulating concurrent speci¯cations and synthesis of asyn-
chronous controllers. ieice transactions on information and systems , e80-
d(3):315{325, march 1997.
14.j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. synthesizing petri
nets from state-based models. in proceedings of the 1995 ieee/acm interna-
tional conference on computer-aided design (iccad '95) , pages 164{171. ieee
computer society, 1995.
15.j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets
from finite transition systems. ieee transactions on computers , 47(8):859{882,
august 1998.
16.a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275{301,
1998.
17.j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
18.j. desel and w. reisig. the synthesis problem of petri nets. acta informatica ,
33(4):297{315, 1996.
19.j. desel, w. reisig, and g. rozenberg, editors. lectures on concurrency and petri
nets, volume 3098 of lecture notes in computer science . springer-verlag, berlin,
2004.
20.b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362{376. springer-verlag, berlin, 2004.
21.b.f. van dongen and w.m.p. van der aalst. multi-phase mining: aggregating
instances graphs into epcs and petri nets. in d. marinescu, editor, proceedings of
the second international workshop on applications of petri nets to coordination,
work°ow and business process management , pages 35{58. florida international
university, miami, florida, usa, 2005.
22.m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.
23.a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315{368, 1989.24.d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321{343, 2004.
25.c. gä unther and w.m.p. van der aalst. a generic import framework for process
event logs. in j. eder and s. dustdar, editors, business process management
workshops, workshop on business process intelligence (bpi 2006) , volume 4103
oflecture notes in computer science , pages 81{92. springer-verlag, berlin, 2006.
26.j. herbst. a machine learning approach to work°ow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183{194. springer-verlag, berlin, 2000.
27.ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
28.e. kindler, v. rubin, and w. schä afer. process mining and petri net synthesis. in
j. eder and s. dustdar, editors, business process management workshops , volume
4103 of lecture notes in computer science , pages 105{116. springer-verlag, berlin,
september 2006.
29.r. lorenz, r. bergenthum, j. desel, and s. mauser. synthesis of petri nets from
finite partial languages. in t. basten, g. juh¶ as, and s.k. shukla, editors, in-
ternational conference on application of concurrency to system design (acsd
2007) , pages 157{166. ieee computer society, 2007.
30.r. lorenz and g. juh¶ as. how to synthesize nets from languages: a survey. in
s.g. henderson, b. biller, m. hsieh, j. shortle, j. d. tew, and r. r. barton,
editors, proceedings of the wintersimulation conference (wsc 2007) , pages 637{
647. ieee computer society, 2007.
31.a.k.a. de medeiros. genetic process mining . phd thesis, eindhoven university
of technology, eindhoven, 2006.
32.a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. work°ow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science , pages
389{406. springer-verlag, berlin, 2003.
33.m. zur mä uhlen and m. rosemann. work°ow-based process monitoring and con-
trolling - technical and organizational issues. in r. sprague, editor, proceedings
of the 33rd hawaii international conference on system science (hicss-33) , pages
1{10. ieee computer society press, los alamitos, california, 2000.
34.w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
35.a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,
bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 163{176. springer-verlag, berlin,
2006.
36.a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. faideiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420{425. springer-verlag, berlin, 2006.
37.a. rozinat and w.m.p. van der aalst. conformance checking of processes based
on monitoring real behavior. information systems , 33(1):64{95, 2008.
38.m. sayal, f. casati, u. dayal, and m.c. shan. business process cockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb'02) ,
pages 880{883. morgan kaufmann, 2002.39.tibco. tibco sta®ware process monitor (spm). http://www.tibco.com, 2005.
40.a.j.m.m. weijters and w.m.p. van der aalst. rediscovering work°ow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151{162, 2003.
41.l. wen, w.m.p. van der aalst, j. wang, and j. sun. mining process models with
non-free-choice constructs. data mining and knowledge discovery , 15(2):145{180,
2007.
42.j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. in k. van hee and r. valk,
editors, proceedings of the 29th international conference on applications and the-
ory of petri nets (petri nets 2008) , volume 5062 of lecture notes in computer
science , pages 368{387. springer-verlag, berlin, 2008.