a configurable referen ce modelling language1 
 
m. rosemanna, w.m.p. van der aalstb,a 
 
 
a centre for information technology innovation, faculty of information technology, queensland university of technology,
 126 margaret street, brisbane qld 4000, australia, 
phone: +61 7 3864 9473, fax +61 7 3864 9390, m.rosemann@qut.edu.au 
b  faculty of technology and management, eindhoven university of technology, p.o. box 513, nl-5600 
mb, eindhoven, the netherlands, w.m.p.v.d.aalst@tm.tue.nl 
 
abstract 
enterprise systems (es) are comprehensive off-the-shelf packages that have to be 
configured to suit the requirements of an organization. most es solutions provide reference models that describe the functionality and structure of the system. however, 
these models do not capture the potential configuration alternatives. this paper discusses 
the shortcomings of current reference modelling languages using event-driven process chains (epcs) as an example. we propose configurable event-driven process chains 
as an extended reference modelling language which allows capturing the core 
configuration patterns. a formalization of this language as well as examples for typical configurations are provided. a program of further research including the identification of 
a comprehensive list of configuration patterns, deriving possible notations for reference 
model configurations and testing the quality of these proposed extensions in experiments and focus groups is presented. 
 
keywords 
reference model, enterprise systems, configuration, event-driven process chains  
                                                           
1 this research project is financially supported by sap research. - 2 - 
  1 introduction 
enterprise systems (es) offer business solu tions for typical functional areas such as 
procurement, materials management, production, sales and distribution, financial 
accounting and human resource management [24, 32]. these functions are typically individualised for countries and industries, e.g. automotive, retailing, high-tech. such off-
the-shelf-solutions require configuration before they can be used in the individual context 
of an organization.  as an approach to improve the understandability of these systems and to stress the 
process-oriented nature of their solutions, es vendors have developed application 
reference models which describe the processes and structure of the system. enterprise systems reference models exist in the form of function, data, system organization, object 
and business process models, although the latter are by far the most popular type.  
current reference models, however, are based on conventional modelling languages that have been developed for the design of enterprise-individual models. thus, they are not able to adequately depict possible system configurations. even further, they don’t provide decision support regarding the selection of relevant variants. current application 
reference models “just” depict the sum of all possible system capabilities and cannot 
sufficiently deal with the requirement of optionality. this paper contributes to this area by extending an existing process modelling language 
used in the by far most successful enterprise system (sap) with configurable elements. 
thus, it becomes possible to clearly highlight the required decisions which have to be made at build-time, i.e. during the individualisation of the generic models.  - 3 - 
  while our selection of the process modelling language has been driven by its popularity 
in the relevant enterprise systems modelling practice, the proposed extensions can be 
easily adapted to other modelling techniques ( e.g. uml or petri-nets). furthermore, we 
contribute to the area of enterprise system s modelling by providing a comprehensive list 
of criteria, which have to be satisfied by configurable process modelling languages. 
this paper is structured as follows. the next section provides an overview about the 
characteristics of application reference models and gives an example for such a model (the so-called epc model) a nd its current shortcomings. th e third section outlines the 
research problem and the research methodology. section four lists the requirements for a 
configurable reference modelling technique. section 5 first formalizes the notion of event-driven process chains (epcs), followed by a presentation of configurable epcs 
(c-epcs). this paper ends with a section on related work, a brief summary and a 
discussion of the future work. 
2 reference models 
reference models are generic conceptual models that formalize recommended practices 
for a certain domain [16,18]. often labelled with the term 'best practice' reference models 
claim to capture reusable state-of-the-art practices [39,40]. the depicted domains can be very different and range from selected functional areas such as financial accounting or 
customer relationship management to the scope of an entire industry sector, e.g. higher 
education. 
the main objective of reference models is to streamline the design of enterprise-
individual (particular) models by providing a generic solution. the application of reference models is motivated by the ‘design by reuse’ paradigm. reference models - 4 - 
  accelerate the modelling process by providing a repository of potentially relevant 
business processes and structures. these ideally ‘plug and play’ models are also called 
partial enterprise models in the terminology of the generalised enterprise reference 
architecture and methodology (geram) [7]. 
reference models can be differentiated along the following main criteria 
• scope of the model ( e.g., functional areas covered) 
• granularity of the model ( e.g., number of levels of decomposition detail) 
• views ( e.g., process, data, objects, organization) that are depicted in the model 
• degree of integration between the views 
• purposes supported 
• user groups addressed 
• internal or external (commercial) use 
• availability of the model ( e.g., paper, tool-based, web-based) 
• availability of further textual explanation of the model 
• explicit inclusion of alternative business scenarios 
• existence of guidelines on how to use these models 
• availability of relevant quantitative benchmarking data 
a further and more comprehensive differentiation based upon the domain  that underlies 
the reference model can be found in [6 and 34]. 
the term reference model is also used for models describing the structure and 
functionality of business applications including enterprise systems [11]. in these cases, a 
reference model can be interpre ted as a structured semi-formal description of a particular 
application. application reference models correspond to an existing off-the-shelf-solution 
that supports the functionality and structure described in the model. they can be used for 
a better understanding and evaluation of the appropriateness of the software. - 5 - 
  furthermore, they aim to facilitate the implementation of the software and can be used for 
related end user training [6,20,33]. 
one of the most comprehensive models is the sap reference model [11]. its data model 
includes more than 4000 entity types and the reference process models cover more than 
1000 business processes and inter-organizati onal business scenarios. most of the other 
market leading es vendors have an approach towards such reference models. an overview of the baan reference model, for example, is provided in [43]. see also [17] for 
reference models in intentia. 
foundational conceptual work for the sap reference model had been conducted by 
sap ag and the ids scheer ag in a collaborative research project in the years 1990-
1992 [23]. the outcome of this project was the process modelling language event-driven 
process chains  (epcs) [23, 38], which has been used for the design of the reference 
process models in sap. epcs also became the core modelling language in the 
architecture of integrated information systems (aris) [38]. it is now one of the most 
popular reference modelling languages and has also been used for the design of many 
sap-independent reference models ( e.g., aris-based reference model for siebel crm or 
industry models for banking, retail, in surance, telecommunication, etc.). 
epcs  are directed graphs, which visualise the control flow and consist of events, 
functions and connectors. each epc starts with at least one event and ends with at least one event [1, 3, 11, 23, 29, 36, 38]. an event triggers a function, which leads to a new 
event. three types of connectors (and, exclus ive or, or) can be used to model splits 
and joins. figure 1 shows an example for an epc as it potentially can be found as part of the sap reference model. this model shows a part of the invoice verification process. - 6 - 
  the epc contains 10 events, 4 functions, and 4 connectors. the events can be seen as 
pre- and/or post-conditions of functions. for example, function release invoice  can be 
executed if event invoice posted  is received and the completion of this function will 
trigger the event payment must be effected . there are three functions triggering event 
invoice posted . the exclusive or connector in the centre of the diagram shows that there 
is no need to synchronize these three functions, e.g., the completion of evaluated receipt 
settlement directly triggers event invoice posted . the three other connectors are and 
connectors. hence, both input events need to be triggered in order to enable function 
evaluated receipt settlement . 
figure 1 shows a classical epc which does no t contain any configuration information. 
therefore, valuable information is lacking. for example, it is not shown that evaluated 
receipt settlement , i.e. the scenario in which payment for goods is triggered through 
goods issue, is only of interest for a subset of all sap customers. this implies that the exclusive or connector may be a choice made at design time for the whole process rather than at run-time for an individual process instance. it also does not show that invoicing 
plan settlement  is only relevant, if evaluated receipt settlement  is conducted. note that 
because of the exclusive or connector only one of them is executed but it does not make 
any sense to allow for invoicing plan settlement  if evaluated receipt settlement  is not 
allowed. moreover, the model does not give an y insights into the necessity or criticality 
of the possible configurations. thus, the model expressive power is limited and does not address the possible configurations of the corresponding enterprise system. - 7 - 
   
fig. 1:  an example for a reference model in epc-notation 
3 research problem and research methodology 
the existence of reference models highlights a difference from the traditional software 
development process. instead of starting from scratch and continuously adding 
functionality, es solutions require a continuous narrowing down of the scope of the 
system. this process starts with the “big picture”, which is then reduced to the relevant part. reference models can be used as a descript ion of this big picture. it is necessary to  goods receipt
postedservice
is accepted
invoice
received
release
invoiceinvoice processing
with referencepurchase
order
created
evaluated
receipt
settlementinvoicing plan
settlement
payment
must
be effectedgoods receipt
postedpurchase
order
createdgoods receipt
postedpurchase
order
created
invoice
postedfunction 
event 
excl. or and 
or legend - 8 - 
  select the necessary functions and to decide during the configuration process between 
alternatives ( e.g., reporting in financial accounting or controlling). 
the reference model lifecycle is initiated by the reference model designers, i.e. the 
enterprise systems vendor. during the design phase available individual conceptual 
models are evaluated, selected and consolidated.2 such a reference model will typically 
not only include one proposed alternative, but a range of often mutually exclusive 
alternatives. this might be because the depicted scenarios cover different industries or 
different countries. at this stage, for example, sap maintains 27 alternative industry solutions. however, the current use of traditional modelling languages does not support a 
consolidation of these models. figure 2 demonstrates this problem in a simple example. it 
shows the consolidation of corresponding reference models from two different industries. 
the xor split (second from the left) in this case represents a decision point that is of 
relevance during the so-called configuration time. a model in this phase cannot necessarily be executed. it rather captures different alternatives for a domain and has to 
be configured before it can serve as the actual build time model for individual process 
instances. 
                                                           
2 an organization might also declare the internal best practice in one subsidiary etc. as the internal 
benchmark. thus, an existing conceptual model can have the status of a reference model. this practice can, for example, be observed in global organizations that roll-out the business blueprint of one location to all 
their subsidiaries worldwide. these models are also called prototypical models [7]. they do not require 
configurations and are not within the scope of this paper. 
  - 9 - 
   
fig. 2:  configuration time, build time and run time 
the lack of the required expressiveness of current reference modelling languages for 
configuration time is for two reasons a serious issue for model users. first, it does not 
become obvious what configuration alternativ es exist during the system implementation 
phase. second, the models do not provide any decision support in the actual selection of 
an alternative. current reference models show what processes are supported in general, 
but not what might be a recommended alternative. they represent the entire functionality from the viewpoint that the complete system is used and look like an ordinary build time 
model. however, only a subset is typically used within an individual organization. 
figure 3 provides a related example for the customer master data entry process in sap r/3. it becomes obvious that the actually selected and implemented business process 
is less than 50 % of the provided reference model. the connectors in the process model 
on the left, however, do not differentiate between decisions which configure the model and decisions at run time. as a result all connectors seem to refer to run time decisions. 
consequently, a model user has problems in identifying the configurable parts in this 
process. a
b
coil & gas
a
b
dchemical
industry
a
b
c dxorcombined
reference model
a
b
da3
b3
d3a2
b2
d2a1
b1
d1derived
enterprise modelderived
instances
configuration time build time run time build time- 10 - 
  fig. 3:  individualisation of a sap reference model  
the main objective of this paper is to propose a new configurable reference modelling 
language by extending an existing popular modelling technique. this research is embedded in a more comprehensive sap-funded research project with the following 
three phases. 
1) the first task was the identification and classification of configuration patterns . a 
configuration pattern describes a distinguishable configuration case. based on the 
work that has been conducted on workflow patterns [4], we derived a set of 
configuration patterns that classify alternative configuration scenarios. as far as possible, examples from the sap reference model have been assigned to each 
configuration pattern. the sap reference model has been used because of its 
maturity, its worldwide use and its availability to the researchers. conditions processing
(purchasing)specify address of
customer
address is specified
interest calculation is
specified
plant processingmaintain accounting
informationsold-to party to be
created
customer is also vendor
planning group is
specified
customer-material-info
processing [standard]maintain account control
maintain sales dataship-to party to be
created
trading partner is
specified
clearing between
customer/vendor
specified for automatic
payments
basic data processing for
legal controls [standard]management of physical
samplespayer to be created
specify company code
company code is
specified
bank details are
specified
possible payment
methods are specified
customer volume rebate
agreement processing
[normal]customer master record
is to be created
specify payment
transaction data
manual sample releasedetermine customer
function
invoice recipient is to be
created
account group with
internal number
assignment determined
define customer number
customer number is
determined
payment card data is
maintained
sales area data are
maintained
maintain payment
information
alternative payer
specific to company
code specified
create customer
customer master record
is created
material listing/exclusion
[standard]sales personnel is
processed
specify account group
maintain control datasample receiver to be
created
account group with
external number
assignment determined
alternative payer for
customer specified
line item settlement is
specified
product allocation [standard]specify alternative payer
maintain messages
decentralized processing
requiredcustomer to be created
for statistical purposes
alternative payer for
item allowed
payment block is
specified
basic data processing for
legal controls [standard]maintain partner
functions
check if decentralized
handling is desiredcustomer is assortment
customer
maintain marketing data
marketing data are
maintained
dunning procedure is
specified
sales deal processing
[standard]decentralized processing
not required
maintain dunning datacustomer is one-time
customer
determine foreign trade
data
foreign trade data
determined
dunning block is
specified
customer hierarchy
processing [standard]create unloading point
maintain
correspondence
correspondence is
maintained
sales summary
processing [standard]create receiving point
receiving point has been
created
assign receiving point to
an unloading point
customer unloading pnts
have been maintained
maintain credit
management data
credit management data
determined
batch search strategy
processing [standard]create department
department has been
created
assign department to a
receiving point
classification [classification
system] [standard]maintain contact
persons
contact person data are
maintainedplant processingsales personnel
master processing
(tacit) depends on
familiarity with customers
and interaction with customer spayment card
setup
conditions processing
(purchasing)specify address of
customer
address is specified
interest calculation is
specified
plant processingmaintain accounting
informationsold-to party to be
created
customer is also vendor
planning group is
specified
customer-material-info
processing [standard]maintain account control
maintain sales dataship-to party to be
created
trading partner is
specified
clearing between
customer/vendor
specified for automatic
payments
basic data processing for
legal controls [standard]management of physical
samplespayer to be created
specify company code
company code is
specified
bank details are
specified
possible payment
methods are specified
customer volume rebate
agreement processing
[normal]customer master record
is to be created
specify payment
transaction data
manual sample releasedetermine customer
function
invoice recipient is to be
created
account group with
internal number
assignment determined
define customer number
customer number is
determined
payment card data is
maintained
sales area data are
maintained
maintain payment
information
alternative payer
specific to company
code specified
create customer
customer master record
is created
material listing/exclusion
[standard]sales personnel is
processed
specify account group
maintain control datasample receiver to be
created
account group with
external number
assignment determined
alternative payer for
customer specified
line item settlement is
specified
product allocation [standard]specify alternative payer
maintain messages
decentralized processing
requiredcustomer to be created
for statistical purposes
alternative payer for
item allowed
payment block is
specified
basic data processing for
legal controls [standard]maintain partner
functions
check if decentralized
handling is desiredcustomer is assortment
customer
maintain marketing data
marketing data are
maintained
dunning procedure is
specified
sales deal processing
[standard]decentralized processing
not required
maintain dunning datacustomer is one-time
customer
determine foreign trade
data
foreign trade data
determined
dunning block is
specified
customer hierarchy
processing [standard]create unloading point
maintain
correspondence
correspondence is
maintained
sales summary
processing [standard]create receiving point
receiving point has been
created
assign receiving point to
an unloading point
customer unloading pnts
have been maintained
maintain credit
management data
credit management data
determined
batch search strategy
processing [standard]create department
department has been
created
assign department to a
receiving point
classification [classification
system] [standard]maintain contact
persons
contact person data are
maintainedplant processingsales personnel
master processing- 11 - 
  2) the next step has been the development and formalization of a new and dedicated 
reference modelling language , which supports the specification of these 
configuration patterns. this task has been constrained by the desire to rather 
extend current reference modelling languages than to develop an entire new language. this has been motivated by the significant development efforts that 
have been invested in reference models already. we selected epcs as the starting 
point for our research due to the popularity of this language for the design of reference models. 
3) the proposed configurable reference modelling language and the corresponding 
notation will be rigorously tested  in two ways. first, experiments with 
experienced business process analysts will be conducted. the selected group of 
analysts will be familiar with sap, process modelling and reference modelling. 
these studies will examine the quality and time of comprehension using a configurable epc in comparison with current process models. second, focus groups with sap application consultants who are using the sap reference model in their consulting practice will be conducted in order to further explore issues 
related to the acceptance of the proposed new modelling techniques. 
this paper reports on the second phase, i.e. the proposed configurable reference 
modelling language. this language is only focused on the so called essential 
configurations, i.e. the system variability as it is visible and relevant to the project team, 
and not the technical configurations, which subsume aspects related to the technical realisation [21]. - 12 - 
  4 requirements for a configurable reference modelling technique 
reference modelling languages have to be configurable. a configurable modelling 
language is characterised by its capabili ty to support decisions at build time, i.e. the 
model user can individualise the model by selecting from alternative options before 
instances will be derived from it. this means that they should not only capture decisions 
on an instance level, but also on a type level. unlike decisions on an instance level, i.e. at 
runtime, decisions on a type level, i.e. at build time, have an impact on the model and its 
actual structure. such configuration decisions have to be clearly differentiated from 
runtime decisions and can be highlighted as variation points  in a model [21]. a variation 
point captures a decision point together with the related possible choices. furthermore, a configurable reference modelling language has to consider the following requirements. 
a) the language has to support configurations regarding entire processes,  functions, 
control flow and data . 
b) it should be possible to differentiate configuration decisions into mandatory and 
optional  decisions. mandatory decisions have to be made before the very first 
instance can be derived from this model. the decision could be not to use a 
certain variant. optional decisions can initially be neglected. it should be possible 
to maintain defaults  for optional configuration decisions. this allows the 
instantiation of the model even without explicitly making all possible decisions.  
c) configuration should be differentiated into global and local  decisions. global 
decisions are based on the general context and can be made without studying the individual process model. such context information includes industry, country, 
size etc. the relevant context factors have to be maintained for every variation - 13 - 
  point. as soon as information regarding the relevant context has been provided, a 
first (hidden or background) configuration of the reference model can take place. 
local configurations require an explicit study of the relevant process model. in 
these cases the decision maker has to consider the available individual choices and make a trade-off decision. 
d) configuration decisions should also be differentiated into critical and non-critical  
decisions. critical decisions have signific ant impact on the use of the system, can 
often not be re-done and should be made by the project team. non-critical 
decisions are of minor importance, can be changed over time and can be made by 
individual team members. 
e) configuration decisions can have interrelationships . any pre-requisites for a 
configuration decision should be clearly highlighted. this can include other 
decisions, which have to be made before. moreover, any impact of one decision on other decisions has to be depicted. this means, a logical order between configuration decisions has to be considered. this includes interrelationships within one model, between two process models but also interrelationships 
between a reference process model and a related reference data model [35]. 
f) configuration decisions can be made on different levels . for example, a first 
configuration of the sap reference model might be an individualization for an 
entire global organization. the next level of configuration can be made for a 
certain country or business unit. - 14 - 
  g) variation points should refer to further related information within the enterprise 
system . this can include the system online help and the system configuration 
module, i.e. in sap the implementation guide. such information can provide 
valuable support for the decision maker. 
h) the entire configuration process should also be guided by recommendations or 
configuration guidelines . such information could come as benchmarking data 
from the outside of the system if a critical mass of system users is willing to provide the required data. it can include information such as the processing time 
of a given process path, the number of ti mes a decision has been made in the same 
industry or the required investments and implementation time for a certain configuration.  
i) enterprise system reference models are already very comprehensive. any further 
extension of these modelling languages has to carefully consider the impact on the 
perceived model complexity . 
the following section introduces configurable epcs as an approach to capture variation 
points in a reference process model. at the end of the next section we will reflect on the 
requirements identified. - 15 - 
  5 configurable  event-driven process chains (c-epcs) 
before introducing configurable epcs (c-epc s), we first formalize the notion of the 
classical epc. then c-epcs are introduced and formalized followed by a definition of 
their semantics and a discussion on partially configured c-epcs. the section is 
concluded by some reflections on the requir ements stated in the previous section. 
5.1 formalization of epcs 
in this section, we give a formal definition of an epc. this definition is based on the 
restrictions described in [23] and imposed by tools such as aris and sap r/3 and allows 
us to specify the requirements an epc should satisfy. note that we need to provide a formal definition of epcs to be able to precisely define the notion of configuration we are 
after.  
definition 1  [epc (1)] an 
 event-driven process chain is  a five-tuple (e,f,c,l,a):  
- e is a finite (non-empty) set of events,  
- f is a finite (non-empty)  set of functions,  
- c is a finite set of logical connectors,  
- l ∈ c → { ∧, xor, ∨} is a function which maps each connector onto a 
connector type,  
- a ⊆ (e ×f) ∪(f ×e) ∪(e ×c) ∪(c ×e) ∪(f ×c) ∪(c ×f) ∪(c ×c) is a set of 
arcs. 
an epc is composed of three types of nodes: events ( e), functions ( f) and connectors 
(c).  figure 1 shows an epc containing 10 events, 4 functions and 4 connectors. the type 
of each connector is given by the function l: l(c) is the type ( ∧, xor , or ∨) of a connector 
c ∈ c. relation a specifies the set of arcs connecting functions, events and connectors. 
definition 1 shows that it is not allowed to have an arc connecting two functions or two 
events. there are many more requirements an epc should satisfy, e.g., only connectors - 16 - 
  are allowed to branch, there is at least one start event, there is at least one final event, and 
there are several limitations with respect to the use of connectors. to formalize these 
requirements we need to define some additional concepts and introduce some notations.  
definition 2  [directed path, elementary path] let epc be an event-driven process 
chain. a directed path p from a node n 1 to a node n k is a sequence 〈n1, n2, …, nk 〉 such 
that 〈ni,ni+1 〉 ∈ a for 1 ≤ i ≤ k−1.  
the definition of directed path will be used to limit the set of routing constructs that may 
be used. it also allows for the definition of cef (the set of connectors on a path from an 
event to a function) and cfe (the set of connectors on a path from a function to an event). 
cef and cfe partition the set of connectors c. based on the function l we also partition c 
into c∧, c∨, and cxor. the sets cj and cs are used to classify connectors into join 
connectors and split connectors.  
definition 3  [n, c ∧, c∨, cxor, •, cj, cs, cef, cfe] let epc=(e, f, c , l, a) be an  event-
driven process chain.  
 
- n = e ∪f ∪c is the set of nodes of epc.  
- c ∧ = { c ∈ c  |  l(c) = ∧}  
- c ∨ = { c ∈ c  |  l(c) = ∨}  
- c xor = { c ∈ c  |  l(c) = xor }  
- for n ∈ n: 
    •n = { m  |  (m,n) ∈ a } is the set of input nodes, and 
    n • = { m  |  (n,m) ∈ a } is the set of output nodes.  
- c j = { c ∈ c  |  |•c| ≥ 2 } is the set of join connectors.  
- c s = { c ∈ c  |  |c•| ≥ 2 } is the set of split connectors.  
- c ef ⊆ c such that c ∈ cef if and only if there is a path p = 〈n1, n2, …, nk−1, nk 〉 
such that n 1 ∈ e, n 2, …,nk−1 ∈ c, n k ∈ f, and c ∈ { n 2, …, nk−1 }.  
- c fe ⊆ c such that c ∈ cfe if and only if there is a path p = 〈n1, n2, …, nk−1, nk 〉 
such that n 1 ∈ f, n 2, …,nk−1 ∈ c, n k ∈ e, and c ∈ { n 2, …, nk−1 }. 
- c ee ⊆ c such that c ∈ cee if and only if there is a path p = 〈n1, n2, …, nk−1, nk 〉 
such that n 1 ∈ e, n 2, …,nk−1 ∈ c, n k ∈ e, and c ∈ { n 2, …, nk−1 }. 
- c ff ⊆ c such that c ∈ cff if and only if there is a path p = 〈n1, n2, …, nk−1, nk 〉 
such that n 1 ∈ f, n 2, …,nk−1 ∈ c, n k ∈ f, and c ∈ { n 2, …, nk−1 }. 
 
 - 17 - 
  these notations allow for the definition of syntactical correctness for epcs.  
definition 4  [epc (2)] an  event-driven process chai n  epc = (e,f,c,l,a) is 
syntactically correct if and only if  th e following requirements are satisfied:  
 
- the sets e, f, and c are pairwise disjoint, i.e., e ∩f = ∅, e ∩c = ∅, and f 
∩c = ∅.  
- for each e ∈ e: |•e| ≤ 1 and |e•| ≤ 1.  
- there is at least one event e ∈ e such that |•e| = 0 (i.e. a start event).  
- there is at least one event e ∈ e such that |e•| = 0 (i.e. a final event).  
- for each f ∈ f: |•f| = 1 and |f•| = 1.  
- for each c ∈ c: |•c| ≥ 1 and |c•| ≥ 1.  
- c j and c s partition c, i.e., c j ∩cs = ∅ and c j ∪cs = c.  
- c ee and c ff are empty, i.e., c ee  = ∅ are c ff  = ∅. 
- c ef and c fe partition c, i.e., c ef ∩cfe = ∅ and c ef ∪cfe = c. 
the first requirement states that each component has a unique identifier (name). note that 
connector names are omitted in the diagram of an epc. the other requirements 
correspond to restrictions on the relation a. events cannot have multiple input arcs and 
there is at least one start event and one final event. each function has exactly one input 
arc and one output arc. a connector c is either a join connector ( |c•| = 1 and |•c| ≥ 2) or a 
split connector ( |•c| = 1 and |c•| ≥ 2). the last requirement states that a connector c is 
either on a path from an event to a function or on a path from a function to an event. 
clearly, the epc shown in figure 1 satisfies the requirements and is therefore syntactically correct. in the remainder of this paper we assume all epcs to be 
syntactically correct.  
note that {c
j, cs}, {cef, cfe}, and {c∧, cxor, c∨} partition c, i.e., cj and cs are disjoint 
and c = c j ∪cs, cef and cfe are disjoint and c = c ef ∪cfe, and c∧, cxor and c∨ are 
pair-wise disjoint and c = c ∧ ∪cxor ∪c∨. in principle there are 2 × 2 × 3 = 12 kinds of 
connectors! in the original definition of epcs  [23] two of these 12 constructs are not - 18 - 
  allowed: a split connector of type cef cannot be of type xor  or ∨, i.e., cs ∩cef ∩cxor = 
∅ and cs ∩cef ∩c∨ = ∅. as a result of this restriction, there are no choices between 
functions sharing the same input event. a choice is resolved after  the execution of a 
function, not before . in the formalization of epcs, we will not impose this restriction and 
consider cs ∩cef ∩cxor = ∅ and cs ∩cef ∩c∨ = ∅ as a guideline rather than a 
requirement.  
5.2 on the semantics of epcs   
definition 4 only provides syntactical requirements and does not make any statements 
about the behaviour of the corresponding epc. for example, one could easily construct 
an epc which contains a deadlock, e.g., in a model an xor-split connector could split 
two flows which are joined using and and-join connector thus resulting in a deadlock at runtime. in this paper, we do not consider is sues related to the verification of the dynamic 
behaviour of epcs. this is outside the scope of the paper and there is no general consensus on the semantics of epcs. when we turn to configurable epcs we will also 
only consider their syntactical correctness and not issues related to their dynamic 
behaviour. nevertheless, we briefly discuss some related work. since their original definition in 1992 [23], the semantics of epcs have often been debated in literature 
[1,3,14,25,29,36]. in the original article [23] but also in later work of the authors only an 
informal definition of the semantics was given. this triggered many questions. for example, epcs allow for or-joins. although, the intent of an or-join connector can 
often be derived from the context, its semantics is not clear. note that an or-join may 
synchronize or not,  i.e., it may continue after the first input or wait for more to come. in 
fact, in [3] it is shown that no suitable semantics exists for the or join. these problems - 19 - 
  triggered two types of approaches: (1) approaches that provide formal semantics by 
mapping epcs onto a language with formal semantics ( e.g., petri nets)  [1,25,29,36] and 
(2) approaches that provide a way to refine a given  epc into a model with formal 
semantics (e.g., by a designer selecting the desirable behaviour) [14]. in this paper, we assume only an informal semantics. in fact , we express the semantics of configurable 
epcs in terms of ordinary epcs. this makes our approach independent of the particular 
semantics chosen for epcs. in other words, any of the formalization approaches mentioned [1,3,14,25,29,36] can be used as a semantical foundation. 
5.3 configurable epcs 
this section introduces the notion of a configurable epc  (c-epc). let us return to the 
initial example shown in figure 1. as was ar gued, the exclusive or  connector was not 
necessarily a decision at run-time but could also be configuration decision at build-time. 
for example, it could be decided at build-time that only the middle branch (invoice 
processing with reference) would be enabled. this would result in an epc where the two 
other branches are blocked, as shown in figure 4. the main goal of a c-epc is to be able to specify that a concrete epc is an acceptable configuration or not.  - 20 - 
  fig. 4:  example for a model derived from the initial example (figure 1)  
in a c-epc functions and connectors can be configurable. configurable functions may be 
included ( on), skipped ( off ) or conditionally skipped ( opt ). configurable connectors 
may be restricted at build-time time, e.g., a configurable connector of type ∨ may be 
mapped onto an ∧ connector. local configuration choices like skipping a function may be 
limited by configuration requirements. for example, if one configurable connector c of 
type ∨ is mapped onto an ∧ connector, then another configurable function f needs to be 
included. this configuration requirement may be denoted by the logical expression 
c=∧⇒ f=on . to guide the configuration process there is also a partial order suggesting goods receipt
postedservice
is accepted
invoice
received
release
invoiceinvoice processing
with referencepurchase
order
created
invoice
postedevaluated
receipt
settlementgoods receipt
postedpurchase
order
created
invoicing plan
settlementgoods receipt
postedpurchase
order
createdgoods receipt
postedservice
is accepted
invoice
received
release
invoiceinvoice processing
with referencepurchase
order
created
invoice
postedevaluated
receipt
settlementgoods receipt
postedpurchase
order
created
invoicing plan
settlementgoods receipt
postedpurchase
order
created- 21 - 
  the order of configuration. moreover, besides the configuration requirements there may 
also be configuration guidelines. one can think of configuration requirements as hard 
constraints and interpret configuration guidelines as soft constraints.  
definition 5  [configurable epc] a configurable epc (c-epc) is a ten-tuple 
(e,f,c,l,a,fc,cc,oc,rc,gc):  
 
- e, f, c, l, and a are as specified in definition 1 satisfying the constraints mentioned in definition 4,  
- f
c ⊆ f is the set of configurable functions,  
- cc ⊆ c is the set of configurable connectors,  
- oc ⊆ (fc ∪cc) ×(fc ∪cc) is a partial order over the configurable nodes 
suggesting the order of configuration,  
- rc is a set of configuration requirements, and  
- gc is a set of configuration guidelines. 
 both r
c and gc are sets of logical expressions where the atomic statements bind the 
configurable nodes to concrete values, e.g., "c=xor" and "f=on" where c is a 
configurable connector and f is a configurable function.  
configurable nodes are denoted by thick circles (for configurable connectors) or thick 
rectangles (for configurable functions). configuration requirements are denoted by dotted 
lines connecting the configurable nodes the logical expression refers to and configuration guidelines are denoted by dashed lines connecting the configurable nodes the logical 
expression refers to (see figure 5). the partial order of configurable nodes o
c is not 
shown in the example of figure 5.  
a configurable function may be configured as included ( on), skipped ( off ) or 
conditionally skipped ( opt ). configurable connectors are mapped onto a concrete choice 
for the split or join considered. clearl y, a configurable connector of type ∧ may not be 
mapped onto a concrete connector of type ∨. the concrete connector should always 
represent a behaviour allowed by the configurable connector, i.e., the configuration 
process only restricts the possible execution sequences. in case of a configurable - 22 - 
  connector of type xor  or ∨, also only one of the options may be selected, e.g., if a split 
connector c has an output function  f, then c=seq f denotes that function f is always 
selected. 
in figure 5 there are three configurable functions: a, e, and f. each of these three 
functions can be configured as included ( on), skipped ( off ) or conditionally skipped 
(opt ). the other three functions cannot be configured, i.e., are always “ on”. there are 
four connectors and only the xor connector is configurable. the configurable xor 
connector can be set to xor ( i.e., a choice at runtime), or select one of the two paths 
(i.e., at configuration time the left-hand side or right-hand side is selected).  figure 5 also 
shows a requirement and a guideline. the requirement states that if a is configured as 
off , the path starting with event 3 should no be selected. the guideline states that if e is 
configured as on, then f should also be configured as on (and visa versa).  - 23 - 
  fig. 5:  example for a c-epc  
configurable connectors can only be configured to a connector type that restricts its 
behaviour. for example, a configurable or connector may be mapped onto an and connector,  but it is not possible to map an xor connector onto an and connector. 
table 1 illustrates the configuration rules for connectors. this table only describes the 
overall constraints. each row corresponds  to a configurable connector type (or
c, xorc, 1
a
xor
3
d4
e
6 75
f
8and
b
and
2
andcrequirement 1
a=off  ⇒
xor1 ≠ seq3
xor1
guideline 1
e=on  ⇔ f=onnormal connectorconfigurable
connectornormal function
configurable function
requirement
guideline- 24 - 
  andc), e.g., an orc may be mapped onto an or ( ∨), xor, and ( ∧), or seq ( seq n for 
some node  n). 
 or xor and seq 
orc x x x x 
xorc  x  x 
andc   x  
table 1:  constraints for the configuration of connectors   
to formalize the constraints shown in table 1 we defined a partial order ≤ c. this partial 
order is used to specify which concrete connector type may be used for a given connector 
type, i.e., x ≤ c y if and only if a connector of type y may be configured to  x (e.g., ∧ ≤ c ∨ 
but not ∨ ≤ c ∧).  
definition 6  [ ≤ c, ct, cts] ≤ c defines a partial order on ct = { ∧, xor, ∨} ∪cts 
where cts={ seq n  |  n ∈ e ∪f ∪c}. ≤ c = { ( ∧,∧), (xor,xor), ( ∨,∨), (xor, ∨), (∧,∨) } 
∪{ (n,xor)  |  n ∈ cts} ∪{ (n,∨)  |  n ∈ cts} ∪{ (n,n)  |  n ∈ cts}.  
note that ≤ c = { (n,n)  |  n ∈ ct} ∪ (xor ,∨)∪ (∧,∨) ∪ { (n 1,n2)  |  n1 ∈ cts  ∧ n2 ∈ 
{xor, ∨}}.  
recall that this partial order is motivated by the fact that the configurable connector has to subsume the 
behaviour of the concrete connector. a configuration maps all configurable nodes onto concrete 
values like on, off , and opt  for functions and ∧, xor , ∨, and seq n for connectors.  
definition 7  [configuration] let cepc=(e,f,c,l,a,fc,cc,oc,rc,gc) be a c-epc. lc ∈ 
(fc → { on, off, opt })  ∪ (cc → ct) is a configuration of cepc if for each c ∈ cc:  
 
- lc(c) ≤ c l(c)  
- if lc(c) ∈ cts and c ∈ cj, then there exists an n ∈ •c such that lc(c) = seq n,  
- if lc(c) ∈ cts and c ∈ cs, then there exists an n ∈ c• such that lc(c) = seq n, 
 
function lc maps configurable functions onto values like on, off , and opt , i.e., lc(f) ∈   
{on, off, opt} for f∈ fc. configurable connectors are mapped onto the set ct, i.e., - 25 - 
  lc(c) ∈ ct for c∈ cc. clearly this mapping should be consistent with table 1 and the 
partial order ≤ c. moreover, if lc(c) = seq n, then n should be in the preset (for a join 
connector) or postset (for a split connector) of  c.  
figure 6 shows two epcs resulting from a configuration. consider the epc shown in 
figure 6(a), i.e., the epc in the left hand side. if we use the configuration 
{(a,off),(xor 1,seq and3),(e,on),(f,on)} , we obtain this epc. note that because 
function a is not needed, the and-split and and-join also were removed. functions e 
and f are both on thus satisfying the guideline. the requirement shown in figure 5 is also satisfied. since a is skip ped, the configurable xor-split xor
1 could not be set to 
seq 3 without violating this requirement. figure 6(b), i.e., the epc in the right hand side, 
results from the configuration {(a,on),(xor 1,seq 3),(e,off),(f,off)}. this 
configuration specifies that function a is always used and the configurable xor-split is 
set to take only the left path involving function d. the setting of the two remaining 
configurable functions ( e and f) is not relevant since they are not reachable because of 
the configuration of the xor-split. - 26 - 
  fig. 6:  two configurations of the c-epc shown in figure 5  
the example in figure 7 shows that optional fu nctions might lead to problems. the left-
hand side of this figure shows a c-epc with a configurable function a. the right-hand 
side shows possible configurations. in the left-most variant lc(a)=on  (variant 1) and a 
is simply included. for variant 2 lc(a)=off  and the function is skipped and the two 
events are merged. in case lc(a)=opt  two variants are possible. the first one (left) 
simply inserts an or-split and an or-join connector to bypass a. this solution however 
violates the guideline/rule that an event should not be followed by an or-split, cf. section 5.1 and [23]. one way to solve this is to add an additional function z and an 
additional events (1a) as shown in the right-most variant in figure 7. the complication of 
this last construct is that configurations like l
c(a)=opt  should be augmented with an 1
4
e
75
f
8b
2
andc1
a
3
d
6and
b
and
2
c(a) (b)
 - 27 - 
  additional decision function z. we will not enforce this but envision some post 
processing where fragments involving an event followed by an or-split are refined as 
shown in figure 7. we will not add this refinement to the formalizations given in this 
section. 
fig. 7:  example for a configuration with additional elements 
as indicated before, rc and gc are sets of logical expressions where the atomic 
statements bind the configurable nodes to concrete values. configurable functions are 
mapped onto the set { on, off , opt  } and configurable connectors are mapped onto { ∧, 
xor , ∨} ∪{ seq n  |  n ∈ e ∪f ∪c}. examples illustrating the syntax of these atomic 
statements are “ c=xor ” and “ f=on ”. these statements correspond to respectively 1
a
2
b
3xor
c-epcvariant 1
(a= on )variant 2
(a= off )variant 3
with additional function  z1
a
2
b
31 / 2
b
31
a
2
b
3xor1az
1
a
2
b
3xorxor
variant 3
(a = opt )skipa- 28 - 
  lc(c)=xor  and lc(f)=on  for some configurable connector c and some configurable 
function f. suppose that c1,c2 ∈ cc and f1,f2 ∈ fc. examples of hard/soft constraints ( i.e., 
requirements in rc or guidelines in gc) are: (1) c1=∧⇔ f1=on ∧f2=on , (2) f1=on 
∨f2=on , and (3) c1=∧⇒ c2=∧. note that in figure 5 already a requirement ( a=off ⇒ 
xor 1 ≠ seq 1) and a guideline ( e=on ⇔ f=on ) have been given. 
configurations may have guidelines and/or requirements that are conflicting, e.g., in 
figure 5 we can add the following two requirements a=off ⇔ e=on and a=off 
⇔ f=off . clearly there requirements are conflicting with the original guideline. if there 
are no conflicting requirements the model is valid. if, in addition, the guidelines are not 
conflicting, the configuration is suitable. 
definition 8  [valid/suitable configuration] let cepc=(e,f,c,l,a,fc,cc, oc,rc,gc) be a 
c-epc and lc a configuration of cepc. lc is a valid configuration if it satisfies all 
configuration requirements, i.e., it satisfies all logical expressions in rc. lc is a suitable 
configuration if it is valid and it satisfies all configuration guidelines, i.e., it satisfies all 
logical expressions in rc and gc.  - 29 - 
  fig. 8:  examples for invalid configurations 
a configuration is valid if it satisfies all requirements. figure 8 shows some examples for 
invalid configurations. since we want to avoid c-epcs that have no valid configurations, we introduce the notion of a "satisfiable" c-epc. 
definition 9  [satisfiable] let cepc=(e,f,c,l,a,f
c,cc,oc,rc,gc) be a c-epc. cepc is 
satisfiable if and only if there is valid configuration. 
give the fact that all requirements and guidelines are logical expressions it is fairly easy 
to provide tool support to guide the designer towards a valid configuration. 
5.4 semantics of configurations 
in examples we already showed that a configuration corresponds to a concrete epc. now 
we provide an algorithm to construct an epc based on a c-epc and a configuration. note that a c-epc defines a space of concrete epcs. each valid configuration maps a c-
epc onto a concrete epc. the function β maps a c-epc and its configuration onto a 
concrete epc β(cepc ,l
c).  1
a
xor
2
b4
c
3 51
a
and
2
b4
c
3 51
a
2
d
31
a
4
c-epcinvalid variant
(wrong connector)invalid variant
(new function, d)invalid variant
(missing function)- 30 - 
  definition 10  [β] let cepc=(e,f,c,l,a,fc,cc,oc,rc,gc) be a c-epc and lc a 
configuration of cepc. the corresponding epc β(cepc,lc) is constructed as follows:  
1. epc 1=(e,f,c,l 1,a1) with l 1 = {(c,l(c)) |  c ∈ c\cc} ∪{(c,lc(c)) |  c ∈ cc} and a 1 = a 
\({(c,n) ∈ cs × c•  |  ∃n′ ∈ c• lc(c)=seq n′ ∧n ≠ n′} ∪{(n,c) ∈ •c ×c j  |  ∃n′ ∈ •c 
lc(c)=seq n′ ∧n ≠ n′}) is the epc obtained by mapping the configurable connectors 
onto their concrete type and removing arcs not involving the selected sequence.3 
2. for each f ∈ fc such that lc(f) = off, rename the function to skip f to reflect that the 
corresponding function is not executed. if •f ∪f• ⊆ e, then merge input and output 
event into one, i.e., epc 2=(e 2,f2,c,l 1,a2) with e 2 = (e ∪{e}) \( •f ∪f•), f 2 = f\{f}, 
and a 2 = { (n 1,n2) ∈ a  |  {n 1,n2}∩(•f ∪f•)=∅} ∪{ (n 1,e)  |  (e 1 ∈ •f) ∧(n1,e1) ∈ a} ∪{ 
(e,n 2)  |  (e 2 ∈ f•) ∧(e2,n2) ∈ a} where e is the new connector (no name clashes, i.e., e 
∉ n) merging the old input and output connector. repeat this for each f of this type 
and let epc 2 be the resulting epc.4 
3. for each f ∈ fc such that lc(f) = opt, add function skip f , a split connector split f, and 
a join connector join f making f optional, i.e., epc 3=(e 2,f3,c3,l3,a3) with f 3 
=f 2∪{skip f}, c 3 = c∪{split f,join f}, l3=l1∪{ (split f,xor),(join f,xor) }, a 3 = { (n 1,n2) 
∈ a2  |  f ∉ {n1,n2}} ∪{(split f,f),(split f,skip f),(skip f,join f),(f,join f)} ∪{ (n,split f)  |  (n,f) ∈ 
a2} ∪{ (join f,n)  |  (f,n) ∈ a2}. repeat this for each f of this type and let epc 3 be the 
resulting epc. 
                                                           
3  note that such an epc may not satisfy all the requirements stated in definition 4. 
4  note that it is not always possible to remove functions that are connected to a connector since connectors 
are either on a path from an event to a function or vice versa. - 31 - 
  4. remove all connectors with just one input and one output node, i.e., 
epc 4=(e 2,f3,c4,l4,a4) with c 4 = {c ∈ c3  |  |c•| > 1  ∨ |•c| > 1}, l 4 = {(c,x) ∈ l3  |  c ∈ 
c4}, and a 4 = { (n 1,n2) ∈ a3  |  {n 1,n2}∩(c3\c4) = ∅} ∪{(n1,n2)  |  ∃c ∈ c3\c4  
{(n1,c),(c,n 2)} ∈ a3}. 
5. remove all isolated nodes, i.e., nodes without input and output arcs. 
6. re-apply step 2 of the algorithm, i.e., try to remove the remaining functions labelled 
“skip f”. 
7. remove all nodes not on some path from a start event to a final event. consider only 
start and final events also present in original epc, i.e., not the new start/final events 
that may have been introduced in e.g. step 1. 
8. re-apply step 4 of the algorithm, i.e., remove connectors with just one input and one 
output node that may have been introduc ed in step 7. the resulting epc is 
β(cepc,lc). 
it is easy to verify that the examples given thus far are indeed consistent with the 
algorithm. although definition 10 suggests that β(cepc,lc) is indeed an epc satisfying 
the requirements mentioned before, this remains to be proven.  
theorem 1  [β(cepc,lc) is an epc] let cepc=(e,f,c,l,a,fc,cc,oc,rc,gc) be a c-
epc and lc a configuration of cepc. β(cepc,lc) is an epc satisfying all requirements 
stated in definition 4.  
proof.  
epc 0=(e,f,c,l,a)  satisfies all requirements by definition. next we check how the 
requirements are affected by the seven steps.  - 32 - 
  - the sets e, f, and c are pair-wise disjoint. although not always stated explicitly we 
assume no name clashes.  
- for each e ∈ e: |•e| ≤ 1 and |e •| ≤ 1. cardinality of number of input and output 
nodes for events is not changed. step 2 may merge two events but does not 
jeopardize this requirement. all other steps can only reduce the number of 
inputs/outputs. 
- there is at least one event e ∈ e such that |•e| = 0 (i.e. a start event). start events are 
not removed. 
- there is at least one event e ∈ e such that |e•| = 0 (i.e. a final event). final events 
remain final events. 
- for each f ∈ f: |•f| = 1 and |f •| = 1. functions may be removed but the cardinality of 
number of input and output nodes for functions is not changed. 
- for each c ∈ c: |•c| ≥ 1 and |c•| ≥ 1. existing connectors and newly added connectors 
(split f, join f) satisfy this requirement. 
- cj and cs partition c. this guaranteed by step 4. 
- cef and cfe partition c. the nature of connectors is never changed. 
we will now use the initial example shown in figure 1 to summarize the 
recommendations for a configurable reference modelling language. the example is a condensed version of the reference model for invoice verification as it can be found in the 
enterprise system sap r/3 ver. 4.6c. figure 1 showed the current non-configurable 
reference model, figure 4 provided an example for one model, which can be derived from this reference model. 
the model depicted in figure 1 can be perceived as a ‘max-epc’ as it includes all 
possible ways of invoice verification supported by the sap system. a more detailed 
analysis, however, shows that this model in cludes many optional elements. the core of 
this process is the classical invoice processing with reference to a purchase order, a 
delivery note or service entry sheet and the actual invoice. this process is mandatory and - 33 - 
  all elements have to be configured. evaluated receipt settlement (ers) is an option that 
allows bypassing the entire classical invoice verification process. based on long term 
contracts and a clear specification of the goods, invoices are posted and released based on 
the arrival of goods which conform in quantity and quality to the specifications of the purchase order or contract. thus, ers is typically only a relevant option, if the company 
is of significant size and the business relationship is based on a highly repetitive 
purchasing process based on a long-term contract with a clear specification of the payment details. in a similar way, invoice plan settlement is an optional function. in this 
case, invoices are consolidated in an invoice plan and scheduled over a series of future 
dates independently of individual procurement transactions and the actual receipt of goods and services. this is relevant for re gularly recurring procurement transactions ( e.g. 
car leasing, subscriptions) (so called periodic invoicing plan) and transactions that are 
subject to stage payments ( e.g. a building project) (so called partial invoicing plan). 
invoicing plan settlement facilitates the au tomatic creation and payment of invoices and 
uses functionality of the evaluated receipt settlement solution [37]. figure 9 shows the reference model in c-epc notation that ca n be derived from this description. - 34 - 
   
 
fig. 9:  the example from figure 1 in c-epc notation 
 
5.5 partially configured c-epcs 
definition 7 assumes a complete configuration, i.e., lc is a complete function mapping 
each configurable node onto a concrete value. however, the configuration process may go through several stages and therefore we also add the notion of a partial configuration.  
definition 11  [partial configuration] let cepc=(e,f,c,l,a,f
c,cc,oc,rc,gc) be a c-
epc. lc ∈ (fc→/    {on, off, opt })  ∪ (cc →/    ct)5 is a partial configuration of cepc if 
for each c ∈ cc ∩dom(lc):  
 
- lc(c) ≤ c l(c)  
- if lc(c) ∈ cts and c ∈ cj, then there exists an n ∈ •c such that lc(c) = seq n,  
- if lc(c) ∈ cts and c ∈ cs, then there exists an n ∈ c • such that lc(c) = seq n, 
                                                           
5  note that partial functions are denoted by a→/    b, i.e., a f∈ a→/    b is a function with a domain that is a 
subset of a. goods receipt
postedservice
is accepted
invoice
received
release
invoiceinvoice processing
with referencepurchase
order
created
evaluated
receipt
settlementinvoicing plan
settlement
payment
must
be effectedgoods receipt
postedpurchase
order
createdgoods receipt
postedpurchase
order
created
invoice
postedguideline 1
ers =on, if
- long term contract
- goods and conditions
are specified
requirement 1
ips=on   ⇒
ers=on- 35 - 
  one can think of a c-epc with a partial configuration as another c-epc. using an 
algorithm similar to the one described in definition 10, one can transform c-epc with a 
partial configuration into a new c-epc. we omit details, but it is straightforward to 
realize this using definition 10. simply co nsider the configurable nodes that are not 
configured as unconfigurable nodes when applying the algorithm. let β′ be the modified 
algorithm which transforms a c-epc with a partial configuration into a new c-epc.  
without proof we give the following theorem.  
theorem 2  [β(cepc,lc) is an epc] let cepc 1 be a c-epc and lc a partial 
configuration of cepc. cepc 2=β′(cepc 1,lc) is the corresponding c-epc.  
 
- if cepc 2 is satisfiable, then cepc 1 is also satisfiable.  
- if lc
2 is a valid (suitable) configuration of cepc 2, then lc
2 is also a valid 
(suitable) configuration of cepc 1 
the above allows us to indicate whether a partial configuration of a c-epc is satisfiable.  
 the concept of partial configured c-epc open s up interesting possibilities. consider for 
example a configurable enterprise system like sap. there could be a top-level c-epc which indicates all possible configurations of sap with respect to a given process. this 
c-epc could be partially configured per industry. (recall that sap has 27 alternative 
industry solutions, as indicated in section 3.) in other words, for each industry there are partial configured c-epcs. such partial configured c-epcs can be used as a starting 
point within a given organization. for large organizations there may be different versions 
of the same process, e.g., per country or per region. however, at the same time the 
organization may want to enforce some unification. therefore, the industry specific c-
epc may be partially configured into an organization-specific c-epc. the latter c-epc may be configured within specific parts of the organization ( e.g., per region). this - 36 - 
  example shows that it may be worthwhile to have (partially configured) c-epcs at 
different levels where at each level the lower level is a (partial) configuration of the upper 
level. for example, there may be a c-epc at the level of sap (what can the system do?), 
at the level of an industry (what configurations of sap make sense for the automotive industry?), and at the level of one organization (what configurations do we allow within 
our organization?). only the c-epc at the organizational level is configured completely 
to support a concrete process within some part of the organization (how do we do this process within the eindhoven branch of our organization?). 
apart from configuration at various levels there can always be the need for customization 
(i.e., support processes that do not fit into the c-epc). the latter should be avoided (if 
possible) since it is risky and costly. if customization is unavoidable, it may be interesting 
to use the notions of inheritance described in [2,5]. these notions of inheritance can 
easily be applied to epcs and c-epcs. the topic of customization is however out of the scope of this paper. 
5.5 extensions 
to conclude this section we reflect on the re quirements given in section 4 in the context 
of the c-epc language just defined.  
a)
 the c-epc language defined in this section mainly focuses on the process and 
control-flow aspects. the data aspect and function aspect have not been addressed explicitly. note that functions can be configured but this only refers to their 
presence rather than the functionality of these functions.  
b)
 c-epcs do not distinguish between mandatory and optional decisions. however, it is fairly easy to add this functionality. it could be defined as an extension of the - 37 - 
  partial order oc. it is also possible to extend the language with defaults for 
optional configuration decisions.  
c) c-epcs do not differentiate between global and local decisions. again it is fairly 
easy to add this as an attribute to all configurable nodes. however, the real challenge is to get this information. 
d)
 similarly remarks hold for the differenc e between critical and non-critical 
decisions.  
e) configuration decisions can have interrelationships. this is partly covered by the 
requirements ( rc) and guidelines ( gc) in a c-epc. however, these are restricted 
to interrelationships within one model and not for e.g. interrelationships between 
two process models and interrelationships  between a reference process model and 
a related reference data model. 
f) configuration decisions can be made on different levels. this can be supported by the partially configurable c-epcs as discussed in the previous subsection. 
g)
 in a c-epc variation points do not refer to further related information within the enterprise system. however, this can be added easily. 
h)
 the entire configuration process should also be guided by recommendations or 
configuration guidelines. this is  supported by the guidelines ( gc) and the partial 
order oc.  
i) the last requirement refers to the impact of configuration extensions on the 
perceived model complexity. the c-epc is a natural extension of the standard epc and should not cause any problems for the typical user of a reference model. 
the most complex parts are the interrelat ionships defined in the requirements ( r
c) - 38 - 
  and guidelines ( gc) in a c-epc since these are expressed in logical expressions. it 
may be worthwhile to think of more graphical notations for modelling typical 
requirements like for example dependency constraints.  
as indicated the c-epc language defined in this paper covers many of the requirements 
but not all. the language reported in this paper focuses on the core functionality of a configurable reference modelling language based on epcs. 
6 related work 
this area of research can be divided into requirements engineering for the development  of 
enterprise systems [10,12] and requirements engineering for the configuration  of 
enterprise systems . the latter one is the focus of this paper. academic contributions in 
this field are still the exception. 
soffer et al.’s [41] suggestions on erp modelling can be regarded as the closest to our 
proposed ideas. the goal of their paper is to determine what language is most appropriate 
for representing erp system capabilities. following the concept of scenario-based requirements engineering, soffer et al. evaluate the object-process modelling 
methodology. the so-called argumentation facet, related to the ability of a modelling 
language to express optionality-related information, is just one of many of their criteria. the paper does not comprehensively analyse requirements related to modelling 
enterprise systems configurability and evaluates an existing technique rather than 
developing a new and more appropriate technique. - 39 - 
  a number of papers have contributed to the area of goal modelling and the 
interrelationships of goal models to other model types and requirement specifications. as 
an example, rolland and prakesh [31] suggest a map including erp goals and objectives 
for the identification and evaluation of user needs. in [30], rolland links goals and strategies in so called maps. she applies this idea to processes from sap’s material 
management (mm) solution. this interesting work stays on the rather high level of goals 
and strategies, does not utilise techniques and contents of existing reference models and 
is very brief regarding configurabil ity of goals and related processes. 
further work on goal modelling has been conducted by soffer and wand [42], who 
propose a generic theory-based process modelling framework based on bunge’s ontology 
for a goal-driven analysis of process model validity. giorgini et al. [19] present a formal framework for reasoning with goal models. all these papers do not consider the 
configurability of models and do not study modelling techniques which are widely 
utilised in practice. 
gulla and brasethvik [20] introduce three process modelling tiers to manage the 
complexity of process modelling in comprehensive erp systems projects. their 
functional tier dimension deals with the func tionality of the enterprise system. however, 
they do not study how reference models fit in to in this tier. brehm et al. [9] discuss 
alternative ways of configuring enterprise systems. their taxonomy for erp 
configuration and customising is widely cited. however, they do not demonstrate how 
this work can be linked to reference models of enterprise systems. - 40 - 
  related work has also been conducted in the area of variability management in software 
families. halmans and pohl [21] discuss issues related to the communication of the 
variability of a software-product family. they propose an extension to use case diagrams 
based on cardinalities in order to explicitly depict variation points. they do not support dependencies between variation points. moreover, use case diagrams have not widely 
been used for reference models. halmans and pohl [21] have been influenced by previous 
work on representing variability in use case diagrams by bertolino et al. [8], von der massen and lichter [27], and john and mutig [22]. software product families have also 
been investigated in from an architectural viewpoint. in fact, there have been several 
workshops on software architectures for product families, cf. [26]. as an example consider the work of dolan et al. [15] on the role of the various stakeholders when it 
comes to software product families. all these publications do not relate to large 
enterprise systems solutions and process modelling techniques which are used in this context. 
7 conclusion and outlook 
reference models have been defined in this paper as reusable conceptual models that 
depict recommended structures and processes. one main class of reference models are application reference models that document the functionality of off-the-shelf-solutions. 
reference modelling languages face specific requirements regarding the configuration of 
these models. however, current models such as the sap reference models (and other enterprise systems reference models) are designed using modelling languages that do not 
cater for the needs of configuration. thus, onl y limited opportunities exist to specify valid 
configurations. this paper proposed a new dedicated reference modelling language that - 41 - 
  allows exactly this explicit specification of  configurations in reference process models. 
this language has been called configurable epcs and has been derived from the popular 
epcs. 
the current focus of our research is on developing a list of configuration patterns and 
exploring alternative ways of modelling these patterns. the quality of our proposed 
reference modelling language as well as its notations will be tested in experiments and focus groups. this project is funded by sap corporate research and it is the explicit aim 
to develop an applicable language. as part of this research project, a related sap-funded 
empirical study on the actual modelling practice in australia is currently conducted. this study will give important insights into the problems with the existing reference models. 
furthermore, it is planned to extend this work to configurable collaborative business 
scenario diagrams. 
another interesting question is: "given a c-epc and a partial configuration, is the partial 
configuration satisfiable?". related questions are: "if not satisfiable, why not?" or "if satisfiable, which configurations are still possible?". since the number of configurations is finite, it is easy to provide automated support for addressing these questions. moreover, 
it would be interesting to link these questions to the dynamics of the resulting epcs. it 
may be the case that a partial configuratio n satisfiable in terms of the configuration 
requirements but that the resulting epcs will always deadlock.  
a further area of research will be the inclusion of evidence-based research. this could 
include access to relevant benchmarking information or typical configuration decisions 
made in one industry sector. this could be visualised in the reference models using the proposed configuration guidelines and would provide valuable guidance for the required - 42 - 
  decisions. clearly this is also linked to the topic of process mining (cf. 
www.processmining.org),  i.e., extracting knowledge from event logs.  by analysing the 
logs of sap and other enterprise systems one can link certain performance metrics to 
configuration decisions. 
8 references 
[1]  w.m.p. van der aalst, formalization and verification of event-driven process 
chains, information and software technology 41(10) (1999) 639-650. 
[2]  w.m.p. van der aalst, t. basten, inheritance of workflows: an approach to 
tackling problems related to change, theoretical computer science, 270(1-2) (2002) 
125-203. 
[3]  w.m.p. van der aalst, j. desel, e. kindler, on the semantics of epcs: a vicious 
circle. in m. nüttgens and f.j. rump, editors, proceedings of the epk 2002: business 
process management using epcs, trier, germany, november 2002. gesellschaft für 
informatik, bonn, 71-80. 
[4]  w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, a.p. barros, 
workflow patterns, distributed and parallel databases 14(3) (2003) 5-51. 
[5]  t. basten, w.m.p. van der aalst, inheritance of behavior. journal of logic and 
algebraic programming, 47(2) (2001) 47-145.  
[6]  j. becker, m. kugeler, m. rosemann, ed s., process management, berlin et al., 2003. 
[7]  p. bernus, geram: generalised enterprise reference architecture and 
methodology, version 1.6.3, march 1999. 
[8]  a. bertolino, a. mantechi, s. gnesi, g.  lamir, a. maccari, use case description of 
requirements for product lines. proceedings of the international workshop on 
requirements engineering for product lines 2002 - repl ’02. technical report: alr-
2002-033, avaya labs. 2002. 
[9]  l. brehm, a. heinzl, m.l. markus, 2000, tailoring erp systems: a spectrum of 
choices and their implications, proceedings of the 34th hawaii international conference 
on system sciences. maui, hawaii, 3-6 january 2000. 
[10]  s. brinkkemper, requirements engineering for erp: requirements management 
for the development of packaged software, proceedings of the 4th international 
symposium on requirements engineering. limerick, ireland, 7-11 june 1999. 
[11]  t. curran, g. keller, sap r/3 business blueprint: understanding the business 
process reference model, upper saddle river, 1997. 
[12]  m. daneva, practical reuse measurement in erp requirements engineering, 
proceedings of the 12th international conference caise 2000, eds., b. wangler and 
l. bergman. stockholm, sweden, june 5-9, lecture notes in computer science 1789, 
2000, 309-324. - 43 - 
  [14]  j. dehnert, p. rittgen, relaxed soundness of business processes, in k.r. dittrich, 
a. geppert, and m.c. norrie, editors, proceedings of the 13th international conference on 
advanced information systems engineering (caise 2001), volume 2068 of lecture 
notes in computer science, springer-verlag, berlin, 2001, 157-170. 
[15]  t. dolan, r. weterings, j.c. wortmann, stakeholder-centric assessment of 
product family architecture: practical guidelines for information system 
interoperability and extensibility, in intern ational workshop on software architectures 
for product families (iw-sapf-3), volume 1951 of lecture notes in computer science, springer verlag, 2000, 225-245. 
[16]  p. fettke, p. loos, classification of reference models - a methodology and its 
application. information systems and e-bu siness management, 2003, 1(1) 35-53. 
[17]  t. forsberg, g. roenne, j. vikstroem, process modeling in erp projects – a 
discussion of potential benefits. intentia r&d 2002. 
[18]  u. frank, conceptual modelling as the core of the information systems discipline 
- perspectives and epistemological challeng es, proceedings of the america conference 
on information systems – amcis ’99, milwaukee, 1999, 695-698. 
[19] p. giorgini, j. mylopoulos, e. nicchi arelli, r. sabastiani: formal reasoning 
techniques for goal models. journal on data semantics, 2004, 1(1), 1-20. 
[20]  j. a. gulla, t. brasethvik, on the challenges of business modeling in large scale 
reengineering projects,. proceedings of the 4
th international conference on 
requirements engineering, schaumburg, ill., 19-23 june 2000, 17-26. 
[21]  g. halmans, k. pohl, communicating th e variability of a software-product family to 
customers. software and systems modeling, 2(1) 2003 15-36. 
[22]  i. john, d. mutig, tailoring use cases for product line modeling. proceedings of 
the international workshop on requirements engineering for product lines 2002 - repl 
’02. technical report: alr-2002-033, avaya labs 2002. 
[23]  g. keller, m. nüttgens, a.w. scheer, semantische processmodellierung auf der 
grundlage ereignisgesteuerter prozessketten (epk), veröffentlichungen des instituts für 
wirtschaftsinformatik, heft 89 (in german), university of saarland, saarbrücken, 1992. 
[24]  h. klaus, m. rosemann, g.g. gable, what is erp?, information system frontiers 
(2000) 2 (2) 141-162. 
[25]  p. langner, c. schneider, j. wehler, petri net based certification of event driven 
process chains. in j. desel and m. silva, editors, application and theory of petri nets 
1998, volume 1420 of lecture notes in computer science, springer-verlag, berlin, 1998, 286-305. 
[26]  f. van der linden, eds., international workshop on software architectures for 
product families, volume 1951 of lecture notes in computer science, berlin 2000. 
[27]  t. von der massen, h. lichter, mode ling variability by uml use case diagrams. 
proceedings of the international workshop on requirements engineering for product 
lines 2002 - repl ’02. technical re port: alr-2002-033, avaya labs. 2002. 
[28]  v.b. misic, j.l. zhao, evaluating the quality of reference models, in a.h.f. 
laender, s.w. liddle, v.c.storey, eds., in proceedings of the 19
th international - 44 - 
  conference on conceptual modeling. salt lake cit, utah, usa, 9-12 october 2000. 
lecture notes in computer science 1920, 484-498. 
[29]  p. rittgen, modified epcs and their formal semantics. technical report 99/19, 
university of koblenz-landau, koblenz, germany, 1999. 
[30] c. rolland: aligning business and system functionality models. proceedings of the 
3rd pre-icis workshop on process management and information systems. eds.: 
j. akoka, i. comyn-wattiau and m. favier. washington d.c., 12 december 2004, 1-10. 
[31]  c. rolland, n. prakash, bridging the gap between organisational needs and erp 
functionality, requirements engineering, 5 (3) (2000) 180-193. 
[32]  m. rosemann, erp software: characteristics and consequences, in j. pries-heje 
et al., eds., in proceedings of the 7th european conference on information systems, 23-25 
june 1999, copenhagen. 
[33]  m. rosemann, using reference models within the enterprise resource planning 
lifecycle. australian accounting review, 10(3) 2000 19-30. 
[34]  m. rosemann, application reference models and building blocks for management 
and control (erp systems). in: handbook on enterprise architecture. p. bernus, l. nemes, g. schmidt, eds., springer-v erlag: berlin et al., 2003, 595-616. 
[35]  m. rosemann, g. shanks, extension and configuration of reference models for 
enterprise resource planning systems. proceedings of the 12th australasian conference 
on information systems - acis 2001, g. finnie, d. cecez-kecmanovic, b. lo, eds., coffs harbour, 4-7 december 2001, 537-546. 
[36]  f. rump, geschäftsprozessmanagement auf der basis ereignisgesteuerter 
prozessketten. reihe wirtschaftsinformatik, teubner verlag, germany, 1999. 
[37]  online documentation mysap er p, sap ag, (help.sap.com)., 2005. 
[38]  a.-w. scheer, aris – business process modelling. 3
rd ed., berlin et al., 2000. 
[39]  l. silverston, the data model resource book, volume 1, a library of universal 
data models for all enterprise s, revised edition, 2001.  
[40]  l. silverston, the data model resource book, volume 2, a library of data 
models for specific industries, revised edition, 2001. 
[41] p. soffer, b. golany, d. dori: er p modelling – a comprehensive approach. 
information systems, 28 (2003), 673-690. 
[42] p. soffer, y. wand: goal-driven analys is of process model validity. in: advanced 
information systems engineering. proceedings of the 16th international conference 
(caise 2004). eds.: a. persson, j. stir na. riga, latvia, june 2004, 521-535. 
[43]  m. verbeek, on tools & models, in: dynamic enterprise innovation. establishing 
continuous improvement in business. 3rd ed., r. van es, ed., 1998. 
  
 