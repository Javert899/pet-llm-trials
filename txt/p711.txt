discovering petri nets from event logs
w.m.p. van der aalst and b.f. van dongen
department of mathematics and computer science,
technische universiteit eindhoven, the netherlands.
fw.m.p.v.d.aalst,b.f.v.dongen g@tue.nl
abstract. as information systems are becoming more and more inter-
twined with the operational processes they support, multitudes of events
are recorded by todays information systems. the goal of process mining
is to use such event data to extract process related information, e.g.,
to automatically discover a process model by observing events recorded
by some system or to check the conformance of a given model by com-
paring it with reality. in this article, we focus on process discovery , i.e.,
extracting a process model from an event log. we focus on petri nets as a
representation language, because of the concurrent and unstructured na-
ture of real-life processes. the goal is to introduce several approaches to
discover petri nets from event data (notably the -algorithm, state-based
regions, and language-based regions). moreover, important requirements
for process discovery are discussed. for example, process mining is only
meaningful if one can deal with incompleteness (only a fraction of all
possible behavior is observed) and noise (one would like to abstract
from infrequent random behavior). these requirements reveal signicant
challenges for future research in this domain.
keywords: process mining, process discovery, petri nets, theory of
regions
1 introduction
process mining provides a new means to improve processes in a variety of appli-
cation domains [2, 41]. there are two main drivers for this new technology. on
the one hand, more and more events are being recorded thus providing detailed
information about the history of processes. despite the omnipresence of event
data, most organizations diagnose problems based on ction rather than facts.
on the other hand, vendors of business process management (bpm) and busi-
ness intelligence (bi) software have been promising miracles. although bpm and
bi technologies received lots of attention, they did not live up to the expectations
raised by academics, consultants, and software vendors.
process mining is an emerging discipline providing comprehensive sets of
tools to provide fact-based insights and to support process improvements [2,7].
this new discipline builds on process model-driven approaches and data mining.
however, process mining is much more than an amalgamation of existing ap-
proaches. for example, existing data mining techniques are too data-centric toprovide a comprehensive understanding of the end-to-end processes in an organi-
zation. bi tools focus on simple dashboards and reporting rather than clear-cut
business process insights. bpm suites heavily rely on experts modeling ideal-
ized to-be processes and do not help the stakeholders to understand the as-is
processes.
over the last decade event data has become readily available and process min-
ing techniques have matured. moreover, process mining algorithms have been
implemented in various academic and commercial systems. examples of com-
mercial systems that support process mining are: aris process performance
manager by software ag, disco by fluxicon, enterprise visualization suite
by businesscape, interstage bpme by fujitsu, process discovery focus by ion-
tas, reectjoneby pallas athena, and reect by futura process intelligence.
today, there is an active group of researchers working on process mining and
it has become one of the \hot topics" in bpm research. moreover, there is a
huge interest from industry in process mining. this is illustrated by the recently
released process mining manifesto [41]. the manifesto is supported by 53 or-
ganizations and 77 process mining experts contributed to it. the manifesto has
been translated into a dozen languages (http://www.win.tue.nl/ieeetfpm/). the
active contributions from end-users, tool vendors, consultants, analysts, and re-
searchers illustrate the growing relevance of process mining as a bridge between
data mining and business process modeling. moreover, more and more software
vendors started adding process mining functionality to their tools. the authors
have been involved in the development of the open-source process mining tool
prom right from the start [11, 56, 57]. prom is widely used all over the globe
and provides an easy starting point for practitioners, students, and academics.
whereas it is easy to discover sequential processes, it is very challenging to
discover concurrent processes, especially in the context of noisy and incomplete
event logs. given the concurrent nature of most real-life processes, petri nets are
an obvious candidate to represent discovered processes. moreover, most real-life
processes are not nicely block-structured, therefore, the graph based nature of
petri nets is more suitable than notations that enforce more structure.
the article is based on a lecture given at the advanced course on petri
nets in rostock, germany (september 2010). the practical relevance of process
discovery and the suitability of petri net as a basic representation for concurrent
processes motivated us to write this tutorial.
figure 1 illustrates the concept of process discovery using a small example.
the gure shows an abstraction of an event log. there are 1391 cases, i.e.,
process instances. each case is described as a sequence of activities, i.e., a trace.
in this particular log there are 21 dierent traces. for example, trace ha;c;d;e;hi
occurs 455 times, i.e., there are 455 cases for which this sequence of activities
was executed. the challenge is to discover a petri net given such an event log.
a discovery algorithm such as the -algorithm [9] is able to discover the petri
net shown in figure 1.
process discovery is a challenging problem because one cannot assume that
all possible sequences are indeed present. consider for example the event log
2a
start register 
requestb
examine 
thoroughly
c
examine 
casually
d
check ticketdecidepay 
compensation
reject 
request
reinitiate 
requesteg
h
fendacdeh
abdeg
adceh
abdeh
acdeg
adceg
adbeh
acdefdbeh
adbeg
acdefbdeh
acdefbdeg455
191
177
144
111
82
56
47
38
33
14# trace
acdefdbeg
adcefcdeh
adcefdbeh
adcefbdeg
acdefbdefdbeg
adcefdbeg
adcefbdefbdeg
adcefdbefbdeh
adbefbdefdbeg
adcefdbefcdefdbeg11
9
8
5
3
2
2
1
1
1# tracefig. 1. a petri net discovered from an event log containing 1391 cases.
shown in figure 1. if we randomly take 500 cases from the set of 1391 cases,
we would like to discover \more or less" the same model. note that there are
several traces that appear only once in the log. many of these will disappear
when considering a log with only 500 cases. also note that the process model
discovered by the -algorithm allows for more traces than the ones depicted in
figure 1, e.g.,ha;d;c;e;f;d;b;e;f;c;d;e;h iis possible according to the process
model but does not occur in the event log. this illustrates that event logs tend
to be far from complete , i.e., only a small subset of all possible behavior can be
observed because the number of variations is larger than the number of instances
observed.
the process model in figure 1 is rather simple. real-life processes will consist
of dozens or even hundreds of dierent activities. moreover, some behaviors
will be very infrequent compared to others. such rare behaviors can be seen as
3noise (e.g., exceptions). typically, it is undesirable and also unfeasible to capture
frequent and infrequent behavior in a single diagram.
process discovery techniques need to be able to deal with noise and incom-
pleteness. this makes process mining very dierent from synthesis . classical
synthesis techniques aim at creating a model that captures the given behavior
precisely . for example, classical language-based region techniques [14,17,19,28,
42, 43, 45] distill a petri net from a (possibly innite) language, such that the
behavior of the petri net is only minimally more than the given language. in
classical state-based region theory [13, 15, 23, 24, 26, 27, 35] on the other hand,
a transition system is used to synthesize a petri net of which the behavior is
bisimilar with the given transition system. intuitively two models are bisimilar
if they can match each other's moves, i.e., they cannot be distinguished from
one another by an observer [36]. in terms of mining this implies that the na vely
synthesized petri net cannot generalize beyond the example traces seen.
process discovery techniques need to balance four criteria: tness (the dis-
covered model should allow for the behavior seen in the event log), precision (the
discovered model should not allow for behavior completely unrelated to what was
seen in the event log), generalization (the discovered model should generalize the
example behavior seen in the event log), and simplicity (the discovered model
should be as simple as possible). this makes process discovery a challenging and
highly relevant topic.
the remainder of this article is organized as follows. section 2 introduces the
process mining spectrum showing that process discovery is an essential ingre-
dient for process analysis based on facts rather than ction. section 3 presents
preliminaries and formalizes the process discovery task. the -algorithm is pre-
sented in section 4. section 5 discusses the main challenges related to process
mining. in section 6, we compare process discovery with region theory in more
detail. this section shows that classical approaches cannot deal with partic-
ular requirements essential for process mining. then, in sections 7 and 8, we
show how region theory can be adapted to deal with these requirements. both
state-based regions and language-based regions are considered. all approaches
described in this article are supported by prom , the leading open-source process
mining framework. prom is described in section 9. section 10 ends this article
with some conclusions and challenges that remain.
2 process mining
process mining is an important tool for modern organizations that need to man-
age non-trivial operational processes. on the one hand, there is an incredible
growth of event data [44]. on the other hand, processes and information need
to be aligned perfectly in order to meet requirements related to compliance, e-
ciency, and customer service. process mining is much broader than just control-
ow discovery , i.e., discovering a petri net from a multi-set of traces. therefore,
we start by providing an overview of the process mining spectrum.
4software 
system
(process)
modelevent
logsmodels
analyzes
discoveryrecords 
events, e.g., 
messages, 
transactions, 
etc.specifies 
configures 
implements
analyzessupports/
controls
extensionconformance“world”
peoplemachines
organizationscomponentsbusiness 
processesfig. 2. positioning of the three main types of process mining: discovery ,conformance ,
and enhancement .
event logs can be used to conduct three types of process mining as shown in
figure 2 [2,7].
the rst type of process mining is discovery . a discovery technique takes
an event log and produces a model without using any a-priori information. an
example is the -algorithm [9] that will be described in section 4. this algorithm
takes an event log and produces a petri net explaining the behavior recorded in
the log. for example, given sucient example executions of the process shown
in figure 1, the -algorithm is able to automatically construct the petri net
without using any additional knowledge. if the event log contains information
about resources, one can also discover resource-related models, e.g., a social
network showing how people work together in an organization.
the second type of process mining is conformance . here, an existing process
model is compared with an event log of the same process. conformance checking
can be used to check if reality, as recorded in the log, conforms to the model and
vice versa. for instance, there may be a process model indicating that purchase
orders of more than one million euro require two checks. analysis of the event log
will show whether this rule is followed or not. another example is the checking of
the so-called \four-eyes" principle stating that particular activities should not be
executed by one and the same person. by scanning the event log using a model
specifying these requirements, one can discover potential cases of fraud. hence,
conformance checking may be used to detect, locate and explain deviations,
and to measure the severity of these deviations. an example is the conformance
checking algorithm described in [51]. given the model shown in figure 1 and
a corresponding event log, this algorithm can quantify and diagnose deviations.
in [4] another approach based on creating alignments is presented. an alignment
isoptimal if it relates the trace in the log to a most similar path in the model.
5after creating optimal alignments, all behavior in the log can be related to the
model.
the third type of process mining is enhancement . here, the idea is to extend
or improve an existing process model using information about the actual pro-
cess recorded in some event log. whereas conformance checking measures the
alignment between model and reality, this third type of process mining aims at
changing or extending the a-priori model. one type of enhancement is repair ,
i.e., modifying the model to better reect reality. for example, if two activities
are modeled sequentially but in reality can happen in any order, then the model
may be corrected to reect this. another type of enhancement is extension , i.e.,
adding a new perspective to the process model by cross-correlating it with the
log. an example is the extension of a process model with performance data. for
instance, figure 1 can be extended with information about resources, decision
rules, quality metrics, etc.
the petri net in figure 1 only shows the control-ow. however, when extend-
ing process models, additional perspectives need to be added. moreover, discov-
ery and conformance techniques are not limited to control-ow. for example,
one can discover a social network and check the validity of some organizational
model using an event log. hence, orthogonal to the three types of mining (dis-
covery, conformance, and enhancement), dierent perspectives can be identied.
the organizational perspective focuses on information about resources hidden in
the log, i.e., which actors (e.g., people, systems, roles, and departments) are in-
volved and how are they related. the goal is to either structure the organization
by classifying people in terms of roles and organizational units or to show the
social network. the time perspective is concerned with the timing and frequency
of events. when events bear timestamps it is possible to discover bottlenecks,
measure service levels, monitor the utilization of resources, and predict the re-
maining processing time of running cases.
3 process discovery: preliminaries and purpose
in this section, we describe the goal of process discovery. in order to do this, we
present a particular format for logging events and a particular process modeling
language (i.e., petri nets). based on this we sketch various process discovery
approaches.
3.1 event logs
the goal of process mining is to extract knowledge about a particular (oper-
ational) process from event logs, i.e., process mining describes a family of a-
posteriori analysis techniques exploiting the information recorded in audit trails,
transaction logs, databases, etc. typically, these approaches assume that it is
possible to sequentially record events such that each event refers to an activ-
ity(i.e., a well-dened step in the process) and is related to a particular case
(i.e., a process instance). furthermore, some mining techniques use additional
6information such as the performer or originator of the event (i.e., the person /
resource executing or initiating the activity), the timestamp of the event, or data
elements recorded with the event (e.g., the size of an order).
to clarify the notion of an event log consider table 1 which shows a fragment
of some event log. only two traces are shown, both containing four events. each
event has a unique id and several properties. for example event 35654423 belongs
to casex123 and is an instance of activity athat occurred on december 30th at
11.02, was executed by john, and cost 300 euros. the second trace (case x128)
starts with event 35655526 and also refers to an instance of activity a. the
table 1. a fragment of some event log.
case id event id properties
timestamp activity resource cost:::
x123 35654423 30-12-2011:11.02 a john 300:::
x123 35654424 30-12-2011:11.06 b john 400:::
x123 35654425 30-12-2011:11.12 c john 100:::
x123 35654426 30-12-2011:11.18 d john 400:::
x128 35655526 30-12-2011:16.10 a ann 300:::
x128 35655527 30-12-2011:16.14 c john 450:::
x128 35655528 30-12-2011:16.26 b pete 350:::
x128 35655529 30-12-2011:16.36 d ann 300:::
:::::: ::: ::: :::::::::
information depicted in table 1 is the typical event data that can be extracted
from today's systems.
systems store events in very dierent ways. process-aware information sys-
tems (e.g., workow management systems) provide dedicated audit trails. in
other systems, this information is typically scattered over several tables. for
example, in a hospital events related to a particular patient may be stored in
dierent tables and even dierent systems. for many applications of process
mining, one needs to extract event data from dierent sources, merge these
data, and convert the result into a suitable format. we advocate the use of the
so-called xes (extensible event stream) format that can be read directly by
prom ( [5,57]). xes is the successor of mxml. based on many practical expe-
riences with mxml, the xes format has been made less restrictive and truly
extendible. in september 2010, the format was adopted by the ieee task force
on process mining. the format is supported by tools such as prom (as of ver-
sion 6), nitro, xesame, and openxes. see www.xes-standard.org for detailed
information about the standard. xes is able to store the information shown in
table 1. most of this information is optional, i.e., if it is there, it can be used
for process mining, but it is not necessary for control-ow discovery.
7in this article, we focus on control-ow discovery. therefore, we only consider
the activity column in table 1. this means that an event is linked to a case
(process instance) and an activity, and no further attributes are needed. events
are ordered (per case), but do not need to have explicit timestamps. this allows
us to use the following simplied denition of an event log.
denition 1 (event, trace, event log). letabe a set of activities. 2a
is atrace , i.e., a sequence of events. l2i b(a)is an event log , i.e., a multi-set
of traces.
the rst four events in table 1 form a trace ha;b;c;di. this trace represents
the path followed by case x123. the second case ( x128) can be represented by
the traceha;c;b;di. note that there may be multiple cases that have the same
trace. therefore, an event log is dened as a multi-set of traces.
amulti-set (also referred to as bag) is like a set where each element may
occur multiple times. for example, [ horse;cow5;duck2] is the multi-set with eight
elements: one horse, ve cows and two ducks. i b( x) is the set of multi-sets (bags)
overx. we assume the usual operators on multi-sets, e.g., x[yis the union of
x and y,xnyis the dierence between xandy,x2xtests ifxappears inx,
andxyevaluates to true if xis contained in y. for example, [ horse;cow2][
[horse2;duck2] = [ horse3;cow2;duck2], [horse3;cow4]n[cow2] = [ horse3;cow2],
[horse;cow2][horse2;cow3], and [ horse3;cow1]6[horse2;cow2]. note that
sets can be considered as bags having only one instance of every element. hence,
we can mix sets and bags, e.g., fhorse;cowg[[horse2;cow3] = [horse3;cow4].
for practical applications of process mining it is essential to dierentiate be-
tween traces that are infrequent or even unique (multiplicity of 1) and traces
that are frequent. therefore, an event log is a multi-set of traces rather than
an ordinary set. however, in this article we focus on the foundations of process
discovery thereby often abstracting from noise and frequencies. see [2] for tech-
niques that take frequencies into account. this book also describes various case
studies showing the importance of multiplicities.
in the remainder, we will use the following example log: l1= [ha;b;c;di5;
ha;c;b;di8;ha;e;di9].l1contains information about 22 cases; ve cases following
traceha;b;c;di, eight cases following trace ha;c;b;di, and nine cases following
traceha;e;di. note that such a simple representation can be extracted from
sources such as table 1, mxml, xes, or any other format that links events to
cases and activities.
3.2 petri nets
the goal of process discovery is to distil a process model from some event log.
here we use petri nets [50] to represent such models. in fact, we extract a
subclass of petri nets known as workow nets (wf-nets) [1].
denition 2. anpetri net is a tuple (p;t;f )where:
1.pis a nite set of places ,
82.tis a nite set of transitions such thatp\t=;, and
3.f(pt)[(tp)is a set of directed arcs, called the ow relation .
an example petri net is shown in figure 3. this petri net has six places
represented by circles and four transitions represented by squares. places may
contain tokens. for example, in figure 3 both p1 andp6 contain one token,
p3 contains two tokens, and the other places are empty. the state, also called
marking , is the distribution of tokens over places. a marked petri net is a pair
(n;m ), wheren= (p;t;f ) is a petri net and where m2i b(p) is a bag over
pdenoting the marking of the net. the initial marking of the petri net shown
in figure 3 is [ p1;p32;p6]. the set of all marked petri nets is denoted n.
t1
t2p1 p2t3
t4p3
p5 p6
p4
fig. 3. a petri net with six places ( p1,p2,p3,p4,p5, andp6) and four transitions ( t1,
t2,t3, andt4).
letn= (p;t;f ) be a petri net. elements of p[tare called nodes . a node
xis an input node of another node yi there is a directed arc from xtoy(i.e.,
(x;y)2f). nodexis an output node ofyi (y;x)2f. for anyx2p[t,
x=fyj(y;x)2fgandx=fyj(x;y)2fg. in figure 3,t3 =fp3;p6gand
t3=fp5g.
the dynamic behavior of such a marked petri net is dened by the so-called
ring rule . a transition is enabled if each of its input places contains a token. an
enabled transition can rethereby consuming one token from each input place
and producing one token for each output place.
denition 3 (firing rule). let(n;m )be a marked petri net with n=
(p;t;f ). transition t2tisenabled , denoted (n;m )[ti, itm. the ring
rule [intn is the smallest relation satisfying for any (n;m )2n
and anyt2t,(n;m )[ti)(n;m ) [ti(n;(mnt)[t).
in the marking shown in figure 3, both t1 andt3 are enabled. the other two
transitions are not enabled because at least one of the input places is empty.
ift1 res, one token is consumed (from p1) and two tokens are produced (one
forp2 and one for p3). formally, ( n;[p1;p32;p6]) [t1i(n;[p2;p33;p6]). so the
resulting marking is [ p2;p33;p6]. ift3 res in the initial state, two tokens are
9consumed (one from p3 and one from p6) and one token is produced (for p5).
formally, (n;[p1;p32;p6]) [t3i(n;[p1;p3;p5]).
let (n;m 0) withn= (p;t;f ) be a marked p/t net. a sequence 2tis
called a ring sequence of (n;m 0) i, for some natural number n2i n, there exist
markingsm1;:::;mnand transitions t1;:::;tn2tsuch that=ht1:::tniand,
for alliwith 0i<n , (n;mi)[ti+1iand (n;mi) [ti+1i(n;mi+1).
let (n;m 0) be the marked petri net shown in figure 3, i.e., m0= [p1;p32;p6].
the empty sequence =hiis enabled in ( n;m 0). the sequence =ht1;t3i
is also enabled and results in marking [ p2;p32;p5]. another possible ring se-
quence is=ht3;t4;t3;t1;t4;t3;t2;t1i. a marking misreachable from the
initial marking m0i there exists a sequence of enabled transitions whose r-
ing leads from m0tom. the set of reachable markings of ( n;m 0) is denoted
[n;m 0i.
[p1,p32,p6] [p2,p33,p6]t1
[p2,p32,p4,p6]t2
[p1,p3,p4,p6]t1
[p2,p3,p42,p6]t2
[p1,p42,p6]t1
[p2,p43,p6]t2[p2,p32,p5]t3
[p1,p3,p5]t1
[p2,p3,p4,p5]t2
[p1,p4,p5]t1
[p2,p42,p5]t2t3
t4
t4
t4
t4
t4t3
t3
t3
fig. 4. the reachability graph of the marked petri net shown in figure 3.
for the marked petri net shown in figure 3 there are 12 reachable states.
these states can be computed using the so-called reachability graph shown in
figure 4. all nodes correspond to reachable markings and each arc corresponds
to the ring of a particular transition. any path in the reachability graph corre-
sponds to a possible ring sequence. for example, using figure 4 is is easy to see
thatht3;t4;t3;t1;t4;t3;t2;t1iis indeed possible and results in [ p2;p3;p4;p5]. a
marked net may be unbounded, i.e., have an innite number or reachable states.
in this case, the reachability graph is innitely large, but one can still construct
the so-called coverability graph [50].
103.3 workow nets
for process discovery, we look at processes that are instantiated multiple times,
i.e., the same process is executed for multiple cases. for example, the process
of handling insurance claims may be executed for thousands or even millions
of claims. such processes have a clear starting point and a clear ending point.
therefore, the following subclass of petri nets (wf-nets) is most relevant for
process discovery.
denition 4 (workow nets). letn= (p;t;f )be a petri net and ta fresh
identier not in p[t.nis aworkow net (wf-net) i:
1.object creation :pcontains an input place i(also called source place) such
thati=;,
2.object completion :pcontains an output place o(also called sink place) such
thato=;,
3.connectedness :n= (p;t[ftg;f[f(o;t);(t;i)g)is strongly connected, i.e.,
there is a directed path between any pair of nodes in n.
clearly, figure 3 is not a wf-net because a source and sink place are missing.
figure 5 shows an example of a wf-net:start =;,end=;, and every node
is on a path from start toend.
ab
cd e
p2end
p4p3 p1
start
fig. 5. a workow net with source place i=start and sink place o=end.
the petri net depicted in figure 1 is another example of a wf-net. not
every wf-net represents a correct process. for example, a process represented
by a wf-net may exhibit errors such as deadlocks, tasks which can never be-
come active, livelocks, garbage being left in the process after termination, etc.
therefore, we dene the following correctness criterion.
denition 5 (soundness). letn= (p;t;f )be a wf-net with input place i
and output place o.nissound i:
1.safeness :(n;[i])is safe, i.e., places cannot hold multiple tokens at the same
time,
112.proper completion : for any marking m2[n;[i]i,o2mimpliesm= [o],
3.option to complete : for any marking m2[n;[i]i,[o]2[n;mi, and
4.absence of dead tasks :(n;[i])contains no dead transitions (i.e., for any
t2t, there is a ring sequence enabling t).
the wf-nets shown in gures 5 and 1 are sound. soundness can be veri-
ed using standard petri-net-based analysis techniques. in fact soundness cor-
responds to liveness and safeness of the corresponding short-circuited net [1].
this way ecient algorithms and tools can be applied. an example of a tool
tailored towards the analysis of wf-nets is woan [55]. this functionality is
also embedded in our process mining tool prom [5].
3.4 problem denition and approaches
after introducing events logs and wf-nets, we can dene the main goal of pro-
cess discovery.
denition 6 (process discovery). letlbe an event log over a, i.e.,l2
i b(a). aprocess discovery algorithm is a function that maps any log lonto
a petri net (l) = (n;m ). ideally,nis a sound wf-net and all traces in l
correspond to possible ring sequences of (n;m ).
the goal is to nd a process model that can \replay" all cases recorded in
the log, i.e., all traces in the log are possible ring sequences of the discovered
wf-net. assume that l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9]. in this case the
wf-net shown in figure 5 is a good solution. all traces in l1correspond to ring
sequences of the wf-net and vice versa. throughout this article, we use l1as
an example log. note that it may be possible that some of the ring sequences of
the discovered wf-net do not appear in the log. this is acceptable as one cannot
assume that all possible sequences have been observed. for example, if there is
a loop, the number of possible ring sequences is innite. even if the model is
acyclic, the number of possible sequences may be enormous due to choices and
parallelism. later in this article, we will discuss the quality of discovered models
in more detail.
since the mid-nineties several groups have been working on techniques for
process mining [7, 9, 10, 25, 29, 32, 33, 58], i.e., discovering process models based
on observed events. in [6] an overview is given of the early work in this domain.
the idea to apply process mining in the context of workow management sys-
tems was introduced in [10]. in parallel, datta [29] looked at the discovery of
business process models. cook et al. investigated similar issues in the context
of software engineering processes [25]. herbst [40] was one of the rst to tackle
more complicated processes, e.g., processes containing duplicate tasks.
most of the classical approaches have problems dealing with concurrency.
the-algorithm [9] is an example of a simple technique that takes concurrency
as a starting point. however, this simple algorithm has problems dealing with
complicated routing constructs and noise (like most of the other approaches
12described in literature). in [32, 33] a more robust but less precise approach is
presented.
recently, people started using the \theory of regions" to process discovery.
there are two approaches: state-based regions and language-based regions. state-
based regions can be used to convert a transition system into a petri net [13,15,
23,24,26,27,35]. language-based regions add places as long as it is still possible
to replay the log [14,17,19,28,42,43].
more from a theoretical point of view, the process discovery problem is related
to the work discussed in [12, 37, 38, 49]. in these papers the limits of inductive
inference are explored. for example, in [38] it is shown that the computational
problem of nding a minimum nite-state acceptor compatible with given data
is np-hard. several of the more generic concepts discussed in these papers can
be translated to the domain of process mining. it is possible to interpret the
problem described in this article as an inductive inference problem specied in
terms of rules, a hypothesis space, examples, and criteria for successful inference.
the comparison with literature in this domain raises interesting questions for
process mining, e.g., how to deal with negative examples (i.e., suppose that
besides log lthere is a log l0of traces that are not possible, e.g., added by
a domain expert). however, despite the relations with the work described in
[12,37,38,49] there are also many dierences, e.g., we are mining at the net level
rather than sequential or lower level representations (e.g., markov chains, nite
state machines, or regular expressions), tackle concurrency, and do not assume
negative examples or complete logs.
the above approaches assume that there is no noise or infrequent behav-
ior. for approaches dealing with these problems we refer to the work done by
christian g unther [39], ton weijters [58], and ana karla alves de medeiros [47].
4-algorithm
after introducing the process discovery problem and providing an overview of
approaches described in literature, we focus on the -algorithm [9]. the -
algorithm is not intended as a practical mining technique as it has problems with
noise, infrequent/incomplete behavior, and complex routing constructs. never-
theless, it provides a good introduction into the topic. the -algorithm is very
simple and many of its ideas have been embedded in more complex and robust
techniques. moreover, it was the rst algorithm to really address the discovery
of concurrency.
4.1 basic idea
the-algorithm scans the event log for particular patterns. for example, if
activityais followed by bbutbis never followed by a, then it is assumed that
there is a causal dependency between aandb. to reect this dependency, the
corresponding petri net should have a place connecting atob. we distinguish
four log-based ordering relations that aim to capture relevant patterns in the
log.
13denition 7 (log-based ordering relations). letlbe an event log over a,
i.e.,l2i b(a). leta;b2a:
{a >lbi there is a trace =ht1;t2;t3;:::tniandi2f1;:::;n 1gsuch
that2landti=aandti+1=b,
{a!lbia>lbandb6>la,
{a#lbia6>lbandb6>la, and
{aklbia>lbandb>la.
consider for example l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9].c >l1dbe-
causeddirectly follows cin traceha;b;c;di. however, d6>l1cbecausecnever
directly follows din any trace in the log.
>l1=f(a;b);(a;c);(a;e);(b;c);(c;b);(b;d);(c;d);(e;d)gcontains all pairs of
activities in a \directly follows" relation. c!l1dbecause sometimes ddi-
rectly follows cand never the other way around ( c >l1dandd6>l1c).
!l1=f(a;b);(a;c);(a;e);(b;d);(c;d);(e;d)gcontains all pairs of activities in
a \causality" relation. bkl1cbecauseb >l1candc >l1b, i.e, sometimes c
followsband sometimes the other way around. kl1=f(b;c);(c;b)g.b#l1e
becauseb6>l1eande6>l1b. #l1=f(a;a);(a;d);(b;b);(b;e);(c;c);(c;e);
(d;a);(d;d);(e;b);(e;c);(e;e)g. note that for any log loveraandx;y2a:
x!ly,y!lx,x#ly, orxkly.
a b
(a) sequence pattern: a→b
ab
c
(b) xor-split pattern:
a→b, a→c, and b#ca
bc
(c) xor-join pattern:
a→c, b→c, and a#b
ab
c
(d) and-split pattern:
a→b, a→c, and b||ca
bc
(e) and-join pattern:
a→c, b→c, and a||b
fig. 6. typical process patterns and the footprints they leave in the event log.
14the log-based ordering relations can be used to discover patterns in the
corresponding process model as is illustrated in figure 6. if aandbare in
sequence, the log will show a>lb. if afterathere is a choice between bandc,
the log will show a!lb,a!lc, andb#lcbecauseacan be followed by band
c, butbwill not be followed by cand vice versa. the logical counterpart of this
so-called xor-split pattern is the xor-join pattern as shown in figure 6(b-c). if
a!lc,b!lc, anda#lb, then this suggests that after the occurrence of either
aorb,cshould happen. figure 6(d-e) shows the so-called and-split and and-
join patterns. if a!lb,a!lc, andbklc, then it appears that after abothb
andccan be executed in parallel (and-split pattern). if a!lc,b!lc, and
aklb, then it appears that cneeds to synchronize aandb(and-join pattern).
figure 6 only shows simple patterns and does not present the additional
conditions needed to extract the patterns. however, the gure nicely illustrates
the basic idea.
a bc
de
p({a,f},{b}) ilp({b},{c})
p({b},{d})p({c},{e})
p({d},{e})g
ol p({e},{f,g})f
fig. 7. wf-netn2derived from l2= [ha;b;c;d;e;f;b;d;c;e;g i;ha;b;d;c;e;gi;
ha;b;c;d;e;f;b;c;d;e;f;b;d;c;e;g i].
consider for example wf-net n2depicted in figure 7 and the log event log
l2= [ha;b;c;d;e;f;b;d;c;e;g i;ha;b;d;c;e;gi;
ha;b;c;d;e;f;b;c;d;e;f;b;d;c;e;g i]. the-algorithm constructs wf-net n2
based onl2. note that the patterns in the model indeed match the log-based
ordering relations extracted from the event log. consider for example the process
fragment involving b,c,d, ande. obviously, this fragment can be constructed
based onb!l2c,b!l2d,ckl2d,c!l2e, andd!l2e. the choice following
eis revealed by e!l2f,e!l2g, andf#l2g. etc.
another example is shown in figure 8. wf-net n3can be derived from
l3= [ha;c;di45;hb;c;di42;ha;c;ei38;hb;c;ei22]. note that here there are two
start and two end activities. these can be found easily by looking for the rst
and last activities in traces.
4.2 algorithm
after showing the basic idea and some examples, we describe the -algorithm.
15bc
p({a,b},{c}) ola
il ed
p({c},{d,e})fig. 8. wf-netn3derived from l3= [ha;c;di45;hb;c;di42;ha;c;ei38;hb;c;ei22].
denition 8 ( -algorithm). letlbe an event log over t.(l)is dened as
follows.
1.tl=ft2tj92lt2g,
2.ti=ft2tj92lt=rst()g,
3.to=ft2tj92lt=last()g,
4.xl=f(a;b)jatl^a6=; ^btl^b6=; ^ 8a2a8b2ba!l
b^ 8a1;a22aa1#la2^ 8b1;b22bb1#lb2g,
5.yl=f(a;b)2xlj8(a0;b0)2xlaa0^bb0=)(a;b) = (a0;b0)g,
6.pl=fp(a;b )j(a;b)2ylg[fil;olg,
7.fl=f(a;p (a;b ))j(a;b)2yl^a2ag[f (p(a;b );b)j(a;b)2yl^b2
bg [f (il;t)jt2tig [f (t;ol)jt2tog, and
8.(l) = (pl;tl;fl).
lis an event log over some set tof activities. in step 1 it is checked which
activities do appear in the log ( tl). these will correspond to the transitions of
the generated wf-net. tiis the set of start activities, i.e., all activities that
appear rst in some trace (step 2). tois the set of end activities, i.e., all activ-
ities that appear last in some trace (step 3). steps 4 and 5 form the core of the
-algorithm. the challenge is to nd the places of the wf-net and their connec-
tions. we aim at constructing places named p(a;b )such thatais the set of input
transitions (p(a;b )=a) andbis the set of output transitions ( p(a;b )=b).
the basic idea for nding p(a;b )is shown in figure 9. all elements of ashould
have causal dependencies with all elements of b, i.e., for any ( a;b)2ab:
a!lb. moreover, the elements of ashould never follow any of the other
elements, i.e., for any a1;a22a:a1#la2. a similar requirement holds for b.
let us consider l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9]. clearlya=fagand
b=fb;egmeet the requirements stated in step 4. also note that a0=fagand
b0=fbgmeet the same requirements. xlis the set of all such pairs that meet
the requirements just mentioned. in this case, xl1=f(fag;fbg);(fag;fcg);
(fag;feg);(fag;fb;eg);(fag;fc;eg);(fbg;fdg);(fcg;fdg);(feg;fdg);
(fb;eg;fdg);(fc;eg;fdg)g. if one would insert a place for any element in xl1
there would be too many places. therefore, only the \maximal pairs" ( a;b)
should be included. note that for any pair ( a;b)2xl, non-empty set a0a,
and non-empty set b0b, it is implied that ( a0;b0)2xl. in step 5 all non-
maximal pairs are removed. so yl1=f(fag;fb;eg);(fag;fc;eg);(fb;eg;fdg);
(fc;eg;fdg)g.
16a1
...a2
amb1
b2
bnp(a,b) ...
a={a1,a2, … am} b={b1,b2, … bn}fig. 9. placep(a;b )connects the transitions in set ato the transitions in set b.
every element of ( a;b)2ylcorresponds to a place p(a;b )connecting tran-
sitionsato transitions b. in addition plalso contains a unique source place il
and a unique sink place ol(cf. step 6).
in step 7 the arcs are generated. all start transitions in tihaveilas an
input place and all end transitions tohaveolas output place. all places p(a;b )
haveaas input nodes and bas output nodes. the result is a petri net (l) =
(pl;tl;fl) that describes the behavior seen in event log l.
thus far we presented three logs and three wf-nets. clearly (l2) =n2,
and(l3) =n3. in gures 7 and 8 the places are named based on the sets yl2
andyl3. moreover, (l1) =n1modulo renaming of places (because dierent
place names are used in figure 5). these examples show that the -algorithm
is indeed able to discover wf-nets based event logs.
b
p({a},{e})ol
ail c
efd
p({e},{f})p({b},{c,f}) p({a,d},{b})p({c},{d})
fig. 10. wf-netn4derived from l4= [ha;b;e;fi2;ha;b;e;c;d;b;fi3;
ha;b;c;e;d;b;fi2;ha;b;c;d;e;b;fi4;ha;e;b;c;d;b;fi3].
17figure 10 shows another example. wf-net n4can be derived from l4=
[ha;b;e;fi2;ha;b;e;c;d;b;fi3;ha;b;c;e;d;b;fi2;ha;b;c;d;e;b;fi4;
ha;e;b;c;d;b;fi3], i.e.,(l4) =n4.
the wf-net in figure 1 is discovered when applying the -algorithm to the
event log in the same gure.
4.3 limitations
in [9] it was shown that the -algorithm is able to discover a large class of
wf-nets if one assumes that the log is complete with respect to the log-based
ordering relation >l. this assumption implies that, for any event log l,a>lb
ifacan be directly followed by b. we revisit the notion of completeness later in
this article.
gac
d
e
fcp1
p2
fig. 11. wf-netn5derived from l5= [ha;c;e;gi2;ha;e;c;gi3;hb;d;f;gi2;hb;f;d;gi4].
even if we assume that the log is complete, the -algorithm has some prob-
lems. there are many dierent wf-nets that have the same possible behavior,
i.e., two models can be structurally dierent but trace equivalent. consider for
examplel5= [ha;c;e;gi2;ha;e;c;gi3;hb;d;f;gi2;hb;f;d;gi4].(l5) is shown in
figure 11. although the model is able to generate the observed behavior, the
resulting wf-net is needlessly complex. two of the input places of gare re-
dundant, i.e., they can be removed without changing the behavior. the places
denoted as p1andp2are so-called implicit places and can be removed without
allowing for more traces. in fact, figure 11 shows only one of many possible
trace equivalent wf-nets.
the original -algorithm has problems dealing with short loops, i.e., loops
of length 1 or 2. this is illustrated by wf-net n6in figure 12 which shows the
result of applying the basic algorithm to l6= [ha;ci2;ha;b;ci3;ha;b;b;ci2]. it is
easy to see that the model does not allow for ha;ciandha;b;b;ci. in fact, in n6,
transitionbneeds to be executed precisely once and there is an implicit place
connecting aandc. this problem can be addressed easily as shown in [46]. using
an improved version of the -algorithm one can discover the wf-net shown in
figure 13.
18a cbfig. 12. incorrect wf-net n6derived from l6= [ha;ci2;ha;b;ci3;ha;b;b;ci2].
a cb
fig. 13. wf-netn7having a so-called \short-loop".
a more dicult problem is the discovery of so-called non-local dependen-
cies resulting from non-free choice process constructs. an example is shown in
figure 14. this net would be a good candidate after observing for example
l8= [ha;c;di45;hb;c;ei42]. however, the -algorithm will derive the wf-net
without the place labeled p1andp2. hence,(l8) =n3shown in figure 8 al-
though the traces ha;c;eiandhb;c;dido not appear in l8. such problems can
be (partially) resolved using rened versions of the -algorithm such as the one
presented in [59].
bca
ed p1
p2
fig. 14. wf-netn8having a non-local dependency.
the above examples show that the -algorithm is able to discover a large
class of models. the basic 8-line algorithm has some limitations when it comes to
particular process patterns (e.g., short-loops and non-local dependencies). some
of these problems can be solved using various renements. however, several more
fundamental problems remain as shown next.
195 challenges
the-algorithm was one of the rst process discovery algorithms to adequately
capture concurrency. today there are much better algorithms that overcome
the weaknesses of the -algorithm. these are either variants of the -algorithm
or algorithms that use a completely dierent approach, e.g., genetic mining or
synthesis based on regions [34]. later we will describe some of these approaches.
however, rst we discuss the main requirements for a good process discovery
algorithm.
to discover a suitable process model it is assumed that the event log contains
arepresentative sample of behavior . there are two related phenomena that may
make an event log less representative for the process being studied:
{noise: the event log contains rare and infrequent behavior not representative
for the typical behavior of the process.
{incompleteness: the event log contains too few events to be able to discover
some of the underlying control-ow structures.
often we would like to abstract from noise when discovering a process. this
does not mean that noise is not relevant. in fact, the goal of conformance check-
ing is to identify exceptions and deviations. however, for process discovery it
makes no sense to include noisy behavior in the model as this will clutter the
diagram and has little predictive value. whereas noise refers to the problem of
having \too much data" (describing rare behavior), completeness refers to the
problem of having \too little data". to illustrate the relevance of completeness,
consider a process consisting of 10 activities that can be executed in parallel
and a corresponding log that contains information about 10,000 cases. the total
number of possible interleavings in the model with 10 concurrent activities is 10!
= 3,628,800. hence, it is impossible that each interleaving is present in the log
as there are fewer cases (10,000) than potential traces (3,628,800). even if there
are 3,628,800 cases in the log, it is extremely unlikely that all possible variations
are present. for the process in which 10 activities can be executed in parallel,
a local notion of completeness can reduce the required number of observations
dramatically. for example, for the -algorithm only 10 (10 1) = 90 rather
than 3,628,800 dierent observations are needed to construct the model.
completeness and noise refer to qualities of the event log and do not say
much about the quality of the discovered model. determining the quality of a
process mining result is dicult and is characterized by many dimensions. as
shown in figure 15, we identify four main quality dimensions: tness ,simplicity ,
precision , and generalization [2,4,51].
a model with good tness allows for the behavior seen in the event log. a
model has a perfect tness if all traces in the log can be replayed by the model
from beginning to end. there are various ways of dening tness. it can be
dened at the case level, e.g., the fraction of traces in the log that can be fully
replayed. it can also be dened at the event level, e.g., the fraction of events
in the log that are indeed possible according to the model [2, 4, 51]. note that
we dened an event log to be a multi-set of traces rather than an ordinary set:
20process 
discoveryfitness
precision generalizationsimplicity“able to replay event log” “occam’s razor”
“not overfitting the log” “not underfitting the log”fig. 15. balancing the four quality dimensions: tness ,simplicity ,precision , and gen-
eralization [2].
the frequencies of traces are important for determining tness. if a trace cannot
be replayed by the model, then the signicance of this problem depends on the
relative frequency.
the simplicity dimension in figure 15 refers to occam's razor , the principle
that states that \one should not increase, beyond what is necessary, the number
of entities required to explain anything". following this principle, we look for
the \simplest process model" that can explain what is observed in the event
log. the complexity of the model could be dened by the number of nodes and
arcs in the underlying graph. also more sophisticated metrics can be used, e.g.,
metrics that take the \structuredness" or \entropy" of the model into account.
fitness and simplicity are obvious criteria. however, this is not sucient as
will be illustrated using figure 16. assume that the four models that are shown
are discovered based on the event log also depicted in the gure. (note that
this event log was already shown in section 1.) there are 1391 cases. of these
1391 cases, 455 followed the trace ha;c;d;e;hi. the second most frequent trace
isha;b;d;e;giwhich was followed by 191 cases.
if we apply the -algorithm to this event log, we obtain model n1shown in
figure 16. a comparison of the wf-net n1and the log shows that this model is
quite good; it is simple and has a good tness. wf-net n2models only the most
frequent trace, i.e., it only allows for the sequence ha;c;d;e;hi. hence, none of
the other 1391 455 = 936 cases ts. wf-net n2is simple but has a poor tness.
let us now consider wf-net n3, this is a variant of the so-called \ower
model" [2, 51], i.e., a model that allows for all known activities at any point in
time. note that a petri net without any places can replay any log and has a be-
havior similar to the \ower model" (but is not a wf-net). figure 16 does not
show a pure \ower model", but still allows for a diversity of behaviors. n3cap-
tures the start and end activities well. however, the model does not put any con-
straints on the other activities. for example trace ha;b;b;b;b;b;b;f;f;f;f;f;g i
21a
start register 
requestbexamine 
thoroughly
cexamine 
casuallydcheck
ticket
decidepay 
compensation
reject 
requestreinitiate 
request eg
hfenda
startregister 
requestc
examine 
casuallyd
check
ticketdecide reject 
requeste h
end
n3 : fitness = +, precision = -, generalization = +, simplicity = +n2 : fitness = -, precision = +, generalization = -, simplicity = +a
start register 
requestb
examine 
thoroughly
c
examine 
casually
d
check ticketdecidepay 
compensation
reject 
request
reinitiate 
requesteg
h
fend
n1 : fitness = +, precision = +, generalization = +, simplicity = +
a
start register 
requestc
examine 
casuallyd
check
ticketdecide reject 
requeste h
end
n4 : fitness = +, precision = +, generalization = -, simplicity = -a
register 
requestd
examine 
casuallyc
check
ticketdecide reject 
requeste ha c
examine 
casuallyd
check
ticketdecidee ga d
examine 
casuallyc
check
ticketdecidee g
register 
requestregister 
requestpay 
compensation
pay 
compensation
a
register 
requestb d
check
ticketdecide reject 
requeste ha
register 
requestd b
check
ticketdecide reject 
requeste ha b d
check
ticketdecidee g
register 
requestpay 
compensationexamine 
thoroughly
examine 
thoroughly
examine 
thoroughly… (all 21 variants seen in the log)acdeh
abdeg
adceh
abdeh
acdeg
adceg
adbeh
acdefdbeh
adbeg
acdefbdeh
acdefbdeg
acdefdbeg
adcefcdeh
adcefdbeh
adcefbdeg
acdefbdefdbeg
adcefdbeg
adcefbdefbdeg
adcefdbefbdeh
adbefbdefdbeg
adcefdbefcdefdbeg455
191
177
144
111
82
56
47
38
33
14
11
9
8
5
3
2
2
1
1
1#trace
1391fig. 16. dierent petri nets discovered for an event log containing 1391 cases.
22is possible, whereas it seems unlikely that this trace is possible when looking at
the event log, i.e., the behavior is very dierent from any of the traces in the
log.
extreme models such as the \ower model" (anything is possible) show the
need for an additional dimension: precision . a model is precise if it does not
allow for \too much" behavior. clearly, the \ower model" lacks precision. a
model that is not precise is \undertting". undertting is the problem that the
model over-generalizes the example behavior in the log, i.e., the model allows
for behaviors very dierent from what was seen in the log.
wf-netn4in figure 16 reveals another potential problem. this model sim-
ply enumerates the 21 dierent traces seen in the event log. note that n4is
a so-called labeled petri net, i.e., multiple transitions can have the same label
(there are 21 transition with label a). the wf-net in figure 16 is precise and
has a good tness. however, n4is also overly complex and is \overtting". wf-
netn4illustrates the need to generalize ; one should not restrict behavior to
the traces seen in the log as these are just examples. overtting is the problem
that a very specic model is generated whereas it is obvious that the log only
holds example behavior, i.e., the model explains the particular sample log, but a
next sample log of the same process may produce a completely dierent process
model. recall that logs are typically far from complete. moreover, generalization
can be used to simplify models. wf-net n1shown in figure 16 allows for be-
havior not seen in the log, e.g., ha;d;c;e;f;d;b;e;f;c;d;e;h i. any wf-net that
restricts the behavior to only seen cases will be much more complex and exclude
behavior which seems likely based on similar traces in the event log.
for real-life event logs it is challenging to balance the four quality dimensions
shown in figure 15. for instance, an oversimplied model is likely to have a
low tness or lack of precision. moreover, there is an obvious trade-o between
undertting and overtting [2,4,48,51].
6 process discovery and the theory of regions
problems similar to process discovery arise in other areas ranging from hardware
design and to controller synthesis of manufacturing systems. often the so called
theory of regions is used to construct a petri net from a behavioral specication
(e.g., a language or a state space), such that the behavior of this net corresponds
to the specied behavior (if such a net exists). the general question answered
by the theory of regions is: given the specied behavior of a system, what is the
petri net that represents this behavior? .
two main types of region theory can be distinguished, namely state-based
region theory andlanguage-based region theory . the state-based theory of regions
focusses on the synthesis of petri nets from state-based models, where the state
space of the petri net is bisimilar to the given state-based model. the language-
based region theory, considers a language over a nite alphabet as a behavioral
specication. using the notion of regions, a petri net is constructed, such that
all words in the language are ring sequences in that petri net.
23the aim of the theory of regions is to synthesize a precise model, with mini-
mal generalization, while keeping a maximal tness. the classical approaches de-
scribed in this section (i.e., conventional state-based region theory and language
based region theory) do not put much emphasis on simplicity. unlike algorithms
such as the heuristic miner [58], the genetic miner [47], and the fuzzy miner [39],
conventional region-based methods do not compromise on precision in favor of
simplicity or generalization.
in the remainder of this section, we introduce the main region theory concepts
and discuss the dierences between synthesis and process discovery. in section 7
and section 8 we show how region theory can be used in the context of process
discovery.
6.1 state based region theory
the state-based region theory [13, 15, 23, 24, 26, 27, 35] uses a transition system
as input, i.e., it attempts to construct a petri net that is bisimilar to the transi-
tion system. hence both are behaviorally equivalent and if the system exhibits
concurrency, the petri net may be much smaller than the transition system.
denition 9 (transition system). ts= (s;e;t )denes a labeled tran-
sition system wheresis the set of states, ais the set of visible activities
(i.e., activities recorded in event log), 62ais used to represent silent steps
(i.e., actions not recorded in event log), e=a[fgis the set of transi-
tion labels, and tsesis the transition relation. we use s1e!s2
to denote a transition from state s1tos2labeled with e. furthermore, we say
thatss=fs2sj69s02s;e2es0e!sgsis the set of initial states, and
se=fs2sj69s02s;e2ese!s0gsis the set of nal states.
in the transition system, a region corresponds to a set of states such that
all states have similarly labeled input and output edges. figure 17 shows an
example of a transition system. in fact, this gure depicts the reachability graph
of the petri net in figure 5, where the states are anonymous, i.e., they do not
contain information about how many tokens are in a place.
denition 10 (state region). letts= (s;e;t )be a transition system and
s0sa set of states. we say s0is a region, if and only if for all e2eone of
the following conditions holds:
1. all the transitions s1e!s2enters0, i.e.,s1=2s0ands22s0,
2. all the transitions s1e!s2exits0, i.e.,s12s0ands2=2s0,
3. all the transitions s1e!s2do not cross s0, i.e.,s1;s22s0ors1;s2=2s0
any transition system ts= (s;e;t ) has two trivial regions: ;(the empty
region) and s(the region consisting of all states). typically, only non-trivial
regions are considered. a region r0is said to be a subregion of another region r
ifr0r. a regionrisminimal if there is no other region r0which is a subregion
ofr. regionris a preregion ofeif there is a transition labeled with ewhich
24s1as2 s3cs5
bs6cs7d
s4 s8debfig. 17. a transition system with 8 states, 5 labels, 1 initial state and 2 nal states.
s1as2 s3cs5
bs6cs7d
s4 s8deb
ab
cd e
p1p2
p3p4
p5p6
fig. 18. the transition system of figure 17 is converted into a petri net using the
\state regions". the six regions correspond to places in the petri net.
25(classical 
region 
theory)s1as2 s4ds3
ed
a de
p1 p2 p3a d1e
p1 p2 p4d2p3(using 
label 
splitting)fig. 19. the transition system is not elementary. therefore, the generated petri net
using classical region theory is not equivalent (modulo bisimilarity). however, using
\label-splitting" an equivalent petri net can be obtained.
exitsr. regionris apostregion ofeif there is a transition labeled with ewhich
entersr.
for petri net synthesis, a region corresponds to a petri net place and an
event corresponds to a petri net transition . thus, the main idea of the synthesis
algorithm is the following: for each event ein the transition system, a transition
labeled with eis generated in the petri net. for each minimal region ria placepi
is generated. the ow relation of the petri net is built the following way: e2pi
ifriis a preregion of eande2piifriis a postregion of e. figure 18 shows
the minimal regions of the transition system of figure 17 and the corresponding
petri net.
the rst publications on the theory of regions only dealt with a special class
of transition systems called elementary transition systems . see [13, 15, 30] for
details. the class of elementary transition systems is very restricted. in practice,
most of the time, people need to deal with arbitrary transition systems that only
by coincidence fall into the class of elementary transition systems. in the papers
of cortadella et al. [26, 27], a method for handling arbitrary transition systems
was presented. this approach uses labeled petri nets , i.e., dierent transitions can
refer to the same event. (wf-net n4in figure 16 is an example of a labeled petri
net, e.g., there are 21 transitions labeled a.) for this approach it has been shown
that the behavior (cf. reachability graph) of the synthesized petri net is bisimilar
to the initial transition system even if the transition system is non-elementary.
26more recently, in [23,24], an approach was presented where the constructed petri
net is not necessarily safe, but bounded1. again, the reachability graph of the
synthesized petri net is bisimilar to the given transition system.
to illustrate the problem of non-elementary transition systems, consider fig-
ure 19. this transition system is not elementary. the problem is that there are
two statess2 ands3 that are identical in terms of regions, i.e., there is no region
such that one is part of it and the other is not. as a result, the constructed petri
net on the left hand side of figure 19 fails to construct a bisimilar petri net.
however, using label-splitting as presented in [26,27], the petri net on the right
hand side can be obtained. this petri net has two transitions d1 andd2 corre-
sponding to activity din the log. the splitting is based on the so-called notions
ofexcitation and generalized excitation region , see [26]. as shown in [26, 27] it
is always possible to construct an equivalent petri net. however, label-splitting
may lead to larger petri nets. in [21] the authors show how to obtain the most
precise model when label splitting is not allowed.
in state-based region theory, the aim is to construct a petri net, such that
its behavior is bisimilar to the given transition system. in process discovery
however, we have a log as input, i.e., we have information about sequences of
transitions, but not about states. in section 7, we show how we can identify state
information from event logs and then use state-based region theory for process
discovery. however, we rst introduce language-based region theory.
6.2 language based region theory
in addition to state-based region theory, we also consider language-based region
theory [14,17,19,28,42,43]. in their survey paper [45], mauser and lorenz show
how for dierent classes of languages (step languages, regular languages and
(innite) partial languages) a petri net can be derived such that the resulting
net is the petri net with the smallest behavior in which the words in the language
are possible ring sequences.
given a prex-closed language aover some non-empty, nite set of activities
a, the language-based theory of regions tries to nd a nite petri net n(a) in
which the transitions correspond to the elements in the set aand of which all
sequences in the language are ring sequences (tness criterion). furthermore,
the petri net should minimize the number of ring sequences not in the language
(precision criterion).
the petri net n(a) = (;;a;;) is a nite petri net with innitely many
ring sequences allowing for any sequence involving activities a. such a model
is typically undertting, i.e., allowing for more behavior than suggested by the
event log. therefore, the behavior of this petri net needs to be reduced so that
the petri net still allows to reproduce all sequences in the language, but does
not allow for behavior unrelated to the examples seen in the event log. this is
achieved by adding places to the petri net. the theory of regions provides a
method to identify these places, using language regions .
1a petri net is safe if there can never be more than 1 token in any place. boundedness
implies that there exists an upper bound for the number of tokens in any place.
27denition 11 (language region). letabe a set of activities. a region
of a prex-closed language loverais a triple (~ x;~ y;c )with~ x;~ y2f0;1gaand
c2f0;1g, such that for each non-empty sequence w=w0a2l,w02l,a2a:
c+x
t2a
~w0(t)~ x(t) ~ w(t)~ y(t)
0
this can be rewritten into the inequation system:
c~1 +m0~ x m~ y~0
wheremandm0are twojljjajmatrices with m(w;t) =~ w(t), andm0(w;t) =
~w0(t), withw=w0a. the set of all regions of a language is denoted by <(l)
and the region (~0;~0;0)is called the trivial region .2
consider a region r= (~ x;~ y;c ) corresponding to some place pr. for any prex
w=w0ainl, regionrsatisesc+p
t2a
~w0(t)~ x(t) ~ w(t)~ y(t)
0 where
cis the initial number of tokens in place pr,p
t2a~w0(t)~ x(t) is the number
of tokens produced for place prjust before ring a(note that w0is the prex
without including the last a), andp
t2a~ w(t)~ y(t) is the number of tokens
consumed from place prafter ring a(wis the concatenation of w0anda).~ wis
the parikh vector of w, i.e.,~ w(t) is the number of times tappears in sequence
w.~ x(t) is the number of tokens tproduces for place pr. transition tconsumes
~ y(t) tokens from place prper ring. so, ~ w(t)~ y(t) is the total number of tokens
tconsumes from place prwhen executing w.
t1 t2
t4 t3x1x2
x3x4y1
y2
y3
y2c
fig. 20. region for a language with four letters: t1,t2,t3, andt4.
figure 20 illustrates the language-based region concept using for a language
over four activities ( jaj=4), i.e., each solution ( ~ x;~ y;c ) of the inequation system
can be regarded in the context of a petri net, where the region corresponds to a
2to reduce calculation time, the inequation system can be rewritten to the form
[~1;m0; m]~ r~0 which can be simplied by eliminating duplicate rows.
28feasible place with preset ftjt2t;~ x(t)1gand postsetftjt2t;~ y(t)1g,
and initially marked with ctokens. in this paper, we assume arc-weights to
be 0 or 1 as we aim at understandable models (i.e., ~ x;~ y2f0;1ga). as shown
in [14, 16, 28, 43] it is possible to generalize the above notions to arbitrary arc-
weights.
a place represented by a region can be added to a petri net, without limiting
its behavior with respect to traces seen in the event log. therefore, we call such
a place feasible .
denition 12 (feasible place). letlbe a prex-closed language over aand
letn= ((p;t;f );m)be a marked petri net with t=aandm2i b(p). a
placep2pis called feasible if and only if there exists a corresponding region
(~ x;~ y;c )2<(l)such thatm(p) =c, and~ x(t) = 1 if and only if t2p, and
~ y(t) = 1 if and only if t2p.
in [16,43] it was shown that any solution of the inequation system of deni-
tion 11 can be added to a petri net without inuencing the ability of that petri
net to replay the log. however, since there are innitely many solutions of that
inequation system (assuming arc weights), there are innite many feasible places
and the authors of [16,43] present two ways of nitely representing these places,
namely a basis representation [43] and a separating representation [16,43].
6.3 process discovery vs. region theory
when comparing region theory|state-based or language based|with process
discovery, some important dierences should be noted. first of all, in region
theory, the starting point is a full behavioral specication , either in the form of a
(possibly innite) transition system, or a (possibly innite) language. hence, the
underlying assumption is that the input is complete andnoise free and therefore
maximal tness is assured.
second, the aim of region theory is to provide a compact, exact representation
of that behavior in the form of a petri net. if the net allows for more behavior
than specied, then this additional behavior can be proven to be minimal, hence
region theory provides precise results.
finally, when region theory is directly applied in the context of process dis-
covery [16,21,53], the resulting petri nets typically perform poorly with respect
to two of the four dimensions shown in figure 15. the resulting models are
typically overtting (lack of generalization) and are too dicult to comprehend
(simplicity criterion). therefore, in sections 7 and 8, we show how region theory
can be modied for process discovery. the key idea is to allow the algorithms to
generalize and relax on preciseness, with the aim of obtaining simpler models.
7 process discovery using state-based region theory
in section 2 we introduced the concept of control-ow discovery and discussed
the problems of existing approaches. in section 6, we introduced region theory
29and showed the main dierences with control ow discovery. in this section, we
introduce a two-step approach to combine process discovery with state-based
region theory [8]. in the remainder, we elaborate on these two steps and discuss
challenges.
7.1 from event logs to transition systems
in the rst step, we construct a transition system from the log, where we gener-
alize from the observed behavior. furthermore, we \massage" the output, such
that the region theory used in the second step is more likely to produce a simple
model. in the second step, we use classical state-based region theory to obtain a
petri net. this section describes the rst and most important step. depending
on the desired properties of the model and the characteristics of the log, the
algorithm can be tuned to provide a more simple and/or generic model.
the most important aspect of process discovery is deducing the states of the
operational process in the log . most mining algorithms have an implicit notion of
state, i.e., activities are glued together in some process modeling language based
on an analysis of the log and the resulting model has a behavior that can be
represented as a transition system. in this section, we propose to dene states
explicitly and start with the denition of a transition system.
trace:  a b c d c d c d e    f a g h h h i
past futurecurrent state
past and future
fig. 21. three basic \ingredients" can be considered as a basis for calculating the
\process state": (1) past, (2) future, and (3) past and future.
in some cases, the state can be derived directly, e.g., each event encodes the
complete state by providing values for all relevant data attributes. however, in
the event log we typically only see activities and not states. hence, we need
to deduce the state information from the activities executed before and after a
given state. based on this, there are basically three approaches to dening the
state of a partially executed case in a log:
{past, i.e., the state is constructed based on the history of a case,
{future , i.e., the state of a case is based on its future, or
{past and future , i.e., a combination of the previous two.
30abcd
acbd
aed
abcd
abcd
aed
acbd
...
(b) transition system based on postfix<>a<a> <a,e>e<a,e,d>d<a,b>
b<a,b,c>c<a,b,c,d>d
<a,c> <a,c,b>b<a,c,b,d>dc
<a,b,c,d>a<b,c,d>
<a,e,d> <e,d>
<a,c,b,d>a
a<c,b,d><d>e<c,d>
<b,d>b
cc
b<>d
<>
<a,b,c,d>a <a>
<b,c,d>
<>
<a,e,d><a>
<e,d>
<>
<a,c,b,d>a
a <a>
<c,b,d><a,e>
<d>e<a,b>
<c,d>
<a,c>
<b,d>b
c<a,e,d>
<>d
<a,c,b>
<d>b<a,b,c>
<d>c <a,b,c,d>
<>d
<a,c,b,d>
<>d
(c) transition system based on prefix and postfix(a) transition system based on prefixfig. 22. three transition systems derived from the log l1= [ha;b;c;di5;ha;c;b;di8;
ha;e;di9].
figure 21 shows an example of a trace and the three dierent \ingredients"
that can be used to calculate state information. given a concrete trace, i.e.,
the execution of a case from beginning to end, we can look at the state after
executing the rst nine activities. this state can be represented by the prex,
the postx, or both.
to explain the basic idea of constructing a transition system from an event
log, consider figure 22. if we just consider the prex (i.e., the past), we get the
transition system shown in figure 22(a). note that the initial state is denoted
hi, i.e., the empty sequence. starting from this initial state the rst activity is
alwaysain each of the traces. hence, there is one outgoing arc labeled a, and
the subsequent state is labeled hai. from this state, three transitions are possible
31all resulting in dierent states, e.g., executing activity bresults in stateha;bi,
etc. note that in figure 22(a) there is one initial state and three nal states.
figure 22(b) shows the transition system based on postxes. here the state of
a case is determined by its future. this future is known because process mining
looks at the event log containing completed cases. now there are three initial
states and one nal state. initial state ha;e;diindicates that the next activity
will bea, followed by eandd. note that the nal state has label hiindicating
that no activities need to be executed. figure 22(c) shows a transition system
based on both past and future. the node with label \ ha;bi,hc;di" denotes the
state where aandbhave happened and canddstill need to occur. note that
now there are three initial states and three nal states.
the past of a case is a prex of the complete trace. similarly, the future of a
case is a postx of the complete trace. this may be taken into account completely,
which leads to many dierent states and process models that may be too specic
(i.e., \overtting" models). it is also possible to take less information into account
(e.g., just the last step in the process). this may result in \undertting" models.
the challenge is to select an abstraction that balances between \overtting" and
\undertting". many abstractions are possible; see for example the systematic
treatment of abstractions in [8]. here, we only highlight some of them.
maximal horizon ( h)the basis of the state calculation can be the complete
prex (postx) or a partial prex (postx).
filter (f)the second abstraction is to lter the (partial) prex and/or postx,
i.e., activities in faare kept while activities anfare removed.
maximum number of ltered events ( m)the sequence resulting after l-
tering may contain a variable number of elements. again one can determine
a kind of horizon for this ltered sequence.
sequence, bag, or set ( q)the rst three abstractions yield a sequence. the
fourth abstraction mechanism optionally removes the order or frequency
from the resulting trace.
visible activities ( v)the fth abstraction is concerned with the transition
labels. activities in vaare shown explicitly on the arcs while the activ-
ities inanvare not shown.
figure 23 illustrates the abstractions. in figure 23(a) only the set abstraction
is usedq=set. the result is that several states are merged (compare with fig-
ure 22(a)). in figure 23(b) activities bandcare ltered out (i.e., f=fa;d;eg
andv=fa;d;eg). moreover, only the last non-ltered event is considered for
constructing the state (i.e., m= 1). note that the states in figure 23(b) refer to
the last event in fa;d;eg. therefore, there are four states: hai,hdi,hei, andhi.
it is interesting to consider the role of bandc. first of all, they are not consid-
ered for building the state ( f=fa;d;eg). second, they are also not visualized
(v=fa;d;eg), i.e., the labels are suppressed. the corresponding transitions are
collapsed into the unlabeled arc from haitohai. ifvwould have included band
c, there would have been two such arcs labeled brespectively c.
32abcd
acbd
aed
abcd
abcd
aed
acbd
...{}a{a} {a,c}c{a,b}
b{a,b,c}c{a,b,c,d}d
{a,e} {a,d,e}de
(a) transition system based on setsb
<>a<a> <d>d<e>
e
(b) transition system abstracting from b and cdfig. 23. two transition systems built on l1using the following prex abstractions:
(a)h=1,f=a(i.e., all activities), m=1,q=set, andv=a, and (b)h=1,
f=fa;d;eg,m= 1,q=seq, andv=fa;d;eg.
the rst four abstractions can be applied to the prex, the postx, or both.
in fact, dierent abstractions can be applied to the prex and postx. as a
result of these choices many dierent transitions systems can be generated. if
more rigorous abstractions are used, the number of states will be smaller and
the danger of \undertting" is present. if, on the other hand, fewer abstractions
are used, the number of states may be larger resulting in an \overtting" model.
an extreme case of overtting was shown in figure 22(c). at rst this may seem
confusing; however, as indicated in the introduction it is important to provide a
repertoire of process discovery approaches. depending on the desired degree of
generalization, suitable abstractions are selected and in this way the analyst can
balance between overtting and undertting, i.e., between generalization and
precision in a controlled way.
using classical region theory, we can transform the transition system into a
process model. however, while we can now balance precision and generalization,
we did not focus on simplicity yet. therefore, we make use of the inner workings
of state-based region theory to \massage" the transition system. this is intended
to \pave the path" for region theory. for example, one may remove all \self-
loops", i.e., transitions of the form sa!s(cf. figure 24(a)). the reason may
be that one is not interested in events that do not change the state or that
the synthesis algorithm in the second step cannot handle this. another example
33would be to close all \diamonds" as shown in figure 24(b). if s1a1!s2,s1a2!s3,
ands2a2!s4, thens3a1!s4is added. the reason for doing so may be that because
(1) botha1anda2are enabled in s1and (2) after doing a1, activitya2is still
enabled, it is assumed that a1anda2can be executed in parallel. although the
sequenceha2;a1iwas not observed, it is assumed that this is possible and hence
the transition system is extended by adding s3a1!s4.
s1
s2 s3
s4s1
s2 s3
s4a1 a2
a2a1 a2
a2 a1
(a) closing the “diamond”s
(a) removing self-loopsas
fig. 24. two examples of modications of the transition system to aid the construction
of the process model.
7.2 from transition systems to petri nets
in the second step, the transition system is transformed into a petri net using
the techniques described in [13,15,23,24,26,27,35]. in section 6.1, we introduced
the basic idea of state-based regions. therefore, we do not elaborate on this here.
the important thing to note is that there is range of techniques to convert a
transition system into a petri net. these techniques typically only address two
of the four quality dimensions mentioned in figure 15: tness and precision .
the other two dimensions| simplicity andgeneralization |need to be addressed
when constructing the transition system or by imposing additional constraints
on the petri net.
the goal of process mining is to present a model that can be interpreted
easily by process analysts and end-users. therefore, complex patterns should be
avoided. region-based approaches have a tendency to introduce \smart places",
i.e., places that compactly serve multiple purposes. such places have many con-
nections and may have non-local eects (i.e., the same place is used for dierent
purposes in dierent phases of the process). therefore, it may be useful to guide
the generation of places such that they are easier to understand. this is fairly
straightforward in both state-based region theory and language-based region
theory. in [26, 27] it is shown that additional requirements can be added with
respect to the properties of the resulting net. for example, the net can be forced
to be free-choice, pure, etc. see [8] for examples.
34ab
cd e
ab c
d
ea
c b
ab
cd
e
a d e
d(a)
(b)
(c) (d)
ab
cd
efig. 25. various petri nets derived for the transitions systems in gures 22 and 23 using
state-based regions. all models are based on event log l1= [ha;b;c;di5;ha;c;b;di8;
ha;e;di9].
the approach was already illustrated using figure 18. figure 25 shows some
more examples based on the transition systems in gures 22 and 23. these mod-
els where computed using the classical synthesis approach presented in [26,27].
this approach applies label-splitting if needed. note that all transition systems
were derived from event log l1= [ha;b;c;di5;ha;c;b;di8;ha;e;di9]. the petri net
in figure 25(a) is obtained by applying state-based region theory to the transi-
tion system in figure 22(a). the same model is obtained when computing the
regions for the transition system in figure 23(a). the petri net in figure 25(b)
is obtained when applying state-based region theory to the transition system in
figure 22(b). two things can be noted: (1) the multiple initial states in fig-
ure 22(b) result in many initial tokens and source places, and (2) label splitting
is used (e.g., there are two atransitions) to allow for the multiple starting points.
the region-based approach synthesizes the model in figure 25(c) for the tran-
sition system in figure 22(c). also this model suers from the problem that
there are multiple initial states. in general, we suggest to avoid having multiple
initial states in the transition system to be synthesized. it is trivial to merge
the initial states or add a new articial initial state before applying region-based
synthesis. figure 25(d) was obtained from the transition system in figure 23(b).
the petri net shows that if we abstract from bandc, we obtain an unlabeled
35transition indicating the state in which bandcwould have occurred. this silent
transition is due to the self-loop in the transition system of figure 23(b). elim-
inating the self-loop using the strategy presented in figure 24(a) would remove
the unlabeled transition in figure 25(d).
7.3 challenges
in this section, we have shown that by combining abstraction techniques and
region theory, a powerful process mining algorithm can be obtained. through
several abstractions, we can obtain the desired level of precision and general-
ization, while by massaging the transition system, we can try to obtain simple
models. however, there are also some drawbacks of this approach.
a cb
fig. 26. petri net obtained using region theory applied to log l6= [ha;ci2;ha;b;ci3;
ha;b;b;ci2] using the following settings: h=1,f=a(i.e., all activities), m=1,
q=set, andv=aand a post-processing step in which states with identical inow or
outow are merged.
it is far from trivial to select the \right" parameters for the abstractions.
existing techniques and tools are sensitive to changes of parameter values, and
the result is often unpredictable. hence, obtaining a suitable process model is a
matter of trial-and-error. figure 26 shows, for example, the settings with which
we can obtain the desired model for log l6, i.e., the petri net with a self-loop on
transitionb. however, the model shown in figure 27 illustrates that the wrong
settings may lead to an overtting model.
nonetheless, the state-based region approach is one of the few that can detect
long-term dependencies, as shown by figure 28, which resulted from applying
the technique to log l8.
furthermore, the major drawback of the approach outlined here is the com-
putational complexity. for larger logs, the resulting transition system may not
t in main memory and second, the region theory used to obtain a petri net has
a time complexity which is exponential in the size of the transition system.
8 process discovery using integer linear programming
in section 7, we have presented a two-step approach to apply region theory in
the context of process mining. we focussed on obtaining a transition system
36abb
cc
cfig. 27. petri net obtained using region theory applied to log l6using the following
parameters: h=1,f=a(i.e., all activities), m=1,q=multiset , andv=a.
bca
ed
fig. 28. petri net obtained using region theory applied to log l8= [ha;c;di45;
hb;c;ei42] using the following settings: h=1,f=a(i.e., all activities), m=1,
q=set, andv=a.
from an event log and used classical region theory to obtain a petri net. in
this section, we do not consider the region theory as a black box, but instead,
we extend existing approaches to make them more applicable in the context of
process discovery, mainly by allowing the techniques to generalize from the log
and to produce simpler models.
both a basis and the separating representations of regions presented in [16,43]
are based on the same principle, namely that a nite representation is provided
of the innite set of places satisfying denition 11. by doing so, the language-
based region theory ensures maximal preciseness and tness, with little to no
generalization and no aim for simple models. hence, only two of the four quality
dimensions of figure 15 are considered.
for process discovery, we are aiming at simple, generalizing models. hence,
we present an approach [60], where we only represent those places satisfying
denition 11 that:
{each place expresses a causal dependency clearly visible in the log,
{no implicit places are included in the net, and
{places which are more expressive than others are favored, i.e., places with
minimal input transitions and maximal output transitions are favored.
in contrast to the state-based region approach, we do not try to inuence
generalization and precision directly. instead, we focus on model simplicity, by
37limiting the number of places in the model (and allowing for varying this num-
ber). as with the state-based approach, maximal tness is guaranteed. in order
to select places satisfying denition 11, we convert this equation into a integer
linear programming (ilp) problem.
8.1 integer linear programming representation
we quantify the expressiveness of places, in order to provide a target function,
necessary to translate the inequation system of denition 11 into an integer
linear programming (ilp) problem. in section 8.2, we then use the result to
generate a petri net in a step-by-step fashion. in section 8.3, we provide insights
into the causal dependencies found in a log and how these can be used for nding
places.
to apply the language-based theory of regions in the eld of process discovery,
we need to represent the event log as a prex-closed language, i.e., by all the
traces present in the event log, and their prexes. recall from denition 1 that
an event log is a nite bag of traces.
denition 13 (language of an event log). letabe a set of activities.
letl2i b(a)be an event log over this set of activities. the language lthat
represents this event log, uses alphabet a, and is dened by:
l=f2aj902l:0g
a trivial petri net capable of reproducing a language is a net with only
transitions. this net is simple, can represent all traces, and hence has maximal
tness. it also generalizes well, but the petri net with only transitions is very
imprecise because anything is possible according to the model. to restrict the
behavior allowed by the petri net, but not observed in the log, we start adding
places to that petri net. as stated before, the places we add to the petri net
should be as expressive as possible , which is the same as saying that such places
have a maximal postset and a minimal preset, i.e., it should not be possible
to add an output transition to or to remove an input transition from a place
without reducing the tness of the resulting net.
besides searching for regions that lead to places with maximum expressive-
ness, we also want to avoid adding implicit places to a model. therefore, we will
search for \minimal regions" as introduced in [30]. using the inequation system
of denition 11 and the expressiveness of a place, we can dene a target function
for our ilp problem to construct the places of a petri net in a logical order [52].
the following target function is shown to be such that it favors minimal
regions which are maximally expressive [60]:
denition 14 (target function). letabe a set of activities. let l2i b(a)
be an event log and lthe corresponding language. furthermore, let mbe the
matrix dened in denition 11. we dene the function :<(l)!i nby
((~ x;~ y;c )) =c+~1t(~1c+m(~ x ~ y))
38combining this target function with the inequation system of denition 11
yields the following ilp problem:
denition 15 (ilp formulation). letabe a set of activities, let l2i b(a)
be an event log, and let mandm0be the matrices as dened in denition 11.
we dene the ilp ilp lfor event log las:
minc+~1t(~1c+m(~ x ~ y)) denition 14
s.t.c~1 +m0~ x m~ y~0 denition 11
~1t~ x+~1t~ y1 there should be at least one edge
~0~ x~1x2f0;1gjtj
~0~ y~1y2f0;1gjtj
0c1c2f0;1g
this ilp problem provides the basis for our process discovery problem. how-
ever, an optimal solution to this ilp only provides a single feasible place with
a minimal value for the target function. therefore, in the next section, we show
how this ilp problem can be used as a basis for constructing a petri net from a
log.
8.2 constructing petri nets using ilp
in the previous subsection, we provided the basis for adding places to a petri
net based on knowledge extracted from a log. in fact, the target function of
denition 14 provides a partial order on all elements of the set <(l), i.e., the set
of all regions of a language. in this subsection, we show how to generate the rst
nplaces of a petri net, that is (1) able to reproduce a log under consideration
and (2) of which the places are as expressive as possible.
a trivial approach would be to add each found solution as a negative example
to the ilp problem, i.e., explicitly forbidding this solution. however, it is clear
that once a region rhas been found and the corresponding feasible place is
added to the petri net, we are no longer interested in regions r0for which the
corresponding feasible place has more tokens, less outgoing arcs or more incoming
arcs, i.e., we are only interested in independent regions.
denition 16 (rening the ilp after each solution). letabe a set of
activities, let l2i b(a)be an event log, let mandm0be the matrices as dened
in denition 11 and let ilp0
lbe the corresponding ilp. furthermore, for i0
let regionri= (~ xi;~ yi;ci)be a minimal solution of ilpi
l. we dene the rened
ilp as ilpi
l, with the extra constraint specifying that:
 cic+~ yt(~1 ~ yi) ~ xt~ xi ci+ 1 ~1t~ xi
note that for any solution r= (~ x;~ y;c ) of ilpi
l:c < cior there is a t2a
such that~ x(t)< ~ xi(t) or~ y(t)> ~ yi(t). if this is not the case (i.e., cciand
~ x(t)~ xi(t) and~ y(t)~ yi(t) for anyt), then cic= ci, ~ x(t)~ xi(t) = xi(t),
and~ y(t)~ yi(t) = 061. hence, we nd a contradiction with respect to the extra
39constraint. as a result the new region ris forced to be suciently dierent from
ri.
the renement operator presented above, basically denes an algorithm for
constructing the places of a petri net that is capable of reproducing a given log.
the places are generated in an order which ensures that the most expressive
places are found rst and that only places are added that have less tokens, less
outgoing arcs, or more incoming arcs. furthermore, each solution of a rened
ilp is also a solution of the original ilp, since the new solution satises all
constraints of the initial ilp formulation, and some extra constraints. hence, all
places constructed using this procedure are feasible places.
this procedure, can be used to continue adding places, thus making the model
more precise, while compromising on model complexity as shown by figure 29.
the petri net in figure 29 allows for more behavior than the log l1contains, so
in theory more places could still be added. nonetheless, any new place would be
such that it has fewer output arcs, or more input arcs than the ones included in
this model. in the worst case, the total number of places introduced is exponential
in the number of transitions. since there is no way to provide insights into an
upperbound for the number of places to generate, we propose a more suitable
approach, not using the renement step of denition 16 . instead, we propose
to guide the search for solutions (i.e. for places) using concepts from the -
algorithm [9].
8.3 using log-based properties
recall from the beginning of this section, that we are specically interested
in places expressing explicit causal dependencies between transitions. in this
subsection, we use the causal relations !ldened earlier in denition 7 in
combination with the ilp of denition 15 to construct a petri net.
ab
c de
fig. 29. petri net obtained using language-based region theory naively applied to log
l1.
40causal dependencies between transitions are used by many process discovery
algorithms [6,9,31,58] and generally provide a good indication as to which tran-
sitions should be connected through places. furthermore, extensive techniques
are available to derive causal dependencies between transitions using heuristic
approaches [9, 31]. however, it is not known whether the log is complete and
whether we covered all causal dependencies. therefore, we restrict ourselves to
search for a petri net such that if a causal dependency is not in the log, it is also
not in the net. in order to nd a place expressing a specic causal dependency,
we extend the ilp presented in denition 15.
denition 17 (ilp for causal dependency). letabe a set of activities,
letl2i b(a)be an event log, let mandm0be the matrices as dened in
denition 11 and let ilp lbe the corresponding ilp. furthermore, let t1;t22a
and assume t1!lt2. we dene the rened ilp, ilpt1!t2
l as ilpl, with two
extra bounds specifying that:
~ x(t1) =~ y(t2) = 1
a solution of the optimization problem expresses the causal dependency
t1!lt2, and restricts the behavior as much as possible. however, such a solu-
tion does not have to exist, i.e., the ilp might be infeasible, in which case no
place is added to the petri net being constructed. nonetheless, by considering
a separate ilp for each causal dependency in the log, a petri net can be con-
structed, in which each place is as expressive as possible and expresses at least
one dependency derived from the log. with this approach, at most one place is
generated for each dependency and thus the upper bound of places in n(l) is
the number of causal dependencies, which is worst-case quadratic in the number
of transitions.
the result of applying this log-based technique to our log l1is shown in
figure 30. this model is very close to the desired model, except that it does
not contain a nal place. this is a general drawback of language-based region
theory: the focus is on the ability to reproduce prexes of log traces rather than
termination in a well-dened nal state.
up to now, we did not impose any restriction on the structure of the resulting
petri net. by adding constraints, several petri net properties can be expressed,
thus resulting in elementary nets, pure nets, (extended) free-choice nets, state
machines and marked graphs [60]. this allows us to further simplify the resulting
petri net. note that this is similar to the renement described in section 7.2 for
state-based regions.
8.4 challenges
in sections 7 and 8 we presented several ways to use region theory in the context
of process discovery in order to alleviate some of the problems of the -algorithm.
first, we have shown how to we can balance precision and generalization while
constructing a transition system from a log. then, by massaging the transition
41ab
cd efig. 30. petri net obtained using language-based region theory using log-based proper-
ties applied to log l1. note that compared to earlier solutions the sink place denoting
termination is missing.
system, we can somewhat improve the simplicity of the resulting models. when
using language-based region theory, we have shown that we can focus on the sim-
plicity of the resulting model. by incrementally introducing places, we can make
the resulting model more precise in a step-by-step fashion. figures 31 and 32
show that we can discover models for the logs l6andl8, but the long-term de-
pendency in l8is not identied, due to the reliance on the causal dependencies
used in the -algorithm. furthermore, as discussed before, language-based re-
gions have problems making the nal state explicit (i.e., sink places are missing
in gures 31 and 32).
a cb
fig. 31. petri net discovered for event log l6. the model was obtained using language-
based region theory guided by log-based properties.
bca
ed
fig. 32. petri net obtained using language-based region theory guided by log-based
properties applied to log l8= [ha;c;di45;hb;c;ei42]. no sink place is created and the
long-term dependencies are not discovered because only short-term dependencies are
used to guide the discovery of places.
42unfortunately, all region-based approaches are computationally challenging.
in the case of the language-based regions, nding a solution for each incremen-
tal ilp problem is of worst-case exponential time complexity. furthermore, the
common property of all region-based techniques is that the tness of the dis-
covered net is guaranteed to be 100%, regardless of the log. this makes these
approaches very robust, but also sensitive to noise.
thus far we only used toy examples to illustrate the dierent concepts. all
functionality has been embedded in the process discovery framework prom,
which is capable of constructing nets for logs with thousands of cases refer-
ring to dozens of transitions. the techniques have been tested on many real-life
and synthetic event logs. however, a discussion of these experimental results is
outside the scope of this article. for this we refer to [2,7,39,47,53].
9 tool support
both for process mining and region theory, it is essential that algorithms can be
put to the test in real life environments. therefore, almost all work presented in
this article is implemented in freely available tools. for example, classical state-
based region theory is implemented in petrify and genet [22], while rbminer [54]
applies this in a process discovery context. some of the language-based region
theory is implemented in viptool [18].
the process mining algorithms presented in sections 4, 7 and 8 have all
been implemented in the prom framework [11, 56, 57]. all algorithms discussed
in this article can be found the most recent version of prom (version 6.0 and
later). prom is a generic open-source framework for implementing process mining
algorithms in a standard environment.
figure 33 shows the startup screen of prom. here, a log was opened for
analysis which is shown in the workspace. when selecting the log and clicking on
the action button, the user is taken to the action browser, where in figure 34, the
-miner is selected. the -miner is an implementation of the work in section 4.
in earlier versions of prom, the actual process mining algorithms imple-
mented by plug-ins assumed the presence of a gui. most algorithms require
parameters, and the plug-in would ask the user for these parameters using some
gui-based dialog. furthermore, some plug-ins displayed status information us-
ing progress bars and such. thus, the actual process mining algorithm and the
use of the gui were intertwined. as a result, the algorithm could only be run
in a gui-aware context, say on a local workstation. this way, it was impossible
to eectively run process mining experiments using a distributed infrastructure
and/or in batch.
in prom 6, the process mining algorithm and the gui have been carefully
separated, and the concepts of contexts has been introduced. for a plug-in, the
context is the proxy for its environment, and the context determines what the
plug-in can do in its environment. a plug-in can only display a dialog or a
progress bar on the display if the context is gui-aware. typically, in prom 6,
the implementation of an algorithm is split into a number of plug-ins: a plug-in
43fig. 33. prom 6 workspace; opening screen after loading a le.
fig. 34. prom 6 action browser; selecting the alpha -miner to discover a process model
from the loaded event log.
44fig. 35. prom 6 package manager showing the packages relevant for the techniques
presented in this article.
for every context. the actual process mining algorithm will be implemented in a
generic way, such that it can run in a general (gui-unaware) context. this allows
the algorithm to be run in any context, even in a distributed context [20]. the
dialog for setting the required parameters is typically implemented in a gui-
aware variant of the plug-in. typically, this gui-aware plug-in rst displays the
parameter dialog, and when the user has provided the parameters and has closed
the dialog, it will simply run the generic plug-in using the provided parameters.
the major advantage of this is that the prom framework may decide to have
the generic plug-in run on a dierent computer than the local workstation. some
plug-ins may require lots of system resources (e.g., computing power, memory,
and disk space), like for example the genetic miner. basically, the genetic miner
takes a model and a log, and then generates a number of alternative models
for the given log. the best of these alternative models are then taken as new
starting points for the genetic miner. the genetic miner repeats this until some
stop criterion has been reached, after which it returns the best model found so
far. clearly, this miner might take considerable time (it may take hundreds of
iterations before it stops and the tness calculation is very time-consuming for
large logs), and it may take considerable memory (the number of alternative
models may grow rapidly). for such an algorithm, it might be preferable to have
it run on a server which is more powerful than the local workstation. moreover,
genetic mining can be distributed in several ways [20]. for example, the pop-
45ulation can be partitioned over various nodes. each subpopulation on a node
evolves independently for some time after which the nodes exchange individu-
als. similarly, the event logs may be portioned over nodes thus speeding up the
tness calculations.
besides separating the functionality from the user interface, prom 6 requires
functionality to be provided in packages . these packages each contain a collec-
tion of related algorithms, typically implemented by one research group. when
prom is started for the rst time, the package manager is opened as shown
in figure 35. here, for each known package, prom shows who the author is,
what the current version is and whether or not this version is installed. the
work presented in this article, requires the following packages to be installed:
alphaminer ,transitionsystems andilpminer . the other packages shown are
automatically installed due to dependencies. furthermore, the package petrify
provides import and export functionality to and from the state-based region tool
petrify.
fig. 36. result of-miner: the -algorithm has problems dealing with the multiple
hotel bookings interleaved with other booking activities.
the event log opened in figure 33 is a log consisting of 1000 cases of a travel
agency. a customer registers, then purchases a bus ticket or a plane ticket while
at the same time he books one or more hotels. after the booking phase, the trip
costs are computed and the customer has to choose between two types of insur-
ance. after that, the total costs are calculated and the payment is completed.
this is a rather simple example used to show the results of the three algorithms.
the resulting petri net after applying the -algorithm to this log is shown
in figure 36. the result after executing the transition system miner is shown in
figure 37 and the result of the ilp miner is shown in 38. all three algorithms
provide a model that indeed models the given situation. the diculty here is the
fact that the hotel booking is executed one or more times. the -algorithm does
46fig. 37. result of ts miner. note that there are now two transitions referring to hotel
bookings (label splitting).
fig. 38. result of ilp miner. the model is able to replay the event log. however,
tokens may remain in the place following the hotel booking and bookings can take
place before the registration step.
47not connect this transition (thus enabling it continuously and destroying the
wf-net structure), while the transition system miner introduces two transitions
for this step, but it enforces that the second hotel can only be booked after the
bus or plane ticket is booked. the ilp miner allows for the hotel booking to
occur arbitrarily often, but at least once before the trip costs are calculated.
10 conclusion
process mining can be seen as the \missing link" between data mining and tradi-
tional model-driven bpm. the spectacular growth of event data is an important
enabler for process analysis based on real observations rather than hand-made
models only. we have applied prom in over 100 organizations ranging from mu-
nicipalities and hospitals to nancial institutions and manufacturers of high-tech
systems. this illustrates the applicability of the techniques described in this ar-
ticle.
process mining can be used to diagnose the actual processes. this is valu-
able because in many organizations most stakeholders lack a correct, objective,
and accurate view on important operational processes. however, process min-
ing is not limited to the process discovery techniques mentioned in this article
(see for example [2]). process mining can also be used to improve the discov-
ered processes. conformance checking can be used for auditing and compliance.
by replaying the event log on a process model it is possible to quantify and
visualize deviations. similar techniques can be used to detect bottlenecks and
build predictive models. given the applicability of process mining, we encour-
age the reader to simply apply the techniques discussed. the event data needed
to conduct such experiments can be found in any non-trivial organization. the
freely available open-source process mining tool prom can be downloaded from
www.processmining.org and supports all of the process mining techniques men-
tioned.
in this article we emphasized that four quality dimensions| tness ,simplic-
ity,precision , and generalization |need to be balanced [2]. moreover, we zoomed
in on region-based approaches. as shown, conventional state-based regions and
language-based regions focus on tness and precision, while neglecting simplicity
and generalization. fortunately, it is possible to modify these techniques to also
deal with the other two quality dimensions. state-based regions can be used for
process discovery tasks provided that the right abstraction is used when con-
structing the transition system. language-based regions can be mapped onto an
ilp problem where the target function and additional constraints are used to
obtain a simple and more general model.
despite the applicability of process mining there are many interesting chal-
lenges; these illustrate that process mining is a young discipline. as discussed,
it is far from trivial to construct a process model based on event logs that are
incomplete and noisy. unfortunately, there are still researchers and tool vendors
that assume logs to be complete and free of noise. although heuristic mining,
genetic mining, and fuzzy mining provide case-hardened process discovery tech-
48niques, many improvements are needed to construct truly intuitive models that
are able to explain the most likely/common behavior. another challenge is to
deal with ever-growing datasets, i.e., it is not uncommon to have event logs with
millions of cases, billions of events, and thousands of activities [44]. in some cases
it is impossible to store all events and process models need to be discovered on-
the-y. in other cases, there is a need to distribute process mining problems over
multiple computers. as discussed in [3] this can be done in various ways. there-
fore, there are many interesting problems for researchers with a background in
petri nets and eager to analyze processes based on real event data rather than
unrealistic toy models.
acknowledgments. the authors would like to thank all the people that con-
tributed to the development of prom (www.processmining.org).
references
1. w.m.p. van der aalst. the application of petri nets to workow management.
the journal of circuits, systems and computers , 8(1):21{66, 1998.
2. w.m.p. van der aalst. process mining: discovery, conformance and enhancement
of business processes . springer-verlag, berlin, 2011.
3. w.m.p. van der aalst. distributed process discovery and conformance checking.
in j. de lara and a. zisman, editors, international conference on fundamental
approaches to software engineering (fase 2012) , volume 7212 of lecture notes
in computer science , pages 1{25. springer-verlag, berlin, 2012.
4. w.m.p. van der aalst, a. adriansyah, and b. van dongen. replaying history
on process models for conformance checking and performance analysis. wires
data mining and knowledge discovery , 2(2):182{192, 2012.
5. w.m.p. van der aalst, b.f. van dongen, c.w. g unther, r.s. mans, a.k. alves
de medeiros, a. rozinat, v. rubin, m. song, h.m.w. verbeek, and a.j.m.m.
weijters. prom 4.0: comprehensive support for real process analysis. in j. kleijn
and a. yakovlev, editors, application and theory of petri nets and other models of
concurrency (icatpn 2007) , volume 4546 of lecture notes in computer science ,
pages 484{494. springer-verlag, berlin, 2007.
6. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
7. w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters, b.f. van dongen, a.k.
alves de medeiros, m. song, and h.m.w. verbeek. business process mining: an
industrial application. information systems , 32(5):713{732, 2007.
8. w.m.p. van der aalst, v. rubin, h.m.w. verbeek, b.f. van dongen, e. kindler,
and c.w. g unther. process mining: a two-step approach to balance between
undertting and overtting. software and systems modeling , 9(1):87{111, 2010.
9. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
10. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ow logs. in sixth international conference on extending database technology ,
49volume 1377 of lecture notes in computer science , pages 469{483. springer-
verlag, berlin, 1998.
11. w.m.p. van der aalst and. b. van dongen, c.w. g unther, a. rozinat, e. verbeek,
and t. weijters. prom: the process mining toolkit. in a.k.a. de medeiros and
b. weber, editors, business process management demonstration track (bpmde-
mos 2009) , volume 489 of ceur workshop proceedings , pages 1{4. ceur-ws.org,
2009.
12. d. angluin and c.h. smith. inductive inference: theory and methods. computing
surveys , 15(3):237{269, 1983.
13. e. badouel, l. bernardinello, and p. darondeau. the synthesis problem for ele-
mentary net systems is np-complete. theoretical computer science , 186(1-2):107{
134, 1997.
14. e. badouel, l. bernardinello, and ph. darondeau. polynomial algorithms for
the synthesis of bounded nets. in tapsoft , volume 915 of lecture notes in
computer science , pages 364{378. springer-verlag, berlin, 1995.
15. e. badouel and p. darondeau. theory of regions. in w. reisig and g. rozenberg,
editors, lectures on petri nets i: basic models , volume 1491 of lecture notes in
computer science , pages 529{586. springer-verlag, berlin, 1998.
16. r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on
regions of languages. in g. alonso, p. dadam, and m. rosemann, editors, inter-
national conference on business process management (bpm 2007) , volume 4714
oflecture notes in computer science , pages 375{383. springer-verlag, berlin,
2007.
17. r. bergenthum, j. desel, r. lorenz, and s. mauser. synthesis of petri nets from
innite partial languages. in international conference on application of concur-
rency to system design (acsd 2008) , pages 170{179. ieee computer society,
2008.
18. r. bergenthum, j. desel, r. lorenz, and s. mauser. synthesis of petri nets from
scenarios with viptool. in applications and theory of petri nets (petri nets
2008) , volume 5062 of lecture notes in computer science , pages 388{398. springer-
verlag, berlin, 2008.
19. r. bergenthum, j. desel, s. mauser, and r. lorenz. synthesis of petri nets from
term based representations of innite partial languages. fundamenta informat-
icae, 95(1):187{217, 2009.
20. c. bratosin, n. sidorova, and w.m.p. van der aalst. distributed genetic process
mining. in h. ishibuchi, editor, ieee world congress on computational intelli-
gence (wcci 2010) , pages 1951{1958, barcelona, spain, july 2010. ieee.
21. j. carmona, j. cortadella, and m. kishinevsky. a region-based algorithm
for discovering petri nets from event logs. in business process management
(bpm2008) , pages 358{373, 2008.
22. j. carmona, j. cortadella, and m. kishinevsky. genet: a tool for the synthesis
and mining of petri nets. in application of concurrency to system design (acsd
2009) , pages 181{185. ieee computer society, 2009.
23. j. carmona, j. cortadella, and m. kishinevsky. new region-based algorithms for
deriving bounded petri nets. ieee transactions on computers , 59(3):371{384,
2010.
24. j. carmona, j. cortadella, m. kishinevsky, a. kondratyev, l. lavagno, and
a. yakovlev. a symbolic algorithm for the synthesis of bounded petri nets.
inapplications and theory of petri nets (petri nets 2008) , pages 92{111, 2008.
5025. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
26. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. synthesizing petri
nets from state-based models. in proceedings of the 1995 ieee/acm interna-
tional conference on computer-aided design (iccad '95) , pages 164{171. ieee
computer society, 1995.
27. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets
from finite transition systems. ieee transactions on computers , 47(8):859{882,
august 1998.
28. ph. darondeau. deriving unbounded petri nets from formal languages. in
concur 1998 , volume 1466 of lecture notes in computer science . springer-
verlag, berlin, 1998.
29. a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275{301,
1998.
30. j. desel and w. reisig. the synthesis problem of petri nets. acta informatica ,
33(4):297{315, 1996.
31. b.f. van dongen. process mining and verication . phd thesis, eindhoven uni-
versity of technology, 2007.
32. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362{376. springer-verlag, berlin, 2004.
33. b.f. van dongen and w.m.p. van der aalst. multi-phase mining: aggregating
instances graphs into epcs and petri nets. in d. marinescu, editor, proceedings of
the second international workshop on applications of petri nets to coordination,
workow and business process management , pages 35{58. florida international
university, miami, florida, usa, 2005.
34. b.f. van dongen, a.k. alves de medeiros, and l. wenn. process mining: overview
and outlook of petri net discovery algorithms. in k. jensen and w.m.p. van
der aalst, editors, transactions on petri nets and other models of concurrency
ii, volume 5460 of lecture notes in computer science , pages 225{242. springer-
verlag, berlin, 2009.
35. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315{368, 1989.
36. r.j. van glabbeek and w.p. weijland. branching time and abstraction in bisim-
ulation semantics. journal of the acm , 43(3):555{600, 1996.
37. e.m. gold. language identication in the limit. information and control ,
10(5):447{474, 1967.
38. e.m. gold. complexity of automaton identication from given data. information
and control , 37(3):302{320, 1978.
39. c.w. g unther and w.m.p. van der aalst. fuzzy mining: adaptive process sim-
plication based on multi-perspective metrics. in g. alonso, p. dadam, and
m. rosemann, editors, international conference on business process management
(bpm 2007) , volume 4714 of lecture notes in computer science , pages 328{343.
springer-verlag, berlin, 2007.
40. j. herbst. a machine learning approach to workow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183{194. springer-verlag, berlin, 2000.
5141. ieee task force on process mining. process mining manifesto. in f. daniel,
k. barkaoui, and s. dustdar, editors, business process management workshops ,
volume 99 of lecture notes in business information processing , pages 169{194.
springer-verlag, berlin, 2012.
42. r. lorenz. towards synthesis of petri nets from general partial languages. in
german workshop on algorithms and tools for petri nets, (awpn 2008) , volume
380 of ceur workshop proceedings , pages 55{62. ceur-ws.org, 2008.
43. r. lorenz and g. juh as. how to synthesize nets from languages: a survey. in
s.g. henderson, b. biller, m. hsieh, j. shortle, j. d. tew, and r. r. barton,
editors, proceedings of the wintersimulation conference (wsc 2007) , pages 637{
647. ieee computer society, 2007.
44. j. manyika, m. chui, b. brown, j. bughin, r. dobbs, c. roxburgh, and a. by-
ers. big data: the next frontier for innovation, competition, and productivity.
mckinsey global institute, 2011.
45. s. mauser and r. lorenz. variants of the language based synthesis problem for
petri nets. in international conference on application of concurrency to system
design (acsd 2009) , pages 89{98. ieee computer society, 2009.
46. a.k. alves de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science , pages
389{406. springer-verlag, berlin, 2003.
47. a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245{304, 2007.
48. j. munoz-gama and j. carmona. enhancing precision in process conformance:
stability, condence and severity. in n. chawla, i. king, and a. sperduti, editors,
ieee symposium on computational intelligence and data mining (cidm 2011) ,
paris, france, april 2011. ieee.
49. l. pitt. inductive inference, dfas, and computational complexity. in k.p. jan-
tke, editor, proceedings of international workshop on analogical and inductive
inference (aii) , volume 397 of lecture notes in computer science , pages 18{44.
springer-verlag, berlin, 1989.
50. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
51. a. rozinat and w.m.p. van der aalst. conformance checking of processes based
on monitoring real behavior. information systems , 33(1):64{95, 2008.
52. a. schrijver. theory of linear and integer programming . wiley-interscience, 1986.
53. m. sol e and j. carmona. process mining from a basis of state regions. in
applications and theory of petri nets (petri nets 2010) , volume 6128 of lecture
notes in computer science , pages 226{245. springer-verlag, berlin, 2010.
54. m. sol e and j. carmona. rbminer: a tool for discovering petri nets from transition
systems. in a. bouajjani and wei-ngan chin, editors, automated technology for
verication and analysis (atva 2010) , volume 6252 of lecture notes in computer
science , pages 396{402. springer-verlag, berlin, 2010.
55. h.m.w. verbeek, t. basten, and w.m.p. van der aalst. diagnosing workow
processes using woan. the computer journal , 44(4):246{279, 2001.
56. h.m.w. verbeek, j.c.a.m. buijs, b.f. van dongen, and w.m.p. van der aalst.
prom 6: the process mining toolkit. in m. la rosa, editor, proc. of bpm demon-
stration track 2010 , volume 615 of ceur workshop proceedings , pages 34{39,
2010.
5257. h.m.w. verbeek, j.c.a.m. buijs, b.f. van dongen, and w.m.p. van der aalst.
xes, xesame, and prom 6. in p. soer and e. proper, editors, information
systems evolution , volume 72 of lecture notes in business information processing ,
pages 60{75. springer-verlag, berlin, 2010.
58. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151{162, 2003.
59. l. wen, w.m.p. van der aalst, j. wang, and j. sun. mining process models with
non-free-choice constructs. data mining and knowledge discovery , 15(2):145{
180, 2007.
60. j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. fundamenta informaticae ,
94:387{412, 2010.
53