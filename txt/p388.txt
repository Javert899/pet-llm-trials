finding structure in unstructured processes: the case for process mining
(invited paper)
w.m.p. van der aalst and c.w. g ¨unther
eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands
{w.m.p.v.d.aalst,c.w.gunther }@tue.nl
abstract
today there are many process mining techniques that al-
low for the automatic construction of process models based
on event logs. unlike synthesis techniques (e.g., based onregions), process mining aims at the discovery of models
(e.g., petri nets) from incomplete information (i.e., only ex-
ample behavior is given). the more mature process miningtechniques perform well on structured processes. however,
most of the existing techniques fail miserably when con-
fronted with unstructured processes. this paper attemptsto “bring structure to the unstructured” by using an in-
tegrated combination of abstraction and clustering tech-
niques. the ultimate goal is to present process models thatare understandable by analysts and that lead to improved
system/process redesigns.
1. introduction
the international conference on application of concur-
rency to system design (acsd) serves as a “forum for dis-seminating theoretical results with application potential and
advanced methods and tools for the design of complex con-
current systems”. hence most contributions are focusingon methods to better design a wide range of concurrent sys-
tems. this paper takes a different perspective. the goal is
not to design a new system but to analyze a system that isbeing used in a particular context . the main idea is that it
is only possible to come to an improved system design if
there is a good understanding of the existing design and its
actual use.
process mining has emerged as a way to analyze systems
and their actual use based on the event logs they produce
[3, 4, 5, 7, 10, 13, 17, 20, 22]. note that, unlike classi-cal data mining, the focus of process mining is on concur-
rent processes and not on static or mainly sequential struc-
tures. also note that commercial “business intelligence”(bi) tools are not doing any process mining. they typi-
cally look at aggregate data seen from an external perspec-
tive (frequencies, averages, utilization, service levels, etc.).
unlike bi tools, process mining looks “inside the process”
(what are the causal dependencies?, where is the bottle-
neck?, etc.) and at a very reﬁned level. in the context of ahospital, bi tools focus on performance indicators such as
the number of knee operations, the length of waiting lists,
and the success rate of surgery. process mining is more con-cerned with the paths followed by individual patients and
whether certain procedures are followed or not.
process mining always starts with event logs . events
logs may originate from all kinds of systems ranging
from enterprise information systems to embedded systems.process mining is a very broad area both in terms of (1)
applications (from hospitals and banks to embedded sys-
tems in cars, copiers, and sensor networks) and (2) tech-niques. this paper will focus on the discovery of processes
as a particular process mining technique. an example is the
α-algorithm [4] which automatically constructs a petri net
based on a set of observed system traces. process discovery
is related to the synthesis problem addressed by techniques
such as the “theory of regions” [6, 8, 16]. however, it isimportant to realize that process mining is also very differ-
ent since synthesis techniques typically assume a complete
description of the behavior . this is not the case for process
mining. in reality one only observes a fraction of all possi-
ble traces. therefore, a model that is only able to reproducethe log is useless!
process mining techniques work well on structured
processes with little exceptional behavior and strong causal
dependencies between the steps in the process. how-
ever, the most interesting logs are much more difﬁcultto mine. note that unstructured processes are typically
difﬁcult to manage while having a big potential for im-
provement. therefore our aim is to “ﬁnd structure in un-
structured processes” . for this purpose we use the “map
metaphor” . just like processes are visualized using graphs
(e.g., petri nets), (road) maps visualize some spatial reality.maps are highly evolved human artifacts for planning and
way-ﬁnding which are heavily using abstraction (leaving
out details, e.g., minor towns and roads) and clustering (ag-
gregating entities, e.g. a city represented as “blob” hidingdetails inside). maps abstract and cluster away unneeded
details to allow humans to recognize and correctly interpret
complex information. our goal is to apply such ideas tothe complex “spaghetti-like” process models discovered us-
ing process mining. this paper presents some of our initial
ideas. these ideas have been implemented in prom [14].
prom is an open-source plug-able framework that provides
a wide range of process mining techniques.
the remainder of this invited paper is structured as fol-
lows. first we provide an overview of process mining
(section 2) and discuss some typical process discovery ap-proaches (section 3). in section 3 we also stress the dif-
ferences between process mining and synthesis. section 4
shows the problems encountered when mining unstructuredprocesses. motivated by these problems, we propose a so-
lution approach in section 5. section 6 concludes the paper.
2. process mining: a short overview
process mining is applicable to a wide range of sys-
tems. these systems may be pure information systems (e.g.,
erp systems) or systems where the hardware plays a more
prominent role (e.g., embedded systems). the only require-
ment is that the system produces event logs , thus recording
(parts of) the actual behavior.
an interesting class of information systems that produce
event logs are the so-called process-aware information sys-
tems (paiss) [15]. examples are classical workﬂow man-
agement systems (e.g. staffware), erp systems (e.g. sap),
case handling systems (e.g. flower), pdm systems (e.g.windchill), crm systems (e.g. microsoft dynamics crm),
middleware (e.g., ibm’s websphere), hospital information
systems (e.g., chipsoft), etc. these systems provide very
detailed information about the activities that have been ex-
ecuted.
however, not only paiss are recording events. also em-
bedded systems increasingly log events. an embedded sys-
tem is a special-purpose system in which the computer iscompletely encapsulated by or dedicated to the device or
system it controls. examples are medical systems (e.g., x-
ray machines), mobile phones, car entertainment systems,
production systems (e.g., wafer steppers), copiers, sensor
networks, etc. software plays an increasingly importantrole in such systems and, already today, many of these
systems record events. an example is the “customer-
care remote services network” of philips medical sys-tems (pms). this is a worldwide internet-based private net-
work that links pms equipment to remote service centers.
an event that occurs within an x-ray machine (e.g., mov-ing the table, setting the deﬂector, etc.) is recorded and an-
alyzed. another example is the event logging infrastructure
developed by asml. asml manufactures chip-making
equipment such as wafer scanners. its products are alsoconnected to the internet. this connection is used to dis-
tribute the events logged. already during the testing phase
of a wafer scanner in the factory, thousands of events arerecorded via an internet connection. this can be used for
improving the service, improving the products, and for im-
proving the test processes. the logging capabilities of themachines of pms and asml illustrate the way in which
embedded systems produce event logs.
the goal of process mining is to extract information
(e.g., process models) from these logs, i.e., process min-
ing describes a family of a-posteriori analysis techniques
exploiting the information recorded in the event logs. typi-cally, these approaches assume that it is possible to sequen-
tially record events such that each event refers to an activity
(i.e., a well-deﬁned step in the process) and is related to aparticular case (i.e., a process instance). furthermore, some
mining techniques use additional information such as the
performer or originator of the event (i.e., the person / re-source executing or initiating the activity), the timestamp of
the event, or data elements recorded with the event (e.g., the
size of an order).
process mining addresses the problem that most
“process/system owners” have limited information about
what is actually happening. in practice, there is often a
signiﬁcant gap between what is prescribed or supposed to
happen, and what actually happens. only a concise assess-
ment of reality, which process mining strives to deliver, canhelp in verifying process models, and ultimately be used in
system or process redesign efforts.
models
analyzesrecords
events, e.g., 
messages,
transactions,
etc.specifies
configures
implements
analyzessupports/
controls
people machines
organizationscomponentsbusiness processes
figure 1. three types of process mining: (1)discovery, (2) conformance, and (3) exten-
sion.the idea of process mining is to discover, monitor and
improve real processes (i.e., not assumed processes) by ex-
tracting knowledge from event logs. we consider three ba-
sic types of process mining (figure 1):
•discovery : there is no a-priori model, i.e., based on
an event log some model is constructed. for example,using the α-algorithm [4] a process model can be dis-
covered based on low-level events.
•conformance : there is an a-priori model. this model
is used to check if reality conforms to the model. for
example, there may be a process model indicating that
purchase orders of more than one million euro require
two checks. another example is the checking of thefour-eyes principle. conformance checking may be
used to detect deviations, to locate and explain these
deviations, and to measure the severity of these devia-tions.
•extension : there is an a-priori model. this model is
extended with a new aspect or perspective, i.e., the goal
is not to check conformance but to enrich the model
with the data in the event log. an example is the ex-tension of a process model with performance data, i.e.,
some a-priori process model is used on which bottle-
necks are projected.
traditionally, process mining has been focusing on dis-
covery , i.e., deriving information about the original process
model, the organizational context, and execution properties
from enactment logs. an example of a technique address-ing the control ﬂow perspective is the α-algorithm, which
constructs a petri net model [11, 19] describing the behav-
ior observed in the event log. however, process mining isnot limited to process models (i.e., control ﬂow) and re-
cent process mining techniques are more and more focusing
on other perspectives, e.g., the organizational perspective orthe data perspective. for example, there are approaches to
extract social networks from event logs and analyze them
using social network analysis [1]. this allows organizationsto monitor how people, groups, or software/system compo-
nents are working together.
conformance checking compares an a-priori model with
the observed behavior as recorded in the log. in [20] it is
shown how a process model (e.g., a petri net) can be eval-
uated in the context of a log using metrics such as “ﬁtness”
(is the observed behavior possible according to the model?)
and “appropriateness” (is the model “typical” for the ob-served behavior?). however, it is also possible to check
conformance based on organizational models, predeﬁned
business rules, temporal formulas, quality of service (qos)deﬁnitions, etc.
there are different ways to extend a given process model
with additional perspectives based on event logs, e.g., deci-sion mining, performance analysis, and user proﬁling. de-
cision mining, also referred to as decision point analysis,
aims at the detection of data dependencies that affect the
routing of a case [21]. starting from a process model, onecan analyze how data attributes inﬂuence the choices made
in the process based on past process executions. classical
data mining techniques such as decision trees can be lever-aged for this purpose. similarly, the process model can be
extended with timing information (e.g., bottleneck analy-
sis).
at this point in time there are mature tools such as the
prom framework [14], featuring an extensive set of analy-sis techniques which can be applied to real-life logs while
supporting the whole spectrum depicted in figure 1.
3. process discovery with prom
in this paper, we focus on control-ﬂow discovery , i.e.,
based on some event log we try to discover a process model
(e.g., a petri net) characterizing the behavior recorded in thelog. mxml, the format used by prom [14], allows for the
logging of a wealth of information. however, for this paper
we limit ourselves to the basic information present in anyevent log.
letabe a set of activity names. for every process in-
stance (often referred to as case), a sequence of activities
is recorded. such a sequence of activities is called a trace .
note that there may be different process instances that havethe same trace. a
∗is the set of all possible traces given
a set of activities a.a n event log is a set of process in-
stances. since only the corresponding traces are of interesthere, an event log lis described by a bag (i.e., a multi-set)
of traces. in other words: l∈a
∗→i n, i.e., for any possi-
bleσ∈a∗,l(σ)denotes the number of process instances
having a sequence of activities σ.
as an example consider the process of handling cus-
tomer orders. an example of a trace would be (register,
ship, send bill, payment, accounting, approved, close) .
this trace represents a sequence of 7 activities. torepresent the log we use more convenient (i.e., shorter)
names: r=register ,s=ship ,sb=send
bill,p=payment ,
ac=accounting ,ap=approved ,c=close . moreover,
there are additional activities such as em=express mail,
rj=rejected , and rs=resolve . using this shorter notation we
now consider a log lwhere each of the following traces
occurs once (r ,s,sb,p,ac,ap,c ),(r,sb,em,p,ac,ap,c ),
(r ,sb,p,em,ac,rj,rs,c ), (r,em,sb,p,ac,ap,c ),
(r ,sb,s,p,ac,rj,rs,c ), (r ,sb,p,s,ac,ap,c ), and
(r ,sb,p,em,ac,ap,c ). it is easy to imagine that such
traces could be extracted from the logs of some informationsystem (e.g., a sap r/3 system). it should be noted that
all traces start with r(register order) and end with c(close
order). moreover, some of the other activities also appearfigure 2. a petri net discovered by prom using the α-algorithm.
in all traces, e.g., sb(send bill), p(payment), and ac
(accounting). in all traces either s(ship) or em(express
mail) occurs. if ap(approved) occurs in this small set of
traces, then rj(rejected) and rs(resolve) do not occur
(and vice versa). note that for the human eye it is difﬁcult
to make these conclusions and construct a process model
that corresponds to the behavior recorded in event log l.
therefore, many process discovery algorithms have beenproposed to automatically construct process models (e.g., a
petri net) [3, 4, 5, 7, 10, 13, 17, 22].
prom implements about 20 different process discovery
algorithms. since a complete review of the different algo-rithms is outside the scope of this paper, we limit ourselves
to showing some examples. figure 2 shows a petri net dis-
covered using the α-algorithm [4], i.e., based on the event
logla model is constructed automatically. it is easy to see
that the traces in the log can indeed be reproduced by this
petri net. note that the α-algorithm “discovers” choices
and concurrency. although the example does not contain
any loops, the α-algorithm can also discover iterations. the
α-algorithm is rather sensitive to noise and exceptional be-
havior and has problems handling more advanced control-
ﬂow patterns. figure 3 shows two alternative techniques
that are more robust. the multi-phase miner always pro-duces a model that can replay the log [13]. it uses event-
driven process chains (epcs) as a default representation as
shown on the left-hand-side of figure 3. however, the epcs
can be converted in other formats such as various types of
petri nets, yawl models, bpel speciﬁcations, etc. thedrawback of the technique used by the multi-phase miner is
that it has a tendency to over-generalize, i.e., sometimes the
model allows for too much behavior. the model shown onthe right-hand-side of figure 3 is produced by the heuristics
miner [22]. the heuristics miner represents processes in a
notation dedicated to process mining. however, its resultscan be converted to other notations. the heuristics miner
specializes in dealing with noise and exceptional situations.
it is not necessary to understand the three discovered
figure 3. two process models discovered
using the multi-phase miner (left) and theheuristics miner (right).models shown in ﬁgures 2 and 3. however, it is important
to note that there are various process mining algorithms that
perform well on structured processes. prom offers a wide
variety of process discovery techniques. using prom thediscovered models can be converted to the desired format
(petri nets, epcs, etc.).
in the next section, we will show that process discov-
ery is not easy for large unstructured processes. however,
before doing so we would like to discuss the link between
process mining and synthesis . synthesis methods try to ex-
tract a precise model from a transition system or a set of
behaviors (traces or partial orders). a well-known exam-
ple is the “theory of regions” [16, 12, 8] which attempts
to convert a transition system into a petri net model. theﬁrst papers on the theory of regions only dealt with a spe-
cial class of transition systems called elementary transition
systems. the class of elementary transition systems is veryrestricted. in practice, most of the time, people deal with
arbitrary transition systems that only by coincidence fall
into the class of elementary transition systems. however,several researchers (e.g., cortadella et al. [8]) have worked
on generalizations. the approach presented in [8] uses la-
beled petri nets, i.e., different transitions can refer to thesame event. for this approach it has been shown that the
reachability graph of the synthesized petri net is bisimilar to
the initial transition system. other synthesis methods havebeen described in literature, e.g., in [18] some ﬁrst steps
are made towards solving the petri net synthesis problem
for non-sequential speciﬁcations (also known as scenarios,
runs, labeled partial orders, or pomsets) and in [9] the limits
of the “theory of regions” are explored. these synthe-sis approaches seem related to process mining. however,
because they attempt to produce a model that exactly corre-
sponds to the given behavior (e.g., in terms of a transitionsystem, set of traces, or regular expression), they tend to
“overﬁt”.
to illustrate the “overﬁtting” of region-based
approaches, consider the log ldescribed before.
let us make an alternative log l
/primewhere the trace
(r ,sb,s,p,ac,rj,rs,c )is replaced by (r ,sb,s,p,ac,ap,c ).
prom offers two mining plug-ins based on regions. the
ﬁrst plug-in incrementally builds regions while parsing thelog. the second plug-in ﬁrst builds a transition system and
then uses petrify to construct a petri net [2]. when using
the default settings, both region-based plug-ins produce
a result similar to the three discovered models shown in
figures 2 and 3. the approach described in [2] offersdozens of strategies to build transition systems to balance
between “overﬁtting” (too speciﬁc) and “underﬁtting” (too
general). using the default settings, the correspondingplug-in represents each state as the set of activities that
already have taken place. based on this state representation,
it is easy to construct a transition system and then use theapproach presented in [8] to synthesize a labeled petri net.
if we apply this to the initial log ( l), we obtain the net
shown in figure 2 (i.e., the result is identical to the net
generated by the α-algorithm [4]). however, if we apply
the region-based plug-in to l
/prime, the result is quite different
as shown in figure 4. the discovered model assumes that
all shipped orders will be approved and never rejected,i.e., the occurrence of s(ship) implies the occurrence of
ap(approved) and excludes rj(rejected) and rs(resolve).
this happens to be the case in this particular set of traces(l
/prime). however, it shows how sensitive the approach is
to the occurrence of combinations of events. the three
algorithms described earlier, i.e., the αminer [4] (figure 2),
the multi-phase miner [13] (left-hand-side of figure 3), and
the heuristics miner [22] (right-hand-side of figure 3), allproduce the original model for l
/primeshowing that they are
less sensitive to the occurrence of combinations of events.
the examples show that there is delicate balance be-
tween “overﬁtting” and “underﬁtting”. region-based ap-
proaches tend to consider everything that did not occur in
the log as “negative examples”, i.e., if the exact behav-
ior did not happen in a particular log, it will never hap-
pen. therefore, these approaches need to be adapted asdescribed in [2]. however, even for these adapted region-
based approaches [2] and dedicated process mining tech-
niques [3, 4, 5, 7, 10, 13, 17, 22], the discovery of real-lifeprocesses remains a challenge, as shown in the next section.
4. the process spaghetti problem
the fundamental idea of process mining is both simple
and persuasive: there is a process which is unknown to us,
but we can follow the traces of its behavior, i.e. we have
access to enactment logs. feeding those into a process min-ing technique will yield an aggregate description of that ob-
served behavior, e.g. in form of a process model.
in the beginning of process mining research, mostly ar-
tiﬁcially generated logs were used to develop and verify
mining algorithms. then, also logs from real-life workﬂowmanagement systems, e.g. staffware, could be successfully
mined with these techniques. early mining algorithms had
high requirements towards the qualities of log ﬁles, e.g. theywere supposed to be complete and limited to events of in-
terest. yet, most of the resulting problems could be easily
remedied with more data, ﬁltering the log and tuning thealgorithm to better cope with problematic data.
while these successes were certainly convincing, most
real-life processes are not executed within rigid, inﬂexible
workﬂow management systems and the like, which enforce
correct, predictive behavior. it is the inherent inﬂexibilityof these systems which drove the majority of process own-
ers (i.e., organizations having the need to support processes)
to choose more ﬂexible or ad-hoc solutions. concepts likefigure 4. a petri net discovered by prom using the region-based approach described in [2].
adaptive workﬂow or case handling either allow users
to change the process at runtime, or deﬁne processes in
a somewhat more “loose” manner which does not strictly
deﬁne a speciﬁc path of execution. yet the most popu-lar solutions for supporting processes do not enforce any
deﬁned behavior at all, but merely offer functionality like
sharing data and passing messages between users and re-sources. examples for these systems are erp (enterprise
resource planning) and cscw (computer-supported co-
operative work) systems, custom-built solutions, or plain
e-mail.
it is obvious that executing a process within such less
restrictive environments will lead to more diverse and less-
structured behavior . this abundance of observed behav-
ior, however, unveiled a fundamental weakness in most of
the early process mining algorithms. when these are used
to mine logs from less-structured processes, the result is
usually just as unstructured and hard to understand. these
“spaghetti” process models do not provide any meaningfulabstraction from the event logs themselves, and are there-
fore useless to process analysts. it is important to note that
these “spaghetti” models are not incorrect. the problemis that the processes themselves are really “spaghetti-like”,
i.e., the model is an accurate reﬂection of reality.
an example of such a “spaghetti” model is given in fig-
ure 5. this ﬁgure shows only a small excerpt (ca. 25%) of ahighly unstructured process model. it has been mined from
machine test logs using the heuristics miner, one of the tra-
ditional process mining techniques which is most resilienttowards noise in logs [22]. although this result is rather use-
ful, certainly in comparison with other early process mining
techniques, it is plain to see that deriving helpful informa-tion from it is not easy.
event classes found in the log are interpreted as activ-
ity nodes in the process model. their sheer amount makes
it difﬁcult to focus on the interesting parts of the process.the abundance of arcs in the model, which constitute the
actual “spaghetti”, introduce an even greater challenge for
interpretation. separating cause from effect, or the generalmart
(complete)
211 0.984
 149
srmb
(complete)
21 0.9
 17
gism
(complete)
434 0.947
 32
zttr
(complete)
10 0.5
 7capc
(complete)
113 0.78
 50
tsdm
(complete)
295
emwc
(complete)
763
 0.667
 30 0.998
 577
swzd
(complete)
29 0.667
 7
xyoa
(complete)
38 0.5
 5
czca
(complete)
38 0.833
 7wztd
(complete)
189 0.923
 50
dihw
(complete)
339xymg
(complete)
20 0.75
 27
 0.859
 80wgtd
(complete)
196 0.886
 75
swap
(complete)
137 0.952
 106
srmc
(complete)
80 0.75
 14
ztri
(complete)
19 0.5
 4
swip
(complete)
1 0.5
 1clpl
(complete)
832 0.994
 522
elln
(complete)
280 0.914
 60 0.925
 64
wtaf
(complete)
196 0.88
 65
swpp
(complete)
14 0.5
 4
 0.916
 102swlh
(complete)
5 0.5
 2
 0.988
 140
elge
(complete)
251 0.817
 68ella
(complete)
199 0.761
 55
elql
(complete)
145 0.941
 17
 0.889
 22 0.836
 84
 0.988
 107
 0.857
 37caso
(complete)
834 0.998
 671
emwa
(complete)
681 0.667
 56cawq
(complete)
638 0.964
 102
 0.997
 507
cabf
(complete)
288 0.78
 81
catd
(complete)
81 0.857
 19 0.994
 203
 0.95
 44 0.938
 41 0.979
 55
 0.971
 42
 0.917
 19giws
(complete)
104 0.909
 38
 0.915
 63 0.917
 18 0.986
 140
 0.936
 42
 0.912
 61 0.99
 93
bmwz
(complete)
302 0.875
 33
 0.941
 32 0.75
 23xykt
(complete)
163
 0.944
 22
srap
(complete)
20 0.769
 14 0.929
 70
ditd
(complete)
220 0.984
 112 0.856
 104 0.992
 208 0.992
 175
bmis
(complete)
885 0.938
 109
swic
(complete)
379 0.944
 18 0.938
 77
 0.997
 631
 0.875
 69emta
(complete)
14 0.833
 7
szfo
(complete)
69 0.889
 26
xyvg
(complete)
46 0.923
 18
foce
(complete)
176 0.929
 25dirg
(complete)
517 0.909
 29
dire
(complete)
1297 0.999
 1107
 0.667
 28lusd
(complete)
410 0.8
 32 0.929
 46foqe
(complete)
104
lupi
(complete)
5768 1
 5388
xyqz
(complete)
52 0.667
 19
xykm
(complete)
566 0.667
 84
 0.933
 137
 0.923
 84elad
(complete)
12 0.5
 7wctm
(complete)
6 0.5
 4
pisv
(complete)
3 0.5
 3emzf
(complete)
10 0.5
 10 0.8
 21
 0.75
 5 0.991
 164
tsda
(complete)
121 0.57
 108
emco
(complete)
21 0.8
 8 0.5
 1
0.833
 47 0.5
 1
foee
(complete)
9 0.5
 2
xynm
(complete)
599 0.941
 37 0.933
 19
xyvm
(complete)
33 0.875
 27
xyvo
(complete)
30 0.821
 28
 0.875
 26
xywg
(complete)
479
 0.8
 92 0.997
 355
xyxt
(complete)
17 0.75
 10
xyug
(complete)
1 0.5
 1 0.8
 18
xywo
(complete)
81 0.958
 48
fggo
(complete)
23 0.75
 6
xyxo
(complete)
7 0.667
 5 0.857
 40 0.99
 121
hwts
(complete)
17 0.5
 5
 0.967
 57
wtaz
(complete)
120 0.833
 29grex
(complete)
49 0.909
 12
grrw
(complete)
47 0.893
 33
 0.977
 58
wtae
(complete)
102 0.784
 51
 0.667
 5 0.917
 17
wtar
(complete)
104 0.947
 80
wtam
(complete)
92 0.901
 83
lhie
(complete)
239 0.667
 8 0.857
 30
 0.857
 34
 0.979
 70
 0.909
 104 0.909
 20xydg
(complete)
215 0.974
 89xydm
(complete)
278
 0.885
 124
xyaz
(complete)
2 0.5
 1 0.978
 103
xydo
(complete)
125 0.885
 99
xyto
(complete)
52 0.889
 47
xyso
(complete)
26 0.957
 25
 0.929
 52 0.929
 26
 0.889
 20xydh
(complete)
49 0.9
 17
hdbr
(complete)
17 0.75
 5
 0.667
 13 0.909
 18q
(complete)
208
 0.889
 30 0.99
 155
xymm
(complete)
50 0.667
 6
xyqo
(complete)
23 0.667
 16
xyxm
(complete)
27 0.75
 4
xyia
(complete)
67 0.667
 27
 0.963
 37pigp
(complete)
414
 0.667
 18xynz
(complete)
194 0.986
 118
xyng
(complete)
273 0.815
 72
 0.5
 33 0.989
 200
xyez
(complete)
6 0.5
 6
xynt
(complete)
273
 0.923
 33 0.987
 190
foqz
(complete)
100 0.857
 25
lhvz
(complete)
3 0.5
 2
xyef
(complete)
53 0.667
 13 0.75
 12 0.833
 24
 0.8
 36 0.812
 26 0.981
 96
xyag
(complete)
9 0.5
 2
 0.966
 48
 0.833
 36hdbz
(complete)
19 0.5
 3
 0.8
 42 0.75
 11 0.996
 344
foqm
(complete)
168 0.8
 12
 0.996
 421
xyno
(complete)
100 0.723
 86
strs
(complete)
22 0.667
 9
 0.667
 38
lptm
(complete)
18 0.5
 6 0.667
 16 0.996
 469
xyko
(complete)
49 0.542
 46 0.667
 9 0.978
 119
 0.842
 30
xyem
(complete)
33 0.667
 2
 0.75
 42 0.938
 34
fpeq
(complete)
52 0.929
 40 0.929
 11
lpta
(complete)
45 0.8
 18
xyuo
(complete)
2 0.5
 1 0.941
 24xyam
(complete)
40 0.857
 4
lptr
(complete)
215
 0.875
 17 0.989
 140
lpcd
(complete)
5 0.75
 5
 0.667
 39
 0.667
 10xymz
(complete)
1 0.5
 1
xymt
(complete)
23 0.667
 7 0.973
 37
xymo
(complete)
12 0.857
 8
xyat
(complete)
28 0.889
 12
 0.667
 21
xyao
(complete)
12 0.889
 12
 0.5
 3
fpfs
(complete)
3 0.5
 1
lhvr
(complete)
1 0.5
 1
 0.5
 1 0.667
 10
swad
(complete)
119 0.963
 75
srad
(complete)
26 0.75
 11
swva
(complete)
151 0.8
 14wzwm
(complete)
252 0.667
 13
race
(complete)
3 0.5
 1
 0.995
 356
emrs
(complete)
183 0.917
 49 0.917
 14
 0.988
 117 0.987
 129 0.8
 29 0.991
 219 0.993
 319
swxa
(complete)
91 0.73
 51
 0.75
 5 0.941
 37
bmck
(complete)
942 0.952
 36
 0.8
 21 0.997
 889
lpts
(complete)
85 0.667
 12
pifv
(complete)
3 0.5
 1 0.667
 30 0.5
 4
pipc
(complete)
112 0.977
 75pini
(complete)
40
 0.909
 34
pisn
(complete)
3 0.4
 3
ping
(complete)
13pizp
(complete)
124
 0.9
 11 0.889
 8
piss
(complete)
107 0.857
 17pipd
(complete)
26 0.667
 5
 0.667
 23 0.982
 81 0.985
 95
pinz
(complete)
13 0.875
 9
pias
(complete)
1 0.5
 1 0.889
 42
 0.998
 613 0.5
 3
pins
(complete)
16
 0.667
 8 0.8
 6
 0.5
 3 0.75
 12
 0.8
 12 0.933
 163
 0.991
 232 0.824
 37
 0.923
 134 0.667
 57 0.998
 46096
6
fode
(complete)
144 0.986
 88fodm
(complete)
155
 0.7
 55 0.923
 15
xydt
(complete)
35 0.676
 33 0.933
 30
xyxg
(complete)
28 0.75
 8
 0.923
 18 0.75
 25
 0.5
 3 0.5
 6 0.833
 6
 0.982
 96
fodz
(complete)
80 0.792
 50
 0.909
 26
fpdm
(complete)
54 0.827
 47
 0.947
 41
fpsq
(complete)
17 0.5
 7 0.978
 216
 0.625
 12
 0.95
 29
 0.917
 10
lptn
(complete)
4 0.667
 4 0.421
 15
 0.5
 5 0.857
 5
 0.923
 25
 0.5
 2
 0.5
 11 0.444
 5
 0.5
 1 0.125
 9
 0.75
 4 0.917
 12
 0.667
 15 0.968
 38 0.667
 16
 0.985
 69
 0.167
 3 0.5
 1 0.5
 1
 0.5
 1 0.5
 4 0.933
 12
 0.5
 1
 0.667
 3 0.5
 3
 0.5
 2 0.5
 9
 0.952
 13
 0.5
 4 0.5
 10
 0.5
 6 0.833
 1
 0.952
 30
 0.5
 1 0.941
 19
 0.974
 72
elqa
(complete)
178 0.809
 53
 0.99
 123
elqs
(complete)
151 0.836
 50
elqr
(complete)
141
 0.962
 15 0.987
 110 0.986
 101
elqd
(complete)
45 0.963
 27
emaz
(complete)
2 0.5
 2
 0.7
 27 0.917
 18
 0.5
 2 0.5
 4
fofe
(complete)
2 0.667
 2
 0.667
 2 0.5
 2 0.5
 1
 0.667
 5
figure 5. excerpt of a typical “spaghetti”
process model (ca. 25% of complete model).
direction in which the process is executed, is not possible
because virtually every node is transitively connected to any
other node in both directions. this mirrors the crux of ﬂexi-bility in process execution – when people are free to execute
anything in any given order they will usually make use of
such feature, which renders monitoring business activitiesan essentially infeasible task.
we argue that the fault for these problems lies neither
with less-structured processes, nor with process mining it-
self. rather, it is the result of a number of, mostly implicit,assumptions which process mining has historically made,
both with respect to the event logs under consideration
and regarding the processes which have generated them.while being perfectly sound in structured, controlled envi-
ronments, these assumptions do not hold in less-structured,
real-life environments and thus ultimately make traditionalprocess mining fail there.
assumption 1: all logs are reliable and trustworthy .
any event type found in the log is assumed to havea corresponding logical activity in the process. how-
ever, activities in real-life processes may raise a ran-
dom number of seemingly unrelated events. activitiesmay also go unrecorded, while other events do not cor-
respond to any activity at all.
the assumption that logs are well-formed and homo-geneous is also often not true. for example, a process
found in the log is assumed to correspond to one log-
ical entity. in less-structured environments, however,there are often a number of “tacit” process types which
are executed, and thus logged, under the same name.
also, the idea that all events are raised on the same
level of abstraction, and are thus equally important, is
not true in real-life settings. events on different levelsare “ﬂattened” into the same event log, while there is
also a high amount of informational events (e.g., de-
bug messages from the system) which need to be dis-regarded.
assumption 2: there exists an exact process which is
reﬂected in the logs . this assumption implies that
there is the one perfect solution out there, which needs
to be found. consequently, the mining result should
model the process completely ,accurately , and pre-
cisely . however, as stated before, spaghetti models
are not necessarily incorrect – the models look like
spaghetti, because they precisely describe every de-tail of the less-structured behavior found in the log.
a more high-level solution, which is able to abstract
from details, would thus be preferable.traditional mining algorithms have also been conﬁned
to a single perspective (e.g., control ﬂow, data), as
such isolated view is supposed to yield higher preci-sion. however, perspectives are interacting in less-
structured processes, e.g. the data ﬂow may comple-
ment the control ﬂow, and thus also needs to be takeninto account.
in general, the assumption of a perfect solution is not
well-suited for real-life application. reality often dif-
fers signiﬁcantly from theory, in ways that had not
been anticipated. consequently, useful tools for prac-tical application must be explorative , i.e. support the
analyst to tweak results and thus capitalize on their
knowledge.
we have conducted process mining case studies in orga-
nizations like philips medical systems, uwv , rijkswater-staat, the catharina hospital eindhoven and the amc hos-
pital amsterdam, and various dutch municipalities. our
experiences in these case studies have shown the above as-sumptions to be violated in all ways imaginable. there-
fore, to make process mining a useful tool in practical, less-
structured settings, these assumptions need to be discarded.
the next section outlines a novel mining approach whichtakes these lessons into account.
5. bringing structure to the unstructured
process mining techniques which are suitable for less-
structured environments need to be able to provide a high-
level view on the process, abstracting from undesired de-
tails. the ﬁeld of cartography has always been faced witha quite similar challenge, namely to simplify highly com-
plex and unstructured topologies. activities in a process
can be related to locations in a topology (e.g., towns or roadcrossings) and precedence relations to trafﬁc connections
between them (e.g., railways or motorways).
insigni ﬁcant roads
are not shown.abstractionparts of the city are merged.aggregation
focuses on theintended use.customizationhighways are highlighted by size, contrast and color.emphasis
figure 6. example of a road map.
when one takes a closer look at maps (such as the exam-
ple in figure 6), the solution cartography has come up with
to simplify and present complex topologies, one can derive
a number of valuable concepts from them.
aggregation: to limit the number of information items
displayed, maps often show coherent clusters of low-
level detail information in an aggregated manner. one
example are cities in road maps, where particular
houses and streets are combined within the city’s tran-
sitive closure (e.g., the city of eindhoven in figure 6).
abstraction: lower-level information which is insigniﬁ-
cant in the chosen context is simply omitted from the
visualization. examples are bicycle paths, which are
of no interest in a motorist’s map.
emphasis: more signiﬁcant information is highlighted by
visual means such as color ,contrast ,saturation , and
size. for example, maps emphasize more important
roads by displaying them as thicker, more colorful and
contrasting lines (e.g., motorway “e25” in figure 6).
customization: there is no one single map for the world.
maps are specialized on a deﬁned local context ,h a v e
a speciﬁc level of detail (city maps vs highway maps),and a dedicated purpose (interregional travel vs alpine
hiking).
these concepts are universal, well-understood, and es-
tablished. in this paper we explore how they can be used
to simplify and properly visualize complex, less-structuredprocesses. to do that, we need to develop appropriate de-
cision criteria on which to base the simpliﬁcation and visu-
alization of process models. we have identiﬁed two funda-
mental metrics which can support such decisions: (1) sig-
niﬁcance and (2) correlation .
signiﬁcance, which can be determined both for event
classes (i.e., activities) and binary precedence relations over
them (i.e., edges), measures the relative importance of be-
havior. as such, it speciﬁes the level of interest we have
in events, or their occurring after one another. one exam-
ple for measuring signiﬁcance is by frequency, i.e. eventsor precedence relations which are observed more frequently
are deemed more signiﬁcant.
correlation on the other hand is only relevant for prece-
dence relations over events. it measures how closely re-
lated two events following one another are. examples for
measuring correlation include determining the overlap ofdata attributes associated to two events following one an-
other, or comparing the similarity of their event names.
more closely correlated events are assumed to share a largeamount of their data, or have their similarity expressed
in their recorded names (e.g. “check
customer application”
and “approve customer application”).
based on these two metrics, we can sketch our approach
for process simpliﬁcation as follows.
•highly signiﬁcant behavior is preserved , i.e. contained
in the simpliﬁed model.
•less signiﬁcant buthighly correlated behavior is ag-
gregated , i.e. hidden in clusters within the simpliﬁed
model.
•less signiﬁcant andlowly correlated behavior is ab-
stracted from , i.e. removed from the simpliﬁed model.
this approach can greatly reduce and focus the displayed
behavior, by employing the concepts of aggregation and ab-
straction. based on such simpliﬁed model, we can employthe concept of emphasis , by highlighting more signiﬁcant
behavior.
figure 7 shows an excerpt from a simpliﬁed process
model, which has been created using our approach. bright
square nodes represent signiﬁcant activities, the darkeroctagonal node is an aggregated cluster of three less-
signiﬁcant activities. all nodes are labeled with their re-
spective signiﬁcance, with clusters displaying the mean sig-niﬁcance of their elements. the brightness of edges be-
tween nodes emphasizes their signiﬁcance, i.e. more sig-
niﬁcant relations are darker. edges are also labeled with
figure 7. excerpt of a simpliﬁed and deco-
rated process model.
their respective signiﬁcance and correlation values. by ei-
ther removing or hiding less signiﬁcant information, this vi-
sualization enables the user to focus on the most interesting
behavior in the process.
yet, the question of what constitutes “interesting” behav-
ior can have a number of answers, based on the process,
the purpose of analysis, or the desired level of abstraction.
in order to yield the most appropriate result, signiﬁcanceand correlation measures need to be conﬁgurable. we have
thus developed a set of metrics, which can each measure
signiﬁcance or correlation based on different perspectives
(e.g., control ﬂow or data) of the process. by inﬂuencing
the “mix” of these metrics and the simpliﬁcation procedureitself, the user can customize the produced results to a large
degree.
we have implemented our approach as the fuzzy miner
plugin for the prom framework [14]. figure 8 shows theresult view of the fuzzy miner, with the simpliﬁed graph
view on the left, and a conﬁguration pane for simpliﬁcation
parameters on the right. by setting a threshold value, theuser can determine how much behavior will be displayed
explicitly, i.e. how aggressively the process model will be
simpliﬁed.
note that this approach is the result of valuable lessons
learnt from a great number of case studies with real-life
logs. as such, both the applied metrics and the simpliﬁ-
cation algorithm have been optimized using large amounts
actual, less-structured data. while it is difﬁcult to validate
the approach formally, the fuzzy miner has already becomeone of the most useful tools in case study applications.
for example, figure 8 shows the result of applying the
fuzzy miner to a large test log of manufacturing machines
(155.296 events in 16 cases, 826 event classes). unlikefigure 8. screenshot of the fuzzy miner, applied to the very large and unstructured log also used for
mining the model in figure 5
tools
complete
0.4710.1390.667
papers
complete
0.4280.011
0.389
slides
complete
0.3940.0060.389
home
complete
1.0000.0070.4000.0200.389
0.3400.707
0.0080.389trac
complete
0.0600.0120.3330.0080.389
tutorial
complete
0.0020.3380.6670.0010.3750.0210.389
0.2860.6950.0240.402
nightly
complete
0.5820.0000.3810.0050.3330.4320.6930.0120.414
0.0150.389
0.0010.3750.0310.5090.0010.3811.0001.000tools
complete
0.4710.1390.667
papers
complete
0.4280.011
0.389
home
complete
1.0000.0070.4000.0200.389
0.3400.707
trac
complete
0.0600.0120.333
tutorial
complete
0.0020.3380.6670.0010.375slides
complete
0.3940.0210.389
0.2860.695
0.0240.402
nightly
complete
0.5820.0000.3810.0050.3330.4320.6930.0120.414
0.0010.3750.0310.509
0.0010.3811.0001.000tools
complete
0.4710.1390.667
papers
complete
0.4280.011
0.3890.0200.389
0.3400.707
slides
complete
0.3940.0080.3330.0210.389
0.2860.695
home
complete
1.0000.0240.402
nightly
complete
0.5820.0000.3810.0120.414
0.0310.509
0.0010.3811.0001.000tools
complete
0.4710.1390.667
papers
complete
0.4280.011
0.3890.0200.389
0.3400.707
cluster 10
2 primitives
~ 0.2270.0120.333
nightly
complete
0.582home
complete
1.000
0.0000.3810.0210.389
0.0240.4020.0120.414
0.0010.3810.0310.509
1.0001.000tools
complete
0.4710.1390.667
cluster 10
2 primitives
~ 0.2440.011
0.389
home
complete
1.0000.0070.400
nightly
complete
0.5820.0000.3810.0200.389
0.0080.3890.0120.414
0.0010.3810.0150.389
1.0001.000nightly
complete
0.582
home
complete
1.0000.0000.381
cluster 10
3 primitives
~ 0.3200.0080.4000.0010.381
0.0120.4141.000
1.000cluster 10
3 primitives
~ 0.320
home
complete
1.0000.0080.4000.0150.414
1.000
1.000
figure 9. progressive simpliﬁcation of a small, yet highly unstructured process model.
the excerpt shown in figure 5, figure 8 shows the whole
process (and not just an excerpt) and was obtained without
ﬁltering the log. it is obvious that our approach is able to
clean up a large amount of confusing behavior, and to infer
and extract structure from what is chaotic. we have suc-cessfully used the fuzzy miner on various machinery test
and usage logs, development process logs, hospital patient
treatment logs, logs from case handling systems and webservers, among others.
figure 9 shows a sequence of progressively aggressive
simpliﬁcations created by our approach. the example used
here is a web server access log, i.e. each process instance
is a user browsing through sections of our web site. the
leftmost process model is non-simpliﬁed, i.e. describes pre-cisely the behavior found in the log. by removing the least
signiﬁcant edges between nodes, our approach already in-
fers a coarse structure in the ﬁrst simpliﬁed model. theremaining steps visualize the gradual simpliﬁcation of the
model, by removing and clustering activity nodes, down to
only one non-simpliﬁed activity node.our approach abandons the fundamental assumptions of
traditional process mining introduced in section 4: we do
not assume the information recorded in event logs to be
ﬂawless and trustworthy, but rather employ a set of con-
ﬁgurable metrics . when tuned to a speciﬁc process and
analysis question, these metrics can correctly capture the
signiﬁcance andcorrelation of model elements. based on
this information, we have developed a method which cansimplify a process model. rather than assuming one per-
fect solution, this approach allows the user to interactively
explore the process and ﬁnd an appropriate visualization .
explorative and interactive tools like the fuzzy miner
perfectly complement the set of traditional mining algo-rithms. once a suitable approximate process model has
been found, it is much easier to ﬁlter the information in a
log so that it reﬂects this model. using such ﬁltered logs,also more formal and exact methods may be applied, which
allow to e.g. analyze the correctness or conformance of the
process.6. conclusion
the message of this paper is twofold. first of all, it was
shown that classical synthesis approaches cannot be used
for process mining since they have a tendency to “overﬁt”
(i.e., if a combination of events did not happen in the log, it
is considered impossible). hence, dedicated process miningtechniques are needed that balance between “overﬁtting”
and “underﬁtting”. second, even the best process discov-
ery techniques tend to produce “spaghetti-like models” for
real-life processes . the reason is that these processes are
complicated and unstructured. therefore, we proposed a
technique which is able to simplify the models presentedto the user. comparable to the drawing of road maps we
useabstraction andclustering to produce models that are
comprehensible.
the ideas presented in this paper have been realized in
the context of the open-source tool prom. prom provides awide range of process mining techniques and can be down-
loaded from www.processmining.org .
acknowledgements
this research is supported by eit, nwo-ew, the technol-ogy foundation stw, and the super project (fp6). more-
over, we would like to thank the many people involved in
the development of prom.
references
[1] w. van der aalst, h. reijers, and m. song. discovering so-
cial networks from event logs. computer supported co-
operative work , 14(6):549–593, 2005.
[2] w. van der aalst, v . rubin, b. dongen, e. kindler, and
c. g ¨unther. process mining: a two-step approach using
transition systems and regions. bpm center report bpm-06-30, bpmcenter.org, 2006.
[3] w. van der aalst, b. van dongen, j. herbst, l. maruster,
g. schimm, and a. weijters. workﬂow mining: a survey ofissues and approaches. data and knowledge engineering ,
47(2):237–267, 2003.
[4] w. van der aalst, a. weijters, and l. maruster. work-
ﬂow mining: discovering process models from event logs.
ieee transactions on knowledge and data engineering ,
16(9):1128–1142, 2004.
[5] r. agrawal, d. gunopulos, and f. leymann. mining
process models from workﬂow logs. in sixth international
conference on extending database technology , pages 469–
483, 1998.
[6] e. badouel, l. bernardinello, and p. darondeau. the syn-
thesis problem for elementary net systems is np-complete.
theoretical computer science , 186(1-2):107–134, 1997.
[7] j. cook and a. wolf. discovering models of software
processes from event-based data. acm transactions
on software engineering and methodology , 7(3):215–249,
1998.[8] j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev.
deriving petri nets from finite transition systems. ieee
transactions on computers , 47(8):859–882, aug. 1998.
[9] p. darondeau. unbounded petri net synthesis. in j. de-
sel, w. reisig, and g. rozenberg, editors, lectures on con-
currency and petri nets , volume 3098 of lecture notes in
computer science , pages 413–438. springer-verlag, berlin,
2004.
[10] a. datta. automating the discovery of as-is business
process models: probabilistic and algorithmic approaches.
information systems research , 9(3):275–301, 1998.
[11] j. desel and j. esparza. free choice petri nets ,v o l -
ume 40 of cambridge tracts in theoretical computer sci-
ence. cambridge university press, cambridge, uk, 1995.
[12] j. desel and w. reisig. the synthesis problem of petri nets.
acta informatica , 33(4):297–315, 1996.
[13] b. van dongen and w. van der aalst. multi-phase process
mining: building instance graphs. in p. atzeni, w. chu,
h. lu, s. zhou, and t. ling, editors, international con-
ference on conceptual modeling (er 2004) , volume 3288
oflecture notes in computer science , pages 362–376.
springer-verlag, berlin, 2004.
[14] b. van dongen, a. medeiros, h. verbeek, a. weijters, and
w. van der aalst. the prom framework: a new era in
process mining tool support. in g. ciardo and p. daron-deau, editors, application and theory of petri nets 2005 ,
volume 3536 of lecture notes in computer science , pages
444–454. springer-verlag, berlin, 2005.
[15] m. dumas, w. van der aalst, and a. ter hofstede. process-
aware information systems: bridging people and softwarethrough process technology . wiley & sons, 2005.
[16] a. ehrenfeucht and g. rozenberg. partial (set) 2-structures
- part 1 and part 2. acta informatica , 27(4):315–368, 1989.
[17] j. herbst. a machine learning approach to workﬂow man-
agement. in proceedings 11th european conference on ma-
chine learning , volume 1810 of lecture notes in computer
science , pages 183–194. springer-verlag, berlin, 2000.
[18] r. lorenz and g. juhas. towards synthesis of petri nets
from scenariose. in s. donatelli and p. thiagarajan, ed-
itors, application and theory of petri nets 2006 , volume
4024 of lecture notes in computer science , pages 302–321.
springer-verlag, berlin, 2006.
[19] w. reisig and g. rozenberg, editors. lectures on petri nets
i: basic models , volume 1491 of lecture notes in computer
science . springer-verlag, berlin, 1998.
[20] a. rozinat and w. van der aalst. conformance testing:
measuring the fit and appropriateness of event logs and
process models. in c. bussler et al., editor, bpm 2005
workshops (workshop on business process intelligence) ,
volume 3812 of lecture notes in computer science , pages
163–176. springer-verlag, berlin, 2006.
[21] a. rozinat and w. van der aalst. decision mining in prom.
in s. dustdar, j. faideiro, and a. sheth, editors, interna-
tional conference on business process management (bpm2006) , volume 4102 of lecture notes in computer science ,
pages 420–425. springer-verlag, berlin, 2006.
[22] a. weijters and w. van der aalst. rediscovering workﬂow
models from event-based data using little thumb. inte-
grated computer-aided engineering , 10(2):151–162, 2003.