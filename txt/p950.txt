generating event logs for high-level process models
mitsyuk, a.a.; shugurov, i.s.; kalenkova, a.a.; van der aalst, w.m.p.
published in:
simulation modelling practice and theory
doi:
10.1016/j.simpat.2017.01.003
published: 01/05/2017
document version
publisher’s pdf, also known as version of record (includes final page, issue and volume numbers)
please check the document version of this publication:
• a submitted manuscript is the author's version of the article upon submission and before peer-review. there can be important differences
between the submitted version and the official published version of record. people interested in the research are advised to contact the
author for the final version of the publication, or visit the doi to the publisher's website.
• the final author version and the galley proof are versions of the publication after peer review.
• the final published version features the final layout of the paper including the volume, issue and page numbers.
link to publication
citation for published version (apa):
mitsyuk, a. a., shugurov, i. s., kalenkova, a. a., & van der aalst, w. m. p. (2017). generating event logs for
high-level process models. simulation modelling practice and theory, 74, 1-16. doi:
10.1016/j.simpat.2017.01.003
general rights
copyright and moral rights for the publications made accessible in the public portal are retained by the authors and/or other copyright owners
and it is a condition of accessing publications that users recognise and abide by the legal requirements associated with these rights.
            • users may download and print one copy of any publication from the public portal for the purpose of private study or research.
            • you may not further distribute the material or use it for any profit-making activity or commercial gain
            • you may freely distribute the url identifying the publication in the public portal ?
take down policy
if you believe that this document breaches copyright please contact us providing details, and we will remove access to the work immediately
and investigate your claim.
download date: 14. jan. 2018simulation  modelling  practice and theory 74 (2017) 1–16 
contents  lists available  at sciencedirect  
simulation  modelling  practice  and theory  
journal  homepage:  www.elsevier.com/locate/simpat  
generating  event  logs for high-level  process  models  /p82 
alexey  a. mitsyuk  a , ivan s. shugurov  a , anna  a. kalenkova  a , ∗, wil m.p. van der 
aalst b , a 
a national research university  higher school of economics,  laboratory  of process-aware  information  systems, moscow, 1010 0 0, russia 
b eindhoven  university  of technology,  department  of mathematics  and computer  science, po box 513, nl-5600 mb eindhoven,  the 
netherlands  
a r t i c l e i n f o 
article history: 
received  20 may 2016 
revised 22 january 2017 
accepted  24 january 2017 
available  online 3 february  2017 
keywords:  
event log generation  
business  process simulation  
bpmn (business  process model and 
notation)  
process mining a b s t r a c t 
business  process model and notation  (bpmn)  is a de-facto  standard  for practitioners  work- 
ing in the business  process management  (bpm) ﬁeld. the bpmn standard  [1] offers high- 
level modeling  constructs,  such as subprocesses,  events, data and message  ﬂows, lanes, 
and is widely used to model processes  in various domains.  recently  several bpmn-based  
process mining techniques  [2, 3, 4] were introduced.  these techniques  allow represent-  
ing processes,  discovered  from the event logs of process-aware  information  systems,  in a 
convenient  way, using the bpmn standard.  to test these mining approaches  an appropri-  
ate tool for the generation  of event logs from bpmn models is needed.  in this work we 
suggest such a tool. we propose  a formal token-based  executable  bpmn semantics,  which 
takes into account  bpmn 2.0 with its expressive  constructs.  the developed  tool is based 
on these semantics  and allows simulation  of hierarchical  process models (including  mod- 
els with cancellations),  models with data ﬂows and pools, and models interacting  through  
message  ﬂows. to manage  the control ﬂow, script-based  gateways  and choice preferences  
are implemented  as well. the proposed  simulation  technique  was implemented  on top of 
existing  plug-ins  for prom (process  mining framework)  [5], and was veriﬁed  on models 
created by practitioners  from various domains.  
© 2017 elsevier b.v. all rights reserved.  
1. introduction  
bpmn (business  process  model and notation)  2.0 [1] is one of the most frequently  used process  modeling  notations  and 
is a de facto standard  in business  process  modeling.  petri nets are respected  in academia  due to their simplicity,  ability to 
express  concurrency,  clear semantics,  and mathematical  nature.  these notations  have good instrumental  support  and are 
widely used by both researchers  and practitioners.  
process  mining  [6] is a research  area which offers tools and methods  for analysing  and improving  processes  by looking  
at insights  hidden  in event logs of information  systems.  in addition  to petri nets, which remain  the most frequently  used 
modeling  notation  among  process  miners,  process  mining  results are increasingly  visualized  as bpmn models  [2–4] . 
most of process  mining  algorithms  require  an event log as an input parameter.  however,  in order to develop  and sys- 
tematically  evaluate  these algorithms  one requires  large sets of models  and corresponding  event logs. although  the goal of 
/p82 this work is supported  by the basic research  program at the national research  university  higher school of economics.  
∗corresponding  author. 
e-mail addresses:  amitsyuk@hse.ru  (a .a . mitsyuk),  shugurov94@gmail.com  (i.s. shugurov),  akalenkova@hse.ru  (a .a . kalenkova),  w.m.p.v.d.aalst@tue.nl  
(w.m.p. van der aalst). 
http://dx.doi.org/10.1016/j.simpat.2017.01.003  
1569-190x/© 2017 elsevier b.v. all rights reserved.  2 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
process  mining  is to analyze  real-life  event logs, they are often not suitable  for the veriﬁcation  of new algorithms  at early 
stages of the development.  the potential  problem  is to ﬁnd (or construct)  a log with particular  characteristics.  artiﬁcially  
generated  logs are needed  for better testing and evaluation  of the process  mining  algorithms.  the possible  evaluation  ap- 
proach  can be deﬁned  as follows.  first, one generates  an event log by simulating  the selected  process  model. second,  he or 
she applies  a novel process  discovery  algorithm  to this log. finally,  the discovered  model is compared  to the initial one. note 
that in real-life  event logs such a “ground  truth” is  often missing.  therefore,  it is important  to be able to generate  models  
and logs in a controlled  manner.  
our objective  is to design and implement  a concrete  approach  for the generation  of event logs by direct simulation  
of bpmn models.  we start by discussing  related  work ( section  2 ), and introducing  a running  example  ( section  3 ). the 
three main contributions  are described  in sections  4 –6 respectively.  in particular,  section  4 introduces  a formal bpmn 2.0 
semantics,  section  5 presents  event log generation  algorithms.  the reader can ﬁnd a description  of the tool implementing  
the proposed  algorithms  and its evaluation  in section  6 . 
2. related  work 
several  papers have been published  in the ﬁeld of artiﬁcial  event log generation  in the context  of process  mining.  in this 
section  we will take a look at existing  approaches  and tools. 
manual  generation  of logs with particular  characteristics  is the most naive way to test process  mining  algorithms.  how- 
ever, in some cases it is useful. for example,  during implementation  of a discovery  algorithm  one usually  has several  very 
simple samples  to evaluate  the code in very straightforward  situations.  manual  generation  has evident  limitations  and dis- 
advantages.  creating  several  larger sets of logs through  manual  generation  is extremely  tedious  and possibly  leads to many 
of mistakes.  usually,  it is also a very time-consuming  activity.  
an approach  for the generation  of artiﬁcial  event logs using cpn tools has been proposed  in [7] . cpn tools is a widely 
used colored  petri nets editor with powerful  simulation  and analysis  abilities.  the proposed  extension  for cpn tools provides  
an opportunity  to generate  random  logs based on a given petri net. the main diﬃculty  of the approach  is that it implies  
writing  scripts in the standard  ml language,  which leads to possible  problems  during tool adaptation  for a speciﬁc  task. cpn 
tools does not support  the simulation  of bpmn models  directly.  although  manual  approaches  for transformation  of bpmn 
subsets  to cpn were discussed  in [8,9] , there are no well-deﬁned  and implemented  algorithms  to perform  these transfor-  
mations.  thus, a lot of manual  work is needed  to simulate  bpmn models,  which includes  control-,  data-ﬂow,  messages,  and 
other bpmn-speciﬁc  concepts  using the colored  petri nets notation.  
yet another  way to simulate  bpmn models  is to follow a two-step  approach:  (1) transform  a bpmn model to a modeling  
formalism  called devs ( discrete  event system speciﬁcation  [10] ), (2) then simulate  devs model using one of the devs simu- 
lation tools [11] . different  implementations  of such an approach  are considered  in [12,13] . in these papers authors  present  
two software  tools for bpmn-to-devs  transformation.  another  bpmn-to-devs  transformation  is presented  in [14] . 
in comparison  to both these approaches,  our method  works without  an additional  transformation  step. we state that 
bpmn models  can be executed  directly.  moreover,  we present  a corresponding  semantics  for bpmn models  and a plug- 
in for prom framework  [5] , which implements  the proposed  approach.  since prom provides  integration  of various  process  
discovery  and log processing  plug-ins,  the direct simulation  based on the formal bpmn semantics  can be incorporated  with 
other process  mining  approaches  to automate  testing of bpmn discovery  methods.  
yet another  instrument  for event logs generation  is secsy tool [15] . the purpose  of this tool is to generate  artiﬁcial  event 
logs for testing algorithms  in the ﬁeld of security-oriented  information  systems  modeling.  the tool generates  an event log 
satisfying  the behavior  predeﬁned  by a given speciﬁcations.  however,  secsy mainly  focuses  on security-oriented  aspects  of 
information  systems.  
processes  logs generator  (plg, and its later version  plg2) is a highly conﬁgurable  toolbox  to produce  event data. 
plg [16,17] is a framework  for the generation  of artiﬁcial  business  process  models  in a form of dependency  graphs and 
event logs of their execution.  the authors  employ  context-free  grammars  to build process  models.  a similar  technique  for 
generating  structured  bpmn models  and event logs is used in [18] . these approaches  deal only with block-structured  process  
models.  
event logs generation  is also possible  using the well-known  bpmn engines  (activiti  1 , bizagi 2 , and others).  these frame- 
works are developed  to maintain  real-life  business  processes  using java or other technologies,  and can be extended  with log 
generation  functions.  unfortunately,  these engines  usually  have rather complex  architecture.  thus, it is hard to apply them 
in research.  moreover,  engines  usually  do not follow the bpmn standard  strictly.  for example,  the synchronization  of paral- 
lel branches  in activiti  (camunda)  differs from the speciﬁcation.  the current  version  of the bizagi engine can not simulate  
sub-processes  with cancellations  and is not an open source tool, thus, it can not be modiﬁed.  igrafx 3 is a set of solutions  
for process  management,  analysis,  and collaborative  process  design.  among  others it has a simulation  functionality.  the no- 
tation used in it is similar  to bpmn, but formal translation  rules are not presented.  the simulator  ﬁts the goals of statistical  
analysis,  but has no functions  for ﬂexible  event log generation.  
1 activiti bpm platform:  http://activiti.org/  . 
2 bizagi engine: http://www.bizagi.com/en/  . 
3 igrafx platform:  http://www.igrafx.com  . a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 3 
fig. 1. architectural  changes process. 
this paper focuses  on the generation  of event logs through  simulation.  there are also approaches  that aim to transform  
event data into simulation  models.  see [19] for example.  another  related  paper on mixing  simulation  with process  mining  
is [20] . characteristics  of generated  event logs were investigated  in [21,22] . authors  of [23] investigate  problems  of dealing  
with large model collections.  
the approach  (and software)  presented  in this paper is an extension  of the earlier one proposed  in [24] . the previous  
version  deals only with process  models  in the classical  petri net notation.  the new version  of the approach  presented  in 
this paper uses a well-deﬁned  subset of the bpmn standard  as a language  for process  models.  the user can generate  logs 
in a ﬂexible  manner  using any bpmn model containing  the main modeling  elements  (activities,  gateways,  cancellations,  
message  ﬂows, and nested processes).  one can ﬁne-tune  the experiment  by using a predeﬁned  process  model. another  
signiﬁcant  improvement  is a new portion  of data-ﬂow-oriented  features.  the user can specify  behavior  of each particular  
node connected  with data objects  by assigning  a script written  in python.  
in contrast  to the log generators  proposed  earlier,  our tool supports:  (1) generation  of event logs using (possibly  non- 
block-structured)  bpmn models  made by experts  in any modeling  tool; (2) cancellation  events and message  ﬂows; (3) data- 
driven gateways  with assigned  scripts;  (4) bpmn pools and lanes considered  as process  roles; (5) time. 
3. motivating  example  
let us consider  an example  of a high-level  process  model, which can be simulated  with the approach  proposed  in this 
paper. modern  best practices  in software  and system  engineering  assume  application  of well-deﬁned  development  and de- 
sign processes.  fig. 1 shows a model of a requirement  change  process.  
the model contains  two main pools related  to the actors (roles) involved  in the process:  customer  and architecture  team . 
during  an iteration  of the development  process  the customer  formulates  new requirements  and sends it to a company’s  
architecture  team via a message  ﬂow. we consider  only architects  and analysts  as architecture  team members  (they are rep- 
resented  as lanes ). firstly, the customer’s  request  is checked  by an analyst  in a nested process  called requirement  check . a 
formal list of changes  prepared  is moved to an architect.  the architect  proposes  architectural  changes  to satisfy new require-  
ments and estimates  time needed  to implement  them, which is stored in the duration  data object. the analyst  calculates  
the costs of an implementation,  and sends a special  proposal  for the customer  via message  ﬂow. if calculated  costs are very 
high or low to meet the business  rules of the developer  company,  the project  is rejected.  such a case can be modeled  using 
cancellation  end and intermediate  boundary  events . the customer  can accept or reject the proposal.  if the customer  accepts  
the proposal,  the analyst  approves  changes  , and updates  the total budget  of the project  via outgoing  data object called total 
budget . the architect  redesigns  architecture  and sends report to the customer  via message  ﬂow. then the customer  analyzes  
the results . the same analysis  is performed  in both reject cases. 
such high-level  models  are quite common  for the bpm ﬁeld. they have relatively  complex  structures  and use various  
bpmn elements.  automated  analysis  and discovery  of such models  can give useful insights.  while such discovery  algorithms  
are being actively  developed,  researchers  face the problem  of testing them. however,  as it was discussed  in section  2 , there 4 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
are no tools supporting  all modeling  elements  shown in fig. 1 in a ﬂexible  manner.  developing  such tools is the main 
motivation  for the work presented  in this paper. 
4. event logs and bpmn modeling  constructs  
this section  presents  event logs, bpmn modeling  constructs  and their semantics  underlying  the proposed  log generation  
algorithms.  bpmn offers a wide range of modeling  elements  but not all of them are frequently  employed  [25] . in contrast  
to other proposed  semantics  [26–28]  , in this paper we consider  key bpmn constructs  which cover the main workﬂow  per- 
spectives:  control,  resource,  and data. furthermore,  the time perspective  is considered  as well. the set of selected  modeling  
constructs  includes  elements  which can be mined using existing  process  discovery  algorithms  [2–4] , and those of high in- 
terest for process  miners  [6,29] . 
first, we introduce  multisets  used to deﬁne states of bpmn models  and event logs, in which one trace can appear  multi- 
ple times. multiset  b : a → n over set a contains  element  a ∈ a, b ( a ) times. a set of all multisets  over a is denoted  as b(a ) . 
we will consider  sets as a special  case of multisets,  where elements  can appear  0 or 1 times. 
function  f : x /notarrowright y is called a partial function  with domain  dom ( f ) ⊆x and range deﬁned  as rng(f) = { f(x ) | x ∈ dom (f) } ⊆y . 
if dom (f) = x, then f is a total function  . 
4.1. event logs 
event logs are used in almost all process  mining  approaches.  event logs show the behavior  (at least a part of it) of an 
information  system  being investigated.  this is the only way to touch real life for analysts.  
an event contains  a name and can be equipped  with additional  attributes  such as: resource,  timestamp,  and different  
data variables.  let us deﬁne some basic notions  which will be used in later deﬁnitions.  let u a be a set of possible  activity  
labels (event names),  u at t r , and u val be sets of possible  attributes  and values correspondingly  [30] . 
deﬁnition  1 (event log) . l = (e, t , act, attr) is an event log where:  
• e is a set of events,  
• t is a set of traces where each trace is a sequence  of events,  i.e., t ⊆e ∗, 
• act : e → u a is a function  which maps each event onto its corresponding  activity  (event name),  
• at t r : e → (u at t r /notarrowright u val ) is a function  which deﬁnes  event attributes  and their values. 
hence, an event log is a set of traces. a trace /angbracketleft e 1 , e 2 , . . . , e n /angbracketright ∈ t is a sequence  of e vents. each e vent e corresponds  to 
activity  act(e ) ∈ u a and has a set of attributes  dom(attr(e))  . one of the standard  attributes  is time , i.e., time ∈ dom(attr(e))  
and attr(e)(time)  is the timestamp  of e . another  standard  attribute  is resource:  resource  ∈ dom(attr(e))  and attr(e)(resource)  is 
a name of the performer  of e . attributes  are also used to record the values of data objects,  such attributes  have names of 
corresponding  data objects.  note that in this paper we assume  each event appear  only once in the event log. 
4.2. base bpmn modeling  constructs  
a typical model of a process  control  ﬂow contains  activities,  start/end  events,  routing  elements,  and connections  between  
them. we also add a resource  perspective  which speciﬁes  performers  of the activities.  usually  resources  are represented  as 
bpmn lanes. 
according  to the bpmn 2.0 standard  activities,  which represent  elementary  steps of the process,  are called tasks. so- 
called gateways  and sequence  ﬂows are used to connect  activities  and to express  different  types of control-ﬂow  routing  
concepts.  formally,  we deﬁne a base bpmn model as follows.  
deﬁnition  2 (base bpmn model)  . a base bpmn model is a tuple: (n, a, g xor , g and , e start , e end , e cancel , sf , ef ,λa ,r, res ) , where 
• n is a set of ﬂow nodes, 
• a, g xor , g and , { e start } , e end form a partition  of n , 
• a ⊆n is a set of activities,  
• g xor ⊆n, g and ⊆nare sets of exclusive  and parallel  gateways  respectively,  
• e start ∈ n, e end ⊆n, e cancel ⊆e end , such that e end \ e cancel /negationslash = ∅ are a start event, a set of end events,  and a set of cancellation  
end events respectively,  
• sf ⊆n ×nis a set of sequence  ﬂows, ef ⊆sf ∩ (a ×n) is a set of exceptional  ﬂows, such that ∀ a ∈ a ∃ n ∈ n : (a, n ) ∈ 
sf , (a, n ) / ∈ ef , i.e., each activity  has a non-exceptional  outgoing  sequence  ﬂow, 
• λa : a → u a is a labeling  function,  
• r is a set of resources,  res : a /notarrowright r is a partial function  which maps some of the activities  onto set of resources.  
this deﬁnition  is based on the deﬁnition  of labeled  bpmn model from [3] . note, that the bpmn 2.0 standard  [1] describes  
more gateway  and event types. in particular,  there are the following  gateway  and intermediate  event types: complex,  inclu- 
sive, event-based,  parallel  event-based  gateways;  message,  timer, link, signal, multi, error, escalation  and other events.  we 
do not consider  these elements  in our base bpmn model. there are two reasons  for that. first, our token-based  semantics  a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 5 
fig. 2. a fragment  with cancellation.  
is supported  by gateways  with local dependencies,  i.e., the enablement  of a gateway  depends  only on its ingoing  ﬂows. 
this is the case for the gateway  types we consider.  second,  many of the interrupting  events behaviorally  correspond  to the 
cancellation  event descried  in this work. in the future we plan to extend the set of supported  bpmn elements.  
an example  of a base bpmn model is shown in fig. 2 . this is a fragment  of the example  process  shown in fig. 1 . the 
fragment  describes  a cost calculation  for a particular  proposal.  depending  on the cost, a proposal  can be either sent to the 
customer,  or canceled.  
the start event e start is an event without  any incoming  sequence  ﬂows. end events e end are events without  any outgoing  
sequence  ﬂows. all events are shown as circles.  end events are represented  by circles with bold borders.  cancellation  events 
are marked  with an additional  “x” sign.  
a marking  of a bpmn model denotes  a current  state of a process  instance.  it is a multiset  over the set of sequence  ﬂows, 
denoted  as m : sf → n . that is, each sequence  ﬂow may contain  tokens or not. a token in some sequence  ﬂow shows, that 
the source activity  (or gateway)  of this sequence  ﬂow is already  ﬁred, whereas  the target activity  (gateway)  may ﬁre, if all 
other incoming  ﬂows for it also carry tokens.  a marking  shows a snapshot  of the process  instance  execution  at a particular  
moment  in time. an initial marking  is a marking  such that m (sf) = 1 , if sf is an outgoing  sequence  ﬂow of e start , m (sf) = 0 
otherwise.  final marking  is a marking  such that ∀ sf ∈ sf : m (sf) = 0 . each node may be enabled,  then an enabled  node may 
ﬁre. 
an activity  is depicted  as a rounded  rectangle  and denotes  some visible action, which occurs in a business  process.  the 
fragment  shown in fig. 2 contains  two activities  “calculate  cost’’ and “send proposal”.  the ﬁrst activity  is performed  in 
all process  instances,  whereas  the branch  with the latter one can be cancelled.  an activity  a ∈ a is said to be in enabled  
state in marking  m if at least one of its incoming  sequence  ﬂows holds at least one token. an enabled  activity  a may ﬁre. 
when activity  a ﬁres it consumes  one token from an incoming  sequence  ﬂow and produces  a token for each outgoing  not 
exceptional  sequence  ﬂow. 
gateways  of two types (parallel  and exclusive)  are needed  to redirect  control  ﬂow during process  runs. exclusive  gateways  
(shown  as diamonds  with an “x” sign)  merge alternative  paths: incoming  sequence  ﬂow token is routed to one of the 
outgoing  sequence  ﬂows. a parallel  gateway  (modeled  as a diamond  with a plus sign) is enabled  if each incoming  sequence  
ﬂow contains  at least one token. an enabled  parallel  gateway  may ﬁre, consuming  a token from each incoming  sequence  
ﬂow and producing  a token to each outgoing  sequence  ﬂow. the reader can see an exclusive  gateway  in fig. 2 . 
an end event is enabled  if one of its incoming  sequence  ﬂows contains  a token. when an ordinary  end event ﬁres, it 
consumes  a token from an incoming  sequence  ﬂow, while a cancellation  end event consumes  all the existing  tokens,  yielding  
an empty marking.  
process  resources  are modeled  with lanes . the reader can see in fig. 1 , that the process  of the architecture  team is 
performed  by two following  roles: “analyst” and “architect”.  the lanes are separated with a solid line and  placed in a single  
bpmn pool . 
4.3. hierarchical  bpmn models 
bpmn supports  hierarchy,  i.e., a process  can contain  sub-processes.  sub-processes  can be presented  as base bpmn mod- 
els. 
fig. 3 shows a fragment  of the architectural  changes  process  model (see fig. 1 ) with sub-process  “calculate  cost”. sub- 
process  is an expanded  activity  of the base model, which contains  a nested model. first, the atomic  activity  “calculate  cost”
is performed.  after its completion  either the prepared  proposal  is sent to the customer,  or the proposal  is canceled.  note 
that a sub-process  can be either ﬁnished  successfully  by reaching  an end event, or canceled.  the choice is made by the 
exclusive  gateway.  this situation  is modeled  using a cancellation  event. the outgoing  exceptional  ﬂow is marked  with a 
boundary  intermediate  cancellation  event. 
let us introduce  a formal deﬁnition  for hierarchical  models.  
deﬁnition  3 (hierarchical  bpmn model)  . a hierarchical  bpmn model is a tuple: bpmn h = ( bpmn models , bpmn root , h, ref , 
cancel) , where 
• bpmn models = { bpmn 1 , ... , bpmn m } is a set of base bpmn models  4 , 
4 let a = a 1 ∪ . . . ∪ a m , ef = ef 1 ∪ . . . ∪ ef m , and e cancel =e cancel 1 ∪ . . . ∪ e cancel m , where a 1 , ... , a m , ef 1 , ... , ef m , and e cancel 1 , ... , e cancel m are sets of activities,  
exceptional  ﬂows, and cancellation  events of base models bpmn 1 , ... , bpmn m respectively.  6 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
fig. 3. a fragment  with sub-process.  
• h ⊆bpmn models \ { bpmn root } ×bpmn models is a tree relation,  which speciﬁes  a parent for each bpmn model, where 
bpmn root is a root of this tree, 
• ref : a /notarrowright bpmn models \ { bpmn root } , such that ( bpmn child , bpmn parent ) ∈ hiff∃ a ∈ a parent : ref (a ) = bpmn child , where a parent is 
a set of bpmn parent activities,  i.e. ref speciﬁes  the link between  activities  in a parent model and child models,  there is an 
activity  for each child model, 
• cancel : e cancel → ef is a bijective function,  such that it maps cancellation end events  ofbpmn child to exceptional sequence  
ﬂows of bpmn parent for each pair ( bpmn child , bpmn parent ) ∈ h. 
consider  a hierarchical  bpmn model bpmn h = ( bpmn models , bpmn root , h, ref , cancel) . we say that activities,  for which ref 
function  is not deﬁned,  are atomic activities  . all other activities  are non-atomic  . a set of nested process  models for a model 
bpmn parent ∈ bpmn models is deﬁned  as { bpmn nested ∈ bpmn models | ( bpmn nested , bpmn parent ) ∈ h ∗} , where h ∗is a transitive  clo- 
sure of h . 
suppose  that e start is a start event of model bpmn root . then an initial marking  m of bpmn h is deﬁned  as follows:  ∀ sf ∈ sf : 
m ( sf ) = 1 , if sf is an outgoing  sequence  ﬂow of e start , and m ( sf ) = 0 , otherwise.  
firing rules of hierarchical  bpmn models  extend the ﬁring rules of base bpmn models  in a part of enabling  and ﬁr- 
ing non-atomic  activities.  suppose  that a is a non-atomic  activity  of a base model bpmn parent ∈ bpmn models , then exists 
bpmn child ∈ bpmn models , such that ref (a ) = bpmn child . activity  a can ﬁre if and only if bpmn child and its nested models  do 
not contain  any tokens.  when activity  a ﬁres it consumes  a token from an incoming  sequence  ﬂow and produces  tokens to 
outgoing  sequence  ﬂows of bpmn child start event. 
if bpmn child reaches  the ﬁnal marking  and a cancellation  end event n of bpmn child is the cause of termination,  then a 
token will be added to ef –a n exceptional  sequence  ﬂow of bpmn parent , such that cancel(n ) = ef , and all the tokens will 
be removed  from sequence  ﬂows of nested models.  otherwise,  if bpmn child and its nested models  reach the ﬁnal markings,  
then tokens will be added to outgoing  not exceptional  sequence  ﬂows of a . 
the bpmn notation  contains  a wide range of event constructs,  the semantics  of which involves  cancellation.  these could 
be error, signal, cancel, and other types of events.  in this paper we combine  all of them together  conceptually  as one type 
called cancel events.  
4.4. bpmn models with data 
in this subsection  we will enrich bpmn models  with data objects  and data associations.  fig. 4 shows a fragment  of 
architectural  changes  process  model (see fig. 1 ) with the data object “cost”. data associations  are shown as dashed  arrows.  
the model contains  an explicit  choice between  acceptance  and rejection  of an architectural  changes  proposal,  prepared  by 
the architecture  team as a result of analysis  of customer’s  needs. then it was received  by the customer  (“receive  proposal”
fig. 4. a fragment  with data object. a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 7 
fig. 5. a fragment  with participants.  
activity  in fig. 4 ). the choice is made in an exclusive  gateway,  basing on the results of the analysis  performed  earlier.  
these results stored in data object “cost” shown  with a symbolic  sheet of paper. it has two following  data associations:  
write association  with activity  “receive  proposal” and  read association  with the exclusive  gateway.  thus, the cost of received  
proposal  is deﬁned  as a value of the data object after the ﬁring of “receive  proposal” activity.  if cost is not appropriate,  the 
gateway  activates  the “reject  proposal” branch.  in other case, the process  proceeds  with the “accept  proposal” activity.  
deﬁnition  4 (bpmn  model with data) . a bpmn model with data is a tuple bpmn data = ( bpmn h , do , da , f a , f sf , default , λd ) , 
where:  
• bpmn h is a hierarchical  bpmn model, where bpmn models = { bpmn 1 , . . . , bpmn m } is a set of base bpmn models  5 , 
• do = { do 1 , . . . , do k } is a set of data objects,  
• da ⊆(a ×do ) ∪ ( do ×a ) ∪ ( do ×g xor ) is a set of data associations,  
• f a : a → ((do → u val ) → (do → u val )) is a function  which speciﬁes  how activities  change  the values of data objects,  
• f sf : sf /prime → ((do → u val ) → { true, false } ) where sf /prime = { (g, n ) ∈ sf /prime | g ∈ g xor , n ∈ n} is a function,  which deﬁnes  condi- 
tional branching,  
• default : g xor → sf is a function  which speciﬁes  a default  outgoing  sequence  ﬂow sf ∈ sf for each exclusive  gateway  
g xor ∈ g xor , 
• λd : do → u attr is a function,  which maps each data object to its name. 
a marking  of a bpmn model with data is deﬁned  as a pair ( m, d ), where m : sf → n is a marking  of hierarchical  model 
bpmn h , and d : do → u val presents  values of data objects.  
bpmn models  with data extend ﬁring rules of hierarchical  bpmn models.  when an activity  a ∈ a ﬁres in a marking  ( m, 
d ) it deﬁnes  and sets new data object values:  d /prime = f a (a )(d) . firing of an exclusive  gateway  g xor in a marking  ( m, d ) results 
in producing  a token to one of the outgoing  sequence  ﬂows sf ∈ sf , for which f sf ( sf )(d) = true . if for all outgoing  sequence  
ﬂows sf holds that f sf ( sf )(d) = false, a token is added to the ﬂow default (g xor ) . 
4.5. interacting  bpmn models 
in this subsection  we will introduce  bpmn models,  which represent  different  participants,  interacting  through  message  
ﬂows. in fig. 5 the reader can see a fragment  of the architectural  changes  process  model (see fig. 1 ), in which new require-  
ments are sent as messages  from a customer  to the architecture  team. the message  ﬂow is shown as a dashed  line with 
a white arrow at the side of a message  receiver  (activity  “new requirement  request”)  and a white circle at the side of a 
sender (activity  “new requirement  formulated”).  
5 further we will use the following  notations:  n = n 1 ∪ . . . ∪ n m , a = a 1 ∪ . . . ∪ a m , g xor = g xor 1 ∪ . . . ∪ g xor m , sf = sf 1 ∪ . . . ∪ sf m , where n 1 , ... , n m , a 1 , 
... , a m , g xor 1 , ... , g xor m , sf 1 , ... , sf m are sets of nodes, activities,  exclusive  gateways  and sequence  ﬂows of models bpmn 1 , ... , bpmn m respectively.  8 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
each participant  is usually  visualized  as a pool within the entire bpmn model 6 . 
deﬁnition  5 (bpmn  model with participants)  . a bpmn model with participants  is a tuple bpmn part = ( bpmn p , mf ) , where 
• bpmn p = /braceleftbig
bpmn d 1 , . . . , bpmn d k /bracerightbig
is a set of bpmn models  with data, 
• mf ⊂(a ×a ) \ (a 1 ×a 1 ) \ . . . \ (a k ×a k ) 7 is a set of message  ﬂows. 
a marking  of a bpmn model with participants  bpmn part = ( bpmn p , mf ) can be represented  as (m 1 , ... , m k , m /prime ) , where 
m i is a marking  of bpmn d i model for i ∈ 1 , k , and m /prime ∈ ( mf → n ) . an initial marking  is represented  as (m 1 0 , ... , m k 0 , m 0 /prime ) , 
where m i 0 is an initial marking  of a corresponding  bpmn d i model. 
message  ﬂows extend the ﬁring rules of activities.  in addition  to the standard  enabling  conditions  presented  earlier,  
each incoming  message  ﬂow of an activity  must contain  at least one token to make this activity  enabled,  i.e., activity  “new 
requirement  request” in  fig. 5 will become  enabled  only when some request  will be sent from the customer.  when an 
activity  ﬁres, apart from the standard  operations  with tokens on sequence  ﬂows, it consumes  a token from each incoming  
message  ﬂow and produces  a token to each outgoing  message  ﬂow. 
bpmn pools and messages  allow to model and simulate  systems  with multiple  participants  working  in parallel  and can be 
synchronized  via message  ﬂows. this is the only modeling  element  allowed  to cross pool’s boundary.  note, that in fig. 1 the 
processes  of customer  and architecture  team have independent  starts and ends. message  ﬂows is the only mechanism  that 
binds them together.  
5. event log generation  
in this section  we present  our approach  for the generation  of event logs. we will consider  the different  types of bpmn 
models  described  earlier.  the remainder  of the section  is organized  as follows:  ﬁrst, an algorithm  for generating  event logs 
from base bpmn models  is described;  then each next section  explains  a speciﬁc  enhancement  of the algorithm.  
5.1. a basic approach  for event log generation  
this subsection  is devoted  to an algorithm  used for the simulation  of base bpmn models  as they are deﬁned  above. an 
event log corresponds  to deﬁnition  1 . recall that we assume  each event appear  one in the log. each trace corresponds  to 
an execution  of a single process  instance.  that is, all tokens in a model created  during generation  of one trace relate to the 
same instance  of a process  being simulated.  
algorithm  1 presents  a base simulation  approach.  during  a model execution  it constructs  a set of event logs, each of 
which consists  of traces. 
firing of an activity  leads to the creation  of an event with certain  attributes,  such as its name and resource.  if lanes 
are presented  in a model, they are used during the generation  in order to specify  resources  involved  in the execution  of 
activities.  
in algorithm  1 all events and gateways  are ﬁred ﬁrst, and only then activities  are executed.  before checking  whether  
activities  are enabled,  all possible  ﬁrings of gateways  are carried  out 8 . after that we have the entire set of activities  enabled  
at a particular  step of simulation.  thus, each of them can ﬁre with the equal probability.  due to the invisible  nature of gate- 
ways execution,  it is enough  to ﬁnd the ﬁrst enabled  gateway  and then it can be immediately  ﬁred. by invisible  nature we 
mean, that there are no records  in the event log corresponding  to the gateway  ﬁrings.  they are needed  for the control-ﬂow  
management  only. in contrast,  activities  require  more careful  handling.  first, all enabled  activities  are found and only then 
a random  one is ﬁred. outgoing  sequence  ﬂows of ﬁred exclusive  gateways  are selected  randomly  as well. therefore,  there 
are two stages in simulation.  first, all events and gateway  are ﬁred in an arbitrary  order until the only enabled  elements  
are activities.  second,  one of the enabled  activities  is selected  randomly  and ﬁred. this ensures  equal probability  of ﬁring 
of each enabled  activity  at each step. moreover,  the choice of one or another  process  model branch  is also made randomly  
( algorithm  2 ). 
the generation  of a trace terminates  when one of two situations  occur: (1) there are no more tokens in the model;  
(2) execution  exceeded  the speciﬁed  maximal  number  of ﬁrings.  in the former  case the replay ﬁnished  successfully  (process  
instance  is completed),  the generated  trace is added to the event log. in the latter case, the replay did not terminate  properly  
and the trace will not be added to the event log. 
forced termination  is supported  to deal with very large or live-locking  models.  
6 note that in contrast to lanes sequence  ﬂows cannot cross pools borders. 
7 a = a 1 ∪ . . . ∪ a k and a 1 , ... , a k are disjoint sets of all activities  of the base bpmn models, forming models bpmn d 1 , ... , bpmn d k respectively.  
8 note, that there can be a cyclic ﬁring of gateways.  in that case according  to algorithm  1 the log generation  process will be terminated  and the trace 
will not be added to a log. a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 9 
algorithm  1. a basic event logs generation.  
algorithm  2. algorithm  1 continued.  
5.2. generating  event logs for bpmn models with data 
in contrast  to the simulation  of hierarchical  and interacting  bpmn models,  which have additional  ﬁring rules and thus 
extend the basic log generation  algorithm  in a natural  way, simulation  of a bpmn model with data should be described  
separately.  
algorithm  3 extends  the basic algorithm  1 with a modiﬁed  procedure  of activity  execution:  each ﬁring of an activity  not 
only changes  the marking,  but assigns  novel values to data objects.  the values of data objects  are written  to the log in a 
form of event attributes.  10 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
algorithm  3 event generation  with data. 
input: activity a , bpmn data = ( bpmn h , do , da , f a , f sf , default , λd ) , (m, (( do 1 , val 1 ) , . . . , ( do n , val n ))) , l i = (e i , t i , act i , at t r i ) 
1: procedure  execute ( a , bpmn data , l i ) 
2: // λa , res , ref are functions  deﬁned by 
3: // bpmn models, which contain activity a 
4: m ← fi r e (a, m, bpmn data ) ; 
5: if ref (a ) is not deﬁned then 
6: e ← createe v ent() ; 
7: e i ← e i ∪ { e } ; 
8: t i ← t i + e ; 
9: act i ← act i ∪ { (e, λa (a )) } ; 
10: if res (a) is deﬁned for a then 
11: at t r i ← at t r i ∪ { (e, (resource , res (a )) } ; 
12: end if 
13: for do j ∈ do do 
14: at t r i ← at t r i ∪ { (e, (λd ( do ) , f a (a )(( do 1 , val 1 ) , . . . , ( do n , val n ))( do j )) } ; 
15: end for 
16: end if 
17: end procedure  
fig. 6. a model fragment  with an exclusive  gateway.  
additionally,  as it follows  from the deﬁnition  of bpmn models  with data, during the execution  of an exclusive  gateway,  
a token is added to one of the outgoing  sequence  ﬂows, for which the value of a special  assigned  function  is true . if the 
values of functions  for all outgoing  sequence  ﬂows are false , a token is added to the default outgoing  sequence  ﬂow. 
5.3. simulating  bpmn models with preferences  
in order to make simulation  more realistic  we introduce  a notion of so-called  preferences  , which is used to modify  the 
choice between  conﬂicting  activities.  for the bpmn language  that is the case when dealing  with exclusive  gateways.  
a typical scenario  is shown in fig. 6 , which is also a fragment  of fig. 1 . obviously,  in a real-life  setting,  rejections  and 
approvals  happen  with different  frequencies.  thus, sometimes  it seems rational  to set one activity  as more frequent  than 
the other when generating  an event log. for example,  one may want to simulate  the situation,  when almost all proposals  
are approved.  
a preference  is a non-negative  integer  value within some range. each preference  corresponds  to exactly  one outgoing  
sequence  ﬂow. the higher a preference  is, the higher possibility  to add a token to a certain  sequence  ﬂow is. the precise  
formula  for the probability  of a sequence  ﬂow to get a token is p (s j ) = pre f(s j ) 
/summationtext | osf | 
i =1 pre f(s i ) . where osf is a set of outgoing  sequence  
ﬂows from a speciﬁc  exclusive  gateway;  s i , s j ∈ osf are two outgoing  sequence  ﬂows, and pref(s) , s ∈ osf is a preference  of 
the particular  sequence  ﬂow s from the set osf . 
for the case shown in fig. 6 osf contains  two sequence  ﬂow to activities  “approve  changes” and  “proposal  rejected”.  for 
example,  one can set pre f(s appro vechanges  ) = 10 and pre f(s proposalre jected  ) = 1 . then, changes  will be approved  in most cases. 
note that it is possible  to completely  disallow  one or more outgoing  ﬂows in order to achieve  the desired  behavior.  
however,  it is ensured  that at least one outgoing  sequence  ﬂow has a non-zero  preference:  /summationtext | osf | 
i =1 pre f(s i ) > 0 . 
the algorithm  used for checking  whether  an exclusive  choice gateway  is enabled  remains  intact –w e only need to extend 
the way an outgoing  sequence  ﬂow is selected.  the pseudo  code is provided  in algorithm  4 . 
5.4. an approach  for generating  event logs with time 
in order to make simulation  more similar  to the way processes  are executed  in real life, where activities  take time to be 
performed,  a slight extension  of the notion of token is required.  a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 11 
algorithm  4 an outgoing  sequence  ﬂow selection.  
input: an exclusive  choice gateway g ∈ g xor output: an outgoing  sequence  ﬂow of g 
1: function  select ( g) 
2: //g•is a list of outgoing  sequence  ﬂows for g, 
3: if size( g•) = 1 then 
4: return g •[1] ; 
5: end if 
6: pre f arr ← /angbracketleft/angbracketright ; 
7: for i ← 1 up to size (g•) do 
8: if i = 1 then 
9: pre f arr ← pre f(g •[1]) ; 
10: else 
11: pre f arr ← pre f arr ∪ (pre f ar r [ i −1] + pre f(g •[ i ])) ; 
12: end if 
13: end for 
14: number ← random (1 , pre f ar r [ size (predar r −1)]) ; 
15: for i ← 1 up to size (g•) do 
16: if number ≤pre f ar r [ i ] then 
17: return g •[ i ] ; 
18: end if 
19: end for 
20: end function  
each token is associated  with a timestamp  which indicates  when the token was added to a sequence  ﬂow. we introduce  
a time function,  which returns  a timestamp  of a given token. given two tokens t 1 and t 2 we say that token t 1 is earlier 
than token t 2 or t 1 < t 2 , if time (t 1 ) < time (t 2 ) . likewise,  we say that token t 1 is later than token t 2 or t 1 > t 2 , if time (t 1 ) > 
time (t 2 ) . 
atomic activities  are the only elements  whose execution  times are deﬁned.  gateways  and events ﬁre instantly.  for a given 
atomic  activity  the function  starttime  returns  either a uniformly  distributed  value between  activity’s  minimal  and maximal  
execution  times or allows for introduction  of other distributions  in a ﬂexible  manner.  activities  in our approach  ﬁre without  
pauses in-between  them. this means that the duration  of the particular  instance  of an activity  in the particular  process  
instance  deﬁned  by the starting  time of the next activity  instance.  
see, for example,  the model shown in fig. 1 . activity  “adjust  requirement  changes” becomes  enabled  after the ﬁring 
of both activities  “propose  changes  of internal  functional  requirements” and  “propose  changes  of internal  non-functional  
requirements”.  the starting  time of the gateway  can be deﬁned  as the latest completion  time of the previous  activities.  the 
gateway  ﬁring takes no time. then, the starting  time of the activity  “adjust  requirement  changes” is  equal to the end time 
of the gateway  ﬁring. that is, the function  starttime  returns  for each activity  a start time, which is exactly  the end time of 
the previously  ﬁred elements.  
the ﬁring of activities  is accomplished  in two phases:  start of ﬁring and end of ﬁring. at the start stage of ﬁring a token 
with the earliest  timestamp  is removed  from one of the incoming  sequence  ﬂows and a token with the earliest  timestamp  
is consumed  from each incoming  message  ﬂow. the start time of ﬁring is equal to the largest timestamp  among  timestamps  
of the consumed  tokens ( algorithm  5 ). 
then, information  on the start of ﬁring ( at t r(e )(time ) = startt ime (a ) )i s written to  the log.  next step is  to log the end  
of ﬁring. to do it we determine  the time needed  for the activity  execution  by invoking  the starttime  function  and adding  
this value to the start time. then a token with the calculated  timestamp  is created  for each outgoing  sequence  ﬂow and 
information  on the activity  termination  is added to the log. 
during  an execution  of an enabled  exclusive  gateway,  the earliest  token is removed  from the incoming  sequence  ﬂows 
and placed to one of the outgoing  sequence  ﬂows without  alteration  of the timestamp.  when a parallel  gateway  ﬁres, the 
earliest  token is taken from each incoming  sequence  ﬂow and the latest among  them deﬁnes  a start of the ﬁring time. a 
token with this timestamp  is added to each outgoing  sequence  ﬂow. 
6. tool support  and evaluation  
6.1. event log generator  
the proposed  approach  was implemented  as a collection  of plug-ins  9 for the well-known  prom tool [5] . prom is an open- 
source framework  for the development  of process  mining  algorithms  in a standardized  environment.  we used an xml-based  
format xes [31] to represent  event logs. an event in xes is described  by a corresponding  activity  name, timestamp,  resource  
id, group id, and customizable  properties  (such as values of data variables).  
the basic log generator  implements  the main generation  functionality.  the user is asked (see fig. 7 ) to specify  (1) the 
number  of event logs to be generated,  (2) the number  of traces to be generated  for each event log, and (3) an upper bound 
9 available  at https://sourceforge.net/projects/gena-  log- generator/  . 12 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
algorithm  5 an activity  start time. 
input: an enabled activity a ∈ a output: start time of a 
1: function  starttime  ( a ) 
2: // function token returns the earliest token from the ﬂow 
3: // a token stored in one of the incoming  sequence  ﬂows of a ; 
4: token sf ; 
5: // a token stored in one of the incoming  message ﬂows of a 
6: token mf ; 
7: for all sf where sf is an incoming  sequence  ﬂow of a do 
8: if m ( sf ) > 0 then 
9: if token( sf ) < token sf then 
10: token sf ← token( sf ); 
11: end if 
12: end if 
13: end for 
14: for all mf where mf is an incoming  message ﬂow of a do 
15: if token ( mf ) > token mf then 
16: token mf ← token( mf ); 
17: end if 
18: end for 
19: if token sf < token mf then 
20: time a ← time ( token mf ); 
21: else 
22: time a ← time ( token sf ); 
23: end if 
24: return time a ; 
25: end function  
fig. 7. general settings. 
for the length of a trace (see section  5.1 ). using the extended  bpmn log generator  the user can easily conﬁgure  the behavior  
of an existing  model via conﬁguration  of exclusive  gateways.  it is also possible  to assign special  preferences  to gateways  as 
described  in section  5 . the time-aware  log generator  is responsible  for the generation  of event logs with timestamps.  the 
data-aware  generator  allows for using models  with explicit  data-ﬂows.  
the actual implementation  of data objects  extends  their deﬁnition  given in section  4 . to make simulation  more ﬂexible  
and conﬁgurable  user-written  python  scripts are supported.  there are three types of nodes which can be enriched  with 
scripts:  (1) data objects,  (2) activities  including  nested processes,  and (3) exclusive  choice gateways.  scripts can be used to 
initialize  data objects  and specify  actions  performed  with them during the node ﬁring. 
each node (of the three mentioned  types) can be associated  with of most one script. if a data object is not associated  
with any initializing  script, its default  value equals to an empty string. otherwise,  a script is called when a generation  of a 
trace starts. 
now let us demonstrate  how to generate  an event log for the model of architectural  changes  process  from section  3 (see 
fig. 1 ) using our tool. the maximal  number  of ﬁrings per trace was set to 200. we decided  to use data-aware  log gener- a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 13 
fig. 8. distribution  of traces. 
table 1 
a one-trace  fragment  of example generated  event log. 
trace event activity name group role timestamp  / data variables  
21 1 new requirement  formulated  customer  – 2016-02-24t22:02:24.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 2 wait for proposal  customer  – 2016-02-24t23:08:16.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 3 new requirements  request arch.team  analyst 2016-02-25t00:01:00.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 4 propose changes of internal non-func  reqs arch.team  analyst 2016-02-25t01:49:28.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 5 propose changes of internal func reqs arch.team  analyst 2016-02-25t01:55:24.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 6 adjust requirement  changes arch.team  analyst 2016-02-25t02:58:31.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 7 check requirements  changes arch.team  architect  2016-02-25t04:45:48.455  + 03:00 
[-;“functional  reqs”;-;-;-]  
21 8 propose architectural  changes arch.team  architect  2016-02-25t05:48:38.455  + 03:00 
[-;“functional  reqs”;203.37;-;-]  
21 9 calculate  cost arch.team  analyst 2016-02-25t07:01:46.455  + 03:00 
[-;“func.reqs”;203.37;426.75;-]  
21 10 send proposal  arch.team  analyst 2016-02-25t08:04:16.455  + 03:00 
[-;“func.reqs”;203.37;426.75;-]  
21 11 receive proposal  customer  – 2016-02-25t09:33:47.455  + 03:00 
[14.1;“func.reqs”;203.37;426.75;-]  
21 12 reject proposal  customer  – 2016-02-25t11:25:35.455  + 03:00 
[14.1;“func.reqs”;203.37;426.75;-]  
21 13 analyze results customer  – 2016-02-25t12:28:49.455  + 03:00 
[14.1;“func.reqs”;203.37;426.75;-]  
21 14 proposal  rejected arch.team  analyst 2016-02-25t12:46:36.455  + 03:00 
[14.1;“func.reqs”;203.37;426.75;-]  
ation with time. the generated  sample  event log contains  10 0 0 traces, 13,119 events,  and 21 activity  classes  (the same 
number  as activities  in the model shown in fig. 1 ). the model contains  ﬁve data objects.  thus, each event in the log will 
contain  values for all ﬁve data variables:  [cost  for customer:  float;  functional  requirements:  string;  
duration:  float;  cost:  float;  total  budget:  float]  . there are 16 different  case variants  (sets of traces 
presenting  the same sequence  of event names)  in the generated  log. this number  is a property  of a particular  model used 
for the log generation.  model shown in fig. 1 speciﬁes  three general  cases: one successful  case, when all stakeholders  accept 
proposals  (with 17 events),  and two rejection  cases (with 12 and 14 events).  other cases lead to deadlocks.  the number  of 
actual case variants  in the log is larger because  of choices  and interleaving  of concurrent  events.  for example,  in the process  
functional  requirements  can be proposed  before or after of non-functional  requirements.  
fig. 8 shows the distribution  of number  of traces by case variants.  one can see, that there are three groups  of cases. 
approximately  700 traces are from the four most popular  cases: 1, 2, 3, 4. several  cases form the second  group of less 
popular  cases (numbered  5, 6, and 7). the over variants  (case types 8 to 16) are even less frequent.  obviously,  short traces 
are the most popular.  the longer the trace, the more variations  it allows.  thus, the structure  of a model together  with the 
generation  settings  inﬂuences  the character  of the distribution.  one can specify  preferences,  which will lead to a single-case  
event log, by disabling  all branches  except the desired  ones. the distribution  shown in fig. 8 is typical for the generation  
with random  choices  on all gateways.  table 1 contains  one-trace  fragment  from the generated  event log. 14 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
table 2 
simulation  statistics  for 10 different  models selected from signavio collection.  
model id number of 
elements  
(events) activities/  
gateways(xor  + and)/ 
flows pools/ 
lanes trace 
variants total events 
(classes)  trace length 
min mean max 
8914774_rev1  11 (2) 5 / 4 + 0 / 12 0 / 0 3 2511 (5) 2 3 3 
100193728_rev3  16 (2) 10 / 2 + 2 / 19 1 / 4 10 0 0 30,930 (10) 21 31 64 
1073989552_rev1  17 (4) 9 / 2 + 2 / 17 0 / 0 5 5072 (9) 3 5 7 
1754711371_rev1  18 (2) 10 / 4 + 2 / 20 1 / 2 6 5905 (10) 4 6 9 
186202353_rev1  30 (2) 16 / 4 + 8 / 35 0 / 0 657 18,024 (16) 15 18 57 
1280191109_rev7  28 (3) 22 / 3 + 0 / 30 0 / 0 10 0 0 896,988 (22) 890 897 904 
604624904_rev1  27 (2) 17 / 0 + 8 / 15 1 / 4 36 17,0 0 0 (17) 17 17 17 
1391700380_rev1  18 (2) 10 / 4 + 2 / 20 0 / 0 6 5962 (10) 4 6 9 
1849720729_rev3  12 (4) 6 / 2 + 0 / 11 1 / 3 3 3505 (6) 3 4 4 
2012957934_rev3  21 (3) 13 / 2 + 3 / 23 0 / 0 28 7228 (13) 1 7 35 
fig. 9. initial model. 
6.2. evaluation  
in order to test robustness  and effectiveness  of the approach,  the presented  tool has been tested on models  selected  from 
the signavio  bpmn reference  models  collection  10 . this collection  contains  several  thousands  (more than 4 700) of real-life  
process  models  made by experts.  these models  were collected  by signavio  from many of application  areas and are usually  
used to test analysis  algorithms  in the bpm ﬁeld. 
approximately  30 0 0 of models  satisfy the restrictions  of the formal framework  described  in section  4 . the most popular  
construct,  which is not supported  in our framework,  is a message  event . in general,  these events are a type of syntactic  sugar, 
they add no essential  aspects  for the modeling.  another  non-supported  type of elements  is timer event . however,  we plan 
to support  these elements  in the next version  of the tool. 
the event log generator  works correctly  and robustly  on 956 of satisfying  models.  for the other models  the tool fails 
to return traces after 10 0 0 attempts.  these models  can not terminate  because  of deadlocks  (process  executions  leading  to 
the states, in which no node is enabled)  or livelocks  (executions  inevitably  ending  up in a loop of repeating  tasks without  
possibility  to reach the end state). for each model the test script generated  an event log of 500 traces using our tool. the 
whole test procedure  (for all models  from the signavio  collection)  took 646,065  ms (10 min approximately)  on a typical 
desktop  computer.  the total number  of generated  traces is 478,0 0 0. during  the generation  10,520 deadlocks  and 198,663  
livelocks  were identiﬁed.  our tool successfully  simulated  models  from signavio  collection,  which satisfy the restrictions  of 
the formal framework,  and contain  no deadlocks  or livelocks.  
table 2 shows generation  statistics  for 10 different  models,  which were randomly  selected  from signavio  collection.  10 0 0 
traces were generated  for each model. the reader can see the relationship  between  model structure  (number  of activities,  
gateways,  lanes) and the variability  of characteristics  of generated  event logs. in fig. 9 the 186202353_rev1  model is 
shown.  fig. 10 shows the view with characteristics  of the event log, which was generated  for this model. 
in the worst case complexity  for the log generation  can be estimated  as c = o (n l ·n tr ·s f ·(| sf | + | mf | + | n| + | do | + 
e v )) , where n l is the number  of event logs, n tr is the number  of traces, s f is a maximum  number  of ﬁrings within a trace 
generation,  sf, mf, n , and do are the total numbers  of sequence  ﬂows, message  ﬂows, sequence  nodes, and data objects  
respectively,  e v is a constant,  indicating  the number  of operations  needed  to generate  an event (depends  on the generation  
type). before a single ﬁring all sequence  and message  ﬂows are checked  for the presence  of tokens,  after that activated  
nodes are determined,  then one of them is selected  and ﬁred, during its ﬁring novel tokens are produced,  the values of data 
variables  are changed  and not more than e v log writing  operations  are performed.  
10 signavio models collection:  http://www.signavio.com/reference-models/  . a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 15 
fig. 10. generated  event log. 
7. conclusion  
this paper proposes  an approach  for the generation  of event logs for high-level  process  models.  formal  semantics  for the 
core part of the bpmn standard,  including  ﬂat control  ﬂow, hierarchy,  data perspective,  and participants,  are deﬁned  and 
supported.  on the basis of the introduced  semantics,  a tool for the automated  event log generation  has been implemented  
within the prom framework.  furthermore,  the generation  is enriched  with capabilities  of modifying  the behavior  of exclusive  
gateways  and simulating  models  with time. 
the approach  has been tested using hundreds  of models  from the signavio  bpmn reference  models  collection.  the 
results of this evaluation  showed  that the approach  allows the generation  of event logs for a signiﬁcant  portion  of models  
from this collection.  moreover,  the tool has shown its effectiveness,  eﬃciency  and robustness.  the entire testing collection  
can be processed  in less than half an our. the tool is resistant  to unsound  models  that get stuck in deadlocks  or livelocks.  
experimentations  also show the need to expand  the number  of bpmn elements  supported  by the tool. several  types of 
events are not yet supported  by our tool but are present  in the model collection.  this is especially  true for message  events.  
nevertheless,  the core part of bpmn model is supported  by our approach.  
with the help of this tool, researchers  and bpm specialists  can evaluate  process  mining  algorithms  using sets of event 
logs with desired  characteristics  generated  for ﬁne-tuned  models.  a possible  extension  of the approach  can be to incorporate  
more elements  from the bpmn 2.0 standard.  the clear identiﬁcation  of dependencies  between  speciﬁc  model parameters  
and statistical  characteristics  of corresponding  event logs may also be an interesting  area for future research.  
references  
[1] omg , business  process model and notation  (bpmn), object management  group, 2013 . (formal/2013-12-09).  
[2] a .a . kalenkova  , m. de leoni , w.m.p. van der aalst , discovering,  analyzing  and enhancing  bpmn models using prom, in: proceedings  of the bpm 
demo sessions 2014 co-located  with the 12th international  conference  on business  process management  (bpm 2014), eindhoven,  the netherlands,  
september  10, 2014, ceur workshop  proceedings,  vol. 1295, ceur-ws.org,  2014, p. 36 . 
[3] a .a . kalenkova  , w.m.p. van der aalst , i.a. lomazova  , v.a. rubin , process mining using bpmn: relating event logs and process models, softw. syst. 
model. (2015) 1–30 . 
[4] r. conforti , m. dumas , l. garca-bauelos  , m. la rosa , beyond tasks and gateways:  discovering  bpmn models with subprocesses,  boundary  events 
and activity markers,  in: business  process management,  in: lecture notes in computer  science, vol. 8659, springer international  publishing,  2014, 
pp. 101–117 . 
[5] h. verbeek , j. buijs , b. dongen , w. aalst , prom 6: the process mining toolkit, in: proc. of bpm demonstration  track 2010, ceur workshop  proceedings,  
vol. 615, 2010, pp. 34–39 . 
[6] w.m.p. van der aalst , process mining - data science in action, second ed., springer,  2016 . 
[7] a .k.a .d. medeiros  , c.w. günther , process mining: using cpn tools to create test logs for mining algorithms,  in: k. jensen (ed.), proceedings  of the 
sixth workshop  on the practical use of coloured  petri nets and cpn tools (cpn 2005), daimi, vol. 576, university  of aarhus, aarhus, denmark,  2005, 
pp. 177–190 . 
[8] m. zäuram , business  process simulation  using coloured  petri nets, university  of tartu, estonia, 2010 master’s thesis . 16 a .a . mitsyuk et al. / simulation  modelling  practice and theory 74 (2017) 1–16 
[9] m. ramadan  , h. elmongui  , r. hassan , bpmn formalisation  using coloured  petri nets, in: the 2nd gstf annual international  conference  on software  
engineering  & applications  (sea’11),  2011 . 
[10] b.p. zeigler, hierarchical,  modular discrete-event  modelling  in an object-oriented  environment,  simulation  49 (5) (1987) 219–230,  doi: 10.1177/ 
003754 978704 900506 . 
[11] g. wainer, devs tools, accessed:  2016-11-03,.  
[12] d. cetinkaya  , a. verbraeck  , m.d. seck , model transformation  from bpmn to devs in the mdd4ms  framework,  in: proceedings  of the 2012 symposium  
on theory of modeling  and simulation  - devs integrative  m&s symposium,  tms/devs  ’12, society for computer  simulation  international,  san diego, 
ca , usa , 2012, pp. 28:1–28:6  . 
[13] h. bazoun , y. bouanan  , g. zacharewicz  , y. ducq , h. boye ,b u s i n e s s  process simulation:  transformation  of bpmn 2.0 to devs models (wip), in: proceed-  
ings of the symposium  on theory of modeling  & simulation  - devs integrative,  devs ’14, society for computer  simulation  international,  san diego, 
ca , usa , 2014, pp. 20:1–20:7  . 
[14] s. boukelkoul,  r. maamri, optimal model transformation  of bpmn to devs, in: 2015 ieee/acs  12th international  conference  of computer  systems and 
applications  (aiccsa),  2015, pp. 1–8, doi: 10.1109/aiccsa.2015.7507115  . 
[15] t. stocker , r. accorsi , secsy: security-aware  ssynthesis  of process event logs, in: proceedings  of the 5th international  workshop  on enterprise  mod- 
elling and information  systems architectures,  2013 . st. gallen, switzerland.  
[16] a . burattin , a . sperduti , plg: a framework  for the generation  of business  process models and their execution  logs, in: bpm 2010 workshops,  pro- 
ceedings  of the sixth workshop  on business  process intelligence  (bpi2010),  lecture notes in business  information  processing,  vol. 66, springer-verlag,  
berlin, 2011 . 
[17] a. burattin , plg2: multiperspective  processes  randomization  and simulation  for online and oﬄine settings, corr abs/1506.08415  (2015) . 
[18] v.m. kataeva , a .a . kalenkova  , applying  graph grammars  for the generation  of process models and their lsogs, in: proceedings  of the 8th 
spring/summer  young researchers  colloquium  on software  engineering  (syrcose  2014), 2014, pp. 83–87 . 
[19] a. rozinat , r.s. mans , m. song , w.m.p. van der aalst , discovering  simulation  models, inf. syst. 34 (3) (2009a) 305–327  . 
[20] a. rozinat , m.t. wynn , w.m.p. van der aalst , a.h.m. ter hofstede  , c.j. fidge , workﬂow  simulation  for operational  decision support, data knowl. eng. 
68 (9) (2009b) 834–850  . 
[21] k.m. van hee , m.l. rosa , z. liu , n. sidorova  , discovering  characteristics  of stochastic  collections  of process models, in: bpm, lecture notes in computer  
science, vol. 6896, springer,  2011a, pp. 298–312  . 
[22] k.m. van hee , z. liu , n. sidorova  , is my event log complete?  - a probabilistic  approach  to process mining, in: rcis, ieee, 2011b, pp. 1–7 . 
[23] r.m. dijkman , m.l. rosa , h.a. reijers , managing  large collections  of business  process models - current techniques  and challenges,  comput. ind. 63 (2) 
(2012) 91–97 . 
[24] i.s. shugurov  , a .a . mitsyuk , generation  of a set of event logs with noise, in: proceedings  of the 8th spring/summer  young researchers  colloquium  on 
software  engineering  (syrcose  2014), 2014, pp. 88–95 . 
[25] m. zur muehlen  , j. recker , how much language  is enough?  theoretical  and practical  use of the business  process modeling  notation,  in: seminal 
contributions  to information  systems engineering,  springer,  2013, pp. 429–443  . 
[26] r.m. dijkman , m. dumas , c. ouyang , semantics  and analysis of business  process models in bpmn, inf. softw. technol. 50 (12) (2008) 1281–1294  . 
[27] a. kheldoun  , k. barkaoui  , m. ioualalen  , speciﬁcation  and veriﬁcation  of complex business  processes  - a high-level  petri net-based  approach,  in: bpm, 
lecture notes in computer  science, vol. 9253, springer,  2015, pp. 55–71 . 
[28] j. ye , s. sun , w. song , l. wen , formal semantics  of bpmn process models using yawl, in: intelligent  information  technology  application,  2008. iita 
’08. second international  symposium  on, vol. 2, 2008, pp. 70–74 . 
[29] a. kalenkova  , i.a. lomazova  , discovery  of cancellation  regions within process mining techniques,  fundam.  inform. 133 (2–3) (2014) 197–209  . 
[30] w.m.p. van der aalst , a .a . kalenkova  , v.a . rubin , h. verbeek , process discovery  using localized  events, in: r. devillers,  a. valmari (eds.), application  
and theory of petri nets and concurrency:  36th international  conference,  petri nets 2015, brussels,  belgium,  june 21–26, 2015, proceedings,  springer 
international  publishing,  cham, 2015, pp. 287–308  . 
[31] ieee task force on process mining, xes standard  deﬁnition,  2013. ( www.xes-standard.org  ) . 