process mining: a two-step approach using
transition systems and regions
wil m.p. van der aalst1, v. rubin2,1, b.f. van dongen1, e. kindler2, and
c.w. g¨ unther1
1eindhoven university of technology, eindhoven, the netherlands
{w.m.p.v.d.aalst,b.f.v.dongen,c.w.gunther }@tue.nl
2university of paderborn, paderborn, germany
{vroubine,kindler }@uni-paderborn.de
abstract. more and more information about processes is recorded by
information systems in the form of so-called “event logs”. despite the
omnipresence and richness of these event logs, most software vendors
have been focusing on relatively simple questions under the assumption
that the process is ﬁxed and known , e.g., the calculation of simple perfor-
mance metrics like utilization and ﬂow time. however, in many domains
processes are evolving and people, typically, have an oversimpliﬁed and
incorrect view on the actual business processes. therefore, process min-
ingtechniques attempt to extract non-trivial and useful information from
event logs. one element of process mining is control-ﬂow discovery, i.e.,
automatically constructing a process model (e.g., a petri net) describing
the causal dependencies between activities. many control-ﬂow discovery
techniques have been proposed in literature. unfortunately, these tech-
niques have problems when discovering processes with complicated depen-
dencies . this paper proposes a new two-step approach . first, a transition
system is constructed which can be modiﬁed to avoid over-ﬁtting. then,
using the “theory of regions”, the model is synthesized. the approach
has been implemented in the context of prom and uses petrify for syn-
thesis. this paper demonstrates that this two-step approach overcomes
many of the limitations of traditional approaches.
1 introduction
processes, organizations, and information systems are getting more and more
interconnected. organizations are “designed” around business processes and in-
formation systems. processes and information systems have become intertwined
in many ways. today, many of the activities in a process are either supported or
monitored by information systems. therefore, there is an increased interest in
the so-called process-aware information systems (paiss) as a means to bridge
the perceived gap between people and software through process technology [20].
erp (enterprise resource planning), wfm (workflow management), crm
(customer relationship management), scm (supply chain management), and
pdm (product data management) software can be used to create paiss. notonly wfm systems have a process engine; modern erp, crm, and pdm sys-
tems also have a workﬂow component built-in. this component allows for the
design and enactment of case-driven processes, i.e., structured processes that
handle cases (e.g., job applications, insurance claims, customer orders, business
trips, etc.).
in recent years, it has become evident that the classical “workﬂow para-
digm” only ﬁts a selected subset of highly structured processes. however, one
cannot assume that a pais supports only “production-like” processes. it can be
observed that today’s information systems increasingly support more dynamic
processes. for example, one can use sap without strictly following the process
steps deﬁned in the idealized reference model. other examples are the “care-
ﬂows” in hospitals where it is obvious that there is a constant need to deviate
from standard processes. therefore, even traditional workﬂow products started
to support case handling, ad-hoc processes, and data-driven workﬂows. this does
not imply that thinking in processes is not important. process thinking is essen-
tial. however, the goal is not to enforce processes but to support, monitor, and
inﬂuence them . at the same time, today’s information systems record enormous
amounts of data. erp, wfm, crm, scm, and pdm software provide excellent
logging facilities, i.e., there is a tight coupling between processes and informa-
tion systems even if the processes are not enforced by the information system,
i.e., information systems are aware of processes even if they do not control them
in every aspect. therefore, these systems are called paiss [20]. let us consider
some examples:
–for many years hospitals have been working on electronic patient records
(epr), i.e., information about the health history of a patient, including all
past and present health conditions, illnesses and treatments are managed
by the information system. although there are still many problems that
need to be resolved (mainly of a non-technical nature), many people forget
that most of this information is already present in the hospital information
system. for example, by dutch law all hospitals need to record the diagnosis
and treatment steps at the level of individual patients in order to receive
payment. this so-called “diagnose behandeling combinatie” (dbc) forces
hospitals to record all kinds of events.
–today, many organizations are moving towards a service-oriented architec-
ture (soa). a soa is essentially a collection of services that communicate
with each other. the communication can involve either simple data passing
or it could involve two or more services coordinating some activity. here
technologies and standards such such as soap, wsdl, and bpel are used.
it is relatively easy to listen in on the message exchange between services.
this results in massive amounts of relevant information that can be recorded.
–increasingly professional high-tech systems such as high-end copiers, complex
medical equipment, lithography systems, automated production systems, etc.
record events which allow for the monitoring of these systems. these raw
event logs can be distributed via the internet allowing for both real-time
and oﬀ-line analysis.–other examples can be found in the classical administrative systems of large
organizations using e.g. erp, wfm, crm, scm, and pdm software. con-
sider for example processes in banks, insurance companies, local govern-
ments, etc. here most activities are recorded in some form.
these examples illustrate that one can ﬁnd a variety of event logs in today’s
paiss. the abundance of event data combined with the need to monitor and
inﬂuence less structured processes (i.e., allowing for some form of ﬂexibility)
explains our interest in process mining.
assuming that we are able to log events, a wide range of process mining tech-
niques comes into reach [5, 6, 9, 13, 17, 18, 35]. the basic idea of process mining
is to learn from observed executions of a process and (1) to discover new models
(e.g., constructing a petri net that is able to reproduce the observed behavior),
(2) to check the conformance of a model by checking whether the modeled be-
havior matches the observed behavior, and (3) to extend an existing model by
projecting information extracted from the logs onto some initial model (e.g.,
show bottlenecks in a process model by analyzing the event log). all three types
of analysis have in common that they assume the existence of some event log .
this paper will focus on a new type of process discovery which entails a two-
step approach: (1) a transition system is used as an intermediate representation
and (2) a petri net obtained through regions [7, 8, 11, 12, 21] as a ﬁnal repre-
sentation. transition systems are the most basic representation of processes,
e.g., simple processes tend to have many states (cf. “state explosion” problem
in veriﬁcation). however, using the “theory of regions” and tools like petrify
[12], transition systems can be “folded” into more compact representations, e.g.,
petri nets [14, 30]. especially transition systems with a lot of concurrency (as-
suming interleaving semantics) can be reduced dramatically through the folding
of states into regions, e.g., transition systems with hundreds or even thousands
of states can be mapped onto compact petri nets. however, before using regions
to fold transition systems into petri nets, we ﬁrst need to derive a transition
system from an event log. this paper shows that this can be done in several
ways enabling a repertoire of process discovery approaches . diﬀerent strategies
for generating transition systems are possible depending on the desired degree
of generalization.
our two-step approach overcomes many of the limitations of existing algo-
rithms. existing process mining algorithms tend to:
–have problems with complex control-ﬂow constructs. for example, many
process mining algorithms are unable to deal with non-free-choice constructs
and complex nested loops.
–not allow for duplicates (i.e., occurrences of the same activity in diﬀerent
phases of the process). in the event log it is not possible to distinguish be-
tween activities that are logged in a similar way, i.e., there are multiple
activities that have the same “footprint” in the log. as a result, most algo-
rithms map these diﬀerent activities onto a simple activity thus making the
model incorrect or counter-intuitive.–over-generalize. many algorithms have a tendency to over-generalize, i.e.,
the discovered model allows for much more behavior than actually recorded
in the log. in some circumstances this may be desirable. however, there seems
to be a need to ﬂexibly balance between “overﬁtting” and “underﬁtting”.
–yield inconsistent models. for more complicated processes many algorithms
have a tendency to produce models that may have deadlocks and/or livelocks.
it seems vital that the generated models satisfy some soundness requirements
(e.g., the soundness property deﬁned in [1]).
we will show that the approach presented in this paper is able to address these
problems.
this paper will not address issues related to noise, e.g., incorrectly logged
events (i.e., the log does not reﬂect reality) and exceptions (i.e., sequences of
events corresponding to “abnormal behavior”). heuristics [35] or genetic algo-
rithms [2] can deal with noise, but are outside the scope of this paper. neverthe-
less, it should be easy to combine the ideas in this paper with existing approaches
already dealing with noise.
the two-step approach presented in this paper has been implemented in
prom (www.processmining.org). prom serves as a testbed for our process mining
research [19]. for the second step of our approach prom calls petrify [12] to
synthesize the petri net. petrify implements diﬀerent algorithms for computing
a petri net from a transition system. moreover, it can be conﬁgured to calculate
petri nets with speciﬁc syntactic constraints.
the remainder of this paper is organized as follows. section 2 provides an
overview of process mining and discusses problems related to process discovery.
the ﬁrst step of our approach is presented in section 3. here it is shown that
there are various ways to construct a transition system based on a log. the second
step where the transition system is transformed into a petri net is presented in
section 4. section 5 describes the implementation, evaluation, and application
of our two-step approach. related work is discussed in section 6, and section 7
concludes the paper.
2 process mining
this section introduces the concept of process mining and provides examples of
issues related to control-ﬂow discovery. it also discusses requirements such as
the need to produce correct models and to balance between models that are too
speciﬁc and too generic.
2.1 overview of process mining
process mining is applicable to a wide range of information systems. there
are diﬀerent kinds of process-aware information systems (paiss) [20] that
produce event logs . examples are classical workﬂow management systems (e.g.
staﬀware), erp systems (e.g. sap), case handling systems (e.g. flower), pdmsystems (e.g. windchill), crm systems (e.g. microsoft dynamics crm), mid-
dleware (e.g., ibm’s websphere), hospital information systems (e.g., chipsoft),
etc. these systems provide very detailed information about the activities that
have been executed. the goal of process mining is to extract information (e.g.,
process models) from these logs, i.e., process mining describes a family of a-
posteriori analysis techniques exploiting the information recorded in the event
logs. typically, these approaches assume that it is possible to sequentially record
events such that each event refers to an activity (i.e., a well-deﬁned step in the
process) and is related to a particular case (i.e., a process instance). further-
more, some mining techniques use additional information such as the performer
or originator of the event (i.e., the person / resource executing or initiating the
activity), the timestamp of the event, or data elements recorded with the event
(e.g., the size of an order).
process mining addresses the problem that most “process owners” have very
limited information about what is actually happening in their organization. in
practice, there is often a signiﬁcant gap between what is prescribed or supposed
to happen, and what actually happens. only a concise assessment of the orga-
nizational reality, which process mining strives to deliver, can help in verifying
process models, and ultimately be used in a process redesign eﬀort.
models
analyzesrecords 
events, e.g., 
messages, 
transactions, 
etc.spec ifies
configures
implements
analyzessupports/
controls
people machines
organizationscomponentsbusiness processes
fig. 1. three types of process mining: (1) discovery, (2) conformance, and (3) exten-
sion.
the idea of process mining is to discover, monitor and improve real processes
(i.e., not assumed processes) by extracting knowledge from event logs. clearly
process mining is relevant in a setting where much ﬂexibility is allowed or needed
and therefore this is an important topic in this paper. the more ways in which
people and organizations can deviate, the more variability and the more inter-esting it is to observe and analyze processes as they are executed. we consider
three basic types of process mining (figure 1):
– discovery : there is no a-priori model, i.e., based on an event log some
model is constructed. for example, using the α-algorithm [5] a process model
can be discovered based on low-level events. events.
– conformance : there is an a-priori model. this model is used to check if
reality conforms to the model. for example, there may be a process model
indicating that purchase orders of more than one million euro require two
checks. another example is the checking of the four-eyes principle. confor-
mance checking may be used to detect deviations, to locate and explain these
deviations, and to measure the severity of these deviations.
– extension : there is an a-priori model. this model is extended with a new
aspect or perspective, i.e., the goal is not to check conformance but to enrich
the model. an example is the extension of a process model with performance
data, i.e., some a-priori process model is used to project the bottlenecks on.
traditionally, process mining has been focusing on discovery , i.e., deriving in-
formation about the original process model, the organizational context, and ex-
ecution properties from enactment logs. an example of a technique addressing
the control ﬂow perspective is the α-algorithm, which constructs a petri net
model [14, 16, 30] describing the behavior observed in the event log. however,
process mining is not limited to process models (i.e., control ﬂow) and recent
process mining techniques are more and more focusing on other perspectives,
e.g., the organizational perspective or the data perspective. for example, there
are approaches to extract social networks from event logs and analyze them us-
ing social network analysis [3]. this allows organizations to monitor how people
and groups are working together.
conformance checking compares an a-priori model with the observed behav-
ior as recorded in the log. in [31] it is shown how a process model (e.g., a petri
net) can be evaluated in the context of a log using metrics such as “ﬁtness” (is
the observed behavior possible according to the model?) and “appropriateness”
(is the model “typical” for the observed behavior?). however, it is also possible
to check conformance based on organizational models, predeﬁned business rules,
temporal formula’s, quality of service (qos) deﬁnitions, etc.
there are diﬀerent ways to extend a given process model with additional
perspectives based on event logs, e.g., decision mining [32]. decision mining, also
referred to as decision point analysis, aims at the detection of data dependencies
that aﬀect the routing of a case. starting from a process model, one can analyze
how data attributes inﬂuence the choices made in the process based on past
process executions. classical data mining techniques such as decision trees can
be leveraged for this purpose. similarly, the process model can be extended with
timing information (e.g., bottleneck analysis).
at this point in time there are mature tools such as the prom framework
[19], featuring an extensive set of analysis techniques which can be applied to
real process enactments while covering the whole spectrum depicted in figure 1.2.2 control-flow discovery
the focus of this paper is on control-ﬂow discovery , i.e., extracting a process
model from an event log. typically, we assume event logs that contain informa-
tion about the execution of activities for cases (i.e., process instances). figure 2
shows a small fragment of a log in mxml, the format used by prom [19].
fig. 2. a small fragment of an event log in mxml format showing information about
processes, cases (processinstance ﬁeld), activities (workﬂowmodelelement ﬁeld), re-
sources (originator ﬁeld), transactional information, timing information, and data el-
ements.
the prom import framework allows developers to quickly implement plug-
ins that can be used to extract information from a variety of systems and con-
vert it into the mxml format [23]. there are standard import plug-ins for
a wide variety of systems, e.g., workﬂow management systems like staﬀware,
case handling systems like flower, erp components like peoplesoft finan-
cials, simulation tools like aris and cpn tools, middleware systems like web-sphere, bi tools like aris ppm, etc. moreover, it is been used to develop
many organization/system-speciﬁc conversions (e.g., hospitals, banks, govern-
ments, etc.).
figure 2 shows the typical data present in most event logs. note that it is
not required that systems need to log all of this information, e.g., some systems
do not record transactional information (e.g., just the completion of activities
is recorded), related data, or timestamps. in the mxml format used by prom,
everything is optional except the processinstance ﬁeld and the workﬂowmod-
elelement ﬁeld, i.e., any event needs to be linked to a case (process instance) and
an activity . all ﬁelds are relevant, however, since we focus on control-ﬂow dis-
covery, we can restrict ourselves to these two mandatory ﬁelds and assume that
an event is described by a pair ( c, a) where crefers to the case and arefers to the
activity. in fact, we can further simplify things by not considering dependencies
between cases. we assume that each of the cases is executed independent from
other cases, i.e., the routing of one case does not depend on the routing of other
cases (although they may compete for the same resources). as a result, we can
simply focus on the ordering of activities within individual cases . therefore, a
single case σcan be described by a sequence of activities, i.e., a trace σ∈a∗
where ais the set of activities. consequently, a log can be described by a set of
traces.
ab
cd e
fig. 3. a log represented by sequences of activities and the process model that is
discovered using the α-algorithm.
figure 3 shows an example of a log and the corresponding process model that
can be discovered using techniques such as the α-algorithm [5]. it is easy to see
that the petri net is able to reproduce the log, i.e., there is a good ﬁt between
the log and the discovered process model.3note that the α-algorithm is a very
simple algorithm, but like many other algorithms it has several limitations. in
section 6 we mention some of these algorithms.
3in this paper, we assume that the reader has a basic understanding of petri nets, cf.
[14, 16, 30].as indicated in the introduction, existing process mining algorithms for
control-ﬂow discovery typically have several problems. using the example shown
in figure 3, we can discuss these problems in a bit more detail.
the ﬁrst problem is that many algorithms have problems with complex
control-ﬂow constructs . for example, the choice between the concurrent execu-
tion of bandcor the execution of just eshown in figure 3 cannot be handled
by many algorithms. most algorithms do notallow for so-called “non-free-choice
constructs” where concurrency and choice meet. the concept of free-choice nets
is well-deﬁned in the petri net domain [14]. however, in reality processes tend
to be non-free-choice. in this particular example, the α-algorithm [5] is able to
deal with the non-free-choice construct. however, some algorithms are unable to
deal with this example and it is easy to think of a non-free-choice process that
cannot be discovered by the α-algorithm. the non-free-choice construct is just
one of many constructs that existing process mining algorithms have problems
with. other examples are arbitrary nested loops, unbalanced splits and joins,
partial synchronization, etc. in this context it is important to note that process
mining is, by deﬁnition, restricted by the expressive power of the target language ,
i.e., if a simple or highly informal language is used, process mining is destined
to produce less relevant or over-simpliﬁed results.
the second problem is the fact that most algorithms have problems with
duplicates . in the event log it is not possible to distinguish between activities
that are logged in a similar way, i.e., there are multiple activities that have the
same “footprint” in the log. as a result, most algorithms map these diﬀerent
activities onto a simple activity thus making the model incorrect or counter-
intuitive. consider for example figure 3 and assume that activities aanddare
both recorded as x. for example, the trace abcd is recorded as xbcx . most
algorithms will try to map the ﬁrst and the second xonto the same activity. in
some cases this make sense. however, if aanddreally play a diﬀerent role in
the process, algorithms that are unable to separate them will run into all kinds
of problems, e.g., the model becomes more diﬃcult or incorrect.
the third problem is that many algorithms have a tendency to over-generalize ,
i.e., the discovered model allows for much more behavior than actually recorded
in the log. we will discuss this in more detail in section 2.3 when we discuss the
completeness of a log.
the fourth problem is that many algorithms have a tendency to generate
inconsistent models . note that here we do not refer to the relation between the
log and the model but to the internal consistency of the model by itself. for
example, the α-algorithm [5] may yield models that have deadlocks or livelocks
when the log shows certain types of behavior. when using petri nets as a model
to represent processes, an obvious choice is to require the model to be sound
[1]. soundness implies that for any case: (1) the model can potentially terminate
from any reachable state (option to complete), (2) that the model has no dead
parts, and (3) that no tokens are left behind (proper completion). see [1, 5] for
details.the four problems just mentioned illustrate the need for more powerful algo-
rithms. see also [28] for a more elaborate discussion on these and other challenges
in control-ﬂow discovery. this is the reason we propose a new approach in this
paper.
2.3 notions of completeness
when it comes to process mining the notion of completeness is very important.
like in any data mining or machine learning context one cannot assume to have
seen all possibilities in the “training material” (i.e., the event log at hand). in
figure 3, the set of possible traces found in the log is exactly the same as the
set of possible traces in the model, i.e., {abcd, acbd, aed }. in general this
is not the case. for example, the trace abecd may be possible but did not
occur in the log. therefore, process mining is always based on some notion of
completeness. a mining algorithm could be very precise in the sense that it
assumes that only the sequences in the log are possible. this implies that the
algorithm actually does not provide more insights than what is already in the
log. it seems better to use occam’s razor, i.e., “one should not increase, beyond
what is necessary, the number of entities required to explain anything”, to look
for the “simplest model” that can explain what is in the log. therefore the α-
algorithm [5] assumes that the log is “locally complete”, i.e., if there are two
activities xandy, and xcan be directly followed by ythis should be observed
in the log.
to illustrate the relevance of completeness, consider 10 tasks which can be
executed in parallel. the total number of interleavings is 10! = 3628800. it is
probably not realistic that each interleaving is present in the log. however, for
local completeness only 10(10-1)=90 observations are needed.
ab
c
d estart end
fig. 4. the so-called “ﬂower petri net” allowing for any log containing a,b,c,d,
ande.
diﬀerent algorithms assume diﬀerent notions of completeness. these notions
illustrate the diﬀerent attempts to strike a balance between “overﬁtting” and
“underﬁtting”. a model is overﬁtting if it does not generalize and only allows
for the exact behavior recorded in the log. this means that the correspondingmining technique assumes a very strong notion of completeness: “if it is not in
the event log, it is not possible.”. an underﬁtting model over-generalizes the
things seen in the log, i.e., it allows for more behavior even when there are
no indications in the log that suggest this additional behavior. an example is
shown in figure 4. this so-called “ﬂower petri net” allows for any sequence
starting with start en ending with endand containing any ordering of activities
a,b,c,d, and ein between. clearly, this model allows for the set of traces
{abcd, acbd, aed }(without the added start andendactivities) but also
many more, e.g., aadd .
a d
c
e b
a d
c
e b(a)
(b)(c)
(d)
fig. 5. two logs and two models illustrating issues related to completeness (i.e., “over-
ﬁtting” and “underﬁtting”).
let us now consider another example showing that it is diﬃcult to balance
between being too general and too speciﬁc. figure 5 shows two event logs and
two models. both logs are possible according to the model shown in (d). however,
only log (a) is possible according to the model shown in (c) because this model
does not allow for ace andbcd present in log (b). clearly, (c) seems to be a
suitable model for (a) and (d) seems to be a suitable model for (b). however,
the question is whether (d) is also a suitable model for (a). if there are just two
cases acd andbce , then there is no reason to argue why (d) would not be
a suitable model. however, if there are 100 cases following acd and 100 cases
bce , then it is diﬃcult to justify (d) as a suitable model and (c) seems more
appropriate. if ace andbcd are indeed possible (model (d)), then it seems
unlikely that they never occurred in one of the 200 cases.
figure 5 shows that there is a delicate balance and that it is non-trivial to
compare logs and process models. in [31] notions such as ﬁtness andappropri-
ateness have been quantiﬁed. an event log and petri net “ﬁt” if the petri net
can generate each trace in the log. in other words: the petri net should be ableto “parse” (i.e., reproduce) every activity sequence observed. in [31] it is shown
that it is possible to quantify ﬁtness as a measure between 0 and 1. the intu-
itive meaning is that a ﬁtness close to 1 means that all observed events can be
explained by the model. however, the precise meaning is more involved since
tokens can remain in the network and not all transactions in the model need to
be logged [31]. unfortunately, a good ﬁtness only does not imply that the model
is indeed suitable, e.g., it is easy to construct petri nets that are able to repro-
duce any event log (cf. the “ﬂower model” in figure 4). although such petri nets
have a ﬁtness of 1, they do not provide meaningful information. therefore, in
[31] a second dimension is introduced: appropriateness . appropriateness tries to
answer the following question: “does the model describe the observed process in
a suitable way?” and can be evaluated from both a structural and a behavioral
perspective. in [31] it is shown that a “good” process model should somehow
be minimal in structure to clearly reﬂect the described behavior, referred to
asstructural appropriateness , and minimal in behavior in order to represent as
closely as possible what actually takes place, which will be called behavioral
appropriateness . the prom conformance checker supports both the notion of
ﬁtness and various notions of appropriateness.
despite the fact that there are diﬀerent ways to quantify notions such as ﬁt-
ness and appropriateness, there is typically not one optimal model. since there
is not “one size ﬁts all”, it is important to have algorithms that can be tuned
to speciﬁc applications. therefore, we present an approach that allows for dif-
ferent strategies allowing for diﬀerent interpretations of completeness to avoid
“overﬁtting” and “underﬁtting”.
3 constructing a transition system (step 1)
after introducing the concept of control-ﬂow discovery and discussing the prob-
lems of existing approaches, we can now explain our two-step approach. in the
ﬁrst step, we construct a transition system and in the second step this transition
system is synthesized into a petri net. this section describes the ﬁrst step. an
important quality of the ﬁrst step is that, unlike existing approaches, it can be
tuned towards the application. depending on the desired qualities of the model,
the algorithm can be tuned to provide suitable models.
3.1 preliminaries
to explain the diﬀerent strategies to construct transition systems from event
logs, we need the following notations.
letabe a set. i b( a) =a→i n is the set of multi-sets (bags) over a, i.e.,
x∈i b(a) is a multi-set where for each a∈a:x(a) denotes the number of
times ais included in the multi-set. the sum of two multi-sets ( x+y), the
diﬀerence ( x−y), the presence of an element in a multi-set ( x∈x), and the
notion of subset ( x≤y) are deﬁned in a straightforward way. moreover, we
also apply these operators to sets, where we assume that a set is a multiset inwhich every element occurs once. the operators are also robust with respect
to the domains of the multi-sets, i.e., even if xandyare deﬁned on diﬀerent
domains, x+y,x−y, and x≤yare deﬁned properly by extending the
domain where needed. |x|=/summationtext
a∈ax(a) is the cardinality of some multi-set x
overa.set(x) transforms a bag xinto a set: set(x) ={a∈x|x(a)>0}.
note that we assume the multi-sets to be ﬁnite.
p(a) is the powerset of a, i.e., x∈ p(a) if and only if x⊆a.
for a given set a,a∗is the set of all ﬁnite sequences over a. a ﬁnite
sequence over aof length nis a mapping σ∈ {1, . . . , n } → a. such a se-
quence is represented by a string, i.e., σ=/angbracketlefta1, a2, . . . , a n/angbracketrightwhere ai=σ(i)
for 1 ≤i≤n.hd(σ, k) =/angbracketlefta1, a2, . . . , a k/angbracketright, i.e., the sequence of just the ﬁrst
kelements (where 0 ≤k≤n). note that hd(σ,0) is the empty sequence.
tl(σ, k) =/angbracketleftak+1, ak+2, . . . , a n/angbracketright, i.e., the sequence after removing the ﬁrst kel-
ements 0 ≤k≤n.tl(σ,0) = σand tl(σ, n) is the empty sequence. σ↑xis
the projection of σonto some subset x⊆a, e.g., /angbracketlefta, b, c, a, b, c, d /angbracketright ↑ { a, b}=
/angbracketlefta, b, a, b /angbracketrightand/angbracketleftd, a, a, a, a, a, a, d /angbracketright ↑ {d}=/angbracketleftd, d/angbracketright.
for any sequence σovera, the parikh vector par(σ) maps every element a
ofaonto the number of occurrences of ainσ, i.e., par(σ)∈i b(a) where for
anya∈a:par(σ)(a) =|σ↑ {a}|.
the parikh vector will be used to count the number of times activities occur
in a sequence of activities.
3.2 approach
in section 2.2 we discussed the mxml format used in our tools (cf. figure 2).
although mxml can store transactional information, information about re-
sources, related data, and timestamps, we focus on the ordering of activities.
cases are executed independently from each other, and therefore, we can simply
restrict our input to the ordering of activities within individual cases. a single
case is described by a sequence of activities and a log can be described by a set
of traces4.
deﬁnition 1 (trace, event log). letabe a set of activities. σ∈a∗is a
trace andl∈ p(a∗)is an event log .
note that a∈amay refer to an atomic activity or may be structured, e.g.,
the set of documents produced in an activity.
the set of activities can be found by inspecting the log. the most important
aspect of process mining is however deducing the states of the process . most min-
ing algorithms have an implicit notion of state, i.e., activities are glued together
in some process modeling language based on an analysis of the log and the re-
sulting model has a behavior that can be represented as a transition system. in
4note that we ignore multiple occurrences of the same trace in this paper. when
dealing with issues such as noise it is vital to also look at the frequency of activities
and traces. therefore, an event log is typically deﬁned as a multi-set of traces rather
than a set. however, for the purpose of this paper is suﬃces to consider sets.this paper, we propose to deﬁne states explicitly and start with the deﬁnition of
a transition system.
in some cases, the state can be derived directly, e.g., each event encodes the
complete state by providing values for all relevant data attributes. however, in
the event log we typically only see activities and not states. hence, we need to
deduce state information from the activities executed before and after a given
state. based on this we conclude that, when building a transition system, there
are basically four approaches to determine the state in a log:
–past, i.e., the state is constructed based on the history of a case,
–future , i.e., the state of a case is based on its future,
–past and future , i.e., a combination of the previous two, or
–explicit knowledge of the current state, e.g., the log contains state information
in addition to event data.
past futurecurrent state
past and futureexplicit knowledge
fig. 6. at least four basic “ingredients” can be considered as a basis for calculating the
“process state”: (1) past, (2) future, (3) past and future, and (4) explicit knowledge.
figure 6 shows an example of a trace and the diﬀerent “ingredients” that can
be used to calculate state information.
in this paper, we assume that we do not have explicit knowledge about the
current state and focus on the past andfuture of a case. however, note that our
approach can also be applied to situations where we have explicit state knowledge
[26].
deﬁnition 2 (past and future of a case). letabe a set of activities and
letσ=/angbracketlefta1, a2, . . . , a n/angbracketright ∈a∗be a trace that represents a complete execution of a
case. the past of this case after executing ksteps ( 0≤k≤n) is hd (σ, k). the
future of this case after executing ksteps ( 0≤k≤n) is tl (σ, k).the past of a case is a preﬁx of the complete trace. similarly, the future of a
case is a postﬁx of the complete trace. this may be taken into account completely,
which leads to many diﬀerent states and process models that may be too speciﬁc
(i.e., “overﬁtting” models). however, many abstractions are possible as we will
see in the remainder.
first of all, the basis of calculation may be a complete or partial preﬁx
(postﬁx):
–complete preﬁx (postﬁx) , i.e., the state is represented by a complete history
(future) of the case,
–partial preﬁx (postﬁx) , i.e., only a subset of the trace is considered.
a partial preﬁx only looks at a limited number of events before the state is
reached. for example, while constructing the state information for the purpose
of process mining, one can decide to only consider the last kevents. for ex-
ample, instead of taking the complete preﬁx /angbracketlefta, b, c, d, c, d, c, d, e /angbracketrightshown
in figure 6 only the last four ( k= 4) events are considered: /angbracketleftd, c, d, e /angbracketright. in a
partial postﬁx also a limited horizon is considered, i.e., seen from the state under
consideration only the next kevents are taken into account.
second, only a selected set of activities may be considered, i.e., the log is
ﬁltered and only the remaining events are used as input for process mining. this
is another type of abstraction orthogonal to taking a partial preﬁx (postﬁx).
filtering may be used to remove certain activities. for example, if there are
start and complete events for activities, e.g., “a started” and “a completed”,
then it is possible to only consider the complete events. it is also possible to
ﬁlter out infrequent activities and focus on the frequent activities to simplify the
discovered model. filtering is a very important abstraction mechanism in process
mining. therefore, tools such as prom provide a wide range of ﬁltering tools
taking transaction types, data ﬁelds, resources, and frequencies into account.
the third abstraction mechanism removes the order or frequency from the
resulting trace. for the current state it may be less interesting to know when
some activity aoccurred and how many times aoccurred, i.e., only the fact
that it occurred at some time in the past is relevant. in other cases, it may be
relevant to know how many times aoccurred or it may be essential to know
whether aoccurred before bor not. this suggests that there are three ways of
representing knowledge about the past and/or future:
–sequence , i.e., the order of activities is recorded in the state,
–multi-set of activities , i.e., the number of times each activity is executed
ignoring their order, and
–set of activities , i.e., the mere presence of activities.
figure 7 illustrates the diﬀerent ways of representing the knowledge about the
past or future for the purpose of process mining. note that the diﬀerent kinds of
abstraction can be combined (assuming that we do not have explicit knowledge).
this results in 3 (past/future/past and future) times 2 (complete/partial) times
2 (no ﬁlter/ﬁlter) times 3 (sequence/multi-set/set) = 3 ∗2∗2∗3 = 36 strategiesprefix sequence:current state
postfix sequence:
prefix multi-set:
postfix multi-set:
prefix set:
postfix set:3 3
3
examples of further abstractions
partial prefix sequence: (last four)
partial prefix multi-set:2(last four)
partial postfix set: (next two)
filtered prefix sequence: (ignore c and d)
filtered postfix multi-set: (ignore g and h)fig. 7. there are many ways to construct the “current state” depending on the desired
level of abstraction.
to represent states. if more abstractions are used, the number of states will
be smaller and the danger of “underﬁtting” is present. if, on the other hand,
fewer abstractions are used, the number of states may be larger resulting in an
“overﬁtting” model.
let us now try to further operationalize the ideas illustrated by figure 7.
deﬁnition 2 already showed how to project a sequence of activities onto the past
or future using hd(σ, k) and tl(σ, k) (given a trace σand the state resulting after
ksteps). the operators parandsetdeﬁned in section 3.1 can be used to abstract
away the ordering of activities thus map sequences onto sets or multi-sets. to
ﬁlter, we use ↑deﬁned in section 3.1.
deﬁnition 3 (filtering). letabe a set of activities, x⊆aa subset of
activities, and σ∈a∗a trace. σ↑xis the sequence obtained by removing the
events that are not in x, i.e., σis ﬁltered by only keeping the activities in x.
when considering partial pre/postﬁxes, we need to deﬁne a horizon hand
usehdh(σ, k) and tlh(σ, k) rather than hd(σ, k) and tl(σ, k) as deﬁned below.
deﬁnition 4 (horizon). letabe a set of activities and σ=/angbracketlefta1, a2, . . . , a n/angbracketright ∈
a∗a complete trace of length n. let hbe a natural number deﬁning the horizon
and let k(0≤k≤n) point to the current state in the trace σ(i.e., state state
after executing ksteps). the partial preﬁx hdh(σ, k) =/angbracketlefta(k−h)max 1, . . . , a k/angbracketrightis
the sequence of at most hevents before reaching the current state. the partial
postﬁx tlh(σ, k) =/angbracketleftak+1, . . . , a (k+h)min n/angbracketrightis the sequence of at most hevents
following directly after the current state.as indicated before, the representation of the current state can be very de-
tailed or not. for example, given a trace σafter ksteps, the state may be repre-
sented as ( hd(σ, k),tl(σ, k)), i.e., the current state is represented by the complete
preﬁx and postﬁx sequences. however, to avoid “overﬁtting” other representa-
tions can be used. the representation par(hd(σ, k)) only considers the complete
preﬁx multi-set, i.e., the full preﬁx is considered but the ordering is not relevant.
the representation set(par(hd(σ, k))) considers the complete preﬁx set, i.e., the
full preﬁx is considered, the ordering is not relevant, and the frequency is not
relevant. another example state representation is set(par(tlh(σ, k))) which con-
siders a partial postﬁx of length hwithout caring about ordering a frequencies.
set(par(tlh((σ↑x), k))) is similar but now ﬁrst the sequence is ﬁltered and all
activities not in xare removed. after these examples, we deﬁne the concept of
state representation with respect to a position in trace explicitly.
deﬁnition 5 (state representation). a state representation state is a func-
tion which, given a sequence σand a kindicating the number of events of σthat
have occurred, produces a some representation r. formally, state ∈(a∗×i n)/negationslash→
rwhere ais the set of activities, ris the set of possible representations (e.g., se-
quences, sets, or bags over a), and dom (state ) ={(σ, k)∈a∗×i n|0≤k≤ |σ|}.
an example of a state representation is: state (σ, k) =set(par(tlh((σ↑x), k))).
the various abstraction concepts can be used to “tune” the state representa-
tion. many diﬀerent state functions are possible and here we only list the obvious
ones. as was indicated before, we consider 3 ∗2∗2∗3 = 36 strategies to represent
states. each of these strategies deﬁnes a state function. these can be constructed
as follows. assume a complete trace σand a kindicating the current position in
σ.
1. filter the log if needed, i.e., use σorσ↑xas a basis. (two possibilities.)
2. decide to use just the past, just the future, or both and determine if partial or
complete pre/postﬁxes are used. there are six possibilities: hd(σ, k),tl(σ, k),
(hd(σ, k),tl(σ, k)),hdh(σ, k),tlh(σ, k), and ( hdh(σ, k),tlh(σ, k)).
3. determine if the ordering and frequency of activities is relevant and fur-
ther abstract from this in the resulting post/preﬁxes if needed. assuming
a pre/postﬁx σit is possible to retain the sequence σ, to remove the or-
dering par(σ) (i.e., construct a multi-set), or to remove also the frequencies
set(par(σ)) (i.e., construct a set). (three possibilities.)
one of the 36 possible strategies is for example:
state (σ, k) = ( set(par(hdh((σ↑x), k))),set(par(tlh((σ↑x), k))))
the next step is to build a transition system based on a particular state func-
tion. the state space is given by all the states visited in the log when assuming
the representation chosen. the transition relation can be derived by assuming
that one can go from one state to another if this occurs in at least one of the
traces in the log.3.3 constructing a transition system (step 1a)
in this section, we give a general deﬁnition of a transition system , which is based
on the notion of state presented in deﬁnition 5.
deﬁnition 6 (transition system). letabe a set of activities and let l∈
p(a∗)be an event log . given a state function as deﬁned before, we deﬁne a
labeled transition system ts= (s, e, t )where s={state (σ, k)|σ∈l∧0≤
k≤ |σ|}is the state space, e=ais the set of events (labels) and t⊆s×e×s
witht={(state (σ, k), σ(k+ 1),state (σ, k+ 1)) |σ∈l∧0≤k <|σ|}is the
transition relation.
this deﬁnition shows that we can build diﬀerent transition systems depending
on the type of state representation selected. note that we identiﬁed more than
36 types in section 3.2. the algorithm for constructing a transition system is
straightforward: for every trace σ, iterating over k(0≤k≤ |σ|), we create a
new state state (σ, k) if it does not exist yet. then the traces are scanned for
transitions state (σ, k−1)σ(k)− →state (σ, k) and these are added if it does not exist
yet5. it is worth mentioning that when dealing with the states based on the
complete preﬁx, a transition system can be constructed eﬀectively online just
while reading a log.
as an example, let us take the following log:
l=

/angbracketlefta, b, c, d /angbracketright,
/angbracketlefta, c, b, d /angbracketright,
/angbracketlefta, e, c, e, c, d /angbracketright

(1)
if we use the complete preﬁx set deﬁnition of a state, i.e. state (σ, k) =
set(par(hd(σ, k))), we get the transition system shown in figure 8. every state
consists of a set of activities and every transition is labeled with a name of an
activity. this transition system contains two self-loop transitions {a, c, e }e→
{a, c, e }and{a, c, e }c→ {a, c, e }. if we use the complete preﬁx sequence
representation of a state, i.e. state (σ, k) = hd(σ, k), we obtain another tran-
sition system as shown in figure 9. for this transition system, every state is
represented by a sequence of activities (for example /angbracketlefta, e, c, e /angbracketright). as is easy
to see, this transition system does not contain any self-loops anymore. in fact,
the complete preﬁx sequence representation of a state always results in acyclic
transition systems. another example of a transition system generated based on
the example log is shown in figure 10. this one is based on the complete postﬁx
multi-set deﬁnition of a state.
3.4 modiﬁcations (step 1b)
transition systems, which are constructed according to the algorithm given in
the previous section, reﬂect the behavior seen in the log. however, often the log
5note that the elements of tare often denoted as s1e→s2instead of ( s1, e, s 2).{}
{a}
{a,b} {a,c}
{a,c,b}
{d,a,c,b}{a,e}
{a,c,e}
{d,a,c,e}a
bc
cb
de
c
de cfig. 8. a transition system constructed us-
ing complete preﬁx sets.
<>
<a>
<a,b> <a,c>
<a,b,c>
<a,b,c,d><a,e>
<a,e,c>
<a,e,c,e>a
b c
cb
de
c
e
<a,e,c,e,c>c
<a,e,c,e,c,d>d<a,c,b>
<a,c,b,d>dfig. 9. a transition system constructed us-
ing complete preﬁx sequences.
{a,b,c,d}
{b,c,d}
{b,d} {c,d}
{d}
{}a
c
bc
de{a,e2,c2,d}
{e2,c2,d}a
{e,c2,d}
{e,c,d}c
eb
fig. 10. a transition system constructed
using complete postﬁx multi-sets.
{}
{a}
{a,b} {a,c}
{a,c,b}
{d,a,c,b}{a,e}
{a,c,e}
{d,a,c,e}a
bc
cb
de
c
dfig. 11. a transition system that is made
acyclic using the “kill loops” strategy.does not contain all the possible traces and, thus, represents only a part of the
possible behavior. in the other cases, we need to further abstract from the log
data, introduce generalizations , or even ignore some unnecessary details. so, in
this section, we present the main operations which make up a framework for
building “clever” modiﬁcation strategies and show some examples of them.
letts= (s, e, t ) be a transition system constructed for some log l∈
p(a∗) using a particular state function. the main operations for building strate-
gies are:
addarc operation addarc (s1, a, s 2) adds a new transition to the transition
relation t, i.e., an arc labeled aconnecting state s1to state s2.ts/prime=
(s, e, t/prime) with t/prime=t∪ {(s1, a, s 2)}is the transition system with an added
arc (assuming ( s1, a, s 2)/negationslash∈t).
removearc operation removearc (s1, a, s 2) removes a transition. ts/prime= (s, e, t/prime)
with t/prime=t\ {(s1, a, s 2)}is the transition system without this arc (assum-
ing (s1, a, s 2)∈t).
mergestates operation mergestates (s1, s2) creates a new state s12=s1+s2.
for any state s,ti
s={(s/prime, a, s/prime/prime)∈t|s/prime/prime=s}is the set of incoming
transitions, to
s={(s/prime, a, s/prime/prime)∈t|s/prime=s}is the set of outgoing transitions,
andts=ti
s∪to
sis the set of all incident transitions. the transition system
resulting from operation mergestates (s1, s2) ists/prime= (s/prime, e, t/prime) with s/prime=
(s\ {s1, s2})∪ {s12},t/prime= (t\(ts1∪ts2))∪tnew) , where tnew=
{(s, a, s 12)| ∃s/prime(s, a, s/prime)∈ti
s1∪ti
s2} ∪ { (s12, a, s)| ∃s/prime(s/prime, a, s)∈to
s1∪to
s2}.
next, we present some useful strategies, and show how they can be ap-
plied to our examples. note that these strategies can be used in combination
with the many strategies deﬁned for the state representation. moreover, these
are just examples showing that the addarc (s1, a, s 2),removearc (s1, a, s 2), and
mergestates (s1, s2) operations can be used to “massage” the transition system
before constructing a process model from it.
“kill loops” strategy the “kill loops” strategy is used for ignoring the loops
and, thus, for building acyclic transition systems. when a set representation is
used, typically self-loops are introduced (whenever an activity is executed for the
second time a self-loop is created). see for example the ts shown in figure 8 that
has two self-loop transitions {a, c, e }e→ {a, c, e }and{a, c, e }c→ {a, c, e }.
letts= (s, e, t ) be a transition system where self-loops need to be removed.
ts/prime= (s, e, t/prime) with t/prime={(s1, a, s 2)∈t|s1/negationslash=s2}is the resulting transition
system. a transition system derived after applying this strategy to the set-based
transition system given in figure 8 is shown in figure 11.
the “kill loops” strategy is motivated that in some cases one is interested
only in the occurrence of an activity and not the ordering of activities or the
frequency of an activity. hence, sets are used to represent states. however, a side-
eﬀect of the set representation is the introduction of self-loops for activities that
can occur multiple times. these can eﬀectively be removed using this strategy
(but this changes the initial behaviour).{}
{a}
{a,b} {a,c}
{a,c,b}
{d,a,c,b}{a,e}
{a,c,e}
{d,a,c,e}a
bc
cb
dec
defig. 12. result of applying the extend
strategy.
<>
<a>
<a,b> <a,c>
<a,b,c,a,c,b,
a,e,c,e,c>
<a,b,c,d,a,c,b,d,
a,e,c,e,c,d><a,e,
a,e,c,e>
<a,e,c>a
bc
cb
de
c
cefig. 13. result of applying the merge
states strategy.
“extend” strategy the “extend” strategy is especially useful for the logs
having a set representation. let ts= (s, e, t ) be a transition system where
this strategy has to be applied. ts/prime= (s, e, t/prime) with t/prime=t∪ {(s1, a, s 2)∈
s×e×s|s1∪{a}=s2∧a /∈s1}is the resulting transition system. basically,
this strategy makes transitions between two states, which were created from
diﬀerent traces but which can be subsequent because there is a single activity
which can be executed to reach one state from the other. this strategy is very
useful for generalizing the behavior seen in the logs by means of extending the
“state diamonds”, i.e., interleavings are added to allow for the deduction of
parallel constructs. an example of this strategy applied to the acyclic transition
system of figure 11 is shown in figure 12. a transition {a, c}e→ {a, c, e }was
added here. it should be noted that a combination of strategies is used, i.e., both
“kill loops” and “extend” are applied to the original transition system shown
in figure 8.
the motivation for the “extend” strategy is that, in many cases, it is unre-
alistic that all possible interleavings of activities are actually present in the log.
when discussing the notion of completeness, we demonstrated that this is in-
deed a problem (section 2.3). therefore, the “extend” strategy in a way extends
the transition system with interleavings not observed in the log but likely to be
present based on the structure. the “extend” strategy is often used in combina-
tion with a set representation of states. this representation seems natural when
in each activity some artifact, e.g. a document, is produced. in this case, the
state refers to the set of artifacts produced so far, e.g., all documents that have
been checked in. in this context the assumption of the “extend” strategy is that
it is possible to move from one state to anther if there is a diﬀerence of a single
document, i.e., if {a1, . . . , a n}and{a1, . . . , a n, an+1}are reachable states, then
there is a transition from {a1, . . . , a n}to{a1, . . . , a n, an+1}.“merge by output” strategy another useful strategy is called “merge by
output”. it merges the states that have the same outputs. this strategy is espe-
cially useful for dealing with loop constructs. let ts= (s, e, t ) be a transition
system. for any state slet us deﬁne an operation out(s) ={a∈e|(s, a, s/prime/prime)∈
t}, which returns the set of output events of a state. let us deﬁne a predi-
cate ismerge ⊆s×ssuch that for any s1, s2∈s:ismerge (s1, s2) if and
only if out(s1) =out(s2). ifismerge (s1, s2), then s1ands2are merged onto a
new state. mts={(s1, s2)|ismerge (s1, s2)}contains all the pairs of states
that can be merged. for any pair of states ( s1, s2)∈mts, we can execute a
mergestates (s1, s2) operation, which produces a new transition system ts/prime, ac-
cording to the deﬁnition given above. based on this new transition system ts/prime,
we can again calculate all the pairs of states that can be merged mts/prime. again a
pair of states is selected and merged using the mergestates operation. this is
repeated until there are no more states to be merged.
there are several ways to reﬁne the ismerge predicate. for example, function
outcould be reﬁned to not only take into account the output event but also
the output state. another reﬁnement would be to avoid merging states if this
introduces loops, e.g., we can redeﬁne the predicate ismerge to:ismerge (s1, s2)
if and only if out(s1) =out(s2) and ∄a, b∈e: (s1, a, s 2)∈tor (s2, a, s 1)∈
t, or there exists an s/prime/primesuch that ( s/prime/prime, a, s 1),(s/prime/prime, b, s 2)∈t. the additional
requirements are given to prohibit building self-loops and multiple arcs between
a pair of states in a transition system after merging.
if we take the sequence-based transition system shown in figure 9 and as-
sume the more reﬁned ismerge predicate, the set mtsincludes pairs such as
(/angbracketlefta, e/angbracketright,/angbracketlefta, e, c, e /angbracketright), (/angbracketlefta, b, c /angbracketright,/angbracketlefta, e, c, e, c /angbracketright), (/angbracketlefta, b/angbracketright,/angbracketlefta, e, c, e /angbracketright),
and ( /angbracketlefta, b, c, d /angbracketright,/angbracketlefta, e, c, e, c, d /angbracketright). note that after merging a pair of states,
the set mts/primeof the new transition system ts/primewill be diﬀerent from mts. so,
starting with merging the pair ( /angbracketlefta, e/angbracketright,/angbracketlefta, e, c, e /angbracketright), and then producing new
transition system and merging the states there, ﬁnally (when no states can be
merged) we produce a transition system shown in figure 13.
in our example, we use only the “merge by output” strategy; but in gen-
eral, the strategies based on equality of inputs and subsets of outputs or inputs
are very helpful for simplifying the transition system and solving the problem
of “loops”. in this section, we deﬁned the basic framework for building strate-
gies and presented the motivating examples of their potential for simplifying
the transition systems. however, in future, further ideas about strategies, their
combinations and their applications should be worked out.
clearly, the three strategies presented in this section (“kill loops”, “ex-
tend”, and “merge by output”) are just examples. moreover, even for these
three strategies many variants exist. it is also important to note that the suit-
ability of a strategy heavily depends on the state representation selected. there
are numerous combinations possible, some of which work better than others de-
pending on the characteristics of the event logs at hand. this diﬀerentiates our
approach for existing approaches which typically propose a single algorithm that
cannot be conﬁgured to address diﬀerent needs.4 synthesis using regions (step 2)
in this section, we present the second step of our approach. in this second step a
petri net is synthesized from the transition system resulting from the ﬁrst step.
to do this we use the “theory of regions” [21, 15, 12].
4.1 constructing petri nets using regions
first, we give the classical deﬁnition of a region .
deﬁnition 7 (region). letts= (s, e, t )be a transition system and s/prime⊆s
be a subset of states. s/primeis aregion if for each event e∈eone of the following
conditions hold:
1. all the transitions s1e→s2enter s/prime, i.e. s1/∈s/primeands2∈s/prime,
2. all the transitions s1e→s2exits/prime, i.e. s1∈s/primeands2/∈s/prime,
3. all the transitions s1e→s2do not cross s/prime, i.e. s1, s2∈s/primeors1, s2/∈s/prime
in figure 14, we continue the example of the sets-based transition sys-
tem with killed loops (see figure 11) and present several examples of regions.
the set r0={{}} is a region, since all the transitions labeled with aexit
it and all other labels do not cross. it is important to see that r0is a set of
states containing one state being the empty set. r1={{a},{a, c}}is a re-
gion, since aenters it, bandeexit it and candddo not cross it; r2=
{{a, b},{a, e},{a, c, b },{a, c, e }}andr3={{d, a, c, b },{d, a, c, e }}are
two other examples of regions, they are also marked with dotted lines in the ﬁg-
ure.
any transition system ts= (s, e, t ) has two trivial regions: ∅(the empty
region) and s(the region consisting of all states). in the remainder we only
consider non-trivial regions.
a region r/primeis said to be a subregion of the other region rifr/prime⊂r. for
example, r0andr1are subregions of region r={{},{a},{a, c}}. a region r
isminimal if there is no other region r/primewhich is a subregion of r. for example,
both r0andr1are minimal regions; in figure 14, the set of regions marked
with dotted lines is the set of all the minimal regions of the ts. a region ris a
preregion of event eif there is a transition labeled with ewhich exits r. a region
ris apostregion of event eif there is a transition labeled with ewhich enters r.
for example, r0is a preregion of aandr1is a postregion of a.
for petri net synthesis, a region corresponds to a petri net place and an
event corresponds to a petri net transition . thus, the main idea of the synthesis
algorithm is the following: for each event ein the transition system a transition
labeled with eis generated in the petri net. for each minimal region ria place
piis generated. the ﬂow relation of the petri net is built the following way:
e∈p•
iifriis a preregion of eande∈•piifriis a postregion of e. an example
of a petri net synthesized from our transition system is given in figure 15. the
incoming place of the transition acorresponds to the minimal region r0and the{}
{a}
{a,c} {a,b}
{a,c,b}
{d,a,c,b}{a,e}
{a,c,e}
{d,a,c,e}a
cb
b c
de
c
dr1r0
r2
r3r4
r5 r2fig. 14. regions in the transition system.
ab
ce d
r0r1
r4r3
r5r2
fig. 15. synthesized pn (algorithm for el-
ementary ts).
ab
ce dfig. 16. synthesized pn (algorithm for
non-elementary ts).
outgoing place of awhich is also the incoming place for transitions bande
corresponds to the region r1respectively.
the ﬁrst papers on the theory of regions only dealt with a special class of
transition systems called elementary transition systems . see [15, 7, 8] for details.
the class of elementary transition systems is very restricted. in practice, most of
the time, people deal with arbitrary transition systems that only by coincidence
fall into the class of elementary transition systems. in the papers of cortadella
et al. [11, 12], a method for handling any transition system was presented. this
approach uses labeled petri nets , i.e., diﬀerent transitions can refer to the same
event. for this approach it has been shown that the reachability graph of the
synthesized petri net is bisimilar to the initial transition system.
in our example, the ts shown in fig. 14 is not an elementary transition
system, whereas the synthesis algorithm described before produces appropriate
results for the elementary ones. thus, the pn in fig. 15 allows for more behavior
than we have seen in the ts. the result of applying the algorithm of cortadella
et al. is shown in fig. 16, it exactly corresponds to the ts from fig. 14 .most of the transition systems shown in the examples from section 3 are not
elementary. however, from a practical point of view this is just a technicality
that can easily be resolved. in the remainder of this paper, we build our ap-
proach on the approach of cortadella et al. [12]. we start our examples with
the petri nets synthesized from the basic transition systems, which were con-
structed in section 3.3. the petri net shown in figure 17 was synthesized from
the transition system shown in figure 8 and the petri net in figure 18 from
figure 9 correspondingly.6both petri nets reﬂect the behaviour seen in the log
(logs can be successfully replayed in this petri nets), but they also have some
disadvantages: the ﬁrst petri net is too general, because transitions candecan
be executed an unlimited number of times; the second petri net is too explicit,
since for the last trace (see the log used for the running example) it allows only
the sequence /angbracketlefta, e 1, c, e, c, d /angbracketrightthat is presented in the log, but not the loop
construct.
ab
c_1e_1
c_2d
c e
d_1
fig. 17. petri net for the transition system
based on sets.
ab
ce_1
defig. 18. petri net for transition system
based on sequences.
the next set of examples shows some modiﬁed transition systems constructed
using the various strategies described earlier. the petri net synthesized from the
acyclic set-based transition system from figure 11 (obtained after applying the
“kill loops” strategy) is shown in figure 16. it is compact and exactly reﬂects
the behaviour from the log, but ignores the loop. the petri net that corresponds
to the extended transition system is shown in figure 19, it supports additional
behaviour, for example it also allows for the trace /angbracketlefta, c, e, d /angbracketright. the last petri
net is shown in figure 20. this petri net is derived from the sequence-based
transition system, where the “merge by output” strategy was applied. this petri
net speciﬁes the behaviour seen in the log, but also recognizes the loop.
4.2 selecting the target format
in this section, we deal with diﬀerent target formats of synthesized petri nets.
we use various synthesis algorithms to derive petri nets in diﬀerent ways and
6the petri nets shown are labeled, so transitions denoted like e, e 1, e2, . . .all refer
to the same event e.ab
ce dfig. 19. petri net for the extended transi-
tion system.
ab
c_1e_1e
c_2d cfig. 20. petri net for the transition system
after state merging.
to produce diﬀerent classes of petri nets, such as free choice, extended free-
choice, pure, state-machine decomposable and others. the algorithms synthesize
labeled petri nets and they are based on transition label splitting . this way, the
petri nets, which can be huge and diﬃcult to understand, can be converted and
simpliﬁed. here, we use the algorithms developed in the work of cortadella et
al. [11, 12], as they generally deal with labeled petri nets.
as described in section 4.1, the algorithms of cortadella et al. deal not only
with elementary but also with the full class of transitions systems. so, all the al-
gorithms check whether a transition system is elementary and split appropriate
labels in case it is not elementary; the splitting is based on the notions of excita-
tion andgeneralized excitation region , see [11]. the simplest synthesis algorithm
generates a petri net from all the regions, this net is called a saturated net . an
improvement of this algorithm is generating a minimal saturated net , which is
based on all the minimal regions. however, both algorithms produce nets with
redundant places , i.e. some places can be removed without changing the behav-
ior. building a place-irredundant net with minimal regions is a challenging task,
which can be solved by assigning costs to diﬀerent solutions based on minimal
regions and ﬁnding the optimal one. so, the algorithm, which was used for all
the examples presented above generates a subset of all the minimal regions of
a transition system, which is suﬃcient for petri net synthesis. all the obtained
petri nets are place-irredundant .
ab
c_1e d c
fig. 21. pure petri net.
ab_1
c_1e d
bc fig. 22. free-choice petri net.as mentioned above, the algorithms support synthesis of diﬀerent classes of
petri nets and it is possible to control the type of the constructed net. for exam-
ple, we can generate alternative representations for the set-based petri net shown
in figure 16. using the settings of the synthesis algorithm, we can construct the
pure7petri net shown in figure 21. to make the net pure, transition chad to
be split to exclude “self-loops”. next, we can build a free-choice8equivalent for
it, see figure 22. transition bhad to be split to exclude the choice between b
ande, which coincided with the synchronization for e.
in this section, we presented the second step of our approach. we demon-
strated a method for deriving petri nets from transition systems constructed
from the event logs. we have shown the beneﬁts of using the well developed
theory of regions and petri net synthesis in the area of process mining.
5 implementation and evaluation
the ideas presented in this paper have been implemented in the context of
prom . prom serves as a testbed for our process mining research [19] and can be
downloaded from www.processmining.org. starting point for prom is the mxml
format. this is a vendor-independent format to store event logs. information as
shown earlier in tabular form can be stored in mxml. one mxml ﬁle can
store information about multiple processes. for each process, events related to
particular process instances (often called cases) are stored. each event refers to
an activity. in the context of this paper documents are mapped onto activities.
events can also have additional information such as the transaction type (start,
complete, etc.), the originator (the resource, e.g., person, that executed the ac-
tivity, in this paper often referred to as the “author”), timestamps (when did
the event occur), and arbitrary data (attribute-value pairs).
5.1 promimport
the promimport framework [23] allows developers to quickly implement plug-
ins that can be used to extract information from a variety of systems and convert
it into the mxml format (cf. promimport.sourceforge.net). there are standard
import plug-ins for a wide variety of systems, e.g., workﬂow management sys-
tems like staﬀware, case handling systems like flower, erp components like
peoplesoft financials, simulation tools like aris and cpn tools, middleware
systems like websphere, bi tools like aris ppm, etc. moreover, it is been
used to develop many organization/system-speciﬁc conversions (e.g., hospitals,
banks, governments, etc.). as will be shown later, the promimport framework
can also be used to extract event logs from systems such as subversion and cvs
(concurrent versions system) [23].
7a petri net p n= (p, t, f ) is called pure if ( p, t)∈fimplies that ( t, p)/∈f, i.e.
the petri net has no self-loops.
8a petri net p n= (p, t, f ) is called free-choice if ∀p∈p:|p•| ≤1 or•(p•) ={p},
i.e. the petri net does mixtures of choice and synchronization.5.2 prom and petrify
once the logs are converted to mxml, prom can be used to extract a variety
of models from these logs. prom provides an environment to easily add so-
called “plug-ins” that implement a speciﬁc mining approach. although the most
interesting plugins in the context of this paper are the mining plugins, it is
important to note that there are in total ﬁve types of plug-ins:
mining plug-ins which implement some mining algorithm, e.g., mining algo-
rithms that construct a petri net based on some event log, or that construct
a transition system from an event log.
export plug-ins which implement some “save as” functionality for some ob-
jects (such as graphs). for example, there are plug-ins to save epcs, petri
nets, spreadsheets, etc.
import plug-ins which implement an “open” functionality for exported ob-
jects, e.g., load petri nets that are generated by petrify.
analysis plug-ins which typically implement some property analysis on some
mining result. for example, for petri nets there is a plug-in which constructs
place invariants, transition invariants, and a coverability graph.
conversion plug-ins which implement conversions between diﬀerent data for-
mats, e.g., from epcs to petri nets and from petri nets to yawl and bpel.
in subsection 5.3, we illustrate the application of the plug-ins developed in
the context of this paper. however, since there are currently more than 140 plug-
ins it is impossible to give a representative overview. one of these more than 140
plug-ins is the mining plug-in that generates the transition system that can be
used to build a petri net model. note that, for this particular approach, prom
calls petrify [12] to synthesize the petri net, which is a command-line tool for the
synthesis of petri nets from transition systems. petrify is freely available from
http://www.lsi.upc.edu/petrify/ and it implements the algorithms developed by
cortadella et al. [11, 12].
5.3 comparison
while it is impossible to evaluate the possibilities of the region-based approach
against all process mining algorithms implemented in prom, we do evaluate it
against two important mining algorithms: the α-algorithm [5] and multi-phase
algorithm [17, 18]. for this comparison, we use an example of a log taken from
a driving school. in this driving school, learners start by applying for a license.
then, in parallel, they take a theoretical exam, as well as driving lessons for
either car or motorbike. after ﬁnishing the theoretical exam and the lessons,
they take a practical exam, after which they do or do not receive a license.
note that it is only possible to do a practical exam for cars if the learner had
car driving lessons and vice versa for a motorbike exam. for the comparison,
we used a complete process log, i.e. a process log that showed all four possible
executions of this process, namely car and bike combined with getting or not
getting a license.(a)
(b)
(c)
fig. 23. prom, showing three petri nets, discovered using (a) the αminer, (b) the multi-phase miner and (c) the petrify-based approach.the ﬁrst algorithm we used to generate a petri net was the α-algorithm.
theα-algorithm is a well-known process discovery algorithm, which is often
used for benchmarking. the reason for this is that it is a simple algorithm that
typically produces nice results if the log satisﬁes certain properties (cf. [5]). for
our example however, the result, shown in figure 23(a), has two problems. first
of all, the resulting model allows for a learner to take car driving lessons and
a motorbike exam. second, after taking an exam, the learner always gets his
license, which is even more undesirable.
since our log does not satisfy all requirements of the α-algorithm, we use the
multi-phase algorithm presented in [17, 18]. this algorithm guarantees to return
a petri net that can reproduce the log. as can be seen from figure 23(b), it
solves the problem that a learner always receives a license after the exam albeit
in a rather complicated way. however, the petri net still allows the learner to
take lessons in a car and an exam on a motorbike.
this dependency between two transitions that are not directly following each
other is typically hard to ﬁnd by process mining algorithms. the genetic ap-
proach presented in [2, 27] is capable of ﬁnding such dependencies, but since
that approach is based on genetic algorithms, it has high demands on computa-
tion time.
the result of the region-based approach presented in this paper is presented
in figure 23(c). it is clear that this petri net indeed correctly models the process
under consideration.
although the example in this section looks rather simple, it nicely shows
that the region based approach is a valuable addition to the existing collection
of process discovery algorithms. however, as with any process discovery algo-
rithm trade-oﬀs are made with respect to the correctness of the result and the
computation time. the α-algorithm and the multi-phase approach are compu-
tationally fast9, the theory of regions approach is more complex, since it has a
worst-case complexity that is exponential in the size of the log. however, the
result of our approach is more accurate, since it also catches long-range depen-
dencies, that are not detected by the multi-phase approach, nor the α-algorithm,
i.e. it does not underﬁt. moreover, a very important feature of the approach pre-
sented in the paper is that it is “tunable”, i.e., the settings can be modiﬁed to
achieve the desired result.
the results presented in this paper have been implemented in prom and
can be downloaded from www.processmining.org. in the next section, we dis-
cuss related work and provide pointers to other algorithms many of which are
implemented in prom.
9the multi-phase approach is polynomial in the size of the log and the α-algorithm
exponential in the size of an abstraction of the log, which can be built in polynomial
time.6 related work
since the mid-nineties several groups have been working on techniques for process
mining [5, 6, 9, 13, 17, 18, 35], i.e., discovering process models based on observed
events. in [4] an overview is given of the early work in this domain. the idea to
apply process mining in the context of workﬂow management systems was intro-
duced in [6]. in parallel, datta [13] looked at the discovery of business process
models. cook et al. investigated similar issues in the context of software engi-
neering processes [9]. herbst [24] was one of the ﬁrst to tackle more complicated
processes, e.g., processes containing duplicate tasks.
most of the classical approaches have problems dealing with concurrency.
theα-algorithm [5] is an example of a simple technique that takes concurrency
as a starting point. however, this simple algorithm has problems dealing with
complicated routing constructs and noise (like most of the other approaches
described in literature). in [17, 18] a more robust but less precise approach is
presented.
in this paper we do not consider issues such as noise. heuristics [35] or genetic
algorithms [2, 27] have been proposed to deal with issues such as noise. it appears
that some of the ideas presented in [35] can be combined with other approaches,
including the one presented in this paper.
the second step in our approach uses the theory of regions [7, 8, 11, 12, 21].
this way, transition systems can be mapped onto petri nets using synthesis. ini-
tially the theory could be applied only to a restricted set of transition systems.
however, over time the approach has been extended to allow for the synthe-
sis from any ﬁnite transition system. in this paper we use petrify [10] for this
purpose. the idea to use regions has been mentioned in several papers. how-
ever, only recently people have been applying regions to process mining [26].
it is important to note that the focus of regions has been on the synthesis of
models exactly reproducing the observed behavior (i.e., the transition system).
an important diﬀerence with our work is that we try to generalize and deduce
models that allow for more behavior, i.e., balancing between “overﬁtting” and
“underﬁtting” is the most important challenge in process mining research.
process mining can be seen in the broader context of business process in-
telligence (bpi) and business activity monitoring (bam). in [22, 33] a bpi
toolset on top of hp’s process manager is described. the bpi toolset includes
a so-called “bpi process mining engine”. in [29] zur muehlen describes the
pisa tool which can be used to extract performance metrics from workﬂow
logs. similar diagnostics are provided by the aris process performance man-
ager (ppm) [25]. the tool is commercially available and a customized version
of ppm is the staﬀware process monitor (spm) [34] which is tailored towards
mining staﬀware logs. it should be noted that bpi tools typically do not allow
for process discovery and oﬀer relatively simple performance analysis tools that
depend on a correct a-priori process model.7 conclusion
this paper presented a new two-step process mining approach. it uses innovative
ways of constructing transition systems and regions to synthesize process models
in terms of petri nets. using this approach, it is possible to discover process mod-
els that adequately describe the behavior recorded in event logs. these logs may
come from a variety of information systems e.g., systems constructed using erp,
wfm, crm, scm, and pdm software. the application is not limited to repet-
itive administrative processes and can also be applied to development processes
and processes in complicated professional/embedded systems. moreover, process
mining is suitable for the monitoring of interacting web services.
existing approaches typically provide a single process mining algorithm, i.e.,
they assume “one size ﬁts all” and cannot be tailored towards a speciﬁc ap-
plication. the power of our approach in this paper is that it allows for a wide
variety of strategies. first of all, we deﬁned 36 diﬀerent strategies to represent
states. a state can be very detailed or more abstract. selecting the right state
representation aids in balancing between “overﬁtting” (i.e., the model is over-
speciﬁc and only allows for the behavior that happened to be in the log) and
“underﬁtting” (i.e., the model is too general and allows for unlikely behavior).
besides selecting the right state representation strategy, it is also possible to
further “massage” the transition system using strategies such as “kill loops”,
“extend”, and “merge by output”. using the theory of regions, the resulting
transition system is transformed into an equivalent petri net. also in this phase
diﬀerent settings can be used depending on the desired end-result (using the
functionality of petrify). this makes the approach much more versatile than the
approaches described in literature.
the approach has been implemented in prom and the resulting process min-
ing tool can be downloaded from www.processmining.org.
future work is aiming at a better support for strategy selection and new
synthesis methods. the fact that our two-step approach allows for a variety
of strategies makes it very important to support the user in selecting suitable
strategies depending on the characteristics of the log and the desired end-result.
we also think that by merging the two steps we can develop innovative synthesis
methods. the theory of regions aims at developing an equivalent petri net while
in process mining a simple less accurate model is more desirable than a complex
model that is only able to reproduce the log. hence it is interesting to develop
a “new theory of regions” tailored towards process mining.
8 acknowledgements
this research is supported by eit, nwo-ew, and the technology foundation
stw. moreover, we would like to thank the many people involved in the devel-
opment of prom.references
1. w.m.p. van der aalst. the application of petri nets to workﬂow management.
the journal of circuits, systems and computers , 8(1):21–66, 1998.
2. w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. genetic
process mining. in g. ciardo and p. darondeau, editors, applications and theory
of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
48–69. springer-verlag, berlin, 2005.
3. w.m.p. van der aalst, h.a. reijers, and m. song. discovering social networks
from event logs. computer supported cooperative work , 14(6):549–593, 2005.
4. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
5. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
6. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
7. e. badouel, l. bernardinello, and p. darondeau. the synthesis problem for ele-
mentary net systems is np-complete. theoretical computer science , 186(1-2):107–
134, 1997.
8. e. badouel and p. darondeau. theory of regions. in w. reisig and g. rozenberg,
editors, lectures on petri nets i: basic models , volume 1491 of lecture notes in
computer science , pages 529–586. springer-verlag, berlin, 1998.
9. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
10. j. cortadella, m. kishinevsky, a. kondratyev, l. lavagno, and a. yakovlev. pet-
rify: a tool for manipulating concurrent speciﬁcations and synthesis of asynchro-
nous controllers. ieice transactions on information and systems , e80-d(3):315–
325, march 1997.
11. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. synthesizing petri
nets from state-based models. in proceedings of the 1995 ieee/acm interna-
tional conference on computer-aided design (iccad ’95) , pages 164–171. ieee
computer society, 1995.
12. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets
from finite transition systems. ieee transactions on computers , 47(8):859–882,
august 1998.
13. a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275–301,
1998.
14. j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
15. j. desel and w. reisig. the synthesis problem of petri nets. acta informatica ,
33(4):297–315, 1996.
16. j. desel, w. reisig, and g. rozenberg, editors. lectures on concurrency and petri
nets, volume 3098 of lecture notes in computer science . springer-verlag, berlin,
2004.17. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362–376. springer-verlag, berlin, 2004.
18. b.f. van dongen and w.m.p. van der aalst. multi-phase mining: aggregating
instances graphs into epcs and petri nets. in d. marinescu, editor, proceedings of
the second international workshop on applications of petri nets to coordination,
workﬂow and business process management , pages 35–58. florida international
university, miami, florida, usa, 2005.
19. b.f. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters,
and w.m.p. van der aalst. the prom framework: a new era in process mining
tool support. in g. ciardo and p. darondeau, editors, application and theory
of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
444–454. springer-verlag, berlin, 2005.
20. m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.
21. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315–368, 1989.
22. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321–343, 2004.
23. c. guenther and w.m.p. van der aalst. a generic import framework for process
event logs. in j. eder and s. dustdar, editors, business process management
workshops, workshop on business process intelligence (bpi 2006) , volume 4103
oflecture notes in computer science , pages 81–92. springer-verlag, berlin, 2006.
24. j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
25. ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
26. e. kindler, v. rubin, and w. sch¨ afer. process mining and petri net synthesis. in
j. eder and s. dustdar, editors, business process management workshops , volume
4103 of lecture notes in computer science , pages 105–116. springer-verlag, berlin,
september 2006.
27. a.k.a. de medeiros. genetic process mining . phd thesis, eindhoven university
of technology, eindhoven, 2006.
28. a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workﬂow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science , pages
389–406. springer-verlag, berlin, 2003.
29. m. zur m¨ uhlen and m. rosemann. workﬂow-based process monitoring and con-
trolling - technical and organizational issues. in r. sprague, editor, proceedings
of the 33rd hawaii international conference on system science (hicss-33) , pages
1–10. ieee computer society press, los alamitos, california, 2000.
30. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
31. a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 163–176. springer-verlag, berlin,
2006.
32. a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. faideiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420–425. springer-verlag, berlin, 2006.
33. m. sayal, f. casati, u. dayal, and m.c. shan. business process cockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb’02) ,
pages 880–883. morgan kaufmann, 2002.
34. tibco. tibco staﬀware process monitor (spm). http://www.tibco.com, 2005.
35. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.