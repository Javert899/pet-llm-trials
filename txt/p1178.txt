model independent error bound estimation for
conformance checking approximation
mohammadreza fani sani1, martin kabierski2, sebastiaan j. van zelst3;1, and
wil m.p. van der aalst1;3
1process and data science chair, rwth aachen university, aachen, germany
2department of computer science, humboldt-universit at zu berlin, berlin, germany
3fraunhofer fit, birlinghoven castle, sankt augustin, germany
ffanisani,s.j.v.zelst,wvdaalst g@pads.rwth-aachen.de,
martin.bauer@hu-berlin.de
abstract conformance checking techniques allow us to quantify the
correspondence of a process's execution, captured in event data, w.r.t.,
a reference process model. in this context, alignments have proven to be
useful for calculating conformance statistics. however, for extensive event
data and complex process models, the computation time of alignments
is considerably high, hampering their practical use. simultaneously, it
suces to approximate either alignments or their corresponding con-
formance value(s) for many applications. recent work has shown that
using subsets of the process model behavior leads to accurate confor-
mance approximations. the accuracy of such an approximation heavily
depends on the selected subset of model behavior. thus, in this paper,
we show that we can derive a priori error bounds for conformance check-
ing approximation based on arbitrary activity sequences, independently
of the given process model. such error bounds subsequently let us select
the most relevant subset of process model behavior for the alignment
approximation. experiments conrm that conformance approximation
accuracy improves when using the proposed error bound approximation
to guide the selection of relevant subsets of process model behavior.
keywords: process mining Â·conformance checking approximation Â·
alignments Â·edit distance Â·instance selection Â·sampling
1 introduction
the execution of processes in companies leaves digital event data footprints in
the databases of the information systems employed, known as event logs .process
mining [1] aims to develop techniques that enhance the overall knowledge of the
process by analyzing such event logs, e.g., by automatically discovering process
models based on the event log. conformance checking [2], i.e., one of the main
sub-elds of process mining, aims at assessing to what degree a given process
model and the recorded event data conform to one another. in this context,
alignments [3], an established class of conformance checking artifacts, are of
particular interest, as they provide an exact quantication of deviations betweenarxiv:2103.13315v1  [cs.se]  23 mar 20212 mohammadreza fani sani et al.
process model m
generates event logprocess p
describes 
language 
lexact conformance checkingexact conformance checkingconformance checking
error boundsconformance checking
error bounds
Ï‰ 
arbitrary finite  proxy -set Ï‰ arbitrary finite  proxy -set Ï‰ relevant 
finite subset
finiteÏ‰ this paper â€™s contribution
possibly infinite 
possibly infinite 
finite
finitemodelsmodels
definesquantifies
figure 1: overview of the proposed approach and its relation to existing work.
a process model mmodels a process pthat generates an event log l. existing
approaches either compute exact orapproximate conformance checking results
based on the language of the model l(m) (or a nite subset thereof). we propose
a method that quanties error bounds for conformance checking approximation,
based on an arbitrary proxy-set 
.
the recorded process execution and its intended behavior, as modeled by the
process model.
the increasing prevalence of information systems in dierent domains leads
to a drastic increase in the amount of recorded event data [4]. such high-volume
event data , combined with complex process models, yield infeasible alignment
computation times, hampering their practical use. yet, in many applications, ex-
act alignment values are not required, i.e., it suces to obtain an approximated
value to draw meaningful conclusions. for example, in genetic process discov-
ery [5], various generations of candidate process models are evaluated w.r.t. an
event log. due to the complexity of alignment computation, computing exact
alignment results for each candidate process model is impractical. however, in
each generation, rather than obtaining an exact alignment result to judge the
process model quality, it is sucient to know whether a newly generated process
model improves its alignment results with respect to that of previous generations.
therefore, fast alignment approximation techniques, that provide guarantees on
the approximation error are of particular interest.
recently, various approaches for alignment approximation have been pro-
posed [6, 7]. in our previous work [6], we exploit subsets of the process model's
behavior for approximation, i.e., by using the subset of process behavior as amodel independent error bound estimation 3
representative for the complete process model behavior. in this way, we are able
to provide bounds for the approximated alignment value. this branch of approx-
imation techniques shows promising results; however, the approximation result's
quality (i.e., the dierence between actual and approximated value) heavily de-
pends on the selected subset of process model behavior. therefore, quantifying
an approximation's quality based on a specic subset of model behavior prior to
performing the actual approximation allows us to identify the most appropriate
subset to use for said approximation. in this paper, we present a novel approach
to quantify an alignment approximations quality before performing the actual
approximation.
consider fig. 1 (page 2), in which we present a schematic overview of the
approach. a process model mmodels a process pthat generates a digital event
logl. existing approaches compute exact orapproximate conformance checking
results by considering the language of the model l(m) (possibly innite), or, a
relevant nite subset thereof. the proposed method allows us to a-priori compute
error bounds for alignment approximation, using an arbitrary proxy-set 
, i.e., a
set of sequence of activities. this proxy-set 
can be used to derive the relevant
subset of process model behavior lf(m) and may consist of behavior that is
not part of the model nor the event log.
we evaluated our error bound estimation technique using various real event
logs. our experiments conrm a strong correlation between the predicted max-
imum error bounds and the eventual approximation error. as such, our exper-
iments conrm that the conformance approximation accuracy improves when
using the proposed error bound approximation to guide the selection of relevant
subsets of process model behavior. furthermore, our experiments show that the
error bounds' computation time is negligible w.r.t. computing conventional exact
alignments.
the remainder of this paper is structured as follows. in section 2, we discuss
related work. in section 3, we present preliminaries and basic notation. we
explain the main methodology of our approach in section 4 and subsequently
evaluate it in section 5. finally, section 6 concludes this work.
2 related work
several process mining techniques exist, ranging from process discovery to pro-
cess performance prediction. here, we cover related work in the eld of confor-
mance checking and corresponding approximation techniques. we refer to [1] for
an extensive overview and introduction of process mining.
conformance checking techniques have been well studied. in [8], the authors
review the various conformance checking techniques in the process mining do-
main. similarly, in [2], dierent methods for conformance checking and its ap-
plications are covered. alignments were introduced in [9] and have rapidly de-
veloped into the standard conformance checking technique. in [10,11], decompo-
sition techniques are proposed for improving the performance of the alignment
computation. applying decomposition techniques improves computation time.4 mohammadreza fani sani et al.
however, these techniques are able to improve the performance of alignment
computation, if there are numerous unique activities in the process [12]. re-
cently, general approximation schemes for alignments, i.e., computation of near-
optimal alignments, have been proposed [13]. finally, the authors in [7] propose
to incrementally compute prex-alignments, i.e., enabling real-time conformance
checking for event data streams.
a limited amount of work considers the use of sampling in process mining.
in [14], the authors recommend a trace-based statistical sampling method to
decrease the required discovery time and memory footprint. moreover, in [15],
we analyzed random and biased sampling methods with which we are able to
adjust the size of the sampled data for process discovery.
some research has focused on alignment approximation. in [16], deep learn-
ing is used to approximate alignment statistics. in [17], the authors propose to
incrementally sample the event log and applying conformance checking on the
sampled data. the proposed method increases the sample size until the approx-
imated value is accurate enough. the authors of [18] propose a conformance ap-
proximation method that applies relaxation labeling methods on a partial order
representation of a process model, which needs to preprocess the process model
each time. unlike these approaches that do not provide bounds for the approx-
imation, some methods have proposed to generate a subset of model behaviors
using instance selection [6] and simulation [19]. [6] has proposed to compute
alignments of some instances in the event log and use the corresponding model
behavior for approximating the alignment of other instances.
in this paper we prove that by having a subset of model behaviors, we can
estimate the approximation error for any process model, thus helping users to
adjust the approximation setting. furthermore, we propose some instance selec-
tion methods to decrease approximation error.
3 preliminaries
this section briey introduces basic conformance checking terminology and the
notation used in this paper. we assume that the reader has a basic knowledge
of sets, bags (multisets), cartesian products functions, and sequences.
we letb(x) denote the set of all possible bags over x. given
b2b(x),b=fxjb(x)>0g.xdenotes the set of all sequences over x.
letx0xand let2x,#x0returns the projected sequence of
on setx0, e.g.,ha;b;c;b;di#fb;dg=hb;b;di. letx1;x2;:::;xnbe
narbitrary sets and let x1x2xndenote the corresponding
cartesian product. let 2(x1x2xn)be a sequence of tuples,
i() returns the sequence of elements in at position 1in, e.g.,
2(h(x1
1;x1
2;:::;x1
n);(x2
1;x2
2;:::;x2
n);:::;(xjj
1;xjj
2;:::;xjj
n)i=hx1
2;x2
2;:::xjj
2i.
given;02x,(;0)2n0represents the longest common subsequence
(lcs) edit distance (only using insertions and deletions ) betweenand0,
i.e., the minimum number of edits required to transform into0. for exam-
ple,(hw;x;yi;hx;y;zi)=2. note that (;0)=(0;) (is symmetrical) andmodel independent error bound estimation 5
table 1: simple example of an event log. rows capture events recorded in the
context of the execution of the process.
case-id event-id activity name starting time finishing time ...
...............:::
7 35 register(a) 2020-01-02 12:23 2020-01-02 12:25 :::
7 36 analyze defect(b) 2020-01-02 12:30 2020-01-02 12:40 :::
7 37 inform user(g) 2020-01-02 12:45 2020-01-02 12:47 :::
7 38 repair(simple)(c) 2020-01-02 12:45 2020-01-02 13:00 :::
8 39 register(a) 2020-01-02 12:23 2020-01-02 13:15 :::
7 40 test repair(e) 2020-01-02 13:05 2020-01-02 13:20 :::
7 41 archive repair(h) 2020-01-02 13:21 2020-01-02 13:22 :::
8 42 analyze defect(b) 2020-01-02 12:30 2020-01-02 13:30 :::
..................
(;00)(;0)+(0;00) (triangle inequality applies to ). given a sequence
2xand a set of sequences sx, we dene (;s)= min
02s(;0).
event logs, i.e., collections of events representing the execution of several
instances of a process, are the starting point of process mining algorithms. an
example event log is shown in table 1. events record when an activity was per-
formed (according to their starting and finishing time ) for an instance of the
process (represented by the case-id column). for some applications, e.g., align-
ment computation, only the control-ow information , i.e., sequences of activities
executed in the context of a process instance, is required. hence, we adopt the
aforementioned mathematical model of an event log (in practice however, event
data typically records much more features related to the executed activities, e.g.,
resource information and costs of activities).
denition 1 (event log). letdenote the universe of activities . atrace
is a sequence of activities ( 2). an event logl2b()is a bag of traces.
process models are used to describe the (expected) behavior of a process.
process models come in various forms, i.e., ranging from simple conceptual draw-
ings to mathematical concepts with associated execution semantics, e.g., petri
nets [20] or bpmn diagrams [21]. for example, in fig. 2, we show process model
m1in bpmn notation. the model describes that the rst activity in the process
should be a, followed by activities band care in parallel. it is possible to skip
activity c. after the execution of activity b, if we execute activity d, we should
again execute b. activity enalizes the process. in this paper's context, we do
not assume a specic modeling notation; rather, we assume process models to
describe a collection of sequences of activities.
denition 2 (process model). letdenote the universe of activities. a
process model mdescribes the intended behavior of a process. we refer to the
behavior described by model mas its language;l(m), i.e., a non-empty
collection of activity sequences.
for the given process model m1in fig. 2, we have
l(m1)=fha;b;ei;ha;b;c;ei;ha;c;b;ei;ha;b;d;b;ei;:::g. note that, due to
the existence of loops, the language of a process model may be innite.6 mohammadreza fani sani et al.
ab d
ce
Â»bde
abÂ»ealignment
figure 2: an example of a process model m1(in bpmn notation) and a simple
event logl1(represented in multiset-view). the optimal alignment of the last
trace of the event log and the process model is shown in the middle of the gure.
to quantify whether an event log conforms to a process model, we use align-
ments. an alignment between a trace and a model describes which events in the
trace can be \aligned with activities described by the process model". further-
more, alignments indicate whether an event cannot be explained by the model
or whether an activity as described by the model was not observed. in fig. 2,
an alignment of trace hb;d;ei, and the given process model is provided. observe
that the trace does not contain activity a, which should always be present ac-
cording to the model. in the alignment, this is visualized by the rst column
a.
similarly, after the observed d-activity, no second b-activity was observed. as
such, in this alignment, the occurrence of dis rendered obsolete, i.e., visualized
asd
. we formally dene alignments as follows.
denition 3 (alignment). letdenote the universe of activities, let mbe
a process model with corresponding language ;l(m)and let2be a
trace. an alignment ofandm, is a sequence, characterized as 2(([f
g)([fg )), s.t.,1()#=and2()#2l(m). the set of all possible
alignments of trace and model language l(m)is denoted as  (;l(m)).
in the context of this paper, given 2 (;l(m)), we write '()=2()#to re-
fer to the \model trace" corresponding to . letc: ([fg )([fg )!r,
then, given 2,mand2 (;l(m)), we let c()=p
1ijjc((i))
denote the cost of alignment . we let ?
c(;l(m))= arg min
2 (;l(m))c() be
the set of optimal/minimal alignments . we letzc(;l(m))= min
2 (;l(m))c()
be the optimal alignment cost for trace and model m(hence:
82 ?
c(;l(m)) (c()=zc(;l(m)))). in the remainder, we assume that
crepresents the standard cost function , i.e.,c(a;)=c(;a)=1;8a2,
c(a;a)=0;8a2andc(a;a0)=1;8a6=a02, and we omit it as a subscript.
4 alignment error bound estimation
in this section, we show how to estimate maximal alignment approximation error
bounds. we rst show that edit distance can be used to compute conventionalmodel independent error bound estimation 7
optimal alignments. subsequently, we use this result to show that we are able to
quantify the maximum alignment approximation error for an arbitrarily given
activity sequence. finally, we show that we can guarantee tighter approximation
bounds by exploiting a collection of arbitrary activity sequences.
4.1 computing the maximal alignment approximation error
in this section, we show that, for given traces ;02and process model m,
(;0) quanties a range for the optimal alignment value z(;l(m)), when
usingz(0;l(m)) as an estimator for z(;l(m)). we rst show that for the
standard cost function, we are able to use the lcs edit distance function to
compute the cost of the optimal alignment.
lemma 1 (edit distance quanties alignment costs). letdenote
the universe of activities, let 2be a trace, let mbe a process model and let
2 ?(;l(m))be an optimal alignment of andm. using the standard cost
function,()=(;'())
proof. observe that only contains elements of the form (a;a),(a;)and
(;a). letrdenote the set of elements of the form (a;)and letidenote
the set of elements of the form (;a). transforming into'()is achieved by
removing activities in represented by the elements in rand inserting activities
inrepresented by the elements in i. hence,()=r+i. similarly, (;'())
represents the minimum number of insertions and removals to transform into
'(). thus, if()<(;'()), then(;'())does not represent the minimal
number of edits. similarly, if ()>(;'())thenis not optimal. 
corollary 1 ( (;l(m))equalsz(;l(m))).letdenote the universe of
activities, let 2be a trace, let mbe a process model with corresponding lan-
guage;l(m). using the standard cost function, z(;l(m))=(;l(m)).
proof. let2 ?(;l(m)).
z(;l(m))=()=(;'())=(;l(m)). 
in the following, we show that it is possible to exploit an arbitrary activity
sequence to derive a range on another activity sequence's alignment value.
theorem 1 (edit distance provides approximation bounds). let
;02be two traces and let mbe a process model with corresponding lan-
guage;l(m). the optimal alignment value z(;l(m)), is within(;0)
ofz(0;l(m)), i.e.,z(0;l(m)) (;0)z(;l(m))z(0;l(m))+(;0).
proof. let2 ?(;l(m))and let02 ?(0;l(m)). triangle inequality of lcs
edit distance yields (;'(0))(;0)+(0;'(0)), which we can rewrite (
lemma 1) to (;'(0))(;0)+z(0;l(m)). sincez(;l(m))(;'(0)),
we have:z(;l(m))z(0;l(m))+(;0).
similarly, (0;'())(;0)+(;'()). again, we deduce
(0;'())(;0)+z(;l(m)). sincez(0;l(m))(0;'()), we deduce
z(0;l(m)) (;0)z(;l(m)). hence, we obtain z(0;l(m)) (;0)
z(;l(m))z(0;l(m))+(;0). 8 mohammadreza fani sani et al.
for example, reconsider process model m1and event log l1in fig. 2.
observe that z(ha;c;c;b;d;ei;l(m1))=2 and(ha;c;c;b;d;ei;ha;c;b;d;ei)=1.
hence, we deduce 1 z(ha;c;b;d;ei;l(m1))3. ifz(ha;c;c;b;d;ei;l(m1)) is un-
known,(ha;c;c;b;d;ei;ha;c;b;d;ei)=1 implies that using it as an estimator for
z(ha;c;b;d;ei;l(m1))yields a maximal absolute approximation error of 1.
4.2 generating proxy-sets
the result of theorem 1 implies that, given a process model mand traces
;02, when using z(0;l(m)) as an estimator for z(;l(m)), we obtain
an approximation error (;0). interestingly, the bound on is determined
independently of the model. furthermore, 0is allowed to be an arbitrary se-
quence, i.e., it is perfectly ne if 0=2l(m), and, given some l2b() s.t.2l,
0=2l. hence, given an arbitrary set of sequences 
, arg min
02
(;0) repre-
sents the members of 
that minimize the expected maximum error when using
z(0;l(m)) as an estimator (i.e., for 02arg min
02
(;0)). in the remainder, we
refer to such a set of sequences 
as a proxy-set , i.e., we intend to \align
by proxy through 
".
observe that, for an event log l2b() and proxy-set 
,
82l
min
02
(;0)=0
,
l, i.e., if every member of the log has an edit
distance of 0 w.r.t. the proxy-set, then every member of the event log is a mem-
ber of the proxy-set (and vice versa). clearly, in such a case, using proxy-set 
yields optimal alignments, yet, at the same (or even worse) time and memory
complexity as computing conventional optimal alignments.
in the remainder, given an event log l2b() and proxy-set 
, we let

(l)=p
2ll()min
02
(;0). given two proxy-sets 
;
0,
dominates

0for event log lif and only if 
(l)
0(l) andj
j<j
j0. in such a case,
we refer to 
0as a redundant proxy-set. a proxy-set 
isk-optimal for event
loglif and only if8
02(j
0j=k=)
(l)
0(l)). ak-optimal proxy-set

isk-primal ifj
j=k. for example, 
=lisjlj-primal, 1-optimal, 2-optimal,
:::,jlj-optimal. furthermore, it is easy to see that any ( k-primal) proxy-set 
withj
j>lis dominated by land hence redundant. more interestingly, primal
proxy-sets that are smaller than the event log are never redundant.
theorem 2 (primal proxy-sets are non-redundant). letl2b()be
an event log and let 
be a proxy-set such that j
j<jljand
isk-primal .

isnon-redundant .
proof. assume that 
is redundant. hence, 9
0(j
0j<j
j^
0(l)
(l)).
however, observe that, we are able to create 
00=
0[l00withjl00j=j
j j
0jand
2l00=)2l^=2
0(note thatj
j=j
00j). observe that 
00(l)<
0(l)and
as a consequence 
00(l)<
(l), contradicting the fact that 
isk-primal. 
observe that theorem 2 implies that for any event log l2b() and
k21;2;:::jlj, there exists a k-primal proxy-set 
. ak-primal proxy-set min-
imizes the maximal possible error bound, and hence, can be regarded as themodel independent error bound estimation 9
optimal proxy-set to use of size k. however, providing such proxy-sets is usually
np-hard. in the upcoming paragraphs, we briey introduce various proxy-set
generation methods and their relation to primal proxy-sets.
sampling proxy-sets can be generated using sampling methods: either sampling
members for the input event log, the given process model, or a mixture thereof.
in previous work, we investigated sampling of model behavior using uniform
distributions [6] and event-log-guided process model simulation [19].
strictly sampling the behavior from the process model, i.e., 
l(m),
particularly when using event-log-guided simulation yields (under standard
cost function) z(0;l(m))=0;802
. on the one hand, it is very un-
likely that such a proxy-set is k-primal. on the other hand, the fact that
z(0;l(m))=0;802
, can be exploited. for example, given some trace 2l
and some02arg min
02
(;0), rather than using z(0;l(m)) (i.e., value 0) as an
estimator for z(;l(m)), one can use(;0)
2. hence, the maximal approximation
error is reduced by half.
sampling
from the event log is likely to result in a proxy-set that is closer
to ak-primal solution, i.e., in particular when prioritizing sampling of 2lwith
highl() values. hence, using event log-based sampling typically yields smaller
values for the maximal obtainable approximation error. however, since the actual
z(0;l(m)) for02
is unknown, we cannot tighten the estimator.
centroid-based clustering for a given target size k, the best possible ob-
tainable proxy-set is k-primal . as an alternative approach to sampling, clustering
algorithms [22] are a suitable proxy-set selection mechanism. a clustering algo-
rithm groups a set of objects into subgroups (clusters) such that the members
of a cluster are similar/close, given some similarity/distance metric. in the case
of proxy-set generation, the edit distance serves as a distance metric. centroid-
based clustering algorithms , i.e., algorithms that dene clusters using a central
object (the centroid), are of particular interest. in centroid-based clustering, the
algorithms assign the objects to the centroid objects that are at a minimal dis-
tance of the object. as an example, the k-medoids algorithm [23] uses objects
from the object set as centroids and minimzizes the pair-wise dissimilarity of the
objects and the centroids. clearly, several variations of centroid-based clustering
algorithms can be used. whereas the clustering algorithms can be applied on an
arbitrary set of activity sequences, applying them on the input event log yields
proxy-sets that are close to the k-primal solution.
4.3 deriving exact alignment approximation bounds
thus far, given sequence 2and process model m, we have shown that a
proxy-set
and proxy-sequence 02
quantify the maximum approximation
error , when using z(0;l(m)) as an estimator for z(;l(m)). in this section,
we show that we can exploit proxy-sets to derive exact approximation bounds .10 mohammadreza fani sani et al.
when approximating alignments using proxy-set 
, we rst compute the
alignments of the proxy-set traces (i.e., 02
). we derive the upper and
lower bound of the alignment cost of z(;l(m)) by simply adding/subtracting
(;0) toz(0;l(m)). observe that, when using the standard cost function,
the lower bound of any alignment is bounded, i.e., it cannot be lower than 0.
furthermore, in certain cases, it is possible to derive a tighter lower-bound.
letm=fa2j92l(m)(a2)g, then, for any 2, it is easy to see that
z(;l(m))j#nmj, i.e., the elements of #nmare always moves of the
forma
. furthermore, in case jj<min
02l(m)j0j, we need at least j0j jj(where
02arg min
02l(m)j0j) moves of the form
a. hence, the theoretical lower-bound of
any2is equal to max(0 ;min
02l(m)(j0j) jj)+j#nmj. we correspondingly
dene the
-driven lower and upper bound as follows.
denition 4 ( 
-driven alignment bounds). letdenote the universe of
activities, let mbe a process model with corresponding language ;l(m)
and let
be a proxy-set. we let >
;m:!ndenote the
-driven upper
bound and we let ?
;m:!ndenote the
-driven lower bound where:
>
;m()= min
02
(z(0;l(m))+(;0)) (1)
?
;m()= max(max(0 ;min
02l(m)(j0j) jj)+j#nmj;max
02
(z(0;l(m)) (;0)))
(2)
finally, given>
;m and?
;m, we quantify the alignment approximation value
of2, i.e., ^z
(;l(m)), as ^z
(;l(m))=>
;m() ?
;m()
2. theoretically, it
is possible to give dierent weights to lower and upper bounds. however, nding
the best weight is not the scope of this paper.
5 evaluation
in this section, we explore the accuracy and the performance of our proposed
method. first, we briey describe the implementation, after which we explain
the experimental setting. finally, we report on the experimental results.
implementation to apply the proposed conformance approximation method,
we implemented the conformance approximation plug-in in the prom [24] frame-
work1, including various proxy-set generation methods (both sampling and
centroid-based clustering, cf. section 4.2).
1svn.win.tue.nl/repos/prom/packages/logfilteringmodel independent error bound estimation 11
table 2: statistics regarding the real event logs that are used in the experiment.
event log activities traces variants df#
bpic- 2012 [25] 23 13087 4336 138
bpic- 2018-inspection [26] 15 5485 3190 67
bpic- 2019 [27] 42 251734 11973 498
hospital-billing [28] 18 100000 1020 143
road [29] 11 150370 231 70
sepsis [30] 16 1050 846 115
5.1 experimental setup
we applied the proposed methods to six real event logs. basic information, e.g.,
the number of distinct activities, traces, and variants, of the event logs used,
is given in table 2. for each event log, we apply conformance checking using
dierent process models. to obtain these process models, we used the inductive
miner [31] process discovery algorithm, with infrequent thresholds equal to 0 :2,
0:4, and 0:6. typically, these models describe a strict subset of the input event
log. we used four dierent proxy-set generation methods, all using the event log
as a primary driver, i.e., random sampling ,frequency-based sampling ,k-medoids
clustering and k-center clustering . in random sampling, we randomly sample
variants (without replacement) from the event log to act as a proxy. in frequency-
based sampling, we select traces based on their l()-values, in descending order.
in k-medoids clustering, centroids are determined by minimizing the pair-wise
dissimilarity. in k-center clustering, the maximum distance between centroids
and the objects is minimized. to determine the size of proxy-sets we use a
dierent percentage of the number variants in the event logs, i.e., 5%, %10,
20%, 30%, 50%. moreover, we have repeated each experiment four times as
some results are non-deterministic.
using the described experimental setup, we investigate the relationship be-
tween the maximum error,i.e.,p
2l(l()min
02
(;0)) and the eventual approx-
imation error, as well as the performance of the approach.
5.2 results
in this section, we discuss the results of the experiments. we rst investigate
the relationship between the estimated maximum error and the actual approx-
imation error. secondly, we investigate the time-performance of the estimation.
lastly, we investigate the role of the new proposed lower bound.
estimated maximum error versus approximation error observe that
minimizing the expected maximum error does not guarantee a minimal ap-
proximation error. for example, given some model m,2,
=f1;2gand

0=f1;3g, assume that (;1)=2,(;2)=3 and(;3)=1. clearly, the
maximal error based on 
is 2, and, based on 
0, it is 1. as such, we intuitively
favor
0over
. however, if z(1;l(m))=7,z(2;l(m))=2 andz(1;l(m))=6,12 mohammadreza fani sani et al.
figure 3: scatter plots of the estimated maximum error bounds and the real
approximation error using dierent proxy-set generation methods.
we obtain?
;m()=>
;m()=5, whereas?
0;m()=5 and>
0;m()=7.
hence, from 
, we derive that z(;l(m))=5 (note ^ z
(;l(m))=5), whereas
from
0, we derive 5z(;l(m))7 (with ^z
0(;l(m))=6). thus, using 
to
derive the alignment approximation value actually yields the exact alignment
value using 
0yields an error of 1.
given that there is no causal relation, we investigate, using the described
proxy-set generation methods and event logs, the strength of the correlation
between the estimated maximum error and the eective approximation error
when using the proxy-set. in fig. 3, we show the scatter plots of these two
values, for each method, using dierent colors for the dierent event logs. more-
over, the corresponding pearson correlation coecients are presented in table 3.
table 3: pearson correlation coe-
cients between the estimated bounds
and the real approximation errors for
dierent methods and event logs.
interestingly, for frequency-based
sampling, k-center, and k-medoids, we
observe a strong correlation between the
estimated maximal approximation error
and the eective approximation error.
for random sampling, as expected, the
correlation is less strong, particularly for
the hospital-billing and road logs. for
all event logs, the highest correlation is
achieved by the k-center method.
in fig. 4, we show the eect of choos-
ing dierent proxy-set generation methods and dierent percentages of variants
in the event log on the accuracy of approximated alignment costs. as we expect,
the k-center and k-medoids approaches provide the highest accuracy. there-
fore, using these approaches, we are able to generate more suitable proxy-sets
and consequently obtain more accurate approximations. moreover, results indi-
cate that the alignment cost error is reduced by increasing the proxy-sets' size
(i.e., the selection percentage). however, for some event logs, specically if the
variants in the event log are similar, this reduction is not always signicant, i.e.,
by just using a few trace-variants we already obtain an accurate approximation.
thus, the approximation's provided bounds help users adjust the setting more
eciently, as a user may make the choice of increasing the proxy set size, thus
increasing the accuracy of approximation.model independent error bound estimation 13
figure 4: eect of increasing the selected percentage of variants on approximated
alignments' accuracy for dierent methods.
conformance checking performance improvement here, we analyze the
time performance of dierent proxy-set generation methods. figures fig. 5a
and fig. 5b show the conformance checking performance improvement using the
proposed approach. to compute the performance improvement pi, we divide
conventional alignment computation time by the alignment approximation time
(both including and excluding proxy-set generation time). a higher pi-value
indicates a higher performance improvement and a pi-value less than 1 indicates
that there is no improvement. the greatest improvement (when we consider the
proxy generation time) is achieved by using the frequency-based method as it
quickly selects variants and generates the proxies. the random method has a
lowerpi-value because it may select some variants that usually need more time
to compute their alignments. furthermore, the results indicate that by increasing
the percentage of the size of proxies, the performance improvement is reduced. in
some cases, we do not improve the performance when the proxy generation time
is considered. thus, it is crucial to avoid selecting too many traces as a proxy.
generally, the proxy generation time for k-center and k-medoids methods is
high, especially when the z size of proxy is high. but, if we separate the proxy
generation time (that is possible in some applications as explained in section 1),
we improve the conformance checking procedure's performance.
eciency of the proposed lower bound finally, in the last ex-
periment, we analyze the role of the lower bound without m0, i.e.,
max(0;min
02l(m)(j0j) jj)+j#nmjand the lower bound that uses
m0, i.,e., max
02
(z(0;l(m)) (;0))) in computing the nal lower
bound. table 4 shows the percentage of traces that have higher val-
ues using the dierent bounds. in case the highest value is returned
by both methods, we consider both of them as the used bound.14 mohammadreza fani sani et al.
(a) performance improvement with consideration of proxy-set generation time.
(b) performance improvement without consideration of proxy selection time.
figure 5: eect of increasing the selected percentage of variants on performance
improvement of dierent proxy selection methods.
table 4: average percentage
of times that lower bounds
have the highest value.
the results show that in most cases, it is su-
cient to use the lower bound, which is based on the
proxy-set and its alignments. consequently, using
the new proposed method for bound computation,
we will have tighter bounds.
6 conclusion
in this paper, we propose to select a set of traces,
compute their alignments and use these to approx-
imate the alignments of other traces in the event log. furthermore, we have
shown that we can derive bounds for the so-introduced approximation error,model independent error bound estimation 15
independently of the model. additionally, we prove that based on the selected
traces (i.e., a proxy-set), we can provide a bound for the approximation error
that helps users estimate the approximation error and thus aids in selecting an
appropriate proxy set. the experiments on the real event logs indicate, that by
using the proposed instance selection methods, we are able to reduce the max-
imum and the average error in the alignment cost approximation. besides, by
increasing the number of the selected traces, the average possible error is re-
duced. but, for certain event logs, this reduction is not signicant, which shows
we are able to select a few traces and have an accurate approximation.
we used the approximation solutions for k-center and k-medoids problems
in this work. however, it is useful for some applications to compute optimal
solutions and nd the best k variants. moreover, it is benecial to provide an
incremental approach that keeps selecting the traces until we guarantee a tight
bound for the approximation error.
references
1. van der aalst, w.m.p.: process mining - data science in action, second edition.
springer berlin heidelberg (2016)
2. carmona, j., van dongen, b., solti, a., weidlich, m.: conformance checking.
springer (2018)
3. adriansyah, a., munoz-gama, j., carmona, j., van dongen, b., van der aalst,
w.m.p.: alignment based precision checking. in: international conference on
business process management, springer (2012) 137{149
4. giacalone, m., cusatelli, c., santarcangelo, v.: big data compliance for innovative
clinical models. big data res. 12(2018) 35{40
5. buijs, j.c., van dongen, b., van der aalst, w.m.p.: on the role of fitness,
precision, generalization and simplicity in process discovery. in: otm, " on the
move to meaningful internet systems", springer (2012) 305{322
6. fani sani, m., van zelst, s.j., van der aalst, w.m.p.: conformance checking
approximation using subset selection and edit distance. in: 32nd international
conference, caise 2020, grenoble, france, june 8-12, 2020, proceedings. volume
12127., springer (2020) 234{251
7. van zelst, s.j., bolt, a., hassani, m., van dongen, b.f., van der aalst, w.m.: on-
line conformance checking: relating event streams to process models using prex-
alignments. international journal of data science and analytics (2017) 1{16
8. elhagaly, m., drvoderi c, k., kippers, r.g., bukhsh, f.a.: evolution of compli-
ance checking in process mining discipline. in: 2nd international conference on
computing, mathematics and engineering technologies (icomet), ieee (2019)
1{6
9. van der aalst, w.m.p., adriansyah, a., van dongen, b.f.: replaying history
on process models for conformance checking and performance analysis. wiley
interdiscip. rev. data min. knowl. discov. 2(2) (2012) 182{192
10. van der aalst, w.m.p.: decomposing petri nets for process mining: a generic
approach. distributed and parallel databases 31(4) (2013) 471{507
11. munoz-gama, j., carmona, j., van der aalst, w.m.p.: single-entry single-exit
decomposed conformance checking. information systems 46(2014) 102{12216 mohammadreza fani sani et al.
12. verbeek, h.m.w., van der aalst, w.m.p., munoz-gama, j.: divide and conquer: a
tool framework for supporting decomposed discovery in process mining. comput.
j.60(11) (2017) 1649{1674
13. taymouri, f., carmona, j.: a recursive paradigm for aligning observed behavior of
large structured process models. in: international conference on business process
management, springer (2016) 197{214
14. bauer, m., senderovich, a., gal, a., grunske, l., weidlich, m.: how much event
data is enough? a statistical framework for process discovery. in: international
conference on advanced information systems engineering, springer (2018) 239{
256
15. fani sani, m., van zelst, s.j., van der aalst, w.m.p.: improving the performance
of process discovery algorithms by instance selection. comput. sci. inf. syst. 17(3)
(2020) 927{958
16. nolle, t., seeliger, a., thoma, n., m uhlh auser, m.: deepalign: alignment-based
process anomaly correction using recurrent neural networks. in: international con-
ference on advanced information systems engineering, springer (2020) 319{333
17. bauer, m., van der aa, h., weidlich, m.: estimating process conformance by trace
sampling and result approximation. (2019) 179{197
18. padr o, l., carmona, j.: approximate computation of alignments of business pro-
cesses through relaxation labelling. in: international conference on business pro-
cess management, springer (2019) 250{267
19. fani sani, m., garza gonzalez, j.j., van zelst, s.j., van der aalst, w.m.p.: con-
formance checking approximation using simulation. in van dongen, b.f., montali,
m., wynn, m.t., eds.: 2nd international conference on process mining, icpm
2020, padua, italy, october 4-9, 2020, ieee (2020) 105{112
20. petri, c.a., reisig, w.: petri net. scholarpedia 3(4) (2008) 6477
21. chinosi, m., trombetta, a.: bpmn: an introduction to the standard. comput.
stand. interfaces 34(1) (2012) 124{134
22. xu, d., tian, y.: a comprehensive survey of clustering algorithms. annals of data
science 2(2) (2015) 165{193
23. park, h., jun, c.: a simple and fast algorithm for k-medoids clustering. expert
syst. appl. 36(2) (2009) 3336{3341
24. van der aalst, w.m.p., van dongen, b., g unther, c.w., rozinat, a., verbeek, e.,
weijters, t.: prom: the process mining toolkit. bpm (demos) 489(31) (2009)
25. van dongen, b.f. (boudewijn): bpi challenge 2012 (2012)
26. van dongen, b.f. (boudewijn), borchert, f. (florian): bpi challenge 2018 (2018)
27. van dongen, b.f. (boudewijn): bpi challenge 2019 (2019)
28. mannhardt, f.: hospital billing-event log. eindhoven university of technology.
dataset (2017) 326{347
29. de leoni, m., mannhardt, f.: road trac ne management process. eindhoven
university of technology. dataset (2015)
30. mannhardt, f.: sepsis cases-event log. eindhoven university of technology (2016)
31. leemans, s.j., fahland, d., van der aalst, w.m.p.: discovering block-structured
process models from event logs containing infrequent behaviour. in: bpi. (2014)
66{78