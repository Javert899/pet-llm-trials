strategies for modeling complex processes
using colored petri nets
wil m. p. van der aalst, christian stahl, and michael westergaard
department of mathematics and computer science,
technische universiteit eindhoven, the netherlands.
fw.m.p.v.d.aalst,c.stahl,m.westergaard g@tue.nl
abstract. colored petri nets (cpns) extend the classical petri net for-
malism with data, time, and hierarchy. these extensions make it possible
to model complex processes as cpns without being forced to abstract
from relevant aspects. moreover, cpns are supported by cpn tools|a
powerful toolset that supports the design and analysis of such processes.
the expressiveness of the cpn language enables dierent modeling ap-
proaches. typically, the same process can be modeled in numerous ways.
as a result, inexperienced modelers may create cpns that are unnec-
essarily convoluted and bulky. using a running example and a set of
design patterns, we show how to solve typical design problems in terms
of cpns. by following these guidelines, it is possible to create succinct,
but also comprehensible, models. in addition, we present some new fea-
tures supported by cpn tools 3.0 (e.g., priorities and real time stamps)
and show how the software can be used for performance analysis (i.e.,
comparing design alternatives using simulation).
keywords: colored petri nets, design patterns, cpn tools
1 introduction
petri nets have been around for about half a century and have shown to be able
to model concurrent processes adequately. the basic formalism is simple and
enables powerful analysis techniques. however, it is not easy to model complex
processes in terms of classical petri nets. therefore, many extensions of the basic
formalism have been proposed in the literature [1,13,14,15,17,18,19,20,22,23,30].
in fact, hundreds of extensions have been proposed for classical petri nets, and it
is impossible to name them all here. some of the extensions proposed are rather
exotic and did not progress beyond a proposal on paper (i.e., no tool support
and no practical applications), whereas other extensions are widely supported
and frequently used. despite the many proposals, there seems to be consensus
on the need for three types of extensions :
{the extension with data. in the classical petri net, two tokens cannot be
distinguished. the only way to distinguish two tokens is to put them in
separate places. this is not practical for realistic applications as the modelquickly becomes extremely complex and potentially innitely large. in fact,
for most practical applications of petri nets, we would like the tokens to be
distinguishable and have particular characteristics (e.g., age, weight, price,
value, owner, or address). for a token modeling a car, we may want to
describe its brand, model, color, or license number. therefore, we need to
add data to the basic model. without this extension, petri nets are like a
programming language without variables and parameters.
{the extension with hierarchy. no matter how expressive a modeling language
is, models tend to become large because in most applications there are many
entities that interact in a nontrivial manner. therefore, a hierarchy concept
is needed to deal with this type of complexity. when designing a model one
would like to use a divide-and-conquer approach. moreover, structuring a
model is essential when communicating design choices and analysis results
with stakeholders. without hierarchy, petri nets are like a programming
language lacking subroutines and subprocedures.
{the extension with time. petri nets are often used to model processes where
time plays an important role. for example, activities take time or exception
handling is required after a timeout. these temporal aspects should be re-
ected in the model. durations may be deterministic or stochastic. in the
latter case, the model typically also incorporates routing probabilities such
that performance analysis comes into reach. in many application domains it
is important to use models to predict response times, utilization, ow times,
and service levels.
although there is consensus on the need to support data, hierarchy, and time for
practical applications of petri nets, dierent proposals have been made. some of
the dierences between competing proposals are mainly syntactical; for example,
cpn tools is using ml as an inscription language [19,24] whereas exspect is
using a dedicated functional language [3,15]. other dierences are more relevant;
for example, the hierarchy concept used in cpn tools (transition renement) is
very dierent from the nets-in-nets paradigm used by renew [21,30].
colored petri nets (cpns) are the most widely used formalism incorporat-
ing data, hierarchy, and time [6,17,18,20,19]. initially, cpns were supported by
design/cpn . later, design/cpn was replaced by cpn tools .1currently, cpn
tools is by far the most widely used petri net tool. cpn tools supports the
design of complex processes and the analysis of such processes using state-space
analysis and simulation.
modeling complex processes in terms of cpns is a nontrivial task. the ex-
pressiveness of the language allows for dierent styles of modeling; that is, the
same process can be modeled in dierent ways. modeling is \an art rather than
a science", but there are recurring modeling problems that can be solved by
applying design patterns .
the most well-known patterns collection in the it domain is the set of de-
sign patterns documented by gamma, helm, johnson, and vlissides [12]. this
1seehttp://cpntools.org .collection describes a set of problems and solutions frequently encountered in
object-oriented software design. the success of the patterns described in [12]
triggered many patterns initiatives in the it eld, including the workow pat-
terns initiative [4,32]. the idea to use a patterns-based approach originates from
the work of the architect christopher alexander. in [7], he provided rules and
diagrams describing methods for constructing buildings. the goal of the patterns
documented by alexander is to provide generic solutions for recurrent problems
in architectural design. the idea to use patterns for design problems in the
it domain is appealing as is reected by the dierent collections of patterns
[4,5,10,12,16,29,31,32]. many of these collections focus on behavioral aspects as
these are most dicult to model and implement.
the idea to provide patterns for modeling in terms of cpns was rst pro-
posed in [26]. based on expert opinions and an analysis of large collections
of cpns (taken from papers and web pages), 34 patterns were identied (see
appendix). these patterns help to tackle particular problems. each pattern is
described using a standard format including elements such as pattern name, in-
tent, motivation, problem description, solution, implementation considerations,
examples, and related patterns. in this paper, we explain the most important
patterns using a running example. unlike in [25,26], we do not explicitly enu-
merate the patterns nor will we use a strict format to present them. instead,
we use a tutorial-style presentation showing how to address frequently recurring
modeling problems.
for a detailed description of the cpn language we refer to [18,19]. our
goal is not to describe the language but to focus on the way it can be used
most eciently. this paper is based on lectures given by the authors during the
5th summer school/advanced course on petri nets (rostock, september 2010).
hence, the goal is not to present new scientic results, but to guide people
using the cpn language and cpn tools. in addition, the paper presents recent
extensions of cpn tools. as of cpn tools 3.0, priorities and real time stamps
are supported. we shall show that these extensions provide additional support
when tackling some of the most important design patterns.
in the last part of the paper, we focus on one particular analysis technique:
simulation . we shall show that the timing concept used by cpns is compelling
and gives the designer full control over temporal aspects of the model. moreover,
cpn tools provides a powerful simulation environment. using our running ex-
ample, we shall show that it is easy to compare dierent alternative models.
the remainder of this paper is organized as follows. section 2 introduces the
basics of cpns. the focus is on the extension with data, that is, colored tokens.
as a running example, we use a gas station that serves two types of customers.
the extension with hierarchy is described in sect. 3. subsequently, we use dif-
ferent variants of the gas station to explain four of the simple design patterns
(sect. 4) and two of the more advanced design patterns (sect. 5). the hierarchy
concept is used to structure these patterns while the patterns themselves focus
on the interplay between control-ow and data. here, we also show how the pri-
ority concept of cpn tools 3.0 can be used to simplify the realization of some ofthe patterns. in sect. 6, we shift our attention to modeling of time. we explain
the time concept and highlight the new timing functionality of cpn tools 3.0
(i.e., real time). subsequently, sect. 7 shows how the addition of stochastic ele-
ments can be used to simulate complex processes and analyze their performance.
section 8 concludes the paper.
2 colored petri nets: basics
colored petri nets (cpns) extend classical petri nets with data, hierarchy, and
time. in this section we focus on the extension with data .
in a classical petri net, tokens are indistinguishable (black), whereas in cpns
tokens are distinguishable; tokens may have dierent colors such that they can
be dierentiated. a colored token carries data attributes that characterize the
entity it represents. note that we use the terms \color" and \data" interchange-
ably. this extension enables us to explicitly model concurrency using the power
of petri nets but also to model sequential or data-processing systems using a
programming language, leading to much more compact and precise models, es-
pecially if several entities in a system behave in a similar manner. that way,
cpns provide a modeling technique that enables us to model complex systems
in detail.
as a running example, we consider a gas station. we start with a simple
version, and, throughout the paper, we add more features. this will illustrate
how to construct a model by incrementally rening and extending it. moreover,
it allows us to show various design patterns for cpns.
in our example, cars arrive at the gas station, wait to be served or rejected if
the station is lacking capacity, and nally leave. we distinguish between regular
cars and taxis. figure 1 shows the rst version of a cpn model. in the rest of
this section, we explain this example in detail and use it to introduce the cpn
formalism. we do not give a formal denition of cpns, but mention that one
such exists and can be found in, for instance, [18,19].
taxi(i)
ii+1
i
cc
cccregular
arrivetaxi
arrive
reject
[not (car.of_taxi c)]
leaveservenext
car id0
int
done
carwaiting
carregular(i)i+1 11`0
fig. 1. simple cpn model of a gas station.like for classical petri nets, the basic components of cpns are place s,transi-
tions, and arcs. a place serves as a placeholder for the entities in the system and
is represented by an ellipse. there are three places in fig. 1: next car id ,waiting ,
and done . a transition represents an action of the system. graphically, a rect-
angle represents a transition. the cpn in fig. 1 has ve transitions: taxi arrive ,
regular arrive ,serve ,reject , and leave . places and transitions are connected by
directed arcs, which describe how data ows when transitions are executed, but
we defer the exact description for a moment. an arc can only connect a place
to a transition or a transition to a place. an arc between two places or between
two transitions is not possible. so a cpn induces a bipartite directed graph with
places and transitions as nodes.
each place has a type (also known as a color set or sort) that determines
which kind of tokens it may contain. this is comparable to how variables have
a type in (explicitly) typed languages and is used both to make it easier to
understand the model and to catch errors. in fig. 1, place next car id is of type
intand the places waiting and done are of type car. this indicates that we
can only have integers in next car id and only cars in the two remaining places.
types are declared explicitly in the model using the language cpn-ml, which
extends standard ml [24] with syntax for cpns. in cpn-ml, the declarations
of the types intandcar are:
colset int = int;
colset car = union regular: int + taxi: int;
the rst line indicates that the type int corresponds to the simple type int
(integer). declarations allow us to give dierent names to simple types to make
the model more readable (e.g., dening a type idif we were using integers as
identiers). the second line species that car is aunion type, which corresponds
to a datatype in standard ml or a disjoint union in mathematics. the idea is
that we can have values that are either regular cars or taxis. regular cars and
taxis have an associated integer, which we use to be able to distinguish each
individual car. thus, the type car contains the values fregular(0) ,taxi(0) ,
regular(1) ,taxi(1);:::g.
aside from a type, each place also has a marking . a marking of a place is
a multiset of values over the type of the place. a multiset is like an ordinary
set (i.e., the order of elements does not matter), but the same element can
occur multiple times. a token is an element of such a marking; that is, it has
a value and resides in a place. in the example in fig. 1, markings of places are
shown in a circle and a rectangle near the places, such as the circle containing 1
and the rectangle containing 1`0on place next car id . the number in the circle
represents the total number of tokens in the place, and the text in the rectangle is
a textual representation of the multiset of tokens. in the example, place next car
idcontains exactly one token and the marking is written 1`0. we use a backwards
apostrophe ( `) to separate the value of a token and the count of how many tokens
with that value is part of the marking. the marking in fig. 1 consists of one
token with value 0. if a marking consists of tokens with dierent values, we
separate them with two pluses (++). this allows us to write a marking such as2`1++3`5 to represent the multiset containing two tokens with value 1and three
tokens with value 5. another example of a marking is 1`"hello"++1`"world" for
a marking containing two tokens, one with value "hello" (i.e., the string hello )
and one with value "world" . places without a marking shown contain an empty
multiset which is not shown explicitly. an assignment of markings to all places
is amarking of the net (or model).
we think of arcs as belonging to transitions, and separate them into input
arcs and output arc s. an input arc connects a place to a transition, and an output
arc connects a transition to a place. an arc has an inscription, i.e. an expression ,
written in cpn-ml. expressions are like expressions in programming languages
and may contain constants, functions, and all common arithmetic operators.
an expression may contain one or more free variables (i.e., it may be an open
expression). in fig. 1, transition regular arrive has an input arc from place
next car id with expression iand two output arcs|one to next car id with
expression i+1and one to waiting with expression regular(i) . a place connected
to a transition using an input arc is an input place , and a place connected using
an output arc is an output place . in the example, next car id is an input place of
transition regular arrive , and next car id and waiting are output places of the
same transition. a place can thus be an input and an output place of the same
transition. variables must be declared to be of a certain type. in our example,
we have declared two variables:
var i: int;
var c: car;
variable iis of type intand variable cof type car. an expression on an arc
must have the same type as the type of the place it is connected to or a multiset
of the place type; that is, when a value (of correct type) is assigned to all free
variables in an expression, it must evaluate to a multiset over or a single value
of the type of the place the arc is connected to.
a transition has a natural set of variables, namely the ones occurring on all
arcs belonging to it. each of these variables can be assigned a value from the set
represented of its type. for example, the variable ican be assigned the value 0,1,
or37as they are all integers. we refer to a transition along with an assignment
to each of its variables as a binding element (or binding for short). we denote
a binding element by the name of the transition and a list of assignments to
all its variables in braces. in our example, there are binding elements regular
arrivehi=0i,regular arrivehi=37i,servehc=taxi(23)i, and many others. note that
such potential bindings exist independent of a particular marking; that is, when
talking about binding elements we do not look at surrounding places, but only
consider the free variables of arcs surrounding the transition. we note that even
though variable ioccurs on more than one arc connected with regular arrive ,
we only write it once in a binding element. if the transition is clear from the
context, we may omit the name of the transition when talking about a binding
element.
given a binding element, we can evaluate the expressions on all arcs belonging
to the transition. for example, given the binding element regular arrivehi=0iinfig. 1, the expression iof the input arc from next car id evaluates to 0, the
expression i+1on the output arc to next car id evaluates to 0+1=1, and the
expression regular(i) on the output arc to waiting evaluates to regular(0) . for
the binding element regular arrivehi=37i, the same expressions evaluate to 37,
38, and regular(37) , respectively. as we only write each variable once, it has to
have the same value in all expressions surrounding a transition, but it can have
other values on other transitions. that means, the scope of a variable in a cpn
model is a transition, and information cannot be exchanged between transitions
directly. we can think of a transition as inducing a namespace for all variables
surrounding it.
given a model with a marking and a binding, we say that the binding is
enabled if all input places contain at least the tokens specied by the evaluation
of the expression on the corresponding input arc in the binding. in fig. 1, the
binding element regular arrivehi=0iis enabled as the expression on the sole input
arc to the transition evaluates to 0, and the marking of next car id contains a
token with value 0. the binding element regular arrivehi=37iis not enabled in
the marking in fig. 1 as next car id does not contain a token with value 37.
a transition is enabled in a marking if there exists at least one binding ele-
ment which is enabled in the marking. in fig. 1, we have two enabled transitions,
taxi arrive andregular arrive , as evidenced by the enabled binding elements reg-
ular arrivehi=0iandtaxi arrivehi=0i. enabled transitions are marked using a bold
outline. figure 1 shows that in the initial marking both regular arrive andtaxi
arrive are enabled. each of them has one enabled binding: regular arrivehi=0i
andtaxi arrivehi=0i.
if a binding element (or a transition) is enabled, it can occur or be executed .
this has the eect of removing all tokens from input places corresponding to
evaluations of expressions on input arcs and producing new tokens on output
places corresponding to evaluations of expressions on output arcs. in the exam-
ple, if binding element regular arrivehi=0ioccurs, we get a situation like the one
in fig. 2. compared to the situation in fig. 1, only the marking has changed;
the net structure remains unchanged. when regular arrivehi=0ioccurs, it con-
sumes the token with value 0from next car id and produces a token with value
1according to the arc expression i+1innext car id . in addition, it produces a
token with value regular(0) inwaiting , and this place now contains exactly one
token with this value. transitions taxi arrive andregular arrive remain enabled
in this marking, albeit the enabled bindings changed: taxi arrivehi=1iandregu-
lar arrivehi=1i. furthermore, transitions reject andserve are now enabled, both
in a bindinghc=regular(0)i.
we look at the net structure of a model and its marking as separate things;
the marking of the model may change, but the net structure remains the same.
the marking of a model before we start simulation is the initial marking ; for
example, in fig. 1, only place next car id contains a token; this token has value
0. the marking after executing regular arrivehi=0iis depicted in fig. 2. we refer
to such a marking as the current marking . executing binding taxi arrivehi=1i
yields a new current marking shown in fig. 3. execution of a binding elementtaxi(i)
ii+1
i
cc
cccregular
arrivetaxi
arrive
reject
[not (car.of_taxi c)]
leaveservenext
car id0
int
done
carwaiting
carregular(i)i+1 11`1
11`regular(0)fig. 2. gas station model after executing binding element regular arrivehi=0i.
is astep. transitions taxi arrive andregular arrive , thus, intuitively model that
a car of the given type arrives and queues up in waiting . we use the token in
next car id as a counter to number all cars arriving.
taxi(i)
ii+1
i
cc
cccregular
arrivetaxi
arrive
reject
[not (car.of_taxi c)]
leaveservenext
car id0
int
done
carwaiting
carregular(i)i+1 11`2
21`regular(0)++
1`taxi(1)
c=  ?
regular(0)
taxi(1)
fig. 3. gas station model after regular arrive and taxi arrive have been executed. as
shown, transition serve is enabled in two bindings, hc=regular(0)iandhc=taxi(1)i.
in fig. 3, transition serve is enabled in two bindings, hc=regular(0)iand
hc=taxi(1)i. these two bindings are shown in fig. 3; the rectangle near the
transition shows that chas two possible values enabling serve .
if we execute the transition in the binding servehc=taxi(1)i, we obtain the
situation in fig. 4, where the taxi(1) is removed from waiting and a token with
the same value has been produced in done . intuitively, this models the serving
of a taxi at the gas station and moving it to a place where it is no longer waiting
to be served. now, the taxi can leave (transition leave is enabled), leading to
a marking similar to fig. 2 except the marking of next car id is1`2instead of
1`1.taxi(i)
ii+1
i
cc
cccregular
arrivetaxi
arrive
reject
[not (car.of_taxi c)]
leaveservenext
car id0
int
done
carwaiting
carregular(i)i+1 11`2
11`taxi(1)11`regular(0)fig. 4. gas station model after serving the taxi.
figures 1, 2, 3, and 4 show one possible sequence of steps. executing enabled
bindings and thus moving from one marking to another is also known as the
token game . this is the mechanism used when simulating the cpn. note that
whenever a state has multiple enabled bindings, one needs to pick one of these
bindings.
if we reconsider the marking in fig. 3, we see that transition reject has an
inscription in squared brackets to the left of it, namely [not (car.of taxi c)] . this
is aguard . a guard denes an additional constraint that must be fullled before
a transition is enabled; that is, it is a boolean expression that needs to evaluate
to true in addition to the earlier requirements. when a guard is not shown,
it implicitly always evaluates to true. a guard may also contain free variables,
and they are considered in the same way as free variables on arcs surrounding
a transition when considering bindings of the transition. in our example, the
guard uses a function, car.of taxi, automatically dened for union types, which
returns whether the parameter given is a taxi (regardless of the integer value).
thus, the guard evaluates to true if the value of cis not taxi. this models
that we do not wish to reject taxis, for example, because they bring a lot of
business. this semantics of a guard is also reected in the enabled bindings of
transitions as shown in fig. 5, where the binding rejecthc=regular(0)iis enabled,
butrejecthc=taxi(1)iis not, even though the token required is present.
3 hierarchical modeling
in this section, we present an approach to extend cpns with hierarchy . this
approach makes it possible to reect the hierarchical structure of the system
in the cpn model. hierarchical cpns simplify modeling, thus facilitating the
modeling of large and complicated systems. the idea is to decompose a system
into a set of modules . a module is a cpn with a set of interface places, and it
can be used to describe the internal structure of a substitution transition. by
showing the substitution transition at the higher level, we can abstract from the
inner structure of a module at the lower level.taxi(i)
ii+1
i
cc
cccregular
arrivetaxi
arrive
reject
[not (car.of_taxi c)]
leaveservenext
car id0
int
done
carwaiting
carregular(i)i+1 11`2
21`regular(0)++
1`taxi(1)
c = regular(0)fig. 5. gas station model: enabling of reject is aected by its guard.
first, we present hierarchical cpns, as supported by cpn tools and show
how hierarchical modeling can be used to rene our running example. subse-
quent, we sketch dierent approaches of hierarchical modeling.
3.1 hierarchical cpns
cpns, as introduced in the previous section, are suitable to model the behavior
of complex systems. the concept of place types allows us to specify the ow of
data objects of any data type, and by using guards and arc inscriptions we can
manipulate these data objects. the weakness of \at" cpns is that they try to
capture the system behavior in one comprehensive net and do not represent the
hierarchical structure of a system. for example, the cpn in fig. 1 models the
serving and rejecting of cars at the gas station but also how cars arrive and leave
the gas station. in other words, the cpn in fig. 1 is unstructured.
for toy examples like the cpn modeling a gas station, this is not a problem.
if a cpn has only few places and transitions, we can lay out the net structure in
a way such that the individual parts of the system can be recognized. however,
if we model more complex systems such as a more rened version of the gas
station example, then the resulting cpn model could have hundreds of places
and transitions. such models cannot be overseen and are, therefore, not suitable
for discussing design decisions or implementation details of a system.
in a cpn, we model the elements of a system as places, transitions, and
tokens. these elements do not allow us to structure a model. as a consequence,
modeling a system by using only places, transitions, and tokens is insucient.
concepts to abstract from parts of the model are necessary. to this end, models
are usually designed following a hierarchical approach . the idea is to have several
levels of abstraction of the system and to rene elements at higher levels into
more detailed elements at lower levels. that way, also the design of large and
complex systems becomes manageable, because designers usually concentrate on
a single aspect of a system and extend the model step by step. for example, if we
only want to know when a car is rejected at the gas station, then the informationof arriving and leaving cars is not relevant and should be abstracted from. we
illustrate the idea of hierarchical modeling by revisiting our running example
introduced in fig. 1.
gas station
gasstationenvironment
environment
done
carwaiting
car
environment gasstation
fig. 6. cpn model of the gas station top module.
we structure the model in fig. 1 by decomposing it into two modules: (1)
the gas station and (2) its environment. the gas station module represents the
functionality of the gas station|that is, the serving and rejecting of waiting cars,
as modeled by transitions service and reject . the environment module models
the arrival and leaving of the cars, as modeled by transitions taxi arrive ,regular
arrive , and leave . the interface between these two modules can be specied by
places waiting anddone . we refer to such a place as a socket . both socket places
are of type car. a token in waiting models a car waiting to be refueled, and a
token in done models a car that has been refueled or rejected. figure 6 shows
the corresponding cpn model of this top-level module. the double-lined rectan-
gles, which are labeled environment and gas station , denote the two respective
modules in an abstract manner.
as already mentioned, a module is a cpn consisting of places, transitions,
arcs, and tokens. there are two kinds of transitions: elementary transitions and
substitution transitions . an elementary transition is an ordinary transition, as
introduced in the previous section. a substitution transition refers to a module.
it abstracts from the internal behavior of a module; that is, it considers a module
as a black box. unlike a normal transition, a substitution transition may have
internal states and does not need to consume and produce tokens in one atomic
action. for example, depending on the underlying module, gas station may rst
consume ten cars from place waiting , before it produces a token to done .
a module may contain any number of substitution transitions. these substi-
tution transitions refer to other modules that, in turn, may contain transitions
referring to other modules. there can be an arbitrary many levels as long as no
cycles are introduced in the inclusion graph; that is, a module may not (transi-
tively) contain itself as this would correspond to an innitely large model when
we replace each substitution transition by the module it refers to.
the top-level module in fig. 6 has two substitution transitions gas station
andenvironment referring to modules environment andgasstation , respectively,as can be seen from the tag on the bottom of a substitution transition. fig-
ure 7(left) shows the cpn modeling module environment and fig. 7(right) the
cpn modeling module gasstation .
cii+1
i+1i
regular
arrivetaxi
arrive
leavewaiting
outcar
done
incarnext
car id0
int
inoutregular(i)taxi(i)
11`0
waiting
incar
done
outcaroutin
serve reject
c[not (car.of_taxi c)]c c
c
fig. 7. cpn models of the environment (left) and gas station module (right).
each of the two cpns in fig. 7 has two interface places: waiting anddone .
we refer to such a place as a port. to be able to replace a substitution transition
by the cpn modeling the module it refers to, we need to relate each socket of
the substitution transition to a port of the cpn modeling the module. that
way, pairs of places|a port and a socket|are semantically merged into one
place. as an example, sockets waiting and done in fig. 6 are merged with the
equally labeled ports in fig. 7(right). on the level of a port, we specify the type
of connection; that is, a port has a type. in fig. 7(right), the tag inon place
waiting denotes that this port is of type input. likewise, the tag outon place
done shows that this port is of type output. a port can also be of type input
and output. in this case, it is labeled i/o.
replacing a substitution transition by the module it refers to is called the
attening of a cpn. the semantics of the cpn in fig. 6 corresponds to the at
cpn in fig. 1.
another advantage of decomposing a system into modules is that it enables
us to reuse existing functionality. that is, the same module can be used several
times in a model if necessary. as a result, multiple substitution transitions may
refer to the same module. to cope with this, we distinguish between a module
denition and a module instance . whereas a module denition serves as a speci-
cation of a cpn model, a module instance can be seen as an individual copy of
the module denition. for example, we could extend our model in fig. 6 and con-
nect sockets waiting anddone with an additional gas station, say gas station 1 .
in this case, we have two substitution transitions, gas station andgas station 1 ,
both referring to the same module denition, gasstation . however, each substi-
tution transition would be replaced by an individual module instance|that is,
a separate copy of the cpn shown in fig. 7(right).
finally, we illustrate how hierarchical modeling simplies the design and, in
particular, the renement of a system. consider the module of the gas station,as depicted in fig. 7(right). cars are modeled as tokens in place waiting and are
waiting to be served. in the current model, a car may be waiting to be served and
after a while be rejected. this is not desirable. therefore, we extend the model
as follows: the gas station has some waiting space where cars are queueing. if
the gas station has too little capacity, arriving cars will be rejected. however,
once a car enters the queue at the gas station, it will be eventually served.
enqueue reject
queue
carcar
carwaiting
inin
done
outoutserve[not (car.of_taxi c)]
c
cccc c
fig. 8. improved cpn model of the gas station module.
to modify the model, we only need to rene the cpn modeling the gas station
module (see fig. 7(right)). figure 8 shows the resulting model. an arriving car
is either rejected right away or put in the queue. as in the previous models, taxis
are not rejected. place queue models the queue at the gas station.
the advantage of hierarchical modeling is that we need only to rene the
module of the gas station. as the environment is not aected by the change, we
do not have to touch the respective model. this example shows that by using
hierarchical cpns, designers can focus on single aspects of a model.
3.2 approaches
there are two prominent approaches to obtain a hierarchical model for a system:
thetop-down approach and the bottom-up approach .
in the top-down approach, we start at the highest level of abstraction. and
decompose the system into modules. each module is considered as a black box,
and only the relationship between the modules, which is modeled as an interface,
is relevant. in subsequent steps, we can consider each module as a black box and
rene it into a set of submodules. we can repeat this procedure until we have
reached the desired degree of abstraction.
the bottom-up approach starts at the lowest level of abstraction and works in
the opposite direction as the top-down approach. at this level of abstraction, wedescribe the elementary modules in detail. these modules are then composed to
form a compound module. this composition step is repeated until we reach the
highest level of abstraction at which the system is modeled as a single module.
hierarchical development of systems is widely used, and all modern program-
ming languages oer facilities to support this approach. for example, function-
ality can be structured by developing a class hierarchy and by implementing
procedures to decompose complex functionality.
hierarchical cpns, as presented in this section, have been formalized
in [18,19] and implemented in cpn tools. cpn tools supports top-down and
bottom-up design. another approach for dening modules is to specify the mod-
ule interface as a set of transitions . flattening a hierarchical petri net then
corresponds to fusing equally labeled interface transitions, an established con-
cept in the petri net literature. whereas place fusion models asynchronous
communication|that is, sending a token by one module is not synchronized by
receiving this token by another module|transition fusion models synchronous
communication. synchronous communication is similar to invoking methods in
object-oriented programming and is the dominant composition approach in pro-
cess algebraic approaches [8,11]. transition fusion is not supported by cpn
tools.
a dierent approach to introduce hierarchy in petri nets is the nets-in-nets
paradigm proposed by valk [30]. whereas traditionally tokens are passive, tokens
in this paradigm can be active. one can think about such tokens as agents rather
than data containers. as an agent has behavior, the token modeling this agent
can represent a petri net again. that way, the nets-in-nets paradigm supports
the modeling of hierarchy. the renew tool [21] supports the modeling, execution,
and analysis of a particular instance of the nets-in-nets paradigm.
4 simple cpn patterns
in this section, we introduce some simple modeling patterns that can be used
frequently. the patterns make it possible to model constructs not natively pos-
sible using the cpn formalism. as indicated in the introduction, the idea to
provide patterns for modeling in terms of cpns was rst proposed in [26] where
34 patterns were identied. the patterns are briey described in the appendix
of the paper. subsets of these patterns can also be found on the cpn tools
web page2and in books such as [6,15,18,19]. however, these publications do not
explicitly identify and name these patterns.3
in this section, we look at patterns for bounding the number of tokens that
can be in a place at once, for imposing an order of how tokens are added to
and removed from places, for checking the number of tokens in a place, and for
folding equal or similar net structures into one generic copy. in the next section,
2seehttp://cpntools.org .
3note that patterns refer to frequently recurring modeling problems and their solu-
tions. therefore, patterns are always based on earlier work and not intended to be
original.ccccc
c
end
servingstart
serving
being
served
carqueue
car
done
outcar
()
()
cccc
c
end
servingstart
serving
free()
unitbeing
served
car
done
outcar11`()
()
()
() ccc
start
servingenqueue reject
[not (car.of_taxi c)]
capacity
unitqueue
carwaiting
in
c ccar
2`()22`()fig. 9. cpn models of the gas station module with non-instantaneous serving of cus-
tomers (left), with only one pump (middle), and with bounded queue size (right).
we present more advanced patterns to model more complex constructs that occur
less often.
unlike in [25,26], we will not be using a strict format for describing the
patterns. instead, we use examples based on the hierarchical gas station example
from fig. 6 with the environment module from fig. 7(left) and the gas station
module from fig. 8. in our examples, we replace only the gas station module.
4.1 bounded places using complement places
figure 8 models the serving of a car as a single transition, serve , indicating that
this action is instantaneous. as it actually takes some time to serve a customer,
this is an oversimplication. for this reason, we split this action into two actions:
start serving and end serving. we then obtain the situation in fig. 9(left). here,
we have a transition start serving , moving a car from place queue tobeing served ,
andend serving , moving a car from place being served todone . the model now
reects that serving a customer is not an instantaneous action, but it introduces
a new problem. consider what happens if we have three cars in queue . now, we
canstart serving all three of them. this does not really make sense if the gas
station has only one pump; rather, the cars should remain in the queue until the
pump is free, at which point we start serving the next one in line. we thus need
to bound the number of cars (tokens) that can be in place being served at any
point in time. therefore, we look at modeling patterns to limit the number of
tokens in place being served .
the simplest way to bound the number of tokens in a place is to introduce
acomplement place (or anti place). the idea is to ensure an invariant, namelythat the total number of tokens in this place and its complement place together
is a constant. a place, which can at most contain a predetermined number of
tokens, is bounded . a bounded place has a certain capacity . bounded places are
related to the concept of safe places in low-level petri nets.
in fig. 9(middle), we have added a new place freewith type unit . the type
unit is declared to be:
colset unit = unit;
the unittype is a type which contains only one element, (), and simulates the
behavior of (black) tokens of classical petri nets: tokens of this type are indistin-
guishable, so we only care about the number of tokens. whenever we produce
a token in being served , we remove a token from free, and vice versa. this en-
sures that the number of tokens in being served and free remains unchanged
and hence that being served contains at most one token. we can think of this
as consuming a right to produce a token in being served when we need it and
returning the right when we no longer need it (when we consume a token).
in general, we model a complement place for a place by mirroring all arcs
connected to the original place. that is, whenever there is an arc from a tran-
sition to the original place, we add an arc from the complement place to the
transition; and whenever there is an arc from the original place to a transition,
we add an arc from the transition to the complement place. the type of the
complement place can be unit , as in the example, or it can be another type
if we want to model a complement place for bounding multiple places or for
bounding tokens of a particular value. for example, assume that we need to
adapt in fig. 9(middle) to model the situation that there are ve pumps: two
diesel pumps, two petrol pumps, and one pump for electric cars. in this case,
the complement place initially has ve tokens making sure that each pump can
only be used for one car at a time. if the pump for electric cars is busy while
the other four pumps are free, then it is impossible to serve another electric car.
this can be ensured by using a dierent type for place free, for example,
colset fuel = with diesel | petrol | electric;
moreover, type car needs to be extended to indicate the type of fuel a car
requires and the arc inscriptions need to be adapted accordingly. however, the
principle is the same: we consume a token from the complement place whenever
we produce one token in the original place. likewise, we produce a token in the
complement place whenever we consume one token from the original place. in
fig. 9(middle), the transitions unconditionally produce/consume tokens in/from
the original place, so we do the same for the complement place. in more advanced
examples, we may produce/consume a varying number of tokens in/from the
original place depending on the binding of the transition; that is, we need to
make the expressions on arcs from/to the complement place reect this.
the pattern to add a complement place to bound the number of tokens in
another place is used frequently. consider for example, locking in databases,
kanbans in production systems, and message buers in middleware.()
()
() ccc
start
servingenqueue reject
[not (car.of_taxi c)]
capacity
unitqueue
carwaiting
in
ccar
c
1`c1++1`c2
2`()22`()
i-1
i
i
i+1()
()
() ccc
start
servingenqueue reject
[not (car.of_taxi c)]
capacity
count
intcapacity
unitqueue
carwaiting
in
22`()cccar
0
11`222`()fig. 10. two gas station modules which reject customers only when there is no capacity
for them.
4.2 inhibitor arcs using counter places
a gas station needs to reject customers if it does not have the capacity to serve
them; otherwise, they are added to the queue. our model does not reect that, as
customers are rejected nondeterministically. transition reject should be enabled
only if the queue is full. as a rst attempt, we add a complement place, capacity ,
for place queue and obtain the situation in fig. 9(right). now, the queue size
is limited to 2. at this point, we start unconditionally rejecting customers. the
model is still not correct, though, as we may also reject customers before the
limit is reached. we thus want to disable reject ifcapacity contains more than
zero tokens (i.e., if the queue is not full).
we can model such a condition in various ways. an arc that inhibits enabling
of a transition if a place contains more than a specied number of tokens is
aninhibitor arc . an inhibitor arc can in particular be used to test whether a
place contains zero tokens, which is also known as zero-testing . some petri net
formalisms contain inhibitor arcs natively, but for cpns, this is not necessary,
as we can easily model them. the simplest way to model an inhibitor arc in
our example is to add an arc between queue and reject checking that queue
contains two tokens, like in fig. 10(left). this arc contains an arrowhead in
both directions. this is a shorthand for an arc in both directions with the same
expression. in cpn terminology, such an arc is called a double arc and in the
literature, it is also known as a test arc orread arc .4the double arc between
queue andreject allows us to test that two tokens are present in queue without
modifying them.
this solution works only for bounded places and is dicult to scale with the
bound of the place (as we need a variable for each token). instead, we introduce
4there are subtle dierences between test and read arcs depending on the exact
transition execution semantics; we will not elaborate on this in this paper.a general way of modeling inhibitor arcs here and another solution in sect. 4.3.
the basic idea of the general solution is to introduce a counter place . this place
counts the number of tokens in a place. it is similar to a complement place, but
we store the number of tokens as an integer rather than indistinguishable tokens.
in fig. 10(right), we have added a counter place capacity count counting the
number of tokens in capacity . the type of capacity count isint. this place is
similar to place next car id used in figs. 1 and 7(left). however, now we increase
the value whenever we add a token to capacity (enqueue ) and decrease it when
we remove one ( start serving ). the double arc between reject andcapacity count
tests that the remaining capacity is 0; that is, cars are only rejected if no capacity
is left.
place capacity is redundant after adding capacity count . recall that capacity
was introduced as a complement place to bound the number of tokens in place
queue . we can also bound the number of tokens in place queue by inhibiting the
enabling of enqueue when it contains more than one token|that is, by using a
guard.
fig. 11(left) shows the situation where capacity is a counter place for place
queue ; that is, the value of the token in capacity corresponds to the number
of tokens in queue . both enqueue and reject use this information to block if
needed; that is, the arcs between capacity and enqueue update capacity and
serve as inhibitor arc. the guard added to enqueue ensures that enqueue is
only enabled if the number of tokens in queue is less than max capacity .
max capacity is a constant dened in the declarations of the model as:
val max_capacity = 2;
this declaration allows us to use a symbolic constant instead of writing the same
value in multiple places, which improves the readability of the model and makes
it easier to change the value of the constant if necessary. we have also added a
double arc between capacity andreject and an extra clause to the guard of reject
checking that the value of the token is greater than or equal to max capacity .
we use a comma ( ,) to separate clauses in the guard. this acts as a shorthand
for logical and(which in cpn-ml is written as andalso ).
4.3 fifo-places using complement places or lists
any variant of the gas station we have looked at until now (see figs. 7{11) serves
cars in a random order. for most gas stations, this does not reect reality; rather,
most gas stations serve customers using a rst-come, rst-served policy, and we
want to make our model reect this. a place from which tokens are removed in
the same order as they are added is a fifo-place (rst-in, rst-out place).
our rst idea is to model each location of the queue explicitly using a com-
plement place to ensure that each location has at most one car. this is shown
in fig. 11(right). the only new thing is that we have a double arc between each
location of the queue and transition reject . these arcs test that every location
in the queue is lled before rejecting customers. we have used separate variablesii+1
i
i-1
()
()
ccccc
c
end
servingstart
servingenqueue[i < max_capacity]
reject
[not (car.of_taxi c),
 i >= max_capacity]
capacity
int
free
unitbeing
served
carqueue
carwaiting
in
done
outcaroutin
c ccar
i0
()11`0
11`()
c1()
()
c
()cc
ccc c
advance
start
servingenqueue reject
[not (car.of_taxi c)]
slot 2'()
unitslot 1'()
unitslot 1
car
slot 2
carwaiting
incar
()()c2
11`()11`()fig. 11. improved gas station module which only rejects customers when there is no
capacity for them (left), and gas station module which serves customers in the order
they entered the queue (right).
for each double arc, as we are not requiring that each location contains the same
car (which in this model is impossible). each car arriving at waiting can only
enter the queue if the rst spot is vacant. likewise, a car in the rst spot can
only progress if the second spot is vacant. so as soon as a car has entered the
queue, it is guaranteed to be served in the order it appeared. this is in contrast
to place waiting where cars are not ordered.
the queue in fig. 11(right) serves its purpose but has some problems. first,
the construction is not scalable. compared to fig. 11(left), where we could
change the capacity of the queue by just changing the value of a constant, we
have to add two places, a transition, and four arcs for each slot we want to
expand the queue with. second, it seems a bit excessive that a car has to drive
through each spot in the queue explicitly even if it is the only car. instead of
using the net structure to express what is essentially a data-structure, we|for
the rst time in this paper|use that cpns support listtypes. the idea is to
represent the cars in queue as a queue rather than a multiset. in cpn-ml, a
queue is easiest modeled using a list.
figure 12(left) shows an implementation of a queue using lists. it is easier
to compare this module with the one in fig. 11(left) rather than the one in
fig. 11(right). we have changed the type of queue from car tocars and usesome more elaborate expressions on the arcs around the place. the type of queue
is a list of cars declared as:
colset cars = list car;
place queue has an initial marking, 1`[], indicating that the place contains a
single token, an empty list (which is written as []in cpn-ml). whenever we
produce a token in queue in fig. 11(left), we now, in fig. 12(left), replace the
token in queue with a new list consisting of the previous list with the new element
appended at the end. this is written as cs ^^ [c] in cpn-ml (i.e., append the
singleton list [c]to the end of list cs). we have also added an arc opposite the
original arc to get access to the previous value ( cs). we need to introduce a
variable csthat is declared as:
var cs: cars;
where we previously removed an arbitrary token from queue , we now take the
rst element of the list and return the tail of the list to queue . we do this by
using pattern matching, which is a powerful mechanism cpn-ml [19] inherits
from standard ml [24]. the expression c::cs assigns the head of the list to c
and the tail to cs. a transition using such an expression on an input arc is only
enabled when the list on the corresponding place contains at least one element.
the list structure also enables an alternative realization of the inhibitor arc
pattern. as all tokens are inside a single data-structure, we can test the number of
tokens without maintaining a separate counter. we have eliminated capacity and
changed the guards of enqueue andreject to refer to length cs , which returns the
number of elements in list cs. thus, if we have imposed an ordering of elements
on a place, we can count the elements directly.
another advantage of using the pattern in fig. 12(left) is that we can use any
data structure to impose any ordering of elements. for instance, we can change
the inscription on the arc from enqueue toqueue toc::cs to add the new car to
the head of list cs, thereby implementing a stack place from which tokens are
removed in last-in, rst-out order. we can also implement priority queue place s
by sorting the list according to a priority upon insertion. see [26] for concrete
examples.
figure 12(left) (but also the other cpn models modeling a queue for the
cars waiting to be served) has the problem that tokens may be queueing in place
waiting . when the queue has reached its maximal capacity and a taxi arrives via
port waiting , then enqueue and reject are unable to handle the taxi. one can
handle this in dierent ways. however, in case of a stochastic arrival process, it
is impossible to ensure that there is a free position in the queue for taxis.
4.4 folding identical net structures
most of the gas stations considered in this section (figs. 9{12) had only one
pump. we can easily change that by increasing the number of tokens initially
in place free, but only if we do not care which pump a customer uses. now,cscs
cs
()
()
cccc::cscs ^^ [c]
c
end
servingstart
servingenqueue[length cs <
 max_capacity]
reject
[not (car.of_taxi c),
 length cs >= max_capacity]
free
unitbeing
served
carqueue[]
carswaiting
in
done
outcaroutin
()c ccar
11`()11`[]
ccc()c
payend
serving
served
car
done
outcarfig. 12. improved gas station module which serves customers in the order they entered
the queue by using lists instead of the net structure (left) and gas station module which
requires users to pay (right).
assume that we add an extra step after refueling for paying for the fuel, as seen
in the fragment in fig. 12(right). this model does not preserve the information
for which pump the customer has to pay.
it is possible to retain the information about which pump was used by dupli-
cating the structure representing the pump and the payment procedure; a model
doing so is shown in fig. 13(left). now, depending on which pump we chose to
use initially, we have to execute either transition pay 1 orpay 2 , thereby ensuring
that each car pays for the gas it actually refueled.
naturally, duplicating net structure is rarely the best solution. if the focus of
the model is the geographical distribution of cars during a day, it may be a good
choice as we have a one-to-one correspondence between places of the model and
physical locations. here, we are not interested in that, so it may be better to fold
the two paths in fig. 13(left) into one, thereby avoiding copying and making it
easier to subsequently add more pumps or to change the behavior of all pumps
(e.g., we may want to keep the reservation of a pump until the customer has
paid, to make it even easier to match the pump and customer to the amount
of gas purchased). a folded version of the model in fig. 13(left) is shown in
fig. 13(right). in the remainder of this section, we explain folding using this
example.folding means that we add to all places and expressions another component
representing the identier of the folded value. in our example, we dene a new
type, pump , and a variable of that type as:
colset pump = index pump with 1..2;
var p: pump;
anindex type consists of a name (here pump ) index by a set of integers (here
1..2); that is, allowed values of tokens in pump arefpump(1) ,pump(2)g. consider
using index types when you mathematically would have used index values like
pump 1;pump 2. we then have to dene types for all places we wish to fold (here
being served ,free, and served ). we dene these types as cartesian products
of the identier used to fold and the original types. if the original type was
unit , there is no need to keep it in the cartesian product and we can just
use the identier type. we have replaced car onbeing served andserved with
carxpump andunit onfree with pump . type carxpump is declared as:
cc::cs
cs
()c
() c
cc
ccccs
()
() ccc::cs
start
serving 1
pay 1end
serving 1
pay 2end
serving 2start
serving 2
free 1()
unitbeing
served 1
car
served 1
carserved 2free 2being
served 2queue[]
cars
done
outcar11`()11`()11`[]
c(c, p)(c, p)cscs
cs
p
p (c, p)(c, p)c::cscs ^^ [c]c c
c
payend
servingstart
servingenqueue[length cs <
 max_capacity]
reject
served
cxpfreepump.all()
pumpbeing
served
cxpqueue[]
carswaiting
incar
done
outcaroutin
[not (car.of_taxi c),
 length cs >=
       max_capacity]
21`pump(1)++
1`pump(2)11`[]
fig. 13. gas station modules which model the situation where payments are linked to
the pump used. two alternative modules are shown: with (left) and without (right)
replicated net structure.colset cxp = product car * pump;
this is the syntax for declaring a cartesian product of preexisting types. we
can also declare cartesian products of more than two types by adding them at
the end. we use the naming convention of using the original types (or the rst
letters) separated by a lowercase letter x, but sometimes it may be more useful
to give it a more descriptive name if the product has a meaning in the domain
of the model. changing the types of places also requires us to change the initial
marking; in our example, this is simple, as only free has a nonempty initial
marking. we add an initial marking of 1`pump(1)++1`pump(2) , specifying that
initially both pump(1) andpump(2) are free for use. we also have to update all
arc expressions. in fig. 13(right), we just carry around the pump id and the
car id, changing all inscriptions consisting of cto(c, p) |a pair of a car and a
pump|and all inscriptions consisting of ()top, the id of the pump.
figure 14 shows a fragment of a slightly modied version of the gas station,
illustrating that we now only have to change the behavior once to change it for
all pumps. in this version, a pump is occupied until a customer has paid. we
have executed some steps of the model; for example, car regular(7) is currently
being served at pump(1) , whereas car regular(3) is done and is about to pay for
the fuel taken from pump(2) . there is no available pump at this time (i.e., free
contains no tokens), and car regular(5) has been served and paid (or refused
service) and is now done.
in the examples we have seen here, we have treated each customer equally
regardless of the pump they use, but we could also discriminate depending on the
pump they use|for example, by inspecting the pump in the guard|introducing
p
c(c, p)(c, p)p
(c, p)(c, p)
payend
servingstart
serving
served
cxpfree
pumpbeing
served
cxp
done
out11`(regular(3),pump(2))11`(regular(7),pump(1))
11`regular(5)
fig. 14. fragment of modied gas station module which requires users to pay for their
own usage.dierent paths depending on which pump a car uses. in fact, the entire model
can be seen as a folded model in which the same procedure is shared for all cars.
all cars are treated almost the same, except that taxis are never rejected, as
seen by the guard of transition reject . when we have a nite number of objects
having the same behavior, such as the two pumps, it is convenient to share the
net structure among them to avoid net replication. when we have an unbounded
number of objects, such as all cars, it is not only convenient, but even necessary,
as we would (theoretically) have to replicate the net structure an innite number
of times to be able to distinguish them.
5 advanced modeling concepts
the patterns, we presented in the previous section, cover constructs that fre-
quently occur in models of systems and processes. in this section, we present two
additional patterns: message broadcast and region ush [25,26]. these patterns
are more advanced than the previously presented patterns and cover constructs
that occur less frequently in models. before presenting these patterns, we intro-
duce the concept of prioritized transitions, as supported by cpn tools version
3.0, and illustrate how this concept can simplify the modeling of systems.
5.1 extending transitions with priorities
a cpn may have a reachable marking in which several conicting transitions
are enabled. we refer to this situation as a nondeterministic choice . the marking
in the gas station module shown in fig. 15(left) is an example of a nondeter-
ministic choice. the token in place waiting models a waiting, regular car. this
marking constitutes two enabled bindings, one enabling transition enqueue and
the second enabling transition reject . which of these two transitions res is not
predetermined. in reality, this would mean that an arriving car may be rejected
even though the queue is not full yet. because this situation is not desirable, we
need to adjust the model such that in the situation shown in fig. 15(left) always
transition enqueue res. earlier, in sect. 4.3, we resolved this problem by adding
an inhibitor arc between queue and reject (see fig. 12(left)). in the following,
we present another solution by prioritizing the ring of transition enqueue over
the ring of transition reject .
priority orprioritized transitions is supported in cpn tools from version
3.0 and onwards. the modeler can assign a priority to each transition: phigh ,
pnormal , and plow . the default value is pnormal . alternatively, it
is also possible to specify the priority of a transition as an integer, where 0
represents the highest priority and larger numbers lower priorities. the built-in
priorities, phigh ,pnormal , and plow correspond to the integer values
100, 1,000, and 10,000, respectively. the semantics of the model are dened by
calculating rst all enabled transitions ignoring priority and then considering
only transitions with the highest priority. if there are multiple enabled bindingwaiting
incar
queue
cars[]reject
[not (car.of_taxi c)]enqueue[length cs <
 max_capacity]c c
cs ^^ [c] cs11`regular(0)
11`[]
waiting
incar
queue
cars[]reject
[not (car.of_taxi c)]enqueue[length cs <
 max_capacity]
p_highc c
cs ^^ [c] cs11`regular(0)
11`[]fig. 15. cpn model without priority (left) and where enqueue has a higher priority
than reject (right).
elements having the highest priority, then one of them is nondeterministically
chosen.
figure 15(right) results from fig. 15(left) by assigning value phigh to tran-
sition enqueue |all other transitions have the default value pnormal , which
is not explicitly shown in fig. 15(right). as a result, only transition enqueue is
enabled in the marking shown in fig. 15(right), because transition reject has a
lower priority than enqueue .
the example illustrates the advantage of extending cpns with priorities,
namely simplicity of the model. the interplay of priorities is a global property
of a cpn; that is, assigning a priority to a single transitions may aect the
enabling of all other transitions. therefore, it is possible that the resulting cpn
allows for undesired behavior. as an illustration, suppose we assign plow to
reject andpnormal to all other transitions. having the lowest priority of all
transitions, reject can only re if it is enabled (in the setting without priorities)
and no other transition is enabled. however, this is never the case, because the
environment module can continuously produce tokens in waiting . as a result,
reject is dead.
priorities simplify the modeling, but they do not increase the expressiveness
of cpns. every cpn with priorities can also be modeled as a cpn without
priorities. in fig. 15(right), we can remove the priority from transition enqueue
if we use an inhibitor arc and extend the transition guard of reject , as shown in
fig. 12(left). in general, expressing priorities between transitions without using
the concept of transition priorities is nontrivial, in particular, if the transitions
have disjoint presets.
5.2 message broadcast
sometimes we need to model sending of a message to an unknown number of
objects. such a task is referred to as a message broadcast . it is particularly useful
for modeling systems where many participants interact with each other (e.g.,
interorganizational business processes) and for message protocols. we illustrate
this pattern with the following modication of the gas station. suppose that
there is a promotion at the gas station and every car driver who has refueledher car gets a voucher before paying for the gas. the diculty is that we do not
know the number of car drivers. the promotor would go to each car driver and
hand over the voucher. figure 16, which is an extension of fig. 13(right), shows
how we can model such a broadcast as a cpn.
firing transition start starts the procedure. first, we identify all car drivers
who should receive a voucher. to this end, transition read stores a copy of all
tokens of place served in a list in place receivers . each list entry refers to one
car driver who will receive a voucher. the guard of transition read ensures that
the same token cannot be added twice to the list. observe that this construction
is independent from the number of tokens in place served . by assigning a high
priority to transition read , we can make sure that begin broadcast can only re if
there are still tokens in place served that have not been added to the list in place
receivers . when the list is complete, begin broadcast res and the broadcast
starts. note that transition paycannot re, because pending is unmarked. firing
begin broadcast produces the length of the car list csinpending . furthermore,
as variable csis a list of cars and vouchers is of type car,csis unfolded and
for each list entry a single token is produced in vouchers ; that is, cpn tools
automatically converts the list csinto a multiset of tokens for place vouchers .
transition end broadcast models the distribution of the vouchers to each car
driver. after all car drivers have received a voucher, there is a token with value
0 in place pending , thus enabling payand start. ifstart res again, then every
car driver receives a second voucher.
served
cxpstarted
unit
receivers
cars[]
vouchers
car
pending
int0end
serving
paystart
read
[not(list.exists 
(fn cc => c = cc) cs)]p_high
begin
broadcast
broadcast(c, p)
(c, p)()
()
c::cscs cs
[]
cs()
(c, p)clist.length cs
i - 1i0
0(c, p)11`[]
11`0
fig. 16. broadcasting vouchers to all car drivers who refueled their cars.5.3 region flush
suppose that the gas station attendant is eager to stop working in time. every
day at 6 p.m. he serves only the cars that are being refueled; all cars in the queue
will not be served anymore and have to drive on. to model this as a cpn, we
must move all tokens from place queue to place done and also reset the value
of place capacity to 0, thereby making sure that transition start serving does
not re while tokens from queue are moved to done . this is trivial if we have
modeled the queue using lists as in fig. 12(left). however, when modeling the
waiting cars in the queue as individual tokens, things become more involved.
figure 17(top) extends the model in fig. 11(left) with this functionality. tran-
sition close models the closing of the gas station. it removes the token from
place capacity . this token is needed to learn the number of cars in the queue
and to prevent transitions enqueue andstart serving from ring. after the queue
has been ushed|that is, all cars have been moved to done |transition open
models the opening of the gas station by initializing place capacity again.5only
then transitions reject and start serving can become enabled. in case we need
to ush more than one place, we must copy the pattern accordingly.
removing tokens from a part of a cpn is referred to as region ush . the
idea is to disable the transitions in the respective part (i.e., the region) of the
cpn while removing all tokens from the places in the region. afterward, the
region is optionally reset.
using the concept of prioritized transitions, as introduced in this section, we
can generalize the model of a region ush. the respective cpn model is shown
in fig. 17(bottom). transition flush reads a boolean false from place open ,
moves a car token from place queue to place done , and decrements the value of
capacity . as only flush has a high priority, it can re until the queue is empty
without being in conict with any other transition. transitions close andopen
model the closing and opening of the gas station. close produces a boolean false
in place open . if there is at least one car in the queue, then flush is enabled
(because of its priority). only after the queue has been ushed, transition open
can change the boolean in place open to true, modeling that the gas station
opens again.
the advantage of using the pattern with priority in fig. 17(bottom) is that
it is independent of the presence of complement place capacity . in contrast,
fig. 17(top) relies on place capacity as it requires knowledge about the number
of cars to be removed; otherwise, we would not know when we have moved all
waiting cars to place done and, hence, when we can open the gas station. place
flush is connected to place capacity to update this complement place; it is not
used to see how many cars need to be ushed.
5when adding explicit time, we can model that the gas station opens again at a
particular time (e.g., 9 a.m. the next day). transition open is not supposed to re
immediately after closing the gas station; this needs to be governed by the time
concept explained in the next section.i-1
i
0i
0i
i
cci+1
i
ii-1
()
()
cccccc c
copenflush[i>0]close
end
servingstart
servingenqueue[i < max_capacity]
reject
[not (car.of_taxi c),
 i >= max_capacity]
trigger capacity
int
free()
unitbeing
served
carqueue
carwaiting
incar
done
outcaroutin
0
int11`0
11`()
i
cfalse
false truefalse true
ci+1
i
i-1
()
cccccc
copenflush
p_highclose
end
servingstart
servingenqueue reject
[not (car.of_taxi c),
 i >= max_capacity]
opentrue
boolcapacity0
int
freebeing
served
carqueuewaiting
incar
done
outcaroutin
car
i
ci-1i
unit()()[i < max_capacity]
11`true
11`0
1
1`()fig. 17. removing all cars from queue without (top) and with (bottom) priority.in fig. 17, only one place is ushed (place queue ). the construct needs to be
copied per place. this may become quite involved, therefore, workow languages
such as yawl support this natively (see the cancellation pattern in [4,32]).
6 modeling time
time is an important aspect in many systems. let us, for example, consider the
gas station obtained by combining the modules in figs. 6, 7(left), and 13(right)
(shown together as fig. 18). in this example, we have modeled the serving of
customers as two transitions, start serving andend serving , indicating that the
action of serving is not instantaneous. however, serving customers is an atomic
action in the sense that neither the car nor the pump can be used for anything else
during the feat. it would be more elegant to model serving as an atomic action
which takes time. the action of paying for the gas should also take time. in
c(c, p)(c, p)cscs
cs
p
p (c, p)(c, p)c::cscs ^^ [c]c c
c
payend
servingstart
servingenqueue[length cs <
 max_capacity]
reject
served
cxpfreepump.all()
pumpbeing
served
cxpqueue[]
carswaiting
incar
done
outcaroutin
[not (car.of_taxi c),
 length cs >=
       max_capacity]
21`pump(1)++
1`pump(2)11`[]
gas station
gasstationenvironment
environment
done
carwaiting
car
environment gasstation
cii+1
i+1i
regular
arrivetaxi
arrive
leavewaiting
outcar
done
incarnext
car id0
int
inoutregular(i)taxi(i)
11`0
fig. 18. untimed gas station.this section, we look at how cpns enable us to model timed aspects of systems
and use this to extract information about the performance of the system. as
shown in the next section, one can do experiments with a timed system using
the model, thereby extracting performance data that can be used as input for
decisions regarding the modeled system. for example, simulation can be used
to nd out whether it is better for a gas station to acquire extra pumps or to
reserve more capacity for the queue if the number of customers doubles. we also
look at the dierence between real and integer time stamps and the interaction
between timed models and prioritized transitions.
6.1 time basics
in cpns, time is introduced by assuming a global clock representing the current
model time . we assign a time stamp to each token. a time stamp on a token
indicates when the token can be consumed. a token can only be consumed if
its time stamp is less than or equal to the current model time. in a sense, a
token with a time stamp in the future (compared to the current model time)
can be regarded as a promise that, at some point in the future, a token will be
produced. hence, one can think of time stamps as reversed expiry dates: tokens
with a time stamp xcan be consumed at time xor later.
figure 19(left) shows a timed version of the gas station from fig. 18. we
have merged the two serve transitions into a single one and added an annotation
@+5 to transition serve . this annotation species that executing the transition
takes 5 units of time (i.e., ring is atomic, however, the tokens are produced with
delay of 5 time units). in the same way, we have added an annotation to paythat
states that paying takes 2 time units. we also see that the current marking of
waiting ,pumps , and paying reects time stamps, so that regular(1) inwaiting
is available at time 0 (due to @0after the token value). furthermore, we now
join tokens with dierent values using +++ instead of ++. this is merely a
technicality due to typing. we see that taxi(0) has been served by pump(2) (it
is on served ) and that taxi(2) is currently in line to be served.6aspump(0) is
available at time 0, the current model time is 0, and serve is enabled at this time.
payis not enabled at time 0, however, as the token in served is not available until
time 5. in a sense, the tokens (i.e., (taxi(0),pump(2)) inserved andpump(2) in
pumps ) have not been produced yet; we have only a promise that in the future
(in 5 time units) the tokens will be produced.
each pump can serve at most one car every 5 time units; that is, the time-
related annotations specify that serving a customer takes time and during that
time the pump is not available.
we have to specify for each type whether it is timed or not (we allow tokens
without a time stamp, which is a shorthand for a token that is always available).
we specify that a type should include a time stamp by adding the keyword timed
at the end of the declaration. in our example:
6although there is a token referring to taxi(0) in place served , the service has not
been completed yet (in fact, it just started). this can be seen by comparing the time
stamp of the token in place served (@5) with the current model time ( 0).(c, p)
c(c, p)cscs
cs
pc::cscs ^^ [c]c c
c
pay @+2serve
@+5enqueue[length cs <
 max_capacity]
reject
[not (car.of_taxi c),
 length cs >= max_capacity]
served
cxppumpspump.all()
pumpqueue[]
carswaiting
incar
done
outcaroutin
11`(taxi(0),pump(2))@521`pump(1)@0+++
1`pump(2)@511`[taxi(2)]11`regular(1)@0
()@+13 ()
()@+8 ()regular(i)taxi(i)
cii+1
i+1i
regular
arrivetaxi
arrive
leavetaxi
rate()
unit
regular
rate()
unitwaiting
outcar
done
incarnext
car id
int
inout011`()@0
11`()@811`regular(0)@011`1fig. 19. simple timed version of the gas station (left) and environment (right).
colset car = union regular: int + taxi: int timed;
colset pump = index pump with 1..2 timed;
colset cxp = product car * pump timed;
the model of the environment in fig. 18 does not take time into account
and, therefore, produces cars that all appear at time 0. this causes all cars to
enqueue at this point. thus, time will never progress, as time only progresses
when there are no more enabled transitions at a given time stamp. we therefore
need to make the environment time-aware. we would like that cars arrive at a
constant rate, but that the rate is dierent for taxis and regular cars. we could
add separate counters for each of the transitions and use a construction similar
to the one used for serve and pump , but instead we choose to add separate
places with a single token limiting the rate of the transitions. we use a timed
unit as type and place a single token in each place, obtaining the environment
in fig. 19(right). we have not added time annotations to the transitions, but
rather to the output arcs. this enables us to produce tokens that are available at
dierent times. in fig. 19(right), we have just executed regular arrive at time 0,
yielding a car regular(0) onwaiting which is available at time 0, and a token ()
onregular rate which is available at time 8. in this way, we have modeled that
arriving takes no time, but the transitions can only occur at a specied rate.
the rate for regular cars is once every 8 time units, and the rate for taxis is onceevery 13 time units. the token in next car id is untimed and does not inuence
the enabling of any transitions as it is always available.
6.2 embedding time stamps in tokens
place queue in fig. 19(left) always contains one token (the queue) and this
token is always available as the place is untimed. hence, the @+5 annotation of
transition serve does not apply to this place. in this particular situation, this
is just ne; time progresses only in-between subsequent arrivals and because
it takes time to serve a car. although the untimed queue works well in this
situation, there are situations in which an untimed queue cannot express the
desired behavior|for example, if the transition enqueue takes time or to model
more complex priority and resource allocation rules, where the next time stamp
needs to be computed based on the entire queue. therefore, we would like to
make the tokens of the queue timed as well, but this is not possible, because
whereas we think of the queue as a list of tokens, the list is a single token and
can therefore have only one time stamp. to x this, we need to embed the time
stamps of the tokens in the queue. we do not have access to the time stamp of a
token (it is either available or not), but we do have access to the current model
time, and can use that to embed time stamps in the elements of the queue,
obtaining the model in fig. 20. the idea is to not just store cars in the list
representing the queue, but a pair of the car and the model time the car arrived;
that is, we dene the types:
colset cxt = product car * string;
colset cars = list cxt timed;
var t : string;
now, cars is timed. we want the time stamp of the list token modeling the
queue to be the minimum of all time stamps inthe queue. if the queue contains
no cars, we assign the current time to the queue. we need to convert the model
time to and from strings, as there is no type in cpn tools that directly corre-
sponds to the type of the model time. for this purpose we dene the following
function:
fun modeltime() = modeltime.tostring(modeltime.time())
moreover, we need to compute the time stamp of the queue. therefore, we dene
function unwrap time, which takes as list of cars and returns the same list, but
with a time stamp equal to the time stamp of the rst car in the list.
fun unwrap_time([]) = [] @ (modeltime.time())
| unwrap_time((c, t)::rest) =
((c, t)::rest) @ (modeltime.maketime t)
fun append(cs, c) = unwrap_time(cs ^^ [(c, modeltime())])
function append adds a new car to the end of the list together with its arrival
time converted to string format. moreover, using unwrap time the time stamp of
the whole list is computed.(c, p)@+5
c(c, p)unwrap_time cs
p@+5(c, t)::cs
c
pay @+2serveenqueue[length cs <
 max_capacity]
reject
[not (car.of_taxi c),
 length cs >= max_capacity]
served
cxppump.all()
pumpqueue[]waiting
in
done
outcaroutin
pumps
pappend (cs, c)
carscs@+maxint
unwrap_time cscs@+maxintccar
c
11`(regular(5),pump(2))@2911`[(taxi(6),"26")]@26
21`pump(1)@18+++
1`pump(2)@29fig. 20. timed version which embeds time stamps in the list.
6.3 ignoring time stamps of tokens
after adding a time stamp to queue , we need to make some minor changes
to other transitions surrounding it so they are not wrongly delayed. first, we
have changed serve to no longer have a time inscription, but to instead only
delay the pump and car moved to served , asunwrap time takes care of delaying
the queue the correct amount. if we kept the time inscription, the time stamp
of the queue might also be delayed 5 time units, resulting in a car not being
served immediately even though a pump is available. second, we have added
time inscriptions to the arcs from queue toenqueue andreject . the inscription
uses maxint , which is a constant, declared as:
val maxint = option.valof (int.maxint)
an inscription on an input arc means that the token can be consumed the
indicated time units before it is really available, so consuming it maxint time
units before basically says to ignore the time stamp. this allows us to reject
or enqueue a car even though the queue is not currently available. although
transition serve needs to wait until the rst car is available, the queue can be
updated at any time. in this situation, this is not required, but the example
shows that we can have full control over time even when objects are put in a
list.6.4 real time and random distributions
until now we have used constant delays and rates on all transitions. this is not
realistic. often we would rather know that something has an average delay or rate
and perhaps even a guess (or assumption) about how the values are distributed.
we thus wish to replace the delays and rates by values resulting from drawing a
random number using a given distribution. however, most random distributions
occurring in practice, especially randomly distributed times, are not integers. in
previous versions of cpn tools, we would need to scale the random values to a
desired precision and convert the randomly drawn values to integers. but from
version 3.0 and onwards, cpn tools supports using real time stamps. changing
time stamps to be real values, we can create a new environment as in fig. 21. we
have changed only the inscriptions on arcs indicating the rates. rather than using
a constant value, we draw values from the exponential function, which randomly
samples values from a negative exponential distribution, which is appropriate
for modeling arrival rates. the exponential function is given a parameter , and
it draws values with a mean value of  1, which is why we write 1.0/13.0 rather
than 13.0. we use inscription @++ rather than the inscription @+. this is needed
when we want to make increments that are not integers. figure 21 shows that
the tokens now have time stamps that are not integers.
()@++exponential(1.0/13.0) ()
()@++exponential(1.0/8.0) ()regular(i)taxi(i)
cii+1
i+1i
regular
arrivetaxi
arrive
leavetaxi
rate()
unit
regular
rate()
unitwaiting
outcar
done
incarnext
car id0
int
inout11`()@3.9909927714
11`()@5.6055594558911`regular(2)@1.4467897948311`3
fig. 21. real timed environment drawing rates from the negative exponential distri-
bution.
we would naturally like to make an implementation of the gas station also
using randomly generated delays. figure 22 shows an example. we have changed
the time inscription of payto randomly draw a value from the normal distribu-
tion with a mean value of 2 and a variance of 1.7transition serve has become
7note that the normal distribution is not a very suitable delay distribution as it may
generate negative values that are eectively treated as zero's, thus shifting the mean.unwrap_time cs
p
(c, p)@++maketime d
c(c, p)(c, t)::csappend (cs, c)c c
cenqueue[length cs <
 max_capacity]
[not (car.of_taxi c),
 length cs >= max_capacity]
cxppumpqueue[]
carswaiting
incar
carin
cs@+maxint
cs@+maxint
unwrap_time cs
done
outoutpayservedserve pumps
output d;
actionmodeltime.tostring(normal(5.0, 2.0))
@++normal(2.0, 1.0)p@++maketime dreject
pump.all()1
1`[(regular(4),"43.8393888658")]@4
3.8393888658
11`(taxi(3),pump(1))@45.572396815521`pump(1)@45.5723968155+++1`pump(2)@5.66599989639fig. 22. real timed gas station drawing average times from a normal distribution.
a bit more complex, as we want the car and pump to complete at the same
time, so we cannot just add two calls to normal , as that would draw a random
value for each. instead, we have added a code segment toserve , which outputs
a variable dand draws a value from a normal distribution with mean 5 and
variance 2, converting it to a string (as variables cannot have type time). the
time inscriptions use variable dand convert it into a time stamp.
6.5 time and priorities
the interplay of priorities on transitions as explained in sect. 5.1 and time as
explained earlier in this section is nontrivial, as they are both global properties.
the basic rule is that time takes precedence over priorities , so if a low-priority
transition is enabled at time 12, but a high-priority transition is enabled at
time 15, the low-priority transition will be executed rst. the intuition of the
interplay of transition priorities and time is that simulation progresses along a
time-line. at each point in time, we evaluate which transitions are enabled and
execute the ones with the highest priority rst. we then execute all transitions
enabled at the current model time in a highest priority rst order until no more
transitions are enabled, at which point we increase the current model time and
start anew.in the gas station example, if we combine the model in fig. 15 with the one
in fig. 19(left) (i.e., we add time stamps to the model in fig. 15), we obtain the
model in fig. 23. here, served is enabled even though there are enough tokens
forenqueue to be enabled. the reason is that regular(4) arrived at time 16, and
the current model time is 16, at which point serve is enabled (if tokens were
enabled at the time, it would be enabled already at time 0 for pump(1) and
at time 13 for pump(2) ).enqueue is not enabled until time 26, when taxi(5)
becomes available. so, even though enqueue has high priority and all available
tokens, it is preempted by serve , which is enabled earlier.
cs
cs
pc::cscs ^^ [c]c c
serveenqueue[length cs <
 max_capacity]
p_high reject
[not (car.of_taxi c)]
pumpspump.all()
pumpqueue[]
carswaiting
incar
21`pump(1)@0+++
1`pump(2)@1311`[regular(4)]11`taxi(5)@26
fig. 23. gas station with priorities and time stamps. the current time is 16.
6.6 dierent timing concepts
many dierent timing concepts have been introduced in the literature. authors
associate time to transitions, places, or arcs. in most timed petri net models,
transitions determine time delays. in only a few models, time delays are as-
sociated to places or arcs. independent of the choice where to put the delay
(i.e., transitions, places, or arcs), several types of delays can be distinguished,
for example, deterministic (the delay is xed), nondeterministic (the delay is
a non-deterministic choice over an interval [1,23]), and stochastic (the delay is
sampled from some probability distribution [22]). even when the location of the
delays and the type of delay are determined, there are still many possibilities.
adding time to petri nets requires a redenition of the enabling and ring rules.
for example, when time is associated to transitions and delays are stochastic,
one can use preselection semantics (i.e., rst the transition to be red is selected
and only then the delay is determined) or race semantics (i.e., transitions are
competing for tokens and the transition that nishes rst takes the tokens). in
the later case one needs to select a memory policy (age memory, enabling mem-
ory, or reset memory). this illustrates there are many ways to add time to petri
nets.generalized stochastic petri nets (gspns) [9] are probably the most widely
used petri net model focusing on the time extension. this model allows for two
types of transitions: transitions that do not take time (immediate transitions)
and transitions that have an enabling time that is sampled from a negative
exponential distribution. due to the memoryless property of the exponential
distribution and the race semantics, it is possible to convert a gspn into an
embedded markov chain, thus allowing for all kinds of analysis [22].
most of the timed petri net models described in literature have been tailored
towards a particular analysis technique. unfortunately, petri net modeling lan-
guages using stochastic delays tend to impose restrictions to allow for markovian
analysis. most petri net modeling languages using xed times or time bound by
intervals also impose restrictions to allow for model checking.
cpns aim at the modeling of large and complex processes. as shown in earlier
sections, this requires tokens to be colored. places may have types that cannot
be enumerated (e.g., lists). in fact, markovian analysis and model checking are
unrealistic for applications that use the patterns described earlier; the state
spaces of such models are simply too large to allow for exact analysis. therefore,
we need to resort to simulation. as a result, we do not have to put any restrictions
on time and, therefore, we can select the most convenient and intuitive time
extension.
since tokens already have a value, it is most natural to also attach time
stamps to tokens [1,15,18]. since time inscriptions can be put on both input
and output arcs and it is possible to inspect the current time (see fig. 22), the
designer has full control over the time in cpn tools. any of the timed petri net
models described in literature can be emulated. however, performance analysis
is restricted to simulation.
7 simulation
as indicated in the previous section, we need to resort to simulation to analyze
the performance of complex processes. therefore, we focus on this type of analy-
sis. first, we position simulation in the broader spectrum of analysis techniques.
then, we show how to construct simulation models and how to monitor them.
finally, we explain how to interpret the results and illustrate this by comparing
dierent redesigns for our running example.
7.1 overview of analysis techniques
the idea of simulation is to take an executable model (e.g., a cpn) and let it
run several times. each run can be seen as an experiment and corresponds to
a \random walk" in the state space of the model. even if it is impossible to
construct the entire state space, it is possible to do such experiments; just \play
the token game" repeatedly. a model may allow for innitely many scenarios,
that is, possible runs. because only a nite number of scenarios can be executed,
only a fraction of the entire state space can be explored. consequently, simulationcan, unlike verication, be applied to verify only the presence of errors and not
their absence.
verication of cpns is challenging. because of the introduction of data and
time, the state space tends to be large, if not innite. the only way to use model
checking techniques eectively, is to limit the use of data and time. typically,
one needs to abstract from time and use types with a limited number of possible
values. we refer to other papers in this topnoc volume that focus on this topic
and that introduce techniques such as reachability graphs, coverability graphs,
unfoldings, invariants, siphons, and traps.
simulation is widely used for performance analysis. performance analysis tries
to make predictions about key performance indicators, such as response time and
ow time, and to detect possible bottlenecks. the goal is to understand the as-is
situation and to compare this with possible to-be situations.
lion's share of petri net research has focused on model-based analysis ; that is,
by analyzing a model, one hopes to be able to make meaningful statements about
an as-is or to-be situation. however, such analysis only makes sense if the model
reects reality. simulation results are irrelevant if the model has little in common
with reality. therefore, we advocate the use of process mining techniques in case
event logs are available. process mining [2] aims to discover process models from
example behavior captured in dierent data sources (e.g., databases, transaction
logs, and audit trails) and to relate existing models to such behavior. as shown
in [27], it is possible to discover cpns from events logs. such cpns model the
control-ow of cases, resources, resource allocation, dataow, routing probabili-
ties, and routing conditions. in the context of workow management systems, it
is even possible to upload the current state of such a system into a cpn model
and conduct short-term simulation [28]. unlike classical simulation approaches
that focus on steady-state behavior, the goal of short-term simulation is to make
predictions about the near future to answers questions such as \how many or-
ders will we have in the pipeline next week?", \what is the expected average
response time tomorrow?", and \what will be the average ow time by the end
of next week if i temporarily add two workers?". the focus of short-term simu-
lation is on the transient behavior. this allows for a \fast forward button" into
the future.
in the remainder of this section, we assume that we are able to create a cpn
model that adequately reects reality. moreover, we focus on the steady-state
behavior of processes. nevertheless, we encourage the reader to consult [27,28] for
more information about the alignment between reality and simulation models.
7.2 adding stochastic behavior to a cpn
in sect. 6 we showed how to add time to models. in our running example, cars
are generated using a poisson arrival process. this means that the time between
two subsequent arrivals is sampled from a negative-exponential probability dis-
tribution. in any situation where there is a large population of potential entities
that can generate requests (e.g., customers refueling their cars), a poisson ar-
rival process is most natural. one can show that if these entities are in steadystate and independent, their behavior will always resemble a poisson arrival pro-
cess. to model the time it takes to refuel a car, we also need to use a probability
distribution. earlier, we used the normal distribution. cpn supports many prob-
ability distributions suitable for modeling time durations. table 1 shows some
examples.
table 1. random distribution functions.
function description
uniform(a:real,b:real):real forb>a,uniform(a,b) samples a value from a uniform
distribution with mean ( a+b)=2.
exponential(r:real):real forr>0,exponential(r) samples a value from an expo-
nential distribution with mean 1 =r.
erlang(n:int,r:real):real forn1 and r>0,erlang(n,r) samples a value from
an erlang distribution; that is, the sum of nindependent
exponentially distributed values with parameter r. the
expected value is n=r.
normal(n:real,v:real):real forv0,normal(n,v) samples a value from a normal
distribution with mean nand variance v.
let us now revisit our running example. figure 24 shows another variant
of the gas station. at the highest level, we now distinguish between cars that
were served (place dones ) and cars that were rejected (place doner ). we use
a poisson arrival process to generate cars. the mean time between subsequent
arrivals of taxis is 12 minutes. regular cars arrive, on average, every 6 minutes.
hence, on average, 5 + 10 = 15 cars arrive per hour. in our initial situation we
have only one pump; that is, freepumps contains only one token. we split the
service transition into a startserve and endserve transition to explicitly show
when a pump is busy or free. transition payis still atomic and is an \innite
server"; that is, the transition takes time, but cars do not need to wait for one
another.
figure 24 uses the following types:
colset stime = string;
colset bcar = product int * stime;
colset car = union regular: bcar + taxi: bcar timed;
colset cars = list car;
colset pump = index pump with 1..1 timed;
colset carxpump = product car * pump timed;
the types are self-explanatory, except for the addition of stime . every car has
a unique id of type intand a creation time of type stime . we use function
modeltime dened earlier to inspect the global clock and convert the current
type to a string such that it can be stored in a token. the creation time of a car
has been added to measure ow times; that is, we measure the dierence in time
between the moment a car leaves module environment and when it returns.p (c,p)@++st(c)
p
(c,p)
cc
cccscs
csc::cscs^^[c]c c
endserve
pay@++pt(c)startserveenqueue[length cs <
 max_capacity]
reject[length cs >= 
max_capacity]
busy
carxpump
doner
outcarserved
carfreepumpspump.all()
pumpqueue[]
carswaiting
incar
dones
outcaroutin
out
gas stationgasstation
environmentenvironment
doner
cardones
carwaiting
carenvironment gasstation
c()@++exponential(1.0/12.0)()
()@++exponential(1.0/6.0) ()regular(i,modeltime())taxi(i,modeltime())
cii+1
i+1i
leaverregular
arrive[i<sl]taxi
arrive[i<sl]
leaves
doner
incartaxi
rate()
unit
regular
rate()
unitwaiting
outcar
dones
incarnext
car id0
int
inout
infig. 24. the initial cpn used for simulation. taxis and regular cars arrive using a
poisson process. the mean time in-between two taxis is 12 minutes. the mean time
in-between two regular cars is 6 minutes. the service time and the time it takes to pay
are sampled from a uniform distribution.
additional declarations used in fig. 24 are:
val max_capacity = 3;
fun st(c) = uniform(2.0, 5.0);
fun pt(c) = uniform(1.0, 2.0);
val sl = 100000;
in our initial simulation model, we allow for 3 cars to queue. the time it takes to
refuel a car is between 2 and 5 minutes (uniform distribution). the time it takes
to pay is between 1 and 2 minutes (uniform distribution). for each simulation
run, we create 100,000 cars. this is reected by parameter slused in module
environment .7.3 monitoring a cpn
figure 24 only models the process we would like to analyze without modeling
the measurements required for analysis. however, to extract simulation results,
this is not sucient; we need to indicate what kind of results should be collected
(e.g., ow times, utilization, costs). in general, we would like to avoid \polluting"
the model with extensions to collect statistics. this is why cpn tools oers
the possibility to add monitors . the idea of a monitor is to collect data from
markings that are reached and bindings that are enabled during the simulation
runs. for example, a marking size monitor counts the average number of tokens
in a place. in fig. 24, we add two such monitors; one for place freepumps and
one for busy. the average number of tokens in busy divided by the number of
pumps, indicates the average utilization of these pumps. to measure the average
number of cars queueing, we add a list length data collection monitor for place
queue .
these monitors can be added without any eort. just select the desired
monitor and attach it to the corresponding place.
measuring the ow time requires a bit more eort. we added the creation
time of a car to the type car. in addition to an id, a car also has a value of
type stime indicating the time it was created by the poisson arrival process in
module environment . transition leaves in module environment consumes cars
that have been served (see fig. 24). this transition res the moment the car has
been refueled and payment has been completed. hence, the dierence between
the time leaves res and the time stored in stime eld of the car token is
the ow time of a car. obviously, we are interested in this duration. later, we
explore various alternatives and analyze their eect on the average ow time of
cars that have been served. using a data collection monitor, we can measure
the ow time. this monitor simply stores measurements. in this case, we need
to specify that we are interested in the dierence between the creation time
and current time. subsequently, these measurements are used by cpn tools to
calculate statistics such as average, variants, upper bounds, and lower bounds.
cars that have not been served have a ow time of 0. therefore, we do not
need to measure the ow time for such cars. however, we want to measure the
fraction of cars that is rejected. again we use a data collection monitor. however,
now we do not measure the ow time, but measure whether a car was rejected
(record a value 1) or not (record a value 0). hence for each car we record 0 or 1.
by computing the average over these values, we know the fraction of cars that
was rejected in the simulation run.
7.4 interpreting the results
after extending the simulation model shown in fig. 24 with monitors, we can
execute a simulation run in which 100,000 cars are generated (see parameter sl)
and inspect the simulation results. for a particular simulation run, we nd that:
{the average length of the list token in queue is 0.915835;{the mean number of tokens in busy is 0.802938;
{the mean number of tokens in freepumps is 0.197062;
{the average ow time of served cars is 9.001130 minutes; and
{the fraction of cars rejected is 0.089430.
hence, the utilization is approximately 80% and on average about one car is
waiting to be served. the average ow time is approximately 9 minutes and
about 9% of the cars is rejected.
based on one simulation run, we cannot make any conclusions. in another
simulation run, the previous results could be dierent. therefore, we need to
compute condence intervals . by repeating the simulation experiment several
times, we can get an idea of the reliability of the results. suppose that we repeat
the experiment 10 times and measure the ow time for each simulation run. if
the 10 values are close to one another, then we can be condent that the result
is reliable. if the 10 values are far apart, then this is an indication that more or
longer simulation runs are needed. using standard statistical methods, one can
compute condence intervals based on subruns. for an introduction to subruns
and condence intervals in the context of cpns, we refer to [6]. here, we just
show the results.
if we compute condence intervals based on 10 simulation runs in which
100,000 cars are generated (i.e., the behavior of 1,000,000 cars is analyzed), then
we get the following 90% condence intervals:
{the average length of the list token in queue is 0:9000:006; that is, with
90% condence the average is between 0 :894 and 0:906;
{the mean number of tokens in busy is 0:7980:001; that is, with 90%
condence utilization is between 0 :797 and 0:799;
{the mean number of tokens in freepumps is 0:2010:001; that is, with 90%
condence the mean number of free pumps is between 0 :200 and 0:202;
{the average ow time of served cars is 8 :9450:020 minutes; that is, with
90% condence the average ow time is between 8 :925 and 8:965; and
{the fraction of cars rejected is 0 :0880:001; that is, with 90% condence
we can conclude that between 8.7% and 8.9% of cars is not served.
condence intervals allow us to compare dierent alternatives. cpn tools au-
tomatically calculates these intervals when the user uses the command:
cpn'replications.nreplications 10
to create more subruns, the parameter of this command can be modied. as
discussed in [6], there is a tradeo between the number of subruns and the length
of each run.
7.5 comparing alternatives
after creating the cpn shown in fig. 24 and adding the monitors, it is easy to
explore various alternative models and compare them. table 2 shows the results
for the original model (i.e., fig. 24) and three alternative models.table 2. statistics of the original process and three redesigns (condence interval of
90%).
process average average average average fraction
queue number of number of ow of cars
length pumps free pumps busy time rejected
original 0 :9000:006 0 :2010:001 0 :7980:001 8 :9450:020 0 :0880:001
extra places 1 :7320:014 0 :1540:001 0 :8460:001 12 :1570:050 0 :0320:001
2nd pump 0 :1070:001 1 :1290:002 0 :8710:002 5 :4310:003 0 :0040:001
faster pump 0 :3890:002 0 :4010:001 0 :5990:001 5 :5410:009 0 :0220:001
in the original cpn, max capacity was set to 3, indicating that at most
three cars can queue. if there are three cars in the queue and a fourth one arrives,
it is rejected (transition reject res). table 2 shows what happens if three more
places are added; that is, max capacity is set to 6 meaning that up to six
cars can queue. more cars are being served, but waiting times and the average
queue length get longer. the ow time increases from approx. 9 minutes to 12
minutes, whereas the percentage of rejected cars decreases to approx. 3%. as
the condence intervals are narrow and non-overlapping, it is justied to make
such conclusions.
instead of adding additional space to wait, we also consider adding an extra
pump. this can be done by adding another token to place freepumps . this
change is costly, but has a positive eect on all performance indicators. as
table 2 shows, the ow time drops to approx. 5 minutes and less than 0.5%
of cars are rejected.
the last row of table 2 shows what happens if we replace the original pump
by a new one that is 30% faster. this alternative is realized by changing the
function that models the service time:
fun st(c) = uniform(1.4,3.5);
the ow time of this alternative is comparable to adding another pump, but
more cars are rejected (approx. 2%).
each of the three redesigns mentioned in table 2 can be modeled in less than
a minute. this illustrates that simulation using cpn tools allows for a quick
exploration of dierent alternatives.
to conclude this section, we look at three more redesigns that all distinguish
between regular cars and taxis. figure 25 shows the adaptations needed to add
an extra pump such that the new pump is only used by taxis whereas the existing
pump is used for regular cars. the type pump has now two possible values ptaxi
andpregular and initially there is one of each. the guard of startserve ensures
that the pumps are used for serving the right type of cars.
table 3 shows the simulation results. the performance is not as good as
adding an extra pump that can be used by any type of car. the ow time
increases from 5 :4310:003 to 6:8000:008 and the fraction of rejected cars
increases from 0 :0040:001 to 0:0330:001. there are two reasons for this. firstp (c,p)@++st(c)
p
(c,p)csc::cs
endservestartserve[(car.of_taxi c andalso p=p_taxi)
orelse(car.of_regular c andalso p=p_regular)]
busy
carxpumpqueue[]
cars
freepumps1`p_taxi++
1`p_regular
pumpfig. 25. changes required to model that taxis have a dedicated pump, i.e., there are
two pumps, one for taxis and one for regular cars.
table 3. statistics for the redesign with a dedicated pump for taxis and a dedicated
pump for regular cars (condence interval of 90%).
average average average average fraction
queue number of number of ow of cars
length pumps free pumps busy time rejected
all cars 0 :4350:002 1 :1530:001 0 :8470:001 6 :8000:008 0 :0330:001
taxis 6 :2810:010 0 :0330:001
regular cars 7 :0580:008 0 :0330:001
of all, it may be that there are three taxis waiting while the pump for regular
cars is free; that is, capacity is unused at times. second, it may even be that the
rst car in the row is \blocking" other cars that could be served. for example,
consider the scenario with two taxis and two regular cars. if one taxi is being
served while the other taxi is rst in line, then the two regular cars get blocked
even though their pump is idle.
table 3 shows results for all cars and results for taxis and regular cars sep-
arately. note that the waiting time of taxis is lower, because on average only 5
taxis arrive each hour, whereas on average 10 regular cars arrive each hour.
next, we consider the situation where taxis have priority; that is, as long
as there are taxis waiting, regular cars are not served. this can be realized by
simply sorting the queue such that taxis are always in front of the queue. table 4
shows the results. the overall ow time is comparable to the original situation.
however, taxis have, on average, shorter waiting times than regular cars.
the last redesign we consider, reserves the places in the queue for taxis.
taxis can queue as long as there are free slots in the queue. however, regular
cars can only enter the queue if no other cars are waiting. hence, regular cars are
always rejected unless the queue is empty. figure 26 shows how the model can
be adapted to realize this redesign. the guards of transitions enqueue andreject
are modied to enforce the new policy. table 5 shows the results. compared totable 4. statistics for the redesign with a single queue where taxis have priority
(condence interval of 90%).
average average average average fraction
queue number of number of ow of cars
length pumps free pumps busy time rejected
all cars 0 :9000:004 0 :2010:001 0 :7980:001 8 :9440:014 0 :0880:001
taxis 6 :8570:007 0 :0880:001
regular cars 9 :9880:021 0 :0880:001
cscs cs^^[c]c c
enqueue[(length cs <
 max_capacity andalsocar.of_taxi c) orelse cs=[]]
reject[not((length cs <
 max_capacity andalsocar.of_taxi c) orelse cs=[])]
queue[]
carscarwaiting
in
fig. 26. only queue if empty
table 5. statistics for the redesign in which regular cars can only queue if the queue
is empty (condence interval of 90%).
average average average average fraction
queue number of number of ow of cars
length pumps free pumps busy time rejected
all cars 0 :3460:001 0 :3000:001 0 :7000:001 6 :7300:007 0 :2000:001
taxis 7 :4750:014 0 :0050:001
regular cars 6 :2040:003 0 :2970:001
the original situation, the fraction of rejected cars increased from 0 :0880:001 to
0:2000:001; that is, approximately twice as many cars are rejected. however,
fewer taxis are rejected (only 0 :0050:001) and the ow time reduced decreased
for all cars (both taxis and regular cars).
the last three redesigns show that it is easy to use properties of the car when
dening policies. this demonstrates the power of cpns compared to timed petri
nets that do not incorporate data.
8 conclusion
colored petri nets (cpns) enhance classical petri nets with commonly agreed
upon extensions such as data, hierarchy, and time. the resulting modeling lan-guage is highly expressive and is supported by cpn tools, a powerful software
tool for the modeling and analysis of cpns.
this paper used a running example to explain several design patterns for
modeling in terms of cpns. these patterns guide users in modeling complex
processes that require interplay of control-ow and data-ow. we showed exam-
ples of simple patterns and more involved ones.
we also introduced the new features of cpn tools. version 3.0 supports
priorities and one can now use real values as time stamps. moreover, the new
simulator is up to twice as fast and is now also supported on 64 bit platforms.
these improvements facilitate simulating complex processes. using our running
example, we showed that it is easy to generate various alternative designs and
using simulation to compare them.
we hope that this paper will help students, researchers, system designers
and process analysts to make better models in less time. for a more in-depth
discussion on modeling in terms of cpns, we refer to [6,19]. for the software
and examples, we refer to cpn tools web page http://cpntools.org .
references
1. w.m.p. van der aalst. interval timed coloured petri nets and their analysis.
in m. ajmone marsan, editor, application and theory of petri nets 1993 , volume
691 of lecture notes in computer science , pages 453{472. springer-verlag, berlin,
1993.
2. w.m.p. van der aalst. process mining: discovery, conformance and enhancement
of business processes . springer-verlag, berlin, 2011.
3. w.m.p. van der aalst, p. de crom, r. goverde, k.m. van hee, w. hofman, h. rei-
jers, and r.a. van der toorn. exspect 6.4: an executable specication tool for
hierarchical colored petri nets. in m. nielsen and d. simpson, editors, applica-
tion and theory of petri nets 2000 , volume 1825 of lecture notes in computer
science , pages 455{464. springer-verlag, berlin, 2000.
4. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workow patterns. distributed and parallel databases , 14(1):5{51, 2003.
5. w.m.p. van der aalst, a.j. mooij, c. stahl, and k. wolf. service interaction:
patterns, formalization, and analysis. in m. bernardo, l. padovani, and g. za-
vattaro, editors, formal methods for web services , volume 5569 of lecture notes
in computer science , pages 42{88. springer-verlag, berlin, 2009.
6. w.m.p. van der aalst and c. stahl. modeling business processes: a petri net
oriented approach . mit press, cambridge, ma, 2011.
7. c. alexander. a pattern language: towns, building and construction . oxford
university press, 1977.
8. j.c.m. baeten, t. basten, and m.a. reniers. process algebra: equational theories
of communicating processes . cambridge tracts in theoretical computer science.
cambridge university press, 1 edition, december 2009.
9. g. balbo. introduction to generalized stochastic petri nets. in m. bernardo and
j. hillston, editors, formal methods for performance evaluation , volume 4486 of
lecture notes in computer science , pages 83{131. springer-verlag, berlin, 2007.
10. m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.11. w. fokkink. introduction to process algebra . springer-verlag, berlin, february
2010.
12. e. gamma, r. helm, r. johnson, and j. vlissides. design patterns: elements
of reusable object-oriented software . professional computing series. addison
wesley, reading, ma, usa, 1995.
13. h.j. genrich and k. lautenbach. system modelling with high level petri nets.
theoretical computer science , 13:109{136, 1981.
14. g. girault and r. valk, editors. petri nets for systems engineering: a guide to
modeling, verication, and applications . springer-verlag, berlin, 2003.
15. k.m. van hee. information system engineering: a formal approach . cambridge
university press, 1994.
16. g. hohpe and b. woolf. enterprise integration patterns . addison-wesley profes-
sional, reading, ma, 2003.
17. k. jensen. coloured petri nets. in w. brauer, w. reisig, and g. rozenberg, edi-
tors, advances in petri nets 1986 part i: petri nets, central models and their prop-
erties , volume 254 of lecture notes in computer science , pages 248{299. springer-
verlag, berlin, 1987.
18. k. jensen. coloured petri nets. basic concepts, analysis methods and practi-
cal use . eatcs monographs on theoretical computer science. springer-verlag,
berlin, 1996.
19. k. jensen and l.m. kristensen. coloured petri nets { modelling and validation
of concurrent systems . springer-verlag, berlin, 2009.
20. k. jensen, l.m. kristensen, and l. wells. coloured petri nets and cpn tools
for modelling and validation of concurrent systems. international journal on
software tools for technology transfer , 9(3-4):213{254, 2007.
21. o. kummer, f.wienberg, m. duvigneau, j. schumacher, m. k ohler, d. moldt,
h. r olke, and r. valk. an extensible editor and simulation engine for petri
nets: renew. in j. cortadella and w. reisig, editors, international conference on
applications and theory of petri nets and other models of concurrency (icatpn
2004) , volume 3099 of lecture notes in computer science , pages 484{493. springer-
verlag, berlin, 2004.
22. m. ajmone marsan, g. balbo, g. conte, s. donatelli, and g. franceschinis. mod-
elling with generalized stochastic petri nets . wiley series in parallel computing.
wiley, new york, 1995.
23. p. merlin and d.j. faber. recoverability of communication protocols. ieee
transactions on communication , 24(9):1036{1043, sept 1976.
24. r. milner, m. tofte, r. harper, and d. macqueen. the denition of standard
ml. the mit press, may 1997.
25. n. mulyar and w.m.p. van der aalst. patterns in colored petri nets. beta
working paper series, wp 139, eindhoven university of technology, eindhoven,
2005.
26. n. mulyar and w.m.p. van der aalst. towards a pattern language for colored
petri nets. in k. jensen, editor, proceedings of the sixth workshop on the practical
use of coloured petri nets and cpn tools (cpn 2005) , volume 576 of daimi ,
pages 39{48, aarhus, denmark, october 2005. university of aarhus.
27. a. rozinat, r.s. mans, m. song, and w.m.p. van der aalst. discovering simulation
models. information systems , 34(3):305{327, 2009.
28. a. rozinat, m. wynn, w.m.p. van der aalst, a.h.m. ter hofstede, and c. fidge.
workow simulation for operational decision support. data and knowledge en-
gineering , 68(9):834{850, 2009.29. n. trcka, w.m.p. van der aalst, and n. sidorova. data-flow anti-patterns:
discovering data-flow errors in workows. in p. van eck, j. gordijn, and
r. wieringa, editors, advanced information systems engineering, proceedings of
the 21st international conference on advanced information systems engineering
(caise'09) , volume 5565 of lecture notes in computer science , pages 425{439.
springer-verlag, berlin, 2009.
30. r. valk. object petri nets: using the nets-within-nets paradigm. in j. desel,
w. reisig, and g. rozenberg, editors, lectures on concurrency and petri nets , vol-
ume 3098 of lecture notes in computer science , pages 819{848. springer-verlag,
berlin, 2004.
31. b. weber, m. reichert, and s. rinderle-ma. change patterns and change support
features: enhancing flexibility in process-aware information systems. data and
knowledge engineering , 66(3):438{466, 2008.
32. workow patterns home page. http://www.workowpatterns.com.
appendix: cpn patterns
in this paper, we used and described several cpn patterns without explicitly
enumerating them. this way we could focus on the running example and the
process of modeling in terms of cpns. in this appendix, we list the patterns
described in [25,26]. this was the rst systematic collection of design patterns
for cpns. note that this collection was based on constructs described in books
such as [6,15,18,19] and examples on the cpn tools website.
1.id matching : to make identical information objects distinguishable. this
pattern is used in most cpn models shown in this paper. for example,
individual cars are distinguished using type car.
2.id manager : to ensure uniqueness of identiers used for distinguishing iden-
tical objects. the places labeled next car id in figs. 1, 7(left), 19(right), 21,
and 24(right) are used to realize this pattern, i.e., each car gets a unique id.
3.aggregate objects : to allow manipulation of a set of information objects as a
single entity. the queue pattern is a specialization of this pattern and used
in various versions of the gas station module (see below). place receivers in
fig. 16 is another example implementing this pattern.
4.queue : to allow manipulation of the queued objects in a strictly specied
order. the places labeled queue in figs. 12(left), 18(left), 19(left), 20, and
24(left) are used to realize this pattern, i.e., cars are put into a list to enforce
a particular order.
5.fifo queue : to allow manipulation of objects from the collection in a strictly
specied order such that an object which arrived rst is consumed rst. the
places labeled queue in figs. 12(left), 18(left), 19(left), 20, and 24(left) are
used to realize this pattern, i.e., cars are put into a list and when a pump
becomes available the car that queued rst is taken.
6.lifo queue : to allow manipulation of objects from the collection in a strictly
specied order, such that the mostly recently added object is retrieved rst.
most queues in this paper use a fifo order. by taking the last element from
the list rather than the rst, a fifo queue can be converted into a lifo
queue.7.random queue : to allow manipulation of objects from the collection such
that objects are added to the queue in any order, and an arbitrary object is
consumed from it.
8.priority queue : to allow manipulation of objects from the collection in the
order of the objects' priority. table 4 shows simulation results for a cpn
model using this pattern.
9.capacity bounding : to prevent over-accumulation of objects in a certain
place. this was the main topic of sect. 4.1. see place being served in fig. 9
(middle) and place queue in fig. 9(right). both places are bounded by a
complement place. the pattern is also used in figs. 10, 11, 12, 13, 14, 17,
18(left), 19(left), 20, 24(left), and 25.
10.inhibitor arc : to support \zero-testing" of places. transition reject in
fig. 10(left) can only re if place queue contains two tokens and, hence,
all free places are taken. fig. 10(right) models this more explicitly by adding
a place that counts the number of free places. in fig. 26, regular cars can
only queue if no taxis are waiting.
11.colored inhibitor arc : to support \non-containment" property of places.
12.shared database : to enable centralized storage of data shared between multi-
ple transitions, supporting dierent levels of data visibility (i.e. local, group,
or global).
13.database management : to specify the interface of accessing data, stored in
a shared database for read-only and modication purposes.
14.copy manager : to make data stored in the shared database available at
other locations for local use, while maintaining the consistency of data in all
places.
15.lock manager : to synchronize access to shared data by means of exclusive
locks. the fuel stations are shared resources that can only be used by one
car at a time. in fig. 25 taxis and regular cars have a dedicated pump. this
can be seen as a form of locking.
16.bi-lock manager : to synchronize access to shared data for reading and writ-
ing purposes by means of shared and exclusive locks.
17.log manager : to record the information about actual process execution by
means of a data log.
18.blocking state-independent filter : to prevent data non-conforming to a cer-
tain property from passing through.
19.blocking state-dependent filter : to prevent data non-conforming to a prop-
erty involving the state of an external data-structure, from passing through.
transition reject in many of the variants of the gas station module is only
allowing cars to queue if the queue is not full yet. consider for example the
two variants shown in fig. 10. taxis that cannot enter the queue will not
be rejected; they are blocked until the queue is not fully occupied anymore.
this can be seen as a variant of this pattern.
20.non-blocking state-independent filter : to lter-out data fullling a certain
property while avoiding accumulation of non-conforming data in the lter
input place.21.non-blocking state-dependent filter : to lter-out data non-conforming to
a property, involving the state of an external data-structure, while avoid-
ing accumulation of non-conforming data in the lter input. consider for
example the two variants shown in fig. 10. regular cars that cannot enter
the queue are immediately rejected; as long as the queue is fully occupied,
regular cars are ltered out. this can be seen as a variant of this pattern.
another example is fig. 26 where regular cars can only queue if no taxis are
waiting.
22.translator : to enable coordinated communication between two actors with
originally dierent data formats.
23.asynchronous transfer : to allow transportation of data from one location
to another, while avoiding the sender to block. the environment module in
fig. 6 does not block while sending cars to the gas station module.
24.synchronous transfer : to allow transportation of data from one location to
another, ensuring that an actor, which posted a request, is blocked until it
does not receive the requested information.
25.rendezvous : allow multiple actors to broadcast and discover data objects
concurrently.
26.asynchronous router : to enable asynchronous transfer of data from a single
source to a dedicated target, providing loose coupling between the source
and targets connected to it.
27.asynchronous aggregator : to provide a holistic view of data, produced by
multiple unrelated sources through asynchronous data aggregation.
28.broadcasting : to allow broadcasting of data from a single source to multiple
targets, while avoiding direct dependencies between them. section 5.2 shows
how to realize a broadcast (see for instance fig. 16).
29.redundancy manager : to prevent the transfer of duplicated data between
loosely-coupled actors who communicate asynchronously.
30.data distributor : to support parallel data processing by distributing data
between several independent actors.
31.data merger : to compose a single information object out of several smaller
ones when all parts required for composition become available.
32.deterministic xor-split : to allow at most one transition out of several pos-
sible to execute, based on fulllment of mutually excluding data conditions.
transitions enqueue and reject in fig. 24(left) form a deterministic xor-
split.
33.non-deterministic xor-split : to allow any transition out of several possible,
but satisfying the same data condition, to execute. transitions serve and
reject in fig. 1 form a (partially) non-deterministic xor-split; regular cars
can be served or rejected in a non-deterministic manner.
34.or: to allow any number of tasks to be selected for execution based on the
fulllment of a certain data condition.
some of the patterns just mentioned (e.g., the queue andcapacity-bounding
patterns) are used frequently in this paper, others are not used at all. the 34
patterns described in [25,26] focus on data management and communication.this explains why several patterns are not used in our running example. some
of the patterns presented in this paper are closer to the workow patterns men-
tioned in sect. 1 [4,32] rather than the original cpn patterns. for example,
theregion flush pattern discussed in sect. 5.3 is closely related to the cancel
region pattern in [4,32]. moreover, compared to the original cpn patterns in
[25,26], we put more emphasis on time (see sect. 6 and sect. 7).