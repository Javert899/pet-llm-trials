ensuring correctness during process conguration via
partner synthesis
wil m.p. van der aalsta,c,, niels lohmannb, marcello la rosac
aeindhoven university of technology, the netherlands
buniversit at rostock, germany
cqueensland university of technology, australia
abstract
variants of the same process can be encountered within one organization or
across dierent organizations. for example, dierent municipalities, courts, and
rental agencies all need to support highly similar processes. in fact, procurement
and sales processes can be found in almost any organization. however, despite
these similarities, there is also the need to allow for local variations in a controlled
manner. therefore, many academics and practitioners have advocated the use
ofcongurable process models (sometimes referred to as reference models). a
congurable process model describes a family of similar process models in a
given domain. such a model can be congured to obtain a specic process model
that is subsequently used to handle individual cases, for instance, to process
customer orders. process conguration is notoriously dicult as there may be all
kinds of interdependencies between conguration decisions. in fact, an incorrect
conguration may lead to behavioral issues such as deadlocks and livelocks. to
address this problem, we present a novel verication approach inspired by the
\operating guidelines" used for partner synthesis. we view the conguration
process as an external service, and compute a characterization of all such services
which meet particular requirements via the notion of conguration guideline .
as a result, we can characterize all feasible congurations (i. e., congurations
without behavioral problems) at design time, instead of repeatedly checking each
individual conguration while conguring a process model.
keywords: congurable process model, operating guideline, petri net,
c-yawl
1. introduction
although large organizations support their processes using a wide variety
of process-aware information systems, the majority of business processes are
corresponding author
email addresses: w.m.p.v.d.aalst@tue.nl (wil m.p. van der aalst),
niels.lohmann@uni-rostock.de (niels lohmann), m.larosa@qut.edu.au (marcello la rosa)
preprint submitted to information systems august 25, 2011still not directly driven by process models [ 1]. despite the success of business
process management (bpm) thinking in organizations, workow management
(wfm) systems | today often referred to as bpm systems | are not widely used.
one of the main problems of bpm technology is the \lack of content"; that is,
providing just a generic infrastructure to build process-aware information systems
is insucient as organizations need to support specic processes. organizations
want to have \out-of-the-box" support for standard processes and are only
willing to design and develop system support for organization-specic processes.
yet most bpm systems expect users to model basic processes from scratch.
enterprise resource planning (erp) systems such as sap and oracle, on the
other hand, focus on the support of these common processes. although all
erp systems have workow engines comparable to the engines of bpm systems,
lion's share of processes supported by these systems are not driven by models.
for example, most of sap's functionality is not grounded in their workow
component, but hard-coded in application software. erp vendors try to capture
\best practices" in dedicated applications designed for a particular purpose. such
systems can be congured by setting parameters. system conguration can be a
time consuming and complex process. moreover, conguration parameters are
exposed as \switches in the application software", thus making it dicult to see
the intricate dependencies among certain settings.
a model-driven process-oriented approach toward supporting business pro-
cesses has all kinds of benets ranging from improved analysis possibilities
(verication, simulation, etc.) and better insights, to maintainability and ability
to rapidly develop organization-specic solutions [ 1,2]. although obvious, this
approach has not been adopted thus far, because bpm vendors have failed to
provide content and erp vendors suer from the \law of the handicap of a head
start". erp vendors manage to eectively build data-centric solutions to sup-
port particular tasks. however, the complexity and large installed base of their
products makes it hard to refactor their software and make it process-centric.
based on the limitations of existing bpm and erp systems, we propose to
usecongurable process models . a congurable process model represents a family
of process models ; that is, a model that through conguration can be customized
for a particular setting. by developing comprehensive collections of congurable
models, one could capture all possible process variations in a particular domain.
for example, one could create a congurable process model for logistics, one
for insurance, etc. from the viewpoint of erp software, congurable process
models can be seen as a means to make these systems more process-centric,
although quite some refactoring would be needed as processes are hidden in
table structures and application code.
various congurable languages have been proposed as extensions of existing
languages (e. g., c-epcs [ 3], c-iepcs [ 4], c-wf-nets [ 5], c-sap and c-bpel [ 6])
but few are actually supported by enactment software (e. g., c-yawl [ 6]). in this
paper, we are interested in models in the latter class of languages, which, unlike
traditional reference models [ 7{10], are executable after they have been congured.
specically, we focus on the verication of congurable executable process models .
in fact, because of conguring a process model, the resulting congured model
2may suer from behavioral anomalies such as deadlocks and livelocks. this
problem is exacerbated by the total number of possible congurations a model
may have, which may be very large, and by the complex domain and data
dependencies which may exist between various conguration options. checking
thefeasibility of each single conguration can be time consuming as this would
typically require performing state-space analysis. moreover, characterizing the
\family of correct models" for a particular congurable process model is even
more dicult and time-consuming as a naive approach would require solving
an exponential number of state-space problems, which is unfeasible for large
real-life models.
as far as we know, our earlier approach [ 5] is the only one focusing on the
verication of congurable process models which takes into account behavioral
correctness and avoids the state-space explosion problem. other approaches
either only discuss syntactical correctness related to conguration [ 3,11,12], or
deal with behavioral correctness but run into the state-space problem [ 13,14].
in this paper, we propose a novel verication approach where we consider the
conguration process as an \external service" and then synthesize a \most
permissive partner" using the approach described by wolf [ 15] and implemented
in the tool wendy [ 16]. this most permissive partner is closely linked to the
notion of operating guidelines for service behavior [ 17]. in this paper, we dene
for any congurable model a so-called conguration guideline to characterize all
correct process congurations. this approach provides the following advantages
over our previous approach [5]:
we provide a complete characterization of all possible (correct) congura-
tions at design time ; that is, the conguration guideline .
computation time is moved from conguration time to design time and
results can be reused more easily.
no restrictions are put on the class of models which can be analyzed. the
previous approach [ 5] was limited to sound free-choice wf-nets. our new
approach can be applied to models which do not need to be sound, which
can have complex (non-free choice) dependencies, and which can have
multiple end states.
to prove the practical feasibility of this new approach, we have implemented
it as a component of the toolset supporting c-yawl.
the remainder of this paper is organized as follows. in section 2 we elaborate
on the need for process conguration and dene the problem in a language
independent manner. section 3 introduces basic concepts such as open nets
and weak termination. these concepts are used in section 4 to formalize the
notion of process conguration. section 5 presents the solution approach for
correctness ensuring conguration. often congurable process models cannot
be freely congured and domain constraints and data dependencies need to be
taken into account. for example, one cannot skip an activity that produces data
to be used in a later phase of the process. therefore, section 6 shows how to
3incorporate such constraints. section 7 discusses tool support. related work is
discussed in section 8. section 9 concludes the paper.
2. motivation
the need for conguring business processes arises in many domains. for
example, there are about 430 municipalities in the netherlands. however, in
principle, they all execute variants of the same set of processes. for example,
they all support processes for registering a marriage or a divorce.
variability also occurs in the insurance domain. for example suncorp, the
largest australian insurance group, oers various insurance products using
dierent brands such as suncorp, aami, apia, gio, just car, bingle, vero,
etc. there are insurance processes for each product (home, motor, commercial,
liability, etc.) and these processes exist for the dierent suncorp brands. in
fact, there are up to 30 dierent variants of the process of handling an insurance
claim at suncorp.
organizations such as suncorp need to support many variants of the same
process (intra-organizational variation). likewise, dierent municipalities in
a country need to oer similar services to their citizens, and, hence, need to
manage similar collections of process models. however, due to demographics
and political choices, municipalities are handling things dierently. sometimes
these dierences are unintentional; however, often these dierences can be easily
justied by the desired \couleur locale" (inter-organizational variation). clearly,
it is undesirable to support these intra- and inter-organizational variations by
making copies of the same process models (and related it systems!) that are
subsequently adapted. hence, it is important to support variability directly at
the process model level.
in this paper, we support process variability by means of congurable process
models . a congurable process model captures the behavior of all possible
process variants and can be congured to each specic variant. accordingly,
conguration corresponds to removing process behavior . clearly, other viewpoints
are possible. for example, some authors also consider renement and model
extension as conguration primitives [ 12{14,18,19]. we will discuss such
alternative approaches in section 8.
specically, we focus on two operators to remove process behavior: i) hiding ,
i.e. bypassing, and ii) blocking , i.e. inhibiting, which are applied to the variation
points of a congurable process model. hiding and blocking are two basic
operators for removing process behavior [ 5], since they apply to single activities.
in fact, all other conguration mechanisms for removing process behavior that
are available in the literature, can be expressed in terms of hiding and blocking
(e.g., [3, 6, 20]).
the congured model that results from a conguration can be analyzed using
traditional process verication approaches. in this paper, we call a conguration
feasible if the congured model is considered to be correct. in particular, we use
the notion of weak termination as a correctness criterion, according to which
4a process instance can always terminate correctly. this notion excludes the
possibility of anomalies such as deadlocks and livelocks in the congured model.
other variants of soundness can be also used [ 21], but this requires adaptations
with respect to the analysis technique used.
using existing techniques, it is already challenging to verify a single con-
crete model. however, in process conguration, there can potentially be many
congured models which would need to be veried. in fact, if a model has n
variation points which are \allowed" by default and can all be congured as
\hidden" or \blocked", there are 3npossible congurations, each leading to a
congured model. for example, the congurable process model we constructed
from the vics documentation1| an industry standard for logistics and supply
chain management | comprises 50 activities, which result in 350possible cong-
urations (an extremely large number) [ 22]. thus, as pointed out in section 1,
it is unrealistic to assume that the brute-force approach depicted in fig. 1 will
work in practice.
configurable 
process model3n configured 
process models3n correctness 
checks
figure 1: classical, brute force, approach to verify the correctness of congurations.
one could use a trail-and-error approach when conguring a congurable
process model. however, ideally the information system should support the con-
guration process by proactively removing conguration possibilities that result
in incorrect process models. in fact, one would like to have a characterization
ofallfeasible congurations and an \auto-complete" option that automatically
completes a partial conguration while ensuring the correctness of the nal
model.
configurable 
process model
controllerconfiguration 
guideline
figure 2: the approach presented in this paper. we reason about controllers that ensure
feasible congurations. using partner synthesis, we create one conguration guideline capturing
all feasible congurations.
given the above requirements, we propose a completely dierent approach
which is shown in fig. 2. rather than exhaustively trying all 3npossible
congurations, we construct a \controller" that congures the process model
correctly. using controller synthesis [ 15,16], we synthesize a so-called \most
1seewww.vics.com
5permissive partner" (see section 5.2). this is the controller that does not
remove any feasible congurations. note that such a partner can be seen as an
external service that congures the congurable model. the most permissive
partner will serve as a conguration guideline steering the designer toward a
good conguration. this provides us with a complete characterization of all
feasible congurations at design time. unlike existing approaches, we do not
need to impose all kinds of syntactical restrictions on the class of models to be
considered. moreover, computation is moved from conguration time to design
time and advanced functionality such as \auto-completion" comes into reach.
the ideas presented in this section are generic and do not depend on a
particular representation. however, in order to explain the approach and to
formalize the concepts, we use petri nets. the next section introduces some
preliminary concepts on petri net.
3. business process models
for the formalization of the problem we use petri nets, which oer a formal
model of concurrent systems. however, the same ideas can be applied to other
languages (e. g. c-yawl, c-bpel), as it is easy to map the core structures of
these languages onto petri nets. moreover, our analysis approach is quite generic
and does not rely on specic petri net properties.
denition 1 (petri net). amarked petri net is a tuplen= (p;t;f;m 0)
such that: pandt(p\t=;) are nite sets of places and transitions,
respectively, f(pt)[(tp) is a ow relation, and m0:p!nis an
initial marking.
a petri net is a directed graph with two types of nodes: places and transitions,
which are connected by arcs as specied in the ow relation. if p2p,t2t,
and (p;t)2f, then place pis an input place of t. similarly, ( t;p)2fmeans
thatpis an output place of t.
the marking of a petri net describes the distribution of tokens over places and
is represented by a multiset of places . for example, the marking m= [a2;b;c4]
indicates that there are two tokens in place a, one token in b, and four tokens in c.
formallymis a function such that m(a) = 2,m(b) = 1, andm(c) = 4. we use
to compose multisets; for instance, [ a2;b;c4][a2;b;d2;e] = [a4;b2;c4;d2;e].
a transition is enabled and can reif all its input places contain at least one
token. firing is atomic and consumes one token from each of the input places
and produces one token on each of the output places. m0t  !mmeans that tis
enabled in marking m0and the ring of tinm0results in marking m. we use
m0  !mto denote that mis reachable from m0; that is, there exists a (possibly
empty) sequence of enabled transitions which by ring lead from m0tom.
for our conguration approach, we use open nets . initially, open nets were
introduced as an extension of workow nets (wf-nets) [ 1], sometimes also referred
to as loosely coupled inter-organizational workows [ 23], open wf-nets (owf-
nets) [ 24], or workow modules [ 25]. whereas wf-nets are closed, open nets
6are enriched with communication places to model channels for sending/receiving
messages to/from other open nets. in other publications the requirement, typical
of wf-nets, of having a dedicated source place (i.e. a place without input
transitions) and a dedicated sink place (i.e. a place without output transitions)
was dropped [ 26]. accordingly, in this paper we allow multiple source and sink
places, an arbitrary initial marking and multiple nal markings. as discussed
in section 5.2, many results for open nets with asynchronous communication
can be extended to open nets with synchronous communication [ 15]. in fact, in
this paper we will only use synchronous communication as this simplies the
modeling of process conguration. therefore, we dene a variant of open nets
without communication places but with transitions that can synchronize with
transitions in other open nets based on common labels. hence, open nets extend
classical petri nets with the identication of nal markings 
, a set of labels l,
and a function `which assigns labels to transitions.
denition 2 (open net). a tuplen= (p;t;f;m 0;
;l;`) is an open net if
(p;t;f;m 0) is a marked petri net (called the inner net ofn),

p!nis a nite set of nal markings ,
lis a nite set of labels ,
62lis a label representing invisible (also called silent) steps, and
`:t!l[fgis alabeling function .
we use transition labels to represent the activity corresponding to the execu-
tion of a particular transition. this way we can model the situation where an
activity appears multiple times in a model. two transitions having the same
visible label refer to the same activity. the special label refers to an invisible
step, sometimes referred to as \silent". we use invisible transitions to represent
internal actions which do not mean anything at the business level. we use visible
labels to denote activities that may be congured. later, in section 5 we use
these labels to synchronize two open nets.
note that denition 2 does not allow for communication places; it is sucient
to introduce transition labels that can be used to model synchronous commu-
nication. therefore, the inner net , i.e., the process without communication
capabilities, is simply the core petri net and its initial marking.
figure 3 shows an example open net which models a typical travel request
approval. the process starts with the preparation of the travel form. this can
either be done by an employee or be delegated to a secretary. in both cases, the
employee personally needs to arrange the travel insurance. if the travel form has
been prepared by the secretary, the employee needs to check it before submitting
it for approval. an administrator can then approve or reject the request, or
make a request for change. now, the employee can update the form according
to the administrator's suggestions and resubmit it. in fig. 3 all transitions bear
7p2
p3
p5
p8t3t1 t2
t4
t6prepare 
travel form
(secretary)prepare 
travel form(employee)
approve
travel form
(admin)reject
travel form
(admin)submit travel form 
for approval 
(employee)request for 
change
(admin)t7check & update travel form(employee)arrange travel insurance(employee)
p4
t5
p6
p7
t9 t8p1
xor-joinxor-split
and-joinand-splitflow
placetransition
tokenfigure 3: the open net for travel request approval (
 = f[p8]g).
a visible label, except for t5which bears a -label as it has only been added for
routing purposes.
unlike our previous approach [ 5] based on wf-nets [ 1] and hence limited
to a single nal place, here we allow multiple nal markings . good runs of an
open net end in a marking in set 
. therefore, an open net is considered to be
erroneous if it can reach a marking from which no nal marking can be reached
any more. an open net weakly terminates if a nal marking is reachable from
every reachable marking.
denition 3 (weak termination). an open net n= (p;t;f;m 0;
;l;`)
weakly terminates if and only if for any marking mwithm0  !mthere exists a
nal marking mf2
 such that m  !mf.
the net in fig. 3 is weakly terminating. weak termination is a weaker notion
than soundness, as it does not require transitions to be quasi-live [ 21]. this
correctness notion is more suitable as parts of a correctly congured net may be
left dead intentionally.
in this paper, we will restrict ourselves to open nets that are bounded , i.e.,
only nitely many states are reachable from the initial marking. the denitions
in this paper also apply to unbounded nets. however, since open nets describe
the life-cycle of one process instance in isolation (e.g., a travel request), there is
no need to consider unbounded behavior. moreover, most synthesis problems
are known to be undecidable for unbounded nets [27].
84. process model conguration
we use open nets to model congurable process models. an open net can
be congured by blocking or hiding activities. blocking activity ameans that
all transitions labeled aare removed. the corresponding activity is no longer
available, i.e., paths visiting a transition corresponding to the blocked activity
cannot be taken any more. hiding activity ameans that all transitions labeled
aare skipped rather than executed. hiding a transition means that it can be
bypassed, i.e., the path containing the transition can still be taken. if a transition
is neither blocked nor hidden, we say it is allowed, meaning it remains in the
model. conguration is achieved by setting visible labels to allow ,hide orblock.
denition 4 (open net conguration). letnbe an open net with label
setl. a mapping cn:l!fallow;hide;blockgis aconguration for n. we
dene:
ac
n=ft2tj`(t)6=^cn(`(t)) = allowg,
hc
n=ft2tj`(t) =_cn(`(t)) = hideg, and
bc
n=ft2tj`(t)6=^cn(`(t)) = blockg.
an open net conguration implicitly denes an open net, called congured
net, where the blocked transitions are removed and the hidden transitions are
given a-label.
denition 5 (congured net). letn= (p;t;f;m 0;
;l;`) be an open net
andcna conguration of n. the resulting congured net c
n= (p;tc;fc;m0;

;l;`c) is dened as follows:
tc=tn(bc
n),
fc=f\((p[tc)(p[tc)), and
`c(t) =`(t) fort2ac
nand`c(t) =fort2hc
n.
as an example, fig. 4(a) shows the congured net derived from the open net
in fig. 3 and the conguration cn(prepare travel form (secretary )) = block
(to allow only employees to prepare travel forms), cn(arrange travel insurance
(employee )) = hide (to skip arranging the travel insurance), and cn(x) =allow
for all other labels x.
a congured net may have disconnected nodes and some parts may be dead
(i. e., can never become active). such parts can easily be removed. however,
as we impose no requirements on the structure of congurable models, these
disconnected or dead parts are irrelevant with respect to weak termination. for
example, if we block the label of t2in fig. 3, transition t5becomes dead as it
cannot be enabled any more, and hence can also be removed without causing any
behavioral issues. nonetheless, not every conguration of an open net results in
a weakly terminating congured net. for example, by blocking the label of t4in
9p2
p3
p5
p8t3t2
t4
t6prepare 
travel form
(employee)
approve
travel form
(admin)reject
travel form
(admin)submit 
travel form 
for approval (employee)request for 
change
(admin) t7check & update travel form
(employee)p4
t5
p6
p7
t9 t8
p2
p3
p5
p8t3t2
t6prepare travel form
(employee)
approve
travel form
(admin)reject
travel form
(admin)submit 
travel form 
for approval (employee)request for 
change
(admin)t7p4
t5
p6
p7
t9 t8
(a) a weakly terminating configured netp1 p1
(b) an incorrectly configured netfigure 4: two possible congured nets based on the model in fig. 3.
the congured net of fig. 4(a), we obtain the congured net in fig. 4(b). this
net is not weakly terminating because after ring t7tokens will get stuck in p3
(as this place does not have any successor) and in p5(ast5can no longer re).
blocking can cause behavioral anomalies such as the deadlock in fig. 4(b).
however, hiding cannot cause such issues, because it merely changes the labels
of an open net. in this paper we are interested in all congurations which yield
weakly terminating congured nets. we use the term feasibility to refer to such
congured nets.
denition 6 (feasible conguration). letnbe an open net and cna
conguration of n.cnisfeasible if and only if the congured net c
nweakly
terminates.
more precisely, given a congurable process model n, we are interested in
the following two questions: i) is a particular conguration cnfeasible? ii) how
to characterize the set of allfeasible congurations?
the remainder of this paper is devoted to a new verication approach an-
swering these questions. this approach extends the work in [ 5] in two directions:
(i) it imposes no unnecessary requirements on the congurable process model (al-
lowing for non-free-choice nets [ 28] and nets with multiple end places/markings),
and (ii) it checks a weaker correctness notion (i. e. weak termination instead
of soundness). for instance, the net in fig. 3 is not free-choice because t4and
t5share an input place, but their sets of input places are not identical. the
non-free-choice construct is needed to model that after ring t1ort7,t5cannot
be red, and similarly, after ring t2,t4cannot be red.
105. correctness ensuring conguration
to address the two main questions posed in the previous section, we could
use a direct approach by enumerating all possible congurations and simply
checking whether each of the congured nets c
nweakly terminates or not (see
fig. 1). as indicated before, the number of possible congurations is exponential
in the number of congurable activities. moreover, most techniques for checking
weak termination typically require the construction of the state space. hence,
traditional approaches are computationally expensive and do not yield a useful
characterization of the set of all feasible conguration. consequently, we propose
a completely dierent approach using the synthesis technique described in [ 15].
as shown in fig. 2, the core idea is to see the conguration as an \external service"
and then synthesize a \most permissive partner". this most permissive partner
represents all possible \external conguration services" which yield a feasible
conguration. the idea is closely linked to the notion of operating guidelines
for service behavior [ 17]. an operating guideline is a nite representation of all
possible partners. similarly, our conguration guideline characterizes all feasible
process congurations . this conguration guideline can also be used to eciently
check the feasibility of a particular conguration without exploring the state space
of the congured net . our approach consists of three steps:
1.transform the congurable process model ninto a conguration interface
nci.
2.synthesize the \most permissive partner" (our conguration guideline )
qcnfor the conguration interface nci.
3. study the composition of nciwithqcn.
in the remainder of this section we explain these three steps. we will
use two types of conguration interfaces: one where everything is allowed by
default and the external conguration service can block or hide labels and one
where everything is blocked by default and the external conguration service can
\unblock" (i. e., allow or hide) labels. section 5.1 provides some more preliminaries
needed to reason about conguration interfaces. in section 5.2, we informally
describe how to check the existence of a partner and how to construct a most
permissive partner. the conguration interface in which everything is allowed
by default is presented in section 5.3. the conguration interface in which
everything is blocked by default is presented in section 5.4. section 5.5 shows
another example to illustrate the concepts.
5.1. composition and controllability
for our solution approach, we compose the congurable process model with a
\conguration service" q. to do so, we rst introduce the notion of composition .
open nets can be composed by synchronizing transitions according to their
visible labels. in the resulting net, all transitions bear a -label and labeled
transitions without counterpart in the other net disappear.
11denition 7 (composition). fori2f1;2g, letni= (pi;ti;fi;m0i;
i;li;`i)
be open nets. n1andn2arecomposable if and only if the inner nets of n1and
n2are pairwise disjoint. the composition of two composable open nets is the
open netn1n2= (p;t;f;m 0;
;l;`) with:
p=p1[p2,
t=ft2t1[t2j`(t) =g[f (t1;t2)2t1t2j`(t1) =`(t2)6=g,
f= ((f1[f2)\((pt)[(tp)))[f(p;(t1;t2))2ptj(p;t1)2
f1_(p;t2)2f2g[f ((t1;t2);p)2tpj(t1;p)2f1_(t2;p)2f2g,
m0=m01m02,

 =fm1m2jm12
1^m22
2g,
l=;, and`(t) =for allt2t.
via composition, the behavior of each original net can be limited; for instance,
transitions may no longer be available or may be blocked by one of the two
original nets. furthermore, nal markings have an impact on weak termination:
nal markings of the compositions consist of the nal markings of each composed
net. hence, it is possible that n1andn2are weakly terminating, but n1n2
is not. similarly, n1n2may be weakly terminating, but n1andn2are not.
the labels of the two open nets in def. 7 serve now a dierent purpose: they are
not used for conguration, but for synchronous communication as described in
[15]. as discussed in section 3, we consider open nets without communication
places as we restrict ourselves to synchronous communication. therefore, the
inner nets need to be pairwise disjoint.
with the notions of composition and weak termination, we dene the con-
cept of controllability , which we need to reason about the existence of feasible
congurations.
denition 8 (controllability). an open net niscontrollable if and only if
there exists an open net n0such thatnn0is weakly terminating.
open netn0is called a partner ofnifnn0is weakly terminating. hence,
nis controllable if there exists a partner. wolf [ 15] presents an algorithm to
check controllability: if an open net is controllable, this algorithm can synthesize
a partner.
5.2. checking controllability and partner synthesis
we briey describe an algorithm from wolf [ 15] to construct a partner for an
open if one exists. the approach is limited to bounded open nets. for innite
state systems, a related controllability notion is undecidable [ 27]. the algorithm
does not directly construct an open net, but a nite-state automaton. the
latter can be transformed into a petri net model using standard techniques and
tools [29, 30].
12to construct a partner for an open net n, we rst overapproximate the
behavior of any open net that is composable to n. as the marking of nis not
observable by the partner, we can only make assumptions based on the previous
communication with n. these assumptions and the uncertainty about the exact
state is modeled by a setsof markings the open net can reach at a certain
point of interaction. this set scontains all markings that can be reached in
nwithout requiring any actions of the environment. that is, scontains those
states that are reachable only by -labeled transitions. hence, the set scan be
treated as a state of a partner of n.
the successors of the set scan be constructed according to the labels of n.
given a label l2l, we construct a new set s0that contains all markings that
can be reached by an l-labeled transition from a marking m2s. again, we
add all markings to s0that can be reached only by -labeled transitions. the
resulting set s0is then the l-labeled successor of s.
in the resulting automaton, we treat those sets that contain a nal marking
ofnas nal states of the partner. the initial state is the set that contains
exactly the initial marking m0ofnand those markings that can be reached
fromm0with only-labeled transitions.
for a bounded open net n, the set construction eventually terminates,
because only a nite number of marking sets exist. however, it is not guaranteed
that the resulting automaton ensures weak termination. therefore, in a last
step, we need to remove all sets sthat contain markings from which no nal
marking of nis reachable. this removal has to be continued until a xed point
is reached. unless all sets are removed, the resulting automaton is a partner of
nand we can conclude that nis controllable.
the partner automaton nfound using the above procedure represents the
\most permissive partner".
details on the algorithm as well as a formal denition can be found in [ 15].
the algorithm is implemented in the tool wendy [ 16] which also implements
several reduction techniques that avoid the generation of sets that would be
removed in later steps.
5.3. conguration interface: allow by default
after these preliminaries, we dene the notion of a conguration interface .
one of the objectives of this paper was to characterize the set of all feasible con-
gurations by synthesizing a \most permissive partner". to do this, we transform
a congurable process model (i. e., an open net n) into an open net nci, called
the conguration interface, which can communicate with services which congure
the original model. in fact, we shall provide two conguration interfaces: one
where everything is allowed by default and the external conguration service
can block and hide labels, and the other where everything is blocked by default
and the external conguration service can allow and hide labels. similarly, one
can construct a hide by default variant, which we do not illustrate in this paper.
in either case, the resulting open net nciis controllable if and only if there
exists a feasible conguration cnofn. without loss of generality, we assume a
131-safe initial marking; that is, m0(p)>0 impliesm0(p) = 1. this assumption
helps to simplify the conguration interface and any net whose initial marking is
not 1-safe can easily be converted into an equivalent net having a 1-safe initial
marking.
denition 9 (conguration interface; allow by default). letn= (p;t;
f;m 0;
;l;`) be an open net. we dene the open net with conguration interface
nci
a= (pc;tc;fc;mc
0;
c;lc;`c) with
pc=p[fpstartg[fpx;pa
x;pb
x;ph
xjx2lg,
tc=t[ftstartg[fbx;hxjx2lg,
fc=f[f(pstart;tstart)g[f(tstart;p)jp2p^m0(p) = 1g[f(t;px);(px;t)j
`(t) =xg[f (bx;pstart);(pstart;bx)jx2lg[f (hx;pstart);(pstart;hx)jx2
lg[f (pa
x;bx);(px;bx);(bx;pb
x)jx2lg[f (pa
x;hx);(hx;ph
x)jx2lg,
mc
0= [p1jp2fpstartg[fpx;pa
xjx2lg],2

c=fml
x2lm
xjm2
^ 8x2lm
x2f[px;pa
x];[pb
x];[px;ph
x]gg,3
lc=fstartg[f block x;hide xjx2lg
`c(tstart) =start,`c(bx) =block xand`c(hx) =hide xforx2l, and
`c(t) =fort2t.
figure 5 illustrates the two conguration interfaces for a simple open net
n. in both interfaces, the original net nconsisting of places fp1;p2;p3;p4gand
transitionsft1;t2;t3;t4gis retained, but all transition labels are set to . let
us rst focus on the conguration interface where all activities are allowed by
default (fig. 5(b)). the conguration interface consists of three parts: first,
placespxandpyare added and connected with biows to each transition of
the original net. these places are used to control, for each label, whether a
transition is blocked (i. e., the place is unmarked) or may re (i. e., the place
is marked). second, the status of each label is modeled by the places pa
xand
pa
y(allowed),pb
xandpb
y(blocked), and ph
xandph
y(hidden). as we consider an
allow-by-default scenario, places px,pa
x,py, andpa
yare initially marked. with
two transitions for each label ( bxandhxfor blocking and hiding x-labeled
transitions, and byandhyfor blocking and hiding y-labeled transitions), the
status can be changed by the environment by synchronizing via labels block x,
hide x,block y, and hide y, respectively. finally, transition tstarthas been added to
ensure conguration actions take place before the original net is activated. this
2[pkjp2x] denotes the multiset where each element of xappears ktimes. initially, pstart
contains one token. since everything is allowed by default, also pxandpa
xcontain a token in
the initial marking ( x2l).
3recall that m1m2denotes the composition of two multisets. the set of nal markings
imposes no restrictions on the newly added places. for label x, any of the three possible
states | allowed [ px; pa
x], blocked [ pb
x], or hidden [ px; ph
x] | is possible.
14p1p2p3p4t1t2t3t4xyτx(a) open net n
(
 =f[p4]g)
p1p2p3p4starttstartpbxpbyt1t2t3t4ττττpstart
paypaxphyhyhideyphxhxhidexblockxblockybxbypxpy
(b) congurable interface nci
a(allow by de-
fault)
p1p2p3p4starttstartpbxpbyt1t2t3t4ττττpstart
paypaxphyhyhideyphxhxhidexpxpyallowxallowyayax(c) congurable interface nci
b(block by de-
fault)
figure 5: an example open net (a) and its two conguration interfaces: (b) shows the allow
by default variant and (c) shows the block by default variant.
way, we avoid \conguration on the y". note that currently the only constraint
with respect to the nal marking is that the original net must reach its nal
marking | all added places may be marked arbitrarily. in sect. 6, we shall rene
this nal marking to encode domain knowledge and data dependencies. we shall
discuss the construction of the conguration interface where all activities are
blocked by default later on.
consider now a conguration service represented as an open net q.nci
aq
is the composition of the original open net ( n) extended with a conguration
interface (nci
a), and the conguration service q. in the initial phase, i. e., before
start res, only blocking and hiding transitions such as bx,by,hx, andhycan
re (apart from unlabeled transitions in q). next, transition start res after
which blocking and hiding transitions such as bx,by,hx, andhycan no longer
re. hence, only the original transitions in nci
acan re in the composition after
ring start. the conguration service qmay still execute transitions, but these
cannot inuence nci
aany more. hence, qrepresents a feasible conguration if
15and only if nci
acan reach one of its nal markings from any reachable marking
in the composition. so qcorresponds to a feasible conguration if and only if
nci
aqis weakly terminating; that is, qis a partner of nci
a.
to illustrate the basic idea, we introduce the notion of a canonical con-
guration partner ; that is, the representation of a conguration cn:l!
fallow;hide;blockgin terms of an open net which synchronizes with the original
model extended with a conguration interface.
denition 10 (canonical conguration partner; allow by default). let
nbe an open net and let cn:l!fallow;hide;blockgbe a conguration for
n.qcna= (p;t;f;m 0;
;lq;`) is the canonical conguration partner with:
l=fx2ljcn(x)6=allowgis the set of labels other than \allow",
p=fp0
x;p!
xjx2lg,
t=ftxjx2lg[ftstartg,
f=f(p0
x;tx);(tx;p!
x);(p!
x;tstart)jx2lg,
m0= [(p0
x)1jx2l],4

 =f[ ]g,
lq=fblock x;hide xjx2lg[f startg,
`(tx) =block x, ifcn(x) =block ,`(tx) =hide x, ifcn(x) =hide, and
`(tstart) = start.
the set of labels which need to be blocked or hidden to mimic conguration
cnis denoted by l. the canonical conguration partner qcnahas a transition
for each of these labels. these transitions may re in any order after which the
transition with label start res. we observe that in the composition nci
aqcna
rst all transitions with a label in fblock x;hide xjx2lgre in a synchronous
manner (i. e., txinqcnares together with bxorhxinnci
a), followed by the
transition with label start (in both nets). after this, the net is congured and
qcnaplays no role in the composition nci
aqcnaany more.
the following lemma formalizes the relation between the composition nci
a
qcnaand feasibility.
lemma 1. letnbe an open net and let cnbe a conguration for n.cnis a
feasible conguration if and only if nci
aqcnais weakly terminating.
proof. ()) letcnbe a feasible conguration for nand letnci
abe as dened
in def. 9. consider the composition nci
aqcnaafter the synchronization via
label start has occurred. by construction, (1) nci
aqcnareached the marking
4recall that [ pkjp2x] denotes the multiset where each element of xappears ktimes. [ ]
denotes the empty multiset.
16m=m0m1m2such thatm0is the initial marking of n,m1marks all
placespa
x,pb
x, andph
xof the labels xwithcn(x) =allow ,cn(x) =block , and
cn(x) =hide, respectively. furthermore, place pxis marked for all unblocked
labelsx. marking m2is the empty marking of qcn. furthermore, (2) all
transitions which bear a synchronization label (i. e., tstart and allbxandhx
transitions) and all blocked transitions t2bc
nare dead in mand cannot become
enabled any more. from nci
a, construct the net nby removing these transitions
and their adjacent arcs, as well as the places added in the construction ( pstartand
pa
x,pb
x, andph
xfor all labels x2l). the marking of these places does not change
any more, i. e., they either always contain a token or remain unmarked, and we
already removed the transitions that are blocked. the resulting net ncoincides
withc
n(modulo renaming of labels which has no eect on termination). hence,
nci
aqcnaweakly terminates.
(() assumenci
aqcnaweakly terminates. from qcna, we can straight-
forwardly derive a conguration cfornin which all labels are blocked which
occur innci
aqcna. with the same observation as before, we can conclude
thatc
ncoincides with the net nconstructed from nci
aafter the removal the
described nodes. hence, c
nweakly terminates and cis a feasible conguration
forn.
lemma 1 states that checking the feasibility of a particular conguration can
be reduced to checking for weak termination of the composition. however, the
reason for modeling congurations as partners is that we can synthesize partners
and test for the existence of feasible congurations.
theorem 1 (feasibility coincides with controllability) .letnbe an open net.
nci
ais controllable if and only if there exists a feasible conguration cnofn.
proof. ()) ifnci
ais controllable, then there exists a partner n0ofnci
asuch
thatnci
an0is weakly terminating. consider a marking mof the composition
reached by a run from the initial marking of nci
an0to the synchronization
via label start . using the construction from the proof of lemma 1, we can derive
a netnfromnci
awhich coincides with a congured net c
nfor a conguration
cn. asnci
an0is weakly terminating, cnis feasible.
(() ifcnis a feasible conguration of n, then by lemma 1, nci
aqcna
weakly terminates and by def. 8, nci
ais controllable.
as shown in section 5.2, it is possible to synthesize a partner which is most-
permissive . this partner simulates any other partner and thus characterizes
all possible feasible congurations. in previous papers on partner synthesis in
the context of service oriented computing, the notion of an operating guideline
was used to create a nite representation capturing all possible partners [ 17].
consequently, we use the term conguration guideline (cg) to denote the
most-permissive partner of a conguration interface. figure 6(a) shows the
conguration guideline cgafor the congurable model in fig. 5(a), computed
from the conguration interface nci
ain fig. 5(b).
17 	
  	
 
	
  	
 	
   	
 
  (a)cgaallow by default
 	
  	

 	
   	
   	
  	
 
   
(b)cgbblock by default
figure 6: two conguration guidelines characterizing all possible congurations.
a conguration guideline is an automaton with one start state and one or
more nal states. any path in the conguration guideline starting in the initial
state and ending in a nal state corresponds to a feasible conguration . the
initial state in fig. 6(a) is denoted by a small arrow and the nal states are
denoted by double circles. the leftmost path in fig. 6(a) (i. e., hblock x;starti),
corresponds to the conguration which blocks label x. pathhblock y;starti
corresponds to the conguration which blocks label y. the rightmost path (i. e.,
hstarti) does not block any label. the three paths capture all three feasible
congurations that do not consider hiding steps. as hiding and allowing have
the same eect on the original net (i. e., the respective labeled transitions may
re), each conguration that does not block a transition (and hence allows it by
default) may further hide that transition. this yields a large number of further
possible congurations. figure 6(a) lists all feasible congurations, and, for
example, shows that blocking both labels is not feasible. since there are only
two labels and eight feasible congurations, the conclusions based on fig. 6(a)
are rather obvious. however, conguration guidelines can be automatically
computed for large and complex congurable process models.
5.4. conguration interface: block by default
thus far, we used a conguration interface that allows all congurable
activities by default, that is, blocking and hiding are explicit actions of the
18partner. it is also possible to use a completely dierent starting point and
initially block all activities.
denition 11 (conguration interface; block by default). letn= (p;t;
f;m 0;
;l;`) be an open net. we dene the open net with conguration interface
nci
b= (pc;tc;fc;mc
0;
c;lc;`c) with
pc=p[fpstartg[fpx;pa
x;pb
x;ph
xjx2lg,
tc=t[ftstartg[fax;hxjx2lg,
fc=f[f(pstart;tstart)g[f(tstart;p)jp2p^m0(p) = 1g[f(t;px);(px;t)j
`(t) =xg[f (ax;pstart);(pstart;ax)jx2lg[f (hx;pstart);(pstart;hx)jx2
lg[f (pb
x;ax);(ax;pa
x);(ax;px)jx2lg[f (pb
x;hx);(hx;ph
x);(hx;px)jx2
lg,
mc
0= [p1jp2fpstartg[fpb
xjx2lg],

c=fml
x2lm
xjm2
^ 8x2lm
x2f[px;pa
x];[pb
x];[px;ph
x]gg,
lc=fstartg[f allow x;hide xjx2lg
`c(tstart) =start,`c(ax) =allow xand`c(hx) =hide xforx2l, and
`c(t) =fort2t.
nci
bin fig. 5(c) shows the conguration interface where all activities are
blocked by default. the idea is analogous to the construction of nci
a. instead
ofbxandby, transitions axandayare added to model the explicit allowing
of labelsxandy, respectively. furthermore, the initial marking was adjusted:
placespxandpyare initially unmarked such that, by default, none of the
original transitions can re. these places can be marked by allowing or hiding
the respective label. very similar to the \allow by default" case, we dene a
canonical conguration partner.
denition 12 (canonical conguration partner; block by default). let
nbe an open net and let cn:l!fallow;hide;blockgbe a conguration for
n.qcn
b= (p;t;f;m 0;
;lq;`) is the canonical conguration partner with:
l=fx2ljcn(x)6=blockgis the set of labels other than \block",
p=fp0
x;p!
xjx2lg,
t=ftxjx2lg[ftstartg,
f=f(p0
x;tx);(tx;p!
x);(p!
x;tstart)jx2lg,
m0= [(p0
x)1jx2l],

 =f[ ]g,
lq=fallow x;hide xjx2lg[f startg,
19`(tx) =allow x, ifcn(x) =allow ,`(tx) =hide x, ifcn(x) =hide, and
`(tstart) = start.
the structure of the canonical conguration partner qcn
bis identical to that
ofqcna. only the labels are dierent; that is, lnlare the labels that need
to be \unblocked" (i. e., allow or hide). moreover, we obtain the same results
linking feasibility to controllability.
lemma 2. letnbe an open net and let cnbe a conguration for n.cnis a
feasible conguration if and only if nci
bqcn
bis weakly terminating.
proof. analogous to the proof of lemma 1.
theorem 2 (feasibility coincides with controllability) .letnbe an open net.
nci
bis controllable if and only if there exists a feasible conguration cnofn
proof. analogous to the proof of theorem 1.
figure 6(b) shows the conguration guideline cgbfor the congurable
model in fig. 5(a), computed from the conguration interface nci
bin fig. 5(c).
again, any path in cgbstarting in the initial state and ending in a nal state
correspond to a feasible conguration. the leftmost path (i. e., hallow x;starti)
corresponds to the conguration which \unblocks" label xby allowing it. paths
hallow x;allow y;startiandhallow y;allow x;starticorrespond to the conguration
where both xandyare allowed. the path hallow y;starti) allowsyonly. similar
paths exist for hiding, e.g., hhide x;starticorresponds to the conguration which
\unblocks" label xby hiding it. again there are eight feasible congurations (see
nal states in fig. 6(b)).
clearly, the two conguration guidelines in fig. 6 point to the same set
of feasible congurations as they refer to the same original model. in can be
noted that for each conguration that contains an allow xthere also exists a
conguration with a hide x, but otherwise identical actions. this is always the
case; hiding and allowing are equivalent with respect to feasibility. for this
reason, we shall not depict hiding actions in the remainder of this section. we
have included them both in the constructs used because they become relevant
when dealing domain knowledge and data dependencies (see section 6). for
example, if a transition produces a data element used later in the process, there
is a clear dierence between hiding or blocking it.
5.5. another example
let us now consider a more elaborated example to see how conguration
guidelines can be used to rule out unfeasible congurations. figure 7 shows
three open nets. the structures are identical, only the labels are dierent. for
example, blocking xinn2corresponds to removing both t1andt4as both
transitions bear the same label, while blocking xinn3corresponds to removing
t1andt5. for these three nets, we can construct the conguration interfaces
using def. 9 and then synthesize the conguration guidelines, as shown in fig. 8.
20p1p2p3p4p5p6vwxyzt1t2t3t4t5(a)n1
p1p2p3p4p5p6x
xyyτt1t2t3t4t5 (b)n2
p1p2p3p4p5p6τxy
yxt1t2t3t4t5 (c)n3
figure 7: three open nets (
 = f[p6]g).

 	 
 



   	


(a)cga
1

 	





(b)cga
2

(c)cga
3
figure 8: the conguration guidelines (allow by default) for n1(a),n2(b) and n3(c). hiding
actions are not depicted.
for these three nets, we can construct the conguration interfaces using def. 9
or def. 11, and then synthesize the conguration guidelines. figure 8 shows the
three conguration guidelines using def. 9 (allow by default). as mentioned
before, we refrained from presenting congurations that contain hiding activities.
figure 8(a) reveals all feasible congurations for n1in fig. 7(a). from
the initial state in the conguration guideline cga
1, we can immediately reach
a nal state by following the rightmost path hstarti. this indicates that all
congurations which block nothing (i. e., only allow or hide activities) are feasible.
it is possible to just block v(cf. pathhblock v;starti) or block both vandy
(cf. pathshblock v;block y;startiandhblock y;block v;starti). however, it is not
allowed to block yonly, otherwise a token would deadlock in p3. for the same
reasons, one can block wonly orwandz, but notzonly. moreover, it is not
possible to combine the blocking of wand/orzon the one hand and vand/ory
on the other hand, otherwise no nal marking can be reached. also xcan never
be blocked, otherwise both vandwwould also need to be blocked (to avoid a
token to deadlock in p2) which is not possible. there are 35= 243 congurations
forn1. if we abstract from hiding as this does not inuence feasibility (assuming
we abstract from data and domain knowledge; see section 6), there remain
2125= 32 possible congurations. of these only 5 are feasible congurations which
correspond to the nal states in fig. 8(a). this illustrates that the conguration
guideline can indeed represent all feasible congurations in an intuitive manner.
figure 8(b) shows the three feasible congurations for n2in fig. 7(b). again
all nal states correspond to feasible congurations. here one can block the two
leftmost transitions (labeled x) or the two rightmost transitions (labeled y), but
not both.
the conguration guideline in fig. 8(c) shows that nothing can be blocked
forn3(fig. 7(c)). blocking xorywill yield an unfeasible conguration as a
token will get stuck in p4(when blocking x) orp3(when blocking y). if both
labels are blocked, none of the transitions can re and thus no nal marking can
be reached.
in the next section we show how the partner synthesis can be further rened by
ruling out specic partners based on domain knowledge and data dependencies.
6. dealing with domain knowledge and data dependencies
given an open net modeling a congurable process model, we can compute a
conguration guideline. this conguration guideline characterizes all feasible
congurations. the only consideration used to construct the conguration
guideline has been weak termination of the model after conguration, i.e., it
should always be possible to reach a desirable end state. however, in practice
there will be many more constraints that a conguration should satisfy. for
example, there may be domain constraints that inhibit particular congurations
(e.g., a check activity may only be hidden when the payment activity is blocked).
data dependencies may also introduce such constraints. for example, if the only
activity producing data element xis hidden, all subsequent activities using x
should be blocked or hidden. these examples show that there is a signicant
dierence between hiding and allowing whereas this was irrelevant for weak
termination (cf. section 5). therefore, we introduce the notion of conguration
constraints . section 6.1 motivates the need for such constraints. section 6.2
shows how these constraints can be formalized by simply restricting the set of
nal markings. as will be shown in section 6.3, the notion of conguration
constraints can be trivially embedded in the approach described in section 5.
this results in conguration guidelines that consider both weak termination and
additional conguration constraints.
6.1. conguration constraints
typically, congurable process models cannot be freely congured, i.e., even
if the resulting congured model is free of deadlocks and livelocks, there may be
good reasons for not allowing a particular conguration.
first of all, a conguration has to comply with constraints imposed by
characteristics of the application domain [ 31]. let us consider the travel request
example in fig. 3. in this business process there must always be an option
to approve the request, and an option to reject it. thus, we cannot block the
22label of transition t8, nor that of t9, although blocking either of these labels
would still result in a feasible conguration. moreover, we cannot hide the
label oft6because a travel request cannot be approved or rejected if it has not
been submitted rst. these examples show that domain constraints may limit
the space of acceptable congurations. corporate governance and regulatory
compliance may result in additional conguration constraints, e.g., there may be
legal reasons for excluding particular congurations, such as the absence of a
particular check activity.
in a similar vein, data dependencies among activities may prevent certain
combinations of hiding and blocking. activities typically have input data and
output data. suppose that activity a1creates a data element dthat is later used
by activity a2. obviously, it is not possible to hide or block a1while keeping a2.
coming back to the travel request example, we cannot hide the labels of t1and
t2because the data needed in subsequent steps would be missing. these two
transitions create the travel form , which is used as input by all other transitions,
e.g. transition \arrange travel insurance" reads the travel form as input and
writes an insurance document as output. although hiding the labels of t1and
t2creates an obvious problem, we would not be able to observe this by just
considering denition 6. this shows that data needs to be taken into account
when constructing the conguration guideline.
there is no need to take the actual data values into account; only the
presence of data matters. data presence can be checked by providing a so-called
crud matrix . this is a matrix showing the relation between activities and
data elements using the basic operations create (c), read (r), update (u), and
delete (d). the idea to link data elements to activities originates from ibm's
business systems planning (bsp) methodology developed in the early eighties.
in [32] it was shown how the information contained in a crud matrix can
be added to a process model expressed in terms of petri nets. the operations
considered in [ 32] are: read (activityarequires a data element das input), write
(activityacreates or updates data element d),destroy (activityadeletes data
elementd), and guard (a boolean condition over data element dis used to route
control to activity a). figure 9 shows a rened version of net n1in fig. 7(a),
namely net nd, which has been enriched with data manipulation aspects.
these data operations can be encoded in a petri net which models the
presence of data elements and the state of guards. there is no need to encode
the explicit values of data elements to nd data dependency errors. in [ 32] a
set of data-ow anti-patterns is dened. for instance, the anti-pattern dap 1
(missing data) describes the situation where some data element needs to be
accessed, i.e., read or destroyed, but either it has never been created or it has
been deleted without having been created again. hiding an activity that creates
a data element may easily result in the situation described by dap 1 . the
data-ow anti-patterns are dened in the context of wf-nets. however, the ideas
can easily be converted to open nets. in this paper, we do not list the various
anti-patterns. instead, we focus on the implications for process conguration.
let us consider fig. 9 again. this process starts when data element ais
available. based on the evaluation of the guard pred(a) , control is either routed
23[pred(a)]
vread:a
write:c
destroy:t1
wread: a
write: d
destroy:t2
xread:a
write:e
destroy:at3p1
p2
yread:c,e
write:f
destroy:c,et4p3 p4
p5
p6zread:d,e
write:g
destroy:d,et5[¬pred(a)]figure 9: net ndmodels an open net annotated with information on data, e.g., transition t1
has a guard involving data element a,t1reads a, and writes c.
to activity vor to activity w. both these activities need to read ato start.v
usesato write, i.e. create, a new data element c, whereaswusesato created.
after one of these activities is executed, control is passed to activity xwhich
also requires ato start. this activity creates eand destroys a. the process
concludes with the execution of yorz, based on the set of data elements that
are available after executing x, i.e.cande(in this case yis executed) or dand
e(in this case zis executed).
from a conguration point of view, we are interested in the data dependencies
that activity yhas on activities vandx.vcreatescandxcreatese, which are
both needed by y. these data dependencies imply the following data constraints
for conguration: i) we can no longer block or hide vwithout also blocking
or hidingy; and ii) we can no longer hide xwithout also hiding or blocking y
(recall that xcannot be blocked for correctness reasons, as shown in fig. 8(a)).
indeed, if we do not also hide or block y, this activity will deadlock waiting
for a data element that will never be available. similarly, zdepends on the
output produced by wandx. thus, we can no longer block or hide w, or hide
x, without also blocking or hiding z, otherwise the latter activity will deadlock.
on the other hand, the dependency of activities v,wandxona, as well as
the guard on a, do not have any implication on the conguration of this net
becauseais an external data element. in fact, for the sake of rening the set of
feasible congurations, we are only interested in the internal data dependencies
24among activities. more precisely, we consider reads, destroys and guards on data
elements that are produced by some activity in the net.
in summary, both domain knowledge and data dependencies may limit
the total number of feasible congurations. we refer to such restrictions as
conguration constraints.
6.2. formalization of conguration constraints
in order to consider conguration constraints in the partner synthesis, we
introduce boolean constraints (\formulae") over activity labels (i.e., set l). for
example, the domain constraint that the label of transition t8(\approve travel
form") cannot be blocked in our travel request process, can be expressed as
:block `(t8)(recall that visible transition labels correspond to activities, i.e., we
do not block a specic transition, but all transitions having label x). further,
the data constraint that the labels of t1andt2cannot be simultaneously hidden,
can be expressed as (( hide `(t1)):hide `(t2))^(hide `(t2)):hide `(t1))), whereas
the data constraints among the transitions of net ndcan be expressed as
allow y)(allow v^allow x) and allow z)(allow w^allow x).
denition 13 (formula). formulae are dened inductively:
(base) for a label x2l,allow x,block xand hide xare formulae.f=s
x2lfallow x;block x;hide xgis the set of all atomic formulae.
(step) if'and are formulae, so are :', ('_ ), ('^ ), and (') ).
examples of atomic formulae are allow xandhide y. examples of non-atomic
formulae are (allow x_hide y) and ((hide x^block y)):hide z).
such formulae are generated based on domain knowledge and data dependen-
cies. in [ 31] we showed how domain constraints can be transformed into such
formulae while in [ 32] we showed how data dependencies can be extracted from
a process model enhanced with data operations.
next, we translate these formulae into constraints on the set of nal markings
of a conguration interface. in denition 9, we dened that the set of nal mark-
ings of the conguration interface (allow by default) is 
c=fml
x2lm
xj
m2
^ 8x2lm
x2f[px;pa
x];[pb
x];[px;ph
x]gg. the conguration interface de-
ned in denition 11 (block by default) specied the same set of nal markings

c. hence, in both cases each label xis required to be in one of the following
three states: [ px;pa
x] (allowed), [ pb
x] (blocked), or [ px;ph
x] (hidden). since this
covers all three possibilities, it does not constrain the set of feasible congura-
tions. we observe that after ring tstart, the state of a label does not change
any more. therefore, domain knowledge and data dependencies can be captured
by removing undesirable markings from 
c.
denition 14 (translation of formulae into a set of nal markings).
letn= (p;t;f;m 0;
;l;`) be an open net and 'be a formula representing
the conjunction of all constraints resulting from domain knowledge and data
dependencies.a'2fis the set of all satisfying assignments of '.
25for an assignment a2a'and labelx2l, we dene the multiset mx
awith:
mx
a=8
><
>:[px;pa
x];allow x2a
[pb
x]; block x2a
[px;ph
x];hide x2a
this allows us to redene the set of nal markings of the conguration interface:

c=fmm
x2lmx
ajm2
^a2a'g
each assignment corresponds to a set of nal markings. the redened set of nal
markings 
ccan be used in the conguration interfaces dened in denitions 9
and 11. by restricting 
c, domain knowledge and data dependencies are taken
into account when checking feasibility and when constructing the conguration
guideline.
6.3. computing conguration guidelines using additional constraints
the idea to constrain the set of partners of an open net by adjusting its
nal marking is inspired by the concept of behavioral constraints presented in
[33]. by replacing 
cin denitions 9 and 11 by the constrained 
cspecied in
denition 14 we limit the set of feasible congurations to all weakly terminating
congurations that do not violate any of the conguration constraints. this
implies that we can still use the approach described in section 5, i.e., using
partner synthesis we synthesize a partner which is most-permissive resulting in
the desired the conguration guideline.
consider again nd, the congurable model extended with data, shown in
fig. 9. assume that we have two conguration constraints: allow y)(allow v^
allow x) and allow z)(allow w^allow x). based on these constraints we redene
the set of nal markings of the conguration interface 
c. based on the rst con-
guration constraint ( allow y)(allow v^allow x)) we remove those combinations
of markings featuring [ py;pa
y;pb
v], [py;pa
y;pv;ph
v], [py;pa
y;pb
x], or [py;pa
y;px;ph
x].
based on the second conguration constraint ( allow z)(allow w^allow x))
we remove all combinations featuring [ pz;pa
z;pb
w], [pz;pa
z;pw;ph
w], [pz;pa
z;pb
x], or
[pz;pa
z;px;ph
x]. this leads to the new conguration guideline cga
nddepicted in
fig. 10 (for simplicity those actions that have been hidden are not depicted).
for example, now it is no longer possible to complete a conguration by blocking
vonly, i.e.,yneeds also to be blocked. it is also not possible to block only w, i.e.
zalso needs to be blocked. compare fig. 10 with fig. 8(a) to see the dierences
between both conguration guidelines.
although the example does not show the labels that have been hidden, we
stress that from the viewpoint of domain knowledge and data dependencies there
is a considerable dierence between allowing and hiding an activity. when an
activity is hidden no data is consumed nor produced. therefore, we included
hiding in the conguration interfaces (denitions 9 and 11). without adding
26
 	 
 


   	

figure 10: cga
ndthe conguration guideline (allow by default) for nd(hidden actions are
not shown).
this to the corresponding interfaces, we would be unable to express constraints
related to hiding.
the simplicity of handling conguration constraints illustrates the exibility
of our approach based on partner synthesis.
7. tool support
to prove the feasibility of our approach, we applied it to the conguration of
c-yawl models [ 6] and extended the yawl system accordingly.5the yawl
language can be seen as an extension of petri nets which provides \syntactic
sugaring" (shorthand notations for sequences and xor-splits/joins). an atomic
activity is called a task in yawl. composite tasks represent subprocesses. yawl
also provides advanced constructs such as cancelation sets, multiple instance
tasks and or-joins. yawl is based on the well-know workow patterns.6the
yawl system supporting this language is one of the most widely used open
source workow systems. for conguration, we restrict ourselves to the basic
control-ow patterns supported by most systems. thus we leave out yawl's
cancelation sets, multiple instance tasks and or-joins. this allows us to easily
map a yawl model onto an open net.
a c-yawl model is a yawl model where some tasks are annotated as
congurable . conguration is achieved by restricting the routing behavior of
congurable tasks via the notion of ports . a congurable task's joining behavior is
identied by one or more inow ports, whereas its splitting behavior is identied
by one or more outow ports. the number of ports for a congurable task
depends on the task's routing behavior. for example, an and-split/join and
an or-join are each identied by a single port, whereas an xor-split/join is
identied by one port for each outgoing/incoming ow. an or-split is identied
by a port for each combination of outgoing ows. to restrict a congurable
task's routing behavior, inow ports can be hidden (thus the corresponding
5http://www.yawlfoundation.org
6http://www.workflowpatterns.com
27figure 11: the c-yawl model for travel request approval.
task will be skipped) or blocked (no control will be passed to the corresponding
task via that port), whereas outow ports can only be blocked (the outgoing
paths from that task via that port are disabled). for instance, fig. 11 shows
the c-yawl model for the travel request approval in the yawl editor, where
congurable tasks are marked with a thicker border.
the yawl editor can be downloaded from www.yawlfoundation.org . it
provides a graphical interface to conveniently congure and check c-yawl
models and subsequently generate congured models. given a conguration, the
tool can show a preview of the resulting congured net by graying out all model
fragments which have been blocked, and commit the conguration by removing
these fragments altogether.
to assist end users in ruling out all unfeasible congurations in an interactive
manner, we developed a new component for the yawl editor named c-yawl
correctness checker . given a c-yawl model in memory, the component rst
maps this model into an open net. more precisely, it maps each condition to
a place, each congurable task's port to a labeled transition, and each non-
congurable task to a silent transition. also, for each task it adds an extra place
to connect the transition(s) derived from its inow port(s) with the transition(s)
derived from its outow port(s). by using silent transitions we prevent non-
congurable tasks from being later congured via a conguration interface. next,
the component passes the generated open net to the tool wendy [16]. wendy
creates the corresponding conguration interface (allow by default), and produces
the conguration guideline (allow by default) from the latter artifact.
28yawl editor
wendy c-yawl correctness checker
mapping
analysisconfiguration 
interface
open net
configuration
guidelinegeneration
generationconfigured
yawl modelc-yawl model
interactive
configuration
userfigure 12: the interaction between the c-yawl correctness checker and the wendy tool.
wendy is a free and open source tool7which implements the algorithms for
partner synthesis [ 15] and to calculate operating guidelines [ 17]. wendy itself
oers no graphical user interface, but is controlled by input/output streams. in
our setting, wendy's output is piped back into the correctness checker, where it
can be parsed. the component's interaction with wendy is illustrated in fig. 12.
the construction of the conguration guideline is based on partner synthesis
as described in section 5.2. hence, we inherit the complexity of the partner
synthesis algorithm. to synthesize a partner for an open net nwith label set l,
rst a graph is constructed that over-approximates any potential interaction with
nusing the communication labels from l. second, any behavior that violates
weak termination is removed. if this results in a non-empty graph, we conclude
nis controllable. we refer to [ 15] for a detailed description of the synthesis
algorithm.
the complexity of this algorithm is dominated by the potential size of the
over-approximation which is at most exponential i) on the size of n(because
the reachability graph of nneeds to be generated), and ii) on the size of l.
the tool wendy implements several reduction techniques to address potential
problems due to this worst case complexity. first, the internal behavior that does
not inuence the interaction behavior is removed from the reachability graph.
second, the reachability graph is further preprocessed to discover non-terminating
behavior as early as possible. third, ecient data structures further minimize
the memory footprint of the over-approximation stage. these optimizations
7available for download at http://service-technology.org/wendy .
29speed-up wendy signicantly when applied to real-life examples. practical
experiences show that wendy is able to analyze industrial models having millions
of states. wendy is also capable of synthesizing partners of similar sizes [16].
at each conguration step, the correctness checker scans the set of outgoing
edges of the current state in the conguration guideline, and prevents users
from blocking those ports not included in this set. this is done by disabling
the block button for those ports. as users block a valid port, the correctness
checker traverses the conguration guideline through the corresponding edge
and updates the current state. if this is not a consistent state, that is, a state
with an outgoing edge labeled \start", further ports need to be blocked, because
the current conguration is unfeasible. in this case the component provides an
\auto complete" option . this is achieved by traversing the shortest path from
the current state to a consistent state and automatically blocking all ports on
that path. after this, the component updates the current state and noties the
user with the list of ports that have been automatically blocked. for example,
fig. 11 shows that after blocking the input port of task check and update travel
form , the component noties the user that the input port of task prepare travel
form for approval (secretary) and the output port of task submit travel form
for approval to task request for change have also been blocked. figure 13
shows the preview of the resulting congured net. from this we can observe
that condition p3and task request for change will also be removed from the
net as a result of applying the earlier conguration. similarly, the component
maintains a consistent state in case users decide to allow a previously blocked
port. in this case the component traverses the shortest backward path to the
closest consistent state and allows all ports on that path. by traversing the
shortest path we ensure that the number of ports being automatically blocked
or allowed is minimal.
this auto-completion feature can be extended by prompting the user with
the set of paths from the current state to a consistent state of a given length
(e.g. ve states). in this way the user can select which combinations of ports to
block/allow in order to keep the conguration feasible.
the c-yawl example of fig. 11 comprises ten inow ports and nine outow
ports. in total more than 30 million congurations are potentially possible. if
we abstract from hiding we obtain 524,288 possible congurations, of which
only 1;593 are feasible according to the conguration guideline. wendy took
an average of 336 seconds (on a 2.4 ghz processor with 2gb of ram) to
generate this conguration guideline which consumes 3 :37 mb of disk space.
nonetheless, the shortest path computation is a simple depth-rst search which
is linear in the number of nodes in the conguration guideline. thus, once the
conguration guideline has been generated, the component's response time at
each user interaction is instantaneous.
8. related work
traditional reference models [ 7{10] are typically not executable. for example,
the well-known sap reference model is disconnected from the actual system
30figure 13: the preview of a congured net for the example in fig. 11.
and has many internal inconsistencies [ 34]. such models focus on training and
documentation rather than enactment. congurable process models [ 3,4,6,20,
35] can be seen as executable reference models.
in this paper, we take the viewpoint that conguration is achieved by re-
striction (i.e., hiding and blocking). other paradigms are possible. for example,
in the provop (managing and conguring process variants) approach process
designers create process variants by applying well-dened change operations
on some reference model [ 13,14]. another example is the application-based
domain modeling (adom) approach which allows both reuse (i.e., restriction)
and specialization [ 18,19]. specialization corresponds to the concretization
of a reference model element into a specic business process model element.
in [12] both congurative and generic adaptation techniques are proposed for
adaptive reference modeling. in [ 36,37] an approach is described to discover a
reference model for which the edit distance to a given set of variants is minimal.
this approach assumes that conguration corresponds to a sequence of change
operations. nevertheless, the majority of process conguration approaches use
restriction of behavior as a conguration mechanism [ 3,4,6,20,35]. this paper
also assumes that conguration is done through behavioral restrictions (hiding
and blocking).
since congurable process models are actively used to support processes,
they need to be correct and only correct congurations should be allowed. many
researchers have worked on the verication of business processes, workows,
and services (e.g., [ 21,32,34,38{41]). however, these approaches focus on the
analysis of one process in isolation and can only be used to exhaustively verify
31all possible congurations to create a conguration guideline. in this respect,
they face the state-space explosion problem.
to the best of our knowledge, our earlier approach [ 5] is the only one focusing
on the behavioral correctness of process congurations which avoids state-space
explosion. other approaches either only discuss syntactical correctness related
to conguration [ 3,11,12], or deal with behavioral correctness but run into
the state-space problem [ 13]. for example, [ 3] preserves syntactic correctness
by construction of the congured epc model from a c-epc, whereas [ 11,12]
prompt users with a list of syntactic issues detected during process conguration,
which need to be manually xed. finally, [ 13] proposes to check the correctness
of each single congured process model.
the approach in [ 5] presents a technique to derive propositional logic con-
straints from congurable process models that, if satised by a conguration step,
guarantee the behavioral correctness of the congured model. this approach
allows correctness to be checked at each intermediate step of the conguration
procedure. whenever a conguration value is assigned to a transition label (e.g.
xis blocked), the current set of constraints is evaluated. if the constraints are
satised, the conguration step is applied. if on the other hand the constraints
are violated, a reduced propositional logic formula is computed, from which addi-
tional conguration values are determined, that also need to be applied in order
to preserve correctness. unfortunately, this approach requires the congurable
process model to be a sound, free-choice workow net. thus, these requirements
limit the applicability of the approach. in the current paper, we do not impose
such restrictions.
this paper is an extended version of [ 42]. in [ 42], we already described the
idea of synthesizing a conguration guideline based on the partner synthesis
approach [ 15]. however, in [ 42] we abstracted from hiding and only showed one
conguration interface (allow by default). the actual construction presented in
section 5 is dierent from that in [ 42] to be able to deal with hiding. moreover,
we showed the conguration interface where everything is blocked by default.
hiding, blocking and allowing are now symmetric. in principle, we could have
also provided a conguration interface that hides by default. finally, we showed
how constraints can be incorporated in our approach. these constraints may
be derived from the domain in which the congurable process model has been
constructed, or from data dependencies that exist among process tasks.
9. conclusion
congurable process models are a means to compactly represent families of
process models. however, the verication of such models is dicult as the number
of possible congurations grows exponentially in the number of congurable
elements. due to concurrency and branching structures, conguration decisions
may interfere with each other and thus introduce deadlocks, livelocks and other
anomalies. the verication of congurable process models is challenging and only
few researchers have worked on this. moreover, existing results impose restrictions
on the structure of the congurable process model and fail to provide insights
32into the complex dependencies among dierent process model conguration
decisions.
the main contribution of this paper is an innovative approach for ensuring
correctness during process conguration. using partner synthesis we compute the
conguration guideline | a compact characterization of all feasible congurations,
which allows us to rule out congurations that lead to behavioral problems. the
approach is highly generic and imposes no constraints on the congurable process
models that can be analyzed. moreover, all computations are done at design
time and not at conguration time. thus, once the conguration guideline has
been generated, the response time is instantaneous stimulating the practical
(re-)use of congurable process models. the approach is implemented in a
checker integrated in the yawl editor. this checker uses the wendy tool to
ensure correctness while users congure c-yawl models.
in previous work, we have shown that our wendy tool can cope with models
generating millions of states. furthermore, we have extensively evaluated the
use of process conguration by \behavior restriction" to various domains such
as logistics, municipalities and the screen business [ 4,22,35]. however, we
acknowledge that further evaluations need to be conducted, in order to claim
that the specic approach presented in this paper can be used in practice. this
is an avenue for future work.
several interesting extensions to this work are possible. first, it is possible to
create more compact representations of conguration guidelines (e.g. exploiting
concurrency [ 29]). the \diamond structures" in the example conguration guide-
lines illustrate that regions can help fold the guidelines and separate unrelated
conguration decisions. however, more research is needed to understand how to
best present the conguration guidelines to end-users (see e.g. our earlier work on
questionnaire-based variability modeling [ 22]). second, one could consider con-
guration at run-time, that is, while instances are running, congurations can be
set or modied. this can be easily embedded in the current approach, but would
be impossible when using conventional techniques. finally, we are interested in
relating this work on process conguration to process mining. process mining
has been focusing on the analysis of individual processes. however, as more
and more variants of the same process need to be supported, it is interesting to
analyze dierences between these variants based on empirical data.
acknowledgments.. we thank jingxin xu for his help with the implementation
and testing of the c-yawl component, and its integration with the wendy tool.
we also thank the anonymous reviewers for their valuable feedback which helped
us improve the paper.
references
[1]w.m.p. van der aalst, c. stahl, modeling business processes: a petri net
oriented approach, mit press, cambridge, ma, 2011.
[2]f. leymann, d. roller, production workow: concepts and techniques,
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
33[3]m. rosemann, w.m.p. van der aalst, a congurable reference modelling
language, information systems 32 (1) (2007) 1{23.
[4]m. la rosa, m. dumas, a. ter hofstede, j. mendling, congurable multi-
perspective business process models, information systems 36 (2).
[5]w.m.p. van der aalst, m. dumas, f. gottschalk, a. ter hofstede, m. rosa,
j. mendling, preserving correctness during business process model con-
guration, formal aspects of computing 22 (3) (2010) 459{482.
[6]f. gottschalk, w.m.p. van der aalst, m. jansen-vullers, m. l. rosa, cong-
urable workow models, international journal of cooperative information
systems 17 (2) (2008) 177{221.
[7]t. curran, g. keller, sap r/3 business blueprint: understanding the
business process reference model, upper saddle river, 1997.
[8]p. fettke, p. loos, classication of reference models - a methodology
and its application, information systems and e-business management 1 (1)
(2003) 35{53.
[9]s. huan, s. sheoran, g. wang, a review and analysis of supply chain
operations reference (scor) model, supply chain management - an
international journal 9 (1) (2004) 23{29.
[10]r. addy, eective it service management. to itil and beyond!, springer-
verlag, berlin, 2007.
[11]k. czarnecki, m. antkiewicz, mapping features to models: a template
approach based on superimposed variants, in: proceedings of the 4th
int. conference on generative programming and component engineering,
springer-verlag, berlin, 2005, pp. 422{437.
[12]j. becker, p. delfmann, r. knackstedt, adaptive reference modeling:
integrating congurative and generic adaptation techniques for infor-
mation models, in: j. becker, p. delfmann (eds.), reference modeling:
ecient information systems design through reuse of information models,
physica-verlag, springer, heidelberg, germany, 2007, pp. 27{58.
[13]a. hallerbach, t. bauer, m. reichert, guaranteeing soundness of cong-
urable process variants in provop, in: cec, ieee, 2009, pp. 98{105.
[14]a. hallerbach, t. bauer, m. reichert, capturing variability in business
process models: the provop approach, journal of software maintenance
and evolution: research and practice 22 (6-7) (2010) 519{546.
[15]k. wolf, does my service have partners?, in: k. jensen, w.m.p. van der
aalst (eds.), transactions on petri nets and other models of concurrency
ii, vol. 5460 of lecture notes in computer science, springer-verlag, berlin,
2009, pp. 152{171.
34[16]n. lohmann, d. weinberg, wendy: a tool to synthesize partners for
services, in: j. lilius, w. penczek (eds.), international conference on
applications and theory of petri nets and other models of concurrency,
vol. 6128 of lecture notes in computer science, springer-verlag, 2010, pp.
297{307
[17]n. lohmann, p. massuthe, k. wolf, operating guidelines for finite-state
services, in: j. kleijn, a. yakovlev (eds.), 28th international conference on
applications and theory of petri nets and other models of concurrency,
icatpn 2007, siedlce, poland, june 25-29, 2007, proceedings, vol. 4546
of lecture notes in computer science, springer-verlag, berlin, 2007, pp.
321{341.
[18]i. reinhartz-berger, p. soer, a. sturm, organizational reference models:
supporting an adequate design of local business processes, international
journal of business process integrations and management 4 (2) (2009)
134{149.
[19]i. reinhartz-berger, p. soer, a. sturm, extending the adaptability of
reference models, ieee transactions on systems, man and cybernetics -
part a: systems and humans 40 (5) (2011) 1045{1056.
[20]a. schnieders, f. puhlmann, variability mechanisms in e-business process
families, in: w. abramowicz, h. mayr (eds.), proceedings of the 9th
international conference on business information systems (bis'06), vol. 85
of lni, gi, 2006, pp. 583{601.
[21]w.m.p. van der aalst, k. hee, a. ter hofstede, n. sidorova, h. verbeek,
m. voorhoeve, m. wynn, soundness of workow nets: classication,
decidability, and analysis, formal aspects of computing 23 (3) (2011)
333{363.
[22]m. rosa, w.m.p. van der aalst, m. dumas, a. ter hofstede, questionnaire-
based variability modeling for system conguration, software and systems
modeling 8 (2) (2009) 251{274.
[23]w.m.p. van der aalst, process-oriented architectures for electronic com-
merce and interorganizational workow, information systems 24 (8) (2000)
639{671.
[24]p. massuthe, w. reisig, k. schmidt, an operating guideline approach
to the soa, annals of mathematics, computing & teleinformatics 1 (3)
(2005) 35{43.
[25]e. kindler, a. martens, w. reisig, inter-operability of workow appli-
cations: local criteria for global soundness, in: w.m.p. van der aalst,
j. desel, a. oberweis (eds.), business process management: models, tech-
niques, and empirical studies, vol. 1806 of lecture notes in computer
science, springer-verlag, berlin, 2000, pp. 235{253.
35[26]r. heckel, open petri nets as semantic model for workow integration, in:
h. ehrig, w. reisig, g. rozenberg, h. weber (eds.), petri net technology
for communication based systems, vol. 2472 of lecture notes in computer
science, springer-verlag, berlin, 2003, pp. 281{294.
[27]p. massuthe, a. serebrenik, n. sidorova, k. wolf, can i nd a partner?
undecidablity of partner existence for open nets, information processing
letters 108 (6) (2008) 374{378.
[28]j. desel, j. esparza, free choice petri nets, vol. 40 of cambridge tracts
in theoretical computer science, cambridge university press, cambridge,
uk, 1995.
[29]e. badouel, p. darondeau, theory of regions, in: w. reisig, g. rozenberg
(eds.), lectures on petri nets i: basic models, vol. 1491 of lecture notes
in computer science, springer-verlag, berlin, 1998, pp. 529{586.
[30]j. cortadella, m. kishinevsky, a. kondratyev, l. lavagno, a. yakovlev,
petrify: a tool for manipulating concurrent specications and synthesis of
asynchronous controllers, ieice transactions on information and systems
e80-d (3) (1997) 315{325.
[31]m. la rosa, j. lux, s. seidel, m. dumas, a. ter hofstede, questionnaire-
driven conguration of reference process models, in: caise'07, vol. 4495
of lecture notes in computer science, springer-verlag, berlin, 2007, pp.
424{438.
[32]n. trcka, w.m.p. van der aalst, n. sidorova, data-flow anti-patterns:
discovering data-flow errors in workows, in: p. van eck, j. gordijn,
r. wieringa (eds.), advanced information systems engineering, proceed-
ings of the 21st international conference on advanced information systems
engineering (caise'09), vol. 5565 of lecture notes in computer science,
springer-verlag, berlin, 2009, pp. 425{439.
[33]n. lohmann, p. massuthe, k. wolf, behavioral constraints for services, in:
bpm 2007, vol. 4546 of lecture notes in computer science, springer-verlag,
berlin, 2007, pp. 271{287.
[34]j. mendling, h. verbeek, b. van dongen, w.m.p. van der aalst, g. neu-
mann, detection and prediction of errors in epcs of the sap reference
model, data and knowledge engineering 64 (1) (2008) 312{329.
[35]f. gottschalk, t. wagemakers, m. jansen-vullers, w.m.p. van der aalst,
m. rosa, congurable process models: experiences from a municipality
case study, in: p. van eck, j. gordijn, r. wieringa (eds.), advanced
information systems engineering, proceedings of the 21st international
conference on advanced information systems engineering (caise'09), vol.
5565 of lecture notes in computer science, springer-verlag, berlin, 2009,
pp. 486{500.
36[36]c. li, m. reichert, and a. wombacher, discovering reference models by
mining process variants using a heuristic approach, in: u. dayal, j. eder,
j. koehler, h. reijers (eds.), business process management (bpm 2009),
vol. 5701 of lecture notes in computer science, springer-verlag, berlin,
2009, pp. 344{362.
[37]c. li, m. reichert, a. wombacher, the minadept clustering approach for
discovering reference process models out of process variants, international
journal of cooperative information systems 19 (3) (2010) 159{203.
[38]h. lin, z. zhao, h. li, z. chen, a novel graph reduction algorithm to
identify structural conicts, in: proceedings of the thirty-fourth annual
hawaii international conference on system science (hicss-35), ieee
computer society press, 2002.
[39]j. dehnert, p. rittgen, relaxed soundness of business processes, in: k. dit-
trich, a. geppert, m. norrie (eds.), proceedings of the 13th international
conference on advanced information systems engineering (caise'01), vol.
2068 of lecture notes in computer science, springer-verlag, berlin, 2001,
pp. 157{170.
[40]w. sadiq, m. orlowska, analyzing process models using graph reduction
techniques, information systems 25 (2) (2000) 117{134.
[41]n. sidorova, c. stahl, n. trcka, soundness verication for conceptual
workow nets with data: early detection of errors with the most
precision possible, information systems 37 (7) (2011) 1026{1043.
[42]w.m.p. van der aalst, n. lohmann, m. rosa, j. xu, correctness ensur-
ing process conguration: an approach based on partner synthesis, in:
r. hull, j. mendling, s. tai (eds.), business process management (bpm
2010), vol. 6336 of lecture notes in computer science, springer-verlag,
berlin, 2010, pp. 95{111.
37