enriching data models with behavioral constraints
alessandro artale1, diego calvanese1, marco montali1, and wil van der aalst2
1krdb research centre for knowledge and data, free university of bozen-bolzano (italy)
{artale,montali}@inf.unibz.it
2process and data science (pads), rwth aachen university (germany)
wvdaalst@pads.rwth-aachen.de
abstract. existing process modeling notations ranging from petri nets to bpmn
have difﬁculties capturing the essential features of the domain under study. pro-
cess models often focus on the control ﬂow, lacking an explicit, conceptually
well-founded integration with real data models, such as er diagrams or uml
class diagrams. in addition, they essentially rely on the simplifying assumption
that each process model focuses on a single, explicitly deﬁned notion of case,
representing the type of objects that are separately manipulated when the process
is instantiated into actual executions. to overcome this key limitation, object-
centric behavioural constraints (ocbc) models were recently proposed as a new
notation where data and control-ﬂow are described in a single diagram, and where
their interconnection is exploited to elegantly capture real-life processes operating
over a complex network of objects. in this paper, we illustrate the essential and
distinctive features of the ocbc approach, and contrast ocbc with contemporary,
case-centric notations. we then relate the approach to recent developments in the
conceptual understanding of processes, events, and their constituents, introducing
a series of challenges and points of reﬂections for the community.
1 introduction
despite the plethora of notations available to model business processes, process mod-
ellers struggle to capture real-life processes using mainstream notations such as business
process model and notation (bpmn), event-driven process chains (epc), and uml
activity diagrams. all such notations require the simplifying assumption that each pro-
cess model focuses on a single, explicitly deﬁned notion of case, representing the type
of objects that are separately manipulated when the process is instantiated into actual
executions. the discrepancy between this assumption and reality becomes evident when
using process mining techniques to reconstruct the real processes based on the available
data [ 1]. process mining starts from the available data and, unless one is using a business
process management (bpm) of workﬂow management (wfm) system for process
executions, explicit case information is typically missing. real enterprise systems from
vendors such as sap (s/4hana), microsoft (dynamics 365), oracle (e-business suite),
and salesforce (crm) are database-centric. process activities can be viewed as updates
on the underlying data, and the notion of process instance (i.e., case) does not exist.
process-centric diagrams using bpmn, epcs, or uml describe the life-cycle of
individual cases. when formal languages like petri nets, automata, and process algebras
are used to describe business processes, they also tend to model cases in isolation.2 a. artale, d. calvanese, m. montali, and w. van der aalst
moreover, the data perspective is secondary or missing completely. object-centric
behavioural constraint (ocbc) models [ 2] have been recently proposed to address the
following two interrelated problems:
–it is difﬁcult to model interactions between multiple process instances , speciﬁcally
when there is a one-to-many ormany-to-many relationship between them. for
example, an order may relate to multiple order lines and one delivery may refer to
multiple order lines belonging to different orders. how to model activities related to
orders, order lines, and deliveries in a single diagram?
–it is difﬁcult to model both the data and control-ﬂow perspective in a uniﬁed and
integrated manner. existing approaches focus on one of the two or resort to the use
of multiple diagrams. for example, the relation between class diagrams and activity
diagrams in uml is indirect and not visualized.
note that languages like bpmn allow modellers to attach simple data objects to
processes, but the more powerful constructs present in entity relationship (er) models
and uml class models cannot be captured in such process models. in particular, complex
constraints over data attached to processes (e.g., cardinality constraints) must inﬂuence
the behaviour of the process itself (think to the activities that must generate those data
objects). in contemporary languages, neither complex constraints over data nor a way
to capture how data can inﬂuence processes are reﬂected at all. also other mainstream
business process modelling notations can only describe the lifecycle of one type of
process instance at a time, but not the co-evolution of multiple, interacting instances
(such as the management of different orders, where the evolution of one order impacts
on the possible evolutions of the related orders).
object-centric behavioural constraint (ocbc) models have been proposed as a
modelling language that combines ideas from declarative, constraint-based languages like
declare [ 3], and from structural conceptual modelling languages (such as er, uml,
or orm) [2]. ocbc allows to describe the temporal interaction between activities in a
given process and is able to attach (structured) data to processes in a uniﬁed framework .
in this way, we can capture in a uniform way processes, data, and their interplay.
ocbc models are related to artifact- and data-centric approaches [ 4,5,6]. these
approaches also aim to integrate data and processes. however, this is not done in a
single diagram representing different types of process instances and their interactions
(which are governed by the data). in addition, these approaches usually assume complete
knowledge over the data, and require to fully spell out data updates when specifying the
activities [ 7,8]. the few proposals dealing with artifact-centric models whose structural
aspects are interpreted under incomplete information [ 9] do not come with a fully
integrated, declarative semantics, but follow instead the levesque functional approach
[10] to separate the evolution of the system from the inspection of structural knowledge
in each state. the semantics of an ocbc model, instead, can be fully characterised
by resorting to ﬁrst-order temporal logic , where the temporal dimension capturing the
dynamics of the process interacts with the structural dimension of objects and their
mutual relationships [11].
in this paper, we illustrate the essential and distinctive features of the ocbc approach,
using a simple, yet very sophisticated example, and contrast ocbc with contemporary,
case-centric notations. we then relate the approach to recent developments in the con-enriching data models with behavioral constraints 3
ceptual understanding of processes, events, and their constituents, introducing a series of
challenges and points of reﬂections for the community.
2 case-centric notations and many-to-many processes
as pointed out in the introduction, contemporary process modelling notations such as
bpmn, epc, and uml activity diagrams typically require a one-to-one correspondence
between a process3and a corresponding notion of case. this notion of case represents
the main object type targeted (and manipulated) by the process. for this reason, in the
remainder of the paper we use the umbrella term case-centric to refer to such notations.
examples of cases are orders in order-to-cash e-commerce scenarios, or prospective
students in the context of admission processes to university study programs.
the intuition behind this correspondence is that each instance of the process will
target (and evolve) a single object of the corresponding case class. since contemporary
notations mainly focus on the process control-ﬂow, that is, on the activities/tasks to be
executed and on their acceptable execution orderings, being case-centric also implies
that each task execution in a given process instance will target, again, a single case
object. a limited form of one-to-many relationship between cases and tasks is supported
through the usage of loops and multi-instance construcs in the process. such constructs
usually implicitly indicate the presence of object classes acting as subcases , where many
subcases may refer to the same case. an example here consists of the various order lines
composing an order. the usage of loops or multi-instance constructs in the process is
only possible if the evolution of all subcases can be synchronously bound to that of the
corresponding case and of the other “sibling" subcases referring to the same case object.
this is not obvious, nor feasible in general.
all in all, case-centric notations fall short when managing complex one-to-many
relationships, and many-to-many relationships relating different objects that are co-
evolved by the same process. such situations are widespread in real organisations.
for example, e-commerce companies like amazon©ﬂexibly handle order-to-delivery
processes by relating multiple customer orders with multiple packages, so that a package
sent to a customer may contain a mix of order lines belonging to different orders placed
by that customer. this makes it impossible to ﬁx a single notion of case when capturing
the process as a whole, since it intrinsically relate objects of different types (such as
orders and packages) in a many-to-many fashion. depending on the subjective view and
scope of interest within the process, different case objects may be selected to understand
how the process works. for example, a courier may see the order-to-delivery process as
centred around the notion of package. a customer, instead, may prefer a view centred
on each single order in isolation, ranging from the order placement and payment to its
delivery (which is materially realised by delivering all packages containing order lines
for that order).
similarly, in a job hiring process there is a many-to-many relationship between
candidates seeking a job, and job offers placed to ﬁll available positions. this requires
to decouple the ﬂow of activities under the responsibility of the company placing the
job offer, from that followed by each applying candidate. in the following, we take
3recall that, in the bpm literature, process is a synonym for process schema .4 a. artale, d. calvanese, m. montali, and w. van der aalst
person
candidate application job offer job proﬁle1
/made by1..⇤ ⇤
responds to1 ⇤
refers to1
fig. 1: uml class diagram capturing the main object and relationship types of the job
hiring domain.
inspiration from [ 12] and discuss in more detail a fragment of a typical job hiring
process, pointing out the challenges it pose to case-centric notations.
2.1 a job hiring process
we consider the fragment of a job hiring process enacted by an organisation whenever
there is the need of ﬁlling an internal position. for simplicity, we consider only two
types of actors involved in the process:
–the organisation itself, responsible for the publishing and management of job offers,
as well as for the selection of winning applications.
–candidates interested in the offered positions, who participate to the selection
process by registering their personal data and by submitting their applications.
the complexity of the process resides in the fact that it relates many candidates to many
job offers, using the key notion of application as relator. in the following, we assume
that the main object and relationship types of the job hiring domain are those illustrated
in the uml class diagram of figure 1.
using this object and relationship types as a basis, we consider various constraints
to describe tasks in the process and their mutual temporal relationships. for the sake of
readability, we use:
–violet, normal sans-serif to indicate object and relationship types;
–blue, bold sans-serif to indicate tasks;
–blue, italics to highlight temporal aspects, such as the amount of times a task can be
repeated, or whether some task is expected to occur before or after another task;
–green, italic sans-serif to point out relationships between tasks and object types.
–blue, underlined italics to indicate co-reference relationships that indirectly indicate
which instances of tasks are related by the constraint depending on the objects they
manipulate.
in particular, the relevant constraints for our job hiring example are:
c.1 theregister data taskis about aperson .
c.2 ajob offer iscreated by executing the post offer task.
c.3 ajob offer isclosed bydetermining thewinner .
c.4 ajob offer isstopped bycanceling thehiring .enriching data models with behavioral constraints 5
c.5 anapplication iscreated by executing the submit task.
c.6 anapplication ispromoted bymarking itas eligible .
c.7 anapplication can be submitted only if, beforehand , the data about thecandi-
date who made that application have been registered .
c.8awinner can be determined for a job offer only if at least one application
responding to that job offer has been previously marked as eligible .
c.9for each application responding to ajob offer , if the application ismarked
as eligible then a winner must be ﬁnally determined forthat job offer , and
this is done only once forthat job offer .
c.10 when a winner isdetermined for a job offer ,applications responding to that
job offer cannot bemarked as eligible anymore .
c.11 ajob offer closed by adetermine winner taskcannot bestopped by executing
thecancel hiring task (and vice-versa).
2.2 capturing the job hiring example with case-centric notations
the most fundamental issue when trying to capture the job hiring example of section 2.1
using case-centric notation is to identify what is the case . this, in turn, determines
what is the orchestration point for the process, that is, which participant coordinates
process instances corresponding to different case objects. this problem is apparent when
looking at bpmn, which speciﬁes that each process should correspond to a single locus
of control, i.e., conﬁned within a single pool.4
in our example, we have two participants: candidates (in turn responsible for man-
aging applications ), and the job hiring organisation (in turn responsible for the
management of joboffers ). however, we cannot use neither of the two to act as unique
locus of control for the process: on the one hand, candidates may simultaneously create
and manage different applications for different job offers; on the other hand, the organi-
sation may simultaneously spawn and manage different job offers, each one resulting
in multiple applications being evaluated. a typical modelling mistake done by novices
is to select the job hiring organisation as unique locus of control, and squeeze all tasks
therein. this leads to very cumbersome courses of execution as shown in figure 2.
as clearly pointed out in textbooks (see, e.g., chapter 8 of [ 12]), the only way to
handle in bpmn a many-to-many process such as the job hiring process considered
here, is to distribute the process across multiple, separate pools – in our case study, the
candidate andthe hiring company. each of such pools focuses on a different case class
– in our case study, the hiring company focuses on job offers, whereas the candidate
focuses on his/her own applications. however, such multiple pools cannot execute their
internal ﬂows in separation, but must instead be properly interconnected using suitable
synchronisation mechanisms , so as to ensure that the evolution of certain process instance
within a pool is properly aligned with the evolution of process instances within another
pool. for example, in our case study a job offer can be canceled only if no candidate
has created an application for it, which also implicitly indicate that once a job hiring has
been canceled, none of its applications can be marked as eligible for it. this requires
to relate job offers with applications, which can only be done by introducing complex
event or data-based synchronisation mechanisms [ 12] that are not at all mentioned in the
description of the process provided in section 2.1.
4recall that a bpmn pool represents a participant [13].6 a. artale, d. calvanese, m. montali, and w. van der aalsthiring companycandidatepostoffercheck if eligibleapplication…job offer(a) a job hiring process receiving at most
one application
hiring companypostofferapplication
job offerhandle candidate…check if eligiblecandidate
(b) a job hiring process receiving multiple applica-
tions in a sequential way; a new application is only han-
dled when the previous applications has been checked
for eligibility
fig. 2: common beginner mistakes when capturing a job hiring process (diagrams
inspired from [12])
3 the ocbc model
we now deﬁne the syntax and graphical appearance of ocbc models, and informally
comment about their formal semantics. we use the job hiring example of section 2.1 to
illustrate the main concepts and to show the sophistication of this approach.
the original proposal in the ocbc model [14,11] is the way activities and data are
related. in particular, an ocbc model captures, at once:
–data dependencies , represented using standard data models containing classes,
relationships and constraints between them;
–mutual relationships between activities and classes , linking the execution of
tasks in a given process with the data objects they manipulate;
–temporal constraints between tasks;
–co-reference constraints that enforce the application of temporal dependencies, and
in particular scope their application to those tasks instances that indirectly co-refer
thanks to the objects and relationships they point to.
we start by recalling data models and temporal constraints, which are then used as
the basic building blocks of the ocbc approach.
3.1 the data model – clam
we assume that data used by the activities is structured according to the clam data model
(which stands for class data model ). while we do not advocate here for a new data
model, for simplicity, we assume clam to be a simpliﬁed version of uml, with object
classes that can be organized along isahierarchies (with possibly disjoint sub-classes
and covering constraints), binary relationships between object classes and cardinalities
expressing participation constraints of object classes in relationships. more formally we
have:enriching data models with behavioral constraints 7
deﬁnition 1 (clam syntax). a conceptual schema ⌃in the class model, clam, is a
tuple
⌃=(uc,ur,⌧,#dom,#ran,isa,isa r,disj,cov),where:
–ucis the universe of object classes. we denote object classes as o1,o2,...;
–uris the universe of binary relationships among object classes. we denote relation-
ships as r1,r2,...;
–⌧:ur!u c⇥ucis a total function associating a signature to each binary
relationship. if ⌧(r)=( o1,o2)then o1is the range and o2thedomain of the
relationship;
–#dom:ur⇥uc7!n⇥(n[ {1} )is a partial function deﬁning cardinality
constraints of the domain of a relationship. the value #dom(r, o)is deﬁned only if
⌧(r)=( o,o 1);
–#ran:ur⇥uc7!n⇥(n[ {1} )is a partial function deﬁning cardinality
constraints of the range of a relationship. #ran(r, o)is deﬁned only if ⌧(r)=
(o1,o);
–isa✓uc⇥ucis a binary relation deﬁning the super-class and sub-class hierarchy
on object classes. if isa(c1,c2)then c1is said to be a sub-class ofc2while c2is
said to be a super-class ofc1;
–isa r✓ur⇥ur, similar to isa, allows to specify sub-relationships in the model;
–disj ✓2uc⇥ucis a binary relation deﬁning the set of disjoint sub-classes in an
isahierarchy on object classes;
–cov ✓2uc⇥ucis a binary relation deﬁning the set of sub-classes covering the
super-class in an isahierarchy on object classes.
as for the formal set-theoretic semantics of clam and its translation to dls we refer
to [15,16,17]. there, cardinality constraints are interpreted as the number of times each
instance of the involved class participates in the given relationship, isais interpreted
as sub-setting, while disj and cov are interpreted in the obvious way using disjoint-
ness/union between classes. more speciﬁcally, since we are using data models in a
dynamic setting where object and relationships evolve over time, we interpret them along
the temporal semantics presented in [ 18,19,20] for temporal data models. essentially,
the constraints captured therein must be satisﬁed in each snapshot (i.e., time point) of
the system.
example 1. figure 1 can be represented as a clam conceptual schema as:
uc={person ,candidate ,application ,job offer ,job proﬁle };
ur={made by ,responds to ,refers to };
⌧(made by )=( application ,candidate ),...
isa={(candidate ,person )};
#dom(made by ,application )=( 1 ,1);
#ran(made by ,candidate )=( 1 ,1);...
cardinalities are shown in the diagram as in uml. /8 a. artale, d. calvanese, m. montali, and w. van der aalst
a bresponse
a bunary -response
a bnon-response
a bprecedence
a bunary -precedence
a bnon-precedence
a bresponded -existence
a bnon-coexistence
fig. 3: types of temporal constraints between activities
response (a, b) if a is executed, then b must be executed afterwards.
unary -response (a, b) if a is executed, then b must be executed exactly once after-
wards.
precedence (a, b) if a is executed, then b must have been executed before.
unary -precedence (a, b) if a is executed, then b must have been executed exactly once
before.
responded -existence (a, b)if a is execute, then b must also be executed (either before or
afterwards).
non-response (a, b) if a is executed, then b will not be executed afterwards.
non-precedence (a, b) if a is executed, then b was never executed before.
non-coexistence (a, b) a and b cannot be both executed.
fig. 4: intuitive meaning of temporal constraints
3.2 temporal constraints over activities
taking inspiration from the declare patterns [ 3], we present here the temporal
constraints between (pairs of) activities that can be expressed in ocbc. fig. 3 graphically
renders such constraints, while their textual representation is deﬁned next.
deﬁnition 2 (temporal constraints). let
–uabe the universe of activities, denoted with capital letters a1,a2,...;
–utcbe the universe of temporal constraints , i.e., utc ={response ,
unary -response ,precedence ,unary -precedence ,responded -existence ,
non-response ,non-precedence ,non-coexistence }, as shown in fig. 3, where
each tc 2utcis a binary relation over activities, i.e., tc ✓ua⇥ua.
the set of temporal constraints in a given ocbc model is denoted as ⌃tcand is
conceived as a set of elements of the form tc(a1,a2), where tc2utcanda1,a22ua.
in the literature, such constraints are typically formalised using linear temporal logic
over ﬁnite traces [21,22]. we report their intuitive meaning in fig. 4.enriching data models with behavioral constraints 9
3.3 ocbc models and their components
we are now ready to deﬁne the ocbc model, and comment on its constitutive com-
ponents, starting from data models and temporal constraints as respectively deﬁned in
sections 3.1 and 3.2.
deﬁnition 3 (ocbc syntax). an ocbc model, m, is a tuple:
(clam ,ua,urac,⌧rac,#act,#obj,cref,neg-cref ),where:
–uais the universe of activities;
–clam is a data model as in deﬁnition 1;
–uracis the universe of activity-object relationships being a set of binary relation-
ships;
–⌧rac:urac!u a⇥ucis a total function associating a signature to each
activity-object relationship. if ⌧rac(r)=( a, o)then a2uaando2uc;
–#act:urac⇥ua7!n⇥(n[ {1} )is a partial function deﬁning cardinality
constraints on the participation of activities in activity-object relationships. the
value #act(r, a)is deﬁned only if ⌧rac(r)=( a, o);
–#obj:urac⇥uc7! {1}is apartial function that, when deﬁned, denotes the activity
thatgenerated a given object in o.#obj(r, o)is deﬁned only if ⌧rac(r)=( a, o);
–cref is the partial function of co-reference constraints s.t.
cref:⌃+
tc⇥urac⇥urac7! uc[ur;
–neg-cref is the partial function of negative co-reference constraints s.t.
cref:⌃ 
tc⇥urac⇥urac7! uc[ur.
activity-object relationships capture how activities relate to classes. let r2urac
so that ⌧rac(r)=( a, o). the intuitive meaning of ris that each instance of activity
aoperates over a single object of type o. in this light, inverses of activity-object
relationships are assumed to be functional. on top of this, we single out activity-object
relationships capturing the fact that objects of the related class are generated when
instances of the related activity are executed. we call these special relationships as
generating activity-object relationships . ifris of this form, then it is associated to a
cardinality constraint of the form #obj(r, o)=1 . the semantics of this cardinality
constraint is as follows: whenever an object ois of type oat a given time t, then there
must have been a previous time t0at which an activity instance aof type awas executed
ono(i.e., such that r(a, o)held at time t0).
cardinality constraints for participation of activities in activity-object relationships
(#act) are instead captured as classical cardinalities in data models (see [15,18,20]).
in the following, we show how activity-object relationships can be used to cap-
ture some of the constraints of our job hiring case study, and comment on interesting
properties of the resulting ocbc model.
example 2. figure 5 shows how constraints c.1–c.6from the job hiring case study
from section 2.1 can be captured in ocbc. we maintain the color and font coding
schemes used in section 2.1, so as to facilitate establishing a connection between the
textual description of constraints, and their corresponding ocbc representation.10 a. artale, d. calvanese, m. montali, and w. van der aalst
is about11
creates
1promotes
1creates1
1stops
1closes
1person
candidate application job offer job proﬁle1
/made by1..⇤ ⇤
responds to1 ⇤
refers to1register
datasubmitmark as
eligible
post
offercancel
hiringdetermine
winner
fig. 5: activity-object relationships in the job hiring scenario of section 2.1
as it is clear from the ﬁgure, the activity-object relationships connecting submit to
application andpost offer tojob offer represent object generation tasks, whereas the
other relationships capture cases where the existence of objects in the classes pointed by
activities does not necessarily imply the execution of instances of such activities. so, a
person can exist in the domain even if no data have been registered for him/her, whereas
an application can exist in the domain only if it was created by an instance of the submit
task.
notably, even though the ocbc model in figure 5 does not contain any explicit
temporal constraint, the presence of activity-object relationships that generate objects,
and their interplay with the constraints present in the data model, already implies the
existence of implicit constraints over the allowed activity executions.
first and foremost, optional activities pointing to a class that is also pointed by a
generating activity-object relationship, can only be executed on an object if that very
same object was previously created. this means that an application can be marked as
eligible only if it was previously created through the execution of a submit activity
instance. similarly, a job offer can be stopped by a cancel hiring activity instance, or
closed by a determine winner activity instance, only if it has been previously created by
executing a post offer activity instance.
this temporal dependencies could also propagate further, depending on how the
pointed classes are related to each other. we discuss in particular two examples from
figure 5. when a job offer is created by posting it, it also requires to create a corre-
sponding job proﬁle, or to relate it to an existing job proﬁle; this is due to the cardinality
constraint indicating that each job offer refers to one and only one job proﬁle. even
more interesting is the creation of an application, which requires on the one hand to
create or select the candidate owning that application, but on the other hand also to
relate it to a job offer, simultaneously or previously created. all in all, the interplay
between the two generating activity-object relationships for application andjob offer ,
mediated by the responds to relationship linking each application to one and only one
job offer, implicitly introduces a complex precedence constraint stating that: whenever
anapplication issubmitted responding to some job offer ,that job offer must
have been posted before . /enriching data models with behavioral constraints 11
2 already gives an intuition about the sophistication, but also the subtleties, arising when
adopting the ocbc approach. this is an intrinsic characteristic of declarative process
modelling notations, as extensively discussed in [21,23].
co-reference constraints constitute the most powerful construct in ocbc. they have
the ability of scoping the temporal constraints deﬁned in section 3.2, in such a way
that they do not apply to any instances of the corresponding activities, but only to
those activity instances that co-refer to each other via the objects they refer to. the
co-reference may insist on a class, thus requiring such objects to be the same object,
or on a relationship, thus requiring such objects to be related to each other via that
relationship.
this is of utmost importance. take for example constraint c.7from section 2.1.
that constraint is not satisﬁed if submitting an application is preceded by an arbitrary
instance of the register data task. the constraint requires more: that there exists a
preceding instance of the register data task that is about the very same candidate
who is related to that application via the made by relationship. similarly, according to
c.11 , the execution of an instance of the cancel hiring task on some job offer does
not at all prevent the possibility of determining thewinner for other offers.
according to deﬁnition 3, there are two kinds of co-reference constraints: positive
and negative, and they can range either over object classes (as illustrated in fig. 6a
and 6c) or over relationships (as illustrated in fig. 6b and 6d). the semantics of co-
reference temporal constraints, considering response andnot-response as proto-
typical example, is informally given in figure 6. a similar meaning can be assigned
toprecedence andnot-precedence (by substituting aftewards with before ), and to
responded -existence andnot-coexistence (by removing afterwards and consider-
ing the entire timeline).
to better clarify the usage of such constraints, and also the interesting (and subtle)
features of unary temporal constraints, we make again use of our case study in the job
hiring domain.
example 3. the ocbc model illustrated in figure 7 captures allconstraints described
in section 2.1. interestingly, each constraint mentioned in section 2.1 is mirrored into a
corresponding activity-object relationship or co-referenced temporal constraint in the
diagram.
theco-reference constraints involving object classes specify constraints on how
objects connected to different activities can/cannot be shared. for example, the job
offer instance stopped by acancel hiring activity is the same as the one closed by
the corresponding determine winner forbidden by the non-coexistence constraint.
this means that when one of the two activities is executed on a job offer, the other
cannot be executed on the same offer, but may be still executable for other offers. this
constraint can be expressed using the following ocbc syntax:
cref 
non-response (determine winner ,cancel hiring ),closes ,stops 
=job offer
the co-reference constraints involving relationships specify constraints on how activities
can/cannot occur on given objects connected to different be related to each other through
the data model. as an example, the co-reference precedence temporal constraint12 a. artale, d. calvanese, m. montali, and w. van der aalst
a1 a2
or1 r2every time an instance a1ofa1is executed
on some object oof type o(i.e., with r1(a1,o)),
then an instance a2ofa2must be executed afterwards
on the same object o(i.e., with r2(a2,o))
(a) co-reference of response over an object class
a1 a2
o1 o2
rr1 r2every time an instance a1ofa1is executed
on some object o1of type o1(i.e., with r1(a1,o1)),
then an instance a2ofa2must be executed afterwards
on some object o2of type o2(i.e., with r2(a2,o2))
thatrelates to o1viar
(i.e., having r(o1,o2)at the moment of execution of a2).
(b) co-reference of response over a relationship
a1 a2
or1 r2every time an instance a1ofa1is executed
on some object oof type o(i.e., with r1(a1,o)),
then no instance a2ofa2that relates to the same object o
(i.e., with r2(a2,o)) can be executed afterwards
(c) co-reference of non-response over an object class
a1 a2
o1 o2
rr1 r2every time an instance a1ofa1is executed
on some object oof type o(i.e., with r1(a1,o)),
then no instance a2ofa2thatrelates to o1viar 
(i.e., so that there exists o2with r2(a2,o2)andr(o1,o2))
can be executed afterwards
(d) co-reference of non-response over a relationship
fig. 6: co-reference response constraints over (a) object classes and (b) relationships,
with their negated versions (c-d)
relating submit toregister data enables the possibility of submitting an application,
only if the candidate
cref(precedence 
submit ,register data ),is about ,sends 
=made by .
obviously, although not directly linked to candidate , the is about activity-object
relationship is inherited by that class given the isalinking it to person . it is interesting
to notice that this constraint does by no means affect when and how many times theenriching data models with behavioral constraints 13
is about11
creates
1promotes
1creates1
1stops
1closes
1person
candidate application job offer job proﬁle1
/made by1..⇤ ⇤
responds to1 ⇤
refers to1register
datasubmitmark as
eligible
post
offercancel
hiringdetermine
winner
fig. 7: ocbc model for the job hiring scenario of section 2.1, where each one of
c.1–c.11 therein corresponds to either an activity-object relationship or a co-reference
temporal constraint in the ocbc model. the lightweight constraint is redundant: it is
implied by the other constraints in the diagram.
register data task can be executed for a given person . this implicitly captures the
fact that the same person may updated his/her personal data multiple times.
of particular interest is the unary -response constraint relating mark as eligible
todetermine winner (which captures c.9from section 2.1), in particular when
multiple applications submitted to the same job offer (say, job offer o) are marked as
eligible. in this case, the constraint requires that every instance of the mark as eligible
taskpromoting anapplication thatresponds to o, is eventually followed by a single
instance of the determine winner task that closes offer o. such a single instance of
determine winner for offer owill be actually the same for all such eligible applications.
in fact, having two distinct instances of determine winner for offer owould violate
the fact that the constraint is a unary response. this has a twofold implication:
–the (unique) instance of determine winner foromust occur after all the occur-
rences of mark as eligible for applications that respond to o.
–once the (unique) instance of determine winner forois executed, it is not possible
anymore to mark as eligible any application responding to o. it this would happen,
they would require a later occurrence of determine winner foro, which would
clash with the uniqueness requirement. this shows that the non-response constraint
relating determine winner tomark as eligible via the responds to relationship
is actually redundant: it is implied by the unary -response constraint relating mark
as eligible todetermine winner via the same responds to relationship. notice
that further applications may be still submitted for a closed job offer, but they will
not be marked as eligible. /
4 conclusion and discussion
we have presented the ocbc model, which enriches structural conceptual models with
behavioural constraints. by means of a small, but relevant case study, we have shown14 a. artale, d. calvanese, m. montali, and w. van der aalst
application
eligiblejob offer
assigned⇤ 1
responds to
1 0..1
wins formark as
eligibledetermine
winner
promotes1
1closes
1
fig. 8: combining behavioural constraints and subtyping to capture phases and how
objects enter in a given phase. the ﬁgure modiﬁes the ocbc model for the job hiring
example shown in figure 7, by introducing the explicit characterisation of an assigned
job offer , which is a phase entered by a job offer when the winner is determined ,
which in turn requires to pick one eligible application among those that responds to
that offer. the two temporal constraints now express that when at least one application
thatresponds to job offer ois promoted toeligible , then determine winner
closing ocan (and is expected) to occur exactly once. since determine winner
references the subtype assigned job offer , upon an occurrence of this activity o
migrates from being just a generic job offer , to now become in phase assigned .
how ocbc captures the interconnection between the process and the data perspective,
in a way that allows one to elegantly capture complex many-to-many processes simul-
taneously operating over different objects. we have discussed that such processes are
recurrent in practice, but they can hardly be represented using conventional, case-centric
process modelling notations.
we believe that the ocbc approach can constitute the basis for novel research
at the intersection of business process management, conceptual modelling, automated
reasoning, and formal ontology. a line of research focussed on the discovery of ocbc
models from event logs of process executions has been already started [ 24,25].w e
discuss next some of the main challenges that are still open, and were we believe the
synergy with recent works by nicola and colleagues would be particularly intriguing.
formal semantics and relationship with other process modelling approaches. as
already recalled in the introduction, the formal semantics of ocbc can be deﬁned in pure
logical terms by resorting to ﬁrst-order temporal logic, i.e., ﬁrst-order logic equipped
with a special sort that represents time points and the usual <binary relation over time
points (fol( <). in particular, every construct present in the ocbc model of interest is
translated into a corresponding fol( <) formula, and the semantics of the entire model
is then simply obtained as the conjunction of all so-obtained formulae.
it is interesting to notice that while this approach is customary in structural conceptual
modelling, it departs from the usual approach followed in business process management,
where the formal (execution) semantics of the process is given in terms of a petri net or
transition system, whose states can possibly be annotated with the conﬁguration of the
data characterising the corresponding state of affairs. this shows that, typically, processes
semantically decouples the structural and temporal/dynamic aspects of the system.
in addition, if such data have to be interpreted under the assumption of incompleteenriching data models with behavioral constraints 15
information, then this semantics cannot capture the evolution of “what is true”, but only
the evolution of “what is certainly known to be true” [10,9].
a preliminary attempt to deﬁne the formal semantics of ocbc can be found in [ 11].
one of the main assumptions in that paper is that activity occurrences executed within
the process should be identiﬁed always by the same objected, acting as a sort of global
process (or scenario) identiﬁer. however, this is only needed it one wants to incorporate
in the ocbc model also global temporal constraints that do not correlate activities
via the data model, but just mutually relate all their possible occurrences. if we only
consider temporal constraints that co-refer activities via the structural conceptual model,
like those presented in this paper, then we do not need such a global identiﬁer, and we
can in fact safely assume that each activity occurrence is not important per sè, but only
in terms of how it relates to the objects in the data model. this reﬂects the intuition
that a candidate in our job hiring example is interested in knowing the identiﬁer of the
application (s)he submitted, but never explicitly refers to the different identiﬁers of the
activity occurrences used to evolve that application.
from the ontological point of view, it remains open to understand whether it is an
essential property of activities to refer to the structural conceptual model, and of temporal
constraints to co-refer via the structural conceptual model, or whether we should instead
conceive also processes that have “global” activities and constraints. this requires a
research agenda focused on the nature of processes and their participants, which has
been recently initiated by adamo et al. in [ 13], but that still misses an ontological
characterisation of how data objects participate to processes.
reasoning over ocbc models. it is notoriously known that domain experts have
difﬁculties in understanding declarative process models, both when indicating whether
an execution trace conforms to the modelled constraints [ 23], and when it comes to
determine which implicit constraints implied by those modelled explicitly [ 21]. in fact,
several hidden dependencies may arise from the (complex) interplay between temporal
constraints. at the same time, some modelled constraints may turn out to be redundant, in
the sense that they are implied by the other constraints in the model. we have discussed
this particular aspect in example 3. reasoning becomes therefore essential in the context
of ocbc, to support humans in ascertaining properties of the model, as well as in
checking whether a given execution trace conforms to the model.
reasoning over ocbc models presents at least two interesting challenges. first
of all, provably correct techniques to carry out fundamental reasoning tasks such as
consistency and constraint implication are needed. this requires, ﬁrst, to understand the
boundaries of decidability and complexity for such reasoning tasks. while the seman-
tics in [ 13] does not directly help towards this goal, we believe that capturing ocbc
constraints that always co-refer through the structural conceptual model can lead to a
much simpler formalisation. in particular, we are currently working on a formalisation
that can be fully captured within the temporal description logics tusalcqi and frag-
ments thereof [ 26,27,28,29,30]. such a formalisation would then provide a concrete
basis for automated reasoning, given that the main reasoning tasks for tusalcqi are
not only decidable, but also present the same worst-case complexity of reasoning on
(non-temporal) alcqi knowledge bases.16 a. artale, d. calvanese, m. montali, and w. van der aalst
a second, key aspect is related to a deeper understanding of ocbc in terms of
ontological analysis. this requires, as a starting point:
–to study how metaproﬁles, in the style of well-known approaches such as onto-
clean [ 31], apply to ocbc activities, but also how ocbc constraints interact
with metaproﬁles used in the structural conceptual schema. figure 8 shows an
example of how an ocbc constraint may interact with phase types .
–to study how ocbc activities can be conceived as (ontological) events . this
is a rather unexplored, but extremely important, topic, not just in the context of
ocbc, but also within business process management in general. this appears to
be extremely difﬁcult when considering foundational ontologies such as dolce
[32], which adopt an eternalist view according to which allevent occurrences
are fully determined (although some of them may be not known). fortunately,
recent developments by guizzardi et al. [ 33] and by guarino [ 34] are now putting
forward an approach where only past events are considered frozen in time, whereas
future events may be genuinely subject to change. this constitutes a solid basis for
understanding events in the context of business processes in general, and ocbc in
particular.
enactment, monitoring, and ontological characterisation of process traces. under-
standing the relationship between ocbc models and the general notion of event becomes
particularly important when the ocbc model is instantiated into an actual execution.
this relationship can be established at a twofold level: the level of activity occurrences,
and that of the entire execution trace.
at the activity level, during enactment one has to clearly distinguishing the events
that have already occurred (and that are consequently frozen in time) from those that
may occur in the future. for the latter, it would be interesting to understand how the
foundational approach in [ 34] can be used to reconstruct the expectations about the
occurrence of future events. in particular, depending on the current execution trace
and the temporal constraints in the model, one should distinguish between activity
occurrences that are expected to occur in the future, those that are forbidden to occur
in the future, and those that instead may happen. monitoring goes even beyond that,
suggesting that not only future event occurrences have to be considered in terms of these
executability criteria, but also that the status of temporal constraints themselves has to
be considered [35,36,37].
at the overall execution trace level, it has to be noted that there is a fundamental
difference between case-centric approaches and declarative, constraint-based approaches
such as ocbc. on the one hand, the execution of an instance of a case-based process is,
in the terminology of guarino [ 34], an episode , because it requires to eventually reach
one of the ending states foreseen by the process model (e.g., the delivery of an order, or
the assignment/cancelation of a job offer). on the other hand, the execution of an instance
of a constraint-based process is what guarino calls in [ 34]aprocess , since it has no
culminating part characterising its full realisation, but can instead be stopped whenever
all temporal constraints present in the model are satisﬁed. in addition, it may happen that
an evolving process instance deviates from the acceptable courses of executions foreseen
by a case-centric process model, or causes the violation of one or more constraints in a
declarative process model (either because of a direct violation of a single constraint, orenriching data models with behavioral constraints 17
because of multiple conﬂicting constraints that could not anymore be all satisﬁed, no
matter how the execution continues [ 38]). how to characterise these different types of
events and episodes is extremely important per sè, but also to contextualise processes
and their execution within the broader context of organisational compliance, risk, and
governance.
references
1.van der aalst, w.m.p.: process mining: data science in activity. springer (2016)
2.van der aalst, w., li, g., montali, m.: object-centric behavioral constraints. corr
abs/1703.05740 (2017)
3.van der aalst, w., pesic, m., schonenberg, h.: declarative workﬂows: balancing between
flexibility and support. computer science - research and development 23(2) (2009) 99–113
4.bhattacharya, k., gerede, c., hull, r., liu, r., su, j.: towards formal analysis of artifact-
centric business process models. in: proc. of the 11th int. enterprise distributed object
computing conf. (edoc). v olume 4714 of lncs., springer (2007) 288–304
5.cohn, d., hull, r.: business artifacts: a data-centric approach to modeling business
operations and processes. ieee data engineering bulletin 32(3) (2009) 3–9
6.gonzalez, p., griesmayer, a., lomuscio, a.: veriﬁcation of gsm-based artifact-centric
systems by predicate abstractivity. in: proc. of the 13th int. conf. on service-oriented
computing (icsoc). v olume 9435 of lncs., springer (2015) 253–268
7.vianu, v .: automatic veriﬁcation of database-driven systems: a new frontier. in: proc. of the
12th int. conf. on database theory (icdt). (2009) 1–13
8.calvanese, d., de giacomo, g., montali, m.: foundations of data-aware process analysis:
a database theory perspective. in: proc. of 32nd symp. on principles of database systems
(pods). (2013)
9.bagheri hariri, b., calvanese, d., montali, m., de giacomo, g., de masellis, r., felli, p.:
description logic knowledge and action bases. journal of artiﬁcial intelligence research
46(2013)
10.levesque, h.j.: foundations of a functional approach to knowledge representation. artiﬁcial
intelligence (1984)
11.van der aalst, w.m.p., artale, a., montali, m., tritini, s.: object-centric behavioral con-
straints: integrating data and declarative process modelling
12.silver, b.: bpmn method and style. 2nd edn. cody-cassidy (2011)
13.adamo, g., borgo, s., francescomarino, c.d., ghidini, c., guarino, n., sanﬁlippo, e.m.:
business processes and their participants: an ontological perspective. in esposito, f., basili,
r., ferilli, s., lisi, f.a., eds.: proc. of the xvith int. conf. of the italian association for
artiﬁcial intelligence (ai*ia). v olume 10640 of lncs., springer (2017) 215–228
14.li, g., montali, m., van der aalst, w.m.p.: object-centric behavioral constraints. corr
technical report, arxiv.org e-print archive (2017)
15.berardi, d., calvanese, d., de giacomo, g.: reasoning on uml class diagrams. artiﬁcial
intelligence 168(1–2) (2005) 70–118
16.artale, a., calvanese, d., kontchakov, r., ryzhikov, v ., zakharyaschev, m.: reasoning over
extended er models. in: proc. of the 26th int. conf. on conceptual modeling (er). v olume
4801 of lncs., springer (2007) 277–292
17.franconi, e., mosca, a., solomakhin, d.: orm2: formalisation and encoding in owl2. in:
proc. of int. workshop on fact-oriented modeling (orm). (2012) 368–378
18.artale, a., parent, c., spaccapietra, s.: evolving objects in temporal information systems.
annals of mathematics and artiﬁcial intelligence 50(1–2) (2007) 5–3818 a. artale, d. calvanese, m. montali, and w. van der aalst
19.artale, a., franconi, e.: foundations of temporal conceptual data models. in: conceptual
modeling: foundations and applications. v olume 5600 of lncs. springer (2009) 10–35
20.artale, a., kontchakov, r., ryzhikov, v ., zakharyaschev, m.: complexity of reasoning over
temporal data models. in: proc. of the 29th int. conf. on conceptual modeling (er). v olume
4801 of lncs., springer (2010) 277–292
21.montali, m., pesic, m., van der aalst, w.m.p., chesani, f., mello, p., storari, s.: declarative
speciﬁcation and veriﬁcation of service choreographiess. acm trans. on the web (tweb)
4(1) (2010)
22.de giacomo, g., de masellis, r., montali, m.: reasoning on ltl on ﬁnite traces: insensitivity
to inﬁniteness. in: proc. of the 28th aaai conference on artiﬁcial intelligence. (2014) 1027–
1033
23.fahland, d., lübke, d., mendling, j., reijers, h.a., weber, b., weidlich, m., zugal, s.:
declarative versus imperative process modeling languages: the issue of understandability.
in halpin, t.a., krogstie, j., nurcan, s., proper, e., schmidt, r., soffer, p., ukor, r., eds.:
proc. of the 10th int. ws. on business-process and information systems modeling (bpmds).
v olume 29 of lnbip., springer (2009) 353–366
24.li, g., medeiros de carvalho, r., van der aalst, w.m.p.: automatic discovery of object-
centric behavioral constraint models. in: proc. of the 20th int. conf. on business information
systems (bis 2017). v olume 288 of lnbip., springer (2017) 43–58
25.li, g., de murillas, e.g.l., medeiros de carvalho, r., van der aalst, w.m.p.: extracting
object-centric event logs to support process mining on databases. in: proc. of information
systems in the big data era (caise forum). volume 317 of lnbip., springer (2018)
182–199
26.wolter, f., zakharyaschev, m.: temporalizing description logics. in: frontiers of combining
systems. research studies press-wiley (2000) 379 – 401
27.artale, a., franconi, e., wolter, f., zakharyaschev, m.: a temporal description logic for
reasoning over conceptual schemas and queries. in: proc. of the 8th european conference
on logics in artiﬁcial intelligence (jelia-02). volume 2424 of lnai., springer-verlag
(september 2002) 98–110
28.gabbay, d., kurucz, a., wolter, f., zakharyaschev, m.: many-dimensional modal logics:
theory and applications. studies in logic. elsevier (2003)
29.lutz, c., wolter, f., zakharyaschev, m.: temporal description logics: a survey. in: proc.
of the 15th int. symposium on temporal representation and reasoning (time 08), ieee
computer society (2008) 3–14
30.artale, a., kontchakov, r., ryzhikov, v., zakharyaschev, m.: a cookbook for temporal
conceptual data modelling with description logics. acm transactivity on computational
logic (tocl) 15(3) (2014)
31.guarino, n., welty, c.a.: evaluating ontological decisions with ontoclean. commun. acm
45(2) (2002) 61–65
32.gangemi, a., guarino, n., masolo, c., oltramari, a., schneider, l.: sweetening ontologies
with dolce. in gómez-pérez, a., benjamins, v .r., eds.: proceedings of the 13th int. conf.
on knowledge engineering and knowledge management (ekaw). v olume 2473 of lncs.,
springer (2002) 166–181
33.adamo, g., borgo, s., francescomarino, c.d., ghidini, c., guarino, n., sanﬁlippo, e.m.:
business process activity relationships: is there anything beyond arrows? in weske, m.,
montali, m., weber, i., vom brocke, j., eds.: proceedings of the 2018 business process
management forum (bpm forum). v olume 329 of lnbip., springer (2018) 53–70
34.guarino, n.: on the semantics of ongoing and future occurrence identiﬁers. in mayr, h.c.,
guizzardi, g., ma, h., pastor, o., eds.: proceedings of the 36th int. conf. on conceptual
modeling (er). v olume 10650 of lncs., springer (2017) 477–490
35.bauer, a., leucker, m., schallhart, c.: comparing ltl semantics for runtime veriﬁcation.
logic and computation (2010)enriching data models with behavioral constraints 19
36.de giacomo, g., de masellis, r., grasso, m., maggi, f.m., montali, m.: monitoring business
metaconstraints based on ltl & ldl for ﬁnite traces. in sadiq, s.w., soffer, p., völzer, h.,
eds.: proceedings of the 12th international conference on business process management
(bpm). v olume 8659 of lncs., springer (2014) 1–17
37.de masellis, r., maggi, f.m., montali, m.: monitoring data-aware business constraints with
ﬁnite state automata. in: proceedings of the international conference on software and system
process (icssp). (2014)
38.maggi, f.m., westergaard, m., montali, m., van der aalst, w.m.p.: runtime veriﬁcation of
ltl-based declarative process models. in khurshid, s., sen, k., eds.: proceedings of the 2nd
international conference on runtime veriﬁcation (rv). volume 7186 of lncs., springer
(2012) 131–146