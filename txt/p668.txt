an operational decision support framework
for monitoring business constraints
fabrizio maria maggi1,⋆, marco montali2,⋆⋆,a n dw i lm . p .v a nd e ra a l s t1
1eindhoven university of technology, the netherlands
{f.m.maggi,w.m.p.v.d.aalst }@tue.nl
2krdb research centre, free university of bozen-bolzano, italy
montali@inf.unibz.it
abstract. only recently, process mining techniques emerged that can
be used for operational decision support (os), i.e., knowledge extracted
from event logs is used to handle running process instances better. in the
process mining tool prom, a generic os service has been developed that
allows prom to dynamically interact with an external information sys-
tem, receiving streams of eventsand returning meaningful insights on the
running process instances. in this paper, we present the implementation
of a novel business constraints monitoring framework on top of the prom
os service. wediscuss the foundations of themonitoring framework con-
sidering two logic-based approaches, tailored to linear temporal logic
on ﬁnite traces and the event calculus.
keywords: declare, process mining, monitoring, operational decision
support.
1 introduction
process mining has been traditionally applied on historical data that refers to
past, complete process instances. recentl y, the exploitation of process mining
techniques has been extended to deal also with running process instances which
havenotyetbeencompleted.inthissetting,processminingprovides operational
decision support (os), giving meaningful insights that do not only refer to the
past, but also to the present and the future [1]. in particular, os techniques can
be used to: checkthe current state of aﬀairs det ecting deviations between the
actual and the expected behavior; recommend what to do next; predictwhat
will happen in the future evolution of the instance.
in order to enable the eﬀective development of os facilities, the widely known
process mining framework prom 6 [2] incorporates a backbone for os [3]. here,
⋆this research has been carried out as a part of the poseidon project at thales under
theresponsibilities of theembeddedsystemsinstitute (esi).the project is partially
supported by the dutch ministry of economic aﬀairs under the bsik program.
⋆⋆this research has been partially supported by the nwo “visitor travel grant”
initiative, and by the eu project fp7-ict acsi (257593).
j. de lara and a. zisman (eds.): fase 2012, lncs 7212, pp. 146–162, 2012.
c/circlecopyrtspringer-verlag berlin heidelberg 2012an operational decision support framework 147
all the common functionalities needed fo r os are implemented, such as manage-
ment of requestscoming from external info rmation systems, dynamic acquisition
and correlation of incoming partial execu tion traces (representing the evolution
of process instances), and interaction with diﬀerent process instances at the
same time. the os backbone relies on a client-server architecture. the client is
exploited by an external stakeholder to send a partial trace to prom and ask
queries related to os. on the server side, an os service (running inside prom)
takes care of coordinating the available os functionalities in order to answer
such queries. multiple os providers that encapsulate speciﬁc os functionalities
can be developed and dynamica lly registered to the os service.
in this work, we present the implementation of a novel runtime compliance
veriﬁcation framework on top of the prom os. the framework is called mo-
bucon(monitoring business constraints) and its focus is to dynamically check
the compliance of running process instances with business constraints, detecting
deviations and measuring the degree of adherence between the actual and the
expected behavior.
givenabusinessconstraintsreferencemodelandapartialtracecharacterizing
the running execution of a process instance, mobucon infers the status of each
business constraint. in particular, it produces a constantly updated snapshot
about the state of each business constraint, reporting whether it is currently
violated. consequently, it determines whether the process instance is currently
complyingwith thereferencemodel ornot.besidethis, othermeaningfulinsights
canbe providedto end users,such as,forex ample, indicatorsand metricsrelated
to the “degree of compliance”, e.g., relating the number of violated constraints
with their total number.
the paper is organized as follows. section 2 presents the declarelanguage
[4] and its extension to include metric temporal constraints and constraints on
event-relateddata.the languageis declarativeand graphical.moreover, declare
has been formalized using a variety of l ogic-based frameworks, such as linear
temporal logic (ltl) with a ﬁnite-trace semantics1[5,6] and the event calcu-
lus (ec)[7,8].section3 describesthe architectureofour proposedframework.in
sect. 4 and 5, we describe the implementa tion of two diﬀerent reasoning engines
as os providers based on ltl and on the ec respectively. we are currently
applying our framework to various rea l-world case studies; in sect. 6, we re-
port on the monitoring of declareconstraints in the context of maritime safety
and security. finally, sect. 7 includes a comparison of the two approaches and
discusses related work and conclusion.
2d e c l a r e
declareis a declarative, constraint-based process modeling language ﬁrst pro-
posed in [5,4]. in a constraint-based approach, instead of explicitly specifying
all the acceptable sequences of activities in a process, the allowed behavior of
1for compactness, in the following we will use the ltl acronym to denote ltl on
ﬁnite traces.148 f.m. maggi, m. montali, and w.m.p. van der aalst
under way 
using engine
under way 
sailingmoored
constrained by 
her draughtprecedenceresponse
not coexistence
(a)basic declaremodelunder way 
using engine
under way 
sailingmoored
constrained by 
her draughtvtypevtype vtype
vtypevtype = passenger [0,360 ][0,2880 ]vtype = cargovtype != cargo /\vtype != passenger
(b) declaremodel augmented with data, data-aware
conditions and metric temporal constraints
fig. 1.two declaremodels in the context of maritime safety and security
the process is implicitly speciﬁed by means of declarative constraints, i.e., rules
that must be respected during the execu tion. in comparison with procedural
approaches, that produce “closed” models, i.e., models where what is not explic-
itly supported is forbidden, declarative languages are “open” and tend to oﬀer
more possibilities for execution. in particular, the modeler is not bound anymoreto explicitly enumerate the acceptable e xecutions and models remain compact:
they specify the mandatory and undesired behaviors, leaving unconstrained all
the courses of interaction that are neither mandatory nor forbidden.
declareis characterized by a user-friendly graphical front-end and is based
on a formal back-end. more speciﬁcally, the formal semantics of declarecan be
speciﬁed by using ltl [5,6], abductive logic programming with expectations [6],
or the ec [7,8]. these characteristics are crucial for two reasons. first, declare
can be used in real scenarios being understandable for end-users and usableby stakeholders with diﬀerent backgrounds. second, declare’s formal semantics
enable veriﬁcation and automated reasoning. this is a key aspect in the imple-
mentation of monitoring tools for declaremodels.
figure 1a shows a simple declaremodel elicited in the context of a real case
study related to the monitoring of vessels behavior in the context of maritimesafetyandsecurity.we usethis exampleto explainthe mainconcepts.itinvolves
four events(depicted as rectangles, e.g., under way using engine )a n dt h r e e
constraints (shown as arcs between the events, e.g., not coexistence ). events
characterize changes in the navigational status of each monitored vessel. con-
straints highlight mandatory and forbidden behaviors, implicitly identifying the
acceptable execution tra ces that comply with (all of) them. in our case study,
a vessel can be either under way using engine orunder way sailing but not
both, as indicated by the not coexistence between such two events. a vessel can
beconstrained by her draught , but only after being under way sailing (a vessel
equipped with an engine cannot be constrained by draught and a sailing vessel
cannotbe constrainedbefore it is under way).this isindicated by the precedence
constraint.finally,after being mooredeach vessel must eventually be under way
using engine , as speciﬁed by the response constraint.
in [7], an extension of this constraint-based language has been proposed; this
extension incorporatesalso non-atomic act ivities (i.e., activities whose executionan operational decision support framework 149
prom
os service
 process-aware 
information 
systems
mobucon 
provider
tcp/ipsend 
reference model
session query + partial trace
reference
modelpartial
tracereasoning
info
response
ﬂuents
model
mobucon
client
fig. 2.mobucon architecture
is characterized by a life cycle that includes multiple events), event-related data
anddata-awareconditionsandmetrictemporalconstraints(forspecifyingdelays,
deadlinesandlatencies).thisextendedlanguageisexploitedinfig.1btoaugment
the aforementioned constraints with conditions on time and data. more speciﬁ-
cally, we assume that each event is equip ped with two data: the identiﬁer of the
vessel and its type. in particular, the response constraintis now diﬀerentiated on
the basis of the vessel type, introducing diﬀerent timing requirements (which are
speciﬁed with the granularity of minute). the ﬁrst response constraint indicates
thatif the typeofthe vesselis passenger ship andevent mooredoccurs,then un-
der way using engine must eventually occur withi n 6 hours at most. the second
one indicates that if the type of the vessel is cargo ship andmooredoccurs, then
under way using engine musteventuallyoccurwithin48hours.alaststandard re-
sponseconstraintisemployedtocapturethebehaviorofallothervessels,without
imposinganydeadline.finally,althoughnotexplicitlyshowninthediagram,each
constraintisappliedtoeventsthatareassociatedtothesamevesselidentiﬁer.this
correlationmechanism makes it possible to properly monitor also a unique event
streamscollecting the evolvingbehaviorsof multiple vesselsatthe same time.
3 mobucon architecture
figure 2 shows the overall architecture of mobucon. mobucon relies on the gen-
eralarchitectureofthe os backboneimplemented inside prom6. such backbone
has been introduced and for malized using colored petri nets in [3]; in sect. 3.1,
we will therefore sketch some relevant a spects of the general architecture. in
sect. 3.2, we ground the discussion to th e speciﬁc case of mobucon, discussing
the skeleton of our compliance veriﬁcation os provider. the data exchanged
between the mobucon client and provider is illustrated in sect. 3.3. finally, in
sect. 3.4, we describe the implemented m obucon clients. the two concrete in-
stantiations of the mobucon skeleton in the ltl and ec settings are discussed
in sect. 4 and 5.
3.1 general architecture
the promos architecturerelieson the well-knownclient-serverparadigm.more
speciﬁcally, the prom os service manages the interaction with running process150 f.m. maggi, m. montali, and w.m.p. van der aalst
instances and acts as a mediator betw een them and the registered speciﬁc os
providers.
sessions are created and handled by the os service to maintain the state of
the interaction with each running client. to establish a stateful connection with
the os service, the client creates a session handle for each managed runningprocess instance, by providing host a nd port of the os service. when the client
sends a ﬁrst query related to one of such running instances to the os service,
it speciﬁes information related to the initialization of the connection (such as
reference models, conﬁguration paramet ers, etc.) and to the type of the queries
that will be asked during the execution. this latter information will be used bythe os service to select, among the regis tered active providers, the ones that
can answer the received query. the session handle takes care of the interaction
with the service from the client point of view, hiding the connection details andmanaging the information passing in a lazy way. the interaction between the
handle and the service takes pla ce over a tcp/ip connection.
3.2 mobucon skeleton
in mobucon, the interaction between a client and the os service mainly con-
sists of two aspects. first of all, before starting the runtime compliance veriﬁ-cation task, the client sends to the os service the declarereference model to
be used. this model is then placed inside the session by the os service. the
reference model is an xml ﬁle that contains the information about events and
constraints mentioned in the model . this format is generated by the declare
editor ( www.win.tue.nl/declare/ ). the client can also set further information
and properties. for example, each constraint in the declarereference model can
be associated to a speciﬁc weight, that c an be then exploited to compute metrics
and indicators that measure the degree of adherence of the running instance tothe reference model.
secondly, during the execution, the client sends queries about the current
monitoring status for one of the managed process instances. the session handleaugments these queries with the partial execution trace containing the evolution
that has taken place for the process instance after the last request. the os
service handles a query by ﬁrst storing t he events received from the client, and
then invoking the mobucon provider.
the mobucon providerrecognizeswhethe r it is being invokedforthe ﬁrsttime
w.r.t. that process instance. if this is the case, it takes care of translating the
reference model onto the underlying formal representation. the provider then
returns a fresh result to the client, exploiting a reasoning component for theactualresult’s computation.the reasoningcomponent, as well as the translation
algorithm, are dependent on the chosen logical framework (ltl or ec), while
thestructureofthe skeletonisthesameforthetwoapproaches.aftereachquery,
the generated result is sent back to the o s service, which possibly combines it
with the results produced by other relevant providers, ﬁnally sending the globalresponse back to the client.an operational decision support framework 151
 fluentsmodel
groupname  fluentsgroup
ﬂuentnamefluent
statenamefluentstate
starttimemvi endtimeclosedmvi
openmvi
fig. 3.fluent model used to store the evolution of constraints
3.3 exchanged data and business constraints states
we now discuss the data exchanged by the mobucon client and provider. note
that these data are common to both instantiations of the provider (mobucon
ltl and mobucon ec). the partial execution traces sent by the client to the
os use the xes format ( www.xes-standard.org/ ) for event data. xes is an
extensible xml-based s tandard recently adopted by the ieee task force on
process mining.
the response produced by the mobucon provider is composed of two parts.
the ﬁrst part contains the temporal information related to the evolution of
each monitored business constraint from the beginning of the trace up to now.
at each time point, a constraint can be in one state, which models whether it
is currently: satisﬁed, i.e., the current execution trace complies with the con-
straint2;(permanently) violated , i.e., the process instance is not compliant with
the constraint; pending(orpossibly violated ), i.e., the current execution trace is
not compliant with the constraint, but it is possible to satisfy it by generating
some sequence of events. this state-b ased evolution is encapsulated in a ﬂuent
modelwhich obeys to the schema sketched in fig. 3. a ﬂuent model aggregates
ﬂuents groups, containing sets of correlated ﬂuents. each ﬂuent models a multi-
state property that changes over time. in our setting, ﬂuent names refer to the
constraints of the reference model. the fact that the constraint was in a certain
state along a (maximal) time interval is modeled by associating a closed mvi
(maximal validity interval) to that state. mvis are characteri zed by their start-
ing and ending timestamps. current states are associate to open mvis, which
have an initial ﬁxed timestamp but an end that will be bounded to a currently
unknown future value.
the mobucon provider also computes the current value of a compliance in-
dicatorof the running monitored instance. this number gives an immediate
feeling about the “degree of adherence” between the instance and the reference
model. a low degree of adherence can be interpreted diﬀerently depending on
the application domain. in general, it is used to classify a process instance as
“unhealthy”. however, it can also be used to show that a reference model is
obsolete and it must be improved to better reﬂect the reality. the compliance
indicator can be computed using diﬀerent metrics, t hat can consider the cur-
rent state of constraints, as well as other information such as the weight of each
individual constraint. for example, the compliance indicator shown in fig. 5a,
implemented in mobucon ltl, is evaluated, at some time t, throughthe formula
1−/summationtext
iweight i#viol i(t)
#events (t)/summationtext
iweight i, and takes into account the number of violations of each
2mobucon ltl also diﬀerentiates between possibly and permanently satisﬁed.152 f.m. maggi, m. montali, and w.m.p. van der aalst
individual constraint of the reference model (# violi)a n di t sw e i g h t( weight i).
on the other hand, the compliance indicator shown in fig. 5b, implemented
in mobucon ec, considers the number of violated (# viol) and satisﬁed (# sat)
instances. in particular, at some time tthe compliance indicator corresponds to
1−#viol(t)
#viol(t)+#sat(t)3.
3.4 mobucon clients
wehavedevelopedthreemobuconclients,inordertodealwithdiﬀerentsettings:
(a)manualinsertionoftheevents,(b) replayofaprocessinstancestartingfroma
completeeventlog,and(c)acquisitionofeventsfromaninformationsystem.the
ﬁrst two clients are mainly used for testing and experimentation. the last client
requires a connection to some information system, e.g., a workﬂow management
system. the three clients diﬀer on how the user is going to provide the stream of
events, but all ofthem include an interface with a graphicalrepresentationofthe
obtained ﬂuent model, showing the evolution of constraints and also reporting
the trend of the compliance indicator (fig. 4).
4 mobucon ltl
as discussed earlier, there are two mobucon providers for monitoring business
constraints: one based on ltl and one based on the ec. we now describe the
ltl-based provider [9]. the basic idea is that a stream of events is monitored
w.r.t. a given declare reference model. each ltl constraint implied by the
declaremodel is translated to a ﬁnite state automaton. moreover, the conjunc-
tion of all ltl constraints is also translated to a ﬁnite state automaton. the
generated automata are used to monitor the behavior. using the terminology
introduced in [9], we call the automaton corresponding to a single declarecon-
straint local automaton and the automaton corresponding to their conjunction
global automaton . local automata are used to monitor each single constraint in
isolation,whereasthe globalautomatonis used to monitor the entiresystem and
detect non-local violations originated by the interplay of multiple constraints.
4.1 modeling and implementation
when mobucon ltl receives a request from a new process instance, it ﬁrst
initializesthe sessionforthat instance.in particular,eachsingleconstraintofthe
declaremodel associated to the session by the client and their conjunction are
translated into ﬁnite state automata. for the translation, we use the algorithm
introduced for the ﬁrst time in [10] and optimized in [11]. local and global
automata are stored in the session. after that, the provider processes the event
(or a collection of events) received wit h the ﬁrst request from the client. the
following requests will provide again single events or collections of events. the
3if # viol(t)+# sat(t) = 0, then the compliance indicator is deﬁned to be 1.an operational decision support framework 153
fig. 4.screenshot of one of the mobucon clients
events are processed one by one by using the automata every time retrieved
from the session. in this way, the state of each automaton is always preserved
from the last request. the set of ﬂuents’ mvis associated to each constraint is
recomputed accordingly and returned by the reasoner.
4.2 approach
both global and local automata are reduced so that, if a transition violates
the automaton from a certain state, this transition does not appear in the list
of the outgoing transitions from that state. more speciﬁcally, a transition canbe positive if it is associated to a single positive label (representing an event,
e.g., moored), or negative if it is associated to negative labels (e.g., ¬aground).
positive labels indicate that we follow the transition when exactly the event cor-
responding to that label occurs, whereas negative labels indicate that we can
follow the transition for any event not me ntioned. hence, acceptable events cor-
respondto the label associatedto a positive outgoing transitionfromthe current
state or to no one of the labels associated to a negative outgoing transition.
the mobucon ltl provider checks ﬁrst whether the processed event is ac-
ceptable by the global automaton. if the event is allowed, the provider ﬁres154 f.m. maggi, m. montali, and w.m.p. van der aalst
the corresponding transition on the global automaton. in this case, to compute
the state of every single constraint in isolation as well, it also ﬁres the transi-tions corresponding to the processed event on the local automata (note that,
if the event is acceptable by the global automaton, it is al so acceptable by all
local automata). if, after having ﬁred the transition, a local automaton is in annon-accepting state, the co rresponding constraint is po ssibly violated. if a local
automaton is in an accepting state, the co rresponding constraint is (possibly or
permanently) satisﬁed. to distinguish between possibly and permanently satis-
ﬁed constraints, the provider checks whether all possible events correspond to a
self loop on the current state. if this is the case, the constraint is permanentlysatisﬁed, otherwise it is possibly satisﬁed. if the processed event violates the
global automaton, from the point of view of the automata, the violating event
is ignored. however, the provider still informs the client that the event caused aviolation w.r.t. the reference model. moreover, it also gives intuitive diagnostics
about the violation. indeed, the global automaton allows the provider to pre-
cisely identify which events were permitted instead of the one that caused theviolation. this information is derived from the labels of the outgoing negative
and positive transitions from the current state in the global automaton.
in some cases, a violation in the global automaton can be directly reduced to
a violation of a local automaton. however, in other cases none of the individual
local automata is violated as the problem stems from the interplay of multipleconstraints [9]. in the latter case, the mobucon ltl provider is able to identify
the conﬂicting sets of constraints, i.e., the minimal sets of constraints that cause
the violation.
5 mobucon ec
mobucon ec exploits a reactive ec-based reasoner to provide monitoring fa-cilities. when a ﬁrst query is received for some process instance, the providerapplies a translation algorithm which analyzes the reference model stored in the
corresponding session, producing a set of corresponding ec axioms. it then cre-
ates a new instance of the reasoner, initializing it with the ec theory obtainedfrom the translation procedure. the reasoner instance is then stored into the
session. every time a new partial trace must be checked, the reasoner is ex-
tracted from the session and updated with the new events. this triggers a new
reasoning phase in which the previously stored ﬂuents’ mvis are revised and
extended. the set of all mvis is then returned by the reasoner.
in the following, we ﬁrst sketch how declareconstraints, possibly augmented
with data and metric temporal aspects, can be tackled by means of ec axioms.
we then discuss the implementation of the reasoner.
5.1 modeling
a comprehensive description of how the ec can be used in the declaresetting
canbefound in[8]. here,weconsideroneoftheconstraintsmentionedin fig.1b,an operational decision support framework 155
namely the response constraintovera cargo ship , to giveanintuition aboutsuch
a translation,considering data andmetrictemporalconstraintsas well.
broadly speaking, an ec theory is a logic program which employs special
predicates for modeling how ﬂuents chang e over time, in response of the execu-
tion of certain events. for example, initiates (e, f, t)(terminates (e, f, t)) is used
to say that event einitiates (terminates) f, i.e., makes ftrue (false), at time
t;holds
 at(f,t) is used to run queries over the validity of ﬂuents, in this case
verifying whether fis true at time t. for a comprehensive description of the ec,
we refer the reader to [12].
inthecontextof declare,anddiﬀerentlyfromtheltl-basedapproach,therun-
timecharacterizationofbusinessconstraintsisnotgivenovertheconstraintsthem-
selves,but istailoredto constraints’insta nces.aconstraintinstancerepresentsa
speciﬁc “grounding” of the constraint inside a speciﬁc context, i.e., with speciﬁc
data,speciﬁcinstantiationtime,andsoon. according to this observation, in the
ec-based formalization of declareﬂuents have the form state(i(id, p arams ),
state), where idis the identiﬁer of the constraint, pa ra m s is a list of parame-
ters characterizinga speciﬁc instance of the constraints, and stateis the current
state of the instance, i.e., one among sat,violand pend(to respectively model
that the constraint instance is satisﬁed, violated or pending). in our example,
theresponse constraintovera cargo ship will be identiﬁed by cr, andtheparams
characterizing each instance will be the i dentiﬁer of the vessel (needed to prop-
erly correlate events) and the creation t ime (needed to properly check the metric
temporal constraints).
ec axioms are given over event types , which are then subject, during the
execution, to uniﬁcation with each occurring concrete event. event types have
the form exec(na m e ,wh o ,d a t a ), where namei st h en a m eo ft h ee v e n t , wh o
identiﬁes the entity that originated the event, and datais a list of further
data. the response over a cargo ship is associated to the mooredand ( under
way using )engineevents, which can be represented by the two event types
exec(moored, v id,[vtype]) and exec(engine, v id,[vtype]). it is instantiated every
time a mooredevent happens for a cargo vessel; the instance is put in a pending
state, waiting for the occu rrence of a corresponding engineevent:
initiates (exec (moored,v id,[cargo ]),status (i(cr,[vid,t]),pend ),t)
astatetransitionfromthependingtothe satisﬁedstatehappensforaninstance,
if the following conditions hold: (1) the instance is currently pending; (2) an
engineevent occurs for a cargo ship ; (3) the event has the same vessel identiﬁer
of the instance; (4) the timestamp of the event is after the creation time of the
instance, but before the actual deadline (which corresponds to the creation time
plus 2880minutes). such statetransitionis modeled by terminating the previous
state and initiating the new one, if all conditions are satisﬁed:
terminates (exec (engine, v id,[cargo ]),status (i(cr,[vid,tc]),pend ),t):−
holds
at(status (i(cr,[vid,tc]),pend ),t),t >t c,t≤tc+ 2880.
initiates (exec (engine, v id,[cargo ]),status (i(cr,[vid,tc]),sat ),t):−
holds
at(status (i(cr,[vid,tc]),pend ),t),t >t c,t≤tc+ 2880.156 f.m. maggi, m. montali, and w.m.p. van der aalst
contrariwise, if a (generic) event ha p p e n sa tat i m ew h i c hi sg r e a t e rt h a n
the creation time of the instance plus 2880, and the constraint instance is still
pending, this attests that the deadline has expired, and that a transition from
the pending to the violated state must be triggered:
terminates (
,status (i(cr,[vid,tc]),pend ),t):−
holds
at(status (i(cr,[vid,tc]),pend ),t),t >t c+2 8 8 0.
initiates (
,status (i(cr,[vid,tc]),viol ),t):−
holds
at(status (i(cr,[vid,tc]),pend ),t),t >t c+2 8 8 0.
finally, a further general rule is added to state that each pending instance
becomes violated when the process instance is completed.
the visualization depicted in fig. 5b shows the status of the various con-
straints for a running trace and is based on the above axioms (together with the
ones modeling the other constraints in fig. 1b).
5.2 reasoner implementation
to eﬀectively compute the mvis characteri zing the evolution of each constraint
instance, mobucon ec relies on a reactive ec reasoner and three translation
components. a ﬁrst translator conv erts the xml representation of a declare
reference model to a corresponding set of ec axioms. a second one converts a
xes (partial) trace to a set of logic programming facts, also applying a trans-
lation of timestamps using the chosen granularity; such facts are then matched
against the ec axioms that formalize the reference model. a last translator is
used to convert the outcome produced by the reasoner (a set of strings) to a
ﬂuent model according to the schema of fig. 3.
the reactive reasoner is inspired by the cached ec (cec) developed by
chittaro and montanari [13]. it uses a prolog-based axiomatization of the ec
predicates following the cec philosophy, i.e., already computed mvis of ﬂuents
are cashed and subsequently revised a nd extended as new events are received.
diﬀerent underlyingprologenginescanbepluggedintothetool.inparticular,
we experimented tuprolog ( tuprolog.alice.unibo.it/ ) which is completely
implemented in java and thus guarantees a seamless integration inside prom,
and yap ( yap.sourceforge.net/ ), which is one of the highest-performance
prolog engine available today.
6 case study
in this section, we present the application of the two mobucon providers (ltl
and ec) as part of a case study conducted within the research project poseidon
(www.esi.nl/poseidon/ )andfocusedontheanalysisofvesselbehaviorinthedo-
mainofmaritimesafetyandsecurity.the casestudyhasbeenprovidedbythales,
a global electronics compan y delivering mission-critical information systems and
services for the aerospace, defense, an d security markets. in our experiments,
we use logs collected by an on-board maritime automatic identiﬁcation systeman operational decision support framework 157
(a)mobucon ltl.
 (b)mobucon ec.
fig. 5.examples of monitoring results in our case study
(ais) [14], which acts as a transponder that logs and sends events to an ais re-
ceiver. an event represents a change in th e navigational status of a vessel (e.g.,
mooredorunder way using engine ). each event has an associated vessel id and
vessel type (e.g., passenger ship orcargo ship ). the logs are excerpts of larger
logsandcorrespondtoaperiodofoneweek.the standardbehaviorofthe vesselsis describedby domainexpert using declare, where constraintsare used to check
the compliance ofthe behaviorof vesselsas recordedinthe logs.
let us ﬁrstfocus onthe mobuconltlprovider.figure1ashowsthe reference
model used to monitor vessels behavior. each vessel corresponds to a process
instance inthe log.figure5ashowsa graphicalrepresentationofthe constraints’
evolution for a speciﬁc instance. events are displayed on the horizontal axis (forthe sakeof readability,a morecompact notationis used). the vertical axisshows
the constraints, reporting their evolution as events occur.
when event mooredis executed the response constraint becomes possibly
violated. indeed, the constraint is wait ing for the occurrence of another event
(execution of ( under way using )engine) to become satisﬁed. after moored,(un-
der way)sailingis executed, leading to a conﬂict caused by the interplay of the
not coexistence and the response constraints. the conﬂict is due to the fact that
the ﬁrst constraint forbids whereas the other constraint requires the presence ofevent engine. note that, after a conﬂict or a (local) violation, constraints can158 f.m. maggi, m. montali, and w.m.p. van der aalst
become non-violated. in fact, mobucon ltl implements a recovery strategy
where the violating events are ignored (af ter having been reported). in this case,
for instance, when sailingoccurs, the conﬂict is raised but the event is, in fact,
ignored.thenexteventis engineandresponse (that waspossiblyviolatedbefore
the conﬂict) becomes possibly satisﬁed. after that, when event sailingoccurs,
not coexistence becomes permanently violated because engineand sailingcan-
not coexist in the same trace (note that also in this case the violating event is
ignored after that the violation ha s been reported). the next event is moored
and response becomes possibly violated. when the case completes, the response
constraint becomes violated because it is not possible to satisfy it anymore.
finally, note the trend of the compliance indicator in fig. 5a. the indicator
decreases in correspondence of each (local) violation. this example also shows
clearly that a violation of the response constraint inﬂuences the indicator more
than a violation of the not coexistence constraint.
let us now consider the mobucon ec provider, which employs the reference
model shown in fig. 1b. in order to show the potentiality of the approach,we consider in this case the unique event s stream generated by the ais receiver;
correlationbetween events referringthe same vessel is under the responsibility of
the frameworkitself, using the formalization discussed in sec. 5. figure 5b shows
a graphical representation of the constr aints’ evolution. events (with attached
data and timestamps) are displayed on the horizontal axis. the vertical axisshowsthe constraintsand theirinstances, reportingtheirevolutionastime ﬂows.
every time event mooredoccurs, a new instance of the response constraint
(for the speciﬁc vessel type) is create d. at ﬁrst, the state of the instance is
pending because it is waiting for the occurrence of an ( under way using )engine
event referring to the same vessel id, and within the deadline speciﬁc for the
corresponding vessel type. event engineoccurs for passenger ship v1 less than
6 hours after moored.f o r v4this takes more than 6 hours, thus resulting in a
violation.similartothe exampleusedforthemobuconltlprovider,alsoin thiscase, the occurrence of sailingforsailing boat v2 generates a conﬂict between
the instance of the response constraint and the instance of the not coexistence
constraint corresponding to this vessel. they can never become both satisﬁed,
the ﬁrst requiring and the other forbidding the presence of event enginefor this
vessel. however, unlike the ltl-based provider, the mobucon ec provider does
not point out any problem when the conﬂict arises. only when, as the last event
of the trace, engineoccurs for v2, the instance of the not coexistence constraint
for vessel v2becomes violated. this example shows that, on the one hand,
the mobucon ec provider is able to monitor constraints augmented with data
conditions and metric temporal constraints. on the other hand, the mobucon
ltlprovidersupportstheearlydetectionofviolationsoriginatingfromaconﬂictamong two or more constraints.
as explained in sect. 3.3, the compliance indicator is computed diﬀerently in
both providers. for both providers the i ndicator decreases aft er each violation.
however, in ec-based provider, the compliance indicator increases when new
satisﬁed instan ces are created.an operational decision support framework 159
table 1. comparison between the mobucon ltl and ec providers (i = imple-
mented, i* = partially implemented, + = supported by the formal framework, –
= not supported by the formal framework)
ltl ec ltl ec
1. single constraints monitoring i i 5. recovery and compensation + +
2. non-local violations i* – 6. metric temporal aspects – i
3. continuous support i i 7. data and data-aware conditions – i*
4. diagnostics i – 8. non-atomic activities – +
7 discussion and conclusion
this paper presents a new operational decision support (os) framework for
monitoring business constraints. the framework implementation exploits the
functionalities provided by the os service in prom. mobucon comes with a
general ﬂexible architecture able to accommodate multiple reasoning engines. in
this paper, we demonstrate two such engines, one based on (ﬁnite-trace) linear
temporal logic (ltl) and automata, and the other on the eventcalculus (ec)
and a prolog-based reactive reasoner.
in the literature, most of the proposed approaches for compliance veriﬁcation
either work onstatic models at designtime [15,16] or on oﬀ-line a-posterioricon-
formance checking [17] using only historical data. the majority of approaches
foronlinebusiness process monitoring focus on measuring numerical attributes,
such as key performance indicators (kpis). for example, in [18], a framework is
introduced for modeling and monitoring of kpis in semantic business process
management. in particular, the authors integrate the kpi management into a
semantic business process lifecycle, cr eating an ontology that is used by busi-
ness analysts to deﬁne kpis based on ontology concepts. in [19], an integrated
framework is presented for run-time monitoring and analysis of the performance
of ws-bpel processes. in particular, this framework allows for dependency
analysis and machine learning with the ultimate goal of discovering the main
factors inﬂuencing process performance (kpi adherence).
an exception to this trend is the work by ly et al. on semantic constraints
in business processes [20]. this work is more related the one presented here.
both approaches recognize the importance of runtime compliance veriﬁcation of
processes with rules and constraints. h owever, while ly et al. aims to describe a
comprehensive framework for compliance of semantic constraints over the whole
processlifecycle, here we haveproposed concretewaysfor attackingthis problem
during the execution of processes.
table 1 provides a comparison of our two os providers for monitoring busi-
ness constraints (ltl-based and ec based). analysis of this table providessome
interestinginsights.firstofall,both approachesareabletomanagethe monitor-
ing of individual business constraints. non-local violations refer to the situation
in which no single constraint is currently violated, but there is a conﬂicting set of
constraints. whereas the ltl-based approach can discover non-local violations
thanks to the constructionof theglobalautomaton,the ec-basedapproachdoes160 f.m. maggi, m. montali, and w.m.p. van der aalst
not support this. note that the detection of non-local violations is currently only
partially supported by the mobucon ltl provider: the non-local violations isdetected, but the minimal conﬂicting set is not yet computed eﬃciently. we are
currently working on extending the colored-automata based approach to more
eﬃciently identify minimal sets of conﬂicting constraints [21]. both approachessupport continuous support, i.e., the monitoring framework is able to provide
support even after a violation takes place. while the mobucon ec provider is
only able to detect that a violation has taken place, mobucon ltl also provides
diagnostics about which events were exp ected (not) to occur. although recovery
and compensation mechanisms have not yet been included in our implementa-tion, both approaches can support them [9,22].
the last three rows in tab. 1 refer to the extension of the declarelanguage.
metric temporal aspects have been already incorporated into the mobucon ecprovider [8]. metric temporal logics and timed-automata will be investigated to
improve the ltl-based approach in this direction. data and data-aware con-
ditions are not-expressible in ltl, while the ec-based tool is being extendedto accommodate them. its ability to support data is attested by the formaliza-
tion example shown in sec. 5 and fig. 5b. similarly, ec is also able to support
non-atomic activities.
finally, let us brieﬂy comment on the performance of the two approaches.
for the mobucon ltl provider, a recent investigation has revealed that veryeﬃcient algorithms can be devised for building local and global automata [11].
once the automata are constructed, runtime monitoring can be supported in an
eﬃcient manner. the state of an instance can be monitored in constant time, in-
dependent of the number of constraints and their complexity. according to [11],
the time to construct an automaton is 5-10 seconds for random models with
30-50 constraints. for models larger than this, automata can no longer routinely
be constructed due to lack of memory, even on machines with 4-8 gib ram.
for the mobucon ec provider, some complexity results are inherited from theseminal investigation by chittaro and montanari [13]. an initial investigation of
the performance of this approach (with yap prolog as underlying reasoner) can
be found in [8]. diﬀerently from the ltl-based approach, whose most resource-consuming task is the generation of the automaton, which is done before the
execution, the ec-based approach triggers a reasoning phase every time a new
event is acquired. despite this, our inves tigationshows that, for randomly gener-
ated models and traces, the reasoner takes an average time of 300ms to process
the 1000th acquired event with a model containing 100 constraints.
references
1. van der aalst, w.m.p., pesic, m., song, m.: beyond process mining: from the
past to present and future. in: pernici, b. (ed.) caise 2010. lncs, vol. 6051,
pp. 38–52. springer, heidelberg (2010)
2. verbeek, e., buijs, j., van dongen, b., van der aalst, w.: prom 6: the process
mining toolkit. in: demo at bpm 2010 (2010)an operational decision support framework 161
3. westergaard, m., maggi, f.m.: modeling and veriﬁcation of a protocol for opera-
tional support using coloured petri nets. in: kristensen, l.m., petrucci, l. (eds.)
petri nets 2011. lncs, vol. 6709, pp. 169–188. springer, heidelberg (2011)
4. pesic, m., schonenberg, h., van der aalst, w.: declare: full support for
loosely-structured processes. in: edoc 2007, pp. 287–300 (2007)
5. pesic, m., van der aalst, w.m.p.: a declarative approach for flexible business
processes management. in: eder, j., dustdar, s. (eds.) bpm workshops 2006.
lncs, vol. 4103, pp. 169–180. springer, heidelberg (2006)
6. montali, m., pesic, m., van der aalst, w.m.p., chesani, f., mello, p., storari, s.:
declarative speciﬁcation and veriﬁcation of service choreographies. acm trans-
actions on the web 4(1) (2010)
7. montali, m.: speciﬁcation andveriﬁcation of declarative openinteraction models.
lnbip, vol. 56. springer, heidelberg (2010)
8. montali, m., maggi, f., chesani, f., mello, p., van der aalst, w.: monitoring
business constraints with the event calculus. technical report deis-lia-002-11, university of bologna (italy) (2011), lia series no. 97,
http://www.lia.deis.unibo.it/research/techreport/lia-002-11.pdf
9. maggi, f.m., montali, m., westergaard, m., van der aalst, w.m.p.: monitoring
business constraints with linear temporal logic: an approach based on colored
automata. in: rinderle-ma, s., toumani, f., wolf, k. (eds.) bpm 2011. lncs,
vol. 6896, pp. 132–147. springer, heidelberg (2011)
10. giannakopoulou, d., havelund, k.: automata-based veriﬁcation of temporal
properties on r unning programs. in : ase 2001, pp.412–416 (2001)
11. westergaard, m.: better algorithms for analyzing andenacting declarative work-
ﬂow languages using ltl. in: rinderle-ma, s., toumani, f., wolf, k. (eds.) bpm
2011. lncs, vol. 6896, pp. 83–98. springer, heidelberg (2011)
12. shanahan, m.: the event calculus explained. in: artiﬁcial intelligence today:
recent trends and developments, pp. 409–430 (1999)
13. chittaro, l., montanari, a.: eﬃcient temporal reasoning in the cached event
calculus. computational intelligence 12, 359–382 (1996)
14. international telecommunications union: technical characteristics for a universal
shipborne automatic identiﬁcation system using time division multiple access in
the vhf maritime mobile band. recommendation itu-r m.1371-1 (2001)
15. governatori, g., milosevic, z., sadiq, s.w.: compliance checking between busi-
ness processes and business contracts. in: edoc 2006, pp. 221–232 (2006)
16. awad, a., decker, g., weske, m.: eﬃcient compliance checking using bpmn-q
and temporal logic. in: dumas, m., reichert, m., shan, m.-c. (eds.) bpm 2008.lncs, vol. 5240, pp. 326–341. springer, heidelberg (2008)
17. van der aalst, w.m.p., de beer, h.t., van dongen, b.f.: process mining and
veriﬁcation of properties: an approach based on temporal logic. in: meersman,r., tari, z. (eds.) coopis/doa/odbase 2005. lncs, vol. 3760, pp. 130–147.
springer, heidelberg (2005)
18. wetzstein,b.,ma,z.,leymann,f.:towardsmeasuringkeyperformanceindicators
of semantic business processes. in: bis 2008, pp. 227–238 (2008)
19. wetzstein, b., leitner, p., rosenberg, f., brandic, i., dustdar, s., leymann, f.:
monitoring and analyzing inﬂuential factors of business process performance. in:edoc 2009, pp. 141–150 (2009)162 f.m. maggi, m. montali, and w.m.p. van der aalst
20. ly, l.t., g¨ oser, k., rinderle-ma, s., dadam, p.: compliance of semantic con-
straints - a requirements analysis for process management systems. in: grcis
2008 (2008)
21. maggi, f.m., westergaard, m., montali, m., van der aalst, w.m.p.: runtime ver-
iﬁcation of ltl-based declarative process models. in: khurshid, s., sen, k. (eds.)
rv 2011. lncs, vol. 7186, pp. 131–146. springer, heidelberg (2012)
22. chesani, f., mello, p., montali, m., torroni, p.: veriﬁcation of choreographies
during execution using the reactive event calculus. in: bruni, r., wolf, k. (eds.)
ws-fm 2008. lncs, vol. 5387, pp. 55–72. springer, heidelberg (2009)