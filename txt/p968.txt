process discovery from event data: relating models
and logs through abstractions
wil m.p. van der aalst
article type
overview article
abstract
event data are collected in logistics, manufacturing, nance, healthcare, customer
relationship management, e-learning, e-government, and many other domains. the events
found in these domains typically refer to activities executed by resources at particular
times and for a particular case (i.e., process instances). process mining techniques are able
to exploit such data. in this article, we focus on process discovery . however, process
mining also includes conformance checking, performance analysis, decision mining,
organizational mining, predictions, recommendations, etc. these techniques help to
diagnose problems and improve processes. all process mining techniques involve both
event data and process models. therefore, a typical rst step is to automatically learn a
control-ow model from the event data. this is very challenging, but in recent years many
powerful discovery techniques have been developed. it is not easy to compare these
techniques since they use dierent representations and make dierent assumptions. users
often need to resort to trying dierent algorithms in an ad-hoc manner. developers of new
techniques are often trying to solve specic instances of a more general problem. therefore,
we aim to unify existing approaches by focusing on log and model abstractions . these
abstractions link observed and modeled behavior: concrete behaviors recorded in event
logs are related to possible behaviors represented by process models. hence, such
behavioral abstractions provide an \interface" between both. we discuss four discovery
approaches involving three abstractions and dierent types of process models (petri nets,
block-structured models, and declarative models). the goal is to provide a comprehensive
understanding of process discovery and show how to develop new techniques. examples
illustrate the dierent approaches and pointers to software are given. the discussion on
abstractions and process representations is also used to reect on the gap between process
mining literature and commercial process mining tools. this facilitates users to select an
appropriate process discovery technique. moreover, structuring the role of internal
abstractions and representations helps to broaden the view and facilitates the creation of
new discovery approaches.
process and data science (pads), rwth aachen university, aachen, germany
1introduction
mainstream data mining and knowledge discovery research and tool development has largely
ignored \processes" as people working in logistics, manufacturing, nance, healthcare, cus-
tomer relationship management, etc. understand them. when trying to improve processes,
people in these domains immediately start drawing process models using \boxes and arrows",
but these are rarely connected to the underlying data. process mining aims to bridge the
gap between process models and event data.2the confrontation between observed behavior
in the form of events and modeled behavior in the form of process diagrams helps to diagnose
performance and compliance problems.
surprisingly, process mining did not emerge from data mining, machine learning, or
knowledge discovery communities. the roots of process mining lie in the business process
management (bpm) discipline.1,24,57here, process mining was introduced as a way to in-
fer workows and eectively use the audit trails present in modern information systems.
the increased interest in process mining illustrates that bpm is rapidly becoming more
data-driven. evidence-based bpm powered by process mining helps to create a common
ground for business process improvement and information systems development. the up-
take of process mining is reected by the growing number of commercial process mining tools
available today. there are over 25 commercial products supporting process mining (celonis,
disco, minit, myinvenio, processgold, qpr, etc.).2all support process discovery and can
be used to improve compliance and performance issues. for example, without any modeling,
it is possible to learn process models clearly showing the main bottlenecks and deviating
behaviors.
this article focuses on process discovery , probably the most challenging process mining
task. input for process mining is an event log . as shown in figure 1, an event log \views"
a process from a particular angle (see the dashed line). each event in the log refers to (1) a
particular process instance (called case), (2) an activity , and (3) a timestamp . there may be
additional event attributes referring to resources, people, costs, etc., but these are optional.
given a collection of events, several complementary event logs may be possible. one can
change scope or change the case notion, resulting in another view (materialized in the form
2of an alternative event log).
conformance 
checkingprocess 
discovery
process 
reengineering
operational 
support event 
logprocess 
model 
pmgenerates describes, 
guides, and /or 
controls 
log abstraction model abstractionhas 
abstractionhas 
abstraction
set thresholds ml2la 
mla2ma mpm2ma reality
log 01
00
11
10
01
00
11
01
01
10
figure 1: overview positioning the dierent types of process mining and the role of log
abstractions and model abstractions.
once a process model has been discovered from an event log it can be used for dierent
purposes, e.g., performance analysis, compliance checking, predictive analytics, etc. figure 1
shows four main types of process mining: (1) process discovery, (2) conformance checking,
(3) process reengineering, and (4) operational support. these will be elaborated later.
to provide an overview of process discovery techniques, we focus on the role of abstrac-
tions . as shown in figure 1 log abstractions and model abstractions link observed and
modeled behavior. a log abstraction characterizes the concrete behavior found in the event
log. a model abstraction characterizes the possible behavior allowed by the process model.
these two abstractions help to unify the dierent types of behavior. very dierent types of
abstractions are possible (e.g., directly-follows graphs, transition systems, and constraints),
3but they all characterize behavior.
this article rst provides a short introduction to the dierent types of process mining,
before limiting the scope to process discovery. rather than presenting one specic discovery
technique in detail or providing a survey, this article aims to unify several process discovery
techniques. this will not cover all process discovery approaches, but is general enough to
cover most. this approach allows us to discuss general principles without focusing on a
particular algorithm. towards the end of this article we will use these insights to discuss
the gap between the process discovery algorithms used in commercial tools and the algo-
rithms described in process mining literature. the former use informal models (often ltered
directly-follows graphs) whereas the latter use formal models aimed at formally describing a
set of possible traces.
process mining: an overview
in recent years, process mining emerged as a new scientic discipline linking process science
to data science.2process mining is both data-driven and process-centric . progress in this
young scientic discipline has been remarkable and this resulted in powerful techniques that
are highly scalable. moreover, process mining tools are increasingly used in practice. there
are over 25 commercial tools supporting process mining. examples include: disco (flux-
icon), celonis process mining (celonis), processgold enterprise platform (processgold),
qpr processanalyzer (qpr), snp business process analysis (snp ag), minit (gradient
ecm), myinvenio (cognitive technology), perceptive processing mining (lexmark).2see
the website of the ieee task force on process mining for examples of successful case stud-
ies.49for example, within siemens there are currently over 2,500 active users of celonis
process mining . siemens reported savings of \double-digit millions euros" as a result of the
worldwide application of process mining.18the commercial tools and case studies illustrate
the adoption and relevance of process mining.
in the academic world, prom is the de-facto standard ( www.processmining.org ) and
research groups all over the world have contributed to the hundreds of prom plug-ins avail-
able. the current version of prom provides over 1500 plug-ins. a plug-in may provide a
4(a) visual inductive miner (prom ) showing a process tree
(b) ilp miner (prom ) showing a petri net (c) heuristic miner (prom ) showing a c -net 
(d) disco (fluxicon ) showing a directly follows graph (e) celonis showing a directly follows graph
figure 2: screenshots of ve dierent process mining tools.
concrete discovery approach or another piece of functionality to support a process mining
task. the broad spectrum of prom plug-ins shows that process mining is not limited to
process discovery.
figure 2 shows the output of ve dierent mining tools applied to the same event log
containing 121,218 events related to 12,666 cases (customer orders). the rst three screen-
shots show output generated by prom plug-ins. figure 2(a) shows process tree (visualized in
a bpmn-like representation) learned using an inductive mining algorithm.30{34figure 2(b)
shows a petri net learned using an approach based on language-based regions.14,56figure 2(c)
shows a causal net (c-net) learned using a variant of the heuristic mining technique.39,52
5figure 2(d) shows a screenshot of disco. the process model is a directly-follows graph and
the numbers indicate frequencies. figure 2(e) shows another directly-follows graph, but now
generated by celonis process mining. the annotations indicate delays. these examples
show that dierent process mining tools may return very dierent process models using a
variety of representations.
a brief history of process mining
process discovery has its roots in various established scientic disciplines such as concurrency
theory, inductive inference, stochastics, data mining, machine learning and computational
intelligence. it is impossible to give a complete overview here. currently there are probably
hundreds of process discovery techniques, some of which are discussed later. here we put
these approaches in a historical context.
in 1967 mark gold showed in his seminal paper \language identication in limit" that
even regular languages cannot be exactly identied from positive examples only.26many
inductive inference problems have been studied since gold's paper.12,15before the paper of
gold, there were already techniques to construct a nite state machine from a nite set of
example traces. it is trivial to construct a nite state machine where the states are described
by prexes of observed traces and transitions move from one state to another by adding an
activity to the prex. such a nite state machine can be made smaller by using the classical
myhill-nerode theorem.44state are equivalent if their \sets of possible futures" coincide
and can be merged. these classical approaches do not consider concurrency, noise, and
incompleteness. therefore, they cannot be used for process discovery in real-life settings
based on variable example behavior.
various data mining algorithms have been developed to nd frequent patterns in large
datasets.28,40,48however, none of these techniques aimed at discovering end-to-end processes.
more related is the work on hidden markov models11. here end-to-end processes can be con-
sidered. however, these models are sequential and cannot be easily converted into readable
business process models.
in the second half of the 1990s, cook and wolf developed process discovery techniques in
6the context of software engineering processes.21in 1998 two papers appeared that, indepen-
dently of one another, proposed to apply process discovery in the context of business process
management.10,23all of these approaches produced sequential models and were based on
classical approaches to learn nite state machines or hidden markov models.
joachim herbst aimed at the discovery of more complicated process models at a very early
stage.29however, it was the -algorithm that rst took concurrency as a starting point and
not as an afterthought or post-optimization.9similar ideas were used in the heuristic miner
that was rened over time.52many algorithms followed.
over the last two decades hundreds of process discovery techniques have been proposed.
many of the initial techniques could not cope with infrequent behavior and made very strong
assumptions about the completeness of the event log. for example, traditional region-based
techniques assume that all behavior possible has been observed and that all behavior observed
is equally important. state-based regions were introduced by ehrenfeucht and rozenberg in
1989 and generalized by cortadella et al.22,25various authors used state-based regions for
process discovery.8,47also language-based regions have been used for this purpose.14,56
over time attention shifted to approaches able to deal with noise and infrequent behavior.
early approaches include heuristic mining, fuzzy mining, and various genetic process mining
approaches.27,52
since 2010 the speed at which new process discovery techniques are proposed is acceler-
ating. as an example consider the family of inductive mining techniques.31{33. all of these
discovery techniques ( im,imf,imc,imd,imfd ,imcd , etc.) produce sound models and
are highly scalable. moreover, these algorithms come with formal correctness guarantees.
for example, the imalgorithm is tness-preserving and for particular classes of models even
rediscoverability is guaranteed. note that these are just examples of techniques as the goal
is not to provide a complete survey of all approaches.
the focus of this article is on process discovery. however, the process mining discipline
is much broader and includes topics such as conformance checking, bottleneck analysis,
predictive process analytics, etc.2from a historic point of view the phd thesis of anne
rozinat is important.46. she was the rst of work on conformance checking and decision
point analysis. using her software, dierent perspectives could be discovered and merged
7into a single process model. as a result process mining could be combined with simulation
and techniques for operational support (e.g., prediction of remaining processing times) could
be developed.2
until 2010 there were only a few commercial process mining tools (futura reect by
futura process intelligence, disco by fluxicon, and interstage automated business process
discovery by fujitsu were notable exceptions). since 2010 there has been a rapid increase
in the number of tools and their maturity. for example, celonis process mining (celonis)
was introduced in 2011, minit (gradient ecm) was introduced in 2014, and processgold
enterprise platform (processgold) was introduced in 2016. currently, there are over 25
commercial tools available. these tools can easily deal with event logs having millions of
events.
four types of process mining
as mentioned earlier, the process mining spectrum is quite broad and in this article we focus
on process discovery. however, to describe the spectrum we group process mining techniques
into the four types depicted in figure 3. process mining typically involves both an event log
(i.e., observed behavior) and a process model (i.e., described or prescribed behavior). this
naturally leads to the following four types of process mining.
process discovery : learning process models from event data. a discovery technique
takes an event log and produces a process model without using additional information.
an example is the -algorithm which takes an event log and produces a petri net
explaining the behavior recorded in the log.9
conformance checking : detecting and diagnosing both dierences and commonalities
between an event log and a process model.3conformance checking can be used to
check if reality, as recorded in the log, conforms to the model and vice versa. the
process model used as input may be descriptive or normative. moreover, the process
model may have been made by hand or learned using process discovery.
process reengineering : improving or extending the model based on event data. like
8for conformance checking, both an event log and a process model are used as input.
however, now the goal is not to diagnose dierences. the goal is to change the process
model. for example, it is possible to \repair" the model to better reect reality. it
is also possible to enrich an existing process model with additional perspectives. for
example, replay techniques can be used to show bottlenecks or resource usage.2process
reengineering yields updated models. these models can be used to improve the actual
processes.
operational support : directly inuencing the process by providing warnings, predic-
tions, and/or recommendations.2conformance checking can be done \on-the-y" al-
lowing people to act the moment things deviate. based on the model and event data
related to running process instances, one can predict the remaining ow time, the
likelihood of meeting the legal deadline, the associated costs, the probability that a
case will be rejected, etc. the process is not improved by changing the model, but
by directly providing data-driven support in the form of warnings, predictions, and/or
recommendations.
conformance 
checkingprocess 
discoveryprocess 
reengineering
operational 
support event 
logprocess 
model event 
logprocess 
model 
event 
logprocess 
model process 
model event 
loglearn a process model 
based on event data 
compare observed 
behavior and modeled 
behavior provide warnings, predictions, 
and/or recommendations improve or extend the process 
model based on event data 
figure 3: the four basic types of process mining: (1) process discovery, (2) conformance
checking, (3) process reengineering (changing the process model), and (4) operational support
(inuencing the process without reengineering it).
next to the four types of process mining there are two additional dimensions that can
be used to structure the process mining spectrum (see figure 4). any process model makes
statements about the control-ow . the control-ow perspective focuses on the ordering of
9activities, i.e., a characterization of all possible sequences of activities. however, next to the
control-ow perspective, one or more additional perspectives may be included.2
the time perspective is concerned with the timing and frequency of events. when
events bear timestamps it is possible to discover bottlenecks, measure service levels,
monitor the utilization of resources, and predict the remaining processing time of
running cases.
the data and decision perspective focuses on the properties of cases and how these
inuence behavior. for example, if a case represents a replenishment order, it may
be interesting to know the supplier or the number of products ordered. attributes of
events and cases may inuence decisions. therefore, one can learn decision rules and
add these to the process model. for example, replenishment orders of less than 15,500
euro tend to skip the pre-approval step.
the resource and organization perspective focuses on information about resources and
organizational entities available in the event log. this can be used to learn which
actors (e.g., people, systems, roles, and departments) are involved and how are they
related. the process model can be extended with role information, work distribution
rules, etc.
many other perspectives can be added. for example, cost information or information
about risks, energy consumption, condentiality, etc.
as figure 4 shows that we can also distinguish between online and oine process mining.
oine process-mining techniques work on historic event data and tend to be used to analyze
only events that belong to cases that have already completed. such techniques are typically
\backward looking". the goal is to improve the process and not to act immediately. online
process mining techniques may work on streaming event data or databases that are contin-
uously updated. these techniques are typically \forward looking" and deal with cases that
are still running. this enables online process mining to inuence these running cases with-
out changing the process. clearly, operational support (the fourth type of process mining in
10control-flowtime 
data / decisions
resources / org .
costs
... online
(forward looking, dealing 
with cases that are still 
running)
offline
(backward looking, dealing 
with cases have finished)figure 4: the control-ow perspective is the basis for the other process perspectives (left).
independent of the perspectives included, process mining techniques can be used in online
and oine settings (right).
figure 3) requires an online setting. however, models learned oine may serve as input for
the online setting.
figures 3 and 4 show three mostly orthogonal dimensions: (1) type of process mining, (2)
the perspectives covered (next to control-ow), and (3) online versus oine. these illustrate
the breadth of the process mining as a discipline. in the remainder, we focus on process
discovery while limiting ourselves to control-ow and the oine setting . this capability is
the starting point for any form of process mining. the control-ow representation is the
backbone of any process model and techniques for online process mining are often based on
oine techniques.
process discovery through abstractions
rather than giving an overview of process discovery techniques or zooming in on a particular
technique, we try to unify the lion's share of existing approaches by using the notion of log
and model abstractions. figure 1 already showed the way in which abstractions are used.
a process discovery algorithm typically builds an abstraction based on the event log using
some log abstraction function ml2la. an event log corresponds to multiset of traces when
focusing on the control-ow perspective. there is one trace for each case, but dierent cases
may follow the same path. a process model describes a set of traces. hence, both event log
and model refer to (multi)sets of traces. the log abstraction function ml2la used to nd log
11abstractions can be modied to provide model abstractions yielding the model abstraction
functionmpm2ma . however, there are dierences. the log abstraction function needs to deal
with the fact that traces may have dierent multiplicities (e.g., trace ha;b;c;b;dimay occur
twelve times in a log). the model abstraction function needs to deal with the fact there may
be innitely many traces (e.g., due to loops). the two abstractions need to bridge the gap.
note that the log contains only example behavior. on the one hand, the log may contain
exceptional behaviors that do not need to be allowed by the model. on the other hand, in
most cases the log contains only a small fraction of all possible behaviors. hence, one cannot
assume that all possible behaviors have been witnessed. for example, in case of loops there
may be innitely many possible traces. the abstractions help to bridge such dierences. for
example, the abstraction may be robust with respect to loops and concurrency and not all
possibilities need to be witnessed. function mla2ma may help to bridge further dierences,
e.g., using frequency based ltering.
note thatml2la andmpm2ma are functions, i.e., for each log or model there is precisely
one abstraction. however, these functions do not need to be injective. multiple logs and
multiple models may be mapped onto exactly the same abstraction. hence, if we take an
abstraction and apply mpm2ma in reverse direction there may be multiple candidate models.
depending on the class of process models considered, it could even be that exists no model
that has such an abstraction. we will elaborate on this later. however, to sketch the overall
approach assume that mpm2ma 1(i.e., the inverse of mpm2ma ) yields a canonical process
model. given this assumption mpm2ma 1(mla2ma (ml2la(l))) returns a process model for
some event log l. this path is visualized at the bottom of figure 1.
many discovery approaches are of the form mpm2ma 1(mla2ma (ml2la(l))), but may
use very dierent abstractions. later we will give several examples, but rst we need to
introduce basic concepts such as event logs and process models.
event data
we distinguish between event collections andevent logs . to conduct process mining we need
to have an event log where each event refers to (1) a particular process instance (called case),
12(2) an activity , and (3) a timestamp . the available event collection needs to be preprocessed
to create an event log corresponding to the process (i.e., \viewpoint") to be studied. for
example, the collection of events needs to be scoped and a suitable case notion has to be
chosen. this corresponds to the view in figure 1.
preliminaries
before dening event data and event logs, we rst introduce some preliminaries used in the
remainder.
=ha1;a2;:::;ani2adenotes a sequence over a.(i) =aidenotes the i-th element
of the sequence, i.e., can be viewed as a function mapping positions onto element values.
jj=nis the length of and dom() =f1;:::;jjgis the domain of .hiis the empty
sequence, i.e.,jhij= 0 and dom(hi) =;.12is the concatenation of two sequences.
b(a) is the set of all multisets over some set a. for some multiset x2b(a),x(a)
denotes the number of times element a2aappears in x. some examples: x= [ ],
y= [x;x;y ], andz= [x3;y2;z] are multisets over a=fx;y;zg.xis the empty multiset,
yhas three elements ( y(x) = 2,y(y) = 1, and y(z) = 0), and zhas six elements. note
that the ordering of elements is irrelevant.
p(a) is the powerset of a, i.e., all of its subsets. x2p(a) if and only if xa. for
example,p(fa;bg) =f;;fag;fbg;fa;bgg.
f2a!bis a total function mapping elements of aonto elements of b.f2a6!bis
a partial functions with domain dom(f)a, i.e.,f(a) is dened if and only if a2dom(f).
partial functions can be applied to sequences. if dom(f) =fa;bg,f(a) =x, andf(b) =y,
thenf(ha;b;c;a;ci) =hx;y;xi.
letabe a set and xaone of its subsets. x2a!xis a projection function and
is dened recursively: hix=hiand for2aanda2a: (hai)x=xifa62xand
(hai)x=haixifa2x. for example,ha;b;aifa;cg=ha;ai. projection can also be
applied to multisets of sequences, e.g., [ ha;b;ai5;ha;d;ai5;ha;c;ei3]fa;cg= [ha;ai10;ha;ci3].
13event collections
an event log can be described as a particular view on an event collection. unlike an event
log, an event collection does not have a xed case notion.
denition 1 (event collection) letebe the universe of event identiers, uattbe the
universe of attribute names, and uvalthe set of attribute names. ec = (e;att;)with
ee, attu att, and2e!(att6!u val)is an event collection. event e2ehas
attributes dom ((e)). fora2dom((e)):(e)(a)is the value of attribute afor evente.
we distinguish the following types of attributes:
identier : the attribute value refers to a particular object (e.g., a customer, a patient,
an order, a request, a machine, a room, or a software component). one can only test
equality on such attribute values. if xandyare identier values, then x=yand
x6=yare dened, but x>y ,x<y ,x+y,x y, etc. have no meaning. note that an
identier may be represented by a number, but is does not make any sense to add or
multiply two identiers.
class : the attribute value refers to a category or concept (e.g., an activity name, a
status, or a type). one can only test equality on such attribute values and sometimes
they are ordered (e.g., high, medium, or low).
time : the attribute value refers to a particular point in time. this includes absolute
and relative timestamps and calendar dates. examples of time attribute values are
2017-07-16t19:55:30+01:00 ,2017-07-16 , and 19:55:30 . operations such as x=y,
x6=y,x>y ,x<y , are dened. one can also add durations, e.g., add a delay of two
days.
numerical : the attribute value represents some kind of measurement. x=y,x6=y,
x>y ,x<y ,x+y,x y, etc. are all dened. the values may be discrete or continuous
and may be bounded or not.
other : the attribute value does not fall in one of the above categories and may have
more structure (lists, tables, etc.).
14extracting event logs
starting point for process discovery is an event log where events are grouped into cases.
events logs can be extracted from event collections by choosing a particular view, i.e., se-
lecting events and mapping attributes. each case in an event log lis represented by a trace,
e.g.,h.;a;b;c;d; i2l.
denition 2 (event log) anevent logl2b(a)is a non-empty multiset of traces over
some activity set a. a trace2lis a sequence of activities. there is a special start activity
.and a special end activity . we require that f.;gaand each trace 2lhas the
structure=h.;a1;a2;:::;an;iandf.;g\fa1;a2;:::;ang=;.ulis the set of all event
logs satisfying these requirements.
an event log captures the observed behavior that is used to learn a process model. an
example log is l1= [h.;a;b;c;d; i45;h.;a;c;b;d; i35;h.;a;e;d; i20] containing 100 traces
and 580 events. act(l) =s
2lfa2gais the set of activities appearing in event log
l. for example, act(l1) =f.;a;b;c;d;e; g.
the assumption that each trace in an event log starts with .and ends with is not
limiting because we can always add such events articially. however, for process discovery
it is helpful to have a unique start and a unique end.
in reality, each event has a timestamp and may have any number of additional attributes.
for example, an event may refer to a customer, a product, the person executing the event,
associated costs, etc. here, we abstract from these notions and simply represent an event by
its activity name.
how to get from the event collection ec= (e;att;) (denition 1) to an event log
l2b(a)? this requires the selection of subsets of events in e1;e2;:::;ene. this way
it is possible to scope the process. events in en(e1[e2[:::[en) are discarded. per
subseteithere needs to be a mapping relating the set of attribute names in ato process
mining concepts such as case, activity, timestamp, etc. we allow for multiple subsets of
events ine1;e2;:::;eneach having a separate mapping, because not all events need to
have the same set of attributes. the event sets may be overlapping (e.g., when events in the
event collection have multiple timestamp attributes).
15event collectionidentifier 
attributescase (m)
activity (m)
typetimestamp (m)
resource
role
costs
othersubcase
activity instanceevent logclass
attributes
time
attributes
numerical 
attributes
other
attributesfigure 5: extracting an event log (right) from a collection of events (left). each event in an
event log has a case, activity, and timestamp.
figure 5 illustrates such mappings. technically, there are mappings m1;m2;:::mk2
fcase;activity;timestamp;:::g6! attsuch thatfcase;activity;timestampgdom(mi). for
example, the case of an event e2eiis determined by the (e)(mi(case)) value, the times-
tamp ofeis(e)(mi(timestamp )), etc. events in eiare only included if the mandatory
attributes ( dom(mi)) are dened. each pair ( ei;mi) yields a set of events having a case,
activity, and timestamp. these together form the event log.
inl2b(a) we abstract from the actual timestamp and case of an event. events
corresponding to the same case form a sequence of activities. the case attribute is used to
group cases and the timestamp attribute is used to order events. here we assume a total
order within each case. however, there are also process mining techniques that use partial
orders as input.
next to the three mandatory events attributed marked with an \m" in figure 5, there are
several other (optional) attributes that have a meaning that is specic for process mining.
type : to capture transactional information (e.g., start, complete, schedule, abort,
suspended, etc.).
subcase : to group events within and between cases (e.g., identifying dierent order
lines within an order). this can be used as a secondary case notion. it can be used to
separate causally unrelated events within a case (e.g., events related to dierent order
16lines within an order should not be related) or to establish links between cases (e.g.,
dierent orders grouped into a single payment or delivery).
activity instance : to relate events corresponding to the same activity execution (e.g.,
link events of type start to events of type complete ).
resource : to relate events to a specic resource (worker, machine, etc.).
role: to relate events to a collection of resources (e.g., an organizational unit or specic
qualications).
costs : to add cost information to events.
other : any other attribute that may be relevant for the execution of cases. for exam-
ple, attributes inuencing decisions or durations.
in the remainder we focus on the core discovery problem and assume an event log ab-
stracts from these additional attributes. however, it is good to understand that l2b(a)
provides a simplied viewpoint (on a much more complex reality that extends far beyond
this article).
process models
aformal process model is able to make rm statements about the inclusion or exclusion of
traces, e.g., trace h.;a;b;c;d; its the model or not. informal process models are unable to
make such precise statements about traces. here, we focus on formal process models. using
this assumption we can view process models as classiers for traces: a trace ts or not. this
leads to the following generic notion.
denition 3 (process model) aprocess model pm2p(a)corresponds to a set of
traces over some activity set a.
of course one does not model a process by simply enumerating all possible traces. mod-
eling languages aim to describe sets of traces in a compact and intuitive manner. in this
17article we consider three notations: petri nets, a particular form of structured process mod-
els (process trees), and a particular form of declarative process models (similar to declare).
these are described next.
petri nets
petri nets are probably the oldest and best investigated process modeling language allowing
for the modeling of concurrency. figure 6 shows an example model allowing for traces like
ha;b;c;di,ha;c;b;di,ha;b;c;e;f;c;b;di, etc.
ab
cd f
p1ep4 p2
p3 p5p7 p6 t1t2
t6
t3t5 t4
figure 6: a petri net with six transitions ft1;t2;:::;t 6gand seven placesfp1;p2;:::;p 7g.
the initial marking minit= [p1] is shown. mnal= [p7] is the nal marking.
a petri net is a bipartite graph composed of places (represented by circles) and transitions
(represented by squares).
denition 4 (petri net) a petri net is a tuple n= (p;t;f )withpthe set of places, t
the set of transitions, p\t=;,f(pt)[(tp)the ow relation. a labeled petri
netsn= (p;t;f;l;a )extends the petri nets with a labeling function l2t6!a.
transitions may represent activities. transitions without a label are called \silent". if
l(t) =a, thenais the observed activity when transition tis executed. for example, l(t1) =a,
l(t2) =b, etc. in figure 6. note that the labeling function in the example is total (no silent
transitions) and injective (no two transitions with the same label). places are added to
model causal relations. x=fyj(y;x)2fgandx=fyj(x;y)2fgdene input and
output sets of places and transitions.
18the state of a petri net, called marking , indicates how many tokens each place contains.
formally: marking mis a multiset of places, i.e., m2b(p). tokens are shown as block
dots inside places. figure 6 shows the initial marking [ p1].
a transition t2tisenabled in marking mof netn, denoted as ( n;m )[ti, if each of its
input places ( p2t) contains at least one token. an enabled transition tmay re, i.e., one
token is removed from each of the input places ( p2t) and one token is produced for each
of the output places ( p2t).
(n;m )[ti(n;m0) denotes that tis enabled in mand ringtresults in marking m0. let
=ht1;t2;:::;tni2tbe a sequence of transitions. ( n;m )[i(n;m0) denotes that there is
a set of markings m0;m1;:::;mnsuch thatm0=m,mn=m0, and (n;mi)[ti+1i(n;mi+1)
for 0i<n .
a system net has an initial and a nal marking. the behavior of a system net corresponds
to the visible behaviors of the set of all traces starting in the initial marking minitand ending
in the nal marking mnal. note that deadlocking or livelocking traces that do not reach
mnalare not part of the behavior.
denition 5 (system net behavior) a system net is a triplet sn = (n;m init;m nal)
wheren= (p;t;f;l;a )is a labeled petri net, minit2b(p)is the initial marking, and
mnal2b(p)is the nal marking. pm sn=fl()j2t^(n;m init)[i(n;m nal)gis
the set of traces possible according to the model.
in the preliminaries we explained that partial functions can be applied to sequences.
hence,l() yields a sequence of activities. transitions that are silent are skipped. visible
transitions are replaced by the corresponding activities.
for the system net in figure 6: pm sn=fha;b;c;di;ha;c;b;di;ha;b;c;e;f;b;c;di;ha;c;b;
e;f;b;c;di;:::ha;c;b;e;f;b;c;e;f;b;c;e;f;c;b;d i;:::g. note that a system net classies
tracesinto tting (2pm sn) and non-tting (62pm sn). hence, system nets pro-
vide a concrete language for the more abstract notion introduced in denition 3.
19structured process models
petri nets, wf-nets, bpmn models, epcs, and uml activity diagrams may suer from
deadlocks, livelocks, and other anomalies. models having undesirable properties independent
of the event log, are called unsound . in principle no mining technique should return an
unsound model. one can use relaxed soundness notions. for example, one can consider
pm2p(a) to be only the behavior that does not result in deadlocks. however, in some
cases discovered models may have no sound executions, i.e., pm =;. consequently, one
cannot interpret the model or assess its quality. moreover, users will have diculties to
discard deadlocking and livelocking behavior from a model.
structured process models, also referred to as block-structured models , are sound by con-
struction. in this article we use process trees as a notation to represent such block-structured
models. process trees are tailored towards process discovery. a process tree is a hierarchical
process model where the (inner) nodes are operators such as sequence and choice and the
leaves are activities. a range of inductive process discovery techniques exists for process
trees.30{33these techniques benet from the fact that the representation ensures soundness.
a d
bcef
figure 7: process tree !(a;	(^(b;c);!(e;f));d).
figure 7 shows a process tree that is behaviorally equivalent to the system net in figure 6.
the inner nodes of the process tree represent operators. the leaves represent activities.
there is one root node. there are four types of operators that can be used in a process tree:
!(sequential composition), (exclusive choice), ^(parallel composition), and 	(redo
20loop). the process tree in figure 7 can also be represented textually:
!(a;	(^(b;c);!(e;f));d)
the root node is a sequence operator stating that the process starts with activity aand ends
with activity d. in-between these two activities there is the subprocess 	(^(b;c);!(e;f)).
the redo loop starts with its leftmost child and may loop back through any of its other
children. in the subtree 	(^(b;c);!(e;f)), the leftmost child (\do part") is ^(b;c), i.e., the
parallel execution of bandc, and the rightmost child (\redo part") is !(e;f) modeling the
sequence of efollowed by f.
in this article, we do not provide formal denitions for process trees and their se-
mantics, but use some examples to explain the behaviors they represent. let pt 1=
^((a;b);c), i.e., a choice between aandbrunning in parallel with c. the correspond-
ing behavior is pm pt1=fha;ci;hb;ci;hc;ai;hc;big. ifpt 2=	(!(a;b);c), then pm pt2=
fha;bi;ha;b;c;a;bi;ha;b;c;a;b;c;a;bi;:::g.
the same activity may appear multiple times in the same process tree. for example,
process tree!(a;a;a ) models a sequence of three aactivities. from a behavioral point of
view!(a;a;a ) and^(a;a;a ) are indistinguishable. both have precisely one possible trace:
ha;a;ai. a silent activity is denoted by and cannot be observed. process tree (a;) can
be used to model an activity athat can be skipped. process tree 	(a;) can be used to
model the process that executes aat least once. the \redo" part is silent, so the process
can loop back without executing any activity. process tree 	(;a) models a process that
executesaany number of times. the \do" part is now silent and activity ais in the \redo"
part.
the mapping from process trees to behaviorally equivalent systems nets is easy. note
that this is possible because we use labeled petri nets. dierent transitions can have the
same label and we can add transitions that are not observable (these correspond to and can
be used to model choices in a block-structured manner). similar translations are possible to
bpmn models, epcs, and uml activity diagrams.
21declarative process models
declarative, constraint-based languages like declare7, start from an open-world assumption:
anything is possible unless there is a constraint explicitly forbidding it. declare has been
formalized in terms of linear temporal logic (ltl) over nite traces6, using abductive logic
programming42, event calculus43, regular expressions19, and colored automata38. here we
use a simpler approach based on the cardinality constraints shown in figure 8.
before ≥ 0 and after ≥ 1
before ≥ 0 and after = 1
before ≥ 0 and after = 00 and 
before ≥ 1 and after ≥ 0
before = 1 and after ≥ 0
before = 0 and after ≥ 0 and and and and  af 
and and and and and  af  af  af  af  af before + after ≥ 1
before = 0 and after = 0 0 and af 
(response)
(unary-response)
(non-response)(precedence)
(unary-precedence)
(non-precedence)(co-existence)
(non-coexistence)
figure 8: declarative notations: eight example constraints.
given some reference event ewe can reason about the events beforeeand the events after
e. we may require that the cardinality of the set of events corresponding to a particular
activity before or after the reference event lies within a particular range. the back dots in
figure 8 refer to reference events.
ab
cd f e
c1c2c3
c4
c5
c6c7
c12 c14 c13 c8
c9
c10 
c11 c15 
c16 
c17 
c18 c19 
c20 
figure 9: a declarative model.
rather than providing formal semantics, we explain the notation using an example.
constraint c1 in figure 9 models that every aevent should be preceded by precisely one start
event (.). traces likeh.;a;b;ci,h.;b;a;ci, andh.;a;a;cisatisfy this constraint. however,
traces likeha;b;ci,ha;.;b;ci, andh.;a;.;a;cido not. how to check this? each aappearing
22anywhere in the trace serves as a reference event. for each reference event we count the
number of b's before and after. this yields the numbers before and after mentioned in
figure 8. consider for example trace h.;a;.;a;ciand constraint c1. there are two reference
events (both a's). for the rst a:before = 1 and after = 1. this satises the constraint
before = 1 and after0, so the rst ameets the requirement. for the second a:before = 2
and after = 0. this violates the constraint, so the second reference event adoes not meet
the requirement.
constraint c2 in figure 9 states that every start event ( .) event should be followed by
precisely one aevent. constraint c3 states that every bevent should be preceded by precisely
oneaevent. constraint c4 states that every aevent should be followed by at least one b
event. etc.
given a declarative model dm,pm dmis the set of all traces that meet all constraints,
i.e., for each constraint and any of the corresponding reference events, the values before
and after need to be in the specied range. obviously, figure 9 allows for much more
behavior than the system net in figure 6 and process tree in figure 7. for example,
h.;a;b;c;b;c;d; i2 pm dm. declarative models are particular useful when allowing for
lots of exibility. however, such models become convoluted when trying to restrict the
behavior to a structured set of traces.
using abstractions
given an event log which provides a particular view on some collection of events, we would
like to discover a process model. as input we assume l2b(a), i.e., a non-empty multiset
of traces over some activity set a. the output is a process model, e.g., a system net or a
process tree, dening a set of traces pm2p(a). discovery approaches typically operate on
an abstraction of the event log as a means to relate observed behavior to modeled behavior.
figure 10 details the lower part of figure 1.
a log abstraction function ml2la maps an event log lonto a log abstraction ml2la(l)
(e.g., a weighted directly-follows graph). the log abstraction is converted into a model
abstraction using mla2ma . in this step one may use thresholds to remove exceptional be-
23process discoveryevent log process model 
pm
log abstraction model abstractionhas 
abstractionhas 
abstraction
set thresholds ml2la
mla2mampm2ma
log 01
00
11
10
01
00mpm2ma-1(mla2ma(ml2la(l)))figure 10: approach based on abstractions.
havior or \massage" the log abstraction in some other way. given a model abstraction
mla2ma (ml2la(l)), we are interested in all models that are mapped onto this abstraction
using model abstraction function mpm2ma . obviously, here may be multiple models having
the same abstraction. however, depending on the abstraction used, it could also be that
there are no process models having the model abstraction mla2ma (ml2la(l)). this is ulti-
mately determined by the representational bias of the modeling language used. we would
like to use the inverse of mpm2ma . however, mpm2ma 1corresponds to a possibly non-empty
set of process models. this can be resolved in the following way. one can assume a canonical
process model given some abstraction. if there is no corresponding model, one can always
use a fall-through resulting in a very general model, e.g., the model which allows for any
behavior over some activity set a. if we assume that mpm2ma 1returns the canonical pro-
cess model for the abstraction used as input, then mpm2ma 1(mla2ma (ml2la(l))) turns an
event log into a process model. this is shown in figure 10.
in principle any abstraction can be used. however, in the remainder we show three char-
acteristic abstractions: directly-follows graphs, transition systems, and cardinality constraint
models.
24directly-follows graphs
many discovery approaches use the directly-follows graph as an abstraction. this graphs
simply shows whether one activity is (often) followed by another activity. a notable exam-
ple is-algorithm9, which was the rst discovery algorithm taking concurrency as a starting
point. other approaches that use the directly-follows graph (sometimes in conjunction with
other abstractions) include variants of the -algorithm41,54,55, fuzzy mining27, heuristic min-
ing52,53, and inductive mining30{33.
denition 6 ((weighted) directly-follows graph) dfg = (a;r)is a directly-follows
graph ifais a set of activities with f.;gaandraais a relation such that
f(a;.)2rja2ag=f(;a)2rja2ag=;.
wdfg = (a;rw)is the weighted directly-follows graph of event log lifa=act(l)and
rw=s
2l[(a;b)2aaj91i<jj(i) =a^(i+ 1) =b].
computing the weighted directly-follows graph of event log lcorresponds to ml2la(l)
in figure 10. wdfg = (a;rw) captures how often some activity ais followed by some
activityb:rw(a;b) denotes this frequency. using some function mla2ma , the weighted
directly-follows graph is transformed into a non-weighted directly-follows graph. in this step
activities may be removed and relations below some threshold may be removed. mpm2ma 1
is applied to the graph resulting in a process model (e.g., a petri net or process tree).
transition systems
there are various approaches to convert an event log to a transition system which is then
converted to a process model.8positions in the traces in the event log are translated to states
in the transition system.
denition 7 ((weighted) transition system) ts= (a;s;s init;snal;r)is a transi-
tion system if ais a set of activities with f.;ga,sis a set of states, sinitsis the
set of initial states, snalsis the set of nal states, and rsasis a relation such
thatf(s1;.;s 2)2rjs162sinitg=f(s1;;s2)2rjs262snalg=;.
25wts = (a;s;s init;snal;rw)is the weighted transition system of lfor given a state
function state2aa!sifa=act(l),s=fstate (1;2)j92l=12g,
sinit=fstate (hi;)j2lg,snal=fstate (;hi)j2lg,rw=s
2l[(state (1;hai
2);a;state (1hai;2))j=1hai2].
the state of a case is determined using state function state2aa!s. consider
a case following trace =12after the occurrence of the activities in 1, i.e.,1has a
happened and 2still has to happen. the case is then in state state (1;2).
examples of state functions include:
state (1;2) =1: the whole history 1matters (the future 2has no inuence on the
state),
state (1;2) =fa21g: only the set of activities that occurred in the past matters,
and
state (1;2) = [a21]: the multiset of activities that occurred in the past matters.
it is also possible to let the state depend on all future activities, the next activity, the last
two activities, etc.
computing the weighted transition system corresponds to applying a log abstraction
functionml2la(l). relation rwcaptures how often one state is followed by another. let
=1hai2be the trace of some case involving activity aat some position. state (1;hai2)
is the state before the occurrence of aand state (1hai;2) is the state after the occurrence
ofa.rwis computed by considering all cases and all positions in the corresponding traces.
using some function mla2ma , the weighted transition system is transformed into an
ordinary transition system that can be converted onto a process model. mpm2ma 1is applied
to resulting transition system to get a petri net or some other model having the behavior
captured in the transition system.
for example, there are various so-called state-based region approaches able to translate a
transition system into a behaviorally equivalent petri net.17,22there may be several system
nets having the same transition system (modulo renaming or bisimulation), e.g., adding a
redundant place does not change the behavior. this shows that mpm2ma is not injective.
26however, it is possible to choose one of the behaviorally equivalent petri nets, thus realizing
mpm2ma 1. note that the abstraction provided by ml2la(l) is essential to be able to
synthesize a petri net that is not severely overtting the event log.
cardinality constraint model
the directly-follows graph only looks at the next activity. this can be generalized to capture
more general constraints among activities. given an event corresponding to activity awe
may look at the bevents before and after it. for example, this particular aevent may be
preceded by 3 bevents, but is never followed by a bevent. such observations can be used
to formulate cardinality constraints. an example constraint could be \any aevent may be
preceded by an arbitrary number of bevents, but can never be followed by a bevent."
declarative languages like declare start from the assumption that anything is possible
as long as it is not explicitly forbidden by a constraint.7several discovery techniques have
been proposed for declare .19,36,37a recently proposed declarative process modeling language
is the class of object-centric behavioral constraint (ocbc) models. ocbc models allow
for multiple intertwined instance notions and can be discovered by monitoring database
updates.35most of these approaches simply evaluate many, if not all, possible constraints.
such approaches are rather time-consuming (depending on the constraint types allowed).
however, for some constraints it is also possible to compute an intermediate structure and
use this to generate a model. we illustrate this by formalizing a particular abstraction:
(weighted) cardinality constraint models. these are employed as an abstraction to mediate
between event log and process model.
denition 8 ((weighted) cardinality constraint model) ccm = (a;c;r )is a car-
dinality constraint model if ais a set of activities with f.;ga,cis a set of disjoint
cardinalities, and raacis a relation.
wccm = (a;c;rw)is the weighted cardinality constraint model of lfor given a car-
dinality function card 2(aaa)a!cifa=act(l),c=fcard((1;a; 2);b)j
92l=1hai2^b2ag,rw=s
2l[(a;b;card((1;a; 2);b))j=1hai2^b2a].
a cardinality constraint model ccm = (a;c;r ) consists of activities a, possible car-
27dinalitiesc, and a relation raac. (a;b;c )2rmeans that the cardinality cis
possible for aandb. note that the roles of aandbare dierent. the cardinality always
considers one aevent in relation to all bevents before and after it (within a case). such an
aevent is called a reference event . thebevents before and after this reference event are
called target events . the above denition is generic and does not x a particular cardinality
notion. however, for a particular reference aevent andbactivity there should be precisely
one cardinality. if ( a;b;c )62r, then cardinality cis not possible for any reference aevent
andbactivity. although cardinalities are mutual exclusive at the event level, there may be
dierent reference events having dierent cardinalities.
the weighted cardinality constraint model counts the number of times ( a;b;c ) is observed.
each event serves as a reference event for each of the activities. hence, the number of
observations is equal to the number of events times the number of activities.
cardinality function card2(aaa)a!cdetermines the semantics of the
relations in r.card((1;a; 2);b) is the cardinality of an aevent preceded by 1and followed
by2with respect to activity b. some example functions:
card 1((1;a; 2);b) = ( bin(1fbg);bin(2fbg)) with bin(0) = 0, bin(1) = 1, bin(k) =
ifk2 yields observations that indicate both whether there were no, one, or more
bevents before the reference aevent and whether there were no, one, or more bevents
after the same reference aevent.
card 2((1;a; 2);b) = (1fbg;2fbg) yields observations that indicate the number
ofbevents before and after the reference aevent.
card 3((1;a; 2);b) = ( hd(2) =b) where hd(ha1;a2;:::;ani) =a1and hd(hi) =?
yields the directly-follows relation: when the reference aevents was followed immedi-
ately by abevent true is returned, otherwise false.
card 4((1;a; 2);b) =(12)fbgyields observations that indicate the total number
ofbevents before and after the reference aevent.
for each reference event ( ain some trace 1hai22l) and activity bwe get an
observation. by counting the number of observations we can get a \footprint" of the relation
28betweenaandb. consider for example card 1which allows for nine dierent observations, i.e.,
c=f(0;0);(1;0);(;0);(0;1);(1;1);(;1);(0;);(1;);(;)g. for a given aandbwe can
count the observations for each element of c. the ones that are above a threshold remain
and are used to build a model. it is easy to see that this way it is relatively easy to build the
declarative models described before (cf. figure 8). for example, if f(0;1);(1;1);(;1)gc
are all observed frequently and the rest not, then it makes sense to add a unary response. if
f(0;0);(1;0);(;0)gcare all observed frequently and the rest not, then a non-response
constraint can be added. if only (0 ;0)2cis observed frequently and the rest not, then a
non-coexistence constraint can be added. note that these are merely examples and in reality
things are often not so clear-cut. however, the examples illustrate that the intermediate
abstraction allows for the discovery of declarative process models.
in this section we introduced three types of abstractions illustrating the general principle
described in figure 10. for each abstraction we introduced a weighted variant that can
be obtained by applying the log abstraction function ml2la to some event log l. these
weighted variants count some relation. by setting thresholds or using some other cut-o
criterion, we can get a non-weighted variant of the abstraction (apply mla2ma ). based on
this we return a model that has the same abstraction (apply mpm2ma 1). we deliberately
did not describe any of the discovery approaches in detail. the goal was to conceptualize
process discovery.
bridging the gap
the focus thus far has been on formal process models. therefore, we could state that a
process model pm2p(a) corresponds to a set of traces over some activity set a. petri
nets, structured process models (process trees), declarative process models (declare) were
used as examples. such formal models are able to classify traces (i.e., sequences of events)
as tting or non-tting, and provide explicit constructs to model sequences, concurrency,
choices, and loops (or their declarative counterparts). commercial process mining tools
remain deliberately vague for reasons of scalability (dealing with millions of events) and
simplicity (results need to be understandable by end-users). the 25 commercial products
29mentioned before (e.g., celonis, disco, minit, myinvenio, processgold, and qpr) mostly
rely on discovery techniques that produce ltered directly-follows graphs . earlier we dened
wdfg = (a;rw) to be the weighted directly-follows graph of event log lwitha=act(l)
andrw=s
2l[(a;b)2aaj91i<jj(i) =a^(i+ 1) =b].rw(a;b) denotes how
many times awas followed directly by b. we can set a threshold on the inclusion of arcs, i.e.,
aandbare connected if rw(a;b) is above some threshold. this threshold can be absolute
or relative to the other weights. if we set the threshold to 1 (i.e., aandbare connected if
and only if rw(a;b)1), then the resulting graph can be viewed as a transition system
or markov chain (since only the last activity matters). such a model is often undertting
(introducing loops that may not exist) and complex (many connections). however, when
the threshold is set higher (e.g., rw(a;b)100), then it becomes impossible to view the
ltered directly-follows graph as a classier for traces. which combinations of output arcs
can be combined? showing frequencies on nodes (activities) and arcs may further add to
the confusion because \numbers do not add up".
(a) frequency distribution of the traces in the event log(b) petri net discovered using the alpha miner 
(c) process tree (visualized in bpmn style ) discovered using the inductive miner 
402 traces 
40.20% of the log send request pay ticket confirm receipt get ticket visit concert 
314 traces 
31.40% of the log send request confirm receipt pay ticket get ticket visit concert 
250 traces 
25.00% of the log send request pay ticket get ticket confirm receipt visit concert 
20 traces 
2.00% of the log send request confirm receipt get ticket pay ticket visit concert 
10 traces 
1.00% of the log send request get ticket pay ticket confirm receipt visit concert 
4 traces 
0.40% of the log send request get ticket confirm receipt pay ticket visit concert 
figure 11: a simple synthetic event log and two formal models derived from it.
to illustrate the problem let us look at a very simple process for which we created an arti-
cial event log l=h.;sr;pt;cr;gt;vc;i402;h.;sr;cr;pt;gt;vc;i314;h.;sr;pt;gt;cr;vc;i250;
h.;sr;cr;gt;pt;vc;i20;h.;sr;gt;pt;cr;vc;i10;h.;sr;gt;cr;pt;vc;i4where srrefers to ac-
tivity \send request", ptrefers to \pay ticket", crrefers to \conrm receipt", gtrefers to
\get ticket", and vcrefers to \visit concert". figure 11 visualizes the event log and two
30formal models. one model (b) is discovered by the -algorithm and the other one (c) by
the inductive miner. both models allow for the traces observed (and nothing more) and
are quite simple. therefore, we consider these models to be an adequate description of the
behavior observed. actually the event log was generated from a simulation model in cpn
tools having the structure shown in figure 11(b). if we feed the same event log to a com-
mercial process mining tool, we are unable to capture this behavior. figure 12 illustrates
the problem using disco and celonis as examples. the unltered directly-follows graph is
complex and also undertting, figure 12(a) and (b) show multiple loops suggesting behav-
iors that are not possible. each activity is executed precisely once for each case. the models
discovered by commercial tools do not show the split and join behavior (and, xor, or or)
in the process model. some of these tools are able to discover concurrency under particular
circumstances, but this is not shown. sometimes concurrency is only detected when activ-
ities overlap (disco) or additional information is given (celonis). however, in both cases,
this is not exposed to the user.
the ltered directly-follows graphs in figure 12(c) and (d) show that the model can be
simplied, but this leads to inconsistent models. first of all, the activity frequencies and the
arc frequencies do not match. see for example activity \visit concert" that occurred 1000
times, but the only input arc has a frequency of only 716. second, the diagrams seem to
suggest that it is possible to bypass \conrm receipt", but this never happens. finally, the
computed delays (not shown in figure 12) are very misleading. the times returned by disco
and celonis are \conditional delays". if \send request" is followed directly by \pay ticket",
then the average delay is 44 hours. however, the actual delay between \send request" and
\pay ticket" is 51 hours.
this small example shows that ltered directly-follows graphs cannot be viewed as formal
models and may lead to invalid conclusions. formal models are able to classify traces into
tting and non-tting. looking at the ltered directly-follows graphs in figure 12(c) and (d)
does not really provide insights into which traces are tting the model. the model generated
by both disco and celonis suggests that h.;sr;pt;cr;gt;vc;iandh.;sr;pt;gt;vc;iare the
two traces possible. however, the second trace never happened (there is no \conrm receipt")
and the rst trace represents only one of six variants.
31(a) disco showing the full directly -follows graph 
(c) disco showing the full directly -follows graph (d) celonis showing a filtered directly -follows graph (b) celonis showing the full directly -follows graph 
the filtered directly -
follows graph covers 
on the two most 
frequent behaviors .
the filtered directly -
follows graph covers 
on the two most 
frequent behaviors .note that the 
numbers do 
not add up .note that the 
numbers do 
not add up .figure 12: screenshots from disco and celonis to show that one should be careful to interpret
results from informal models like a ltered directly-follows graph correctly.
however, formal models may be hard to understand by end-users when things get com-
plex. formal models may also be incorrect, have soundness problems (e.g., deadlocks), or
take a long time to compute. consider for example the -algorithm that is guaranteed to
discover a particular class of process model.9however, when the event log is incomplete
or the underlying process is outside the class of models, the -algorithm often returns a
process model that is not sound (e.g., having deadlocks and livelocks) or that does not allow
for behavior seen (e.g., skips). in such cases formality is simply misleading. therefore, it is
recommended to always check a formal model using conformance checking. there are several
algorithms that guarantee certain properties (e.g., soundness or ability to replay the event
32log). however, such models tend to be extremely complex due to overtting the event log
or simple but severely undertting the event logs (unconstrained behavior). for example,
region-based discovery techniques provide models that are guaranteed to be able replay the
event log and that may construct very \smart" places constraining behavior to what was seen
in the log.8,14,47,56however, petri nets with smartly constructed places and bpmn models
with many gateways are quickly perceived as too complex. also the dierence between t-
ting and non-tting traces may be less clear cut. these challenges explain why commercial
vendors resorted to informal models. commercial process mining tools also need to be able
to handle logs with millions of events and still be used in an interactive manner. therefore,
the challenge is to bridge the gap between the formal approaches described in literature and
the more pragmatic approaches used by commercial vendors.
additional research is needed to better combine the best of two worlds. one approach
is to use relaxed versions of the inductive mining techniques.33,34the inductive approach
ensures a sound model that is able to replay a substantial part of the event log. there
are also highly scalable variants of the approach. if needed, the algorithm can be forced to
guarantee perfect tness. however, the resulting process model may be severely undertting.
for unstructured processes, the discovered process trees tend to have many loops combined
with activities that can be skipped. as a result almost any behavior is possible.
another approach is to use hybrid process models .5these models aim to combine the
best of both worlds. constructs with formal semantics are only used for the parts that
are clear-cut. for these denite parts of the process we distinguish between concurrency,
choice, and other exactly specied behaviors. for the other parts we resort to arcs showing
dependencies that should not be interpreted formally. this way hybrid process models are
able to express informal dependencies (like in commercial tools) that are deliberately vague
and at the same time provide formal semantics for the parts that, supported by the data,
can be expressed in an unambiguous manner. whenever dependencies are a bit weaker or
too complex, then they are not left out, but depicted in an informal manner. install the
hybridminer package from http://www.promtools.org to see an example implementation
of this idea.5
the need for new approaches that better balance between informal models (e.g., just
33showing strong directly-follows relations) and formal models (e.g., petri net places and
bpmn gateways) is nicely illustrated by the way that commercial vendors started to sup-
port conformance checking. for example, celonis uses formal bpmn models when checking
compliance and ltered directly-follows relations when discovering model from event data.
using dierent process models for dierent process mining tasks is far from optimal: a more
seamless integration is needed.
a described in this section, there exists a gap between the commercial systems often
generating informal models (i.e., models that cannot be used to classify trace into tting
and non-tting) and the more formal approaches described in literature. the framework
depicted in figure 10 may help to bridge this gap and create awareness for the problems
identied in this section.
related work
for a more elaborate introduction to the topic of process mining we refer to the book \process
mining: data science in action"2in the current article, unlike the book, we focused on
process discovery. the rst comprehensive survey on process discovery appeared in 2003.4
in 2008 another survey by tiwari, turner, and majeed was published.50both surveys do
not reect the current state-of-the-art in process discovery anymore. many new algorithms
appeared in recent years.
there have also been several papers comparing the performance of dierent algorithms in
terms of model quality.13,51these papers focus on measuring the performance of algorithms
on selected sets of event logs and not on unifying the inner working of dierent algorithms.
to support the selection of process discovery techniques an automated service was proposed
by ribeiro et al.45however, the quality of this recommender system depends on portfolio of
models and logs used as input. claes focused on providing an overview of the use of prom
plug-ins.20also more specic surveys appeared such as the recent study on educational
process mining.16
this article complements existing literature by introducing the topic of process discovery
in an original manner. by unifying existing approaches and discussing the abstractions used,
34the reader gets a compact, yet insightful, overview of the eld. moreover, figure 10 and the
expressionmpm2ma 1(mla2ma (ml2la(l))) elegantly shows how to get from an event log to
a process model through log and model abstractions. often these notions are not visible and
used in an implicit manner.
conclusions
event data are everywhere and process mining techniques help to unlock the value in such
data. the four main types of process mining described in this article are (1) process dis-
covery, (2) conformance checking, (3) process reengineering, and (4) operational support.
process mining is not only about control-ow, other perspectives like the time perspective,
the data and decision perspective, the resource and organization perspective, etc. can be
added. independent of the perspectives included, process mining techniques can be used in
online and oine settings. in this article, we rst provided an overview of the process mining
spectrum, and then focused on control-ow discovery.
the starting point is an event log. we showed that an event log represents a viewpoint
on some event collection. each event should have a case identier, an activity name and a
timestamp as a bare minimum. we also described dierent target languages: system nets
(i.e., petri nets with in initial and nal state), structured process models (process trees in
particular), and declarative models composed of cardinality constraints.
there are many discovery techniques to learn process models from event logs. these
techniques often use log and model abstractions. in this article we discussed three types of
abstractions: (1) the (weighted) directly-follows graph, (2) the (weighted) transition system,
and (3) the (weighted) cardinality constraint model. although these abstractions are very
dierent, we showed that they can be captured in a common framework (figure 10).
despite the many successful applications of process mining and the availability of over 25
commercial products supporting process mining (celonis, disco, minit, myinvenio, process-
gold, qpr, etc.), there are still many open challenges. discovery techniques need to balance
dierent goals (e.g., tness, simplicity, precision, and generalization) and at the same time
provide guarantees (e.g., able to rediscover a behaviorally equivalent process model).
35we expect that the framework presented in this article will trigger novel ideas for new
discovery techniques. existing approaches tend to have tight coupling between the abstrac-
tions used and the target modeling language. decoupling the log-based and model-based
abstractions from the process modeling notation stimulates a cross-fertilization among exist-
ing approaches. for example, cardinality constraint models could be used to learn process
trees or petri nets. another direction for future research is to include formal and informal
elements in process models resulting in so-called hybrid process models.5the log-based ab-
straction may hold information that cannot be mapped onto modeling constructs as these
make binary decisions on included and excluded behavior.
references
1. w.m.p. van der aalst. business process management: a comprehensive survey. isrn
software engineering , pages 1{37, 2013. doi:10.1155/2013/507984.
2. w.m.p. van der aalst. process mining: data science in action . springer-verlag, berlin,
2016.
3. w.m.p. van der aalst, a. adriansyah, and b. van dongen. replaying history on process
models for conformance checking and performance analysis. wires data mining and
knowledge discovery , 2(2):182{192, 2012.
4. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workow mining: a survey of issues and approaches. data and
knowledge engineering , 47(2):237{267, 2003.
5. w.m.p. van der aalst, r. de masellis, c. di francescomarino, and c. ghidini. learning
hybrid process models from events: process discovery without faking condence. in
j. carmona, g. engels, and a. kumar, editors, international conference on business
process management (bpm 2017) , volume 10445 of lecture notes in computer science ,
pages 59{76. springer-verlag, berlin, 2017.
366. w.m.p. van der aalst and m. pesic. decserflow: towards a truly declarative service
flow language. in m. bravetti, m. nunez, and g. zavattaro, editors, international
conference on web services and formal methods (ws-fm 2006) , volume 4184 of lecture
notes in computer science , pages 1{23. springer-verlag, berlin, 2006.
7. w.m.p. van der aalst, m. pesic, and h. schonenberg. declarative workows: balanc-
ing between flexibility and support. computer science - research and development ,
23(2):99{113, 2009.
8. w.m.p. van der aalst, v. rubin, h.m.w. verbeek, b.f. van dongen, e. kindler, and
c.w. g unther. process mining: a two-step approach to balance between undertting
and overtting. software and systems modeling , 9(1):87{111, 2010.
9. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workow mining: dis-
covering process models from event logs. ieee transactions on knowledge and data
engineering , 16(9):1128{1142, 2004.
10. r. agrawal, d. gunopulos, and f. leymann. mining process models from workow
logs. in sixth international conference on extending database technology , volume 1377
oflecture notes in computer science , pages 469{483. springer-verlag, berlin, 1998.
11. e. alpaydin. introduction to machine learning . mit press, cambridge, ma, 2010.
12. d. angluin and c.h. smith. inductive inference: theory and methods. computing
surveys , 15(3):237{269, 1983.
13. a. augusto, r. conforti, m. dumas, m. la rosa, f.m. maggi, a. marrella, m. mecella,
and a. soo. automated discovery of process models from event logs: review and
benchmark. corr , abs/1705.02288, 2017.
14. r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on regions
of languages. in g. alonso, p. dadam, and m. rosemann, editors, international con-
ference on business process management (bpm 2007) , volume 4714 of lecture notes in
computer science , pages 375{383. springer-verlag, berlin, 2007.
3715. a.w. biermann and j.a. feldman. on the synthesis of finite-state machines from
samples of their behavior. ieee transaction on computers , 21:592{597, 1972.
16. a. bogarin, r. cerezo, and c. romero. a survey on educational process mining. wiley
interdisciplinary reviews: data mining and knowledge discovery , 2017.
17. j. carmona, j. cortadella, and m. kishinevsky. new region-based algorithms for
deriving bounded petri nets. ieee transactions on computers , 59(3):371{384, 2010.
18. celonis. process mining success story: innovation is an alliance with the fu-
ture, http://www.win.tue.nl/ieeetfpm/lib/exe/fetch.php?media=:casestudies:
siemens_celonis_story_english.pdf , 2017.
19. c. di ciccio and m. mecella. a two-step fast algorithm for the automated discovery
of declarative workows. in ieee symposium on computational intelligence and data
mining (cidm 2013) , pages 135{142. ieee computer society, 2013.
20. j. claes and g. poels. process mining and the prom framework: an exploratory survey ,
pages 187{198. springer-verlag, berlin, berlin, heidelberg, 2013.
21. j.e. cook and a.l. wolf. discovering models of software processes from event-based
data. acm transactions on software engineering and methodology , 7(3):215{249, 1998.
22. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets from
finite transition systems. ieee transactions on computers , 47(8):859{882, august
1998.
23. a. datta. automating the discovery of as-is business process models: probabilistic
and algorithmic approaches. information systems research , 9(3):275{301, 1998.
24. m. dumas, m. la rosa, j. mendling, and h. reijers. fundamentals of business process
management . springer-verlag, berlin, 2013.
25. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2. acta
informatica , 27(4):315{368, 1989.
3826. e.m. gold. language identication in the limit. information and control , 10(5):447{
474, 1967.
27. c.w. g unther and w.m.p. van der aalst. fuzzy mining: adaptive process simplica-
tion based on multi-perspective metrics. in g. alonso, p. dadam, and m. rosemann,
editors, international conference on business process management (bpm 2007) , vol-
ume 4714 of lecture notes in computer science , pages 328{343. springer-verlag, berlin,
2007.
28. d. hand, h. mannila, and p. smyth. principles of data mining . mit press, cambridge,
ma, 2001.
29. j. herbst. a machine learning approach to workow management. in proceedings 11th
european conference on machine learning , volume 1810 of lecture notes in computer
science , pages 183{194. springer-verlag, berlin, 2000.
30. s.j.j. leemans, d. fahland, and w.m.p. van der aalst. discovering block-structured
process models from event logs: a constructive approach. in j.m. colom and j. desel,
editors, applications and theory of petri nets 2013 , volume 7927 of lecture notes in
computer science , pages 311{329. springer-verlag, berlin, 2013.
31. s.j.j. leemans, d. fahland, and w.m.p. van der aalst. discovering block-structured
process models from event logs containing infrequent behaviour. in n. lohmann,
m. song, and p. wohed, editors, business process management workshops, interna-
tional workshop on business process intelligence (bpi 2013) , volume 171 of lecture
notes in business information processing , pages 66{78. springer-verlag, berlin, 2014.
32. s.j.j. leemans, d. fahland, and w.m.p. van der aalst. discovering block-structured
process models from incomplete event logs. in g. ciardo and e. kindler, editors,
applications and theory of petri nets 2014 , volume 8489 of lecture notes in computer
science , pages 91{110. springer-verlag, berlin, 2014.
33. s.j.j. leemans, d. fahland, and w.m.p. van der aalst. scalable process discovery with
guarantees. in k. gaaloul, r. schmidt, s. nurcan, s. guerreiro, and q. ma, editors, en-
39terprise, business-process and information systems modeling (bpmds 2015) , volume
214 of lecture notes in business information processing , pages 85{101. springer-verlag,
berlin, 2015.
34. s.j.j. leemans, d. fahland, and w.m.p. van der aalst. scalable process discovery
and conformance checking. software and systems modeling (online first) , pages 1{33,
2016.
35. g. li, r. medeiros de carvalho, and w.m.p. van der aalst. automatic discovery
of object-centric behavioral constraint models. in w. abramowicz, editor, business
information systems (bis 2017) , volume 288 of lecture notes in business information
processing , pages 43{58. springer-verlag, berlin, 2017.
36. f.m. maggi, r.p. jagadeesh chandra bose, and w.m.p. van der aalst. ecient dis-
covery of understandable declarative process models from event logs. in j. ralyte,
x. franch, s. brinkkemper, and s. wrycza, editors, international conference on ad-
vanced information systems engineering (caise 2012) , volume 7328 of lecture notes in
computer science , pages 270{285. springer-verlag, berlin, 2012.
37. f.m. maggi, r.p. jagadeesh chandra bose, and w.m.p. van der aalst. a knowledge-
based integrated approach for discovering and repairing declare maps. in c. salinesi,
m.c. norrie, and o. pastor, editors, international conference on advanced information
systems engineering (caise 2013) , volume 7908 of lecture notes in computer science ,
pages 433{448. springer-verlag, berlin, 2013.
38. f.m. maggi, m. montali, m. westergaard, and w.m.p. van der aalst. monitoring
business constraints with linear temporal logic: an approach based on colored au-
tomata. in s. rinderle, f. toumani, and k. wolf, editors, business process manage-
ment (bpm 2011) , volume 6896 of lecture notes in computer science , pages 132{147.
springer-verlag, berlin, 2011.
39. f. mannhardt, m. de leoni, and h.a. reijers. heuristic mining revamped: an inter-
active, data-aware, and conformance-aware miner. in proceedings of the bpm 2017
demo track , pages 1{5, 2017.
4040. h. mannila, h. toivonen, and a.i. verkamo. discovery of frequent episodes in event
sequences. data mining and knowledge discovery , 1(3):259{289, 1997.
41. a.k. alves de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. workow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis, doa, and
odbase , volume 2888 of lecture notes in computer science , pages 389{406. springer-
verlag, berlin, 2003.
42. m. montali. specication and verication of declarative open interaction models: a
logic-based approach , volume 56 of lecture notes in business information processing .
springer-verlag, berlin, 2010.
43. m. montali, f.m. maggi, f. chesani, p. mello, and w.m.p. van der aalst. monitoring
business constraints with the event calculus. acm transactions on intelligent systems
and technology (amc tist) , 5(1):17:1{17:30, 2013.
44. a. nerode. linear automaton transformations. proceedings of the american mathe-
matical society , 9(4):541{544, 1958.
45. j. ribeiro, j. carmona, m. msr, and m. sebag. a recommender system for process
discovery. in s. sadiq, p. soer, and h. voelzer, editors, international conference on
business process management (bpm 2014) , volume 8659 of lecture notes in computer
science , pages 67{83. springer-verlag, berlin, 2014.
46. a. rozinat. process mining: conformance and extension . phd thesis, eindhoven uni-
versity of technology, november 2010.
47. m. sole and j. carmona. process mining from a basis of regions. in j. lilius and
w. penczek, editors, applications and theory of petri nets 2010 , volume 6128 of lecture
notes in computer science , pages 226{245. springer-verlag, berlin, 2010.
48. r. srikant and r. agrawal. mining sequential patterns: generalization and performance
improvements. in proceedings of the 5th international conference on extending database
technology (edbt 96) , pages 3{17, 1996.
4149. tfpm. process mining case studies, http://www.win.tue.nl/ieeetfpm/doku.php?
id=shared:process_mining_case_studies , 2017.
50. a. tiwari, c.j. turner, and b. majeed. a review of business process mining: state-of-
the-art and future trends. business process management journal , 14(1):5{22, 2008.
51. j. de weerdt, m. de backer, j. vanthienen, and b. baesens. a multi-dimensional
quality assessment of state-of-the-art process discovery algorithms using real-life
event logs. information systems , 37(7):654{676, 2012.
52. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workow models
from event-based data using little thumb. integrated computer-aided engineering ,
10(2):151{162, 2003.
53. a.j.m.m. weijters and j.t.s. ribeiro. flexible heuristics miner (fhm). beta working
paper series, wp 334, eindhoven university of technology, eindhoven, 2010.
54. l. wen, w.m.p. van der aalst, j. wang, and j. sun. mining process models with
non-free-choice constructs. data mining and knowledge discovery , 15(2):145{180,
2007.
55. l. wen, j. wang, w.m.p. van der aalst, b. huang, and j. sun. a novel approach
for process mining based on event types. journal of intelligent information systems ,
32(2):163{190, 2009.
56. j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik. process
discovery using integer linear programming. fundamenta informaticae , 94:387{412,
2010.
57. m. weske. business process management: concepts, languages, architectures .
springer-verlag, berlin, 2007.
42further reading
for more information on process mining the reader should read the book \process mining:
data science in action"2or follow the free massive open online course (mooc) with the
same title: www.coursera.org/course/procmin . also the website www.processmining.
orgprovides further information and pointers.
43