process equivalence: comparing two process
models based on observed behavior
w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fw.m.p.v.d.aalst,a.k.medeiros,a.j.m.m.weijters g@tm.tue.nl
abstract. in various application domains there is a desire to compare
process models, e.g., to relate an organization-speci¯c process model to
a reference model, to ¯nd a web service matching some desired service
description, or to compare some normative process model with a pro-
cess model discovered using process mining techniques. although many
researchers have worked on di®erent notions of equivalence (e.g., trace
equivalence, bisimulation, branching bisimulation, etc.), most of the ex-
isting notions are not very useful in this context. first of all, most equiva-
lence notions result in a binary answer (i.e., two processes are equivalent
or not). this is not very helpful, because, in real-life applications, one
needs to di®erentiate between slightly di®erent models and completely
di®erent models. second, not all parts of a process model are equally
important. there may be parts of the process model that are rarely acti-
vated while other parts are executed for most process instances. clearly,
these should be considered di®erently. to address these problems, this pa-
per proposes a completely new way of comparing process models. rather
than directly comparing two models, the process models are compared
with respect to some typical behavior. this way we are able to avoid the
two problems. although the results are presented in the context of petri
nets, the approach can be applied to any process modeling language with
executable semantics.
keywords : process equivalence, petri nets, process mining.
1 introduction
today one can ¯nd a wide variety of process models in any large organization
[10]. typical examples are:
{reference models (e.g., the epc models in the sap r/3 reference model)
{work°ow models (e.g., models used for enactment in systems like sta®ware,
flower, filenet, oracle bpel, etc.),
{business process models/simulation models (e.g., using tools such as aris,
protos, arena, etc.),
{interface/service descriptions (e.g., the partner interface processes in roset-
tanet, the abstract bpel processes in the context of web services, choreog-
raphy descriptions using wscdl), or{process models discovered using process mining techniques.
given the co-existence of di®erent models and di®erent types of models, it is
interesting to be able to compare process models. this applies to di®erent lev-
els ranging from models at the business level to models at the level of software
components (e.g., when looking for a software component matching some speci¯-
cation). to compare process models in a meaningful manner, we need to assume
that these models have semantics. moreover, we need to assume some equivalence
notion (when are two models the same?) people working on formal methods have
proposed a wide variety of equivalence notions [1, 11, 13], e.g., two models may
be identical under trace equivalence but are di®erent when considering stronger
notions of equivalence (e.g., bisimulation). unfortunately, most equivalence no-
tions provide a \true/false" answer. in reality there will seldom be a perfect ¯t.
hence, we are interested in the degree of similarity , e.g., a number between 0
(completely di®erent) and 1 (identical). in other to do so, we need to quantify
the di®erences. here it seems reasonable to put more emphasis on the frequently
used parts of the model.
a
b d c
ep1
p2 p3
p5 p4
p6f
(a) (b) (d)
legend:
a=register request
b=book train
c=book flight
d=book hotel
e=send invoice
f=change hotel
(e)frequencies:
40: abde
85: acde
15: adbe
20: adce
(f)a
b d c
ep1
p2
p5 p4
p6a
d c
ep1
p2 p3
p5 p4
p6a
b d c
ep1
p2 p3
p5 p4
p6
(c)
fig. 1. running example.
to clarify the problem, let us consider figure 1 where four process models
(expressed in terms of petri nets [16]) are depicted. these models describe the
booking of a trip, see the legend for the interpretation of the various transitionsin the petri nets, e.g., crefers to the booking of a °ight. clearly, these models
are similar. however, using classical equivalence notions all models are consid-
ered di®erent. for example, in process (a) it is possible to have the execution
sequence adbe while this sequence is not possible in (b) and (c). moreover, the
petri net in figure 1(d) allows for acdfde which is not possible in any of the
other models. note that we focus on the active parts of the net (i.e., the transi-
tions) rather than passive things such as places. although classical equivalence
notions consider the four models to be di®erent, it is clear that some are more
similar than other. therefore, we want to quantify \equality", i.e., the degree of
similarity. a naive approach could be to simply compare the sets of transition la-
bels, e.g., nets (a) and (b) have the same transition labels: fa; b; c; d; e gwhile
(c) has a smaller set (without b) and (d) has a bigger set (with f). however,
models with similar labels can have completely di®erent behaviors (cf. (a) and
(b) in figure 1). therefore, it is important to consider causal dependencies and
the ordering of activities, e.g., to distinguish between parallelism and choice. an-
other approach could be to consider the state spaces or sets of possible traces of
both models. however, in that case the problems are that there may be in¯nitely
many traces/states and that certain paths are more probable.
in this paper, we investigate these problems and propose a completely new
approach. the main idea is to compare two models relative to an event log con-
taining \typical behavior". this solves several problems when comparing dif-
ferent models. even models having in¯nitely many execution sequences can be
compared and automatically the relevance of each di®erence can be taken into
account. moreover, as we will show, we can capture the moment of choice and
analyze causalities that may not be explicitly represented in the log.
to give some initial insights in our approach, consider the set of traces listed
in figure 1(f). each trace represents an execution sequence that may or may not
¯t in the models at hand. moreover, frequencies are given, e.g., in the event log
trace abde occurred 40 times, i.e., there were 40 process instances having this
behavior. figure 1(f) represents some \typical behavior". this may be obtained
using simulation of some model or it could be obtained by observing some real-
life system/process. all 160 traces ¯t into the ¯rst petri net (cf. figure 1(a)),
moreover, this petri net does not allow for any execution sequences not present in
the log. in this paper, we will quantify a notion of ¯tness . however, our primary
objective is not to compare an event log and a process model, but to compare
models in the presence of some event log as shown in figure 1(f). compare for
example models (a) and (b): in a substantial number of cases (35) dprecedes
borc. if we compare (a) and (c) based on the log, we can see that for 55
cases there is a di®erence regarding the presence of b. we will show that we can
quantify these di®erences using the event log. it is important to note that we
do not only consider full traces, e.g., if we compare figure 1(a) with a petri net
where dis missing in the model, there is still some degree of similarity although
none of the traces still ¯ts (they all contain d).
the remainder is organized as follows. after providing a brief overview of
related work, we introduce some preliminaries required to explain our approach.although we use petri nets to illustrate our approach, any other process model
with some local execution semantics (e.g., epcs, activity diagrams, bpmn, etc.)
could be used. in section 4, we present two naive approaches (one based on the
static structure and one based on a direct comparison of all possible behaviors)
and discuss their limitations. then, in section 5 we present the core results of
this paper. we will show that we can de¯ne precision andrecall measures using
event logs containing typical behavior. these notions have been implemented in
prom [9]. finally, we conclude the paper.
2 overview of various equivalence notations and
related work
in the literature, many equivalence notions have been de¯ned for process models.
most equivalence notions focus on the dynamics of the model and not on the
syntactical structure (e.g., trace equivalence and bisimulation [1, 11, 13]).
this paper uses petri nets as a theoretical foundation [16]. in [15] an overview
is given of equivalence notions in the context of petri nets. see also [5] for more
discussions on equivalence in the context of nets. most authors translate a petri
net to a transition system to give it semantics. however, there are also authors
that emphasize the true-concurrency aspects when giving petri nets semantics.
for example, in [7] the well-known concept of occurrence nets (also named runs)
are used to reason about the semantics of petri nets.
any model with formal/executable semantics (including petri nets) can be
translated to a (possibly in¯nite) transition system. if we consider transition
systems, many notions of equivalence have been identi¯ed. the weakest notion
considered is trace equivalence : two process models are considered equivalent
if the sets of traces they can execute are identical. trace equivalence has two
problems: (1) the set of traces may be in¯nite and (2) trace equivalence does
not capture the moment of choice. the ¯rst problem can be addressed in various
ways (e.g., looking at ¯nite sets of pre¯xes or comparing transition systems
rather than traces). the second problem requires stronger notions of equivalence.
bisimulation and various kinds of observation equivalence [13] attempt to capture
the moment of choice. for example, there may be di®erent processes having
identical sets of traces fabc; abd g, e.g., the process where the choice for cor
dis made after executing aor the process where the same choice is made only
after executing b. branching bisimilarity [11] is a slightly ¯ner equivalence notion
than the well-known observation equivalence [13]. a comparison of branching
bisimilarity, observation equivalence, and a few other equivalences on processes
with silent behavior can be found in [11]. based on these equivalence relations
also other relations have been introduced, e.g., the four inheritance relations in
[1] are based on branching bisimilarity.
all references mentioned so far, aim at a \true/false" answer. moreover, they
do not take into account that some parts of the process may be more important
than others. few people (e.g., prakash panangaden and jose desharnais [8])
have been working on probabilistic bisimulation using labeled markov processesrather than labeled transition systems. see [8] for an excellent overview of this
work and also links to the probability theory community working on metrics on
spaces of measures. in this paper, we use a di®erent approach. we do not assume
that we know any probabilities. instead we assume that we have some example
behavior than can serve as a basis for a comparison of two models. also related is
the work on metric labeled transition systems where the \behavioral di®erence"
between states is a non-negative real number indicating the similarity between
those states [6]. this way one can de¯ne a behavioral pseudometric to compare
transition systems as shown in [6]. note that this approach very much depends
on an explicit notion of states and it is not clear how this can be applied to a
practical, mainly activity oriented, setting.
as far as we know, this paper is the ¯rst to propose the use of \typical
behavior" recorded in event logs as an aid for comparison. this makes the work
quite di®erent from the references mentioned in this section. moreover, we show
that this can be used in the context of process mining [2, 4].
3 preliminaries
this section introduces some of the basic mathematical and petri-net related
concepts used in the remainder.
3.1 multi-sets, sequences, and matrices
letabe a set. i b( a) =a!i n is the set of multi-sets (bags) over a, i.e.,
x2i b(a) is a multi-set where for each a2a:x(a) denotes the number of
times ais included in the multi-set. the sum of two multi-sets ( x+y), the
di®erence ( x¡y), the presence of an element in a multi-set ( x2x), and
the notion of subset ( x·y) are de¯ned in a straightforward way and they
can handle a mixture of sets and multi-sets. the operators are also robust with
respect to the domains of the multi-sets, i.e., even if xandyare de¯ned on
di®erent domains, x+y,x¡y, and x·yare de¯ned properly by extending
the domain where needed. jxj=p
a2ax(a) is the size of some multi-set xover
a.
for a given set a,a¤is the set of all ¯nite sequences over a. a ¯nite se-
quence over aof length nis a mapping ¾2 f1; : : : ; n g !a. such a sequence is
represented by a string, i.e., ¾=ha1; a2; : : : ; a niwhere ai=¾(i) for 1 ·i·n.
hd(¾; k) =ha1; a2; : : : ; a ki, i.e., the sequence of just the ¯rst kelements. note
that hd(¾;0) is the empty sequence.
every multi-set can be represented as a vector, i.e., x2i b(a) can be repre-
sented as a row vector ( x(a1); x(a2); : : : ; x (an)) where a1,a2,: : :,anenumerate
the domain of x. (x(a1); x(a2); : : : ; x (an))tdenotes the corresponding column
vector (ttransposes the vector). assume xis an k£`matrix, i.e., a matrix
with krows and `columns. a row vector can be seen as 1 £`matrix and a
column vector can be seen as a k£1 vector. x(i; j) is the value of the element
in the ithrow and the jthcolumn. let xbe an k£`matrix and yan`£mmatrix. the product x¢yis the product of xandyyielding a k£mmatrix,
where x¢y(i; j) =p
1·q·`x(i; q)y(q; j). the sum of two matrices having the
same dimensions is denoted by x+y.
for any sequence ¾2 f1; : : : ; n g ! aover a, the parikh vector¡ !¾maps
every element aofaonto the number of occurrences of ain¾, i.e.,¡ !¾2i b(a)
where for any a2a:¡ !¾(a) =p
1·i·nif¾(i) =athen 1 else 0.
3.2 petri nets
this subsection brie°y introduces some basic petri net terminology [16] and
notations used in the remainder.
de¯nition 1 (petri net). a petri net is a triple (p; t; f ).pis a ¯nite set of
places, tis a ¯nite set of transitions ( p\t=;), and fµ(p£t)[(t£p)
is a set of arcs (°ow relation).
figure 1 shows four petri nets. places are represented by circles and transitions
are represented by squares.
for any relation/directed graph gµa£awe de¯ne the preset ²a=
fa1j(a1; a)2ggand postset a²=fa2j(a; a2)2ggfor any node a2a.
we useg²aorag²to explicitly indicate the context gif needed. based on the
°ow relation fwe use this notation as follows. ²tdenotes the set of input places
for a transition t. the notations t²,²pandp²have similar meanings, e.g., p²is
the set of transitions sharing pas an input place. note that we do not consider
multiple arcs from one node to another. in the petri net shown figure 1(d):
p5²=fe; fg,²p5 =fdg,a²=fp2; p3g,²a=fp1g, etc.
at any time a place contains zero or more tokens , drawn as black dots. the
state of the petri net, often referred to as marking , is the distribution of tokens
over its places, i.e., m2i b(p). in each of the four petri nets shown in figure 1
only one place is initially marked ( p1). note that more places could be marked
in the initial state and that places can be marked with multiple tokens.
we use the standard ¯ring rule , i.e., a transition tis said to be enabled if and
only if each input place poftcontains at least one token. an enabled transition
may ¯re, and if transition t¯res, then tconsumes one token from each input
place poftandproduces one token for each output place poft. for example, in
figure 1(a), ais enabled and ¯ring awill result in the state marking place p2
andp3. in this state both b,c, and dare enabled. if b¯res, cis disabled, but
dremains enabled. similarly, if c¯res, bis disabled, but dremains enabled,
etc. after ¯ring 4 transitions in figure 1(a) the resulting state marks p6 with
one token (independent of the order of borc). in the following de¯nition, we
formalize these notions.
de¯nition 2 (firing rule). letn= (p; t; f )be a petri net and m2i b(p)
be a marking.
{enabled (n; m ) =ft2tjm¸ ²tgis the set of enabled transitions,
{result (n; m; t ) = (m¡ ²t) +t²is the state resulting after ¯ring t2t,{(n; m )[ti(n; m0)denotes that tis enabled in (n; m )(i.e., t2enabled (n; m ))
and that ¯ring tresults in marking m0(i.e., m0=result (n; m; t )).
(n; m )[ti(n; m0) de¯nes how a petri net can move from one marking to another
by ¯ring a transition. we can extend this notion to ¯ring sequences. suppose
¾=ht1; t2; : : : ; t niis a sequence of transitions present in some petri net nwith
initial marking m. (n; m )[¾i(n; m0) means that there is also a sequence of
markings hm0; m1; : : : ; m niwhere m0=m,mn=m0, and for any 0 ·i <
n: (n; m i)[ti+1i(n; m i+1). using this notation we de¯ne the set of reachable
markings r(n; m ) as follows: r(n; m ) =fm02i b(p)j 9¾(n; m )[¾i(n; m0)g.
note that m2r(n; m ) because mis reachable via the empty sequence.
note that result (n; m; t ) does not need to yield a multi-set if tis not enabled
in marking mbecause some places may have a negative number of tokens.
although this is not allowed in a petri net (only enabled transitions can ¯re),
for technical reasons it is sometimes convenient to use markings that may have
\negative tokens". this becomes clear when considering the incidence matrix of
a petri net.
de¯nition 3 (incidence matrix). letn= (p; t; f )be a petri net and m2
i b(p)be a marking.
{~nis the incidence matrix of n, i.e., ~nis ajpj£jtjmatrix with ~n(p; t) = 1
if(p; t)62fand(t; p)2f,~n(p; t) =¡1if(p; t)2fand(t; p)62f, and
~n(p; t) = 0 in all other cases,
{result (n; m; ¾ ) =m+~n¢¡ !¾is the state resulting after ¯ring ¾2t¤,1
{enabled (n; m; ¾ ) =enabled (n;result (n; m; ¾ ))is the set of enabled transi-
tions after ¯ring ¾2t¤.
the incidence matrix of a petri net can be used for di®erent types of analysis,
e.g., based on ~nit is possible to e±ciently calculate place and transition invari-
ants and to provide minimal (but not su±cient) requirements for the reachability
of a marking. it is important to see that result (n; m; ¾ ) does not need to yield a
valid marking, i.e., there may be a place psuch that result (n; m; ¾ )(p)<0 indi-
cating a negative number of tokens. if ( n; m )[¾i(n; m0), then result (n; m; ¾ ) =
m0. however, the reverse does not need to be the case. enabled (n; m; ¾ ) cal-
culates which transitions are enabled after ¯ring each transition¡ !¾times using
function result and the earlier de¯ned function enabled (cf. de¯nition 2). it may
be the case that while executing ¾starting from ( n; m ), transitions were forced
to be ¯red although they were not enabled. as a result, places may get a neg-
ative number of tokens. the reason we need such concepts is because we will
later compare petri nets with some observed behavior. in such situations, we
need to be able to deal with transitions that were observed even if they were not
enabled.
1note that ¾does not need to be enabled, i.e., transitions are forced to ¯re even if
they are not enabled. also note that we do not explicitly distinguish row and column
vectors.4 naive approaches
in this paper we propose to compare two processes on the basis on some event log
containing typical behavior. however, before presenting this approach in detail,
we ¯rst discuss some naive approaches.
4.1 equivalence of processes based on their structure
when humans compare process models they typically compare the graphical
structure, i.e., do the same activities (transitions in petri net terms) appear
in both models and do they have similar connections. clearly, the graphical
structure may be misleading: two models that super¯cially appear similar may
be very di®erent. nevertheless, the graphical structure is an indicator that may
be used to quantify similarity. let us abstract from the precise split and join
behavior (i.e., we do not distinguish between and/xor-splits/joins). in other
words, we derive a simple graph where each node represents an activity and each
arc some kind of connection. for example, the petri net shown in figure 1(a)
is reduced to a graph with nodes a,b,c,dande, and arcs ( a; b), (a; c),
(a; d), (b; e), (c; e) and ( d; e). for the other petri nets models in figure 1
a similar graph structure can be derived. it is easy to see that each of the
four process models has a di®erent graph structure. however, there are many
overlapping connections, e.g., all models have arc ( a; c). this suggests that
from a structural point of view the models are not equivalent but similar. when
quantifying the overlap relative to the whole model we can take the perspective
of the ¯rst model or the second model. this leads to the de¯nition of precision
andrecall as speci¯ed below.2
de¯nition 4 (structural precision and recall). letn1= (p1; t1; f1)and
n2= (p2; t2; f2)be two petri nets. using c1=f(t1; t2)2t1£t1jt1n1²\n1²
t26=;gandc2=f(t1; t2)2t2£t2jt1n2²\n2²t26=;g, we de¯ne:
precisions(n1; n2) =jc1\c2j
jc2jrecalls(n1; n2) =jc1\c2j
jc1j
precisions(n1; n2) is the fraction of connections in n2that also appear in n1. if
this value is 1, the precision is high because all connections in the second model
exist in the ¯rst model. recalls(n2; n1) is the fraction of connections in n1that
also appear in n2. if this value is 1, the recall is high because all connections
in the ¯rst model appear in the second model. note that here we think of n1
as the \original model" and n2as some \new model" that we want to compare
with the original one.
letna,nb,nc, and ndbe the four petri nets shown in figure 1. precisions
(na; nb) =3
5= 0:6.recalls(na; nb) =3
6= 0:5. note that precisions(n1; n2) =
recalls(n2; n1) by de¯nition for any pair of petri nets n1andn2. therefore,
2these metrics are an adaptation of the precision and recall metrics in [14].we only list some precision values: precisions(na; nb) = 0 :6,precisions(na;
nc) = 4 =4 = 1 :0,precisions(na; nd) = 6 =8 = 0 :75,precisions(nb; na) = 3 =6 =
0:5,precisions(nb; nc) = 2 =4 = 0 :5,precisions(nb; nd) = 3 =8 = 0 :375, etc. if
we consider nato be the initial model, then nchas the best precision of the
other three models because all connections in ncalso appear in na. moreover,
if we consider nato be the initial model, then ndhas the best recall because
all connections in naalso appear in nd.
p6
(a) (b) (c) (d)a
c b
dp1
p2 p3
p5 p4
p6a
c b
dp1
p2
p3
p4a
c b
dp1
p2 p3
p5 p4
p7a
c b
dp1
p2 p3
p4
p5a
fig. 2. although the connection structures of (a) and (b) are similar they are quite
di®erent in terms of behavior. moreover, the connection structure of (a) and (c) di®ers
while the corresponding behaviors are identical.
the precision and recall ¯gures for the four process models in figure 1 seem
reasonable. unfortunately, models with nearly identical connections may be quite
di®erent as is shown in figure 2. let na,nb,nc, and ndbe the four petri nets
shown in figure 2.3although precisions(na; nb) =recalls(na; nb) = 1, naand
nbare clearly di®erent. in natransitions bandcare executed concurrently
while in nba choice is made between these two transitions. however, although
naandncare structurally di®erent ( precisions(na; nc) = 4 =5 = 0 :8), they have
identical behaviors. these examples show that de¯nition 4 does not provide a
completely satisfactory answer when it comes to process equivalence. neverthe-
less,precisions(n1; n2) and recalls(n1; n1) can be used as rough indicators for
selecting a similar model, e.g., in a repository of reference models.
3note that strictly speaking nddoes not correspond to a petri net as de¯ned in
de¯nition 1, because there are two transitions a. however, it is easy to extend
de¯nition 1 to so-called labeled petri nets where di®erent transitions can have the
same label.4.2 equivalence of processes based on their state space or traces
since process models with a similar structure may have very di®erent behaviors
and models with di®erent structures can have similar behaviors, we now focus
onquantifying the equivalence of processes based on their actual behaviors . we
start with a rather naive approach where we de¯ne recall and precision based
on the full ¯ring sequences of two marked petri nets.
de¯nition 5 (naive behavioral precision and recall). letn1= (p1; t1; f1)
andn2= (p2; t2; f2)be two petri nets having initial markings m1andm2
respectively. moreover, let the corresponding two sets of possible full ¯ring se-
quences be ¯nite:
s1=f¾2t¤
1j 9m02i b(p1)(n1; m1)[¾i(n1; m0)^enabled (n1; m0) =;gand
s2=f¾2t¤
2j 9m02i b(p2)(n2; m2)[¾i(n2; m0)^enabled (n2; m0) =;g.
precisionb((n1; m1);(n2; m2)) =js1\s2j
js2j
recallb((n1; m1);(n2; m2)) =js1\s2j
js1j
clearly, the initial markings of n1andn2are highly relevant. however, if these
are clear from the context, we do not explicitly mention these, i.e., precisionb
(n1; n2) =precisionb((n1; m1);(n2; m2)) and recallb(n1; n2) =recallb((n1;
m1);(n2; m2)).
letna,nb,nc, and ndbe the four petri nets shown in figure 2 and sa,sb,
sc, and sdtheir corresponding full ¯ring sequences. sa=fha; b; c; d i;ha; c; b;
dig,sb=fha; b; d i;ha; c; d ig,sc=sa, and sd=sb. hence, precisionb(na;
nb) = 0 and recallb(na; nb) = 0, i.e., the models are considered to be com-
pletely di®erent because there are no identical full ¯ring sequences possible in
both models. however, precisionb(na; nc) = 1 and recallb(na; nc) = 1 and
precisionb(nb; nd) = 1 and recallb(nb; nd) = 1.
we can also consider the four process models in figure 1. the fourth model
(nd) has an in¯nite set of full ¯ring sequences. therefore, we focus on the ¯rst
three models: na,nb, and nc. let us ¯rst compare naandnb:precisionb(na; nb)
= 2=2 = 1 and recallb(na; nb) = 2 =4 = 0 :5, i.e., all full ¯ring sequences in nb
are possible in nabut not the other way around. although ncdi®ers from
nb, the precision and recall values are identical when comparing with na, i.e.,
precisionb(na; nc) = 1 and recallb(na; nc) = 0 :5.
these examples show that de¯nition 5 provides another useful quanti¯cation
of equivalence quite di®erent from de¯nition 4. however, also this quanti¯cation
has a number of problems:
1.the set of full ¯ring sequences needs to be ¯nite . this does not need to be
the case as is illustrated by the petri net shown in figure 1(d).2.the models need to be terminating , i.e., it should be possible to end in a
dead marking representing the completion of the process. note that models
may have unintentional livelocks or are designed to be non-terminating. for
such models, we cannot apply de¯nition 5 in a meaningful way.
3.de¯nition 5 does not take into account di®erences in importance (i.e., fre-
quently visited parts of the model are probably more important). for ex-
ample, certain full ¯ring sequences may have a very low probability in com-
parison to other sequences that occur more frequent . clearly this should be
taken into account.
4.fourth, de¯nition 5 appears to be too rigid, i.e., one di®erence in a full ¯ring
sequence invalidates the entire sequence. in figure 2 precisionb(na; nb) = 0
andrecallb(na; nb) = 0 although both models always start with aand end
with d.
5.themoment of choice is not taken into account in de¯nition 5, i.e., essen-
tially trace equivalence is used as a criterion. many authors [1, 11, 13] have
emphasized the importance of preserving the moment of choice by de¯ning
notions such as observation equivalence, bisimilarity, branching/weak bisim-
ilarity, etc. to illustrate the importance of preserving the moment of choice,
consider nbandnddepicted in figure 2. although precisionb(nb; nd) = 1
andrecallb(nb; nd) = 1, most environments will be able to distinguish both
processes. in nbin figure 2(b) there is no state where only bor just cis
enabled. however, such states exist in ndin figure 2(d), e.g., there can be
a token in p2 enabling only b. suppose that bandccorrespond to the
receipt of di®erent messages sendt by some environment. in this case, nd
potentially deadlocks, e.g., a message for bcannot be handled because the
system is waiting for c(i.e., p3 is marked). such a deadlock is not possible
innb.
the problems listed above show that similarity metrics based on criteria directly
comparing all possible behaviors in terms of traces are of little use from a practi-
cal point of view. an alternative approach is to compare the state spaces rather
than the sets of traces. for example, trying to establish a bisimulation relation
where states are related in such a way that any move of one process model can
be followed by the other one and vice versa [1, 11, 13]. however, this would only
solve some of the problems listed above. moreover, the notion of state often only
exists implicitly and it is very di±cult to extend more re¯ned equivalence no-
tions to include probabilities (cf. [6, 8]). therefore, we propose another approach
as presented in the next section.
5 equivalence of processes in the context of observed
behavior
to overcome the problems highlighted so far, we propose an approach that uses
exemplary behavior to compare two models. this exemplary behavior can be
obtained on the basis of real process executions (in case the process alreadyexists), user-de¯ned scenarios, or by simply simulating one of the two models
(or both). we assume this exemplary behavior to be recorded in an event log .
de¯nition 6 (event log). an event log lis a multi-set of sequences on some
set of t, i.e., l2i b(t¤).
an event log can be considered as a multi-set of full ¯ring sequences (cf. de¯-
nition 5). however, now these sequences may exist independent of some model
and the same sequence may occur multiple times.
before comparing two process models using an event log, we ¯rst de¯ne the
notion of ¯tness . this notion is inspired by earlier work on genetic mining and
conformance checking [12, 17].
de¯nition 7 (fitness). let(n; m )be a marked petri net and let l2i b(t¤)
be a multi-set over t.4
¯tness ((n; m ); l) =
(x
¾2ll(¾)
j¾jjfi2 f0;j¾j ¡1g j¾(i+ 1)2enabled (n; m; hd(¾; i))gj)=jlj
¯tness ((n; m ); l) yields a number between 0 and 1. note that per sequence
¾2lwe calculate the number of times that a transition that was supposed
to ¯re according to ¾was actually enabled. this is divided by j¾jto yield a
number between 0 and 1 per sequence. this number shows the \¯t" of ¾. this
is repeated for all ¾2l. since the same sequence may appear multiple times
inl(i.e., l(¾)>1), we multiply the result for ¾with l(¾) and divide by
jlj. de¯nition 7 assumes that jlj>0 and j¾j>0. this is not a fundamental
restriction, if such strange cases occur (empty event log or an empty sequence),
then we can simply assume that 0 =0 = 0.
as an example, consider the event log lshown in figure 1(f) containing 160
traces. clearly, ¯tness (na; l) = 1 because all sequences in lcan be reproduced
byna.5moreover, ¯tness (nb; l) = (40 + 85 + (15 ¤3=4) + (20 ¤3=4))=160 =
0:945, ¯tness (nc; l) = ((40 ¤1=2) + 85 + (15 ¤1=2) + 20) =160 = 0 :828, and
¯tness (nd; l) = 1. these examples show that de¯nition 7 matches our intuitive
understanding of ¯tness. it is important to note that transitions are \forced"
to ¯re even if they are not enabled , cf. de¯nition 3. moreover, a particular se-
quence can be \partly ¯tting", e.g., if we parse sequence ha; b; d; e iusing
ncin figure 1(c), half of the sequence ¯ts. when forcing the execution of
ha; b; d; e iusing nc,ais initially enabled. however, bis not enabled and
does not even exist in the model. nevertheless, in the resulting state dis still
enabled. however, after ¯ring d, the last event in the sequence ( e) is not en-
abled. hence, only two of the four events in ha; b; d; e iare actually enabled,
4note that not all events in the log need to correspond to actual transitions. these
events are simply ignored, i.e., we assume enabled (n; m; ¾ ) to be de¯ned properly
even if not all transitions in ¾actually appear in n.
5note that again we omit the initial marking if it is clear from the context, i.e.,
¯tness (na; l) =¯tness ((na;[p1]); l).resulting in a ¯tness of 0.5. note that it is better to look at individual events
rather than considering whole sequences like in de¯nition 5. using de¯nition 7,
¯tness (nc; l) = 0 :828. however, if we would focus on completely ¯tting se-
quences, ¯tness (nc; l) = (0 + 85 + 0 + 20) =160 = 0 :656, i.e., considerably lower
because partly ¯tting are ignored.
inspired by the de¯nition of ¯tness, we would like to compare twomodels
on the basis of a log. a straightforward extension of de¯nition 7 to two models
is to compare the overlap in ¯tting or partially ¯tting sequences. however, in
this case one only considers the actual behavior contained in the log. therefore,
we go one step further and look at the enabled transitions in both models and
compare these, i.e., we do not just check whether an event in some sequence is
possible, but also take into account all enabled transitions at any point in the
sequence . this idea results in the following de¯nition of precision and recall.
de¯nition 8 (behavioral precision and recall). let(n1; m1)and(n2; m2)
be marked petri nets and let l2i b(t¤)be a multi-set over t.6
precision ((n1; m1);(n2; m2); l) =
(x
¾2ll(¾)
j¾j(j¾j¡1x
i=0jenabled (n1; m1;hd(¾; i))\enabled (n2; m2;hd(¾; i))j
jenabled (n2; m2;hd(¾; i))j) )=jlj
recall ((n1; m1);(n2; m2); l) =
(x
¾2ll(¾)
j¾j(j¾j¡1x
i=0jenabled (n1; m1;hd(¾; i))\enabled (n2; m2;hd(¾; i))j
jenabled (n1; m1;hd(¾; i))j) )=jlj
to explain the concept consider a log l=f(ha; b; c; d i;2);(ha; c; b; d i;1)g
and the ¯rst three petri nets shown in figure 2. precision (na; nb; l) = ((2 =4¤
(1=1 + 2 =2 + 0 =1 + 1 =1)) + (1 =4¤(1=1 + 2 =2 + 0 =1 + 1 =1)))=3 = 0 :75 and
recall (na; nb; l) = ((2 =4¤(1=1 + 2=2 + 0=1 + 1=1)) + (1 =4¤(1=1 + 2=2 + 0=1 +
1=1)))=3 = 0 :75.precision (na; nc; l) =recall (na; nc; l) = 1.
we can also consider the four process models in figure 1 with respect to
the logs shown in figure 1(f). precision (na; nb; l) = ((40 =4¤(1=1 + 2 =2 +
1=1 + 1 =1)) + (85 =4¤(1=1 + 2 =2 + 1 =1 + 1 =1)) + (15 =4¤(1=1 + 2 =2 + 2 =3 +
1=1)) + (20 =4¤(1=1 + 2 =2 + 2 =3 + 1 =1)))=160 = 0 :98 and recall (na; nb; l) =
((40=4¤(1=1 + 2 =3 + 1 =1 + 1 =1)) + (85 =4¤(1=1 + 2 =3 + 1 =1 + 1 =1)) + (15 =4¤
(1=1 + 2 =3 + 2 =2 + 1 =1)) + (20 =4¤(1=1 + 2 =3 + 2 =2 + 1 =1)))=160 = 0 :92. note
that both numbers would be lower if the sequences starting with ha; d; : : : i
would be more frequent. let us now compare naandndin figure 1 using l.
precision (na; nd; l) = ((40 =4¤(1=1+3=3+1=1+1=2))+(85 =4¤(1=1+3=3+1=1+
1=2))+(15 =4¤(1=1+3=3+2=3+1=2))+(20 =4¤(1=1+3=3+2=3+1=2)))=160 = 0 :75
6note that the two denominators jenabled (n2; m2;hd(¾; i))jand
jenabled (n1; m1;hd(¾; i))jmay evaluate to zero. in these case, the numerator
is also zero. again, we assume in such cases that 0 =0 = 0.andrecall (na; nd; l) = ((40 =4¤(1=1+3=3+1=1+1=1))+(85 =4¤(1=1+3=3+1=1+
1=1))+(15 =4¤(1=1+3=3+2=2+1=1))+(20 =4¤(1=1+3=3+2=2+1=1)))=160 =
1. note that ndallows for behavior not present in log l(i.e., executing f).
nevertheless, as we can see from precision (na; nd; l) = 0 :75, the enabling of f
is taken into account. it is also easy to see that de¯nition 8 takes into account the
moment of choice, i.e., the enabling of set of transitions is the basis of comparison
rather than the resulting sequences. hence, we can distinguish nbandndin
figure 2.7
in section 4.2 we listed ¯ve problems related to the use of de¯nition 5. it is
easy to see that de¯nition 8 addresses each of these problems:
1.even models with an in¯nite set of ¯ring sequences can be compared using
a ¯nite, but representative, set of traces.
2.models do not need to be terminating.
3.di®erences between frequent and infrequent sequences can be taken into
account by selecting a representative log.
4.partial ¯ts are taken into account, i.e., small local di®erences do not result
in a complete \mis¯t".
5.the moment of choice is taken into account because the focus is on enabling.
given the attractive properties of the precision and recall metrics de¯ned in
de¯nition 8, we have implemented these metrics in the prom framework [9].8
here it has been applied to a variety of process models. in particular the context
of genetic mining [3].
one the of critical success factors is the availability of some log lthat can
serve as a basis for comparison. we propose to use existing event logs or to
generate arti¯cial logs using simulation .
existing logs can be extracted from information systems but can also be
obtained by manually describing some typical scenarios. it is important to re-
alize that today's information systems are logging a wide variety of events. for
example, any user action is logged in erp systems like sap r/3, work°ow
management systems like sta®ware, and case handling systems like flower.
classical information systems have some centralized database for logging such
events (called transaction log or audit trail). modern service-oriented architec-
tures record the interactions between web services (e.g., in the form of soap
messages). moreover, today's organizations are forced to log events by national
or international regulations (cf. the sarbanes-oxley (sox) act that is forcing
organizations to audit their processes).
an example application scenario where existing event logs are used is the
comparison of an existing process and a set of possible redesigns. for each of
the redesigns, we can measure the precision and recall taking an event log of the
existing information system as a starting point. first of all, the existing process
7note that ndcontains duplicate labels, i.e., two transitions with label a. however,
it is possible to extend de¯nition 8 and the resulting approach for such models.
8prom and the analysis plug-in implementing the precision and recall metrics can be
downloaded from www.processmining.org.can be compared with this event log using the ¯tness notion presented in this
section. this gives an indication of the quality of the initial model. then, if the
quality is acceptable, each of the redesigns can be compared with the existing
process using this log.
another approach would be to use simulation. this simulation could be based
on both models or just the initial model. note that the generated logs do not need
to be complete, because de¯nition 8 also takes the enabling into account. it is
more important that the probabilities are taken into account, because di®erences
in the frequently visited parts of the model are of less importance than di®erences
in rarely visited parts of the model.
6 conclusion
this paper presented a novel approach to compare process models. existing
approaches typically do not quantify equivalence, i.e., models are equivalent or
not. however, for many practical applications such an approach is not very useful,
because in most real-life settings we want to distinguish between marginally
di®erent processes and completely di®erent processes. we have proposed and
implemented notions of ¯tness ,precision , and recall in the context of the prom
framework. the key di®erentiator is that these notions take an event log with
typical execution sequences as a starting point. this allows us to overcome many
of the problems associated with approaches directly comparing processes at the
model level. although our approach is based on petri nets, it can be applied to
other models with executable semantics, e.g., formalizations of epcs, bpmn,
or uml activity diagrams.
future work will focus on the application of the concepts and tools presented
in this paper. we have already applied the approach in the context of process
mining. genetic algorithms have been evaluated using notions of precision and
recall [3]. however, these notions can be applied in a wide variety of situations,
e.g., to measure the di®erence between an organization speci¯c process model
and a reference model, to select a web service that ¯ts best based on some
description (e.g., pips or abstract bpel), to compare medical guidelines, or to
compare an existing process model with some redesign.
references
1.w.m.p. van der aalst and t. basten. inheritance of work°ows: an approach
to tackling problems related to change. theoretical computer science , 270(1-
2):125{203, 2002.
2.w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. genetic
process mining. in g. ciardo and p. darondeau, editors, applications and theory
of petri nets 2005 , volume 3536 of lecture notes in computer science , pages
48{69. springer-verlag, berlin, 2005.
3.w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. process
equivalence in the context of genetic mining. bpm center report bpm-06-15,
bpmcenter.org, 2006.4.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
5.e. best and m.w. shields. some equivalence results for free choice nets and simple
nets, and on the periodicity of live free choice nets. in w. brauer, w. reisig, and
g. rozenberg, editors, proceedings of caap '83 , volume 159 of lecture notes in
computer science , pages 141{154. springer-verlag, berlin, 1987.
6.f. van breugel. a behavioural pseudometric for metric labelled transition sys-
tems. in 16th international conference on concurrency theory (concur 2005) ,
volume 3653 of lecture notes in computer science , pages 141{155. springer-
verlag, berlin, 2005.
7.j. desel. validation of process models by construction of process nets. in w.m.p.
van der aalst, j. desel, and a. oberweis, editors, business process management:
models, techniques, and empirical studies , volume 1806 of lecture notes in com-
puter science , pages 110{128. springer-verlag, berlin, 2000.
8.j. desharnais, v. gupta, r. jagadeesan, and p. panangaden. metrics for labelled
markov processes. theoretical computer science , 318(3):323{354, 2004.
9.b. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters, and
w.m.p. van der aalst. the prom framework: a new era in process mining tool
support. in g. ciardo and p. darondeau, editors, application and theory of petri
nets 2005 , volume 3536 of lecture notes in computer science , pages 444{454.
springer-verlag, berlin, 2005.
10.m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems: bridging people and software through process technology . wiley
& sons, 2005.
11.r.j. van glabbeek and w.p. weijland. branching time and abstraction in bisim-
ulation semantics. journal of the acm , 43(3):555{600, 1996.
12.a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic pro-
cess mining: a basic approach and its challenges. in c. bussler et al., editor,
bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 203{215. springer-verlag, berlin,
2006.
13.r. milner. a calculus of communicating systems , volume 92 of lecture notes in
computer science . springer-verlag, berlin, 1980.
14.s.s. pinter and m. golani. discovering work°ow models from activities lifespans.
computers in industry , 53(3):283{296, 2004.
15.l. pomello, g. rozenberg, and c. simone. a survey of equivalence notions of
net based systems. in g. rozenberg, editor, advances in petri nets 1992 , volume
609 of lecture notes in computer science , pages 420{472. springer-verlag, berlin,
1992.
16.w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
17.a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,
bpm 2005 workshops (workshop on business process intelligence) , volume 3812
oflecture notes in computer science , pages 163{176. springer-verlag, berlin,
2006.