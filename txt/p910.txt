automatic discovery of object-centric behavioral
constraint models
guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
eindhoven university of technology, p.o. box 513, 5600 mb, eindhoven, the netherlands.
g.li.3@tue.nl ,r.carvalho@tue.nl ,w.m.p.v.d.aalst@tue.nl
abstract. process discovery techniques have successfully been applied in a
range of domains to automatically discover process models from event data. un-
fortunately existing discovery techniques only discover a behavioral perspective
of processes, where the data perspective is often as a second-class citizen. be-
sides, these discovery techniques fail to deal with object-centric data with many-
to-many relationships. therefore, in this paper, we aim to discover a novel mod-
eling language which combines data models with declarative models, and the
resulting object-centric behavioral constraint model is able to describe processes
involving interacting instances andcomplex data dependencies . moreover we
propose an algorithm to discover such models.
keywords: process miningobject-centric modeling process discoverycar-
dinality constraints
1 introduction
process discovery is one of the most challenging process mining tasks. however, state
of the art techniques can already deal with situations where each process instance is
recorded as a case with ordered events and each event is related to exactly one case by
a case identiﬁer [1]. examples of algorithms that consider process instances to derive
models include the inductive miner, ilp miner, heuristic miner and declare miner,
distributed as prom plugins.1all examples extract models from behavior-centric logs
(e.g., xes logs). moreover, there are already over 20 commercial software products
supporting process mining (e.g., disco, celonis, processgold, qpr, etc.).
however, when it comes to data-centric/object-centric processes supported by crm
and erp systems, most of the existing discovery techniques fail. such systems have
one-to-many and many-to-many relationships between data objects that makes it im-
possible to identify a unique process instance notion to group traces. if we enforce such
a grouping anyway, it leads to convergence and divergence problems. besides, the dis-
covered models using existing approaches are often based on business process modeling
languages such as petri nets, bpmn diagrams, workﬂow nets, epcs, and uml activity
diagrams. they typically consider process instances in isolation, ignoring interactions
in between. moreover, they cannot model the data perspective in a precise manner. data
objects can be modeled, but the more powerful constructs (e.g., cardinality constraints)
1http://www.processmining.org/prom/start2 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
used in entity-relationship (er) models [5], uml class models [9] and object-role
models (orm) [10] cannot be reﬂected at all in today’s process models. as a result,
data and control-ﬂow need to be described in separate diagrams.
numerous approaches in literature tried to solve the problems mentioned above.
various techniques of colored petri nets , i.e., petri nets where tokens have a value, are
employed to add data to process models [23, 8, 7, 13, 14]. these approaches do not sup-
port explicit data modeling, i.e., there is no data model to relate entities and activities.
the earliest approaches that explicitly related process models and data models were
proposed in the 1990s [22, 11]. one example is the approach by kees van hee [11]
who combined petri nets, a speciﬁcation, and a binary data model. other approaches
such as data-aware process mining discovery techniques [17, 21] extend the control-
ﬂow perspective with the data perspective. they discover the control-ﬂow perspective
of processes, using one of the process discovery techniques available today (e.g., induc-
tive mining techniques), and then the data perspective (e.g., read and write operations,
decision points and transition guards) using standard data mining techniques. these
techniques mainly focus on control-ﬂow perspective, considering the data perspective
as a second-class citizen. artifact-centric approaches [6, 12, 15, 18] (including the work
on proclets [2]) attempt to describe business processes in terms of so-called business
artifacts. artifacts have data and lifecycles attached to them, thus relating both perspec-
tives. there are a few approaches to discover artifact-centric models from data-centric
processes [19, 16, 20]. however, these force users to specify artifacts as well as a single
instance notion within each artifact, and tend to result in complex speciﬁcations that are
not fully graphical and distribute the different instance types over multiple diagrams.
this paper uses a novel modeling language, named object-centric behavioral con-
straint (ocbc) , that combines declarative language ( declare [4]), and data/object mod-
eling techniques (er, uml, or orm) [3]. cardinality constrains are used as a unifying
mechanism to tackle data and behavioral dependencies, as well as their interplay. be-
sides motivating that the novel language is useful for modeling data-centric processes,
we also propose an algorithm for discovering ocbc models from event data lacking a
clear process instance notion. by doing this, we demonstrate that this novel modeling
language has potential to be used as an alternative to mainstream languages for all kinds
of process mining applications.
the remainder is organized as follows. section 2 presents a process to introduce
ocbc models. section 3 illustrates the ingredients of ocbc models. our discovery
algorithm is proposed in section 4. section 5 shows some experimental results showing
the validity of our approach and implementation and section 6 concludes the paper.
2 motivation example
in this section, the order to cash (otc) process, which is the most typical business
process supported by an erp system, is employed to illustrate ocbc models. the otc
process has many variants and our example is based on the scenario in dolibarr .2
2dolibarr erp/crm is an open source (webpage-based) software package for small and
medium companies (www.dolibarr.org). it supports sales, orders, procurement, shipping, pay-
ments, contracts, project management, etc.automatic discovery of object-centric behavioral constraint models 3
create 
paymentcreate 
invoice
order line order1create 
ordercreate 
shipment
customer11
111 22 33 5566 7788
99 1
1 11..* 1..*1
**invoice shipment payment
0..1
1*1 1..* 1..*
*1..* 1..*
*441
11 1
1..*
fig. 1. a small object-centric behavioral constraint (ocbc) model.
figure 1 shows an ocbc model which describes the otc process in dolibarr. the
top part shows behavioral constraints. these describe the ordering of activities ( create
order ,create invoice ,create payment , and create shipment ). the bottom part describes
the structuring of objects relevant for the process, which can be read as if it was a uml
class diagram (with six object classes order ,order line ,invoice ,payment ,shipment , and
customer ). note that an order has at least one order line, each order line corresponds to
precisely one shipment, each order refers to one or more invoices, each invoice refers
to one or more payments, each order, shipment or invoice refers to one customer, etc.
the middle part relates activities, constraints, and classes.
the notation will be explained in more detail later. however, to introduce the main
concepts, we ﬁrst informally describe the 9 constructs highlighted in figure 1. con-
struct 3indicates a one-to-one correspondence between order objects and create order
events. if an object is added to the class order , the corresponding activity needs to be
executed and vice versa. 1,2and 5also represent the one-to-one correspondence.
4shows a one-to-many relation between create order events and order line objects.
6expresses that each create invoice event is followed by one or more corresponding
create payment events and each create payment activity is preceded by one or more cor-
responding create invoice events. a similar constraint is expressed by 7.8demands
that each create order event is followed by at least one corresponding create shipment
event. 9denotes that each create shipment event is preceded by precisely one corre-
sponding create order event. note that one payment can cover multiple invoices and
multiple payments can be executed for a particular invoice (i.e., one payment only cov-
ers a part of the invoice). obviously, this process has one-to-many and many-to-many
relations, and it is impossible to identify a single case notion.
the process described in figure 1 cannot be modeled using conventional notations
(e.g., bpmn) because (a) four different types of instances are intertwined and (b) con-
straints in the class model inﬂuence the allowed behavior. moreover, the ocbc model
provides a fullspeciﬁcation of the allowed behavior in a single diagram , so that no
further coding or annotation is needed.4 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
3 object-centric behavioral constraint (ocbc) modeling
language
after introducing ocbc models based on a typical real-life process, we describe the
data perspective and the behavioral perspective, and show how ocbc models relate
both perspectives. see [3] for the formal deﬁnition of the ocbc language.
3.1 modeling data cardinality constraints
in this paper, the term “object” is different from it used in other ﬁelds, such as software
engineering. in general, objects are data elements generated and used by information
systems. these are grouped in classes and have some attributes. for example, a record
in the “order” table can be considered as an object of class “order”. each value (e.g., a
customer name “mary”) in the record can be considered as an attribute of the object.
cardinalities indicates non-empty sets of integers, i.e., “ 1::” denotes the set of pos-
itive integersf1;2; :::g. objects may be related and cardinality constraints help to struc-
ture dependencies. as shown in figure 2(a), we use a subset of mainstream notations
to specify a class model with temporal annotations such as “eventually” cardinalities
(indicated by}) and “always” cardinalities (indicated by ).3
ac
br2
r1
a bc
r2
r1r1r1r2
r2
(a) class model (b) object modelb3b1c2
c1
b2a1
a21..* 11
1..*
fig. 2. example of a class model and corresponding object model.
a class model contains a set of object classes ( oc) and a set of relationship types
(rt). relationship types are directed (starting from source classes and pointing to tar-
get classes) and each one deﬁnes two cardinality constraints: one on its source side
(close to the source class) and one on its target side (close to the target class).4
the class model depicted in figure 2(a) has three object classes, i.e., oc =
fa;b;cgand two relationship types, i.e., rt =fr1;r2g.r1points to bfrom a, which
indicates ais the source class, bis the target class, and aandbare related through r1.
3indicates the constraint should hold at any point in time and }indicates the constraint
should hold from some point onwards.
4for the sake of brevity, we omit redundant cardinalities in the graph. for instance, “ 1” im-
plies “}1” and therefore “}1” can be removed in this case.automatic discovery of object-centric behavioral constraint models 5
a b ccon1 con2
fig. 3. an example behavioral model with two behavioral cardinality constraints.
the annotation “1::” on the target side of r1indicates that for each object in a, there
is always at least one corresponding object in b. “}1” on the source side of r2indicates
that for each object in b, there is eventually precisely one corresponding object in c.
a class model deﬁnes a “space” of possible object models , i.e., concrete collections of
objects and relations instantiating the class model.
an object model includes a set of objects ( obj) and a set of object relations ( rel).
more precisely, an object relation can be viewed as a tuple consisting of a class rela-
tionship type, a source object and a target object. for instance, (r1; a1; b1)is an object
relation, with r1as its name, a1as the source object, b1as the target object, and a1and
b1are related through r1. note that each object has a corresponding object class, e.g.,
a1corresponds to the object class a.
figure 2(b) shows an object model. the objects are depicted as grey dots: obj =
fa1;a2;b1;b2;b3;c1;c2g. among them, a1anda2belong to object class a;b1,b2and
b3belong to object class b;c1andc2belong to object class c. there are three relations
corresponding to relationship r1(e.g., (r1;a1;b1)), and three relations corresponding
to relationship r2(e.g., (r2;c1;b1)).
3.2 modeling behavioral cardinality constraints
a process model can be viewed as a set of constraints . for example, in a procedural
language like petri nets, places correspond to constraints: removing a place may allow
for more behavior and adding a place can only restrict behavior. in this paper, we will
employ a graphical notation inspired by declare , a declarative workﬂow language [4].
figure 3 shows two example behavioral constraints: con 1andcon 2. each constraint
corresponds to one constraint type. table 1 shows eight examples of constraint types.
constraint con 1is aresponse constraint and constraint con 2is aunary-response con-
straint. the graphical representations of the eight example constraint types are shown
in figure 4. besides the example constraint types, we allow for any constraint type that
can be speciﬁed in terms of the cardinality of preceding and succeeding target events
relative to a collection of reference events . as a shorthand, one arrow may combine two
constraints as shown in figure 5. for example, constraint con 56states that after creating
an order there is precisely one validation and before a validation there is precisely one
order creation.
given some reference event ewe can reason about the events before eand the events
aftere. one constraint type may require that the number of corresponding events of one
particular reference event before or after the event lies within a particular range (e.g.,
before>0 and after>1 for response ). for instance, constraint con 1speciﬁes that each
aevent should be succeeded by at least one corresponding bevent and constraint con 2
speciﬁes that each bevent should be succeeded by precisely one cevent.6 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
table 1. examples of constraint types, inspired by declare . note that a constraint is deﬁned with
respect of a reference event.
constraint formalization
responsef(before ;after )2i ni njafter1g
unary-response f(before ;after )2i ni njafter = 1g
non-response f(before ;after )2i ni njafter = 0g
precedence f(before ;after )2i ni njbefore1g
unary-precedence f(before ;after )2i ni njbefore = 1g
non-precedence f(before ;after )2i ni njbefore = 0g
co-existencef(before ;after )2i ni njbefore +after1g
non-co-existencef(before ;after )2i ni njbefore +after = 0g
before ≥ 0 and after ≥ 1
before ≥ 0 and after = 1
before ≥ 0 and after = 0
before ≥ 1 and after ≥ 0
before = 1 and after ≥ 0
before = 0 and after ≥ 0
before + after ≥ 1
before = 0 and after = 0
(response )
(unary -response )
(non -response )(precedence )
(unary -precedence )
(non -precedence )(co-existence )
(non -coexistence )
fig. 4. graphical notation for the example constraint types deﬁned in table 1. the dot on the left-
hand side of each constraint refers to the reference events .target events are on the other side that
has no dot. the notation is inspired by declare , but formalized in terms of cardinality constraints
rather than ltl.
abehavioral constraint model is a collection of activities and constraints. more
precisely, a constraint corresponds to a constraint type, a reference activity and a target
activity. figure 3 displays a behavioral model consisting of two constraints ( con 1and
con 2) and three activities ( a,bandc). each constraint has a dot referring to the
reference activity . the corresponding target activity can be found on the other side. for
example, the reference activity of con 2isb(see dot) and the target activity of con 2is
c. the shape (e.g., a double-headed arrow) of each constraint indicates the constraint
type. for instance, con 1has a dot on the left side and a double-headed arrow on the right
side, which means the corresponding constraint type is response , the reference activity
isaand the target activity is b.
3.3 object-centric behavioral constraints
section 3.1 focused on structuring objects and formalizing cardinality constraints on
object models (i.e., classical data modeling) while section 3.2 focused on control-ﬂow
modeling and formalizing behavioral constraints without considering the structure of
objects. this subsection relates both perspectives by combining control-ﬂow modeling
and data modeling to fully address the challenges described in the introduction.automatic discovery of object-centric behavioral constraint models 7
equalscreate
 ordercreate 
invoice
create
 ordervalidate
 orderequalscreate
 ordercreate 
invoicecon3
create
 ordervalidate
 ordercon5con4
con6con34
con56
fig. 5. an arrow with two reference events ( ) can be used as a shorthand. constraint con 34
(con 56) corresponds to the conjunction of constraints con 3andcon 4(resp. con 5andcon 6).
a
(create order)b
(wrap item)c
(deliver items)
b
(order line)a
(order)c
(delivery)1 1..* 1..*1
11..*10..1 1
1
r1 r2con1 con2activity constraint
object classeach “a” event 
refers to precisely 
one “a” objectrelationship 
between activities 
and classesindicating the 
reference eventconstraint relation
(used to determine target events related 
to the reference event)each “b” object always refers to at 
most one “b” event and eventually refers 
to precisely one “b” event
1
relationship 
typearrow points to 
the target classeach “a” object 
always refers to at least 
one “b” objecteach “b” object 
eventually refers to precisely 
one “c” object11indicating the 
constraint type
cr1 cr2
fig. 6. an example model illustrating the main ingredients of ocbc models.
we use so-called aoc relationships (denoted by a dotted line between activities
and classes) and constraint relations (denoted by a dashed line between behavioral con-
straints and classes or class relationships) to combine the behavioral constraint model
in figure 3 with the class model in figure 2, resulting in the complete example ocbc
model in figure 6. for better understanding, we attach a scenario on the model. for
example, activity acorresponds to create order activity while class acorresponds to
class order .
the example model has four aoc relationships, i.e., aoc =f(a;a);
(a;b);(b;b);(c;c)g.5note that arefers to object classes aandbwhile brefers to ac-
tivities aandb. this shows that ocbc models are capable of modeling one-to-many
and many-to-many relationships between events and objects. aoc relationships also
have cardinalities. the (}) cardinalities on the activity side deﬁne how many events
there always (eventually) need to be for each object. the cardinalities on the class side
5in this paper, we use the upper-case (lower-case) letters to express activities (classes), and use
the upper-case (lower-case) letters with a footnote to express events (objects).8 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
(withoutor}symbols) deﬁne how many objects there need to be for each event
when the event occurs.
constraint relations deﬁne the scope of each constraint thereby relating reference
events to selected target events. if a constraint relation connects a constraint to a class,
events are correlated through objects of this class. consider the constraint relation cr1
between con 1andb. let a1be one reference event for con 1(i.e., one create order
event) and a1refers to a set of bobjects (i.e., order line objects). each bevent (i.e.,
wrap item event) that refers to at least one object in the set is the target event of a1
forcr1. if a constraint relation connects a constraint to a relationship, the target events
are related to the reference event through object relations (of this relationship) in the
object model. consider the constraint relation cr2between con 2andr2. letb1be one
reference event for con 2(i.e., one wrap item event) and b1refers to bobjects (i.e., order
lineobjects) which are related to cobject (i.e., delivery objects) through r2relations.
each cevent (i.e., deliver items event) that refers to at least one one of these cobjects
(i.e., delivery objects) is the target event of b1forcr2. note that, indicated by the
example model, b1refers to precisely one bobject that is related to one cobject, which
means b1has precisely one target event.
4 discovery of object-centric behavioral models
in this section, we specify a new format of logs that are object-centric, and propose a
novel algorithm to discover ocbc models based on such logs.
4.1 object-centric event logs
a process is merely a collection of events without assuming some case or process in-
stance notion, and the corresponding event log provides a snapshot of the object model
after each event , where the object model represents the state of the process. such a log
can be extracted from real-life it systems. for instance, the oracle database provides
change tables to record any modiﬁcation in the database. with these tables, it is possible
to reconstruct any previous state of the database. besides, without the change tables, it
is still possible to produce such a log by exploiting explicit change logs in systems like
sap.
in a log, each event corresponds to an object model (in the “object model” column)
which represents the state of the process just after the execution of the event. besides,
each event corresponds to an activity and may have additional attributes , e.g., the time
at which the event took place. moreover, events are atomic and ordered (indicated by the
“index” column). in order to relate the behavioral perspective and the data perspective
(i.e., events and objects), each event also refers to at least one object (in the “reference”
column). logs of this format are called object-centric event logs (denoted as xoc logs
in remainder).
table 2 gives an example xoc log containing 7 events. event a1corresponds to the
ﬁrst occurrence of activity a, has one attribute att1whose value is v1and refers to three
objects: a1,b1, andb2. the corresponding object model of a1consists of three objects
and two object relations. table 2 also illustrates the evolution of the object model. afterautomatic discovery of object-centric behavioral constraint models 9
the occurrence of some event, objects may have been added, and relations may have
been added or removed.6note that the example log has the same scenario as indicated
by the model in figure 6, e.g., activity ameans activity create order and object a1
means an order object.
table 2. an example xoc log
index event activity attributes referencesobject model
objects relations
1a1 afatt1=v1gfa1; b1; b2gfa1; b1; b2gf(r1; a1; b1);(r1; a1; b2)g
2b1 bfatt2=v2gfb1gfa1; b1; b2gf(r1; a1; b1);(r1; a1; b2)g
3b2 bfatt2=v3gfb2gfa1; b1; b2gf(r1; a1; b1);(r1; a1; b2)g
4a2 afatt1=v4gfa2; b3gfa1; a2; b1,
b2; b3gf(r1; a1; b1);(r1; a1; b2),
(r1; a2; b3)g
5b3 bfatt2=v5gfb3gfa1; a2; b1,
b2; b3gf(r1; a1; b1);(r1; a1; b2),
(r1; a2; b3)g
6c1 cfatt3=v6,
att4=v7gfc1gfa1; a2; b1,
b2; b3; c1gf(r1; a1; b1);(r1; a1; b2),
(r1; a2; b3),(r2; c1; b1)g
7c2 cfatt3=v8,
att4=v9gfc2gfa1; a2; b1,
b2; b3; c1,
c2gf(r1; a1; b1);(r1; a1; b2),
(r1; a2; b3),(r2; c1; b1),
(r2; c2; b2),(r2; c2; b3)g
4.2 discovery algorithm
the algorithm takes an xoc log as well as a set of possible behavioral constraint types
as input, which means users can specify the constraint type set based on their needs. in
figure 3 the response andunary-response types were used, but the user can select from
a range of possible types that can be discovered. next, we explain the discovery process
based on the example log.
4.2.1 discovery of class models
in general, the class model is discovered based on the object models in the input log.
figure 2(a) shows the discovered class model from the example log, where oc =
fa; b; cgandrt =fr1; r2g.
oc can be learned by incorporating all classes of all objects in the object models
of all events. for instance, ais a discovered class since object models contain objects of
classa, e.g., a1.rtcan be learned through observing object relations in object models
of each event. r1(having aas the source class and bas the target class) is discovered
since there exist object relations involving r1, e.g., (r1;a1;b1), and each of them has a
object as the source object and bobject as the target object.
6we assume that objects cannot change class or be removed at a later stage to avoid referencing
non-existent objects. objects can be marked as deleted but cannot be removed (e.g, by using
an attribute or relation).10 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
for each relationship, its “always” (“eventually”) cardinalities can be derived
through integrating the number of related objects of each reference object in the ob-
ject model of each (the last) event.7for instance, the discovered “always” cardinality
on the source side of r1is “1” since in the object model of each event, each bobject
has precisely one related aobject, e.g., b1andb2have one related aobject a1. the dis-
covered “eventually” cardinality on the source side of r1is also “1” since in the object
model of the last event (i.e., c2),b1andb2have one related aobject a1while b3has one
related aobject a2(the “eventually” cardinality is omitted on the graph for simplicity).
note that the directly discovered “always” and “eventually” cardinalities on the
target side of r1should bef1;2g, since a1has two related bobjects ( b1andb2) while
a2has one related bobject ( b3). we use a strategy to extend f1;2gtof1;2; :::g, which
will be explained later.
4.2.2 discovery of aoc relationships
after the class model is discovered, we can mine aoc relationships based on the objects
referred to by each event.8the idea is that if an event refers to an object, the activity
of the event refers to the class of the object. for instance, since event a1refers to
three objects a1,b1, and b2, activity arefers to class aandb, which means two aoc
relationship (a; a )and(a; b)can be discovered as shown in figure 6.
for each aoc relationship, its cardinalities on the class side can be achieved by
incorporating numbers of referred objects by each event. consider the cardinality on
the class side of (a; b). since a1has two referred bobjects ( b1andb2) while a2has
one referred bobject ( b3), the directly discovered cardinality is f1;2gand it is extended
tof1;2; :::g. similarly, the “always” (“eventually”) cardinalities on the activity side
can be achieved by incorporating numbers of events referring each reference object
just after every (the last) event happens. consider the cardinality on the activity side
of(b; b). since b1andb2are not referred by any bevent after the ﬁrst event a1
just happens, 0 is an element of the “always” cardinality. after the second event b1
just happens, b1is referred by b1, which adds a new element “1” into the “always”
cardinality. after we check all events, the discovered “always” cardinality is f0;1g. in
terms of the “eventually” cardinality on the activity side of (b; b), we just check the
moment when the last event just happens. since each bobject is referred by precisely
onebevent (i.e., b1is referred by b1,b2is referred by b2andb3is referred by b3),
the discovered “eventually” cardinality is f1g.
4.2.3 discovery of behavioral models
based on the discovered class model and aoc relationships, we can relate events by
7in terms of cardinalities on the source (target) side of a relationship, the objects in the target
(source) class are reference objects.
8there is a reference relation between an event (e.g., a1) and an object (e.g., a1) if and only
if the event refers to the object, denoted as (a1; a1). the reference relations accumulate
along with the occurrence of events. for instance, after a1happens, the set of reference re-
lations isf(a1; a1);(a1; b1);(a1; b2)g; after b1happens, the set of reference relations is
f(a1; a1);(a1; b1);(a1; b2);(b1; b1)gautomatic discovery of object-centric behavioral constraint models 11
objects and discover the constraints between activities. more precisely, each pair of ac-
tivities referring to the same class or two related classes may have potential constraints
in between. the class or the relationship between the two related classes serves as the
intermediary to relate events. note that each potential constraint, e.g., con, between an
activity pair, e.g., (a; b ), takes aas the reference activity and bas the target activity,
and corresponds to a constraint relation which connects the constraint and its interme-
diary. the constraint relation can identify the target events of each reference event for
con(cf. section 3.3). if the relation between each reference event and its target events
satisﬁes the restriction indicated by a constraint type, e.g., response (cf. section 3.2),
the potential constraint conbecomes a discovered constraint which takes response as
the constraint type. consider the activities aandbin figure 6 (assuming the model
does not have behavioral constraints) and the example log. since both aandbrefer to
b, they have potential constraints in-between. if we assume ais the reference activity,
then there are two reference events a1anda2, where a1is followed by two target
events b1andb2, anda2is followed by one target event b3. this relation satisﬁes the
requirement indicated by constraint type response , resulting in a discovered constraint
con 1.
4.3 discussion of model metrics
based on the above three steps, we can discover a model similar to the one shown in fig-
ure 6 from the example log. the ﬁtness of the discovered model is 1. as we mentioned,
we need heuristics to extend the directly discovered cardinalities, e.g., when to replace
f1;2;5;8gby1::? since the directly discovered cardinalities only contain the actual
numbers observed in the log, their quality depends on the size of the log, i.e., if the log is
not large enough to contain complete cardinalities in the process, the discovered model
is overﬁtting. in order to improve generalization, we can extend cardinalities to allow
more possibilities. an extreme example is to extend all directly discovered cardinalities
to “”, which allows all possibilities and makes the model to be underﬁtting.
the difference between the discovered model and the one shown in figure 6 is that
the former one has more behavioral constraints (e.g., a constraint with bas its refer-
ence activity and aas its target activity). in this sense, discovered models tend to have
too many behavioral constraints, since our algorithm discovers all allowed constraints
between each activity pair. this often makes discovered models spaghetti-like. in order
to get more understandable models, we can remove less important constraints based on
the speciﬁc situation. for instance, implied constraints can be removed without losing
ﬁtness and precision.9note that, in general, ﬁltering a model tends to improve (at least
remain) ﬁtness (i.e., more behavior ﬁts the model), decrease complexity (i.e., the model
has fewer edges), improve generalization (i.e., more behavior is allowed) and degrades
precision (i.e., unobserved behaviors in the log may become allowed). based on the
speciﬁc need, one needs to balance between such concerns. our plugin introduced in
next section allows for seamless navigation possibilities to balance ﬁtness, precision
and simplicity.
9the implied constraint by one constraint has the same reference activity, the same target ac-
tivity and refers to the same class or relationship as the constraint as well as allowing more
behavior than the constraint.12 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
5 experiments
the discovery algorithm was validated based on logs extracted from data generated by
the dolibarr erp/crm system when executing the otc (order to cash) process. more
precisely, the data was extracted from 6 tables in the database of dolibarr. for instance,
“llxcommande” table records customer orders while “llx facture” table consists of in-
voices. based on the tables, we derived 4 activities ( create order ,create invoice ,create
shipment andcreate payment ) and 6 object classes (i.e., one table corresponds to one
object class) to be included in the xoc logs.10we instrumented the erp/crm system
in such a way that we could extract data executed by real and simulated users of the
system.
our algorithm has been implemented in the “ocbc model discovery” plugin in
prom.11figure 7 shows the interface of the plugin and a discovered model (in panel 4)
from an xoc log . panel 1presents the distribution of cardinalities and the instances
related to one selected constraint (highlighted in red in panel 4). panel 2shows the
metrics of constraints such as conﬁdence and support (this discussion is beyond the
paper). it is possible to zoom in/out models through operating panel 3.
as discussed in last section, we can ﬁlter the discovered models to get a better
understanding. using the ﬁlter panels, it is possible to ﬁlter behavioral constraints based
on constraint types (the plugin discovers all constraints of 9 common types by default)
and activity names through panel 5, or based on the regulation of ﬁtness and precision
(the method for computing ﬁtness and precision is not covered by this paper) through
panel 6. for instance, if the desired action is to inspect the unary-response ,response ,
unary-precedence andprecedence constraints between create order andcreate shipment
activities, one can uncheck the other boxes (all boxes are checked by default). the
ﬁltered model for the example log is shown in figure 8.
in the ﬁltered model, there exist a response and a unary-precedence constraints
between create order andcreate shipment activities. the constraints indicate one create
order event is followed by one or more corresponding create shipment events while one
create shipment event is always preceded by precisely one corresponding create order
event. investigating the dolibarr system and its tables, it is possible to afﬁrm that the
process behavior of the system is according to these statements. the system allows
creating multiple shipments for one order, but does not allow a shipment to contain
products from multiple orders (as shown in figure 8). although the discovered model
in figure 7 is more complex than the real model (designed based on the real process) in
figure 1, we can easily get the same insights after ﬁltering appropriately.
6 conclusion
in this paper we introduced object-centric behavioral constraint (ocbc) modeling
language to graphically model control-ﬂow and data/objects in a truly integrated man-
10these tables and logs can be found at https://svn.win.tue.nl/repos/prom/packages/ocbc/trunk/
tests/testﬁles/logs&models/ocbcmodeldiscovery.
11download prom 6 nightly builds from http://www.promtools.org/prom6/nightly/ and update
theocbc package .automatic discovery of object-centric behavioral constraint models 13
fig. 7. the interface of the “ocbc model discovery” plugin.
ner. this novel language uses cardinality constraints to describe data and behavioral
perspectives in a single diagram which overcomes the problems of existing data-aware
approaches that separate the data (e.g., a class model) and behavioral (e.g., bpmn,
epcs, or petri nets) perspectives. in ocbc models, different types of instances can
interact in a ﬁne-grained manner and the constraints in the class model guide behavior.
in this paper, we proposed an algorithm to discover ocbc models from object-
centric event logs. currently, the discovered models perfectly ﬁt the source logs (i.e.,
there is no noise in logs or we do not distinguish noise). in future, we will extend the
algorithm to better deal with infrequent and incomplete behavior. besides, some metrics
such as ﬁtness, precision and generalization will be proposed to evaluate discovered
models. also, we will improve our approach to deal with larger scale logs in more
complex scenarios, i.e., enabling the approach to discover compact models in a scalable
manner (e.g., remove redundancies).
moreover, this paper serves as a starting point for a new line of research. next to
model discovery and its support tools (ocbc model editor and ocbc model discov-
ery plugin) in prom , we also support conformance checking. based on ocbc models,
many deviations which cannot be detected by existing approaches can be revealed.
references
1. w.m.p. van der aalst. process mining: data science in action . springer-verlag, 2016.
2. w.m.p. van der aalst, p. barthelmess, c.a. ellis, and j. wainer. proclets: a framework for
lightweight interacting workﬂow processes. international journal of cooperative informa-
tion systems , 10(4), 2001.14 guangming li, renata medeiros de carvalho, and wil m.p. van der aalst
fig. 8. the model discovered from the otc process after ﬁltering.
3. w.m.p. van der aalst, g. li, and m. marco. object-centric behavioral con-
straints. corr technical report, arxiv.org e-print archive, 2017. available at
https://arxiv.org/abs/1703.05740.
4. w.m.p. van der aalst, m. pesic, and h. schonenberg. declarative workﬂows: balancing
between flexibility and support. computer science - research and development , 23(2),
2009.
5. p. chen. the entity-relationship model - toward a uniﬁed view of data. acm transaction
on database systems , 1(1), 1976.
6. d. cohn and r. hull. business artifacts: a data-centric approach to modeling business
operations and processes. ieee data engineering bulletin , 32(3), 2009.
7. h.j. genrich. predicate/transition-nets. in w. brauer, w. reisig, and g. rozenberg, editors,
advances in petri nets 1986 part i: petri nets, central models and their properties , volume
254 of lecture notes in computer science , pages 207–247. springer-verlag, berlin, 1987.
8. h.j. genrich and k. lautenbach. the analysis of distributed systems by means of
predicate/transition-nets. in g. kahn, editor, semantics of concurrent compilation , volume
70 of lecture notes in computer science , pages 123–146. springer-verlag, berlin, 1979.
9. object management group. omg uniﬁed modeling language 2.5 . omg, 2013.
10. t. halpin and t. morgan. information modeling and relational databases . morgan kauf-
mann publishers inc., san francisco, ca, usa, 2008.
11. k.m. van hee. information system engineering: a formal approach . cambridge university
press, 1994.
12. r. hull et al. business artifacts with guard-stage-milestone lifecycles: managing artifact
interactions with conditions and events. in international conference on distributed event-
based systems (debs 2011) . acm, 2011.
13. k. jensen. coloured petri nets. in w. brauer, w. reisig, and g. rozenberg, editors, ad-
vances in petri nets 1986 part i: petri nets, central models and their properties , volume
254 of lecture notes in computer science , pages 248–299. springer-verlag, berlin, 1987.
14. k. jensen. coloured petri nets: basic concepts, analysis methods and practical use .
springer-verlag, berlin, 1996.automatic discovery of object-centric behavioral constraint models 15
15. n. lohmann. compliance by design for artifact-centric business processes. in business
process management (bpm 2011) , volume 6896 of lncs . springer, 2011.
16. x. lu, m. nagelkerke, d. van de wiel, and d. fahland. discovering interacting artifacts
from erp systems. ieee transactions on services computing , 8(6):861–873, 2015.
17. m. de leoni and w.m.p. van der aalst. data-aware process mining: discovering decisions
in processes using alignments. in proceedings of the 28th annual acm symposium on
applied computing , pages 1454–1461. acm, 2013.
18. a. nigam and n.s. caswell. business artifacts: an approach to operational speciﬁcation.
ibm systems journal , 42(3), 2003.
19. e.h. nooijen, b.f. van dongen, and d. fahland. automatic discovery of data-centric and
artifact-centric processes. in international conference on business process management ,
pages 316–327. springer, 2012.
20. v . popova, d. fahland, and m. dumas. artifact lifecycle discovery. international journal
of cooperative information systems , 24(01):1–44, 2015.
21. a. rozinat and w.m.p. van der aalst. decision mining in prom. in international conference
on business process management , pages 420–425. springer, 2006.
22. p.a.c. verkoulen. integrated information systems design: an approach based on object-
oriented concepts and petri nets . phd thesis, eindhoven university of technology, eind-
hoven, 1993.
23. c.r. zervos. coloured petri nets: their properties and applications . phd thesis, university
of michigan, michigan, 1977.