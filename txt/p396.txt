modeling grid workﬂows with
colored petri nets⋆
carmen bratosin, wil van der aalst, and natalia sidorova
department of mathematics and computer science
eindhoven university of technology
p.o. box 513, 5600 mb eindhoven, the netherlands
c.c.bratosin@tue.nl, w.m.p.v.d.aalst@tue.nl, n.sidorova@tue.nl
abstract. grid computing refers to the deployment of a widely dis-
tributed architecture for the execution of computationally challengi ng
tasks. the grid provides a set of distributed resources which can b e
used for “computing on demand” or for constructing a “virtual super-
computer”. recently, several researchers started to look at the rel ation
between workﬂow management and grid computing. the ﬂow of work
through a grid can be seen as a classical “workﬂow”. however, as op-
posed to the classical workﬂows, the resources are not humans and are
not managed by some centralized client-server architecture. inste ad, the
grid is highly distributed and the resources are computing power, m em-
ory, etc. currently, there is no conceptual framework for grid comput ing
and the role of workﬂows in grids is unclear. this paper provides ini-
tial steps towards a conceptual framework expressed in terms of colore d
petri nets. cpn tools is used to model grids while focusing on the work-
ﬂow aspects. the resulting model can be analyzed to detect deadloc ks,
etc. the framework is illustrated using process mining as an applic ation.
keywords: colored petri nets; grid computing; modeling.
1 introduction
grid computing [21] is concerned with the development and advancement of
technologies that provide seamless and scalable access to wide-area distributed
resources. currently, many researchers and practitioners are developing softwar e
to support grid computing. a well-known example is the globus toolkit which
provides an open source software toolkit for building grids [17]. within t he grid
community several research groups have made attempts to adopt ideas from
workﬂow management and apply them in a grid context [15, 18, 19, 23, 25]. fo r
many grid applications the workﬂow-paradigm is quite natural, e.g., complex
scientiﬁc computations can be modeled as workﬂows. however, unlike classi-
cal workﬂows the control is decentralized and resources are computing power,
memory, etc. rather than people.
⋆this research is supported by the glance nwo project “workﬂow manage ment
for large parallel and distributed applications”.despite the current interest in grids and workﬂow, a good conceptual model
of grids is missing and most researchers are focusing on the practical realization
of grids. terms like “resource”, “job”, and “workﬂow” are subject to multipl e
interpretations. therefore, in this paper, we model the basic grid concepts in
terms of colored petri nets (cpns, [20]). the main purpose is to clarify the
basic concepts. moreover, we also show that the mapping of grids onto cpns
allows for all kinds of analysis. given the fact that the allocation and dea llocation
of resources in grids is done in a distributed manner and that multiple resources
may be involved in some task, a grid workﬂow may easily deadlock. theref ore,
this paper will focus on the use of state-space analysis to discover deadlocks.
grids are often used in areas where there is a need for a lot of (preferably
inexpensive) computing power. examples can be found in scientiﬁc comput-
ing, e.g., seti@home searches for possible evidence of radio transmissions fro m
extraterrestrial intelligence using data from radio telescopes. seti@home uses
cpu-scavenging for this, i.e., a grid of unused desktop computers is exploited
to analyze the radio transmissions. this particular form of grid use is al so called
“voluntary computing” because the resources are made available without a clear
economic motive for the participants. another interesting application domain
is the use of grids for data mining to analyse the large volumes of data gener-
ated today (cf. the datamininggrid project [2]). in this paper, we will focus on
a particular application: the utilization of grid computing for process mining .
the goal of process mining is to extract models (e.g. petri nets) from event logs
[9]. this is possible because many systems ranging from enterprise inform ation
systems and web applications to embedded and high-tech systems are collecting
enormous volumes of audit trails. to deal with these large amounts of data and
computationally expensive process mining algorithms, grids are particularly use-
ful. high-level process mining tasks can easily be described as workﬂows where
the activities correspond to the execution of particular process mining algo-
rithms. therefore, process mining is an interesting application domain for gri d
computing.
the remainder of the paper is organized as follows. in section 2 we present
a running example and motivate the utilization of grid computing for process
mining. section 3 introduces the basic grid concepts which are mapped onto
cpns in section 4. related work is discussed in section 6 and section 7 concludes
the paper.
2 running example: applying grid technology to
process mining
as indicated in the introduction, in this paper we focus on using grid technology
for large process mining tasks. in recent years, process mining has emerged
as a way to analyze systems and their actual use based on the event logs they
produce [11]. note that, unlike classical data mining, the focus of process mining
is on concurrent processes and not on static or mainly sequential structures. aclassical example is the α-algorithm [11] which automatically constructs a petri
net based on a set of observed system traces.
process mining is applicable to a wide range of systems. these systems may
be pure information systems (e.g., erp systems) or systems where the hardw are
plays a more prominent role (e.g., embedded systems). the only requirement is
that the system produces event logs , thus recording (parts of) the actual behav-
ior. information systems such as classical workﬂow management systems (e.g.
staﬀware) case handling systems (e.g. flower), pdm systems (e.g. windchill) ,
middleware (e.g., ibm’s websphere), hospital information systems (e.g., chip-
soft) record detailed information about the activities that have been executed.
other systems recording events are medical systems (e.g., x-ray machines), pro-
duction systems (e.g., wafer steppers), copiers, sensor networks, etc. an example
is the “customercare remote services network” of philips medical systems
(pms). this is a worldwide internet-based private network that links pms equip-
ment to remote service centers. an event that occurs within an x-ray machine
(e.g., moving the table, setting the deﬂector, etc.) is recorded and analyzed. the
logging capabilities of the machines of pms illustrate that event logs are w idely
available.
the goal of process mining is to extract information (e.g., process models)
from these logs, i.e., process mining describes a family of a-posteriori analysis
techniques exploiting the information recorded in the event logs .
simple algorithms such as the α-algorithm [11] are linear in the size of the
event log. however, such algorithms do not perform well on real-life data and
their simplicity is misleading for two reasons: (1) more advanced process min-
ing algorithms are needed that require lots of computing power and parameter
tuning and (2) the “process of process mining” consists of additional pre- and
post-processing steps (ﬁltering, cleaning, merging, conformance checking, etc.).
it should be noted that event logs may be huge, e.g., there may be thousands of
diﬀerent cases and there may be thousands of events per case. logs such as the
ones produced by the machines of pms illustrate the computational challenges.
moreover, some process mining techniques require lots of computing power. con-
sider for example the genetic process mining algorithms described in [24]. all
of the more advanced algorithms have lots of parameters that need to be set.
typically, the algorithms are run with diﬀerent parameter settings to achiev e ac-
ceptable results. hence, diﬀerent process mining experiments are run iteratively
or in parallel. besides running the core process mining algorithms several pre-
and post-processing steps need to conducted.
the main goal of grid computing is to oﬀer wide distributed computing and
storage facilities for complex applications. from the observations just ma de,
process mining process can require challenging computational executions, and
also has to deal with a large amount of data. therefore, process mining is an
interesting application domain for grid computing . on the one hand, there are
clear computational challenges that can be addressed through grid computing.
on the other hand, the “process of process mining” can be seen as a workﬂowstart end prepare log analyze logselect
algorithmheuristic
minercheck
conformancereturn
resultsalpha
miner
genetic
miner+ -
startset
parameterspartition log 
for 10 fold 
checking1
+
check
results
102
run
algorithm-
endreturn
results
fig. 1. the process mining workﬂow expressed in terms of yawl [6]
consisting of activities ranging from data preparation and ﬁltering to discover y
and conformance checking.
to illustrate the application of grid computing to process mining, we use
a rather simple and abstract example as shown in figure 1. it is kept simple
so that it is understandable by non-process mining experts and to allow for
understandable cpn models later in this paper.
figure 1 describes a typical process mining scenario in terms of the workﬂow
language yawl [6]. yawl extends petri nets with notations useful for repre-
senting workﬂows. the workﬂow at the top of figure 1 shows that a high-level
process mining job starts with the preparation of the log (task prepare log ). it
includes the scanning of the log for inconsistencies (e.g., descending timestamps,
missing event types, etc.) and the addition of dummy start and end events if
needed. then the log is analyzed (task analyze log ) and several characteristics
are collected, e.g., size, completeness, number of event types, distribution of ac-
tivities, etc. based on this task select algorithm chooses a particular algorithm
that is expected to perform well given the characteristics of the log. if chara cter-
istics indicate that the log is highly structured and has no noise, the α-algorithm
may be selected. if it contains some noise and is large, the heuristic miner [22]
may be selected. the genetic miner may be selected if the structure of the model
is complicated, there is noise, and the log is not too large. after running one of
the process mining algorithms, the quality of the result is checked (task check
conformance ). if the quality is acceptable or there are no more alternatives,the results are returned. otherwise, another algorithm is selected and the pro-
cess is repeated. each of the process mining algorithms corresponds to a yawl
subprocess. in figure 1 only the subprocess genetic miner is described. the ge-
netic miner starts by setting the parameters. genetic algorithms typically hav e
many diﬀerent parameters that one can experiment with. the genetic miner has
parameters such as population size, number of generations, seed, elitism, muta-
tion rate, ﬁtness function, crossover type, etc. although not shown in figure 1
diﬀerent instances of the same algorithm could run in parallel with diﬀerent pa-
rameters to improve response time. after task set parameters , the log is split and
replicated for 10-fold checking. k-fold cross validation divides the data set into k
subsets. each time, one of the ksubsets is used as the test set and the other k−1
subsets are put together to form a training set. then the average error across
allktrials is computed. in this workﬂow the cases in the logs are split over 10
sets and each of the 10 parallel branches in figure 1 takes 9 of these 10 sets to
construct a process model based on the genetic algorithm. after applying the
algorithm the result is evaluated using the remaining test set. task check results
collects these results and decides whether a new experiment is needed, i.e., the
subprocess returns to task set parameters or ends with task return results .
figure 1 also shows some annotations describing the use of resources. for
this simpliﬁed example, we assume that there are only two types of required
properties for task execution: cpu and disk space. disk space is denoted by the
small tube and cpu power is denoted by a small hexagon. disk space is typically
allocated for multiple subsequent tasks while cpus are typically released af ter
each task. task prepare log claims space for storing the entire log and the overall
results. this space is only returned at the end of the workﬂow. since the genetic
algorithm is a more complex process, the algorithm has its own private data
space.
in the remainder of this paper, we will use process mining and in particular
the example shown in figure 1 to illustrate our approach.
3 grid workﬂows
this section introduces the basic grid concepts relevant for the remainder of this
paper. as indicated, we will model grids in terms of cpns and emphasize the
workﬂow aspect of grid computing.
the standard grid architecture [16] is composed of several layers: (1) the in-
frastructure layer composed of resources (e.g. databases, cluster computers), (2)
theapplication layer , where the grid user describes the processes to be submitted
to the grid, and (3) the middleware layer , which is in charge of ﬁnding a resource
for the user requirements and other management issues (e.g. monitoring, fault
recovery).
infrastructure layer the grid infrastructure is a widely distributed infrastruc-
ture, composed of diﬀerent resources, linked via the internet. the resources allow
for the execution of diﬀerent tasks. examples of typical resources in a grid infr as-
tructure are computing elements (e.g. cluster computers) and storage elements(e.g databases) [3]. a computing element is usually described in terms of its com-
puting power and software available, e.g. number of cpu’s, installed soft ware
packages, main memory size, operating system. a storage element is a resour ce
that allows grid users to store and manage ﬁles together with the space assig ned
to them. the typical characteristics of a storage element are the software us ed to
manage the device, the allocated space, and, an identiﬁer of the data contained.
a storage element typically contains multiple storage areas .
we deﬁne the resource capacity as a set of characteristics that we will refer
to asproperties . examples are the number of cpu’s and hdd size. the capacity
of a resource can be described as a multiset of properties, e.g., two cpu’s and
one disk of 1gb.
because a resource may host applications according to the available capacity,
we split the capacity in free capacity (i.e., available computing power or stor-
age to be used by a grid job) and busy capacity (i.e., capacity that is already
allocated/reserved for the performance of certain jobs). we refer to the set of
resources composing a grid infrastructure as the resource pool . in the model pre-
sented in this paper, we assume that the resource pool is ﬁxed and that the
resources are reliable, i.e. if an application was allocated on a resource, then the
resource will eventually perform it.
application layer the upper level of a grid architecture is composed of user
applications. such applications deﬁne the jobs to be executed using the grid
infrastructure. since jobs may causally depend on one another, the application
level needs to specify the “ﬂow of work”. therefore, we use the term grid workﬂow
to refer to the processes speciﬁed at the application level. note that there may
be diﬀerent grid workﬂows using the same infrastructure and that there may be
multiple instances of the same grid workﬂow (referred to as process instances).
for each process instance, a partially ordered set of jobs needs to be executed.
the grid workﬂow deﬁnes the dependencies between jobs and the properties
required per job. in a grid workﬂow one can ﬁnd the classical workﬂow patterns
[7] but also patterns focusing on resource allocation, e.g., allocating multipl e
resources to the same job.
middleware layer the linking between user jobs and resources is done by a
matchmaker (or broker). in this paper we restrict ourselves to middleware wor k-
ing according to a “just-in-time” strategy, i.e., at the moment job instance must
be executed, the matchmaker searches for an available resource matching the
job, and if it exists the job is allocated to that resource. after the allocati on,
the free capacity of the resource and the busy capacity are updated according
to the job requirements.
in the next section we map the concepts mentioned onto cpns with two
goals in mind: (1) to clarify the basic grid concepts and (2) to show that petri -
net based analysis is useful and feasible in a grid context. figure 2 illustrat es
thegrid model we aim to represent in terms of cpns. the model is composed of
the grid workﬂows (i.e., application layer) submitted to the grid and a comm on
resource pool, containing all the infrastructure resources with their capacity (i .e.,fig. 2. grid model
infrastructure layer). the grid model assumes a very simple middleware layer
and will be represented by the allocation/deallocation of the jobs instances only .
4 modeling grids in terms of cpns
in the previous section, we have presented the main components of a grid model.
in this section, we describe how to model a grid using colored petri nets (cpn)
[20] and present some basic design patterns [7] that support the modeling of
dependencies between grid jobs. we conclude the section by providing a cpn
model for the running example presented in section 2.
4.1 mapping the grid model onto cpns
as we discussed in the previous section, a grid model is composed of a set of
grid workﬂows, a pool of resources, and allocation/deallocation mechanism s. in
our examples, we typically focus on a single grid workﬂow, however the same
approach can be used to model multiple grid workﬂows sharing a grid infras-
tructure.
we model the grid infrastructure in terms of a resource pool place . this place
contains tokens corresponding to the resources. each resource has a unique id
modeled by the color set resid . the capacity of a resource is expressed in
terms of available ( free) capacity and allocated ( busy) capacity. both types of
capacity are modeled as a multiset of properties. recall that a property refers to
a single resource characteristic, e.g., a capability like storage space, comput ing
power, bandwidth, etc. the color set propis used to model properties (e.g. cpu,
storage area), and color set props represents a multiset of properties. note that
props is deﬁned as a list of prop elements to model multisets. the tokens of
theresource pool place are of the color set res. this color set incorporates the
resource id, the available capacity, and allocated capacity.
the grid workﬂows are modeled as an extension of the classical workﬂow
nets [4] and there are also clear relations with the so-called colored workﬂowfig. 3. color sets for a grid workﬂow
nets [8]. like in a workﬂow net there is a single input startplace and a single
output endplace, and every node of the grid workﬂow is on a path from the
start place to the endplace. however, we distinguish between two types of
places: job places andcontrol places . job places correspond to the execution of
jobs while using resources from the grid and control places are merely added for
the routing of process instances. job places are mirrored by requirement places
indicating the resource requirements in terms of a multiset of properties. another
diﬀerence with classical workﬂow nets is that transitions do not represent tasks
but correspond to the allocation or deallocation of resources, i.e., we are fo rced
to model the workﬂow at a ﬁner level of granularity. initially, all job places
and control places are empty and only the requirement places contain tokens.
moreover, for each process instance a token is added to the startplace.
process instances are referred to using the color set pinst. all control places,
including the startandendplace, are of type pinst. job places are of type job.
this color set is deﬁned as the product of a process instance id (color set pinst)
and a resource id (color set resid ).1each requirement place contains one token
of type props, i.e., the token holds a multiset of properties denoting the resource
requirements of the corresponding job place.
in the cpn model we assume a very simple middleware layer, therefore the
binding between the grid infrastructure and the grid workﬂows can be realized
through allocation anddeallocation transitions. when a job is created, i.e., a
token is put on a job place, an allocation transition ﬁres. if a job completes, i.e.,
a token is removed from a job place, a deallocation transition ﬁres.
figure 3 presents all the basic color sets deﬁned for the grid model. in the
deﬁnitions, we deﬁne also the basic operations for multisets. these operations
will be used for modeling with allocating and deallocation capacity.
figure 4 shows a very simple example of a grid model which uses the color
sets mentioned before. there is one start and one end place and these are the
only two control places. there is just one job place jof type job. the cor-
responding requirements place is named rand is of type props. the resource
1note that this color set assumes that a job cannot use multiple resources . later we
will relax this requirement.i i req(i,rid)
req
t2 t1[en((rid,free,busy),req)]j1
job
r1["cap1"]
props pinstpiinit
pinststart end
take((rid,free,busy),req) return((rid,free,busy),req)resources(rid,free,busy) (rid,free,busy)
resresinit(i,rid)
fig. 4. a simple job example
pool is modeled by the place resources . an allocation transition t1precedes
the job place in figure 4. the guard of this transition is given by the functio n
en((rid,free,busy),req) . the transition is enabled if there exists at least one re-
source ( rid) such that the token in rplace ( req) is a subset of the multiset free
(i.e. free resource capacity).
by the ﬁring of transition t1, a token containing the process id ( i) and the
allocated resource id ( rid) is created for the job place j. at the same time,
the allocated resource characteristics are retrieved from the resource pool. t he
token of the resource pool is modiﬁed by function take((rid,free,busy),req) . the
function modiﬁes the capacity occupied by the job as busy capacity.
when the job is ﬁnished, the deallocation transition ﬁres (transition t2in
figure 4). the function return((rid,free,busy),req) modiﬁes the token of the re-
source that the job releases, by updating the free capacity of the resource (i.e.
the new free capacity is the reunion of the free capacity with the capacity equal
with the job requirements).
4.2 basic patterns
in the previous subsection we modeled a grid model containing just one grid
workﬂow and this grid workﬂow consisted of only one job. however, it is obvi ous
how these types and naming conventions can be used to represent larger grid
models. to illustrate this we deﬁne some basic patterns to help a grid user to
deﬁne his process. these are inspired by the workﬂow patterns in [7]. however,
we also provide a pattern dedicated to multiple resource allocation.
atomic job in the previous section, we have presented a simple job example (see
figure 4). the quadruple jobplace, requirement place, allocation transition,
anddeallocation transition is the most simple pattern that we use in our model.
all the other patterns are composed of this pattern. therefore, for simplicity
we deﬁne a subpage containing this pattern.the user can use this subpage in
diﬀerent locations of his grid workﬂow, adapting the marking of the reqplace
according to the job description. note that for each job type a diﬀerent subpage
can be deﬁned that is reused multiple times.ii
i
ijob 1job 1
job 2
job 2t2 t1c3
pinst
c4
pinstc2
pinstc1
pinst
end
pinstresources
resstart
job 2job 1
resinitpiinit
pinsti
i
fig. 5. parallel pattern
parallel pattern a common pattern in grid computing is the execution of diﬀer-
ent jobs in parallel. figure 5 presents the parallel pattern. since the matchmaker
assumes all the jobs to be independent, two tokens are created so that the match-
maker allocates each job when it ﬁnds a suitable resource for this job. the jobs
can in principle be diﬀerent, therefore they are mapped to two diﬀerent jobsub-
pages. the process instance will wait till both jobs ﬁnish, and then the transitio n
t2ﬁres, which terminates the execution of the pattern.
multiple resource allocation a typical scenario in grid computing is that multiple
resources are needed for the execution of a job. for example, a job requires
access to a storage area, that contains some data and, after some computation,
the result is written back to the same storage area. the storage area has t o be
reserved till the computation is ﬁnished. figure 6 illustrates one of the possibl e
patterns to realize this. this pattern creates a job to reserve one of the resources,
and then looking for a second resource. the ﬁrst resource remains locked till the
second resource ﬁnishes the computation.
i ii ii
i(i,rid)
t2
job
["cap2"]
propsjobr1["cap1"]
props
pinstend
pinst
resstartpiinit
pinst
j2t1
[en((rid,free,busy),req)]t3 t4resources
(rid,free,busy)
take((rid,free,busy),req) return((rid,free,busy),req)(rid,free,busy)(rid,free,busy)
pinstc1 c2(rid,free,busy)req req
req req(i,rid) (i,rid)return((rid,free,busy),req) resinit take((rid,free,busy),req)j1(i,rid) [en((rid,free,busy),req)]
r2
fig. 6. multiple resource allocation: pattern 1req1 req1
1`return((rid1,free1,busy1),req1)++
1`return((rid2,free2,busy2),req2)1`(rid1,free1,busy1)++
1`(rid2,free2,busy2)
1`take((rid1,free1,busy1),req1)++
1`take((rid2,free2,busy2),req2)1`(rid1,free1,busy1)++
1`(rid2,free2,busy2)i ireq2 req2
(i,rid1,rid2) (i,rid1,rid2)
t2 t1
[en((rid1,free1,busy1),req1) andalso en((rid2,free2,busy2),req2)]r1["cap1"]
props
jr2["cap2"]
props
end
pinst
resourcesresinit
resstartpiinit
pinstjob2
fig. 7. multiple resource allocation: pattern 2
the disadvantage of the pattern illustrated by figure 6 is that it can lead t o
deadlocks when a second resource is not available in the resource pool because
it is already locked by other jobs.
figure 7 presents another pattern to realize the allocation of multiple re-
sources. for each of the required resources, the user creates a requirement place:
r1andr2. from the resource pool the allocation transition retrieves two re-
sources, each one corresponding to one of the requirements places. in this case
the token of the job place contains one process instance id and two resources ids.
the deallocation transition will release both resources. in this second patter n,
there may be multiple resources involved in the same job. this makes the model
less simple and may lead to modeling errors such as releasing the wrong resource.
4.3 process mining example mapped to cpn
figure 8 shows the cpn model of the process mining example already described
in section 2. in figure 1 this grid model was introduced using a yawl diagram.
here we focus on the mapping of figure 1 into figure 8 using the patterns deﬁned
before.
first, a storage area has to be allocated (places sa allocated andreq for
sa). the storage area will be used to store and to retrieve the results of all the
executed computations. the allocated storage area will be released only when all
the other jobs of the same instance have ﬁnished. we choose to use the multiple
resource pattern shown in figure 6 to model this behavior.
the sequence of jobs prepare log andanalyze log follows the sequence pat-
tern. after, the analyze log , a choice between diﬀerent mining algorithms should
be made. to model this choice we introduce a new color set chalg that can
take three values: aa,hm, and gm. each of the three values corresponds to
the choice of one of the process mining tools: aafor the plug-in using the α-ii i(i,cha)(i,cha) (i,cha)(i,cha)i ii i
return((rid,free,busy),req)take((rid,free,busy),req)(rid,free,busy)
(rid,free,busy)(i,rid) (i,rid)
ii
ii
iii
(i,ch)
i (i,ch)i
analyzeloganalyzelog
tend tstart
[en((rid,free,busy),req)]
check conformance
checkconformancet3[cha=gm]
t2[cha=hm]
t1[cha=aa]
genetic miner
geneticminerheuristic min.
heuristicmineralpha alg.
alphaalgorithmprepare logpreparelog
t5[ch=restart]
t6
[ch=finish]select 
algorithm
c5
pichalgreq for sasa props
sa allocated
job
c6
pinstc7
pinstc8
pinstc2
pinst
c10
pichoicec4
pinstc3
pinst
c9
pinstc1
pinstend
pinst
resourcesresinit resstartpiinit pinst preparelog
alphaalgorithm heuristicminer geneticminer
checkconformanceanalyzelogreq req
fig. 8. cpn model of the process mining workﬂowi
ireturn((rid,free,busy),req)take((rid,free,busy),req)
(rid,free,busy)(rid,free,busy)
i
(i,ch)
(i,rid)
req req(i,rid)(i,ch)i
t2[ch=finish]
t1
[en((rid,free,busy),req)]run algorithm
runalg[ch=restart]
req for sasa
propssa allocated
jobpichoicec3
pinstc2
pinst
pinststartin
pinstendout
pinstresources
i/oresinit
resi/oout
in
runalgc4re-start
checkresults
checkresultscheckresultsc1partition log and 
set param
partitionlogsetparampartitionlogsetparamn threads
are created synchronization of 
the n threads
fig. 9. genetic miner
algorithm, hmfor heuristic miner, and gmfor genetic miner. note that place
c5haspichalg as color set. this color set is the product of pinst andchalg .
after the selected algorithm is executed, job check conformance is submitted
to the grid. according to the results one of the algorithms (re-)starts or the
process ends. to make this choice we use a variable from the color set choice ,
that can take two values: restart to (re-)do one of the algorithms and ﬁnish to
end the process. note that place c10haspichoice as color set. this color set is
the product of pinst andchoice .
for the execution of the α-algorithm and heuristic miner, a resource with
freecpu capacity is needed. on the other hand, the use of genetic algorithms
requires a more complex process (cf. figure 9). a new storage area is allocated
in order to store/retrieve intermediate results of the genetic miner. then a com-
puting element is used to partition the log and to set the parameters. ndiﬀerent
threads are created inside subpage partitionlogsetparam (not shown here), and
on each thread the genetic miner algorithm is performed (a grid job requiring a
computing element). when all threads have ﬁnished, the results of the threads
are combined and analyzed (job check results ). after the job check results ends,
all the process re-runs or it stops (for this choice an element of color set choice
is used).
the example cpn model shows that it is indeed possible to model complex
computations using a grid infrastructure. using cpn tools we were able to
clarify the basic terms used in grid computing. moreover, the allocation and
deallocation of resources may lead to deadlock problems as will be shown in the
next section. because of this, the cpn model is also useful from an analysis
point of view.
5 analysis of grid workﬂows
the analysis of grid workﬂows may include validation (i.e. checks whether the
workﬂow behaves as expected), veriﬁcation (i.e. workﬂow correctness) and per-formance analysis (i.e. evaluating whether time or cost requirements are ful-
ﬁlled). in this section we focus on a speciﬁc type of analysis: veriﬁcation. the
veriﬁcation of grid workﬂow is related to the correctness properties such as ab-
sence of deadlocks, livelocks and resource conﬂicts (cf. [14]). to verify these
properties, we use the state space analysis functionality provided by cpn too ls.
the analysis is conducted in two steps. first, we perform a soundness check. for
this purpose, we will extend the soundness property [10] for traditional work-
ﬂow such that it takes into account the grid workﬂow characteristics. in the
second step, we verify whether there are any resource conﬂicts between diﬀer-
ent jobs originating from diﬀerent grid workﬂows and their instances. we also
show a more eﬃcient deadlock analysis technique which allows us to look at one
instance in isolation.
5.1 soundness check
since we are interested in soundness, we assume in this subsection that the
resource pool has an “inﬁnite” amount of resources (i.e. whenever a job claims
resources, available resources exist in the resource pool).
the correctness property that we want to establish is soundness . a traditional
workﬂow is sound if it satisﬁes the following property: if we put a token in t he
startplace, there is a possible path to reach the endplace with just one token
from each reachable state, and if the endplace is reached no “garbage” tokens are
left behind (i.e. all the places except the endplace are unmarked). in our case,
because the grid workﬂow contains also requirements places and a resource place,
we have to extend the soundness property with the following two conditions: (1)
the marking of the requirements places remains the same for all the reachable
markings and (2) the resource pool place marking in the ﬁnal state has the same
value as in the initial state.
the necessary and suﬃcient conditions that ensure that a grid workﬂow is
sound using the state space report of cpn tools are the following: (1) there
exists only one dead marking, this marking should also be a home marking
(i.e. a marking reachable from all other markings) and there are no other home
markings, moreover this dead marking is indeed the desired ﬁnal marking (i.e.
the marking meets the soundness conditions) and (2) the lower and upper bounds
of a requirement place marking are equal.
for figure 8, cpn tools generated a full state space of 91 nodes and 139 arcs
in less than one second for an initial state with just one process instance and a r e-
source pool tokens2:1‘("ce",["cpu","cpu","cpu","cpu","cpu","cpu","cpu",
"cpu","cpu","cpu","cpu"],[])++ 1‘("se",["sa","sa","s a"],[]) .
the state space report provided information about boundedness properties,
home properties and liveness properties as below3:
2note that we did not add inﬁnitely many resources to the initial markin g. however,
it is easy to check whether suﬃcient resources have been added by checking the multi
set bounds in the state space report.
3we present a partial state space report that contains only the necessary information
to establish grid workﬂow soundness.boundedness properties
-----------------------
best integer bounds
upper lower
alphaalgorithm’r 1 1 1
analyzelog’r 1 1 1
checkconformance’r 1 1 1
checkresults’r 1 1 1
geneticminer’req_for_sa 1 1
heuristicminer’r 1 1 1
pm’req_for_sa 1 1 1
partitionlogsetparam’r 1 1
preparelog’r 1 1 1
runalg’r 1 1 1
best upper multi-set bounds
alphaalgorithm’r 1 1‘["cpu"]
analyzelog’r 1 1‘["cpu"]
checkconformance’r 1
1‘["cpu"]
checkresults’r 1 1‘["cpu"]
geneticminer’req_for_sa 1
1‘["sa"]
heuristicminer’r 1 1‘["cpu"]
pm’req_for_sa 1 1‘["sa"]
partitionlogsetparam’r 1
1‘["cpu"]
preparelog’r 1 1‘["cpu"]
runalg’r 1 1‘["cpu"]best lower multi-set bounds
alphaalgorithm’r 1 1‘["cpu"]
analyzelog’r 1 1‘["cpu"]
checkconformance’r 1
1‘["cpu"]
checkresults’r 1 1‘["cpu"]
geneticminer’req_for_sa 1
1‘["sa"]
heuristicminer’r 1 1‘["cpu"]
pm’req_for_sa 1 1‘["sa"]
partitionlogsetparam’r 1
1‘["cpu"]
preparelog’r 1 1‘["cpu"]
runalg’r 1 1‘["cpu"]
home properties
-----------------------
home markings
[28]
liveness properties
-----------------------
dead markings
[28]
dead transition instances
none
live transition instances
none
from the boundedness properties, we observe that each of the requirement
places (i.e. rplaces) has a lower bound equal to the upper bound. marking 28
is a home marking and a dead marking and it corresponds to the desired ﬁnal
marking. therefore, we conclude that the process mining grid workﬂow is sound.
5.2 resource veriﬁcation
the main problem in resource sharing is the potential of deadlocks when multiple
instances run in parallel and compete for the same resources step-by-step. there-
fore, we now look at the analysis of a grid model with multiple instances and a
limited set of resources . using cpntools we want to verify whether soundness
is jeopardized. we do this by looking for deadlocks.
let us consider the process mining grid workﬂow again. for two process
instances and a resource pool containing the following tokens:
1‘("ce1",["cpu","cpu","cpu"],[])++1‘("se1",["sa"],[])++1‘("se2",["sa"],[])
cpn tools generates a full state space with 1140 nodes and 2176 arcs in less
than 2 seconds. the state space report contains three dead markings and no
home markings.home properties
-----------------------
home markings
noneliveness properties
-----------------------
dead markings
[420,456,952]
dead marking 952 is the desired ﬁnal marking (i.e. the grid model proper
terminates), and the other two (420,456) refer to instances where both of process
instances deploy the genetic miner concurrently. the deadlocks occur because
each of the instances needs an additional storage area, but the resource pool
depleted all available storage areas. even if we increase the number of avail able
resources, the system will deadlock when the number of process instances running
in parallel is also increased.
in the following subsection, we propose a method to correct such a grid
workﬂow in order to ensure its proper termination independently from the num-
ber/type of available resources.
5.3 correcting a resource constraint grid workﬂow
in [26], we studied resource-constraint processes with homogeneous resources
and we have shown that a necessary and suﬃcient condition that ensures proper
termination (i.e. absence of deadlocks violating e.g. the soundness property) is
that any path resulting in the claim of one or more resources should have a
successor path resulting in the release of some resources.
we verify the necessary and suﬃcient condition for each property type.
therefore, we construct an automaton modeling the behavior of the system just
from the point of view of claiming and releasing of resources, abstracting fro m
all the the other possible events (i.e. those events are considered as silent steps ).
figure 10 presents the automaton for the process mining workﬂow. in state s1,
the system needs to reserve a computing element with a free cpu capacity, and
in state s3a new storage area if the genetic miner algorithm is selected. the two
claims are made without being preceded by releases of resources providing the
same type of property. therefore, the workﬂow does not satisfy the necessary
fig. 10. process mining automatonfig. 11. modiﬁed process mining automaton
and suﬃcient condition (presented in [26]) neither for cpu property, neither for
saproperty.
to avoid deadlocks the model shown in figure 8 needs to be corrected. the
correction of the grid workﬂow is made by checking if there are enough resources
to execute all the jobs composing the workﬂow (cf. [26]). the resources are just
claimed and released, ensuring that the necessary and suﬃcient condition is
satisﬁed. the algorithm presented in [26] is applied for each property type.
for the running example, the corrected automaton, by joining the results
for each property type, is shown in figure 11. the only modiﬁcation made is
to claim and to release in state start two additional resources with properties
saandcpu. for the corrected automaton, we observe that the necessary and
suﬃcient condition is fulﬁlled. we map the solution from the automaton to the
fig. 12. the changed process mining workﬂowcpn model, by changing the guard of the allocating transition of the ﬁrst sto rage
area as shown in figure 12. from the resource pool , three resources are required
(rid1,rid2andrid3). each of this resources must fulﬁll one of the requirements
of the jobs contained by the workﬂow. just one resource is kept ( rid1, as in the
original model), and the other two are released without any modiﬁcation.
for the modiﬁed model, cpn tools generates a full state space with 492
nodes and 664 arcs in less than one second. just one marking is reported as
both a home marking and dead marking and it corresponds to the desired ﬁnal
marking. hence the grid model is sound.
6 related work
the idea of using grid workﬂows to model and enact complex scientiﬁc processes
and distributed resources such as computing elements and data has emerged
in the grid community in recent years. grid workﬂow systems [1, 15, 25] hav e
been developed, but most of them support only directed acyclic graphs (dags)
as a modeling language. the disadvantage of using a dag is that it does not
support loop patterns and choice patterns. therefore, in the last years, petri
nets were introduced [12, 19] as a more powerful and suitable language to model
grid workﬂows. however, most of the work is focused on the practical realiza tion
of grids, and less attention has been paid to providing a conceptual framework
to model grid workﬂows.
many reseachers have applied petri nets to workﬂow management [4, 27].
note that these papers do not necessarily focus on grid workﬂows. moreover,
these papers typically focus on a single aspect, e.g. control ﬂow veriﬁcation,
while ignoring the interplay between resources and workﬂows. however, there
have been some papers using cpns to address other aspects of workﬂows, e.g.
[8]. to address the deadlock problem in grids we propose to use a variant of the
technique proposed in [26].
the running example comes from the process mining domain. in [13], the
authors proposed a process mining workﬂow that can call process mining algo-
rithms using a process engine. more details related to process mining concepts
and algorithms can be found in [11, 22, 24].
7 conclusion
in this paper, we propose a conceptual framework to use cpn for modeling and
verifying of grid workﬂows. grid concepts such as “job”, “grid workﬂow” a nd
“resource” have been explained in order to map them on cpns.
we proposed some basic patterns in order to model common grid behavior
such as parallel execution and multiple resources allocation. combining these
patterns, a complex grid workﬂow was build up.
moreover, we showed that cpn tools can be used to conduct soundness and
resource veriﬁcation to ﬁnd potential deadlocks. the state space analysis fro mcpn tools is able to discover deadlocks when multiple instances run in parallel
while incrementally claiming similar resources. based on our previous work [2 6],
we have corrected the model such that all instances terminate properly.
this paper is mainly conceptual. however, it is good to mention that we
are in the process of connecting yawl, globus, and prom. yawl [6] is used
as a workﬂow engine taking care of the orchestration. globus [17] is an open
source software toolkit used for building grid systems and applications but is not
process-aware. prom [5] is used to execute the actual process mining activities.
prom provides a plugable architecture with dozens of process mining algorithms
and a lot of functionalities related to ﬁltering, conversion, conformance checking ,
etc. currently, prom [5] aims at interactive mining. however, as shown in [13],
prom can be adapted such that its functionality can be invoked by a workﬂow
engine.
references
1. dagman (directed acyclic graph manager): condor meta-scheduler.
http://www.cs.wisc.edu/condor/dagman/.
2. datamininggrid project. http://www.datamininggrid.org/.
3. glue schema v1.3. http://forge.gridforum.org/sf/go/doc14185?nav=1.
4. w.m.p. van der aalst. the application of petri nets to workﬂow managem ent.
the journal of circuits, systems and computers , 8(1):21–66, 1998.
5. w.m.p. van der aalst, b.f. van dongen, c. g¨ unther, r. mans, a.k. al ves de
medeiros, a. rozinat, v. rubin, m. song, h. verbeek, and a. weijters . prom 4.0:
comprehensive support for real process analysis. in j. kleijn and a . yakovlev,
editors, icatpn 2007 , volume 4546 of lncs , pages 484–494. springer-verlag,
berlin, 2007.
6. w.m.p. van der aalst and a.h.m. ter hofstede. yawl: yet another wor kﬂow
language. information systems , 30(4):245–275, 2005.
7. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
8. w.m.p. van der aalst, j. jørgensen, and k. lassen. let’s go all the w ay: from
requirements via colored workﬂow nets to a bpel implementation of a new
bank system paper. in r. meersman and z. t. et al., editors, otm confederated
international conferences, coopis, doa, and odbase 2005 , volume 3760 of
lncs , pages 22–39. springer-verlag, berlin, 2005.
9. w.m.p. van der aalst, b. van dongen, j. herbst, l. maruster, g. schi mm, and
a. weijters. workﬂow mining: a survey of issues and approaches. data and
knowledge engineering , 47(2):237–267, 2003.
10. w.m.p. van der aalst and k. m. van hee. workﬂow management: models, meth-
ods, and systems . mit press, 2002.
11. w.m.p. van der aalst, a. weijters, and l. maruster. workﬂow minin g: discovering
process models from event logs. ieee transactions on knowledge and data
engineering , 16(9):1128–1142, 2004.
12. m. alt, s. gorlatch, a. hoheisel, and h.-w. pohl. a grid workﬂow langu age using
high-level petri nets. technical report tr-0032, institute on grid i nformation
and monitoring services, coregrid - network of excellence, march 2006.13. l. cabac and n. knaak. process mining in petri net-based agent-orient ed software
development. in d. moldt, f. kordon, k. van hee, j.-m. colom, and r. bast ide,
editors, proceedings of the international workshop on petri nets and softwa re en-
gineering (pnse’07) , pages 7–21, siedlce, poland, june 2007. akademia podlaska.
14. j. chen and y. yang. key research issues in grid workﬂow veriﬁcation an d vali-
dation. in acsw frontiers ’06: proceedings of the 2006 australasian works hops
on grid computing and e-research , pages 97–104, darlinghurst, australia, 2006.
australian computer society, inc.
15. e. deelman, j. blythe, y. gil, c. kesselman, g. mehta, s. patil, m .-h. su, k. vahi,
and m. livny. pegasus: mapping scientiﬁc workﬂows onto the grid. grid com-
puting: lncs , 3165:11–20, 2004.
16. i. foster. the anatomy of the grid: enabling scalable virtual organizations .pro-
ceedings. first ieee/acm international symposium on cluster com puting and
the grid , pages 6–7, 2001.
17. i. foster. globus toolkit version 4: software for service-oriented s ystems. in h. jin,
d. a. reed, and w. jiang, editors, npc, volume 3779 of lncs , pages 2–13.
springer, 2005.
18. g. c. fox and d. gannon. workﬂow in grid systems. concurrency and compu-
tation: practice and experience , 18(10):1009–1019, 2006.
19. a. hoheisel. user tools and languages for graph-based grid workﬂows. concur-
rency and computation: practice and experience , 18(10):1101–1113, 2006.
20. k. jensen. coloured petri nets. basic concepts, analysis methods and prac tical
use. volume 1 . eatcs monographs on theoretical computer science. springer-
verlag, berlin, 1997.
21. c. kesselman and i. foster. the grid: blueprint for a new computing infrastruc-
ture. morgan kaufmann publishers, november 1998.
22. l. maruster, a. weijters, w.m.p. van der aalst, and a. van den bosch . a rule-
based approach for process discovery: dealing with noise and imbalanc e in pro-
cess logs. data mining and knowledge discovery , 13(1):67–87, 2006.
23. a. s. mcgough, w. lee, and j. darlington. workﬂow deployment in icen i ii. in
international conference on computational science (3) , pages 964–971, 2006.
24. a. medeiros, a. weijters, and w.m.p. van der aalst. genetic proc ess mining:
a basic approach and its challenges. in c. bussler et al., editor, bpm 2005
workshops (workshop on business process intelligence) , volume 3812 of lncs ,
pages 203–215. springer-verlag, berlin, 2006.
25. t. m. oinn, m. addis, j. ferris, d. marvin, m. senger, r. m. gree nwood,
t. carver, k. glover, m. r. pocock, a. wipat, and p. li. taverna: a t ool
for the composition and enactment of bioinformatics workﬂows. bioinformatics ,
20(17):3045–3054, 2004.
26. k. m. van hee, a. serebrenik, n. sidorova, m. voorhoeve, and j. van d er wal.
scheduling-free resource management. data and knowledge engineering , 61(1):59–
75, 2007.
27. y. wang, c. lin, y. yang, and y. qu. grid service workﬂow models and th eir
equivalent simpliﬁcation methods. in gcc workshops , pages 302–307. ieee com-
puter society, 2006.