component behavior discovery from software
execution data
cong liu, boudewijn van dongen, nour assy and wil m.p. van der aalst
department of mathematics and computer science,
eindhoven university of technology, eindhoven, the netherlands.
e-mail:fc.liu.3, b.f.v.dongen, n.assy, w.m.p.v.d.aalst g@tue.nl
abstract ‚Äîtremendous amounts of data can be recorded dur-
ing software execution. this provides valuable information on
software runtime analysis. many crashes and exceptions may
occur, and it is a real challenge to understand how software is
behaving. software is usually composed of various components .
a component is a nearly independent part of software that full-
Ô¨Ålls a clear function. process mining aims to discover, monitor
and improve real processes by extracting knowledge from event
logs. this paper presents an approach to utilize process mining
as a tool to discover the real behavior of software and analyze it.
the unstructured software execution data may be too complex,
involving multiple interleaved components, etc. applying existing
process mining techniques results in spaghetti-like models with
no clear structure and no valuable information that can be easily
understood by end. in this paper, we start with the observation
that software is composed of components and we use this
information to decompose the problem into smaller independent
ones by discovering a behavioral model per component. through
experimental analysis, we illustrate that the proposed approach
facilitates the discovery of more understandable software models.
all proposed approaches have been implemented in the open-
source process mining toolkit prom.
i. i ntroduction
during the execution of software, execution data can be
recorded. by exploiting the recorded data, one can discover
behavioral models to describe the actual execution of software.
the discovered models can provide insight regarding real
usage of software, motivate novel idea on model-based testing,
enable software usability improvements, localize performance
problems and architectural challenges, etc. process mining
[15] aims at extracting process models from event logs. there
are three major types of process mining: (1) process discovery;
(2) conformance checking; and (3) enhancement. process
discovery takes an event log as input and produces a pro-
cess model. conformance checking aims to compare process
models discovered or hand-made with real-behavior recorded
in event logs. enhancement also takes an event log and an
existing model as inputs and tries to improve or extend the
model using additional information in the log. enhancement
can be used to highlight bottlenecks, predict performance, etc.
with the development of process mining techniques on the
one hand, and the growing availability of software execution
data on the other hand, a new form of software analytics comes
into reach, i.e., applying process mining techniques to analyze
software execution data. this inter-disciplinary research area
is called software process mining (spm) [14].the software execution data consist of method calls and
object information. usually, each software run may last for a
long time and involve multiple interleaved component execu-
tions. applying existing process mining techniques typically
results in Ô¨Çat and spaghetti-like models with no clear structure
and no valuable information for comprehension. given the ob-
servation that software typically involve a set of components,
we propose to use this component information to decompose
the problem into smaller independent ones by discovering a
behavioral model per component. starting from the original
execution data, we Ô¨Årst propose a novel idea that allows us
to identify component instance (one independent run of a
software component) as the case notion of software event
log. as process mining algorithms expect an event log as
input, the choice of case notion determines the scope of the
discovered models [1]. besides components, software usually
have a hierarchical structure represented as multi-level nested
method calls, hence the discovered behavioral models should
also depict this hierarchy nature. after obtaining a software
event log for each component, we then recursively transform
the log to a hierarchical one using the calling relation among
methods. given a hierarchical software event log, we use
existing techniques to discover a hierarchical process model.
existing approaches are unable to discover software (compo-
nent) behavioral models with hierarchies. to the best of our
knowledge this is the Ô¨Årst paper to discover such models.
the rest of this paper is organized as follows. section
ii presents a brief review of related work. section iii de-
Ô¨Ånes some preliminaries. section iv presents the software
component behavior discovery approach. section vi presents
experimental results. section v introduces prom plugin im-
plementation. finally, section vii concludes the paper.
ii. r elated work
a. software dynamic analysis
software dynamic analysis is used to understand the be-
havior of software by exploiting its execution data. several
techniques and tools have been presented to extract informa-
tion from running software. most existing approaches, such as
[9] and [20], generate automaton-based models using different
variants of the k-tail algorithm which was Ô¨Årst deÔ¨Åned by
biermann andfeldman [2]. however, these techniques cannot
discover concurrency explicitly, resulting in a so-called state
explosion for complex models. although automaton-basedmodels are popular in this area, there are several techniques
to learn other types of models. for example, some techniques
visualize software execution traces as sequence diagrams [11]
and some of them are extended with loops [3]. similarly,
the sequence diagram-based models also lack concurrency
description. moreover, each sequence diagram or automaton-
based model only describes the behavior of a single execution
trace. given software execution data referring to multiple
traces, these existing approaches will obtain an excessive
number of behavioral models rather than a compact model for
the whole data. in addition, considering the hierarchy nature
of a software, the discovered Ô¨Çat sequence diagrams or Ô¨Çat
automation-based models cannot accurately capture the real
behavior in a meaningful way.
b. process mining
process mining deals with discovering, monitoring and
improving business processes by extracting knowledge from
event logs [15]. the -algorithm [16] deÔ¨Ånes four kinds
of ordering relations (directly-follow, causality, choice and
concurrency), based on which it constructs a workÔ¨Çow net.
more recently, a family of inductive process mining techniques
[7] using process trees are proposed to handle incomplete
and noisy event logs. different from these process discovery
algorithms that produce Ô¨Çat models, a two-phase mining
approach using pattern detection techniques was introduced by
li et al. [8] to discover hierarchical process models. two types
of patterns, loops and maximal repeats, are considered. once
patterns are identiÔ¨Åed, all their occurrences are replaced by an
abstract activity and extracted as sub-process logs. different
from them, we propose to detect software-related patterns
and discover hierarchical models organized in calling relation.
conforti et al. [4] present a technique to discover bpmn
model with sub-processes, multi-instance markers, etc. it relies
on some special attributes (primary and foreign keys) to infer
dependencies between parent and sub-processes and multi-
instance markers. another research area is artifact-centric
process discovery, which aims to discover artifact lifecycle
behavioral models and interactions between them [10]. an
artifact describes the lifecycle of a business object (e.g. a
purchase order). our work goes into similar direction and aims
to discover software behavioral models.
c. software process mining
software process mining enables the extraction of knowl-
edge from software execution data, which helps software ana-
lysts better understand software behavior. our paper belongs to
the software runtime behavior discovery spectrum. one of the
Ô¨Årst papers addressing this problem using process mining is
[17]. for the mining of software systems, the recorded events
explicitly refer to parts of the system (components, services,
etc.). references to system parts facilitate the generation of
localized event logs. a generic process discovery approach is
proposed based on localized event logs. experimental results
show that location information indeed helps to improve the
quality of the discovered models. leemans and van der aalst[6] analyze the operational processes of software systems,
and process mining techniques are applied to obtain precise
and formal models using real-life event logs. they propose
to discover Ô¨Çat behavior models using inductive miner [7].
however, the hierarchical structure of software is not fully
considered. more recently, van der aalst [1] propose to
analyze software systems under real-life circumstances using
process mining, i.e., the ‚Äú big software on the run ‚Äùproject1.
our current work is also in the context of this project.
iii. p reliminaries
letsbe a set and we use ;for the empty set. we use the
standardjsjto denote the number of elements in set s. the
powerset of sis denoted byp(s) =fs0js0sg.f2x!
yis a function, i.e., dom(f)is the domain and rng(f) =
ff(x)jx2dom(f)gis the range. a multi-set (or bag) over
sis a set where elements can appear multiple times, e.g.,
m= [p3;q2]is a multi-set over s=fp;qgwherem(p) = 3 ,
m(q) = 2 . the set of all multi-sets over sis denoted by ns.
we use +and for the union and difference of two multi-sets.
both of them are deÔ¨Åned the same way as set.
a sequence over sof lengthnis a function :
f1;2;:::;ng!s. if(1) =a1;(2) =a2;:::(n) =an,
we write=ha1;a2;:::ani. a sequence of length 0 is called
the empty sequence, denoted by hi. the length of a sequence 
is denoted byjj, e.g.,jhij= 0. the set of all Ô¨Ånite sequences
over setsis denoted by s. letu;v2sbe two sequences,
theconcatenation operation denoted by =uvis deÔ¨Åned
as:f1;2;:::juj+jvjg !s, such that (i) =u(i)for
1ijuj, and(i) =v(i juj)forjuj+ 1ijuj+jvj.
deÔ¨Ånition 1: (sequence projection ) letxbe a set and
qxbe its subset.q2x!qis a projection function
and is deÔ¨Åned recursively: hiq=hi; and for2xandx2x:
(hxi)q=qif x =2q
hxi(q)if x2q(1)
deÔ¨Ånition 2: (labeled petri net [13]) a labeled petri net
is a 4-tuple pn= (p;t;f;l ), satisfying (1) p\t=;,
p[t6=;wherepis the place set and tis the transition
set; (2) f(pt)[(tp)is the Ô¨Çow relation; and (3)
l:t!ais a labeling function where ais a set of labels
and2adenotes invisible label.
given a pn= (p;t;f;l), we deÔ¨Åne the preset and post-
set of transitions and places. for each x2p[t, the set
x=fyj(y;x)2fgis the preset (input) of xandx=
fyj(x;y)2fgis the postset (output) of x. to describe the
semantics of a labeled petri net, we use markings . a marking
mofpnis a multiset of places, i.e., m2np, indicating how
many tokens each place contains. markings are state of a net.
(pn;m0)is amarked net wherem0is its initial marking . a
transitiont2tisenabled in marking m2np, denoted as
(pn;m)[t>if and only if8p2t:m(p)1. an enabled
transitiontmay Ô¨Åreand results in a new marking m0with
m0=m t+t, denoted by (pn;m)[t>(pn;m0).
1http://www.3tu-bsr.nl/doku.php?id=startexecution recording
software execution data
software sytems
t1a bc
det1a bc
de
f g h i
t1a bc
de
h icomponent behavioral modelsoftware event log
‚Ä¶
software event log
software event log
hierarchical software event log
‚Ä¶
hierarchical software event loghierarchical software event log
component behavioral model
component behavioral modelfig. 1. software component behavior discovery: an overview of the approach
iv. c omponent behavior discovery
this section details the main approach to discover com-
ponent behavioral models from software execution data. in
section iv-a, we give an overview of our approach. in
sections iv-b-iv-c, we present our main discovery approach.
a. approach overview
the input of our approach is software execution data, which
can be obtained by instrumenting and monitoring software
execution. fig. 1 shows an overview of the approach which
consists of three main steps:
1. component instance identiÔ¨Åcation . software typically
contains a set of components . a component is a non-trivial,
nearly independent and replaceable part of software that full-
Ô¨Ålls a clear function in the context of a well-deÔ¨Åned archi-
tecture [5]. starting from the original software execution data,
we Ô¨Årst propose a novel idea to identify component instances.
these serve as the basic case notion to generate a software
event log for each component. here, a component instance
refers to one independent run of a software component.
2. hierarchical software event log construction . because
a software (component) usually has a hierarchical structure
represented as multi-level nested method calls, the discovered
behavioral model should depict this hierarchy nature. for each
component, we recursively transform its software event log to
a hierarchical one using calling relations among methods.
3. component behavioral model discovery . for each
component, we discover a hierarchical behavioral model from
its corresponding hierarchial software event log. given the
hierarchy of a software event log, we only need to traverse
through different levels of the log and discover a process model
for each sub-log. note that we can use any existing process
discovery approach in this step.
b. software component instance identiÔ¨Åcation
the starting point of our component behavior discovery
approach is the software execution data and the method call
is the basic unit in these data.
deÔ¨Ånition 3: (method call, attribute ) letumbe the
method call universe. a method call may have various at-
tributes. let uabe the attribute universe, i.e., a set ofattribute names. for each method call m2umand attribute
an2ua,#an(m)is the value of an form.
in the following, let unbe the method universe, uclbe
the class universe, ucobe the class object universe, and ut
be the time universe. we assume that each method call m2
umhas at least the following standard (mandatory) attributes:
#calleem (m)2unis the callee method name of m;
#calleec (m)2uclis the callee class name of m;
#calleeco (m)2ucois callee class object identiÔ¨Åer of m;
#callerm (m)2unis the caller method name of m;
#callerc (m)2uclis the caller class name of m;
#callerco (m)2ucois caller class object identiÔ¨Åer of m;
#starttime (m)2utis the start timestamp of m; and
#endtime (m)2utis the end timestamp of m.
deÔ¨Ånition 4: (software execution trace/data ) letum
be the method call universe. umis a software execution
trace. sdp(um)is software execution data such that
8i;j2sd:i\j=;_i=j.
given a software system, it contains a set of interacting
components. according to deÔ¨Ånition 4, software execution
data are composed of a set of execution traces, each describing
a set of interacting components. the term of component is
generic, and typically consists of a group of classes. given
software whose development documents are well organized
and kept, we have information of how classes are grouped to
form components [5]. therefore, we can pre-process software
execution data to obtain a set of software component execution
data. consider for example the software execution data in
table i, it is composed of one software execution trace e.
each row corresponds to a method call, we use idto uniquely
represent each method call, e.g., e1is the Ô¨Årst method call.
a component cuclis a set of classes and p(ucl)
is the component universe. in this paper, we assume classes
are uniquely identiÔ¨Åable by using packages as the preÔ¨Åx.
given a piece of software, comp(ucl)is its com-
ponent set. we assume components of the same software
cannot overlap, i.e., for any ci;cj2com ,ci\cj=;or
ci=cj. for instance, we assume the software execution data
in table i has two components: c1=fclass1;class2gand
c2=fmainclassg.table i
anexample of software execution data
id callee method callee class callee class object caller method caller class caller class object
e1 init() class2 @5746e7cc main() mainclass @mainclass
e2 init() class1 @3b7359cb main() mainclass @mainclass
e3 setclass1() class2 @5746e7cc init() class1 @3b7359cb
e4 perform() class1 @3b7359cb main() mainclass @mainclass
e5 work() class2 @5746e7cc perform() class1 @3b7359cb
e6 init() class1 @614b152d main() mainclass @mainclass
e7 setclass1() class2 @5746e7cc init() class1 @614b152d
e8 perform() class1 @614b152d main() mainclass @mainclass
e9 work() class2 @5746e7cc perform() class1 @614b152d
e10 main() mainclass @mainclass null null null
deÔ¨Ånition 5: (software component execution trace/-
data ) let comp(ucl)be the component set of a
piece of software, sdp(um)be its software execution
data and c2com be one software component. for each
2sd,c=fe2j#calleec (e)2cgis the software ex-
ecution trace of component c.sdc=fcj2sdgis the
software execution data of component c.
according to deÔ¨Ånition 5, the example execution
traces of c1andc2in table i are c1=
fe1;e2;e3;e4;e5;e6;e7;e8;e9gandc2=fe10g.
a component instance represents one run of the component
and a software component execution trace may contain one
or more interleaved component instances. in this work, we
propose to split each component execution trace into different
independent ones. to identify a component instance, we make
the observation that for an object-oriented software, a com-
ponent instance starts when its class objects are constructed.
then a component instance contains: (1) the Ô¨Årst class object
constructed by an external component; and (2) all class objects
that interact (directly or indirectly) with the Ô¨Årst constructed
object. to identify independent component instances, we pro-
pose to: (1) construct a class object interaction graph for each
software component execution trace; and (2) detect its weakly
connected components which represent different instances.
deÔ¨Ånition 6: (class object interaction graph )
let c2com be one software component and
sdcbe its software component execution data. for
eachc2sdc,gc= (vc;rc)is the class
object interaction (coi) graph of csuch that (1)
vc=fo2ucoj9e2c: #calleeco (e) =ogand (2)
rc=f(oi;oj)2vcvcj9e2c:#callerco (e) =oi^
#calleeco (e) =ojg.
according to deÔ¨Ånition 6, a coi graph contains (1) a
set of class objects, i.e. vertices; and (2) a set of inter-
action relations between them, i.e., edges. it is worth not-
ing that the interaction relation among class objects is ob-
tained from the calling relation among method calls. given
a class object interaction graph coi, we use coi.v and
coi.r to represent its vertex and edge sets. considering
the example trace c1ofc1, its class object interaction
graph, denoted as coi1, is shown in fig. 2 (a). its class ob-
ject set coi1.v=f@5746e7cc, @3b7359cb, @614b152d gand
interaction relation set coi1.r=f(@3b7359cb, @5746e7cc) ,
call
call@5746e7cc@3b7359cb
@614b152dcall@5746e7cc@3b7359cb
@614b152d
(a) coi1 of œÉc1 (b) coi2 of œÉc1'fig. 2. examples of class object interaction graphs for two different traces
(@614b152d, @5746e7cc) g. if we modify c1to0
c1=
fe1;e2;e4;e6;e7;e8;e9g, its class object interaction graph,
denoted ascoi2, is shown in fig. 2 (b). the class object set is
coi2.r=f@5746e7cc, @3b7359cb, @614b152d gand the in-
teraction relation set is coi2.v=f(@614b152d, @5746e7cc) g.
after constructing a class object interaction graph, the set
of vertices (class objects) included in each weakly connected
component corresponds to a component instance. a weakly
connected component of a directed graph is a maximal group
of vertices that are mutually reachable by violating the edge
directions. it can be easily obtained by several iterative dfs-
traverse s [12] of its corresponding undirected graph. consider
the execution trace c1and its coi graph in fig. 2 (a), it
has one weakly connected component, which means this trace
only relates to one component instance. consider the execution
trace0
c1and its coi graph in fig. 2 (b), it has two weakly
connected components, which means this trace relates to two
component instances and will be split into two different ones.
deÔ¨Ånition 7: (software component instance ) let
c2sdcbe a software component execution trace and
gc= (vc;rc)be its corresponding class object inter-
action graph. ic=fii
cji1gp (vc)is the compo-
nent instance set of csuch that (1)s
i1ii
c=vc; (2)
8
1i<jii
c\ij
c=;^rc\((ii
cij
c)[(ij
cii
c)) =;;
and (3) @i0
cp(vc) :ji0
cj>jicj.
by recursively applying deÔ¨Ånition 7 to each software ex-
ecution trace of a component, we can identify all instances
of this component. to enable the discovery of the behavior
of software components using process mining techniques,
software event logs of each component are required as input.
a software event log is obtained from a software component
execution data by instance identiÔ¨Åcation. each software caseis deÔ¨Åned as a sequence of software events refer to one
identiÔ¨Åed component instance, and a software event refers
to a method call. therefore, all attributes deÔ¨Åned on method
calls are included for software events. to explicitly capture all
information that may exist in software event logs, we formalize
software events and their attributes as follows:
deÔ¨Ånition 8: (software event ) let sdcbe the software
execution data of component c.e=s
c2sdcfeje2cgis
the software event set of component c. all events e2ehave
the following standard attributes: (1) #case(e) =ii
cwhere
ii
c2icand#calleeco (e)2ii
c, is thecase ofe; (2)
#act(e) = (# calleec (e);#calleem (e))is theactivity ofe;
and (3) #time(e) = # starttime (e)is thetimestamp ofe.
a software event is identiÔ¨Åed by its activity name, e.g.,
#act(e1) = ( class2;init()), and is denoted as class2:init().
deÔ¨Ånition 9: (software case, software event log ) let
ebe the software event set of component c. the software
event log over e, denoted as l=f'j'2eg, is a Ô¨Ånite
set of cases such that (1) each software event appears only
once in each case, i.e., 8'2l,16i<j6j'j:'i6='j;
(2) each software event appears in one and only one case, i.e.,
8e2e;9'2l:e2'^@'02l;'06=':e2'0; (3) all
events in the same case have the same #case attribute
value, i.e.,8'2l;16i;j6j'j: #case('i) = # case('j);
(4) all events with the same #case attribute value are in
the same case, i.e., 8ei;ej2e: #case(ei) = # case(ej))
9'2l:ei;ej2'; and (5) all events
of the same case are ordered by the timestamp, i.e.,
8'2l;1i<jj'j: #time('i)#time('j).
in the following discussion, we use e(l) =s
'2lfeje2'g
to denote the event set of a software event log l.
c. component behavioral model discovery
the software event log of a component contains a set
of cases, each describing one component instance, based on
which we can discover the component behavioral model.
because a component usually has a hierarchical structure
represented as multi-level nested method calls, the discovered
component behavioral model should be able to depict this.
after obtaining a software event log, we recursively transform
it to a hierarchical one using the calling relation among
methods. to deÔ¨Åne the hierarchical structure, we Ô¨Årst deÔ¨Åne its
root that we call main (or top-level) event log. it is composed
of a set of events whose caller classes do not belong to the
current component, i.e., they are invoked by other components.
deÔ¨Ånition 10: (main event log ) let c2p(ucl)be a
software component, lbe its software event log and e(l)
be its event set. me(l) =fe2e(l)j9'2l:e2'^
#calleec (e)2c^#callerc (e)=2cgis the main event set of
l.mlog 0=f'me(l)j'2lgis the main event log of l.
to introduce the nesting relationships in the hierarchical
structure, we deÔ¨Åne the nested event set and events invoked
by each nested event in the following.
deÔ¨Ånition 11: (nested event set ) letlbe a software event
log ande(l)be its event set. ne(l) =fne2e(l)j9'2
calle1e2e4 e8
e3e5 e9e6
e7call call callfig. 3. hierarchical structure of c1
l;e2':ne2'^#callerco (e) = #calleeco (ne)gis the
nested event set of l.
deÔ¨Ånition 12: (invoked event set ) letlbe a software
event log,e(l)be its event set and ne(l)be its nested event
set. the event set of linvoked by ne2ne(l)is deÔ¨Åned as:
ie(ne;l) =fe2e(l)j9'2l:e2'^#callerco (e) =
#calleeco (ne)g.
according to deÔ¨Ånitions 11-12, the nested event set of c1
isfe2;e4;e6;e8gand the invoked event set of e2isfe3g.
given a software event log landmlog 0is its main
event log, neh(mlog 0) =e(mlog 0)\ne(l)is the nested
event set of mlog 0andnec
h(mlog 0) =f#act(e)je2
neh(mlog 0)gis the nested event class set of mlog 0.
deÔ¨Ånition 13: (hierarchical software event log ) letl
be a software event log. hl(l) = ( mlog 0;hl(mlog 0))is
deÔ¨Åned as the hierarchical software event log of lwhere:
mlog 0is the main event log of l; and
hl(mlog 0)=;ifneh(mlog 0) =;; otherwise
hl(mlog 0)=f(nec;ilog nec;hl(ilog nec))jnec2nec
h(mlog 0)g
where ilog nec=s
ne2neh(mlog 0)f'ie(ne;l)j'2l^
#act(ne) =necgis the invoked event log of lbynec.
taking a software event log with only trace c1as
example. its hierarchical structure is shown in fig. 3.
according to deÔ¨Ånitions 10-11, its main event log is
mlog 0= [he1;e2;e4;e6;e8i], its nested event set is
neh(mlog 0) =fe2;e4;e6;e8gand nested event class set
is nec
h(mlog 0) =fclass1:init();class1:perform ()g.
then, the event logs invoked by class1:init()and
class1:perform ()are ilog class1:init()= [he3i;he7i]and
ilog class1:perform ()= [he5i;he9i]. the recursive deÔ¨Ånition
stops at this level as the invoked event logs of class1:init()
andclass1:perform ()do not contain any nested events.
given the hierarchy of a software event log, we need
to discover a hierarchical process model to explicitly show
the behavior. for this step, we can recursively apply any
process discovery approach, including techniques such as the
inductive miner [7]. instead of obtaining a normal petri net, the
discovered petri net is extended with a set of nested transitions.
deÔ¨Ånition 14: (petri net with nested transitions ) apetri
net with nested transitions is a 2-tuple pnn= (pn;n)such
that (1) pn= (p;t;f;l)is a labeled petri net; and (2) n:
t!fa;ngis a mapping function such that 8t2t,n(t) =
arepresentstis an atomic transition and n(t) =nrepresents
tis a nested transition.
given a pnn, we denote by ta=ft2tjn(t) =ag
the atomic transition set and tn=ft2tjn(t) =ngthe
nested transition set. in the following, we will use the notation
ta0andtn0forpnn0. fig. 4 shows a simple example ofm nfig. 4. an example of petri net with nested transitions
class2.init() class1.init() class1.perform()
class2.setclass1() class2.work()pnn1 pnn2
fig. 5. an example hierarchical petri net with nested transitions
petri net with nested transitions where an atomic transition
is drawn using single-line rectangle ( m) and a double-line
rectangle ( n) is used to draw a nested transition.
letupnbe the universe of petri net with nested transitions.
based on calling relation, we recursively deÔ¨Åne the hierarchi-
cal petri net with nested transitions .
deÔ¨Ånition 15: (hierarchical petri net with nested transi-
tions )hpn = (pnn0;hpn (pnn0))is deÔ¨Åned as a hierar-
chical petri net with nested transitions where: pnn02upn
is the top-level petri net with nested transitions; and
hpn (pnn0) =;iftn0=;; otherwise
hpn (pnn0) =f(ti;pnni;hpn (pnni))jti2tn0g
where pnni2upn is the petri net with nested
transitions that is called by ti.
the behavior discovery approach takes a hierarchical soft-
ware event log as input, and discovers a hierarchical petri
net with nested transitions. as the hierarchical software event
log already has the notion of hierarchies, we only need to
(1) traverse different levels of software event log to discover
itspnnand (2) construct the mapping from each nested
transition (nested event class) to its corresponding pnn.
deÔ¨Ånition 16: (discovery ) letuhlbe the universe of
hierarchical software event log and uhpnbe the universe of hi-
erarchical petri net with nested transitions. d:uhl!uhpn
is a discovery function such that for each hl(l)2uhl,
d(hl(l)) =hpn is deÔ¨Åned as following:
pnn0= (pn0;n0)such that: pn0=(mlog 0)where
represents a process discovery algorithm; and 8t2t0,
n0(t) =n if9nec2nec
h(mlog 0) :l(t) =nec,
n0(t) =aotherwise; and
hpn (pnn0) =;iftn0=;; otherwise
hpn (pnn0) =f(ti;pnni;hpn (pnni))jti2tn0g
where pnni= (pni;ni) such that
pni=(ilog nec) where nec2nec
h(mlog 0)
and nec=l(ti); and8t2ti,ni(t) =n if
9nec02nec
h(ilog nec):l(t)=nec0;ni(t)=aotherwise.
an example of a hierarchical petri net is shown in fig. 5.
it can be obtained from the example execution trace c1. the
top-level pnncontains one normal transition ( class2.init() )
and two nested transitions each referring to a petri net
with nested transitions. more speciÔ¨Åcally, nested transition
class1.init() refers to pnn1andclass1.perform() calls pnn2.
because both pnn1andpnn2do not contain any nested
transitions, the recursive deÔ¨Ånition stops at this level.v. i mplementation in prom
the open-source (pro)cess (m)ining framework prom 6
[18] has been developed as a completely plugable environment
for process mining and related topics. it can be extended by
adding plug-ins, and currently, more than 1500 plug-ins are
included. the framework can be downloaded freely2.
the proposed software component behavior discovery ap-
proaches have been implemented as two consecutively exe-
cuted plug-ins in our prom 6 package3. the Ô¨Årst one, called
identifying software event log of components , is used to
generate a set of software event logs for different components
by taking (1) the original software execution data, and (2) a
conÔ¨Åguration Ô¨Åle describing which classes belong to which
components. the second plugin, software component behav-
ior discovery , takes the software event log of each component
as input, and returns its behavioral model.
vi. e xperimental analysis
in this section, we use an online bookstore software as
a case to show that the proposed approach exploits both
component information and hierarchical structure and as a
result produces more understandable behavioral models. this
case contains three components, i.e., starter ,searchoffer and
orderanddelivery . the starter component contains book-
storestarter class, the searchoffer component consists cat-
alog,bookseller andbookstore classes, and the orderandde-
livery component contains order class and delivery classes.
more speciÔ¨Åcally, the software starts with the instantiation of
thestarter component, the searchoffer component is used to
get an offer for each book and the orderanddelivery compo-
nent is used to generate book orders and perform delivery for
all selected books. we Ô¨Årst instrument the source code using
kieker framework [19]. therefore, the method invocations
are stored as software execution data. each method call has
all attributes deÔ¨Åned in deÔ¨Ånition 3. in this experiment, we
created a software execution data by collecting 20 traces which
cover all possible execution scenarios.
without considering component information and hierar-
chical structure of the software, we can directly transform
the original software execution data (i.e., without using the
approach described). this yields a software event log with
20 cases, denoted as onlinebookstore.xes , where each case
refers to an execution trace. taking this event log as input,
we run the inductive miner with default settings and discover
a behavioral model as shown in fig. 6. it is a Ô¨Çat petri net
model where the labeled transitions represent methods and
the places represent method invocation relations. the model
is a bit spaghetti-like and contains misleading behavior which
hinders the understanding of how software really behaves. for
example, the model has some self-loops which do not exist in
our software implementation. using our approach, we split the
software execution data to different components, and a set of
software event logs each refers to one component are obtained.
2http://www.processmining.org
3https://svn.win.tue.nl/repos/prom/packages/congliu/fig. 6. behavioral model of online bookstore software without hierarchy
call
@91adf07
:catalog@f724bd0
:bookseller
@11671cbc
:bookstore
@796ed69e
:catalogcall
@4604eecb
:bookstore
call call@5bcc5d5a
:booksellerinstancei
instancej
fig. 7. class object interaction graph of one execution trace
in addition, one software execution may trigger multiple
executions of a component, i.e., multiple component instances.
for example, the instance number of component searchoffer is
the same with the number of searched books as this component
is iteratively instantiated for each book. fig. 7 gives an
example of class object interaction graph of one searchoffer
component execution trace. it contains two weakly connected
sub-graphs, each refers to one instance of searchoffer com-
ponent. next, we refactor each component log by identifying
component instances as new case notion using the approach
insection iv-b.
according to table ii, the refactored logs of different
table ii
software event logsizecomparison
log name number of cases
onlinebookstore.exs 20
starter.xes 20
searchoffer.xes 54
orderanddelivery.xes 20
searchoffer starter orderanddeliveryfig. 8. behavioral models of different components
callcall
fig. 9. behavioral model of the searchoffer component
components are starter.xes with 20 cases, searchoffer.xes with
54 cases, and orderanddelivery.xes with 20 cases. the reason
why searchoffer.xes has more than 20 cases is that each
execution will invoke an arbitrary number (exactly the number
of searched books) of instances. taking these refactored logs
as inputs, we run the inductive miner again for different
components and obtain one behavioral model per component
as shown in fig. 8. fig. 8 shows three Ô¨Çat petri nets each
describing the behavior of one component. the behavioral
model of each component is much simpler compared to that in
fig. 6. however, given the observation that software usually
has a hierarchical structure implemented as multi-level nested
method calls, the discovered Ô¨Çat models still cannot give an
accurate description of its actual behavior.
next, we take the notion of hierarchy into account and
perform hierarchial behavior discovery for each componentcallfig. 10. behavioral model of the orderanddelivery component
using the approach in section iv-c. the discovered hierarchi-
cal behavioral models of searchoffer andorderanddelivery
are shown in figs. 9-10 where: (1) a single-line rectangle rep-
resents an atomic method call; and (2) a double-line rectangle
stands for a nested method call which refers to another sub-net.
by comparing the Ô¨Çat model in fig. 6 with the hierar-
chical models of each component, we argue that the use of
component information and hierarchy helps to give a better
understanding of how software behaves from the perspective
of individual component.
vii. c onclusion
by exploiting tremendous amounts of software execution
data, this paper proposes to utilize process mining techniques
to discover behavioral models for each software component.
to do this, we Ô¨Årst identify component instances and construct
software event logs for each component from the raw software
execution data. then, based on the software event log, we con-
struct its corresponding hierarchical software event log using
calling relations among methods. next, the software behavioral
model, represented as a hierarchical petri net with nested
transitions, is discovered from a hierarchical software event log
by recursively applying existing process discovery techniques.
our proposed approaches are demonstrated through an online
bookstore software case and implemented in the open source
process mining toolkit prom.
this work serves as a starting point for several re-
search directions. given a software with several components,
these components usually interact with each other by inter-
component method invocations. the representation and dis-
covery of inter-component interactions are our on-going work.
a component is a set of classes collaborating to perform a
particular function. this paper assumes that the mappings
between classes and components are known beforehand. in
real-life cases, for instance some legacy software systems, the
development documents are incomplete or even unavailable.
automatic identiÔ¨Åcation of components (groups of classes)
from software execution data will be investigated in the future.references
[1] w. v. d. aalst, ‚Äúbig software on the run: in vivo software analytics based
on process mining (keynote),‚Äù in proceedings of the 2015 international
conference on software and system process . acm, 2015, pp. 1‚Äì5.
[2] a. w. biermann and j. a. feldman, ‚Äúon the synthesis of Ô¨Ånite-
state machines from samples of their behavior,‚Äù ieee transactions on
computers , no. 6, pp. 592‚Äì597, 1972.
[3] l. c. briand, y . labiche, and j. leduc, ‚Äútoward the reverse engineering
of uml sequence diagrams for distributed java software,‚Äù software
engineering, ieee transactions on , vol. 32, no. 9, pp. 642‚Äì663, 2006.
[4] r. conforti, m. dumas, l. garc ¬¥ƒ±a-ba Àúnuelos, and m. la rosa, ‚Äúbpmn
miner: automated discovery of bpmn process models with hierarchical
structure,‚Äù information systems , vol. 56, pp. 284‚Äì303, 2016.
[5] s. d. kim and s. h. chang, ‚Äúa systematic method to identify software
components,‚Äù in software engineering conference, 2004. 11th asia-
paciÔ¨Åc . ieee, 2004, pp. 538‚Äì545.
[6] m. leemans and w. m. van der aalst, ‚Äúprocess mining in software
systems: discovering real-life business transactions and process models
from distributed systems,‚Äù in model driven engineering languages and
systems (models), 2015 acm/ieee 18th international conference on .
ieee, 2015, pp. 44‚Äì53.
[7] s. j. leemans, d. fahland, and w. van der aalst, ‚Äúdiscovering block-
structured process models from event logs-a constructive approach,‚Äù in
application and theory of petri nets and concurrency . springer, 2013,
pp. 311‚Äì329.
[8] j. li, r. j. c. bose, and w. m. van der aalst, ‚Äúmining context-dependent
and interactive business process maps using execution patterns,‚Äù in
business process management workshops . springer, 2010, pp. 109‚Äì
121.
[9] d. lo, l. mariani, and m. pezz `e, ‚Äúautomatic steering of behavioral
model inference,‚Äù in proceedings of the the 7th joint meeting of the
european software engineering conference and the acm sigsoft
symposium on the foundations of software engineering . acm, 2009,
pp. 345‚Äì354.
[10] x. lu, m. nagelkerke, d. v. d. wiel, and d. fahland, ‚Äúdiscovering
interacting artifacts from erp systems,‚Äù services computing, ieee trans-
actions on , vol. 8, no. 6, pp. 861‚Äì873, 2015.
[11] m. mcgavin, t. wright, and s. marshall, ‚Äúvisualisations of execution
traces (vet): an interactive plugin-based visualisation tool,‚Äù in pro-
ceedings of the 7th australasian user interface conference-volume 50 .
australian computer society, inc., 2006, pp. 153‚Äì160.
[12] h. nagamochi and t. ibaraki, algorithmic aspects of graph connectivity .
cambridge university press new york, 2008, vol. 123.
[13] w. reisig, petri nets: an introduction . springer science & business
media, 2012, vol. 4.
[14] v . rubin, c. w. g ¬®unther, w. m. van der aalst, e. kindler, b. f.
van dongen, and w. sch ¬®afer, ‚Äúprocess mining framework for software
processes,‚Äù in software process dynamics and agility . springer, 2007,
pp. 169‚Äì181.
[15] w. van der aalst, process mining: data science in action . springer,
2016.
[16] w. van der aalst, t. weijters, and l. maruster, ‚ÄúworkÔ¨Çow mining:
discovering process models from event logs,‚Äù knowledge and data
engineering, ieee transactions on , vol. 16, no. 9, pp. 1128‚Äì1142, 2004.
[17] w. m. van der aalst, a. kalenkova, v . rubin, and e. verbeek,
‚Äúprocess discovery using localized events,‚Äù in international conference
on applications and theory of petri nets and concurrency . springer,
2015, pp. 287‚Äì308.
[18] b. f. van dongen, a. k. a. de medeiros, h. m. w. verbeek, a. j.
m. m. weijters, and w. m. p. van der aalst, ‚Äúthe prom framework:
a new era in process mining tool support,‚Äù in proceedings of the 26th
international conference on applications and theory of petri nets , ser.
icatpn‚Äô05. berlin, heidelberg: springer-verlag, 2005, pp. 444‚Äì454.
[19] a. van hoorn, m. rohr, w. hasselbring, j. waller, j. ehlers, s. frey,
and d. kieselhorst, ‚Äúcontinuous monitoring of software services: design
and application of the kieker framework,‚Äù 2009.
[20] n. walkinshaw and k. bogdanov, ‚Äúinferring Ô¨Ånite-state models with
temporal constraints,‚Äù in proceedings of the 2008 23rd ieee/acm
international conference on automated software engineering . ieee
computer society, 2008, pp. 248‚Äì257.