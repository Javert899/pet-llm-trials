mining process models with prime invisible
tasks
lijie wen1;2, jianmin wang1;4;5, wil m.p. van der aalst3, biqing huang2, and
jiaguang sun1;4;5
1school of software, tsinghua university, beijing, china
wenlj00@mails.thu.edu.cn, fjimwang, hbq, sunjg g@tsinghua.edu.cn
2department of automation, tsinghua university, beijing, china
3department of mathematics & computer science, eindhoven university of
technology, eindhoven, the netherlands.
w.m.p.v.d.aalst@tue.nl
4key laboratory for information system security, ministry of education
5tsinghua national laboratory for information science and technology (tnlist)
abstract. process mining is helpful for deploying new business pro-
cesses as well as auditing, analyzing and improving the already enacted
ones. most of the existing process mining algorithms have problems in
dealing with invisible tasks, i.e., such tasks that exist in a process model
but not in its event log. this is a problem since invisible tasks are mainly
used for routing purpose but must not be ignored. in this paper, a new
process mining algorithm named ®#is proposed, which extends the min-
ing capacity of the classical ®algorithm by supporting the detection of
prime invisible tasks from event logs. prime invisible tasks are divided
into three types according to their structural features, i.e., skip, redo
and switch. after that, the new ordering relation for detecting men-
dacious dependencies between tasks that re°ects prime invisible tasks
is introduced. a reduction rule for identifying redundant \mendacious"
dependencies is also considered. then the construction algorithm to in-
sert prime invisible tasks of skip/redo/switch types is presented.
the proposed ®#algorithm has been evaluated using both arti¯cial and
real-life logs and the results are promising.
1 introduction
process mining aims at the automatic discovery of valuable information from an
event log. the ¯rst dedicated process mining algorithms were proposed in [10,
11]. the discovered information can be used to deploy new systems that support
the execution of business processes or as an analytical tool that helps in auditing,
analyzing and improving already enacted business processes. the main bene¯t
of process mining techniques is that information is objectively compiled. in other
words, process mining techniques are helpful because they gather information
about what is actually happening according to an event log of an organization,
and not what people think is happening in this organization.the scenarios of applying process mining technology are illustrated in fig-
ure 1. this ¯gure shows that process mining can be used in two ways, i.e., before
and after an information system supporting business processes is deployed. in
the ¯rst scenario, the event logs are collected manually. process mining can be
used to mine a process model (i.e., process visualization ) from a given log and
compare the behaviors of the mined model with the given log (i.e., conformance
testing ). in the second scenario, process mining can be used in a similar way
except that the event logs are recorded by information systems automatically.
moreover, we can compare the mined process model with the prede¯ned one to
¯nd the discrepancies between them (i.e., delta analysis ).
predefined and 
mined process 
models event logs 4. process mining operational 
processes 
5.1 conformance 
testing 2. config 
5.2 delta 
analysis information 
systems support/
control 
a. collect 1 . mo d e l
3 . re c o rd
mined 
process 
models b. process mining 
c. conformance 
testing scenario 1
scenario 2
fig. 1. the scenarios of applying process mining technology
although quite a lot of work has been done on process mining, there are
still some challenging problems left [4{7, 20], i.e., short loops, duplicated tasks,
invisible tasks, non-free-choice constructs, time, noise, incompleteness, etc. the
issue of short loops is solved in [21]. for discussions about duplicated tasks,
readers are referred to [16, 17, 22]. [22, 27, 28] attempt to resolve most kinds of
non-free-choice constructs. time aspects are partially considered in [2]. noise
and incompleteness are discussed in [19]. in this paper, we will investigate how
to mine process models with prime invisible tasks from event logs.
1.1 motivation
invisible tasks are such tasks that exist in a process model but not in its event
log. they are di±cult to mine because they do not appear in any event trace of
an event log. however, they are very common in real-life process models. the
following situations can lead to process models containing invisible tasks:
{there are tasks in process models that are used for routing purpose only. the
executions of such routing tasks are not recorded automatically or manually.{there are real tasks that have been executed but they are systematically
lost in event traces (i.e., not recorded).
{the enactment services of processes allow skipping or redoing current task
and jumping to any previous task as a result of human interventions to
improve the °exibility of execution[8]. but such human interventions cannot
be expressed in the control °ow of the process model in order to keep the
model as simple and clear as possible.
there are quite a number of real-life business processes containing invisi-
ble tasks. when deploying our product lifecycle management system named
tiplm6for shaoxing electric power bureau7, zhejiang province, china, we
found that the deployed 43 process models corresponding to business processes
in this organization all contain many invisible tasks. tiplm contains a busi-
ness process management subsystem named tiwork°ow and there are routing
tasks in process models whose executions are not recorded in event traces. fig-
ure 2 shows one of these process models, which is modeled in the system speci¯c
language of tiwork°ow.
for each process model in tiwork°ow similar to that shown in figure 2, there
should be only one start node (the green circle) and only one end node (the red
round rectangle). the diamonds represent the task nodes and the other kinds of
nodes are routing nodes, i.e., and-split, and-join, xor-split and xor-join. it
is the change process of design drawings. there are totally three kinds of virtual
or real objects in this process, i.e., change request ,change task andchanged
drawings . the change request will pass through apply ,audit tasks. if the result of
audit is negative, the process ends. otherwise, the change task will pass through
dispatch ,assign ,modify andverify tasks. after that, the changed drawings will
pass through review ,review technically andprint and dispatch tasks. if one of
the results of the two review tasks is negative, the process will come back to the
assign task. when the process instances are executed, tiwork°ow engine only
records the executions of task nodes. the executions of routing nodes are totally
ignored. in the business environment before tiplm was deployed, similar things
happened and the event traces were recorded manually on paper.
for the process model shown in figure 2, it can be easily seen that the number
of routing nodes is about half of the number of all nodes, i.e., 12/27 ¼44.4%.
table 1 shows the proportions for routing nodes out of all nodes in each of the
above-mentioned 43 process models taken from shaoxing electric power bureau.
the average proportion nearly approaches 40%. in other organizations (such as
xiamen king long united automotive industry co. ltd.8and hebei zhongxing
automobile manufacture co. ltd.9, etc.) that have deployed tiplm, similar
ratios are found. it shows that the need for mining process models with invisible
tasks from event logs is high, i.e., one cannot assume that the mined process
only contains visible tasks.
6http://www.thit.com.cn/tiplm/tiplm.htm
7http://www.sx.zpepc.com.cn
8http://www.xmklm.com.cn/english/js6.jsp
9http://www.zxauto.comfig. 2. the change process of design drawings de¯ned in tiwork°owtable 1. the proportion for routing tasks out of all tasks in real-life process models:
nrt-the number of routing tasks, nat-the number of all tasks
the name of each process model nrtnatproportion
change process 7 40 17.5%
technical change noti¯cation process 8 39 20.5%
change process of design drawings 12 27 44.4%
debug process of drawings in control center 21 40 52.5%
debug process of drawings in circuitry work area 21 40 52.5%
debug process of drawings in remedy work area 21 40 52.5%
debug process of drawings in operation work area 21 40 52.5%
process for checking completion on rebuilt engineering 62 136 45.6%
process for checking completion on new engineering 64 139 46.0%
¢¢¢ ¢¢¢ ¢¢¢ ¢¢¢
summary 1317 3306 39.8%
1.2 problems related to invisible tasks
the problems encountered when mining process models using the classical ®
algorithm [7] from event logs generated by wf-nets (see [1]) containing invisible
tasks will be investigated in this subsection. for example, in figure 3 and figure
4,n1ton6are the original wf-nets and n0
1ton0
6are the corresponding mined
models derived from the complete event logs w1tow6respectively by using ®
algorithm10. the black block transitions without labels represent invisible tasks.
all the original wf-nets are sound, but the mined models have various problems.
b
c e
db
c e
dw 1={bde, dbe, bce, cbe} n 1 n 1'= α(w 1)
b a cn 2 w 2={ac, abc}
b a c
b a cn 3 w 3={abc, abbc}
b a cn 2'= α(w 2)
n 3'= α(w 3)
fig. 3. problems encountered when mining process models using ®algorithm: case one
tasks bandcas well as banddare parallel in n1, while they are mutually
exclusive in n0
1. here n0
1is not a sound wf-net because a deadlock will always
10a log is complete if it contains information about all causal dependencies [7]. this
notion will be explained later.occur. although n0
2is a sound wf-net, ccannot directly follow aandn0
2
contains an implicit place. as a result, the behavior of n0
2is not equivalent with
that of n2because it cannot produce the event trace ac. inn3,bbehaves
like a length-one-loop task. however, cnever directly follows a. there will not
a place connecting aandcinn0
3, which should be the only place associated
with b. here n0
3is not a wf-net at all. n0
4,n0
5andn0
6are all wf-nets but not
sound. n4is more general than n2andn3is a special case of n5. the invisible
task in n6connects two separate execution branches.
b a c d b a c dn 4 w 4={ad, abcd} n 4'= α(w 4)
b a c dn 5 w 5={abcd, abcbcd}
b a c dn 5'= α(w 5)
a c
b da c
b dn 6 w 6={ac, ad, bd} n 6'= α(w 6)
fig. 4. problems encountered when mining process models using ®algorithm: case two
the steps for constructing the mined model in ®algorithm result in the above
issues. each mined process model has one of the following features.
1.it is a sound wf-net, but it cannot reproduce the given log, e.g., n0
2.
2.it is a wf-net but not sound and cannot reproduce the given log, e.g., n0
1,
n0
4,n0
5andn0
6.
3.it is not a wf-net at all. it cannot reproduce the given log and may even
generate lots of redundant event traces, e.g., n0
3.
in this paper, a new mining algorithm will be proposed based on the ®algo-
rithm, in which most invisible tasks can be derived correctly and e±ciently. we
choose the ®algorithm as a base for its theoretical foundation. still the correct-
ness of detection method for invisible tasks will be proved and the classi¯cation
of invisible tasks will be provided.
the remainder of the paper is organized as follows. section 2 introduces
related work on mining invisible tasks. section 3 gives the classi¯cation of invisi-
ble tasks according to their structural features, i.e., typical patterns encountered
when dealing with invisible tasks. the detection methods of invisible tasks are
proposed in section 4. the new mining algorithm ®#is presented in section 5.
section 6 shows the evaluation results on the new algorithm using both arti¯cial
and real-life event logs. section 7 concludes the paper and gives future work.2 related work
here only process mining algorithms based on petri nets [12, 23] are considered.
for other process mining algorithms not based on petri net, which do not need to
concern invisible tasks, their emphases are focused on the e±cient identi¯cation
of relationships (i.e., and-split, xor-split, and-join and xor-join) between
each pair of input/output arcs of the same task [9{11, 14, 15, 26].
a synchro-net based mining algorithm is proposed in [18]. the authors state
that short loops and invisible tasks can be handled with ease. however, neither
the original model nor the mined model contains any invisible task. in the mining
algorithm, no steps seem to handle invisible tasks.
[25] attempts to mine decisions from process logs, which emphasizes detect-
ing data dependencies that a®ect the routings of cases. when interpreting the
semantics of the control °ows in the mined decisions, the authors propose a de-
scriptive method to identify decision branches starting from invisible tasks. this
method cannot handle all kinds of invisible tasks. even when there are other
decision points with join nodes on one decision branch, the method fails.
the genetic mining algorithm (ga for short) is the only method that natively
supports the detection of invisible tasks [22]. it uses the basic idea of the genetic
algorithm and de¯nes two genetic operators for process mining, i.e., crossover
and mutation. it aims at supporting all the common control °ow constructs in
current business processes, especially duplicated tasks, invisible tasks, non-free-
choice constructs. the genetic mining algorithm can partially handle these three
constructs. however, this algorithm needs many user-de¯ned parameters and it
cannot always guarantee to return the most appropriate results within limited
time. the number of invisible tasks in the mined model is often much greater
than that of the original model. as a result, the behavior of the mined model is
not equivalent with that of the original model or does not conform to the event
log. furthermore, the biggest disadvantage of the genetic mining algorithm is its
huge time consumption. even for a small event log generated by a simple process
model, the algorithm takes at least several minutes to mine an acceptable model.
in summary, there is still no e±cient mining algorithm that can handle in-
visible tasks well. this paper will focus on mining process models from event
logs with invisible tasks based on the classical ®algorithm proposed in [7]. it is
also an extension of the work done in [29] by extending the motivation, related
de¯nitions and theorems and the experimental results.
3 de¯nitions and classi¯cation of invisible tasks
first some de¯nitions about invisible tasks in a wf-net will be given (subsec-
tion 3.1). after that, we will introduce the classi¯cation of invisible tasks in detail
(subsection 3.2). note that we assume the reader to be familiar with wf-nets
and soundness. wf-nets are a special class of petri nets with a source place and
a sink place. a wf-net is sound if it is always possible to move a token from
the source place to the sink place, i.e., no deadlocks and livelocks. moreover, allparts of the wf-net are executable (i.e., there are no dead tasks) and the net is
safe (i.e., a place should never hold two or more tokens).
3.1 de¯nitions about invisible tasks
before going into the details about invisible tasks, a function about all traces of
a wf-net should be introduced ¯rst.
de¯nition 1 (trace function traces ).letn= (p; tvstiv; f)be a sound
wf-net. traces (n)µt¤
vis the set of all ¯ring sequences leading from the
marking with a token in the source place ito the marking with a token in
the sink place oby removing all tasks in tivfrom each ¯ring sequence, i.e.,
8t2tv;9¾2traces (n) :t2¾and8¾2traces (n);8t2tiv:t62¾. such a
wf-net nis call iwf-net, here we use a new notation n= (p; tv; tiv; f).
based on an iwf-net and the trace function traces , the conceptual invisible
task can be de¯ned as follows.
de¯nition 2 (invisible task). letn= (p; tv; tiv; f)be a sound iwf-net
andwµtraces (n)be an event log of n. for any task t2tiv,tis an invisible
task with respect to w.
not all invisible tasks can be rediscovered from the corresponding event logs.
in fact, if an invisible task does not a®ect the behavior of a wf-net, it cannot
be detected by any mining algorithm. we will de¯ne so-called \prime invisible
task" formally in the following, which has e®ects on the behavior of a wf-net.
before this, the following concept and two auxiliary notations are given.
de¯nition 3 (invisible elementary path). letn= (p; tv; tiv; f)be a
sound iwf-net. an elementary path is a sequence ep= (n0; n1; : : : ; n k)where
80·i<k: (ni; ni+1)2f,n0; nk2pand80·i;j·k: (ni=nj))(i=j).iep is
invisible i® 80·i·k: (ni2tvstiv))ni2tiv.iep iandiep odenote the
start place and the end place of iep respectively.
an elementary path in an iwf-net is a directed acyclic path, which starts
from a place and walks along the direction of the arc between each pair of
successive nodes and ends with another place. no two nodes on the path are the
same. an invisible elementary path contains only invisible tasks. this concept
will be used in the forthcoming notations. all invisible elementary paths of an
iwf-net nis denoted as iep n.
de¯nition 4 (input/output visible task set). letn= (p; tv; tiv; f)be
a sound iwf-net. for any p2p, we have:
{±p=ft2tvjt2 ²p_ 9iep2 iep n: (t2 ²iep i^p=iep o)g, i.e., p's
input visible task set.
{p±=ft2tvjt2p² _9iep2 iep n: (t2iep o² ^p=iep i)g, i.e., p's
output visible task set.de¯nition 5 (prime invisible task). letn= (p; tv; tiv; f)be a sound
iwf-net and t2tivbe an invisible task. tis prime if the following requirements
hold at the same time:
1.surround. 8p2 ²t;9t02 ²p:t02tvand8p2t²;9t02p²:t02tv, i.e.,
each invisible task should have at least one direct preceding visible task and
one direct successive visible task.
2.succession. 8t02 f±pjp2 ²tg;8t002 fp± jp2t²g: (9¾2traces (n);0<
i <j¾j:t0=¾i^t00=¾i+1), i.e., if two visible tasks aandbare connected
via an invisible elementary path, bcan directly follow ain some traces.
3.necessity. 9t02 f±pjp2t²g;9t002 fp± jp2 ²tg: (8¾2traces (n);0< i <
j¾j:t0=¾i)t006=¾i+1), i.e., the invisible task cannot be removed directly
by merging its input and output places without introducing additional causal
dependencies between visible tasks.
figure 5 lists some wf-nets containing invisible tasks that are not prime
because these wf-nets can be further reduced by simply removing some invisible
tasks or being changed to other ones with equivalent behaviors.
a
t 1
b a(c)
(d) (e)b a ct 1
t 2b a
(a)a
(b)b
t 3 t 2
ed
c
a b
(f)
fig. 5. some invisible tasks that are not prime
for the wf-net shown in figure 5(a), the only invisible task violates require-
ment 3 and it can be removed directly. the invisible task shown in figure 5(b)
does not obey requirement 2 and can be removed too. while for the wf-net
shown in figure 5(c), t1andt2violate requirements 2 and 3 at the same time.
butt3only violates requirement 3. the invisible task shown in figure 5(d)
also violates requirement 3. in figure 5(e), t1andt2have the same function
and both are prime. but none of them violates requirements 2 and 3. however,
one of them should be removed to avoid redundency. the reduction rule will be
illustrated in section 4.2. all invisible tasks in figure 5(f) are not prime because
they all violate requirement 3.
the problem of mining prime invisible tasks can be formalized as follows.de¯nition 6 (mining problem). letn= (p; tv; tiv; f)be a potential
sound iwf-net and wµtraces (n)be an event log of n. the problem of mining
prime invisible tasks is to construct an iwf-net n0= (p0; tv; t0
iv; f0)from w
such that n0is behavior equivalent with nwith respect to wand contains only
minimal prime invisible tasks.
to tell the truth, the original iwf-net nis not necessary to be present and
the log wis enough for a mining algorithm. we can compare the mined model
n0andwto determine whether the mining result is good enough.
3.2 classi¯cation of prime invisible tasks
before detecting prime invisible tasks from event logs, we will ¯rst classify prime
invisible tasks into several types by their structural features. all types (i.e., skip,
redo and switch) of prime invisible tasks were already shown in figure 3
and figure 4. the formal de¯nitions are given one by one in the following.
de¯nition 7 (invisible task of skip type). letn= (p; tv; tiv; f)be an
iwf-net with the source place iand the sink place o. for any task t2tiv,t
is an invisible task of skip type i® there is an elementary path (n0; n1; : : : ; n k)
such that n06=i,nk6=o,n02 ²t,nk2t²and80·i·k:ni6=t. ifk= 2,tis of
short-skip type. otherwise (k >2),tis of long-skip type.
the invisible task in n2is of short-skip type and the one in n4is of
long-skip type. the union of these two subtypes is the skip type. invisible
tasks of this type are used to skip the executions of one or more tasks.
de¯nition 8 (invisible task of redo type). letn= (p; tv; tiv; f)be
an iwf-net. for any task t2tiv,tis an invisible task of redo type i® there
is an elementary path (n0; n1; : : : ; n k)such that n02t²andnk2 ²t. ifk= 2,t
is of short-redo type. otherwise (k >2),tis of long-redo type.
the invisible task in n3is of short-redo type and the one in n5is
of long-redo type. the union of these two subtypes is of the redo type.
invisible tasks of this type are used to repeat the executions of one or more tasks.
a wf-net only containing invisible tasks of short-redo type may generate
behaviors similar (but not the same) to another wf-net only containing length-
1-loops. so the new mining algorithm should have the ability to distinguish the
two totally di®erent structures but with similar behaviors.
de¯nition 9 (invisible task of switch type). letn= (p; tv; tiv; f)
be an iwf-net. for any task t2tiv,tis an invisible task of switch type i®
there are two elementary paths (n0; n1; : : : ; n k)and(m0; m1; : : : ; m j)such that
80<u<k; 0<v<j :nu6=mv,90<x<k :nx2 ²t,90<y<j :my2t²and there is no
elementary path from nxtomy.the invisible task in n6is of switch type and invisible tasks of this type
are used to switch the execution chances among multiple alternative branches.
although the de¯nitions of invisible tasks of skip, redo and switch
type are di®erent, they have similar e®ects on the behaviors of wf-nets. we can
see this from the detection method illustrated in the next section.
in fact, there are still some invisible tasks that are not prime but can a®ect
the behavior of an iwf-net, e.g., the invisible task in n1in figure 3. such an
invisible task takes either the source place ias its input or the sink place oas
its output but not both (i.e., invisible task of side type). by manually adding
a begin event to the begin and an end event to the end of each event trace of a
given event log (i.e., pre-processing), such an invisible task can be transformed
to a prime one or just be replaced. in post-processing, the manually added tasks
can be just removed or reserved as an invisible task. for the added begin task,
if it has more than one output arcs or the only output place has more than one
input arc in the mined model, it must be reserved. for the added end task, the
similar post-processing happens.
4 detection of prime invisible tasks
in this section, the detection methods for invisible tasks will be introduced.
based on basic ordering relations between tasks, advanced ordering relations for
mendacious dependencies between tasks associated with invisible tasks are de-
rived (subsection 4.1). the reduction rule for identifying redundant mendacious
dependencies is given in subsection 4.2.
4.1 ordering relations for mendacious dependencies
when there are invisible tasks in process models, the causal dependencies be-
tween tasks detected from event logs are not always correct any more. such
dependencies are called mendacious dependencies . the most important step of
detecting invisible tasks from event logs is identifying all the mendacious de-
pendencies out of the causal dependencies. the basic ordering relations between
tasks derived from event logs are ¯rst listed below. for a more detailed expla-
nation about these basic ordering relations, readers are referred to [7, 21].
de¯nition 10 (basic ordering relations). letn= (p; tv; tiv; f)be a
potential sound iwf-net and wµtraces (n)be an event log of n. let a; b2tv,
then:
{a >wbi®9¾=t1t2t3¢¢¢tn2w; i2 f1; : : : ; n ¡1g:ti=a^ti+1=b,
{a4wbi®9¾=t1t2t3¢¢¢tn2w; i2 f1; : : : ; n ¡2g:ti=ti+2=a^ti+1=b,
{a¦wbi®a4wb^b4wa,
{a!wbi®a >wb^(bwa_a¦wb),
{a#wbi®a6>wb^bwa, and
{akwbi®a >wb^b >wa^a6 ¦wb.from de¯nition 10, it can be seen that >wand4ware the most basic
ordering relations. all other four ordering relations are based on them. >w
re°ects that two tasks can are executed successively and 4wwill be used to
distinguish length-2-loop from parallel routing. to prove the correctness of the
detection method for invisible tasks, it should be assumed that any given event
log is complete. otherwise the minimal ordering relations between tasks cannot
be identi¯ed successfully. the requirement for the completeness of an event log
is the same as the one proposed in [21] (i.e., loop-complete). the de¯nition of
completeness is just based on >wand4w.
de¯nition 11 (complete event log). letn= (p; tv; tiv; f)be a potential
sound iwf-net and wµtraces (n)be an event log of n.wis complete i®:
1.8w0µtraces (n) :>w0µ>w,
2.8w0µtraces (n) :4w0µ 4 w, and
3.8t2tv;9¾2w:t2¾.
de¯nition 11 shows that completeness does not require an event log to contain
all traces that could be generated by the corresponding process model. it only
demands that the event log contains all possible basic relations (i.e., >wand
4w) between any pair of tasks and each visible task should appear in some event
trace. this completeness notion has shown to be realistic in real-life applications.
now an advanced ordering relation for mendacious dependencies can be de-
rived from the basic ordering relations. this ordering relation will serve as the
basis for detecting invisible tasks of skip, redo, and switch type.
de¯nition 12 (advanced ordering relation). letn= (p; tv; tiv; f)be a
potential sound iwf-net and wµtraces (n)be an event log of n. for8a; b2
tv,aãwbi®a!wb^ 9x; y2tv:a!wx^y!wb^ywx^x,w
b^a,wy.
ãwre°ects the mendacious dependencies associated with invisible tasks of
skip, redo and switch types and this kind of ordering relation can be
used to construct invisible tasks. figure 6 illustrates the basic idea behind ãw.
because of the invisible task t, task acan be directly followed by task bin the
log. hence, existing mining algorithms (such as the ®algorithm) try to connect
aandbvia a place. this leads to incorrect results as shown in ¯gures 3 and 4.
consider for example logs w2tow6shown in these two ¯gures. for log w2, we
distinguish the mendacious dependency aãwc, i.e., amay be followed by c
but this cannot be modeled by inserting a place as done by the ®algorithm.
x a y b t
fig. 6. illustration for the derivation of ãw
in figure 6, there is an invisible task tin the snippet of a wf-net and
assume that tcan be detected from the corresponding log. the correctness ofthe detection method corresponding to ãwcan be proved theoretically as will
be shown later. if yis equal to x,tis of short-skip type. if yis reachable
from x,tis of long-skip type. if ais equal to b,tis of short-redo type.
ifais reachable from b,tis of long-redo type. otherwise, tis of switch
type, i.e., atoxandytobare two alternative paths.
to prove the correctness of the detection method for the relationship between
an invisible task and a mendacious dependency, we provide the related theorem
and derive the mining capacity of the detection method to be a subclass of
wf-net named diwf-net.
de¯nition 13 (direct wf-net with prime invisible tasks). letn=
(p; tv; tiv; f)be an iwf-net with the source place iand the sink place o.nis
a direct wf-net with prime invisible tasks (diwf-net for short) i®:
1.8a; b2tvstiv:a² \ ² b6=; ) 9 m2[n;[i]i: (n; m )[ai ^(n; m ¡
²a\a²)[bi, i.e., if aandbare connected via a place, there should be ¯ring
sequences such that ais directly followed by b.
2.there are no invisible tasks that are not prime and implicit places, i.e., it
should not be possible to remove tasks or places without changing the observ-
able behavior of the iwf-net.
de¯nition 13 limits the capacity of the above detection method to a reason-
able subclass of wf-net. the mendacious dependencies in non-diwf-nets may
not be detected correctly. as a result, our algorithm may fail to ¯nd a sound
wf-net covering the given log or return a diwf-net with equivalent behaviors
but di®erent structures compared to the original wf-net. figure 7 shows four
sound wf-nets that are not diwf-nets.
a
bc
d eab
cd
(a) (b)
a b ct 1
t 2a b ct 1
t 2t 3
(c) (d)
fig. 7. some non-diwf-nets containing invisible tasks
the invisible task in figure 7(a) cannot be detected correctly because of the
non-free-choice constructs involving it and e, which leads to that the invisible
task cannot follow adirectly. the mendacious dependency aãwdin figure 7(b)
cannot be detected because ais never directly followed by d. there are diwf-
nets containing a length-1-loop about b, which have equivalent behaviors withthose of the wf-net in figure 7(c). the essential reason is that the two invisible
tasks t1andt2are not prime. a similar observation holds for the wf-net in
figure 7(d). there are diwf-nets having more invisible tasks than this wf-net
but with equivalent behaviors.
the goal of ãwis to detect the presence of prime invisible tasks. the next
theorem shows that this is indeed the case for diwf-nets. it is assumed that
the invisible tasks of side type have been detected and constructed successfully
by now using the method illustrated at the end of section 3.2.
theorem 1. letn= (p; tv; tiv; f)be a sound diwf-net, wbe a complete
event log of nanda; b2tvbe two visible tasks. there is a prime invisible task
t2tivsuch that a² \ ² t6=;andt² \ ² b6=;i®aãwb.
proof. the theorem is proven to be correct in both directions.
1.assume that there exists a prime invisible task t2tsuch that a² \ ² t6=;
andt²\²b6=;. we need to prove that aãwbholds. let pin2a²\²t; pout2
t² \ ² b. according to requirement 2 in de¯nition 2, a >wbholds. assume
akwb, there must be a marking msuch that m2[n;[i]iand ( n; m )[ai
and ( n; m )[biand ( n; m ¡ ²a+a²)[ti. because ²a\ ²b=;(assuming
akwb) and ²t\ ²b=;(requirement 3 in de¯nition 5), after t¯res in
marking m¡ ²a+a², there will be two tokens in poutwhich violates the
notion of soundness assumed here. hence we get a contradiction and akwb
cannot hold. as a result, a!wbholds because a >wbanda,wb. because
tis prime, jpin²j>1 and j²poutj>1 hold (requirement 3 in de¯nition 5).
there will be at least a visible task xsuch that pin2 ²xor an invisible task
t0such that t06=tandpin2 ²t0. in the latter case, there will be at least
a visible task x0such that t0² \ ² x06=;(requirement 1 in de¯nition 5).
similarly, there will be at least a visible task ysuch that pout2y²or an
invisible task t00such that t006=tandpout2t00². in the latter case, there
will be at least a visible task y0such that y0² \ ² t006=;. here we only
prove the simplest case, i.e., pin2 ²xandpout2y². similar to the proof
ofa!wb, in all the four cases, a!wx,y!wb,a,wy,x,wband
y,wxhold. now we still need to prove y9wx. assume that there is a
causal relation between any pout's input transition yand any pin's output
transition x(x6=t), i.e., y!wx. according to requirement 3 in de¯nition
5, the assumption does not hold. hence, we have shown that a!wband
9x;y2ta!wx^y!wb^y6>wx^x,wb^a,wy.
2.assume aãwbholds, i.e., a!wband there exist two tasks x, y such
that a!wx,y!wb,y6>wx,x,wbanda,wy. we now need to
prove that there exists an invisible task t2tsuch that a² \ ² t6=;and
t² \ ² b6=;. assume there is no invisible task between any of a's output
places and any of b's input places, i.e., we try to obtain a contradiction. if
there is no such invisible task, a!wbimplies a² \ ² b6=;(theorem 4.1 in
[7]).a!wximplies a² \ ² x6=;or there is an invisible elementary path
from a's output places to x's input places. here we only prove the simplest
case, i.e., a² \ ² x6=;. similarly, y!wbimplies y² \ ² b6=;. becauseywx, it can be concluded that y² \ ² x=;. thus there will be four
basic constructs to re°ect the above-mentioned features, which are listed in
figure 8. now we will show that all these constructs have various issues. in
figure 8(a), a#wydoes not hold. if this is not the case, a!wb,y!wb
anda#wywill imply a²\y²\²b6=;(theorem 4.4 in [7]). in this case, either
a!wyory!waholds ( a,wyand not a#wy). ifa!wyholds, there
will be a place connecting aandy. after ais executed, ywill always occur
before b. hence we get a contradiction. similarly, if y!waholds, we can
get a contradiction with y!wb. as a result, the construct in figure 8(a)
is not sound. similarly, the other two constructs in figure 8(b) and (d) are
not sound either. in figure 8(c), after yis executed, bcannot occur directly
unless there the place connecting a,yandbis not safe. this violates y!wb
and we still get a contradiction. the assumption that aãwband there is
no invisible task connecting aandbis wrong and the construct can only be
similar to the one shown in figure 6.
hence, the theorem is proven to be correct in both directions. ¤
a x
y ba x
y ba x
y b
(a) (b) (c)a x
y b
(d)
fig. 8. possible constructs related to aãwbnot containing invisible tasks
after detecting all mendacious dependencies between tasks, the real causal
dependencies should be distinguished, which is de¯ned below.
de¯nition 14 (real causal dependency). letn= (p; tv; tiv; f)be a
potential sound iwf-net and wµtraces (n)be an event log of n. for a; b2tv,
a7!wbi®a!wbanda6ãwb.
4.2 identifying redundant mendacious dependencies
not all the mendacious dependencies detected from event logs are meaning-
ful to the mined process model. there may be some mendacious dependencies
leading to redundant invisible tasks, which are called redundant mendacious de-
pendencies . one reduction rule is proposed in this subsection to identify such
mendacious dependencies so as to separate them from those necessary ones.
figure 9 shows two wf-nets (i.e., n7andn8) involving redundant invisible
tasks. in both n7andn8, the function of t3can be replaced by the combinational
function of t1andt2. when mining process models from w7andw8, whether
constructing t3depends on user decision (by user-de¯ned parameter). from thet 1
b a ct 2
d
t 3t 2
b a ct 3
d
t 1n 7 w 7={ad, abd,acd,abcd} n 8 w 8={accd, abcbcd}fig. 9. wf-nets involving redundant invisible tasks
semantics of a process model, the redundant invisible tasks may be necessary
when they involve multiple parallel branches.
aãwc,bãwdandaãwdcan be derived from w7andaãwd
is redundant. similarly, cãwb,aãwcandcãwccan be derived from
w8andcãwcis redundant. the following reduction rule referred to as rule
1 hereafter can be used to identify such dependencies.
8a; b2tw: (aãwb^ 9c; d2tw: (c!wd^aãwd^cãwb))
)aãwb is redundant(1)
in rule 1, wis an event log and tw=ftj9¾2w:t2¾g. this rule
implies that all mendacious dependencies which can be combined by other ones
are redundant. aãwdandcãwcprove to be redundant, which are derived
from w7andw8respectively in figure 9.
5 the mining algorithm ®#
this section ¯rst analyzes how to construct invisible tasks from mendacious
dependencies. then the mining algorithm for constructing the mined process
model is introduced in detail.
5.1 construction of invisible tasks
for process models containing only causal relations between tasks, there is a
one-to-one relationship between invisible tasks and mendacious dependencies.
however, this is not always the case because selective and parallel relations are
so common in real-life processes. constructing invisible tasks is not such a trivial
task. see figure 10 for detail explanation.
t 2
ca
d ft 1g
i
beht 3n 9
fig. 10. the one-to-many relationship between invisible tasks and ãw
the process model n9is a sound diwf-net and one of its complete log is
w9=facddfghi; bceefhgi; adedeghi; aedghi; bedhgi; bdehgi g.t1corresponds to dãwd,dãwe,eãwdandeãwe. sim-
ilar things happen to t2andt3. on the contrary, there are situations where
multiple invisible tasks correspond to one mendacious dependency. for a vari-
ation of the diwf-net shown in figure 10, fãwiwould correspond to two
parallel invisible tasks skipping gandhrespectively.
the algorithm for constructing prime invisible tasks will be given below,
which is the core of the ®#algorithm. the operators about the relations between
a task and an event log (i.e., 2,first andlast) are borrowed from [7] directly.
the two functions preset andpostset are used to construct the input and
output places of a task. when generating the places here, the !wrelations
related to mendacious dependencies will not be considered because they do not
re°ect real causal dependencies.
de¯nition 15 (construction algorithm conit). letn= (p; tv; tiv; f)
be a potential sound iwf-net and wµtraces (n)be a complete event log of n.
conit(w) that is used to construct prime invisible tasks is de¯ned as follows.
1.tw=ft2¾j¾2wg,
2.ti=ffirst (¾)j¾2wg,
3.to=flast(¾)j¾2wg,
4.dm=f(a; b)ja2tw^b2tw^aãwbg,
5.rm=f(a; b)2dmj(a; b)is redundant g,
6.dm=dm¡rm,
7.xi=f(pin; pout)j(8(a; x)2pin;(y; b)2pout: (8a2a; b2b: (a; b)2
dm^(a; x)2postset (a)^(y; b)2preset (b))^(8x2x; y2y:
x,wy))^(8(a1; x1);(a2; x2)2pin: (9a12a1; a22a2:a1kwa2))^
(8(y1; b1);(y2; b2)2pout: (9b12b1; b22b2:b1kwb2))g,
8.yi=f(pin; pout)2xij8(p0
in; p0
out)2xi:pinµp0
in^poutµp0
out)
(pin; pout) = (p0
in; p0
out)g,
9.x0
i=f(pin; pout)j(8(a; x)2pin;(y; b)2pout: (8a2a; b2b: (a; b)2
rm^(a; x)2postset (a)^(y; b)2preset (b))^(8x2x; y2y:
x,wy))^(8(a1; x1);(a2; x2)2pin: (9a12a1; a22a2:a1kw
a2))^(8(y1; b1);(y2; b2)2pout: (9b12b1; b22b2:b1kwb2))g,
10.y0
i=f(pin; pout)2x0
ij(@(pin1; pout1); : : : ; (pink; poutk)2yi[x0
i; k > 1 :
pin\pin16=; ^pout1\pin26=; ^: : :^poutk\pout6=;)^(8(p0
in; p0
out)2
x0
i:pinµp0
in^poutµp0
out)(pin; pout) = (p0
in; p0
out))g,
11.ds=f(t(pin;pout); t(p0
in;p0
out))j(pin; pout);(p0
in; p0
out)2yi[y0
i^pout\p0
in6=
;g [ f (a; t(pin;pout))j(pin; pout)2yi[y0
i^ 9(a; x)2pin:a2ag [
f(t(pin;pout); b)j(pin; pout)2yi[y0
i^ 9(y; b)2pout:b2bg,
12.dp=f(t(pin;pout); t(p0
in;p0
out))j(pin; pout);(p0
in; p0
out)2yi[y0
i^ 8(a; x)2
pin;(a0; x0)2p0
in:9a2a; a02a0; x2x; x02x0:akwa0_xkw
x0g [ f (t; t(pin;pout))jt2tw^(pin; pout)2yi[y0
i^ 8(a; x)2pin:9a2
a; x2x:akwt_xkwtg [ f (t(pin;pout); t)jt2tw^(pin; pout)2
yi[y0
i^ 8(a; x)2pin:9a2a; x2x:akwt_xkwtg,
13.tw=tw[ ft(pin;pout)j(pin; pout)2yi[y0
ig, and
14.conit (w) = (tw; ti; to; ds; dp).the algorithm conit works as follows. steps 1, 2 and 3 are borrowed from
[7, 21] directly. they are used to construct the sets of all tasks, ¯rst tasks and
last tasks, i.e., tw,tiandto. all mendacious dependencies between tasks
are detected and the redundant ones are identi¯ed and excluded in steps 4 to 6.
step 7 to step 10 are used to construct invisible tasks of skip/redo/switch
types (stored in yiandy0
i) re°ected by the mendacious dependencies. these four
steps are the most important ones in the whole algorithm. the only di®erence
between step 7 and step 9 is that the latter needs to check that no new invisible
task can be composed by other ones. in steps 11 and 12, new causal and parallel
relations between invisible tasks as well as the ones between invisible tasks and
visible tasks are added. finally, the task set tware extended by new constructed
invisible tasks in step 13 and step 14 returns the necessary results.
5.2 construction of the mined process model
based on the algorithms proposed in the above subsection, the mining algorithm
named ®#can be de¯ned as follows. it returns the mined model in diwf-net.
de¯nition 16 (mining algorithm ®#).letwbe a loop-complete event log
over a task set t(i.e., wµt¤).®#(w)is de¯ned as follows.
1.(tw; ti; to; ds; dp) =conit (w),
2.xw=f(a; b)jaµtw^bµtw^(8a2a; b2b:a7!wb_(a; b)2
ds)^(8a1; a22a: (a1#wa2^(a1; a2)62dp)_(a17!wa2^a2>wa2)_
(a27!wa1^a1>wa1))^(8b1; b22b: (b1#wb2^(b1; b2)62dp)_(b17!w
b2^b1>wb1)_(b27!wb1^b2>wb2))g,
3.yw=f(a; b)2xwj8(a0; b0)2xw:aµa0^bµb0)(a; b) =
(a0; b0)g,
4.pw=fp(a;b)j(a; b)2ywg [ fiw; owg,
5.fw=f(a; p(a;b))j(a; b)2yw^a2ag [ f (p(a;b); b)j(a; b)2yw^b2
bg [ f(iw; t)jt2tig [ f(t; ow)jt2tog, and
6.nw= (pw; tw; fw).
the®#algorithm is relatively simple and easy to understand, which works as
follows. step 1 invokes the algorithm conit to construct all invisible tasks and
¯x the causal/parallel relations between tasks. all pairs of task sets related to
possible places are constructed in step 2. this step takes into account invisible
tasks and length-one-loop tasks at the same time. steps 3 to 6 are directly
borrowed from [7], in which the places together with the connecting arcs are
constructed and the mined process model in wf-net is returned.
to illustrate the ®#algorithm, we show the result of each step using the log
w9. the original model corresponding to w9is shown in figure 10. here we
only concentrate on the steps in conit because there is no invisible tasks of
side type and the steps in ®#algorithm is straightforward.
1.tw=fa; b; c; d; e; f; g; h; i g,
2.ti=fa; bg,3.to=fig,
4.dm=f(a; d);(a; e);(b; d);(b; e);(d; d );(d; e);(d; g);(d; h );(e; d);
(e; e);(e; g);(e; h )g,
5.rm=;,
6.dm=dm,
7.xi=f(f(fag;fcg)g;f(fcg;fdg)g);(f(fag;fcg)g;f(fcg;feg)g);(f(fbg;
fcg)g;f(fcg;fdg)g);(f(fbg;fcg)g;f(fcg;feg)g); : : : ; (f(fa; bg;fcg)g;
f(fcg;fd; eg)g);(f(fdg;ffg)g;f(fcg;fdg)g);(f(feg;ffg)g;f(fcg;feg)g);
: : : ;(f(fd; eg;ffg)g;f(fcg;fd; eg)g);(f(fdg;ffg)g;f(ffg;fgg)g); : : : ;
(f(feg;ffg)g;f(ffg;fhg)g);(f(fd; eg;ffg)g;f(ffg;fgg);(ffg;fhg)g)g,
8.yi=ft2= (f(fa; bg;fcg)g;f(fcg;fd; eg)g); t1= (f(fd; eg;ffg)g;f(fcg;
fd; eg)g); t3= (f(fd; eg;ffg)g;f(ffg;fgg);(ffg;fhg)g)g,
9.x0
i=;,
10.y0
i=;,
11.ds=f(a; t2);(b; t2);(t2; d);(t2; e);(d; t1);(e; t1);(t1; d);(t1; e);(d; t3);
(e; t3);(t3; g);(t3; h)g,
12.dp=;,
13.tw=fa; b; c; d; e; f; g; h; i; t 1; t2; t3g, and
14.conit (w) = (tw; ti; to; ds; dp).
comparing the above results with the diwf-net n9shown in figure 10, we
can ¯nd that all the three invisible tasks are correctly detected. the ordering
relations among new invisible tasks as well as the ones between invisible tasks
and visible tasks are established successfully too. if these results are taken as
the input of the ®#algorithm, the mined model will be the same as n9.
6 experimental evaluation of the work
first we introduce the implementation of the ®#algorithm (subsection 6.1).
then the evaluation criteria for conformance testing is illustrated (subsection 6.2).
thirdly, evaluation results are explained in detail in subsection 6.3. finally, the
limitations of the ®#algorithm are discussed in subsection 6.4.
6.1 implementation of the ®#algorithm
the®#algorithm has been implemented as a mining plug-in of prom [3, 13] and
can be downloaded from www.processmining.org. the current version of prom
is 5.0 and it is an open-source extensive framework for process mining, which
is implemented in java. currently, there are already more than 210 mining,
analysis and conversion plug-ins. it takes an event log in an extensible, xml-
based format (i.e., mxml) as input and uses a process mining plug-in to mine
a process model from that log. the mined process model will be shown to the
end user graphically. a snapshot of prom is given in figure 11, which shows
an diwf-net constructed by the ®#algorithm. the mining result can also be
converted to an event-driven process chain and be analyzed for soundness by
analysis plug-in. furthermore, the result can be exported to tools such as cpn
tools, aris, yawl, aris ppm, yasper, epc tools, wo°an, etc.fig. 11. the snapshot of prom when mining a process model using the ®#plug-in
6.2 evaluation criteria
although visual inspection of the mined model and the original model can be
used to see whether the mining result is correct, there are also some problems
related to this visual inspection. firstly, it works well only for small examples.
secondly, we cannot assume that the original model is always present. finally, the
original model and the mined model may have di®erent structures but have ex-
actly the same behaviors. therefore the following metrics are introduced, which
are used to test the conformance between the mined model and the given log[24].
the metric fis determined by replaying the log in the model, i.e., for each
case the \token game" is played as suggested by the log. for this, the replay of
every event trace starts with marking the initial place in the model and then
the transitions that belong to the logged events in the trace are ¯red one after
another. while doing so, one counts the number of tokens that had to be created
arti¯cially (i.e., the transition belonging to the logged event was not enabled and
therefore could not be successfully executed ) and the number of tokens that were
left in the model (they indicate that the process has not properly completed ).
only if there were neither tokens left nor missing, the ¯tness measure evaluates
to 1.0, which indicates 100% ¯tness. in other words, ¯tness re°ects the extent to
which the event traces can be associated with execution paths speci¯ed by the
process model. thus if f= 1 then the log can be parsed by the model without
any error. the token-based ¯tness metric fis formalized as follows:
f=1
2(1¡pk
i=1nimipk
i=1nici) +1
2(1¡pk
i=1niripk
i=1nipi) (2)
here kis the number of di®erent traces from the aggregated log. for each
event trace i(1·i·k):niis the number of process instances combined into thecurrent trace, miis the number of missing tokens, riis the number of remaining
tokens, ciis the number of consumed tokens, and piis the number of produced
tokens during log replay of the current trace. note that for all i,mi·ciand
ri·pi, and therefore 0 ·f·1. the maximum value of the ¯tness metric will
be used as an evaluation criteria, i.e., f= 1.
the other two conformance testing metrics are ab(behavioral appropriate-
ness) and as(structural appropriateness ). appropriateness re°ects the degree
of accuracy in which the process model describes the observed behavior (i.e.,
ab), combined with the degree of clarity in which it is represented (i.e., as). for
all the three metrics, their values are between 0.0 and 1.0. for any successful
mining, the value of fshould be 1.0 and the values of abandasshould be as
big as possible. another important evaluation criteria is that the mined model
should be sound. from the viewpoint of practical application, the soundness of
any process model is a necessary requirement.
6.3 evaluation results
in an experimental setting, logs can be obtained in three ways: (1) as a download
or conversion from an operational information system (i.e., a real log), (2) a
manually created or collected log, and (3) a log resulting from a simulation.
for evaluation of the ®#algorithm, we have used all three possibilities. in this
section, we show the results of our experimental evaluation of the ®#algorithm.
a lot of experiments have been done to evaluate the proposed methods to-
gether with the implemented algorithm. the ®#plug-in of prom has been ap-
plied to several real-life logs and many smaller arti¯cial logs. there are totally
96 arti¯cial examples in diwf-nets evaluated. the corresponding complete logs
are generated manually. the maximum number of tasks in one process model
is less than 20 and the number of cases in one event log is less than 30. all
types of invisible tasks are modeled in a separate or combined manner. of all
the examples, 24 models involve invisible tasks of side type, 12 models involve
length-1-loops, length-2-loops and invisible tasks of short-redo type, and 4
models do not contain any invisible task (the corresponding logs are l23,l24,
l48, and l54). the conformance testing results are shown in figure 12.
from figure 12, we can see that all 96 models are mined successfully from
their corresponding logs (i.e., f= 1). given the 96 complete event logs generated
by di®erent diwf-nets, the correct rate of mining process models from logs by
the®#algorithm approaches 100%. while for the ®algorithm, the correct rate is
only 4 =96t4:2%. only the 4 models that do not contain any invisible task were
mined successfully. it shows that the ®#algorithm is a good extension of the
®algorithm to handle invisible tasks. at the same time, the ®#algorithm can
distinguish invisible tasks of short-redo type and length-1-loops correctly.
ten real-life logs are obtained from kinglong company in xiamen, fujian
province, china, which are all about processes for routing engineering document.
the mined process model from l10 is shown in figure 13. the source place
and the sink place are not visible in this ¯gure for space limitation. all the
conformance testing results are shown in table 2. it is obvious that all the0.2 0.4 0.6 0.8 1
1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46 log id f
a b 
a s 
0.2 0.4 0.6 0.8 1
49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 log id f
a b 
a s fig. 12. evaluation of ®#algorithm using 96 arti¯cial logs
experiments are successful. compared with the given logs, the mining results
of the ®#will not introduce new ordering relations between invisible tasks.
the proportion for invisible tasks out of all tasks is 77/(77+88)=46.7%. this
proportion is very near to that computed from the process models in section 1
and verify the correctness of the ®#to some extent.
table 2. conformance testing results based on real-life logs: f-¯tness, ab-behavioral
appropriateness, as-structural appropriateness, noi-the number of invisible tasks, noc-
the number of cases, noe-the number of events, not-the number of visible tasks
l1 l2 l3 l4 l5 l6 l7 l8 l9 l10
f1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
ab 0.823 0.983 0.876 0.902 0.811 0.933 0.791 0.953 0.804 0.809
as 0.321 0.5 0.375 0.5 0.45 0.478 0.286 0.529 0.391 0.271
noi 10 3 9 3 5 4 14 2 7 20
noc 8 6 5 11 40 42 30 42 297 44
noe 43 52 59 84 324 469 221 288 2020 531
not 7 15 10 7 7 9 8 7 7 11
in section 2, we have shown that the ga algorithm can mine process models
with invisible tasks too. however, the main goal of ga algorithm is to ¯nd a
suitable process model to ¯t the given event log. besides invisible tasks, it can
also handle duplicate tasks, non-free-choice constructs and noise. it is based on
the generic algorithm and has more than ten parameters. because the ®#al-
gorithm do not need any parameter, when mining an event log using the ga
algorithm, all default values of the parameters will be used. many previous ex-
ample logs (i.e., 96 arti¯cial ones and 10 real-life ones) can be mined successfully
by the ga algorithm (i.e., f= 1). however, there are still many logs on whichfig. 13. a real-life process model mined from l10 by the ®#algorithmthe®#algorithm performs better than the ga algorithm. figure 14 lists the
comparison results of the ®#algorithm and the ga algorithm. all the testing
logs are chosen from the above arti¯cial and real-life logs.
the numbers of invisible tasks in the mined process  models 
0510 15 20 25 30 35 
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 n i ( a # ) 
n i ( g a ) 00 . 1 0 . 2 0 . 3 0 . 4 0 . 5 0 . 6 0 . 7 0 . 8 0 . 9 1
1 3 5 7 9 1 1 1 3 1 5 1 7 1 9 2 1 2 3 2 5 2 7 2 9 3 1 3 3 3 5 3 7 3 9 4 1 f(a#) 
ab(a#) 
as(a#) 
f(ga) 
ab(ga) 
as(ga) 
1.5 22.5 33.5 44.5 
1 3 5 7 9 1 1 1 3 1 5 1 7 1 9 2 1 2 3 2 5 2 7 2 9 3 1 3 3 3 5 3 7 3 9 4 1 log(t(ga)/t(a#)) (a)
(b)
(c)
fig. 14. comparison results of the ®#algorithm and the ga algorithm
three perspectives are concerned when comparing the mining results of the
®#algorithm and the ga algorithm, which are explained as follows:
1.the values of f,abandasbetween the each mined model and its cor-
responding log. the importance priorities of the three metrics from big to
small are f,abandas. the bigger the value of fis, the better the result
is. if f= 1 is true for both algorithm, abandaswill be considered. from
figure 14(a), we can see that on the chosen 41 example logs, the ®#algo-
rithm performs better than the ga algorithm. whether f®#= 1> fgaor
f®#=fga= 1^ab®#> ab gaorf®#=fga= 1^ab®#=abga^as®#>
asgais true. the ga algorithm are di±cult to handle event logs generated
by the process models containing some special constructs, such as length-
1-loops, invisible tasks of side type, invisible tasks of skip type between
and-split task and and-join task, invisible tasks of short-redo type,
invisible tasks involved in non-free-choice constructs, invisible tasks in series,
invisible before/after parallel tasks, and-split tasks connecting the source
place, and and-join tasks connecting the sink place, etc.2.the number of invisible tasks in the process model mined by the two algo-
rithms. when the values of the three metrics are the same, the smaller the
number of invisible tasks is, the better the result is. from figure 14(b), we
can see that for most of the testing example logs, the number of invisible
tasks mined by the ®#algorithm is smaller than that mined by the ga
algorithm. only for a few logs, the ga algorithm can mine a model with less
invisible tasks. however, the mined models are not sound or they are not as
good as the ones mined by the ®#algorithm.
3.the time spent by the two mining algorithms. if the previous two perspec-
tives cannot distinguish which results are better, the time spent by the corre-
sponding algorithm can be considered. the less the time is spent, the better
the result is. figure 14(c) shows that for all the chosen logs, the mining time
spent on each log by the ga algorithm is almost 100 to 10000 times as that
spent by the ®#algorithm.
the evaluation results show that so long as the event logs are complete,
the®#algorithm can mine all useful invisible tasks in diwf-nets successfully.
compared to the ga algorithm that can handle invisible tasks, the ®#algorithm
shows good performance (e.g., mining capacity, quality and e±ciency).
6.4 limitations of the ®#algorithm
from de¯nition 13 and theorem 1, it is obvious to see that the mining capacity
of the ®#algorithm is limited to diwf-nets and the given event log is assumed
to be complete. although diwf-nets is a large subclass of wf-nets, there are
still some sound non-diwf-nets that cannot be mined by the ®#algorithm
(e.g., the two wf-nets n10andn11shown in figure 7(a) and figure 7(b)
respectively). for n10, one of its complete event log is w10=fac; bcde; bdce g.
taking w10as input, the ®#algorithm constructs the wf-net named n0
10as
shown in figure 15(a). after one token is put in the source place of n0
10, there will
be a free-choice between aandb. ifais chosen, the net will terminate normally.
otherwise, after bexecutes, canddcan execute concurrently. the executions of
canddwill not a®ect the soundness of n0
10. however, if the only invisible task
executes after c¯nishes execution, there will be a deadlock at e. thus the mined
wf-net n0
10is not structural sound though it is a diwf-net. the reason for
such a mining error is that although there is a place connecting aand the only
invisible task t0inn10,t0has no chance to execute immediately after a. but the
essential reason is the non-free-choice construct between eandt0. for n11, one
of its complete event log is w11=facd; abcd; acbd g. the corresponding mined
wf-net by the ®#algorithm is n0
11as shown in figure 15(b). after analyzing
the structure of n0
11, we can draw the conclusion that it is structural sound.
however, n11andn0
11are not behavioral equivalent. n0
11cannot generate the
trace acdand hence it cannot cover the given log w11. the essential reason is that
although aanddare connected by an invisible elementary path, dcannot execute
immediately after abecause there is another parallel path without invisible tasks
between them.a
bc
e da b d
c
(a) (b)fig. 15. two mined models from the complete logs generated by two non-diwf-nets
the correctness of the ®#algorithm depends on the assumption that the
potential wf-nets are diwf-nets and the given log is complete. these two
assumptions should be relaxed further in future works.
7 conclusion
based on the analysis of mining problems encountered using the classical ®al-
gorithm, a new mining algorithm based on petri net named ®#algorithm is
proposed. invisible tasks are classi¯ed into four types according to their func-
tionalities for the ¯rst time, i.e., side, skip, redo and switch. the uni-
versal detection method for invisible tasks of skip/redo/switch types is
illustrated in detail and the correctness of the method can be proved theoreti-
cally. the construction algorithms for all types of invisible tasks and the process
models in wf-nets are proposed and explained too. the ®#algorithm has been
implemented as a plug-in of prom and evaluated using a lot of arti¯cial logs
and a few real-life logs. the evaluation results show that the algorithm can mine
appropriate diwf-nets with invisible tasks successfully so long as the corre-
sponding event logs are complete.
our future work will mainly focus on the following two aspects. firstly, more
real-life logs will be gathered for further evaluating the ®#algorithm and the
implemented plug-in. secondly, theoretical analysis will be done to explore the
exact mining capacity of the ®#algorithm.
acknowledgements
the work is supported by the national basic research program of china (no.
2002cb312006 and no. 2007cb310802), the national natural science foun-
dation of china (no. 60373011 and no. 60473077) and the program for new
century excellent talents in university.
the authors would like to thank ton weijters, ana karla alves de medeiros,
boudewijn van dongen, minseok song, laura maruster, eric verbeek, monique
jansen-vullers, hajo reijers, michael rosemann, and peter van den brand for
their on-going work on process mining techniques and tools at eindhoven uni-
versity of technology.
references
1.w.m.p. van der aalst. the application of petri nets to work°ow management.
the journal of circuits, systems and computers , 8(1):21{66, 1998.2.w.m.p. van der aalst and b.f. van dongen. discovering work°ow performance
models from timed logs. in y. han, s. tai, and d. wikarski, editors, international
conference on engineering and deployment of cooperative information systems ,
volume 2480 of lecture notes in computer science , pages 45{63. springer-verlag,
berlin, 2002.
3.w.m.p. van der aalst, b.f. van dongen, c.w. gä unther, r.s. mans, a.k. alves
de medeiros, a. rozinat, v. rubin, m. song, h.m.w. verbeek, and a.j.m.m.
weijters. prom 4.0: comprehensive support for real process analysis. in j. kleijn
and a. yakovlev, editors, the 28th international conference on applications and
theory of petri nets (icatpn 2007) , volume 4546 of lecture notes in computer
science , pages 484{494. springer-verlag, berlin, 2007.
4.w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. work°ow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
5.w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining , special
issue of computers in industry, volume 53, number 3. elsevier science publishers,
amsterdam, 2004.
6.w.m.p. van der aalst and a.j.m.m. weijters. process mining: a research agenda.
computers in industry , 53(3):231{244, 2004.
7.w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. work°ow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.
8.w.m.p. van der aalst, m. weske, and d. grä unbauer. case handling: a new
paradigm for business process support. data and knowledge engineering ,
53(2):129{162, 2005.
9.r. agrawal, d. gunopulos, and f. leymann. mining process models from work°ow
logs. in i. ramos, g. alonso, and h.j. schek, editors, the sixth international
conference on extending database technology , pages 469{483, 1998.
10.j.e. cook and a.l. wolf. automating process discovery through event-data anal-
ysis. in proceedings of the 17th international conference on software engineering ,
pages 73{82. acm, new york, ny, usa, 1995.
11.j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
12.j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts
in theoretical computer science . cambridge university press, cambridge, uk,
1995.
13.b.f. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters,
and w.m.p. van der aalst. the prom framework: a new era in process mining
tool support. in g. ciardo and p. darondeau, editors, international conference
on application and theory of petri nets 2005 , volume 3536 of lecture notes in
computer science , pages 444{454. springer-verlag, berlin, 2005.
14.g. greco, a. guzzo, g. manco, and d. sacc¶ a. mining and reasoning on work°ows.
ieee transactions on knowledge and data engineering , 17(4):519{534, 2005.
15.g. greco, a. guzzo, l. pontieri, and d. sacc¶ a. discovering expressive process
models by clustering log traces. ieee transactions on knowledge and data en-
gineering , 18(8):1010{1027, 2006.
16.m. hammori, j. herbst, and n. kleiner. interactive work°ow miningrequirements,
concepts and implementations. data and knowledge engineering , 56:41{63, 2006.
17.j. herbst and d. karagiannis. work°ow mining with inwolve. computers in
industry , 53(3):245{264, 2004.18.x.q. huang, l.f. wang, w. zhao, s.k. zhang, and c.y. yuan. a work°ow
process mining algorithm based on synchro-net. journal of computer science and
technology , 21(1):66{71, 2006.
19.l. maruster, a.j.m.m. weijters, w.m.p. van der aalst, and a. van der bosch. a
rule-based approach for process discovery: dealing with noise and imbalance in
process logs. data mining and knowledge discovery , 13(1):67{87, 2006.
20.a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters. work°ow
mining: current status and future directions. in r. meersman, z. tari, and d.c.
schmidt, editors, on the move to meaningful internet systems 2003: coopis,
doa, and odbase , volume 2888 of lecture notes in computer science , pages
389{406. springer-verlag, berlin, 2003.
21.a.k.a. de medeiros, b.f. van dongen, w.m.p. van der aalst, and a.j.m.m. wei-
jters. process mining for ubiquitous mobile systems: an overview and a concrete
algorithm. in l. baresi, s. dustdar, h. gall, and m. matera, editors, ubiquitous
mobile information and collaboration systems , pages 154{168, 2004.
22.a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic pro-
cess mining: an experimental evaluation. data mining and knowledge discovery ,
14(2):245{304, 2007.
23.w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
24.a. rozinat and w.m.p. van der aalst. conformance testing: measuring the fit
and appropriateness of event logs and process models. in c. bussler et al., editor,
bpm 2005 workshops , volume 3812 of lecture notes in computer science , pages
163{176. springer-verlag, berlin, 2006.
25.a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. faideiro, and a. sheth, editors, the fourth international conference on busi-
ness process management , volume 4102 of lecture notes in computer science ,
pages 420{425. springer-verlag, berlin, 2006.
26.g. schimm. mining exact models of concurrent work°ows. computers in industry ,
53(3):265{281, 2004.
27.l.j. wen, w.m.p. van der aalst, j.m. wang, and j.g. sun. mining process models
with non-free-choice constructs. data mining and knowledge discovery , 15(2):145{
180, 2007.
28.l.j. wen, j.m. wang, and j.g. sun. detecting implicit dependencies between
tasks from event logs. in x. zhou, x. lin, and h. lu et al., editors, the 8th asia-
paci¯c web conference (apweb 2006) , volume 3841 of lecture notes in computer
science , pages 591{603. springer-verlag, berlin, 2006.
29.l.j. wen, j.m. wang, and j.g. sun. mining invisible tasks from event logs. in
g.z. dong, x.m. lin, w. wang, and y. yang, editors, the joint conference of the
9th asia-paci¯c web conference and the 8th international conference on web-
age information management , volume 4505 of lecture notes in computer science ,
pages 358{365. springer-verlag, berlin, 2007.