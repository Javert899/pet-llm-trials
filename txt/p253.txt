process mining and veriﬁcation of properties:
an approach based on temporal logic
w.m.p. van der aalst and h.t. de beer and b.f. van dongen
department of technology management, eindhoven university of technology,
p.o.box 513, nl-5600 mb, eindhoven, the netherlands.
w.m.p.v.d.aalst@tm.tue.nl
abstract. information systems are facing conﬂicting requirements. on
the one hand, systems need to be adaptive and self-managing to deal with
rapidly changing circumstances. on the other hand, legislation such asthe sarbanes-oxley act, is putting increasing demands on monitoring
activities and processes. as processes and systems become more ﬂexible,
both the need for, and the complexity of monitoring increases. our earlierwork on process mining has primarily focused on process discovery, i.e.,
automatically constructing models describing knowledge extracted from
event logs. in this paper, we present another approach supported by ourprom framework and based on both a standard xml format and tem-
poral logic. given an event log and a property, our ltl checker veriﬁes
whether the observed behavior matches the (un)expected/(un)desirablebehavior.
key words : process mining, temporal logic, business process management, workﬂow
management, data mining, petri nets.
1 introduction
a constantly changing reality is forcing organizations and their information sys-
tems to adapt at an ever increasing pace. business process management (bpm)
and workﬂow management (wfm) systems increasingly allow for more ﬂexibil-
ity. instead of recoding the system it typically suﬃces to reconﬁgure the system
on the basis of a process model [3]. several researchers have addressed the prob-
lems related to workﬂow change [1, 14, 29, 30]. although the work on workﬂowchange is highly relevant, in reality many processes are not bound by a wfm
or bpm system driven by an explicit process model. some systems, e.g., the
case handling system flower, allow for implicit routing, other systems allowfor much more behavior than desired. for example, people using the sap r/3
system are not limited by process models described in the sap r/3 reference
model [24]. deviations from the “normal process” may be desirable but may alsopoint to ineﬃciencies or even fraud. new legislation such as the sarbanes-oxley
(sox) act [34] and increased emphasis on corporate governance has triggered
the need for improved auditing systems [22]. to audit an organization, businessactivities need to be monitored. as enterprises become increasingly automated, a
tight coupling between auditing systems and the information systems supportingthe operational processes becomes more important.
today’s information systems need to compromise between two requirements:
(1) being adaptive and self-managing and (2) being able to be audited. within
the context of this struggle, we have developed a tool called ltl checker . this
tool has been developed in the context of the prom framework
1.t h ep r o m
framework oﬀers a wide range of tools related to process mining, i.e., extracting
information from event logs [6]. process mining is motivated by the fact that
many business processes leave their “footprints” in transactional informationsystems (cf. wfm, erp, crm, scm, and b2b systems), i.e., business events
are recorded in so-called event logs. until recently, the information in these
logs was rarely used to analyze the underlying processes. process mining aims atimproving this by providing techniques and tools for discovering process, control,
data, organizational, and social structures from event logs, i.e., the basic idea
of process mining is to diagnose business processes by mining event logs forknowledge.
the work presented in this paper is related to process mining, but, unlike
most process-mining approaches, the emphasis is not on discovery. instead we
focus on veriﬁcation , i.e., given an event log we want to verify certain properties.
an example is the 4-eyes principle , i.e., although authorized to execute two
activities, a person is not allowed to execute both activities for the same case.
for example, a manager may submit a request (e.g., to purchase equipment, to
make a trip, or to work overtime) and he may also approve requests. however,it may be desirable to apply the 4-eyes principle implying that the manager
is not allowed to approve his own request. if there is an event log recoding
the events “submit request” and “approve request”, the 4-eyes principle can beveriﬁed easily. more diﬃcult are properties relating to the ordering or presence of
activities. for example, activity amay only occur if it is preceded by activity b
or activity cand immediately followed by activity d. therefore, we propose an
approach based on temporal logic [25, 28]. more speciﬁcally, we use an extension
oflinear temporal logic (ltl) [16, 19, 20] tailored towards event logs holding
information on activities, cases (i.e., process instances), timestamps, originators
(the person or resource executing the activity), and related data.
this paper reports on the language developed to formulate properties in the
context of event logs, the approach used to check these properties, the implemen-
tation in the prom framework, and the relation between this work and process
discovery. it is important to note that process discovery is diﬃcult in situations
where a lot of ﬂexibility is oﬀered. the approach based on veriﬁcation is more
robust because it can focus on the essential properties. hence, the ltl checkeris a welcome addition towards a wider range of process mining tools.
this paper is organized as follows. section 2 introduces a running example
that will be used to illustrate the concept of process mining. the prom frame-work and the xml format used to store event logs is presented in section 3. then
1both documentation and software can be downloaded from www.processmining.org.the ltl language is introduced and it is shown how properties can be speciﬁed.
section 5 shows how these properties can be veriﬁed using the ltl checker inprom. finally, some related work is discussed and the paper is concluded.
2 running example
today, many enterprise information systems store relevant events in some struc-tured form. for example, wfm systems typically register the start and comple-tion of activities. erp systems like sap log all transactions, e.g., users ﬁlling
out forms, changing documents, etc. business-to-business (b2b) systems log the
exchange of messages with other parties. call center packages but also general-purpose customer relationship management (crm) systems log interactions
with customers. these examples show that many systems have some kind of
event log often referred to as “history”, “audit trail”, “transaction log”, etc.
[6, 7]. the event log typically contains information about events referring to
anactivity and a case. the case (also named process instance) is the “thing”
which is being handled, e.g., a customer order, a job application, an insurance
claim, a building permit, etc. the activity (also named task, operation, action,
or work-item) is some operation on the case. typically, events have a timestamp
indicating the time of occurrence. moreover, when people are involved, event
logs will typically contain information on the person executing or initiating the
event, i.e., the originator . based on this information several tools and techniques
for process mining have been developed.
a
eg
invite
reviewersd
get review 2
time-out 2collect
reviewsh
decidei
accept
j
rejectinvite
additional
reviewerkml
get review x
time-out xcb
get review 1
time-out 1
gf
get review 3
time-out 3
fig. 1. running example.
as a running example, we will use the process shown in figure 1. the process
describes the reviewing process of a paper for a journal and is represented in
terms of a petri net (more speciﬁcally a workﬂow net [3]). after inviting threereviewers (activity a) each of the reviewers returns a review or a time-out occurs,
e.g., for the ﬁrst review either borcoccurs. then the reviews that were returned
in time are collected (activity g) and a decision is made (activity h). there are
three possible outcomes of this decision: (1) the paper is accepted ( i), (2) the
paper is rejected ( j), or (3) an additional reviewer is needed ( k). similar to the
original three reviewers, the additional reviewer may return the review in time
(l)o rn o t( m).
case id activity id originator timestamp
...
case0 invite reviewers john 2005-01-01t08:00
case1 invite reviewers john 2005-01-01t08:00
case0 get review 1 nick 2005-02-06t08:00
case0 get review 2 pete 2005-03-07t08:00
...
table 1. a fragment of the event log.
for the process shown in figure 1, we may log events such as the ones shown
in table 1. as discussed before, each event refers to a case (e.g., case 1) and
an activity (e.g., invite reviewers). moreover, in this case the timestamp andoriginator are logged. the ﬁrst line of the fragment shown in table 1 states
that john executed step a(invite reviewers) for case
0 on the ﬁrst of january
2005. table 1 does not show that for some events additional data is logged.for example, each case has a data element titleand each review result (e.g.,
get review 1) has a result attribute which is either accept or reject. table 1
only shows a fragment of the log used throughout this paper. the log holdsinformation about 48 cases (i.e., papers) and 354 events and is used as a running
example.
3 prom framework and xml format
the ltl checker presented in this paper is embedded in the prom framework
and should be seen as an addition to a collection of process mining tools. there-
fore, we ﬁrst describe the prom framework and some of the process mining
techniques that have been developed in this framework.
in table 1 we showed a fragment of some event log. we assume a standard
log format, named mxml, and have developed several adaptors to map logs
in diﬀerent information systems onto our log format (e.g., staﬀware, flower,ms exchange, mqseries, etc.). figure 2 shows the hierarchical structure of
mxml. the format is xml based and is deﬁned by an xml schema (cf.
www.processmining.org).
the prom framework has been developed as a completely plug-able environ-
ment. it can be extended by simply adding plug-ins, i.e., there is no need toknow or recompile the source code. currently, more than 30 plug-ins have been
added. the most interesting plug-ins are the mining plug-ins and the analysis
plug-ins. the architecture of prom allows for ﬁve diﬀerent types of plug-ins:fig. 2. xml schema for the mxml format used by prom.
mining plug-ins which implement some mining algorithm, e.g., mining algo-
rithms that construct a petri net based on some event log.
export plug-ins which implement some “save as” functionality for some ob-
jects (such as graphs). for example, there are plug-ins to save epcs, petri
nets, spreadsheets, etc.
import plug-ins which implement an “open” functionality for exported ob-
jects, e.g., load instance-epcs from aris ppm.
analysis plug-ins which typically implement some property analysis on some
mining result. for example, for petri nets there is a plug-in which constructsplace invariants, transition invariants, and a coverability graph.
conversion plug-ins which implement conversions between diﬀerent data for-
mats, e.g., from epcs to petri nets.
fig. 3. using the αmining plug-in in prom we can discover the underlying process
model.
for the process perspective, four mining plug-ins are available including the
αplug-in [8], a genetic miner, and a multi-phase miner. the goal of these plug-
ins is to extract a process model from a given event log without using any
additional knowledge of the process. for example, based on the log mentioned
in section 2 (i.e., the log holding information on 48 papers and 354 events), theαplug-in discovers the process model shown in figure 3. note that this model is
identical to the one shown in figure 1. of course the layout is diﬀerent since it isautomatically generated. for the organizational/social perspective, one mining
plug-in named minson is available [5]. if we apply this plug-in to the same log,
prom constructs the social network shown in figure 4. a social network showsall actors in the organization and their relationships. based on an analysis of the
log (e.g., transfer of work or similarity of work proﬁles), the relationships and
their relative strength are derived. figure 4 shows how these can be analyzed,e.g., using a tool like netminer. the screenshot on the left shows that john and
mike are the two central players in the reviewing process. this is no surprise
since john is the editorial assistant (responsible for the contacts with reviewersand authors) and mike is the editor of the journal. the screenshot on the right-
hand-side of figure 4 illustrates how netminer can discover “cliques” in a social
network.
fig. 4. the social network discovered by prom can be exported to the sna tool
netminer.
figures 3 and 4 show how process mining techniques can be used to discover
models based on some event log. the results presented in this paper are related
to process mining, but unlike the mining plug-ins mentioned the focus is not ondiscovery. instead, the focus is on veriﬁcation. therefore, in the context of the
prom framework, the ltl checker should be considered as an analysis plug-in
rather than a mining plug-in.
4 formulating properties: the ltl language
assuming that the information system at hand left a “footprint” in some eventlog, it is interesting to check whether certain properties hold or not. beforebeing able to check such properties, a concrete language for formulating dynamic
properties is needed. given the fact that we consider behavioral properties where
ordering and timing are relevant, some temporal logic seems to be the best basisto start from [25, 28]. there are two likely candidates: computational tree logic
(ctl) and linear temporal logic (ltl) [16, 19, 20]. given the linear nature ofan event log, ltl is the obvious choice. it would only make sense to use ctl
if ﬁrst a model (e.g., an automaton) was built before evaluating the property.
unlike most of the existing process mining techniques supported in the promframework, we try to avoid this and simply use ltl as a basis directly working
on the event log.
it is not suﬃcient to select ltl as a language. to easily specify properties in
the context of mxml, a dedicated language is needed that exploits the structure
shown in figure 2. therefore, in addition to standard logical operators, we needdedicated statements to address the properties of cases and events. for example,
it should be easy to use the various attributes of a case (both standard ones such
as case, activity, timestamp, originator and event type, and context speciﬁc onessuch as data values).
we have developed a complete language including type deﬁnitions, renam-
ing, formulas, subformulas, regular expressions, date expressions, propositional
logic, universal and existentional quantiﬁcation, and temporal operators such as
nexttime ( /circlecopyrtf), eventually ( 3f), always ( 2f), and until ( fug). a complete
description of the language is beyond the scope of this paper but is given in [10].
to illustrate the language we use the examples shown in table 2.
the notation ate.x is used to refer to some attribute xof an audit trail entry
(ate), i.e., an event in the event log. similarly pi.xis used to refer to attribute
xof a process instance ( pi), i.e., a case. there are several predeﬁned attributes,
e.g., ate.workflowmodelelement refers to the activity (or other process ele-
ments) being executed. ate.originator is the resource executing it, i.e., the
person. ate.timestamp is the timestamp of the event. ate.eventtype is the type
of the event (i.e., schedule, assign, withdraw, start, complete, etc.). the three set
declarations shown in table 2 (lines 1-3) declare that ate.workflowmodelelement ,
ate.originator ,a n d ate.eventtype can be used for quantiﬁcation, e.g.,
ate.workflowmodelelement may refer to the activity related to the current
event but may also be used to range over all activities appearing the a case. line5 declares the datetime format used when specifying a value (note that this al-
lows for shorter notations than the standard xml format). line 6 declares a data
attribute at the level of an event. the data attribute result is used to record the
outcome of a single review in the running example. line 7 shows a data attribute
at the level of a case. note that both attributes are of type string . to allow
for shorter/customized names our language allows for renaming. as shown inlines 9-11, ate.originator ,ate.timestamp ,a n d ate.workflowmodelelement
are renamed to person ,timestamp ,a n d activity respectively. these names
are used in the remainder of table 2.
the goal of the ltl language is to specify properties. properties are de-
scribed using the formula construct. formulas may be nested and can have
parameters. to hide formulas that are only used indirectly, the subformula con-
struct should be used. table 2 describes ﬁve formulas and two subformulas. lines
13-14 specify a formula without any parameters. the property holds for a given1set ate.workflowmodelelement;
2set ate.originator;
3set ate.eventtype;
4
5date ate.timestamp := "yyyy-mm-dd";
6string ate.result;
7string pi.title;
8
9rename ate.originator as person;
10rename ate.timestamp as timestamp;
11rename ate.workflowmodelelement as activity;
1213
formula accept_or_reject_but_not_both() :=
14(<>(activity == "accept") <-> !(<>(activity == "reject")));
15
16formula action_follows_decision() :=
17[]( (activity == "decide" -> _o( ((activity == "accept" \/
18activity == "reject") \/ activity == "invite additional reviewer") )));
19
20subformula execute( p : person , a : activity ) :=
21<> ( (activity == a /\ person = =p));
22
23formula not_the_same_reviewer() :=
24forall[p:person |
25(((!(execute(p,"get review 1")) \/ !(execute(p,"get review 2"))) /\
26(!(execute(p,"get review 1")) \/ !(execute(p,"get review 3")))) /\
27(!(execute(p,"get review 2")) \/ !(execute(p,"get review 3")))) ];
2829
subformula accept(a : activity ) :=
30<> ( (activity == a /\ ate.result == "accept" ) ) ;
3132
formula dont_reject_paper_unjustified() :=
33(((accept("get review 1") /\ accept("get review 2")) /\
34accept("get review 3"))
35-> <> ( activity == "accept" ) );
36
37formula started_before_finished_after(start_time:timestamp,
38end_time:timestamp) :=
39(<>( timestamp < start_time ) /\ <>( timestamp > end_time ));
table 2. some ltl formulas for the running example.event log if for each paper there was an acceptance (activity iin figure 1) or
a rejection (activity jin figure 1) but not both. to formulate this both tem-
poral and logical operators are used: <>is the syntax for the temporal operator
eventually ( 3f),<->denotes “if and only if”, and !is the negation. line 14
uses the shorthand activity deﬁned in line 11 twice. activity == "accept"
is true if the workflowmodelelement attribute of the current event points to
the acceptance activity. hence, <>(activity == "accept") holds if the accep-
tance activity was executed. similarly, <>(activity == "reject") holds if the
rejection activity was executed. using <->and!we can formulate that exactly
one of these two should hold. the formula accept_or_reject_but_not_both
can be evaluated for each case in the log. if it holds for all cases, it holds for theentire log.
lines 16-18 deﬁne the property that any decision (activity hin figure 1)
should be directly followed by a rejection ( j), acceptance ( i) or invitation ( k).
the following logical and temporal operators are used to achieve this: []to de-
note the always operator ( 2f),->for implication, _odenote the nexttime oper-
ator (/circlecopyrtf), and \/for the logical or. the part []( (activity == "decide" ->
states that it should always be the case that if the current activity is decide, the
following should hold. the second part starts with _oto indicate that immedi-
ately after the decision step the current activity should be of one of the threementioned.
the formula speciﬁed in lines 23-27 uses the parameterized subformula de-
ﬁned in lines 20-21. the subformula states whether at some point in time activity
awas executed by person p. note that both parameters are typed through the
declarations in the top part of table 2. formula not_the_same_reviewer calls
the subformula six times to express the requirement that no reviewer should
review the same paper twice. in terms of figure 1: activities b,d,a n dfshould
be executed by diﬀerent people. note that universal quantiﬁcation over the set
people involved is used (cf. forall[p:person | ... ) where person is renamed
in line 9 and declared to be a set type in line 2.
the formula speciﬁed in lines 32-34 uses the parameterized subformula de-
ﬁned in lines 29-30. the subformula checks whether there is some event corre-
sponding to activity a
that has a data attribute result set to value accept, i.e.,
ate.result == "accept" . note that ate.result was declared in line 6. for-
mula dont_reject_paper_unjustified states that a paper with three positive
reviews (three accepts) should be accepted for the journal.
the last formula in table 2 (lines 36-37) shows that it is also possible to use
timestamps. the formula has two parameters (start and end time) and it holdsif each case was started before the given start time and ended after the given
end time.
the formulas shown in table 2 are speciﬁc for the running example intro-
duced in section 2. however, many generic properties can be deﬁned, e.g., the4-eyes principle . recall that this principle states that, although authorized to
execute two activities, a person is not allowed to execute both activities for the
same case. the following formula can be used to verify this:formula four_eyes_principle(a1:activity,a2:activity) :=
forall[p:person |(!(execute(p,a1)) \/ !(execute(p,a2)))];
the property four_eyes_principle("invite reviewers","decide") checks
whether activities aandhin figure 1 are indeed executed by diﬀerent people.
this example and the formulas in table 2 provide an impression of the ltl
language we have developed. it can be seen as a temporal logic tailored towards
events logs. for more details we refer to [10] and www.processmining.org. thenext section elaborates on the tool support for this language.
5 verifying properties: the ltl checker
in section 3, the prom framework has been introduced. to be able to verify prop-
erties using the language presented, three plug-ins are needed: (1) a mining plug-
in to load and ﬁlter an mxml ﬁle, (2) an import plug-in to load ltl ﬁles like theone shown in table 2, and (3) an analysis plug-in providing the graphical inter-
face and doing the actual veriﬁcation. for convenience a large number of generic
properties have been speciﬁed (e.g., the 4-eyes principle). there are about 60
application-independent properties focusing on the ate.workflowmodelelement
(activity), ate.originator (person), ate.timestamp ,a n d ate.eventtype at-
tributes. only for speciﬁc questions (e.g., related to data) the user needs to spec-
ify new formulas. the 60 standard formulas are stored in a default ﬁle that can be
applied directly without any knowledge of the ltl syntax described in the pre-vious section. it is possible to link html markup to any formula. this markup
is shown to the user when selecting a formula. this should support the selec-
tion and interpretation of the corresponding property. note that formulas may beparameterized and users need to type a value for each parameter, e.g., the two ac-
tivity names in four_eyes_principle("invite reviewers","decide") .t h e
graphical user interface shows the html text and a form that need to be ﬁlledout, cf. figure 5.
the implementation of the actual ltl checker is rather complicated. how-
ever, the core structure of the checker is fairly straightforward as is sketchedin the remainder of this section. let ldenote the event log and fa formula
expressed in the language described in the previous section. (if fis parame-
terized, then it is evaluated for concrete parameter values.) check
log(l,f)=
∀π∈l(check(f,π,0)) evaluates to true if fholds for the log l.π∈lis a process
instance (i.e., case) represented by a sequence of audit trail entries (i.e., events).|π|is the length of π, i.e., the number of events, and π
iis the ( i−1)-th entry,
i.e.,π=π0π1...π |π|−1.
check(f,π,0) checks whether the formula fholds for the ﬁrst process-instance
π∈l(i.e., the πat position 0 in l). for temporal operators, the position in the
sequence πis relevant as well. therefore, let fdenote a formula, πa case, and
ia number (0 ≤i<|π|).
check(f,π,i )=
iff=fig. 5. the ltl checker allows for the selection of formulas from a pull-down menu,
oﬀers help text, and supports the setting of parameters.
expr(πi)⇔
true, expr is atomic and holds for i-th audit trail entry of π, i.e., πi;
false, expr is atomic and does not hold for i-th audit trail entry of π, i.e., πi;
¬φ⇔¬check(φ,π,i);
φ∧ψ⇔check(φ,π,i)∧check(ψ,π,i );
φ∨ψ⇔check(φ,π,i)∨check(ψ,π,i );
φ→ψ⇔check(φ,π,i)→check(ψ,π,i );
φ↔ψ⇔check(φ,π,i)↔check(ψ,π,i );
∀x∈x(φx)⇔∀ x∈x(check(φx,π,i));
∃x∈x(φx)⇔∃ x∈x(check(φx,π,i));
2φ⇔
check(φ,π,i)∧check(f,π,i +1 ),0≤i<(|π|−1);
check(φ,π,i),i=(|π|−1);
3φ⇔
check(φ,π,i)∨check(f,π,i +1 ),0≤i<(|π|−1);
check(φ,π,i),i=(|π|−1);
/circlecopyrtφ⇔
check(φ,π,i +1 ),0≤i<(|π|−1);
false,i =(|π|−1);
φuψ⇔
check(ψ,π,i )∨(check(φ,π,i)∧check(f,π,i + 1)),0≤i<(|π|−1);
check(ψ,π,i )∨check(φ,π,i),i=(|π|−1);theexprfunction is a function which computes atomic boolean expressions
that may involve all kinds of attributes (e.g., timestamps etc. but also data valuesor case attributes). given the fact that there are many comparison operators,
typing issues and advanced features such as pattern matching, the coding of the
ltl checker is more complex than the sketch just given suggests.
the unfolding of the quantiﬁcations may be an expensive operation. how-
ever, no quantiﬁcation is bigger than the number of events within a single case.
moreover, each case (process instance) can be checked in isolation thus making
the algorithms tractable. note that logs may contain thousands or even mil-lions of cases. however, the number of events per case is typically less than 100.
therefore, from a practical point of view, the core algorithm is linear in the size
of the log.
fig. 6. the ltl checker detected a problem when checking the 4-eyes principle.
to conclude, we show a screenshot of the result, cf. figure 6. it shows the
result of four_eyes_principle("get review 1","get review 3") applied to
the log with 48 cases. 47 of these cases satisfy the property. only for one case
(case 2), the property is not satisﬁed as shown in figure 6. indeed the paper is
reviewed by trudy twice. in one review, she rejects the paper while in anotherone she accepts it.
for every property, the ltl checker partitions the set of cases into two sets:
l
ok(the cases that satisfy the property) and lnok(the ones that do not).
iflnok=∅, the property holds. otherwise, lnokprovides counterexamples.
both sets can be saved and analyzed further. for example, it is possible to
construct a process model or social network for lokorlnok.t h i sm a yb e
helpful when analyzing (root) causes for violations of a desirable property.6 related work
the work reported in this paper is closely related to earlier work on process
mining, i.e., discovering a process model based on some event log. the idea of
applying process mining in the context of workﬂow management was ﬁrst in-
troduced in [9]. cook and wolf have investigated similar issues in the contextof software engineering processes using diﬀerent approaches [12]. herbst and
karagiannis also address the issue of process mining in the context of workﬂow
management using an inductive approach [21]. they use stochastic task graphsas an intermediate representation and generate a workﬂow model described in
the adonis modeling language. then there are several variants of the αalgo-
rithm [8, 37]. in [8] it is shown that this algorithm can be proven to be correctfor a large class of processes. in [37] a heuristic approach using rather simple
metrics is used to construct so-called “dependency/frequency tables” and “de-
pendency/frequency graphs”. this is used as input for the αalgorithm. as a
result it is possible to tackle the problem of noise. for more information on
process mining we refer to a special issue of computers in industry on process
mining [7] and a survey paper [6]. given the scope of this paper, we are unable
to provide a complete listing of the many papers on process mining published in
recent years.
conformance testing, i.e., checking whether a given model and a given event
log ﬁt together, can be a seen a very speciﬁc form of log-based veriﬁcation.
instead of some logical formula, a process model (e.g., petri net) is used toverify whether the log satisﬁes some behavioral properties. therefore, the work
of cook et al. [13, 11] is closely related to this paper. in [13] the concept of
process validation is introduced. it assumes an event stream coming from themodel and an event stream coming from real-life observations. both streams are
compared. only in the last part of the paper an attempt is made to selectively
try and match possible event streams of the model to a given event stream. asa result only ﬁtness is considered and the time-complexity is problematic as the
state-space of the model needs to be explored. in [11] the results are extended
to include time aspects. the notion of conformance has also been discussed inthe context of security [4], business alignment [2], and genetic mining [26].
monitoring events with the goal to verify certain properties has been inves-
tigated in several domains, e.g., in the context of requirements engineering [15,
31, 32] and program monitoring [16, 19, 20]. it is also interesting to note the pos-
sible applications of such techniques in the context of monitoring web services.in such a distributed environment with multiple actors, it is highly relevant to
be able to monitor the behavior of each actor.
the work robinson [31, 32] on requirements engineering is highly related.
he suggests the use of ltl for the veriﬁcation of properties. important dif-
ferences between this approach and ours are the focus on real-time monitoring
(with model-checking capabilities to warn for future problems) and the codingrequired to check the desired properties. the following quote taken from [31]
illustrates the focus of this work: “execution monitoring of requirements is a
technique that tracks the run-time behavior of a system and notes when it devi-ates from its design-time speciﬁcation. requirements monitoring is useful when
it is too diﬃcult (e.g., intractable) to prove system properties. to aid analy-sis, assumptions are made as part of the requirements deﬁnition activity. the
requirements and assumptions are monitored at run-time. should any such con-
ditions fail, a procedure can be invoked (e.g., notiﬁcation to the designer).” in atechnical sense, the work of havelund et al. [19, 20] is highly related. havelund et
al. propose three ways to evaluate ltl formulas: (1) automata-based, (2) using
rewriting (based on maude), (3) and using dynamic programming. we use thelatter approach (dynamic programming).
process mining, conformance testing, and log-based veriﬁcation can be seen
in the broader context of business (process) intelligence (bpi) and businessactivity monitoring (bam). in [17, 18, 35] a bpi toolset on top of hp’s process
manager is described. the bpi tools set includes a so-called “bpi process min-
ing engine”. in [27] zur muehlen describes the pisa tool which can be usedto extract performance metrics from workﬂow logs. similar diagnostics are pro-
vided by the aris process performance manager (ppm) [23]. the latter tool is
commercially available and a customized version of ppm is the staﬀware pro-cess monitor (spm) [36] which is tailored towards mining staﬀware logs. note
that none of the latter tools is supporting conformance testing or the checking of
(temporal) properties. instead, the focus of these tools is often on performance
measurements rather than monitoring (un)desirable behavior.
for a more elaborate description of the ltl language and checker we refer
to [10]. the idea to apply ltl to workﬂow management originates from the ﬁrstauthor and was implemented by the second author under the supervision of the
ﬁrst and third author. in parallel to this implementation, a simpliﬁed prototype
was developed [33].
7 conclusion
this paper presents both a language and a tool to enable the veriﬁcation of
properties based on event logs. the language is based on ltl and is tailored
towards events logs stored in the mxml format. the mxml format is a tool-independent format to log events and can be generated from audit trails, transac-
tion logs and other data sets describing business events. current software allows
for the easy collection of such data, cf. bpm, wfm, crm, bam systems. more-over, the need for both ﬂexibility [1, 14, 29, 30] and auditing capabilities (cf. the
sarbanes-oxley act [34]) underpins the relevance of the results presented in this
paper.
we have predeﬁned 60 typical properties one may want to verify (e.g., the 4-
eyes principle). these can be used without any knowledge of the ltl language.
in addition the user can deﬁne new sets of properties. these properties may beapplication speciﬁc and may refer to data. each property is speciﬁed in terms
of a so-called formula. formulas may be parameterized, are reusable, and carry
explanations in html format. this way both experts and novices may use theltl checker. the ltl checker has been implemented in the prom framework
and the results can be further analyzed using a variety of process mining tools.
we do not propose to solely use ltl for the type of analysis discussed in this
paper. in addition to the ltl checker and the process mining tools, conventional
tools such as sql and xpath can also be used to query and ﬁlter event logs. forexample, in the context of a case study we loaded mxml ﬁles into an oracle
database to query them using sql.
references
1. w.m.p. van der aalst. exterminating the dynamic change bug: a concrete
approach to support workﬂow change. information systems frontiers , 3(3):297–
317, 2001.
2. w.m.p. van der aalst. business alignment: using process mining as a tool for
delta analysis. in j. grundspenkis and m. kirikova, editors, proceedings of the 5th
workshop on business process modeling, development and support (bpmds’04) ,
volume 2 of caise’04 workshops , pages 138–145. riga technical university, latvia,
2004.
3. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
4. w.m.p. van der aalst and a.k.a. de medeiros. process mining and security:
detecting anomalous process executions and checking process conformance. inn. busi, r. gorrieri, and f. martinelli, editors, second international workshop
on security issues with petri nets and other computational models (wisp 2004) ,
pages 69–84. star, servizio tipograﬁco area della ricerca, cnr pisa, italy, 2004.
5. w.m.p. van der aalst and m. song. mining social networks: uncovering interac-
tion patterns in business processes. in j. desel, b. pernici, and m. weske, editors,
international conference on business process management (bpm 2004) ,v o l u m e
3080 of lecture notes in computer science , pages 244–260. springer-verlag, berlin,
2004.
6. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
7. w.m.p. van der aalst and a.j.m.m. weijters, editors. process mining ,s p e c i a l
issue of computers in industry, volume 53, number 3. elsevier science publishers,amsterdam, 2004.
8. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128–1142, 2004.
9. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
10. h. de beer. the ltl checker plugins: a reference manual . eindhoven university
of technology, eindhoven, 2004.
11. j.e. cook, c. he, and c. ma. measuring behavioral correspondence to a timed
concurrent model. in proceedings of the 2001 international conference on soft-
ware mainenance , pages 332–341, 2001.12. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
13. j.e. cook and a.l. wolf. software process validation: quantitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147–176, 1999.
14. c.a. ellis, k. keddara, and g. rozenberg. dynamic change within workﬂow
systems. in n. comstock, c. ellis, r. kling, j. mylopoulos, and s. kaplan, editors,
proceedings of the conference on organizational computing systems , pages 10 –
21, milpitas, california, august 1995. acm sigois, acm press, new york.
15. s. fickas, t. beauchamp, and n.a.r. mamy. monitoring requirements: a case
study. in proceedings of the 17th ieee international conference on automated
software engineering (ase’02) , page 299. ieee computer society, 2002.
16. d. giannakopoulou and k. havelund. automata-based veriﬁcation of temporal
properties on running programs. in proceedings of the 16th ieee international
conference on automated software engineering (ase’01) , pages 412–416. ieee
computer society press, providence, 2001.
17. d. grigori, f. casati, m. castellanos, u. dayal, m. sayal, and m.c. shan. business
process intelligence. computers in industry , 53(3):321–343, 2004.
18. d. grigori, f. casati, u. dayal, and m.c. shan. improving business process qual-
ity through exception understanding, prediction, and prevention. in p. apers,
p. atzeni, s. ceri, s. paraboschi, k. ramamohanarao, and r. snodgrass, ed-
itors, proceedings of 27th international conference on very large data bases
(vldb’01) , pages 159–168. morgan kaufmann, 2001.
19. k. havelund and g. rosu. monitoring programs using rewriting. in proceedings
of the 16th ieee international conference on automated software engineering(ase’01) , pages 135–143. ieee computer society press, providence, 2001.
20. k. havelund and g. rosu. synthesizing monitors for safety properties. in pro-
ceedings of the 8th international conference on tools and algorithms for the con-struction and analysis of systems (tacas 2002) , volume 2280 of lecture notes
in computer science , pages 342–356. springer-verlag, berlin, 2002.
21. j. herbst. a machine learning approach to workﬂow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183–194. springer-verlag, berlin, 2000.
22. t. hoﬀman. sarbanes-oxley sparks forensics apps interest: vendors oﬀer moni-
toring tools to help identify incidents of financial fraud. computerworld , 38:14–
14, 2004.
23. ids scheer. aris process performance manager (aris ppm): measure, ana-
lyze and optimize your business process performance (whitepaper). ids scheer,
saarbruecken, gemany, http://www.ids-scheer.com, 2002.
24. g. keller and t. teufel. sap r/3 process oriented implementation . addison-
wesley, reading ma, 1998.
25. z. manna and a. pnueli. the temporal logic of reactive and concurrent systems:
speciﬁcation . springer-verlag, new york, 1991.
26. a.k.a. de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. using ge-
netic algorithms to mine process models: representation, operators and results.
beta working paper series, wp 124, eindhoven university of technology, eind-hoven, 2004.
27. m. zur m¨ uhlen and m. rosemann. workﬂow-based process monitoring and con-
trolling - technical and organizational issues. in r. sprague, editor, proceedingsof the 33rd hawaii international conference on system science (hicss-33) , pages
1–10. ieee computer society press, los alamitos, california, 2000.
28. a. pnueli. the temporal logic of programs. in proceedings of the 18th ieee
annual symposium on the foundations of computer science , pages 46–57. ieee
computer society press, providence, 1977.
29. m. reichert and p. dadam. adeptﬂex: supporting dynamic changes of
workﬂow without loosing control. journal of intelligent information systems ,
10(2):93–129, 1998.
30. s. rinderle, m. reichert, and p. dadam. correctness criteria for dynamic
changes in workﬂow systems: a survey. data and knowledge engineering ,
50(1):9–34, 2004.
31. w.n. robinson. monitoring software requirements using instrumented code. in
proceedings of the 35th annual hawaii ieee international conference on systems
sciences , pages 276–276. ieee computer society , 2002.
32. w.n. robinson. monitoring web service requirements. in proceedings of 11th
ieee international conference on requirements engineering (re 2003) ,p a g e s
56–74. ieee computer society , 2003.
33. e. roubtsova. a property speciﬁcation language for workﬂow diagnostics. in-
ternal note, eindhoven university of technology, 2005.
34. p. sarbanes, g. oxley, and et al. sarbanes-oxley act of 2002, 2002.35. m. sayal, f. casati, u. dayal, and m.c. shan. business process cockpit. in pro-
ceedings of 28th international conference on very large data bases (vldb’02) ,
pages 880–883. morgan kaufmann, 2002.
36. staﬀware. staﬀware process monitor (spm). http://www.staﬀware.com, 2002.
37. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.