extracting object-centric event logs to support
process mining on databases
guangming li1, eduardo gonz ´alez l ´opez de murillas1, renata medeiros de
carvalho1, and wil m.p. van der aalst1;2
1department of mathematics and computer science, eindhoven university of technology,
p.o. box 513, 5600 mb eindhoven, the netherlands.
fg.li.3,e.gonzalez,r.carvalho,w.m.p.v.d.aalst g@tue.nl
2rwth aachen university, aachen, germany.
abstract. process mining helps organizations to investigate how their opera-
tional processes are executed and how these can be improved. process mining
requires event logs extracted from information systems supporting these pro-
cesses. the extensible event stream (xes) format is the current standard which
requires a case notion to correlate events. however, it has problems to deal with
object-centric data (e.g., database tables) due to the existence of one-to-many and
many-to-many relations. in this paper, we propose an approach to extract, trans-
form and store object-centric data, resulting in extensible object-centric (xoc)
event logs. the xoc format does not require a case notion to avoid ﬂattening
multi-dimentional data. besides, based on so-called object models which repre-
sent the states of a database, a xoc log can reveal the evolution of the database
along with corresponding events. dealing with object-centric data enables new
process mining techniques that are able to capture the real processes much better.
1 introduction
process mining represents a set of techniques which are widely used to extract insights
from event data generated by information systems. the starting point for process min-
ing techniques is formed by event logs. the xes log format [1] is widely employed
to generate event logs. in general, a xes log consists of a collection of traces. a trace
describes the life-cycle of a particular case (i.e., a process instance) in terms of the ac-
tivities executed. process-aware information systems (e.g., bpm/wfm systems) which
assume an explicit case notion to correlate events, provide such logs directly.
however, the information systems one encounters in most organizations are object-
centric . some examples of these systems are customer relationship management
(crm) and/or enterprise resource planning (erp) which provide business functions
such as procurement, production, sales, delivery, ﬁnance, etc. examples are the er-
p/crm suites from vendors such as sap (s/4hana), oracle (e-business suite), mi-
crosoft (dynamics 365), and salesforce (crm). there are also some free and open
source alternatives such as dolibarr and odoo. a common feature of these systems is
that they are built on top of database technology, i.e., they contain hundreds of tables
covering customers, orders, deliveries, etc. figure 1 shows a fragment of data generated
by the dolibarr erp system. this is an example of object-centric data since object in-
stances are explicitly recorded (e.g., orders, which can be abstracted as objects) while2 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
events related to the underlying process are implicitly recorded by other means, e.g.,
through redo logs (cf. table 1). approaches to extract xes logs from databases with
the aid of ontology [3] or redo logs [5] have been previously proposed.
order (o)
id creation_date customer
o1 2017 -08-11 10:33:37 c1
o2 2017 -08-13 16:28:15 c1
shipment_line (sl)
id shipment order_line quantity
sl1 s1 ol1 1
sl2 s2 ol1 1
sl3 s2 ol2 3
sl4 s3 ol3 3
sl5 s3 ol4 2shipment (s)
id creation_date customer
s1 2017 -08-14 11:36:35 c1
s2 2017 -08-16 14:15:31 c1
s3 2017 -08-19 13:22:04 c1
element _relation (er)
id order invoice 
er1 o1 i1
er2 o1 i2
er3 o2 i2
er4 o2 i3
invoice ( i)
id creation_date customer amount
i1 2017 -08-15 09:13:27 c1 2380
i2 2017 -08-17 17:38:36 c1 1431
i3 2017 -08-23 14:23:19 c1 1904customer (c)
id name address
c1 ming eindhoven
c2 cong tilburgpayment_line (pl)
id payment invoice amount
pl1 p1 i1 2380
pl2 p1 i2 1431
pl3 p2 i3 1904payment (p)
id creation_date amount
p1 2017 -08-21 16:26:13 3811
p2 2017 -08-26 14:53:49 1904
order _line ( ol)
id order product quantity price
ol1 o1 computer 2 1190
ol2 o1 phone 3 476
ol3 o2 cup 3 1
ol4 o2 tv 2 952r5 r4
r8 r10r6
r7 r2r3
r1r9
foreign
keyprimary
key
fig. 1. a fragment of data generated by a real erp system.
although there exist approaches to extract xes logs from object-centric data, the
constraints set by this format do not match the nature of the data at hand. the following
challenges have been identiﬁed when applying the xes format to object-centric data:
–it is required to identify the case id for the whole process . database object-centric
data lacks a single explicit deﬁnition of case notion. on the contrary, because of
the existence of multiple classes of objects (tables) and relations (foreign keys),
object-centric data can be correlated in many ways. each of these correlations may
correspond to different processes affecting the same data, or different views on the
same process (customer vs. provider point of view). in the case of xes, a case
notion has to be deﬁned beforehand to proceed with the extraction, requiring one
dedicated event log for each perspective to be analyzed.
–the quality of the input data gets compromised . if we straightjacket object-centric
data into xes logs, the input data with one-to-many and many-to-many relations is
ﬂattened into separate traces, in which events referred to by multiple cases are du-
plicated. this forced transformation introduces unnecessary redundancy and leads
to problems such as data convergence and divergence [9].3
–interactions between process instances get lost . traces in xes logs only describe
the evolution (i.e., lifecycle) of one type of process instance and they are typically
considered in isolation. due to the lack of interactions between process instances,
xes logs cannot provide a whole view to indicate the state of a system.
3data convergence means the same event is related to multiple process instances at once. data
divergence means that multiple events of the same activity are related to one process instance,
i.e., the same activity is performed multiple times for the same process instance (cf. figure 4).extracting object-centric event logs to support process mining on databases 3
–the data perspective is only secondary .4the xes format focuses on the behavioral
perspective, considering any additional information as trace or event attributes. in
this sense, the information not directly related to the events is discarded (records,
data objects, etc.), which weakens the data perspective of the original system.
to face the problems mentioned above, we propose a novel log format to organize
object-centric data from databases, resulting in extensible object-centric (xoc5)logs.
this log format provides an evolutionary view on databases based on the idea that a log
is a list of events and each event refers to an object model (cf. section 2.1) representing
the state of the database just updated by the event. process mining takes logs as input,
and this log format transforms the raw data from databases into event logs, which paves
a road to analyze databases in a process mining approach.
compared with xes, the xoc format has the following contributions. it correlates
events based on objects rather than a case notion, which solves the challenge of identi-
fying a case id. besides, without the constraints set by the case notion, xoc logs can
better deal with one-to-many and many-to-many relations. additionally, more power-
ful concepts such as object models are employed to provide a whole view of the state
of the database as well as the interactions between instances. moreover, all columns
in a record can be abstracted as attributes of an object (denoting the record) to enrich
the data perspective. to validate the log format, we present an approach to automati-
cally transform object-centric data into xoc logs. in resulting logs, an event type is
deﬁned on the information system level (e.g., “create order”) rather than the database
level (e.g., “insert an order record” and “insert an order line record”) [5], which makes
extracted events more intuitive for users. besides these contributions, xoc logs enable
new process mining techniques to further solve the problems mentioned above. discov-
ering data-aware process models like the object-centric behavioral constraint (ocbc)
models [8], to better reveal the complex interactions between the behavioral and data
perspectives4(cf. figure 5), checking conformance for deviations which cannot be de-
tected by conventional methods [14] and predicting future events and objects according
to a discovered ocbc model (cf. section 4) are some examples of enabled techniques.
the remainder is organized as follows. in section 2, we describe the xoc log for-
mat. section 3 proposes an approach to extract xoc logs from databases, and section 4
demonstrates an implementation of the approach and a comparison between xoc logs
and xes logs. section 5 reviews the related work while section 6 concludes the paper.
2 object-centric event log
process mining techniques take event logs as input. in order to apply these techniques to
object-centric data, we propose a novel log format to organize such data in this section.
2.1 object-centric data
increasingly, organizations are employing object-centric information systems, such as
erp and crm, to deal with their transactions. in this paper, we use the term “object”
4the behavioral perspective refers to the control-ﬂow of events while the data perspective refers
to data attributes.
5xoc is pronounced as /s 6k/.4 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
to abstract data elements (e.g., records in database tables) generated by information
systems. in this sense, object-centric systems refer to systems which record the transac-
tions of the same category (e.g., orders) in the same table (e.g., the “order” table) based
on the relational database technology. accordingly, the data generated by such systems
are called object-centric data. figure 1 shows an example of object-centric data.
objects are grouped in classes and have some attributes. for example, a record in
the “order” table (e.g., the ﬁrst row) can be considered as an object of class “order”.
each value (e.g., “c1”) in the record can be considered as an attribute of the object.
besides, there exist class relationships between classes, which corresponds to depen-
dency relations between tables. for instance, there is a class relationship between class
“order” and class “order line”, indicated by one of foreign keys of table “order line”,
which refers to the primary key of table “order”.
customer invoice shipment
c2c1
er1
er4s1 s2
r2r1
r1r1
r2
r3
r9
paymentpayment line
order line
r10
r10
r10orderelement relation shipment line
pl2
pl3pl1sl5
sl4
r7r8
ol1
ol2
ol3 ol4p2
p1er3s3
sl1
sl2sl3
o1
o2i2
r2i1i3
er2r3
r3r3r4
r4
r4
r5r5r6r6r6 r6r6
r7 r7r8 r8r8 r9 r9 r9r9
r10
fig. 2. an example of an object model.
deﬁnition 1 (object model). letuobe the universe of objects ,ucbe the universe
ofclasses ,urtbe the universe of class relationships ,uattr be the universe of at-
tribute names anduvalbe the universe of attribute values .c u cis a set of
classes and rt u rtis a set of class relationships. an object model is a tuple
om= (obj;rel;class;objectattr ), where
–objuois a set of objects,
–relrtobjobj is a set of object relations,
–class2obj!cmaps objects onto classes, and
–objectattr2obj!(uattr6!u val)maps objects onto a partial function assign-
ing values to some attributes.
uomis the universe of object models.
an object model consists of objects, object relations and two functions indicating
the class and attributes of each object. in the database context, an object model repre-
sents the state of a database at some moment, where objects correspond to records in
tables and relations correspond to dependencies between records.extracting object-centric event logs to support process mining on databases 5
figure 2 shows an object model om= (obj;rel;class;objectattr )which repre-
sents the state of the database indicated in figure 1. the 28 objects are depicted as grey
dots. there are two objects o1ando2belonging to class “order” , i.e., class(o1) =
class(o2) =order . there are three object relations corresponding to class relationship
r1, i.e., (r1;c1;i1)2rel,(r1;c1;i2)2reland(r1;c1;i3)2rel. the object
i1has an attribute named “creation date” with a value “2017-08-15 09:13:27”, i.e.,
objectattr (i1)(\creation date") = \2017 08 15 09 : 13 : 27" . note that, the
attributes of objects are not shown in the graph.
2.2 database changes
unlike process-aware information systems (e.g., bpm/wfm systems), object-centric
information systems keep transactions in “regular tables” in databases. a record in a
table indicates the current state of an instance. it is difﬁcult to reveal all the events im-
pacting this record, e.g., the ﬁrst record in “order line” table tells nothing about events.
fortunately, database technology often provides so-called redo logs (as shown in ta-
ble 1) that record the history of database changes. similarly, most sap systems provide
twochange tables , i.e., cdhdr (recording all database changes) and cdpos (record-
ing details of each change in cdhdr) as shown in table 2. if redo logs and change
tables are not available, then domain knowledge is needed to obtain changes, i.e., times-
tamps/dates in particular columns refer to the creation of the row or to changes of values.
using domain knowledge, these timestamps can reconstruct database changes.
table 1. a fragment of a redo log in which each line corresponds to a change in the database.
# time redo
12017-08-11 10:33:37 insert into “order” (“id”,“creation date”,“customer”) values (“o1”,“2017-08-11 10:33:37”,“c1”)
22017-08-11 10:33:37insert into “order line” (“id”,“order”,“product”,“quantity”,“price”) values
(“ol1”,“o1”,“computer”,“2”,“1190”)
32017-08-11 10:33:37insert into “order line” (“id”,“order”,“product”,“quantity”,“price”) values
(“ol2”,“o1”,“phone”,“3”,“476”)
table 2. a fragment of the cdhdr table (left) and cdpos table (right).
headid date time op
100 2017-08-11 10:33:37 i
101 2017-08-11 10:33:37 i
102 2017-08-11 10:33:37 i
103 2017-08-13 16:28:15 i
104 2017-08-14 11:36:35 iitemid headid tabname key fieldname op newvalue oldvalue
1 100 order o1 id i o1 none
2 100 order o1creation date i2017-08-11 10:33:37 none
3 100 order o1 customer i c1 none
4 101 order line ol1 id i ol1 none
5 101 order line ol1 order i o1 none
each change corresponds to one execution of an sql sentence, i.e., one event on the
database level. in this paper, the extracted logs cater to people who operate information
systems and may be unfamiliar with databases. therefore, the extracted events are on
the information system level rather than the database level. in other words, an example
of an event is a “create order” operation rather than an execution of “insert an order
record”, which makes extracted logs more intuitive and understandable. note that, an
event may correspond to multiple changes, e.g., the three changes in table 1 correspond
to one “create order” event, and these changes may have the same timestamp (i.e., it is
not necessary that each change has a unique timestamp). in real applications, the derived
changes may cover multiple processes. for a given process, we can scope the changes
using tricks such as based on a time window or classes involved [13].6 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
2.3 extensible object-centric (xoc) log format
based on database changes and the current state of a database, it is possible to restore all
previous states of the database. the idea of the xoc format is that one event represents
one operation on the information system and corresponds to an object model providing
asnapshot of the system just after this operation . besides, each event has an event
type to indicate the executed activity (e.g., “create order”), and refers to some objects
modiﬁed by the event.
table 3. a fragment of the xoc log extracted from the motivating example data in figure 1.
index event event type referencesobject model
objects relations
1co1create
order (co)fo1;ol1,
ol2gfc1;c2;o1;ol1;ol2gf(r5;c1;o1);(r10;o1;ol1);(r10;o1;ol2)g
2co2create
order (co)fo2;ol3,
ol4gfc1;c2;o1;ol1;ol2,
o2;ol3;ol4gf(r5;c1;o1);(r10;o1;ol1);(r10;o1;ol2),
(r5;c1;o2);(r10;o2;ol3);(r10;o2;ol4)
3cs1create
shipment
(cs)fs1;sl1gfc1;c2;o1;ol1;ol2,
o2;ol3;ol4;s1;sl1gf(r5;c1;o1);(r10;o1;ol1);(r10;o1;ol2),
(r5;c1;o2);(r10;o2;ol3);(r10;o2;ol4),
(r4;c1;s1);(r6;s1;sl1);(r9;ol1;sl1)g
4ci1create
invoice
(ci)fi1;er1gfc1;c2;o1;ol1;ol2,
o2;ol3;ol4;s1;sl1,
i1;er1gf(r5;c1;o1);(r10;o1;ol1);(r10;o1;ol2),
(r5;c1;o2);(r10;o2;ol3);(r10;o2;ol4),
(r4;c1;s1);(r6;s1;sl1);(r9;ol1;sl1),
(r1;c1;i1);(r3;i1;er1);(r8;o1;er1)g
5cs2create
shipment
(cs)fs2;sl2,
sl3gfc1;c2;o1;ol1;ol2,
o2;ol3;ol4;s1;sl1,
i1;er1;s2;sl2;sl3gf(r5;c1;o1);(r10;o1;ol1);(r10;o1;ol2),
(r5;c1;o2);(r10;o2;ol3);(r10;o2;ol4),
(r4;c1;s1);(r6;s1;sl1);(r9;ol1;sl1),
(r1;c1;i1);(r3;i1;er1);(r8;o1;er1),
(r4;c1;s2);(r6;s2;sl2);(r9;ol1;sl2),
(r6;s2;sl3);(r9;ol2;sl3)g
deﬁnition 2 (extensible object-centric event log). letuebe the universe of
events anduetbe the universe of event types . an extensible object-centric (xoc)
event log is a tuple l= (e;act;refer;om;), where
–eueis a set of events,
–act2e!u etmaps events onto event types,
–refer2e!p(uo)relates events to sets of objects,
–om2e!u ommaps an event to the object model just after the event occurred,
–eedeﬁnes a total order on events.
ulis the universe of xoc event logs.
table 3 shows a xoc log example. the “event” column speciﬁes the set of events
while the “index” column indicates the total order on events. the last four columns
show the corresponding event type, object references (i.e., modiﬁed objects) and object
model (i.e., objects and relations) of each event, respectively. note that, the information
of objects (e.g., attribute values) is left out in table 3. in some cases, object models
may increase dramatically since an object model contains unchanged contents of the
previous one and new contents. this problem can be solved by some storage tricks,
e.g., only storing updated information, which falls out of the scope of this paper.
3 extracting object-centric event logs from databases
in this section, we propose an approach to extract xoc logs from databases based on
object-centric data (i.e., database tables) and database changes.extracting object-centric event logs to support process mining on databases 7
3.1 formalizations of object-centric data
this subsection provides a formal deﬁnition to describe object-centric data (i.e.,
database tables), which refers to the notations in [13, 5].
deﬁnition 3 (data model). letv u valbe a set of values. a data model is
a tuple dm = (c; a; classattr ; val; pk;fk;classpk ;classfk ;keyrel ;keyattr ;
refattr )such that
–cucis a set of classes,
–auattris a set of attribute names,
–classattr2c!p (a)maps each class onto a set of attribute names,6
–val2a!p (v)maps each attribute onto a set of values,
–pkis a set of primary keys and fkis a set of foreign keys, where pk and fk are
assumed to be disjoint in this paper (i.e., pk\fk=;) and k=pk[fk,
–classpk2c!pkmaps each class onto a primary key,
–classfk2c!p (fk)maps each class onto a set of foreign keys,
–keyrel2fk!pkmaps each foreign key onto a primary key,
–keyattr2k!p (a)maps each key onto a set of attributes, and
–refattr2fka6!amaps each pair of a foreign key and an attribute
onto an attribute from the corresponding primary key. that is, 8k2fk :
8a; a02keyattr (k) : (refattr (k; a)2keyattr (keyrel (k))^(refattr (k; a) =
refattr (k; a0)=)a=a0).
udmis the universe of data models.
adata model describes the structure of the object-centric data. more precisely,
a class represents a table while an attribute represents a column in a table. function
classattr speciﬁes the attributes of a class and function valindicates possible values
for an attribute. classpk andclassfk deﬁne the primary key (pk) and foreign keys
(fks) for each table, respectively. given a fk, keyrel indicates its referred pk.
take the tables in figure 1 as an example. c=fp; o; s; er; ol; sl; pl; i; c gand
a=fid; creation date; amount; :::; address g.classattr (p) =fid; creation date;
amountgandval(amount ) = i n where p2c(i.e., the “payment” table).
deﬁnition 4 (records). letdm = ( c; a; classattr ; val; pk;fk;classpk ;
classfk ;keyrel ;keyattr ;refattr )be a data model and mdm=fmap2a6!
vj 8a2dom(map) :map(a)2val(a)gbe the set of mappings of dm.
rdm=f(c; map )2cmdmjdom(map) = classattr (c)gis the set of all
records of dm if8(c; map );(c; map0)2rdm: (8a2keyattr (classpk (c)) :
map(a) =map0(a)))map=map0.
given a data model, deﬁnition 4 formalizes the possible records of the model. for
instance, the ﬁrst record in the “payment line” table can be formalized as (c; map )
where c=pl,dom(map) =fid; payment; invoice; amount g, and map(id) =pl1,
map(payment ) =p1,map(invoice ) =i1,map(amount ) = 2380 .
deﬁnition 5 (data set). an object-centric data set is a tuple ds= (dm;rs)where
dm2udmis a data model and rsrdmis a set of records of dm .udsis the
universe of data sets.
6p(x)is the power set of x, i.e.,y2p (x)ifyx.8 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
3.2 formalizations of database changes
after formalizing the data perspective (i.e., data model and records), this subsection
formalizes the changes (i.e., adding, updating, or deleting records) in databases.
deﬁnition 6 (change types). letdm = (c; a; classattr ; val; pk;fk;classpk ;
classfk ;keyrel ;keyattr ;refattr )be a data model. ctdm=ctdm
add[ctdm
upd[
ctdm
del is the set of change types composed of the following pairwise disjoint sets:
–ctdm
add=f(; c; a0)jc2c^a0classattr (c)^keyattr (classpk (c))a0g
are the change types for adding records of dm,
–ctdm
upd=f(; c; a0)jc2c^a0classattr (c)^keyattr (classpk (c))\a0=
;gare the change types for updating records of dm, and
–ctdm
del=f(	; c; a0)jc2c^a0=classattr (c)gare the change types for
deleting records of dm.
uctis the universe of change types.
deﬁnition 7 (changes). letdm be a data model, rdmbe the set of records of dm ,
ctdm=ctdm
add[ctdm
upd[ctdm
delbe the set of change types and map null2;! v
be a function with the empty set as domain. chdm=chdm
add[chdm
upd[chdm
del is
the set of changes composed of the following pairwise disjoint sets:
–chdm
add =f(; c; a0; map old; map new)j(; c; a0)2ctdm
add^map old=
map null^(c; map new)2rdmg,
–chdm
upd=f(; c; a0; map old; map new)j(; c; a0)2ctdm
upd^(c; map old)2
rdm^(c; map new)2rdmg, and
–chdm
del=f(	; c; a0; map old; map new)j(	; c; a0)2ctdm
del^(c; map old)2
rdm^map new=map nullg.
achange (op; c; a0; map old; map new)corresponds to an sql sentence, i.e.,
adding, updating or deleting a record in a table. its change type (op; c; a0)indicates
which table (i.e., c) the record is in, which columns (i.e., a0) of the record are impacted
and how the record is impacted (indicated by op, i.e., adding, updating or deleting),
while its old and new mappings (i.e., map oldandmap new) specify the contents of the
record before and after the change, respectively. note that, a0provides more power to
produce different change types, i.e., changes impacting different attributes in the same
table can be clariﬁed into different change types, which is not considered in [5].
deﬁnition 8 (change occurrence, change log). letdm be a data model and
chdmbe the set of changes of dm. lettsbe the universe of timestamps. codm=
chdmtsis the set of all possible change occurrences of dm. a change log
cl=hco1; co 2; :::; co ni2(codm)is a sequence of change occurrences such that
time is non-decreasing, i.e., tsi6tsjfor any coi= (chi; tsi)andcoj= (chj; tsj)
with16i < j6n.uclis the universe of change logs.
achange occurrence co= (ch; ts )represents a change chhappened at ts. it corre-
sponds to one row in the redo log or cdhdr table. a change log consists of a list of
change occurrences which are sorted by timestamps such that time is non-decreasing.
note that, change logs record behavior on the database level (e.g., an execution of “in-
sert an order record”) while xoc logs record behavior on the information system level
(e.g., a “create order” operation) (cf. section 2.2).extracting object-centric event logs to support process mining on databases 9
deﬁnition 9 (effect of a change). letdm be a data model. chdmis the set
of changes of dm andch= (op; c; a0; map old; map new)2chdmis a change.
dsold= (dm;rsold)anddsnew= (dm;rsnew)are two data sets. dsnew is
generated after the change chondsoldand denote dsoldch!dsnewif and only if
–rsnew=f(c0; map0)2rsoldj(c0; map0)6= (c; map old)g[f (c; map new)j
op6=	gor
–rsold=f(c0; map0)2rsnewj(c0; map0)6= (c; map new)g[f (c; map old)j
op6=g
deﬁnition 10 (effect of a change log). letdm be a data model and cl=
hco1; co 2; :::; co ni2u clbe a change log. there exist data sets ds0,ds1,...,dsn2
udssuch that ds0co1!ds1co2!ds2:::con!dsn. hence, change log cl results in data
setdsnwhen starting in ds0. this is denoted by ds0cl!dsn.
given a data set dsold= (dm;rsold), a change results in a new data set dsnew
through adding, updating or deleting a record in the record set rsoldofdsold(cf. deﬁ-
nition 9). similarly, a change log results in a data set dsnthrough orderly accumulating
the effects of all changes on the initial data set ds0, indicated by deﬁnition 10.
3.3 formalizations of extracting logs
a xoc log (e;act;refer;om;)consists of events, event types, object references, ob-
ject models and event ordering. for extracting events, one needs to specify some event
types based on domain knowledge which indicates the relations between event types
(classifying behavior at the information system level) and change types (classifying be-
havior at the database level)(cf. section 2.2). an example of the knowledge is that the
“create order” event type consists of two change types, i.e., “insert one order record”
and “insert one or more order line records”, since a click on the “create order” button
inserts one record in the “order” table and one or more records in the “order line” table.
deﬁnition 11 (cardinalities). ucard=fx2p(i n)nf;gg deﬁnes the universe of all
cardinalities. a cardinality (an element of ucard) speciﬁes a non-empty set of integers.
deﬁnition 12 (event types). letdm be a data model and ctdmbe the set of
change types of dm.etdm=fet2p(ucardctdm)nf;gj8 (card 1; ct1);
(card 2; ct2)2et: (ct1=ct2)card 1=card 2)gis the set of event types of dm.
anevent type is deﬁned as a set of tuples of a cardinality and a change type, where
the cardinality describes the quantitative relation between the event type and the change
type. for example, the “create order” event type is denoted as f(f1g;(; o; a0
1));
(f1::g;(; ol; a0
2))gwhich means a “create order” event adds precisely one record
in the “order” ( o) table, and at least one record in the “order line” ( ol) table. deﬁni-
tion 12 speciﬁes a concrete realization for event types while uet(cf. deﬁnition 2) only
abstractly deﬁnes the universe.
deﬁnition 13 (events). letdm be a data model, codmbe the set of change oc-
currences of dm andetdmbe the set of event types of dm.edm=fe210 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
(codm)nf;gj8 (chi; tsi);(chj; tsj)2e: (i < j)tsi6tsj)gis the set of events
ofdm. function possiblee2etdm!p(edm)returns possible events of an event
type such that possiblee (et) =fe2edmj8((op; c; a0; map old; map new); ts)2
e: (9card2 u card : (card;(op; c; a0))2et)^8(card0;(op0; c0; a00))2et:
jf((op0; c0; a00; map0
old; map0
new); ts0)2egj2card0g.
an event is a non-empty sequence of change occurrences such that time
is non-decreasing. function possiblee gives all possible events correspond-
ing to one event type. for instance, e=h((; o; a; map old; map new); ts);
((; ol; a0; map0
old; map0
new); ts)iis a possible event of the event type “create order”
(co), i.e., e2possiblee (co). deﬁnition 13 speciﬁes a concrete realization for events.
deﬁnition 14 (extracting event types). letdm be a data model. eedmis a
set of events. etetdmis a predeﬁned set of event types where 8et1; et22et:
possiblee (et1)\possiblee (et2) =;. function extractet2e!etmaps an event
to an event type such that extractet (e) =etwhere e2possiblee (et).
given a predeﬁned set of event types whose possible events are disjoint, function
extractet maps an event to an event type in the set. in this paper, we assume there
exists exactly one possible type in the predeﬁned set for the event.
deﬁnition 15 (mapping record into object). letdm= (c; a; classattr ; val; pk;
fk;classpk ;classfk ;keyrel ;keyattr ;refattr )be a data model and rdmbe the
set of records of dm. function extracto2rdm!u omaps a record (c; map )to
an object such that extracto ((c;map)) = ( c; map k)2cmdmwhere
–dom(map k) =keyattr (classpk (c)), and
–8a2dom(map k) :map k(a) =map(a).
function extracto ﬁlters in the mapping for attributes corresponding to the primary
key of a record, resulting in an object. this function speciﬁes a concrete realization, i.e.,
a tuple (c; map k), for each object in uo(cf. deﬁnition 1).
deﬁnition 16 (mapping data set into object model). letds= (dm;rs)be
a data set where dm= (c; a; classattr ; val; pk;fk;classpk ;classfk ;keyrel ;
keyattr ;refattr )is a data model and rsis a set of records. function extractom2
uds! u om maps a data set to an object model such that extractom (ds) =
(obj;rel;class;objectattr )where
–obj=fextracto (r)jr2rsg,
–rel=f(rt;extracto ((c;map));extracto ((c0;map0))jrt= (c; pk; c0; fk)2
cpkcfk^(c; map )2rs^(c0; map0)2rs^pk=classpk (c)^
fk2classfk (c0)^keyrel (fk) = pk^8a2keyattr (fk) :map0(a) =
map(refattr (fk; a))g,
–8(c; map k)2obj:class((c; map k)) =c, and
–8(c; map k)2obj:objectattr ((c;map k)) = map where (c; map )2rsand
extracto ((c;map)) = ( c; map k).
function extractom maps a data set into an object model. more precisely, if each
attribute value corresponding to a foreign key of a record ris equal to the value of
the attribute identiﬁed by function refattr in another record r0, there exists an object
relation between extracto (r)andextracto (r0).extracting object-centric event logs to support process mining on databases 11
deﬁnition 17 (transforming change log into event sequence). function
extractes2ucl!(ue)extracts an event sequence from a change log such that
8cl=hco1; co 2; :::; co ni2u cl:extractes (cl) =he1; e2; :::; e miwhere
–fco2clg=fco0jco02ei^ei2he1; e2; :::; e mig, and
–8ei; ej2he1; e2; :::; e mi: (8(ch; ts )2ei;(ch0; ts0)2ej:i < j)ts < ts0).
a reverse function restorees2(ue)!u clwhich restores an event sequence
to a change log such that restorees (he1;e2; :::;emi) =hco1; co 2; :::; co ni.
function extractes transforms a change log (i.e., a change occurrence sequence)
into an event sequence by grouping change occurrences at the same time into an
event without modifying the order of these change occurrences. note that, it is
possible to group change occurrences based on domain knowledge instead of time,
which provides more freedom for extracting events (e.g., overlapping events). on
the contrary, function restorees transforms an event sequence into a change occur-
rence sequence, i.e., restorees (he1;e2; :::;emi) =hco1;co2; :::;coniif and only if
extractes (hco1;co2; :::;coni) =he1;e2; :::;emi, .
deﬁnition 18 (extracting xoc event log). function extractl2udsucl!u l
extracts a xoc event log from a data set and a change log such that 8ds2uds;cl2
ucl:extractl (ds;cl) = (e;act;refer;om;)where
–e=fe2he1; e2; :::; e migwherehe1; e2; :::; e mi=extractes (cl),
–act=extractet ,
–8ei2e:refer(ei) =foj 9((op; c; a0; map old; map new); ts)2ei:o=
extracto (c;map new)^op6=	g[f oj9((	; c; a0; map old; map new); ts)2ei:
o=extracto (c;map old)g,
–8ei2e:om(ei) =omisuch that omicl0
!extractom (ds)where cl0=
restorees (tlm i(he1;e2; :::;emi))andhe1; e2; :::; e mi=extractes (cl),7and
–=f(ei; ej)jei2e^ej2tlm i(he1;e2; :::;emi)wherehe1; e2; :::; e mi=
extractes (cl).
function refer is obtained through identifying the impacted (added, updated
or deleted) objects by each event. the data set indicates the object model (i.e.,
extractom (ds)) corresponding to the last event (i.e., em). in order to obtain the
object model corresponding to one event ei, we get (i) its sufﬁx event sequence
tlm i(he1; e2; :::; e mi)(i.e.,hei+1; ei+2; :::; e mi), (ii) the corresponding change se-
quence cl0through extractes and (iii) the object model omithrough!.
4 implementation
our approach has been implemented in the “xoc log generator” plugin in prom 6
nightly builds , which takes tables (from a database or csv ﬁles) as input and automati-
cally generates a xoc log. for instance, taking the motivating data as input, this plugin
generates an event log with 10 events, the ﬁrst ﬁve ones of which are shown in table 3.8
a xoc log reveals the evolution of a database along with the events from its cor-
responding information system. as shown in figure 3, after the occurrence of an event
7tlk()means to get the last k elements of a sequence .
8the involved data and more real life examples can be found at http://www.win.tue.nl/ocbc/.12 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
(denoted by a black dot), its corresponding object model (denoted by a cylinder) is up-
dated by adding, updating or deleting objects (highlighted in red). besides, xoc logs
provide methods to correlate events by objects. for instance, two events are correlated
if they refer to (indicated by dotted lines) two related objects, e.g., co1andcs1are
correlated since co1refers to ol1,cs1refers to sl1andol1is related to sl1.
c2
ol1
ol2o1c1
c2
ol1
ol2ol3
ol4 o2o1c1
c2s1
sl1
ol1
ol2ol3
ol4 o2o1c1
c2 s1
sl1
ol1
ol2ol3
ol4i1
er1
o2o1c1
c2s2
s1
sl2
sl3sl1
ol1
ol2ol3
ol4i1
er1
o2o1c1co1 co2 cs1 ci1 cs2
fig. 3. a xoc log (in table 3) revealing the evolution of a database.
figure 4 shows the comparison between the xes log and the xoc log derived
from the motivating data in figure 1. more precisely, figure 4(a) reveals the behavioral
perspective of the xoc log after correlating events and figure 4(b) shows two cases
o1ando2. our log is able to represent one-to-many and many-to-many relations by
removing the case notion, while the xes log splits events based on a straightjacket
case id. the split performed in the xes log results in two separated cases without
interactions in between as well as leading to convergence (e.g., cp1appears in two
cases) and divergence (e.g., multiple instances of the activity cpappear in o2) problems.
co1
(co) (cs)cs1 ci1
(ci)cs2
(cs)ci2
(ci)cp1
(cp)
co2
(co)ci2
(ci)cs3
(cs)ci3
(ci)cp2
(cp)cp1
(cp)o1
o2ci1
(ci) ci2
(ci)ci3
(ci)cs1
(cs)cs2
(cs)
time (a) the behavioral perspective of the generated xoc log. (b) the generated xes log.co1
(co)
cp2
(cp)cp1
(cp)
co2
(co)cs3
(cs)
fig. 4. a comparison which indicates xoc logs can avoid data convergence and divergence.
besides the advantages over the existing log format, xoc logs open a door for other
techniques. based on xoc logs, we can discover object-centric behavioral constraint
(ocbc) models [8], as shown in figure 5. figure 6 shows parts of three example models
discovered from the generated xes log in figure 4(b), which displays the problems
caused by data convergence and divergence. in (a) we see that the negative relation
denoted by d5with a dotted line cannot be discovered in the declare model, since in case
o2, the “create payment” event cp1is wrongly related to its subsequent “create invoice”
event ci3. the discovered directly follow graph (dfg) in (b) indicates that “create
invoice” happens 4 times, violating the real frequency of 3 times due to the duplication
ofci2. in (c) we observe that, since the multiple instance of activities “create invoice”
and “create payment” cannot be distinguished, two loops with two implicit transitions
are discovered, resulting in an imprecise petri net. in contrast, since xoc logs areextracting object-centric event logs to support process mining on databases 13
order
customer1..*
*element
relationshipment
linepayment
11
1..**
payment 
lineshipment invoice1
1
11
1*
**
*
*1
1
1..** 1
11 11..* 1
1..*
1 11..** 1
1
1 11..* 1..*
1..* 1..*
r1 r2r3
r4r5 r6 r7r8 r9 r10create 
payment (2)create 
invoice (3)
1create 
order create 
shipment 
1*
1..*22 33 55771
661 1 1
1..*11
1
1..*111
11 1 1..*1
1
11..*11 44 88
order linec1
c2c4
c5c6
c7
c8 c3
1..*indicating 
constraints between 
events
indicating 
constraints between 
objectsindicating 
constraints between 
events and objects
fig. 5. the ocbc model discovered from the generated xoc log.
not affected by convergence and divergence, the discovered ocbc model (cf. figure 5)
can show the correct frequencies (i.e., numbers in red) and the missing negative relation
(i.e.,c1)9, avoiding the problems confronted by these three models. besides, compared
with existing modeling notations, such as the models in figure 6, ocbc models can
show the data perspective, the behavioral perspective and the interactions in between
in a single diagram. moreover, since xoc logs can correlate events by objects and
have a richer data perspective, they can be used to check conformance for more implicit
deviations by considering multiple instances and data objects [14]. additionally,since
the discovered ocbc model indicates constraints in/between objects and events, it is
possible to predict future events and objects based on observed ones.
create 
invoice create 
payment d41..* 1..*
d3d1 d2
(a) a fragment of the discovered declare model.
create 
invoice(4)create 
payment(3)21
(b) a fragment of the discovered dfg. (c) a fragment of the discovered petri net.create
invoicecreate
payment d5
fig. 6. problems suffered by three kinds of models discovered from the generated xes log.
5 related work
in this section, we review the existing event log formats and introduce some researches
which extract event logs from databases.
event log formats . event logs serve as the input for many process mining tech-
niques. the xes log format [1] which stands for extensible event stream (www.xes-
standard.org) is the de facto exchange format for process mining. this format is sup-
ported by tools such as prom and implemented by openxes, an open source java li-
brary for reading, storing and writing xes logs. the xes format cannot deal well with
object-centic data. [4] proposes a meta model to abstract the object-centric data and
9the notation for the negative relation in ocbc models is different from that in declare models.14 g. li, e. gonzalez lopez de murillas, r.m. de carvalho, and w.m.p. van der aalst
redo logs into different types of entities such as attributes, objects, relations and events.
the meta model covers both behavioral and data perspectives and builds a bridge to
connect databases with process mining. this meta model is not a concrete log format,
but transforms the object-centric data into “bricks” which can constitute logs to enable
process mining techniques. our xoc log format combines the “bricks” from [4] in an
object-centric way, i.e., it focuses more on the data perspective unlike the xes format.
objects are replacing a case notion to correlate events, which makes xoc logs able to
deal with one-to-many and many-to-many relations. moreover, through deﬁning object
models, a xoc log reveals the evolution of a database through time.
extracting event logs . in order to obtain event logs, researches propose a number
of techniques and tools. a popular tool is xesame10, which is used to convert databases
into xes event logs. [13] conceptualizes a database view over event data based on the
idea that events leave footprints by changing the underlying database, which are cap-
tured by redo logs of database systems. triggered by this idea, [5] proposes a method to
extract xes logs from databases by identifying a speciﬁc trace id pattern. [3] proposes
an approach to ﬂexibly extract xes event logs from relational databases, by leveraging
the ontology-based data access paradigm and [2] provides a tool ( onprom ) to extract
event logs from legacy data based on an ontology. in order to obtain logs from non-
process-aware information systems, [11] correlates events into process instances using
similarity of their attributes. [7] provides an overview of the decisions that impact the
quality of the event logs constructed from database data. [6] proposes an analysis sys-
tem which allows users to deﬁne events, resources and their inter-relations to extract
logs from sap transactions. [12] addresses merging logs produced by disintegrated
systems that cover parts of the same process by choosing a “main” process. artifact-
centric approaches [10, 9] try to extract artifacts (i.e., business entities) and address the
possibility of many-to-many relationships between artifacts. compared with the exist-
ing approaches, our approach outputs object-centric logs, i.e., xoc logs, rather than
process-centric logs, i.e., xes logs. the main advantage of object-centric logs is the
new kinds of analyses that they enable. data-aware process model discovery [8], and
new conformance checking techniques [14] that exploit data relations are examples of
approaches directly applicable to xoc logs. another important contribution is that our
approach supports the abstraction from low level database events (like the ones obtained
in [5]) to high level events (e.g., from the original information system).
6 conclusion
in this paper we proposed an approach to extract event logs from object-centric data
(i.e., database tables), using the extensible object-centric (xoc) log format. the xoc
format provides a process mining view on databases. compared with existing log for-
mats, such as xes, it has the following advantages:
– by removing the case notion and correlating events with objects, xoc logs can per-
fectly deal with one-to-many and many-to-many relations, avoiding convergence
and divergence problems and displaying interactions between different instances.
– an object in xoc logs contains as much information as its corresponding record in
the database. by extending the data perspective, xoc logs retain the data quality.
10http://www.processmining.org/xesame/startextracting object-centric event logs to support process mining on databases 15
– the object model of an event represents a snapshot of the database just after the
event occurrence. based on this idea, the log provides a view of the evolution of the
database, along with the operations which triggered changes in the database.
besides, xoc logs serve as a starting point for a new line of future techniques.
based on experiments implemented on the generated xoc logs, it is possible to dis-
cover ocbc models (cf. figure 5) to describe the underlying process in an object-
centric manner [8]. additionally, taking a xoc log and an ocbc model as input,
many deviations which cannot be detected by existing approaches, can be revealed by
new conformance checking techniques [14]. moreover, prediction of future events and
objects is also enabled according to the constraints indicated by the discovered ocbc
model. note that, the ocbc discovery, conformance checking and prediction are just
examples of potential applications of xoc logs. it is possible to propose more tech-
niques based on xoc logs, e.g., discovering other types of data-aware process models.
references
1. ieee standard for extensible event stream (xes) for achieving interoperability in event
logs and event streams. ieee std. 1849-2016 , pages i–48, 2016.
2. d. calvanese, t.e. kalayci, m. montali, and s. tinella. ontology-based data access for
extracting event logs from legacy data: the onprom tooland methodology. in bis 2017 ,
pages 220–236. springer, 2017.
3. d. calvanese, m. montali, a. syamsiyah, and w.m.p. van der aalst. ontology-driven ex-
traction of event logs from relational databases. in bpm 2015 workshops , pages 140–153.
springer, 2015.
4. e. gonz ´alez l ´opez de murillas, h.a. reijers, and w.m.p. van der aalst. connecting
databases with process mining: a meta model and toolset. in international workshop
on business process modeling, development and support , pages 231–249. springer, 2016.
5. e. gonz ´alez l ´opez de murillas, w.m.p. van der aalst, and h.a. reijers. process mining
on databases: unearthing historical data from redo logs. in international conference on
business process management , pages 367–385. springer, 2015.
6. j.e. ingvaldsen and j.a. gulla. preprocessing support for large scale process mining of
sap transactions. in bpm 2007 workshops , pages 30–41. springer, 2007.
7. m. jans and p. soffer. from relational database to event log: decisions with quality
impact. in international workshop on quality data for process analytics . springer, 2017.
8. g. li, r.m. de carvalho, and w.m.p. van der aalst. automatic discovery of object-centric
behavioral constraint models. in bis 2017 , pages 43–58. springer, 2017.
9. x. lu, m. nagelkerke, d. van de wiel, and d. fahland. discovering interacting artifacts
from erp systems. ieee transactions on services computing , 8(6):861–873, 2015.
10. a. nigam and n.s. caswell. business artifacts: an approach to operational speciﬁcation.
ibm systems journal , 42(3):428–445, 2003.
11. r. prez-castillo and et al. assessing event correlation in non-process-aware information
systems. software & systems modeling , 13(3):1117–1139, 2014.
12. l. raichelson and p. soffer. merging event logs with many to many relationships. in bpm
2014 workshops , pages 330–341. springer, 2014.
13. w.m.p. van der aalst. extracting event data from databases to unleash process mining. in
bpm-driving innovation in a digital world , pages 105–128. springer, 2015.
14. w.m.p. van der aalst, g. li, and m. montali. object-centric behavioral con-
straints. corr technical report, arxiv.org e-print archive, 2017. available at
https://arxiv.org/abs/1703.05740.