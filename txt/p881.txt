computing manuscript no.
(will be inserted by the editor)
revising history for cost-informed process
improvement
w. z. low s. k. l. m. vanden broucke 
m. t. wynn a. h. m. ter hofstede 
j. de weerdt w. m. p. van der aalst
received: date / accepted: date
abstract organisations are constantly seeking new ways to improve oper-
ational eciencies. this study investigates a novel way to identify potential
eciency gains in business operations by observing how they were carried
out in the past and then exploring better ways of executing them by taking
into account trade-os between time, cost and resource utilisation. this paper
demonstrates how these trade-os can be incorporated in the assessment of
alternative process execution scenarios by making use of a cost environment. a
number of optimisation techniques are proposed to explore and assess alterna-
tive execution scenarios. the objective function is represented by a cost struc-
ture that captures dierent process dimensions. an experimental evaluation is
conducted to analyse the performance and scalability of the optimisation tech-
niques: integer linear programming (ilp), hill climbing, tabu search, and our
earlier proposed hybrid genetic algorithm approach. the ndings demonstrate
that the hybrid genetic algorithm is scalable and performs better compared to
other techniques. moreover, we argue that the use of ilp is unrealistic in this
setup and cannot handle complex cost functions such as the ones we propose.
finally, we show how cost-related insights can be gained from improved execu-
tion scenarios and how these can be utilised to put forward recommendations
for reducing process-related cost and overhead within organisations.
keywords business process analysis business process improvement 
process miningoptimisationcost-informedgenetic algorithm
mathematics subject classication (2000) 68u0168u35
w. z. lowm. t. wynna. h. m. ter hofstede
queensland university of technology (qut), brisbane, australia
e-mail: w4.low@qut.edu.au
s. k. l. m. vanden broucke j. de weerdt
ku leuven, belgium
w. m. p. van der aalst
technische universiteit eindhoven (tu/e), the netherlands2
1 introduction
within the eld of business process management, the concept of business pro-
cess redesign and improvement is highly relevant to researchers and practi-
tioners. business process improvement is concerned with identifying process
redesign opportunities bearing in mind the potential impact that these re-
design actions may have on dierent dimensions such as time, cost, quality
and exibility [14]. approaches ranging from six sigma [19], lean think-
ing [34], and kaizen [16], to value-based management (vbm) [15], economic
value added (eva) [21], and value driver trees [20], are constantly being em-
ployed by organisations to conduct business process improvement and redesign
activities. process mining facilitates the identication of improvement oppor-
tunities by providing techniques to discover, monitor, and improve processes
by extracting knowledge from business process histories [27]. by obtaining de-
tailed insights into how business operations were carried out in the past, it
is possible to explore whether these same operations can be performed better
(for example, can process instances be completed faster? can operational cost
be reduced? can the quality of the outcomes be improved?).
business processes are often evaluated using the devil's quadrangle, where
time, cost, quality, and exibility are considered as improvement dimensions [3].
hence, business process redesign and improvement activities are often thought
to have an overlapping interest with operations research, as operations research
is interested in maximising (prot, productivity, or utilisation) or minimising
(cost or risk) objectives of real-world problems [33]. within an organisation,
there may be trade-os between these dimensions, making it impossible to
maximise all four dimensions [3]. it is then up to organisations to determine
which dimension(s) should be the focus of business process redesign and im-
provement, with (either positive or negative) consequences on other dimen-
sion(s) of the quadrangle. various means to gain insights from the time and
resource perspectives have been looked into [11]. cost reduction has also been
the objective of several investigations [22,37]. however, there is a lack of multi-
objective business process improvement initiatives that take into account dif-
ferent execution costs and their respective trade-os.
this paper proposes a cost-informed technique to intelligently search for
alternative business process execution scenarios with the aim of \improving
the history", taking into account trade-os between time, cost, and resource
utilisation. the main objectives of this work are 1) to discover execution sce-
narios that are cheaper (better) than the original (baseline) scenario to gain
insights for future redesign activities, 2) to propose a generic, adaptable cost
structure, and 3) to evaluate the performance and scalability of the proposed
optimisation techniques. the approach of this research is inspired by the de-
sign science research methodology, where the emphasis is placed on design
and development of artefacts to evaluate and improve their functionality [10].
the starting point of our cost-informed process improvement approach is an
event log that contains a detailed record of business operations over a certain
period. a number of key characteristics of the process are kept the same (such3
as the activities performed and their durations, and the arrival times of pro-
cess instances) while other elements within the log (resource allocations and
start times of activities) are adjusted to explore dierent execution scenarios.
by making use of a generic and adaptable cost structure, the cost of various
execution scenarios can be computed and compared.
the contribution of this paper is fourfold. one, we advocate a cost-informed
process improvement approach that splits the event log into two parts (xed
and variable parts) and search for alternative execution scenarios by perturb-
ing the variable part. two, a cost structure is introduced to cater for dierent
cost trade-os. three, several optimisation techniques have been introduced
and formalised as an attempt to solve the optimisation problem. optimisation
strategies were dened to explore cost-optimal execution scenarios that take
into account trade-os from multiple process dimensions. finally, an experi-
mental evaluation is carried out to assess the performance and scalability of
the proposed techniques in facilitating the exploration of dierent execution
scenarios. this paper extends our previous work [13] in some areas:
{in addition to the proposed hybrid genetic algorithm, three additional opti-
misation techniques are investigated, which are integer linear programming
(ilp), hill climbing, and tabu search.
{the fundamentals (event log, resource utilisations, and many more) and
the cost structure used in our previous work [13] are formalised.
{the concept of working hours is introduced and formalised, leading to a
more realistic involvement of resources.
{a more complex motivating example, inspired by a real-world business
process in the insurance domain, is presented.
{a new set of experiments is performed, comparing the performance and
scalability of the proposed optimisation techniques against our hybrid ge-
netic algorithm [13].
the remainder of this paper is organised as follows. related work is re-
viewed and discussed in section 2. in section 3, a cost-informed process im-
provement approach is proposed and illustrated through a motivating example.
next, the proposed optimisation techniques are discussed in section 4. sec-
tion 5 discusses the experimental results and the limitations. lastly, section 6
concludes this paper and states potential future work.
2 related work
the research agenda on cost-aware business process management [36] advo-
cated for the full integration of a cost perspective in all phases of the business
process management life cycle, enabling the management of business process
operation costs in a structured manner. vom brocke et al. [31] proposed an
information model to link the aris accounting structure with event-driven
process chains (epcs) during the process design stage. a process accounting
model (pam) was proposed to integrate and structure both accounting and4
process data to support the design, execution, and control of business pro-
cesses [23], in line with the push for cost perspective integration into business
process management lifecycle phases. in our earlier work [35], a conceptual
data model for cost model was designed, informed by requirements gathered
from domain experts and a literature study of costing techniques such as
activity-based costing (abc), time-driven activity-based costing (tdabc),
and resource consumption accounting (rca). these works aim to provide
organisations with better cost insights and cost control over their business
processes, potentially reducing the cost of their operations.
operations research encompasses a wide range of problem-solving tech-
niques to enhance both decision-making ability and eciency. these tech-
niques include, but are not limited to, integer linear programming (ilp) [18],
hill climbing [1], tabu search [7], simulated annealing [4] and genetic algo-
rithms [8]. each technique has a dierent approach towards a given optimi-
sation problem, where it depends on aspects such as how the search space is
explored and how the accumulated search experience is exploited [2]. table 1
compares a number of optimisation techniques based on features that charac-
terise the two aspects mentioned above. in this work, a detailed investigation
of four optimisation techniques, namely, ilp, hill climbing, tabu search, and
(hybrid) genetic algorithms is conducted. ilp is chosen due to its ability to
provide a good and quick solution for complex optimisation problems [18]. a
heuristic technique (hill climbing) is also considered for its speed and scala-
bility when a problem has many solutions [1]. tabu search is selected due to
its relatively fast speed and its avoidance of retracing its previous steps [7].
finally, a genetic algorithm guided by a set of heuristics is being considered for
its robust performance and global search properties [8]. in comparison, slow
computation of simulated annealing [4], ant colony's uncertainty in conver-
gence time [5], as well as particle swarm's inability to work out the problems
of scattering and optimisation [6], are among the reasons why these techniques
did not become our rst choice of investigation.
scheduling problems are among the key problems in operations research.
these problems emphasise on the optimisation of resource allocation and
utilisation. some well-known scheduling problems include shop scheduling
problems [12] and resource-constrained (multi-) project scheduling problems
(rc(m)psp) [9]. scheduling problems are similar to business process optimisa-
tion problems, as both aims to optimise the allocation of resources to tasks [26].
however, scheduling optimisation solutions are developed to solve targeted
problems, and hence cannot easily be applied to other elds. as pointed out
by verigidis et al. [28], business processes involve additional components such
as business rules and decisions that are hard to express mathematically, and
may not be covered by scheduling problems.
despite this, a number of studies attempted to apply scheduling techniques
to optimise business processes in terms of time, cost, and resource utilisa-
tion. within the area of optimising business process modelling and design,
verigidis et al. [30] reviewed the topics of business process modelling, analysis,
and optimisation. wang et al. [32] developed an evolutionary, multi-objective5
table 1: features and the characteristics of common optimisation techniques
(adapted from [2]).
hhhhhhhhhhhhfeaturestechniques hill tabu genetic simulated ant particle
climbing [1] search [7] algorithm [8] annealing [4] colony [5] swarm [6]
trajectory search :p:p: :
population-based : :p:p p
memory usage 9p9 :p p
multiple neighbourhoodp: 9 : : 9p= feature is present; 9= feature is partially present; := feature is not present.
*this classication only serves as an indication of the techniques' characteristics and does
not apply to all implementations.
framework as a rst attempt to optimise business process designs. their work
tackles constrained process optimisation problems, emphasising on reducing
the number of infeasible solutions generated. an evolutionary multi-objective
optimisation algorithm to generate a series of diverse optimised business pro-
cess designs was also proposed [29]. tiwari et al. [25] proposed an optimisation
framework that generates a number of dierent optimised business process de-
signs, and they evaluated the optimisation results through an experiment.
there are other works that looked into optimisation from a business process
execution perspective. yu and buyya [40] investigated the optimisation prob-
lem of minimising the cost and execution time of workow scheduling. this
work only minimises either one of these optimisation objectives, but not both.
xu et al. [37] investigated the optimisation of ow time and cost of business
processes separately and improved the process structure according to resource
allocation requirements. dierent heuristic scheduling strategies that take into
account resource availability constraints such as resource slots, resource ca-
pabilities, process task dependencies, and instance deadlines have also been
studied [38]. nevertheless, the execution cost of the business process is not
considered in this study. table 2 provides a summary of authors, techniques,
foci, and objectives of the related works. while most of the business process
execution-related studies discussed above deal with the minimisation of cost,
the minimisation of execution time, and complex resource behaviour, none of
them propose an approach that takes all of these into account. in contrast to
the works discussed above, this paper:
{investigates how the execution of a business process can be improved;
{identies cost-optimal execution scenarios by perturbing the process his-
tory (event log) and learn from it;
{introduces working hours for resources to enable a more accurate cost
measurement; and
{incorporates dierent cost-related dimensions into a cost structure (for
example, activity-based cost, time-based cost, and resource utilisation),
which allows the use of more sensible cost-based trade-os as the objective
function for the optimisation techniques.6
table 2: a summary of the related works.
authorsoptimisationfoci objective(s)technique(s)
wang et al. [32] genetic algorithm process designreduce the number of infeasible solutions generated by
tailoring operators used by a genetic algorithm.
verigidis andgenetic algorithm process designgenerate diverse, optimised business process designs for
tiwari [29] the same process requirements.
tiwari et al. [25]genetic algorithm &process designgenerate alternative optimised process designs and
particle swarm performed an experimental evaluation.
yu and heuristics &process executionscheduling workow applications by either minimising
buyya [40] genetic algorithm cost or execution time while satisfying constraints.
xu et al. [37] heuristicsprocess designoptimise resource allocation based on cost
& executionand execution time, and allow process structure
to adapt the optimised resource allocation.
xu et al. [38] heuristics process executionallocate resources based on a set of heuristic rules during
build time to maximise the success rate of scheduling.
3 cost-informed log perturbation
the motivation for this research is to identify a more cost-ecient execution
scenario. the notion of cost is applied towards a number of eciency mea-
sures. for example, eciency measures such as service level agreement and
resource allocation rules (for example, roles, skills, etc.) are often introduced
by organisations to ensure adequate provision of services and appropriate al-
location of resources. hence, desirable desirable utilisation rates are promoted
(see denition 6 in subsection 3.1), and unsuitable resources and service level
agreement violations are discouraged (see denition 7 in subsection 3.1). al-
ternative execution scenarios are explored where a scenario with a lower cost
represents a more ecient scenario.
fig. 1: overview of the cost-informed process improvement approach.
fig. 1 illustrates the proposed approach for the generation of cost-informed
alternative scenarios. to explore dierent execution scenarios, the identica-
tion and separation of the xed part and the variable part of a typical event
log is the rst step in this approach. an abstract event log (a detailed expla-
nation follows below, see denition 2) contains the xed part of an event log,
whereas a binding (detailed explanation in denition 3) contains the variable
part of an event log. then, by using a number of optimisation techniques,
dierent execution scenarios are explored by manipulating the variable part of
the event log, in this case, the binding. the dened cost structure is used as an7
objective function to determine the tness of the execution scenarios in terms
of process-related cost. note that the cost structure can be further cong-
ured and customised by organisations, taking into consideration cost-informed
trade-os between multiple aspects such as process instance durations, activ-
ity invocation, and resource allocation and utilisation. the abstract event log
and binding combination result in an alternative execution scenario. the most
cost-ecient alternative execution scenarios are then identied and analysed.
in this section, the fundamentals and the corresponding formalisation are
discussed, followed by a motivating example.
3.1 fundamentals
denition 1 (event log) an event log is a data store that records poten-
tially vast amounts of event-related information [24,27]. an event log consists
of a collection of process instances ( cases ). for each case, there is a sequence
ofactivities (commonly referred to as \work items"), where an activity is an
instance of a task. each activity has a start time and an end time , aresource
that is executing the activity, as well as any additional properties that are
related to the activity.
table 3: a fragment of a car insurance claim event log in chronological order.
case id activity start time end time resource property (damage type) ...
1 car 10/06/13 09:31:00 10/06/13 09:39:00 a5 windscreen ...
1 rar 10/06/13 09:42:00 10/06/13 10:00:00 is2 - ...
2 car 10/06/13 09:45:00 10/06/13 09:50:00 a1 theft ...
2 rar 10/06/13 09:55:00 10/06/13 10:10:00 is1 - ...
... ... ... ... ... ... ...
table 3 illustrates an event log fragment of the example car insurance claim
process that is used as the motivating example. as we are seeking improve-
ments concerning execution time and resource allocation, the historical event
attributes that inuence timing and resource allocation are considered as the
variable part (i.e. the binding ). all other historical attributes, such as cases
and activities, are kept xed (i.e. the abstract event log ). this includes the
properties of cases and activities, as they do not aect the optimisation of
process executions, hence are being kept the same (invariable).
denition 2 (abstract event log) letts= i r be the set of possible
timestamps, dur = i r+
1the set of durations, and valthe set of all possible
property values (records, tables, and many more). l= (c;a;t;case;task;art;
dur;prop;) is an abstract event log where:
{cis a set of cases,
{ais a set of activities (commonly referred to as \work items"),
{tis a set of tasks,8
{the setsc,a, andtare pairwise disjoint and nite,
{case2a!c is a surjective function mapping activities to cases,
{task2a!t is a surjective function mapping activities to tasks,
{art2c! tsis a function specifying the arrival time of cases,
{dur2a! dur is a function mapping activities to durations,
{prop2(c[a )!valis a function mapping cases and activities to their
invariable properties,
{aa denes a partial order on activities within cases:
{8a1;a22aa1a2)case(a1) =case(a2) (activities of dierent cases
are unordered),
{8a1;a22aa1a2)a26a1(asymmetric), and
{8a1;a2;a32a(a1a2^a2a3))a1a3(transitive).
{case 12c!p (a) is dened such that for c2c:
{case 1(c) =fa2aj case(a) =cg.
{task 12t !p (a) is dened such that for t2t:
{task 1(t) =fa2aj task(a) =tg.
denition 3 (binding, concrete event log) letl= (c;a;t;case;task;
art;dur;prop;) be an abstract event log. b= (r;res;st;et;wh) is a bind-
ing for lwhere:
{ris a set of resources,
{res2a!r is a surjective function mapping each activity onto a resource,
{st2a! tsassigns a start time to each activity and et2a! ts
assigns an end time to each activity such that:
{8a2ast(a)art(case(a)) (activities must start on or after the arrival
time of the case they belong to),
{8a2ast(a)<et(a) (the start time of an activity must be earlier than
its end time), and
{8a1;a22aa1a2)et(a1)st(a2) (the end of an activity must not
come after the start of an activity that it precedes).
{wh :r!p (tsts) is a set of timestamp pairs denoting the valid
working hours of resources (where resources are allowed to execute activi-
ties), such that:
{for (t;t0)2wh(r),stw2wh!tsdenotes the starting time of the
working hour, i.e. stw(t;t0) =t, and etw2wh!tsdenotes the end
time of the working hour, i.e. etw(t;t0) =t0,
{for all r2r, and all p1;p22wh(r),p1=p2, orstw(p2)>etw(p1),
orstw(p1)>etw(p2),
{furthermore, for all p2wh(r) :stw(p)<etw(p).
we adapt our activity duration mapping function, dur, to take working hours
into account:
durwh
(l;b)(a) =x
p2wh(res(a))dur(st(a);et(a);stw(p);etw(p));
where
dur(st(a);et(a);stw(p);etw(p)) =9
8
>>>>>><
>>>>>>:0 if et(a)stw(p)_etw(p)st(a)
et(a) st(a) if st(a)stw(p)^et(a)<etw(p)
etw(p) st(a) if etw(p)et(a)^stw(p)<st(a)^etw(p)>st(a)
et(a) stw(p) if stw(p)st(a)^etw(p)>et(a)^stw(p)<et(a)
etw(p) stw(p) if stw(p)>st(a)^etw(p)<et(a)
the working hours of a resource are taken into account when the duration of
an activity is calculated. thus, the activity duration remains the same across
dierent bindings, and the time gaps where resources are not working do not
inuence the duration of an activity.
the combination of landb, (l; b) is a concrete event log, where only
theres;st, and etare changed.randwh will remain the same. a concrete
event log represents an (alternative) execution scenario. table 4 illustrates the
abstract event log and the binding that corresponds to the event log in table 3.
by changing the information in the bindings, alternative execution scenarios
(new concrete event logs) can be produced.
table 4: an abstract event log (top) and binding (bottom) that correspond to
the car insurance claim event log in table 3.
abstract event log
idcaseactivitypropertydurationpreceding succeeding
id (damage type) activity activity
341 1 car windscreen 00:08:00 fg f rarg
342 1 rar - 00:18:00 fcarg f ncug
343 2 car theft 00:05:00 fg f rarg
344 2 rar - 00:15:00 fcarg f ncug
... ... ... ... ... ... ...
binding
id start time complete time resource
341 10/06/13 09:31:00 10/06/13 09:39:00 a5
342 10/06/13 09:42:00 10/06/13 10:00:00 is2
343 10/06/13 09:45:00 10/06/13 09:50:00 a1
344 10/06/13 09:55:00 10/06/13 10:10:00 is1
... ... ... ...
denition 4 (resource eligibility) let ( l; b) be a concrete event log
withl= (c;a;t;case;task;art;dur;prop;) and b= (r;res;st;et;wh).
can2t !p (r) returns the set of resources that are eligible to perform a
task (can perform), such that if can(t) =r, any resource in rcan perform
task t.
organisations can dene eligibility of resources for task execution through
the use of roles and rules (e.g. required skills). furthermore, the availability of
resources can also be explicitly captured (e.g. by specifying working hours).
denition 5 (safe binding) letl= (c;a;t;case;task;art;dur;prop;
) be an abstract event log, and canbe the set of resource eligibility. b=
(r;res;st;et;wh) is a safe binding for li:10
{8r2r8 t2ts:jactres
(l;b)(r; t)j1 (a resource works on at most one
activity at any point in time),
{8a2ares(a)2can(task(a)) (a resource involved in the execution of an
activity must be eligible to perform it), and
{8a2a9p1;p22tsts[(p1;p22wh(res(a)))^(stw(p1)st(a)etw(p1))^
(stw(p2)et(a)etw(p2))] (the execution of activities must be within
the dened time blocks where resources are allowed to execute activities).
a binding is deemed unsafe if 1) a resource works on multiple activities at
any point in time, 2) an activity is not performed by an eligible resource (see
denition 4), or 3) an activity is executed outside the dened working hours
of its allocated resource. a violation is a breach of any of the rules above. an
unsafe binding contains one or more violations, and a violation cost function
is used to penalise these unsafe bindings.
denition 6 (utilisation) let ( l; b) be a concrete event log with l=
(c;a;t;case;task;art;dur;prop;) and b= (r;res;st;et;wh). let r2r,
t2tsandh2durnf0g, then the utilisation of resource rat time tusing a
horizon his given by:
utilh
(l;b)(r; t) =p
a2a;res(a)=r;
st(a)<t^et(a)>(t h)durwh
(l;bh)(a)
p
p2wh(r)dur(t h;t;stw(p);etw(p));
where bh= (r;res;st0;et0;wh), and
st0(a) =(
st(a) if st(a)t h^st(a)< t
t hifst(a)< t h^et(a)> t h;
and
et0(a) =(
et(a) if et(a)t h^et(a)t
t hifet(a)> t^st(a)> t:
resource utilisation is the fraction of time a resource is busy (executing
activities) in a specied time frame. the horizon species the time frame that
is used to compute the resources' utilisation rates. if bis a safe binding for
l, then 0utilh
(l;b)(r; t)1 for any resource r, time t, and for any positive
time horizon h > 0.util = [0;1] is the set of possible utilisations. if a safe
binding is produced, the utilisation of any resource will be between zero and
one within a positive time horizon.
denition 7 (cost structure) letrbe a set of resources, tbe a set of
tasks, and costs = i r+
0a set of costs. cs= (costscase;costsact;costsres) is a
cost structure over randtwhere:
{costscase2(durval)!costs such that costscase(d; v) are the costs of
a case having duration d2dur and invariable properties v2val,11
{costsact2(tr durval)!costs such that costsact(t; rs; d; v ) are
the costs of executing task t2tby resources rsr, having duration
d2dur, and invariable properties v2val, and
{costsres2(rdurutil)!costs such that costsres(r; d; u ) are the costs
of using resource r2r ford2dur time units and having a utilisation of
u2util.
a cost structure represents a generic data model that stores a set of cost
functions for process-related cost computations (see [13] for details). organi-
sations can not only dene functions to calculate the cost of a case, an activity,
and a resource, but also functions to enforce business rules such as service level
agreements and resource eligibility. to compute the total cost of a concrete
event log, the cost of cases, activities, and resources are aggregated. shorter
case durations that do not breach the service level agreement, optimal re-
source utilisation, and appropriate resource allocation are desired as the goal
is to achieve a reduction in overall execution cost. this cost structure is used as
a basis of the objective function within the proposed optimisation techniques.
3.2 motivating example
car insurance claim process (realistic_shrink)
create
assessment
reportreport approved?
notify
customer
advice vehicle
collectionpickup preferred?
arrange
vehicle
deliveryarrange
pickup taxireview and
provide
vehicle drop-
off advice
vehicle drivable?
arrange tow
truckstartlodge
insurance
quote
requestinsurance number
authenticated?
collect vehiclereview
insurance
advicelodge claim?
drop-off
vehicle at
body shopend end
review and
authorize
repairreview
assessment
report
compile
write-off
report
endreceive
vehicle at
body shopassess
damagevehicle repairable?
estimate
repair cost
repair vehiclerepair cost exceed
insurance cover?
send invoiceapprove
vehicle write-
off
endnoyesno
yesyes
no
yesnonoyes
yesnono
yes
fig. 2: a bpmn model illustrating the car insurance claim process.
fig. 2 illustrates a car insurance claim process that was used as a motivat-
ing example in this work. the process was inspired by aami's car insurance
claim process1, where aami is an insurance provider in australia. the process
starts o within the insurance company when a customer lodges an insurance
quote request for his damaged car. if the customer's insurance number is pos-
itively authenticated, an insurance adjuster will create an assessment report
1http://www.aami.com.au/car-insurance/claimsprocess12
based on the quote description. an insurance supervisor will then review the
assessment report. if the report is approved, the insurance adjuster will no-
tify the customer. if the report is rejected, the insurance adjuster will need to
recreate the report. the customer will then decide whether to lodge a claim by
reviewing the insurance advice. should the customer lodge a claim, a service
coordinator will review and provide advice on dropping-o the vehicle at the
body shop. if the vehicle is drivable, the customer will drop-o the vehicle at
the body shop. if not, the service coordinator will arrange a tow truck to
collect the vehicle on behalf of the customer.
within the body shop, a foreman receives the damaged vehicle and as-
sesses the damage. if the damage is not repairable, a body shop supervisor
will approve the vehicle for write-o, and a write-o specialist will compile a
write-o report afterwards. if the damage is repairable, the foreman will esti-
mate the repair cost and provide feedback to the insurance supervisor. if the
estimation exceeds the insurance cover, the estimation will be rejected, and
the foreman will need to readjust the estimated repair cost. otherwise, the
foreman will repair the vehicle accordingly. after the repair is completed, the
body shop supervisor will send an invoice to the insurance company while
the service coordinator advises the customer for vehicle collection. the vehi-
cle can either be delivered to the customer, or a pickup taxi can be arranged
to transport the customer to the body shop for vehicle pick-up. the process
is complete when the customer collects the vehicle.
the process was translated into a petri net [17] and was simulated using
cpn tools2to obtain an event log with 500 cases. the process spans across
two organisational groups, which consists of 16 tasks, 6 roles, and 29 resources.
each task can only be executed by a certain role(s) (group of resources). each
resource group (role) is responsible for a xed set of tasks. realistic working
hours were also introduced in the process simulation, where all resources are
only allowed to work between 9 am and 5 pm.
table 5 illustrates an excerpt of the dened cost functions elaborated below:
{the cost of a case is calculated based on its case properties and its duration.
an additional service level agreement has been specied, in which cases
that ran overtime are penalised.
{the cost of an activity is calculated based on that activity's resource allo-
cation. a higher cost is incurred if an inappropriate/less-desired resource
executes that activity.
{resource costs are calculated based on resource utilisation. the per minute
cost rate is determined by the resource attributes (for example, skills and
roles) and utilisation for the specied time horizon. an assumption for this
example is that the desired resource utilisation is 0.8. a stepped cost rate,
where a resource's utilisation between 0.75 and 0.85 within the time horizon
is cheapest is used. on the other hand, resource under- or over-utilisation
results in a higher cost rate.
2http://cpntools.org/13
table 5: example of cost functions dened in the cost structure.
cost type property value cost rate
casedamage type & case duration windscreen $40 per hour
case duration [service level agreement breach]$1500 if it takes more than 5 days, and
$500 for every subsequent day after that
activityactivity & resource car & a1 $100 per invocation
activity & resource [over-qualied resources] $1000 per invocation
resourceresource utilisation between 0 and 0.15 (under-utilised) $45 per minute
resource utilisation between 0.75 and 0.85 (optimum utilisation) $1 per minute
resource utilisation higher than 0.9 (over-utilised) $20 per minute
4 optimisation techniques
this section discusses the optimisation techniques proposed to identify less
costly execution scenarios by exploring dierent possible bindings for a given
event log. the event log and the cost structure dened in section 3 are used as
the problem denition and the objective function of our proposed optimisation
techniques respectively. in our previous work, we looked into a hybrid genetic
algorithm to nd a cost-optimised event log [13]. extending from that, we aim
to compare our approach against other potential optimisation techniques, as
well as make optimisation more realistic by taking working hours into account.
hence, we look into ilp as our rst approach towards cost optimisation. how-
ever, a number of drawbacks were encountered, leading us towards the use of
heuristic methods as a next logical step. we re-run the experiments and com-
pare methods such as tabu search and hill climbing against the hybrid genetic
algorithm-based approach that we have proposed in our previous paper [13].
the details on the optimisation techniques, the diculties faced, and further
analyses are discussed in the remainder of this section.
4.1 ilp
a subclass of the integer programming problems, integer linear programming
(ilp) problems are a mathematical description of an optimisation problem in
which some or all the constraints and the objective functions have to be inte-
gers [18] and expressed in linear form. as ilp can take into account dierent
real-life aspects, it was chosen as the rst approach because it is often a good
solution for complex problems and allows the denition of problem structure
formally.
as only the resource allocations and activity start times can be changed,
the key aspect of the ilp formalisation is that the resource assignment and
start time assignment are represented as a binary \hypercube", containing a
binary value for each (caseno, actno, resource, time) combination, denoting
a particular resource and starting time for each activity in every case.
we propose an ilp formalisation of our problem as follows. given:
{an ordered list of case identiers: c=fc1; c2; : : : ; cjcjg.
{an ordered list of activities per case: a=faiji= 1; : : : ;jcjgwith: ai=
fai;1; : : : ; a i;jaijg.14
{an ordered list of resources: r=fr1; : : : ; rjrjg.
{an ordered list of time slots: t=ft1; : : : ; tjtjg.
{arr2c!t: the arrival time of a case.
{dur2a!n: the duration of an activity.
{forbactres2a!p(r): the set of resources which may not be assigned to
an activity.
{forbacttime2a!p (t): the set of time slots where an activity may not
be scheduled.
{forbactres2r!p(t): the set of time slots where a resource may not be
scheduled.
{cost dur2n!r,cost start2n!r,cost res2ar!r,cost dur2
r!r: functions denoting duration, starting (delay), resource usage and
resource duration costs respectively.
with variables:
{xi;j;r;t2f0;1gwith: solution variables representing a binary hypercube
denoting whether activity ai;jhas been scheduled to start at time ttusing
resource rr.
{si;j2t: integer helper variables denoting the start time of activity ai;j.
{ei;j2t: integer helper variables denoting the end time of activity ai;j.
{ur2n: integer helper variable denoting utilisation value of resource rr.
we can formulate a candidate objective function as follows:
minx
ci2ccost dur(ei;jaij si;1)+ (1)
x
ci2ccost start(si;1)+ (2)
x
ai;j2a; r r2r; t t2tcost res(ai;j)xi;j;r;t+ (3)
x
rr2rcost util(rr)ur (4)
where (1) is used to calculate a cost associated to the duration of each
case, depending on the scheduled starting times of the rst and last activity in
each case. (2) indicating the starting cost (postponing the start of a case leads
to higher costs). (3) indicating the cost of assigning a particular resource to a
particular activity, and (4) indicating the cost of utilisation, which is xed per
resource but multiplied by the urhelper variable to estimate the utilisation
rate of each resource. the constraints, then, were formalised as follows:
8ai;j2a:x
rr2r; t t2txi;j;r;t = 1 (1)15
8ai;j2a:x
rr2r; t t2t:t<arr (ci)xi;j;r;t = 0 (2)
8ai;j2a:j>1:ei;j 1 si;j0 (3)
8rr2r;tt2t:x
ai;j2ax
m2f0;:::;dur(ai;j) 1g:
t m>0^t mmax(t)xi;j;r;t m1 (4)
8ai;j2a:x
rr2forbactres(ai;j); tt2txi;j;r;t = 0 (5)
8ai;j2a:x
rr2r;
tt2forbacttime (ai;j)x
m2f0;:::;dur(ai;j) 1g:
t m>0^
t mmax(t)xi;j;r;t m= 0 (6)
8rr2r:x
ai;j2a;
tt2forbrestime (rr)x
m2f0;:::;dur(ai;j) 1g:
t m>0^
t mmax(t)xi;j;r;t m= 0 (7)
8rr2r:ur=x
ai;j2a; t t2tdur(ai;j)xi;j;r;t (8)
8ai;j2a:si;j=x
rr2r; t t2tt xi;j;r;t (9)
8ai;j2a:ei;j=x
rr2r; t t2t(t xi;j;r;t +dur(ai;j)) (10)
constraint (1) ensures that exactly one resource and start time is assigned
to each activity. (2) ensures that the start time of activities adheres to the
arrival time of cases. (3) ensures that the ordering of activities is adhered to. (4)
ensures that resources do not overlap in time. note that this constraint needs to
be checked over multiple time periods, as the xi;j;r;t variable only represents the
scheduled starting time for each activity. (5) allows for prohibiting resources
to be assigned to particular activities. (6) and (7) allow to constrain working
times for activities and resources respectively. (8), (9) and (10) are constraints
ensuring the assignment of the helper variables.
a number of remarks are relevant regarding the formalisation above. first,
note that the construction of the helper variables is optional and added for
clarity. that is, they can be immediately inserted into each expression whilst
retaining linearity. second, it is important to note that the utilisation expres-
sion as introduced before cannot be expressed in a linear form, and is thus
estimated here using an absolute integer variable. hence, the cost structure is
adapted to a heuristic utilisation cost computation (a xed cost per resource
invocation), where the number of time slots a resource is used (in total) was
counted and a cost is derived based on that. third, although we express our
decision variable with a four-dimensional subscript, it is also possible to ex-
press this as a three-dimensional variable, i.e. an activity identier, a resource
identier, and a time identier. fourth, due to the nature of integer linear
programming, time is discretised into a list of \time slots". resources are also16
expressed as a list, but can nevertheless still allow to assign groups of resources
to activities (with each possible subgroup then being captured in a separate
rritem). fifth, it is not possible to construct the problem by means of two
separate decision variables (for example, tactandract) with one representing
the assigned starting time and one representing the assigned resource, as this
would render it impossible to formulate the problem in linear form. the same
remark holds when expressing the assignment of time as a non-binary integer
(representing the index of the assigned time slot) instead of a binary vector.
although we have successfully applied the ilp formalisation introduced
above on small problems, this method becomes unusable on larger problems,
due to the exponentially growing variable size and complexity concerning input
size. additionally, as mentioned above, the resource utilisation calculation,
where the utilisation of a resource within a certain horizon is computed, cannot
be done linearly. due to these drawbacks, we explore other heuristic techniques
as an alternative to ilp below.
4.2 hill climbing
hill climbing is a local search mathematical optimisation technique that em-
ploys an iterative search that attempts to nd a better solution by incremen-
tally changing a single element of an arbitrary solution. hill climbing is the
rst choice after ilp because it is relatively easy to implement and is relatively
fast for problems that have many solutions. an initial random safe solution, in
this case, a random generation of a safe binding is chosen as a starting point.
by going through the neighbours, an objective function is used to evaluate
the neighbours, with cost minimisation as its goal. if the cost of a particular
neighbour is lower than the initial solution, the solution is replaced with the
corresponding neighbour. the search is repeated until the stop criteria have
been met, or no neighbours with lower cost, i.e. a local optimum has been
found.
we have customised the neighbourhood search function to increase its
speed and scalability. we rst applied an incremental search approach, where
a neighbour solution was produced for each activity, for each allowed time pe-
riod, and for each available resource. however, due to the high number of can-
didate neighbours generated in each iteration when applying this procedure,
we improved the scalability by sampling candidate neighbours for each activ-
ity. to further improve the speed and scalability of this method, we adapted
the approach to generate a xed number of nearby neighbours, that is, a global
sample over all possible activity, time, and resource possibilities. to generate
a neighbour (safe binding), an activity is rst picked randomly, for which the
time periods where the activity can start and the eligible resources are ob-
tained. a start time for that activity is chosen, as well as an eligible resource.
the chosen start time and resource are applied to generate a neighbour and
subsequently passed on to the hill climbing method for further analysis.17
either with or without sampling, the main disadvantage of the hill climbing
method is that it will not necessarily converge to a global minimum. given the
complexity of the proposed problem for this study, it is very likely that the
hill climbing method will result in a local minimum. hence, we investigated
another optimisation technique as a remedy to this drawback.
4.3 tabu search
tabu search is a metaheuristic search method that employs local search meth-
ods used for mathematical optimisation [7]. a distinguishing feature of tabu
search is the use of a \memory" construct, where recent searches are recorded
in a so-called tabu (forbidden) list for a set amount of iterations. tabu search
was investigated because it has a relatively fast execution time. also, the use
of a tabu list prevents the search from retracing its steps and reinvestigating
previous moves to try and avoid local minima.
tabu search also starts o from a single, random safe solution, in this case,
a random generation of a safe binding. based on the binding, a set of nearby
neighbours that are not in the tabu list is explored. the neighbourhood is
searched in a similar manner to the hill climbing's neighbourhood search. the
objective function is then used to evaluate the cost of the neighbours, where
cost minimisation is the ultimate goal. the current solution is replaced with
the neighbour solution with the lowest cost, and the tabu list is updated with
the recently explored solutions. the search is repeated and only terminated
when the stop criterion is met. to increase the speed and scalability of tabu
search, we perform a similar sampling procedure as described in the previous
subsection that only generates a xed amount of neighbours in each iteration.
due to the potential memory constraint that is dependent on the tabu list
size, we looked into a genetic algorithm-based optimisation as an alternative
approach to our problem.
4.4 hybrid genetic algorithm
we also developed a hybrid genetic algorithm to facilitate the construction and
exploration of the massive search space at hand in this context [13]. genetic
algorithms use the principles of evolution to guide the search. in this case,
special-purpose crossover and mutation operators are applied to a population
of bindings, which are subsequently evaluated according to reductions in cost.
a genetic algorithm-based approach was opted for because of its exibility
and adaptability, along with robust performance and global search character-
istics [30]. an additional heuristic approach, where there is a low chance of
generating a new random solution, was incorporated to minimise the chances
of the genetic algorithm converging into a local minimum. hence, a hybrid
genetic algorithm resulted from the addition of a heuristic operator.
reinforcing the previous arguments, the non-linear nature discourages the
use of lp or ilp techniques, while the high-dimensionality makes the use18
of a brute force or monte carlo-inspired approach impractical. furthermore,
due to the many local optima, traditional heuristic approaches (for example,
hill climbing) and simulated annealing are deemed less suitable as they tend
to be more prone to converge to such suboptimal solutions [39]. therefore,
it is argued that a hybrid genetic algorithm-based approach is the adequate
technique for our problem.
genetic operators are responsible for evolving a next generation of a popu-
lation (multiple solutions). to produce a new solution (individual), the opera-
tors are applied to a parent or a pair of parent solutions. a number of operators
have been developed for the hybrid genetic algorithm. they are designed in
such a way that unsafe bindings produced will be penalised heavily by the
objective function. this will encourage the generation of safe bindings, taking
into account resource availability, authorisation, and working hour restrictions.
the operators used in this work and their frequencies are as follows.
1.crossover . the crossover operator cross-breeds the properties (activity
start time and resource allocation) of a number of activities between two
bindings. a crossover point is picked randomly from the parent bindings'
list of activities, and a specied number of activity crossovers ( crossover
frequency: 1% of total activity count ) are applied, where the activities' start
times and resource allocations are swapped between two parent bindings. if
the crossover produces safe bindings, the safe bindings are kept and brought
forward to the next generation. if not, the bindings are discarded, and the
parent bindings are brought forward to the next generation instead.
2.time mutation . the time mutation operator changes the start times of
a number of activities within a binding individual. for a number of cases
(case frequency: poisson (100% of total case count)3), a number of activ-
ities ( activity frequency: discrete (0% to 100% of total activity count)4)
are selected to have their start times altered. a new start time is chosen
between the activity's possible minimum and maximum start times. the
chosen start time will be checked for potential violations of the activity
order and the resource allocation authorisation. if the mutation will result
in an unsafe binding, no mutation is performed. the activity's start time
is mutated if it does not result in violations.
3.resource mutation . the resource mutation operator swaps the resource
that is executing an activity. for a random number of cases ( case frequency:
poisson (10% of total case count)3), a random number of activities ( activity
frequency: discrete (0% to 100% of total activity count)4) are selected to
have their resource allocation mutated. a dierent resource is randomly
picked from the pool of eligible (allowed to execute the activity) and idle
(available) resources (refer to denition 4 in subsection 3.1) for mutation.
if there is no resource available, no mutation is performed.
3poisson ( mean ) = pick a random value from a poisson distribution with the stated
mean.
4discrete ( min tomax) = pick a random value from a discrete uniform distribution
between the stated minimum and maximum values.19
4.new heuristic binding . this operator introduces a new safe binding
into the population. although typically applied with a low probability
(heuristic frequency: 5% of total population count ), this operator reduces
the chance of the algorithm conning itself to a local optimum neighbour-
hood. for each case (randomly ordered), the earliest possible start time is
proposed for an activity, and the algorithm attempts to identify a resource
that is suitable (allowed to execute the activity) and available during the
activity's proposed execution time frame. if there is a suitable resource,
the activity is scheduled with the proposed start time and resource alloca-
tion. if no suitable resource is found, a new start time is proposed (based
on previously scheduled activities), and the resource allocation process is
repeated. this process is iterated until all activities have been scheduled.
this operator ensures the generation of a safe binding.
5 experimental setup and discussion
this section rst describes the experimental setup used to evaluate the ef-
fectiveness and eciency of dierent approaches, followed by a detailed dis-
cussion about the experimental results. two experiments are conducted using
two event logs, and the performance and scalability of the four optimisation
techniques are discussed and compared.
5.1 experiment setup
to evaluate the performance and scalability of the proposed optimisation tech-
niques, two event logs of the car insurance claim process were used. as the
goal of this study is to improve the business process within the organisation,
activities that are performed by customers were ltered out. after ltering,
the simulated event log contained 453 cases (this log is referred to as log a
from now on). the second event log (this log is referred to as log b from now
on) is a sliced version of log a, where only the initial 10% in terms of time
ordering of the log is taken into consideration. log b contained only 45 cases.
the experiments were executed over the period of one week5,6. to increase
the speed of the optimisation techniques, and to enable sensible objective
function calculation, the timestamps within the event log were discretised into
one-minute blocks. results from the previous experiment performed [13] in-
dicates that safe variants of the technique (operators that only explore safe
bindings) provided better results. hence, in this experiment, only safe bindings
are explored. apart from ilp, where its cost structure (objective function) is
linearised and estimated as described above, the cost structure used across
5qut's high performance computing (hpc) facility was used to run these experiments.
http://www.itservices.qut.edu.au/researchteaching/hpc/hw\_catalogue.jsp
6files can be obtained via http://yawlfoundation.org/cost/
logbasedcostanalysisandimprovement.html .20
dierent algorithms and dierent logs is the same. the objective functions
and parameters for the dierent algorithms are xed in consideration of the
search space and the experiment's feasibility. table 6 details the settings and
specications for each optimisation algorithms.
table 6: settings and specications for the optimisation algorithms.
optimisation objective functionadditional specicationstechnique description
ilpminimisation of duration, cost of
n/adelay, resource assignment and
resource utilisations, linearised
and estimated.
hill climbingfull cost structure applied to(i) 100000 neighbour generation per iteration.each population member.
tabu searchfull cost structure applied to (i) 100000 neighbour generation per iteration.
each population member. (ii) tabu size of 5000.
(i) population size of 50.
hybrid full cost structure applied to (ii) top 5% of total population count as elites.
genetic algorithm each population member. (iii) tournament selection strategy, 75%
probability that a tter individual will be selected.
5.2 result analysis and discussion
the goal of the experiments is to measure the performance of the proposed
optimisation techniques in terms of cost reduction over time. the performance
of ilp was rst experimented using log b. for this relatively small-sized log,
the experiment was unable to complete as it required more than 80gb of stack
memory to contain the problem structure. consequently, we did not proceed
to experiment with log a, and we conclude that utilising ilp for optimisation
is infeasible for real world usage. following that, two experiments using both
log a and log b were conducted over a one week period to compare the
performance and scalability of the remaining three techniques.
fig. 3 illustrates the cost reduction of log b achieved by the three op-
timisation techniques over a week. in this experiment, all three techniques
managed to discover cheaper alternative execution scenarios. the hill climb-
ing and tabu search techniques performed slightly better with a cost reduction
of over 13%. the hybrid genetic algorithm's performance fell slightly short of
that, with a 12.75% reduction in cost over time. although hill climbing and
tabu search have a higher cost reduction rate over time, the hybrid genetic
algorithm managed to gain a high reduction in a small time, reducing up to
12% within the rst 6 hours from when the experiment was initialised. how-
ever, the performance of the hybrid genetic algorithm plateaued after that. hill
climbing and tabu search reached 12% roughly 40 hours into the experiment,
and although slow, continually reduced the cost and surpassed the hybrid ge-
netic algorithm after two days of running time. it should be noted that the
hill climbing technique restarted around the 100-hour mark, as no cheaper
alternative execution scenario was found during the search iteration. for this21
fig. 3: log b's cost reduction over a period of one week.
experiment, we thus observe that the hill climbing, tabu search, and hybrid
genetic algorithm perform equally well.
fig. 4: log a's cost reduction (logarithmic scale) over a period of one week.
the experiment conducted with log b is for scalability test purposes only,
and the size of this log is a far cry from a real-life event log. hence, we turn
our attention to the second experiment to gain a more concrete conclusion.
we now analyse the experiment that made use of log a, with results illus-
trated in fig. 4. the hybrid genetic algorithm performed distinctively better
in this scenario, with a cost reduction of 6.36% after one week of computa-
tion, whereas hill climbing and tabu search only managed to reduce the cost
by approximately 0.2%. again, a similar pattern to the previous experiment
regarding the performance of the hybrid genetic algorithm was observed. the
hybrid genetic algorithm rapidly reduced the cost, reducing 4.5% of the cost22
(a) experiment results in terms of aver-
age waiting time between activities and
service level agreement breach count us-
ing log b.
(b) experiment results in terms of aver-
age waiting time between activities and
service level agreement breach count us-
ing log a.
fig. 5: experiment result in terms of non-cost indicators.
in the rst 6 hours, and up to 5.5% in the following 12 hours, which strongly
highlights the validity of this approach for real-life sized event logs.
also, several non-cost indicators were used as measurement factors. the
average waiting time between activities within the case was calculated, where
a reduction in average waiting time results in a reduction of service level agree-
ment breaches, therefore bringing down the cost. fig. 5 shows the changes in
relation to these two non-cost indicators. all techniques managed to reduce
the average waiting time while also reducing the service level agreement breach
count. it was additionally be observed that the hybrid genetic algorithm, in
particular, performs slightly better in reducing the average waiting time, re-
ducing at least 85% of the average waiting time compared with less than 78%
for the other two techniques. all techniques also managed to considerably
reduce, or even eliminate the number of cases that breach the service level
agreement. from a resource perspective, the resources are utilised in a much
more eective way, resulting in changes to their overall resource utilisation
percentage. our cost optimisation technique not only achieved a reduction in
cost, but also increased the eciency in a number of process aspects.
in this section, we discussed the approach undertaken to evaluate the pro-
posed cost optimisation techniques with dierent logs. these preliminary re-
sults show that it is possible to learn from the history by generating alternative
scenarios to satisfy the goal of cost minimisation. in a nutshell, the ilp tech-
nique is straightforward, but its application to real-world business processes
is unrealistic. the hill climbing and tabu search techniques perform well with
small sized logs. although most of the options to improve the eciency of
the techniques have been considered, the hybrid genetic algorithm approach
still outperforms them on realistic logs. considering the emphasis on cost re-
duction, the importance of scalability, and the balance between the non-cost
indicators, it can be concluded that the hybrid genetic algorithm exhibited the
best results.
now we focus on some of the potential limitations of the presented work.
we assume that both start and complete times of activities are recorded in an23
event log. this assumption enables us to compute accurate activity durations
and allows us to reduce activity wait times by shifting forward the start time
of the activity if a suitable resource is available. however, we acknowledge that
it not all event logs generated by it systems contain both start and complete
times for activities. in such cases, organisations need alternative methods to
calculate or approximate activity durations, or design a cost function that
caters for this deciency. we would also like to note that the car insurance
claims example and its corresponding event log are not generated by a domain
expert. the example is inspired by a widely available insurance claim process7,
as well as our research group's expertise with process models and logs from the
insurance sector8. the example cost structure used in the paper is intended to
demonstrate the extent of the proposed generic cost structure which is backed
by insights gained from literature in the areas of management accounting and
business process improvement. it is possible that some of the cost functions and
cost values presented in this cost structure may not be realistic for a particular
organisation. to conduct a more thorough evaluation of our approach, we are
dependent on an organisation providing us with a detailed event log and a
tailored cost structure, which is stated as part of our future work.
6 conclusion
this paper proposes a novel cost-informed process improvement approach that
enables the generation and comparison of alternative process execution sce-
narios while taking into account trade-os in terms of cost. this approach is
based on the identication of xed and variable parts of an event log. on top of
this framework, an adaptive cost structure that captures dierent cost-related
dimensions has been proposed and incorporated as the objective function. a
number of optimisation techniques were implemented and subsequently com-
pared. the experiments performed concluded that, although the time required
for optimisation is quite high, the hybrid genetic algorithm is still the best
approach to achieve a cost-informed process improvement in terms of per-
formance and scalability. observe that in our approach, the overall cost of a
business process (based on the process behaviour represented in an event log)
is computed, not the cost of individual cases. organisations can also utilise
our proposed approach to perform scenario analysis or what-if analysis by us-
ing dierent cost structures, enabling process analyst to analyse various to-be
scenarios using dierent cost functions and eciency measures dened within
the cost structure.
as future work, our proposed approach could be evaluated not only by
using a real-world scenario, but also by using a real-world cost structure. the
viability and performance of other optimisation techniques could be inves-
tigated as well. another possible direction of future work is to explore the
relaxation of optimisation constraints, where our recommended technique 1)
7http://www.aami.com.au/car-insurance/claimsprocess
8http://bpm-research-group.org/research/rss-publications24
could be extended to allow activities to be executed in parallel, and 2) could
incorporate changes in activity durations to cater for productivity dierences
among resources. it is also possible to explore the dierences between the base-
line and improved event logs and investigate visualisation techniques to better
portray the degree to which these dierences contribute to cost minimisation.
this may lead to the development of a methodology for deriving cost-related
insights and using these insights as a basis for improvement recommendations.
acknowledgements this work is supported by australian research council (arc) dis-
covery grant 120101624. we would also like to thank professor erhan kozan for his input
to the ilp formalisation.
references
1. e.h.l. aarts and j.k. lenstra. local search in combinatorial optimization . princeton
university press, 2003.
2. m. birattari, l. paquete, t. stiitzle, and k. varrentrapp. classication of metaheuris-
tics and design of experiments for the analysis of components. 2001.
3. n. brand and h. van der kolk. workow analysis and design. deventer: kluwer
bedrijfswetenschappen , 1995.
4. s.p. brooks and b.j.t. morgan. optimization using simulated annealing. the statis-
tician , 44(2):241{257, 1995.
5. a. colorni, m. dorigo, v. maniezzo, et al. distributed optimization by ant colonies.
inproceedings of the rst european conference on articial life , volume 142, pages
134{142. paris, france, 1991.
6. r.c. eberhart and j. kennedy. a new optimizer using particle swarm theory. in
proceedings of the sixth international symposium on micro machine and human science ,
volume 1, pages 39{43. new york, ny, 1995.
7. f. glover and m. laguna. tabu search . springer, 1999.
8. d.e. goldberg. genetic algorithms in search, optimization, and machine learning .
addison-wesley professional, 1989.
9. s. hartmann and d. briskorn. a survey of variants and extensions of the resource-
constrained project scheduling problem. eur. j. oper. res. , 207(1):1{14, 2010.
10. a.r. hevner, s.t. march, j. park, and s. ram. design science in information systems
research. mis quarterly , 28(1):75{105, 2004.
11. z. huang, x. lu, and h. duan. resource behavior measure and application in business
process management. expert systems with applications , 39(7):6458{6468, 2012.
12. h.c. hwang and b.k. choi. workow-based dynamic scheduling of job shop operations.
international journal of computer integrated manufacturing , 20(6):557{566, 2007.
13. w.z. low, j. de weerdt, m.t. wynn, a.h.m. ter hofstede, w.m.p. van der aalst,
and s.k.l.m. vanden broucke. perturbing event logs to identify cost reduction oppor-
tunities: a genetic algorithm-based approach. in proceedings of the ieee cec 2014,
beijing, china, july 6-11, 2014 , pages 2428{2435, 2014.
14. s.l. mansar and h.a. reijers. best practices in business process redesign: use and
impact. business process management journal , 13(2):193{213, 2007.
15. j.d. martin and j.w. petty. value based management: the corporate response to the
shareholder revolution . oxford university press, 2001.
16. i. masaaki. kaizen: the key to japan's competitive success. new york, mcgraw-hill ,
1986.
17. t. murata. petri nets: properties, analysis and applications. proceedings of the ieee ,
77(4):541{580, 1989.
18. g.l. nemhauser and l.a. wolsey. integer and combinatorial optimization , volume 18.
wiley new york, 1988.25
19. r.p. neuman and r. cavanagh. the six sigma way: how ge, motorola, and other
top companies are honing their performance . mcgraw hill professional, 2000.
20. a. rappaport. creating shareholder value: a guide for managers and investors . simon
and schuster, 1999.
21. r. ray. economic value added: theory, evidence, a missing link. review of business ,
22(1/2):66, 2001.
22. h.a. reijers and k.m. van hee. product-based design of business processes applied
within the nancial services. j. res. pract. inf. tech. , 34(2):110{122, 2002.
23. c. sonnenberg and j. vom brocke. the missing link between bpm and accounting:
using event data for accounting in process-oriented organizations. business process
management journal , 20(2):213{246, 2014.
24. a.h.m. ter hofstede, w.m.p. van der aalst, m.adams, and n.russell, editors. modern
business process automation - yawl and its support environment . springer, 2010.
25. a. tiwari, k. vergidis, and c. turner. evolutionary multi-objective optimisation
of business processes. in soft computing in industrial applications , pages 293{301.
springer, 2010.
26. w.m.p. van der aalst. petri net based scheduling. operations research spektrum ,
18(4):219{229, 1996.
27. w.m.p. van der aalst. process mining: discovery, conformance and enhancement of
business processes . springer, 2011.
28. k. vergidis, d. saxena, and a. tiwari. an evolutionary multi-objective framework for
business process optimisation. applied soft computing , 12(8):2638{2653, 2012.
29. k. vergidis and a. tiwari. business process design and attribute optimization within
an evolutionary framework. in ieee congress on evolutionary computation , pages
668{675. ieee, 2008.
30. k. vergidis, a. tiwari, and b. majeed. business process analysis and optimization:
beyond reengineering. ieee trans. syst., man, cybern. c, appl. rev. , 38(1):69{82,
2008.
31. j. vom brocke, c. sonnenberg, and u. baumoel. linking accounting and process-aware
information systems - towards a generalized information model for process-oriented
accounting. european conference on information systems , pages 1{13, 2011.
32. k. wang, a. salhi, and e.s. fraga. process design optimisation using embedded hy-
brid visualisation and data analysis techniques within a genetic algorithm optimisation
framework. chem. eng. process. process intensif. , 43(5):657{669, 2004.
33. w.l. winston and j.b. goldberg. operations research: applications and algorithms .
thomson/brooks/cole belmont, 2004.
34. j.p. womack and d.t. jones. lean thinking: banish waste and create wealth in
your corporation . simon and schuster, 2010.
35. m.t. wynn, w.z. low, a.h.m. ter hofstede, and w. nauta. a framework for cost-
aware process management: cost reporting and cost prediction. journal of universal
computer science , 20(3):406{430, 2014.
36. m.t. wynn, j. de weerdt, a.h.m. ter hofstede, w.m.p. van der aalst, h.a. reijers,
m.j. adams, c. ouyang, m. rosemann, and w.z. low. cost-aware business pro-
cess management: a research agenda. 24th australasian conference on information
systems , 2013.
37. j. xu, c. liu, x. zhao, and z. ding. incorporating structural improvement into resource
allocation for business process execution planning. concurr. comp - pract. e. , 25:427{
442, 2012.
38. j. xu, c. liu, x. zhao, and s. yongchareon. business process scheduling with re-
source availability constraints. in otm to meaningful internet systems , pages 419{427.
springer, 2010.
39. x. yang. introduction to mathematical optimization . cambridge international science
publishing, 2008.
40. j. yu and r. buyya. scheduling scientic workow applications with deadline and
budget constraints using genetic algorithms. scientic programming , 14(3-4):217{230,
2006.