ieee transactions on knowledge and data engineering 1
an integrated framework for process discovery
algorithm evaluation
toon jouck, alfredo bolt, beno ÀÜƒ±t depaire, massimiliano de leoni, and wil m. p . van der aalst
abstract ‚Äîprocess mining offers techniques to exploit event data by providing insights and recommendations to improve business
processes. the growing amount of algorithms for process discovery has raised the question of which algorithms perform best on a
given event log. current evaluation frameworks for empirically evaluating discovery techniques depend on the notation used
(behavioral identical models may give different results) and cannot provide more general statements about populations of models.
therefore, this paper proposes a new integrated evaluation framework that uses a classiÔ¨Åcation approach to make it modeling notation
independent. furthermore, it is founded on experimental design to ensure the generalization of results. it supports two main evaluation
objectives: benchmarking process discovery algorithms and sensitivity analysis, i.e. studying the effect of model and log characteristics
on a discovery algorithm‚Äôs accuracy. the framework is designed as a scientiÔ¨Åc workÔ¨Çow which enables automated, extendable and
shareable evaluation experiments. an extensive experiment including four discovery algorithms and six control-Ô¨Çow characteristics
validates the relevance and Ô¨Çexibility of the framework. ultimately, the paper aims to advance the state-of-the-art for evaluating process
discovery techniques.
index terms ‚Äîprocess discovery, performance evaluation, benchmark testing.
f
1 i ntroduction
today ‚Äôsinformation systems store large amounts of
data about the business processes within organizations.
this leads to the challenge of extracting value and informa-
tion out of these event data. process mining is a discipline
that sits between data mining and process modeling and
analysis and, hence, can be considered as the linking-pin
between data science and process science [1]. the idea of
process mining is to discover, monitor and improve the
processes by extracting knowledge from the data that are
stored in information systems about how these systems
are used to carry out processes. differently from a-priori
analysis, the focus is not on the assumed processes but on
real processes in the way that they are executed. therefore,
the starting point of process mining is an event log, which
is analyzed to extract useful insights and recurrent patterns
about how processes are executed within organizations.
the lion‚Äôs share of attention within process mining was
received by process discovery, which aims to discover a
process model from event logs. this resulted in dozens
of new discovery algorithms (see, e.g., [2], [3], [4] and for
an overview see [1], [5]). researchers aim to improve the
quality of the mined models to adequately represent the
behavior observed in the event logs. typically, the quality
is measured as the Ô¨Åtness between the event log and the
mined model. a good model allows for the behavior seen
in the event log. fitness alone is not sufÔ¨Åcient, also a proper
balance between overÔ¨Åtting and underÔ¨Åtting is required [1]. a
process model is overÔ¨Åtting (the event log) if it is too restric-
t. jouck and benoÀÜ ƒ±t depaire are with the faculty of business economics,
uhasselt - hasselt university, 3590 diepenbeek, belgium.
e-mail: toon.jouck, benoit.depaire@uhasselt.be.
a. bolt, m. de leoni and w. van der aalst are with the department of
mathematics and computer science, eindhoven university of technology,
eindhoven, the netherlands.
e-mail: a.bolt, m.d.leoni, w.m.p.v.d.aalst@tue.nl.tive, disallowing behavior which is part of the underlying
process. this typically occurs when the model only allows
for the behavior recorded in the event log. conversely, it
is underÔ¨Åtting (the reality) if it is not restrictive enough,
allowing behavior which is unlikely to be part of the under-
lying process. this typically occurs if it overgeneralizes the
observed behavior in the event log.
the abundance of discovery algorithms has made it in-
creasingly important to develop evaluation frameworks that
can compare the efÔ¨Åciency of these discovery techniques,
especially in terms of balancing between overÔ¨Åtting and
underÔ¨Åtting. as detailed in section 5, several comparison
frameworks have already been proposed in literature. un-
fortunately, these frameworks are characterized by at least
one of the following three major limitations:
1) they are not independent from the modeling no-
tation in which the discovered models are rep-
resented, e.g. two behaviorally equivalent models
may have very different precision scores, or quality
can only be measured after a conversion that does
not preserve the behavior precisely. this restricts the
framework to a comparison of the algorithms that
generate models in one speciÔ¨Åc notation.
2) the evaluation results are based on real event logs
and cannot be generalized as the population of
processes from which they originate is unknown.
processes come from different populations depend-
ing on the type of behavior allowed. processes may
have different behavioral characteristics, with parts
that can repeat, with mutually-exclusive and paral-
lel branches, with non-local dependencies and so on.
also, these characteristics can be more or less pre-
dominant in a process model. different algorithms
may better deal with a certain characteristic thanarxiv:1806.07222v1  [cs.se]  8 jun 2018ieee transactions on knowledge and data engineering 2
others. and the quality of the discovered model
may also depend on the predominance of certain
characteristics. performing a comparison without
acknowledging the inÔ¨Çuence of these behavioral
characteristics can lead to inconclusive results.
3) they use manually created processes to generate
artiÔ¨Åcial event data. as a result the studied process
characteristics are not randomly included in the pro-
cesses. furthermore, relatively few processes and
event logs were created. this prevents the results
from being statistically and generally valid.
this paper tries to overcome these limitations by proposing
a framework that
1) abstracts from the modeling notation employed;
2) starts from the deÔ¨Ånition of a process population
where the probability of several behavioral char-
acteristics can be varying. from this population a
random sample of process models and event logs
is drawn, thus making it possible to evaluate and
generalize the inÔ¨Çuence of behavioral characteristics
on the quality of the discovered models by the
different algorithms under analysis;
3) performs experiments on random samples of a user-
speciÔ¨Åed size, so as to return statistically valid re-
sults;
in a nutshell, our framework is based on a classiÔ¨Åcation
perspective to evaluate the quality of a discovered model.
the framework starts with artiÔ¨Åcially generating random
samples of process models from a speciÔ¨Åed population of
processes. for each model, we generate a training log with
Ô¨Åtting traces (to discover a model) and a test log with both
Ô¨Åtting and non-Ô¨Åtting traces. then, the quality of a discovery
algorithm with respect to the event log is related to the
ability to correctly classify the traces in the test event log:
the discovered model should classify a trace representing
real process behavior as Ô¨Åtting and a trace representing a
behavior not related to the process as non-Ô¨Åtting. in this way
the classiÔ¨Åcation approach allows us to evaluate discovery
algorithms generating models in different modeling nota-
tions because the quality measurement is not based on one
speciÔ¨Åc modeling notation. furthermore, by using (large)
samples of randomly generated models and logs we can
make general statements about populations of models and
logs.
obviously, repeating the generation of event logs and
process models cannot be done manually to get signiÔ¨Åcant
results. we aim at thousands of models and logs in order
to generalize. fortunately, this can be automated through
the use of scientiÔ¨Åc workÔ¨Çows. scientiÔ¨Åc workÔ¨Çow man-
agement (swfm) systems help users to design, compose,
execute, archive, and share workÔ¨Çows that represent some
type of analysis or experiment. the advantages of using
scientiÔ¨Åc workÔ¨Çows for process mining are discussed in [6].
this framework clearly enables the sensitivity analysis
mentioned above: by deÔ¨Åning and then sampling from
a population of processes using the process-characteristic
dimensions, one can evaluate the impact of the different
behavioral characteristics on the quality of the models dis-
covered by the different techniques under analysis. thismeans that the quality measure needs to be returned for
each combination of event log and algorithm.
in summary, this paper reports on the formalization and
the operationalization of our framework using rapidprom,
a scientiÔ¨Åc workÔ¨Çow system with process mining features.
the experiments report the results of their application to
four state-of-the-art discovery algorithms. it is beyond the
scope of this paper to extensively cover every existing
discovery algorithms. however, the operationalization and
the experiments show how easy it is to extend to other
algorithms. ultimately, this paper aims to advance the state-
of-the-art for evaluating process discovery algorithms.
the remainder of the paper is structured as follows.
section 2 discusses the new evaluation framework including
the methodological foundations and all the building blocks.
next, the experiments section 3 describes the validation of
the new framework using a large experiment. section 4 in-
cludes a discussion of the experimental results and future re-
search opportunities. related work is discussed in section 5
and section 6 wraps up the paper with the conclusions.
2 d iscovery evaluation framework
this paper reports on a framework that aims to evaluate the
quality of discovery algorithms to rediscover a model when
confronted with a fraction of its behavior. the framework
is designed based on the principles of scientiÔ¨Åc workÔ¨Çows
and experimental design. the former captures the complete
evaluation experiment in a workÔ¨Çow that can be automated,
reused, reÔ¨Åned and shared with other researchers [7]. the
latter allows for precise answers that a researcher seeks to
answer with the evaluation experiment [8].
to integrate the steps needed for empirically evaluating
process discovery algorithms, the framework is built as a
scientiÔ¨Åc workÔ¨Çow. generally such workÔ¨Çows are repre-
sented as a directed graph with nodes denoting computa-
tional steps and arcs expressing data Ô¨Çows and data de-
pendencies between steps [9] (see fig. 1). bolt et al. [6] have
described generic process mining building blocks to conduct
process mining experiments using scientiÔ¨Åc workÔ¨Çows.
scientiÔ¨Åc workÔ¨Çows offer several advantages over tra-
ditional ways to conduct process discovery evaluation. the
Ô¨Årst advantage comes from workÔ¨Çow automation. experi-
ments evaluating discovery techniques involve large-scale
and computationally expensive experiments that require
intensive human assistance [6]. therefore, automating these
experiments removes the need for the human assistance and
reduces the time needed to perform experiments. a second
beneÔ¨Åt comes from the modularity of the workÔ¨Çows. this
allows researchers to adapt and extend an existing work-
Ô¨Çow, e.g. by using other parameter settings or adding new
process discovery techniques. a Ô¨Ånal beneÔ¨Åt of scientiÔ¨Åc
workÔ¨Çows is that they can be shared with other researchers.
as a result other researchers can replicate experiments with
little effort. in this way, our framework facilitates repeated
process discovery evaluation, e.g. it becomes trivial to eval-
uate another set of algorithms or to assess the algorithm‚Äôs
performance with regard to other data characteristics (e.g.
noise, control-Ô¨Çow patterns, etc.).
an evaluation analysis aims to test statistical hypotheses
about a discovery algorithm. for example, does the presenceieee transactions on knowledge and data engineering 3
fig. 1: framework for process discovery algorithm evaluation
of loops cause the alpha+ miner [10] to discover models
with lower Ô¨Åtness? or: does the alpha+ miner and heuris-
tics miner [11] perform equally in the Ô¨Åtness dimension
on event logs with non-exclusive choice (or) behavior? this
makes it Ô¨Åt within the experimental design methodology in
which the primary goal is to establish a causal connection
between the independent (algorithm, log characteristics)
and dependent (model quality criteria) variables [8]. the
three cornerstones of good experimental design are: ran-
domization, replication and blocking [12]. the three corner-
stones together are fundamental to make the experiments
scientiÔ¨Åcally sound (e.g., avoid bias or wrong conclusions).
therefore, the evaluation framework incorporates each of
the cornerstones.
randomization involves the random assignment of sub-
jects to the treatment in order to limit bias in the outcome
of the experiment [8], [13]. in the evaluation context, the
subjects are the event logs and the treatments are the
discovery algorithms. therefore, the evaluation framework
has to ensure that the event logs generated in the data
generation step are random observations from a population
of processes with all desired control-Ô¨Çow characteristics.
replication means that more than one experimental unit is
observed under the same conditions. it enables researchers
to estimate error effects and obtain a more precise estimate
of treatment effects [8]. in the context of process discovery
this implies that one needs to test a speciÔ¨Åc algorithm onmore than one event log to accurately assess the effect of
that algorithm on model quality. the framework requires
that the evaluation is based on a sample of event logs
from a given population to obtain better estimates of the
studied effect. finally, blocking an experiment is dividing
the observations into similar groups. in this way one can
compare the variation between groups more precisely [13].
for example, if the experiment studies the effect of loops on
model quality, also other characteristics such as infrequent
behavior could have an effect. therefore, the evaluation
framework allows to vary the presence of loops in models
(variable of interest) while holding the infrequent behavior
constant to obtain precise estimates of the effect of loops on
model quality (studied effect).
the remainder of the section will discuss the design of
the framework and its building blocks in more detail.
2.1 the design and use of the evaluation framework
the framework focuses on evaluating control-Ô¨Çow discov-
ery algorithms. therefore, other process related perspec-
tives, such as data and resources, are out of its scope1.
moreover, the framework aims at evaluation instead of
predicting the best performing algorithm given an event log.
the framework enables two main objectives: either bench-
marking different discovery algorithms, either performing
1. however, the same ideas can be applied to include these other
perspectives.ieee transactions on knowledge and data engineering 4
sensitivity analysis, i.e. what effect does a control-Ô¨Çow
characteristic or event log characteristic have on algorithm
performance.
fig. 1 illustrates the design of the new evaluation frame-
work as a workÔ¨Çow. the directed graph shows how the
different tasks needed for evaluating process discovery al-
gorithms are connected. the framework enforces the con-
secutive execution of data generation, process discovery,
quality measurement and statistical analysis. the frame-
work applies a classiÔ¨Åcation approach to allow for the
evaluation of discovery algorithms generating models in
different notations.
the Ô¨Årst step, i.e. the data generation, is triggered by
the objective of the experiment. as a result, the objective
determines the control-Ô¨Çow behavior a researcher wants
to include in the event logs. the speciÔ¨Åcation of control-
Ô¨Çow behavior deÔ¨Ånes a population of process models. this
population deÔ¨Ånition is the start of the data generation
phase.
for each discovery algorithm to be tested, multiple in-
stances of the ‚Äúgenerate models‚Äù task run in parallel. the
generation results in multiple random samples of process
models from the same population. each model (‚Äúoriginal
model‚Äù) is then simulated by the task ‚Äúgenerate event log‚Äù
to create one event log, i.e. a random sample of traces from
all possible traces allowed by the model. the samples of
process models and event logs constitute as ‚Äúthe ground
truth‚Äù.
next, the 10-fold cross-validation splits each event log
into ten subsets, i.e. folds, of equal sizes. nine folds form
the training log, while the remaining fold serves as the
test log. the task ‚Äúdiscover model‚Äù applies the algorithm
to induce a model from the training log. to this point, the
test log only contains positive examples, i.e. traces that Ô¨Åt
the original model. the classiÔ¨Åcation approach requires also
negative examples, i.e. traces that do not Ô¨Åt the original
model. to generate negative examples, the task ‚Äúcreate non-
Ô¨Åtting traces‚Äù alters half of test traces until they cannot
be replayed2anymore by the original model (‚Äúthe ground
truth‚Äù) to create non-Ô¨Åtting traces.
subsequently, the framework measures the quality of
the discovery algorithm by using the discovered model to
classify the test traces. this classiÔ¨Åcation happens within
the ‚Äúconformance checking‚Äù block which replays all traces
on the discovered model. a trace representing real process
behavior should be classiÔ¨Åed as allowed, i.e. completely
replayable. a trace representing behavior not related to the
real process should be classiÔ¨Åed as disallowed by the discov-
ered model, i.e. not completely replayable. this approach
allows for any discovery algorithm generating models with
formal replay semantics.
the classiÔ¨Åcation results are then combined in a con-
fusion matrix (see section 2.2). based on that matrix, one
can compute the well-known recall and precision metrics to
evaluate the quality of the discovery algorithm. the frame-
work repeats the process of splitting, discovery, creating
non-Ô¨Åtting traces and conformance checking ten times, each
time with a different fold as ‚Äútest log‚Äù. the task ‚Äúaverage
2. replay uses the trace and the model as input. the trace is ‚Äúre-
played‚Äù on top of the model to see if there are discrepancies between
the trace and the model [1].results‚Äù computes the average of the metric values over the
ten folds to get an estimate of the algorithm‚Äôs performance.
note that by using 10-fold cross validation the obtained
estimate is less likely to suffer from bias, i.e. it helps to de-
crease the difference of the estimate from the real unknown
value of the algorithm‚Äôs performance on the population of
processes. finally, the task ‚Äústatistical analysis‚Äù tests the
hypotheses formulated in the context of the objectives.
this framework‚Äôs design has the property that no two
discovery algorithms are applied on the same event log. fur-
thermore, for each generated model - randomly drawn from
a predeÔ¨Åned population of models - we randomly draw
only a single event log. consequently, all discovered mod-
els and any corresponding quality metric are independent
observations which is an important assumption underlying
many standard statistical techniques. we acknowledge that
this design decision is not the only option as one could test
discovery algorithms on the same logs. this alternative de-
sign would have more statistical power for the same sample
size, however it requires more complex statistical techniques
to deal with the dependence between observations. we can
compensate for the loss in power in our design by deÔ¨Åning
the desired power in advance and calculate the sample size
required for such power.
finally, the framework‚Äôs design based on the experi-
mental design principles enable users to obtain algorithm‚Äôs
performance measures that are independent from speciÔ¨Åc
process models and event logs. more speciÔ¨Åcally, this starts
from the generation of (preferably large) random samples of
process models and logs from a population, which are then
used to estimate the performance of a algorithm with regard
to that population. this contrasts evaluation based on a
small non-random sample of (manually created) process
models and event logs as it could inÔ¨Çuence the performance
estimate to only reÔ¨Çect these particular models and logs.
the following subsection will elaborate on each of the
tasks in the evaluation framework.
2.2 the building blocks of the framework
2.2.1 generate models
this building block generates a random sample of process
models from a population of models. the inputs of this
block are the population characteristics. the user can specify
the population by assigning probabilities to each of the
model building blocks and setting the size of the models
in terms of visible activities. the probabilities of the control-
Ô¨Çow characteristics inÔ¨Çuence the probability for each char-
acteristic to be included in the resulting process model. for
example, if the probability of loops is 0.2, then on average
20% of the model constructs will be of type loop.
in particular, this block allows one to generate models
that can feature the basic patterns identiÔ¨Åed in [14], namely:
-sequence: certain process activities need to be se-
quentially executed.
-exclusive choice: certain process parts/branches of
the process are mutually exclusive. in several notations, this
is known as xor split/join.
-parallelism: certain parts/branches are ‚Äúparallel‚Äù,
indicating that the activities of a Ô¨Årst part of the model do
not impose ordering constraints on the activities of a second
part. in several notations, this is known as and split/join.ieee transactions on knowledge and data engineering 5
-inclusive choice: when reaching given points of the
process, a choice needs to be made on which part(s) of
process that follow need to be carried on. differently from
exclusive choice, multiple parts can be executed in parallel;
different from the parallelism construct, not every part that
follows the reached point needs to be executed. in several
notations, this is known as or split/join.
-loop: certain parts of the process can be sequen-
tially repeated multiple times.
this set of pattern is complemented by a number of more
advanced patterns:
-silent transitions: certain transitions are inserted
into the model for a process-routing purpose. for instance,
combined with exclusive choices, silent transitions enable
certain parts of the process to be skipped.
-duplicate activities: the same activity appears in
different parts of the process, indicating that the activity can
reoccur.
-long-term dependency: the choice of one or mul-
tiple branches at a certain moment in the execution of the
process can inÔ¨Çuence which choices become available at a
later point.
-infrequent paths: this is always combined with an
exclusive choice. when the execution reaches an exclu-
sive choice, certain potential process branches have higher
chance to be chosen. in fact, this pattern is rather related to
the generation of event logs.
these constructs are those typically discovered by dis-
covery algorithms because they are the most relevant.
bpmn and other modelling notations support more com-
plex constructs, such as multiple instances and terminating
events; however, at the best of our knowledge, no discovery
algorithms support their discovery.
as a result, this block allows users to fully control
the control-Ô¨Çow behavior in the generated models and
generalize the results to the pre-deÔ¨Åned population. the
user deÔ¨Ånes a population of process models by setting the
following parameters:
model size parameters: mode; min; max.
control-Ô¨Çow characteristic probabilities: sequence;
exclusive choice; parallelism; loop; or; silent tran-
sitions; duplicate activities; long-term dependency;
infrequent paths
in the framework, process models are generated as process
trees [15], which support for all the constructs/patterns
mentioned above. to feature the artiÔ¨Åcial, random gener-
ations of process trees, the framework leverages on the
technique and implementation reported in [16], to which
interested readers are referred for further information.
2.2.2 generate log
for each generated model the ‚Äúgenerate log‚Äù block creates
an event log, i.e. a random sample of all possible traces
allowed by that model. this building block simulates the
given model to generate a user-speciÔ¨Åed number of traces
per event log. the exclusive choices in each of the models
have output-branch probabilities. as a result, the resulting
event log contains a random set of Ô¨Åtting and complete
traces. the presence of infrequent paths will make sometraces more probable than others which will result in event
logs with infrequent behavior.
2.2.3 split log
this building blocks applies the Ô¨Årst step needed for the
10-fold cross validation evaluation method. the step splits
a given event log into ten subsets (folds) of equal size.
nine folds form the ‚Äútraining log‚Äù and are the input of
the discovery algorithm. the tenth fold is the ‚Äútest log‚Äù
which is split in half: one half constitutes the ‚ÄúÔ¨Åtting test
traces‚Äù, the other half will serve as input of the ‚Äúcreate non-
Ô¨Åtting traces‚Äù block to make ‚Äúnon-Ô¨Åtting test traces‚Äù. this is
repeated ten times such that each of the ten folds becomes a
‚Äútest log‚Äù exactly once.
2.2.4 create non-Ô¨Åtting traces
in a classiÔ¨Åcation approach the ‚Äútest log‚Äù should contain
positive and negative examples. to this point, there are only
positive examples, i.e. traces that Ô¨Åt the original model. the
‚Äùcreate non-Ô¨Åtting traces‚Äù building block alters the given
test traces so that they do not Ô¨Åt the original model anymore.
the goal of the non-Ô¨Åtting traces is to punish overgener-
alization of discovery algorithms. the Ô¨Çower model is an
example of extreme overgeneralization that allows every
possible trace involving the set of activities but provides no
added value in a business context [1]. therefore, this paper
aims to punish typical overgeneralizing patterns: unneces-
sary loops, activity skips and parallelism, by altering the
traces using speciÔ¨Åc noise operations (see description below)
that can add or remove behavior. additionally, the traces are
altered but kept as close to the original trace as possible. in
this way, the framework avoids non-Ô¨Åtting traces that would
be trivially rejected by underÔ¨Åtting models.
given a process model and a set of Ô¨Åtting traces, noise
is added to each trace as follows. first, one or more of the
following noise types based on [17], is added with a user
speciÔ¨Åed probability:
add activity : one of the process activities is added in
a random position within the trace.
duplicate an activity : when an activity is duplicated,
it is inserted immediately after the original.
remove an activity : a single activity is randomly re-
moved from the trace.
swap consecutive activities : a random pair of consecu-
tive activities are swapped within the trace.
swap random activities : similar to the previous type of
noise, but the activities to be swapped are selected
from random positions in the trace (not necessarily
consecutive).
then, the modiÔ¨Åed trace is checked for Ô¨Åtness with respect
to the original model. if the trace does not Ô¨Åt anymore, it
is a noisy trace which will not be edited anymore. if the
trace still Ô¨Åts the model, noise is added again (and checked
afterwards) until it does not Ô¨Åt anymore, or until noise has
been added Ô¨Åve times. if the noisy trace still does not Ô¨Åt the
model, the trace is discarded and another trace is randomly
selected from the set of Ô¨Åtting traces. this trace follows the
same process described above.ieee transactions on knowledge and data engineering 6
2.2.5 discover process model
this block applies a discovery algorithm to the ‚Äútraining
log‚Äù to induce a process model. this could be any discov-
ery technique with user speciÔ¨Åed parameter settings. the
discovered model will be used for conformance checking.
2.2.6 conformance checking
the conformance checker will replay the given traces on
the discovered model. because the framework applies a
classiÔ¨Åcation approach, the replay assigns each trace to a
binary class: if a trace can be completely replayed by the
discovered model it belongs to the ‚ÄúÔ¨Åtting‚Äù class, otherwise
the trace is part of the ‚Äúnon-Ô¨Åtting‚Äù class. the number of
classes could be extended to create a more Ô¨Åne-grained
evaluation. however, we argue that determining the classes
for partially Ô¨Åtting traces would require additional research,
which is outside the scope of this paper.
2.2.7 calculating performance metrics
the framework summarizes the performance of an algo-
rithm using three standard metrics adopted from the data
mining and information retrieval domain: precision, recall
and f measure. traditionally these metrics are based on:
true positives: the number of real traces that Ô¨Åtthe
discovered model.
false positives: the number of false traces that Ô¨Åtthe
discovered model.
false negatives: the number of real traces that do not
Ô¨Åtthe discovered model.
true negatives: the number of false traces that do
not Ô¨Åt the discovered model.
the precision metric refers to the percentage of traces
that Ô¨Åt the original model from all the traces that Ô¨Åt the
discovered model.
precision =true positives
(true positives +false positives )(1)
inversely, the recall metric refers to the percentage of
traces that Ô¨Åt the discovered model from all the traces that
Ô¨Åt the original model.
recall =true positives
(true positives +false negatives )(2)
the framework uses the f1variation of the f measure.
this statistic refers to the harmonic average of the precision
and recall metrics.
f1=2precisionrecall
(precision +recall )(3)
2.2.8 result analysis
the evaluation framework allows users to compare the
performance of algorithms and to study the effect of control-
Ô¨Çow characteristics on algorithm performance. the statis-
tical analysis based on the evaluation results depends on
the objectives of the experiment and the corresponding
hypotheses to be tested. therefore, the framework does not
incorporate speciÔ¨Åc statistical techniques, instead it can be
used with a whole range of exploratory, descriptive and
causal statistical techniques to test any hypothesis that canbe expressed in terms of precision, recall, f1score, and
characteristics of log and model. the authors believe that
this will beneÔ¨Åt the adoption of the framework for all types
of evaluation studies, rather than serve a speciÔ¨Åc purpose.
2.3 extensibility of the framework and bpmn
as claimed in section 1, the framework reported in this
paper is not bound to petri nets or any other modelling
notation. as a consequence, it is extensible to incorporate
new discover algorithms, independently of the notations in
which these algorithms generate the model. every change
that is necessary to evaluate a new discovery algorithm that
produces models in a notation n (say bpmn) is related
to the implementation, whereas the framework work-Ô¨Çow
does not require changes.
in the implementation, it is necessary to (1) plug-in the
new algorithm as a new instantiation of block discover model
in figure 1 (cf. section 2.2.5) and (2) plug-in a new confor-
mance checker for notation n, with the latter not being nec-
essary if notation n is already among those available in the
framework. it is not necessary to change the instantiation
of block generate models in figure 1. any model generator
in any notation that can represent the patterns deÔ¨Åned in
section 2.2.1, such as process trees, can be employed. these
models are only used to generate the event logs with Ô¨Åtting
and non-Ô¨Åtting traces and are not directly compared with
the models that are discovered.
consider the case that one wants to evaluate algorithms
that discover bpmn models while limiting the number of
changes to the current implementation. the implementation
of the algorithm needs to be plugged into rapidprom.
also, a conformance checker of bpmn models needs to
be available in the implementation. as a matter of fact,
this conformance checker is already available in the imple-
mentation. first, the bpmn model is converted into a trace
equivalent petri net that is trace equivalent: each execution
of the bpmn is possible in the petri net, and vice versa [18].
second, the petri-net conformance checker can be employed.
the trace equivalence between the bpmn and the petri net
models guaranteed that every trace that is diagnosed as
Ô¨Åtting/unÔ¨Åtting using the equivalent petri net will also be
as such with respect to the original bpmn model.
3 i mplementations and experiments
the framework was operationalized through rapidprom ex-
tension of the rapidminer analytic-workÔ¨Çow tool [6], which
contains all the operators mentioned in section 2.2 (see
appendix b for more details on the implementation). the
experiments were based on alpha+ miner [10], heuristics
miner [11], ilp miner [19] and inductive miner [20]. these
discovery algorithms are returning petri nets, which require
a suitable conformance checker. the choice has fallen on the
alignment-based conformance-checking technique presented
in [21], which is available in rapidprom and, differently
e.g. from the token-based algorithm [22], is able to deal with
invisible transitions and duplicate activity labels. excluding
the ilp miner, the other algorithms were used with the
default conÔ¨Åguration. the ilp miner was conÔ¨Åguration to
generate models in which the Ô¨Ånal marking is the emptyieee transactions on knowledge and data engineering 7
marking (no tokens remaining). any other conÔ¨Åguration
generates process models in which the ilp miner does
not state what the Ô¨Ånal marking is, which would require
a model inspection by a human. the human involvement
would hinder the possibility of an automatic workÔ¨Çow.
the generations of process models and event logs are
based on the techniques and implementations that are re-
spectively reported in [16] and in [23], which are in line
with section 2.2.
we conducted two rounds of experiments. the Ô¨Årst
round validates the usefulness of the proposed framework
through an experiment consisting of a detailed empirical
analysis of the process discovery algorithms mentioned
above. the discussion of the Ô¨Årst round is in section 3.1 and
the experimental results are reported in section 3.2. in the
second experiment round, the Ô¨Çexibility of the framework
and its support for large-scale experiments is validated by
extending the Ô¨Årst round to experiments Ô¨Åve times larger.
section 3.3 reports on the second round.
3.1 setup of the first experiment
as mentioned in section 2.1, the goal of this framework
is to analyze and compare the accuracy of process dis-
covery techniques to rediscover process models based on
observed executions (i.e., event logs). the population of
process models that we aim to rediscover is generated
by varying a number of parameters, which identiÔ¨Åes the
probability of occurrences of typical process characteristics,
such as parallel branches, silent transitions and infrequent
paths. section 2.2 has discussed the constructs which, so
far, our framework allows for and how the probabilities
inÔ¨Çuence the generated process models. in the Ô¨Årst round
of experiments, the population of models is generated by
varying the probability of duplicate activities and by en-
abling or disabling the presence of infrequent paths. in this
way, we can study the impact of infrequent behavior and of
different frequencies of duplicate activities on the accuracy
of process discovery techniques. section 3.3 will report on
the extended experiment where the probability of the other
process characteristics are also varied.
therefore, the experimental design includes all the com-
binations of three independent variables: process discovery
technique used, presence or absence of infrequent behavior
and the probability of having duplicate activities . the three
variables and their levels are summarized in table 1. in total,
the 56 possible combinations are included in the experiment:
4 discovery techniques 2 levels of infrequent behavior 
7 probabilities of duplicate activities.
as mentioned above, the other process characteristics are
not taken into account in this analysis. the probability of
non-exclusive choice (or) and of loops are set to zero and,
hence, these two constructs do not occur. the probability
of sequence, exclusive choice and parallelism is set and kept
Ô¨Åxed to values 46%, 35% and 19%, respectively. these values
have been determined after analysing their frequencies in
the large collections of models reported in [24]. in this work,
kunze et al. have observed that 95% of the models consist
of activities connected in sequences, 70% of the models
consist of activities, sequences and xor connectors and 38%
consist of sequences, activities and and connectors (see
fig. 2: distribution of completeness of logs wrt. their re-
spective process models. completeness is measured as the
fraction of traces allowed by the model that are present in
the event log.
fig. 4b of the paper). assuming independence of occurrence
probability of sequences, and and xor, it follows that:
p(sequence ) = 0:95
p(sequence^xor ) =p(sequence )p(xor ) = 0:70
)p(xor ) = 0:74
p(sequence^and ) =p(sequence )p(and ) = 0:38
)p(and ) = 0:4
when these values are normalized to 1, the Ô¨Ånal probabili-
ties of the constructs are obtained.
for each discovery technique a random sample of 62
process models is drawn. the sample size of 62 models
allows us to study the effect of process discovery techniques,
infrequent paths and different probabilities of duplicate-
activity occurrences (and their interactions) using a Ô¨Åxed
effects anova analysis [13] with signiÔ¨Åcance level =
0:05and power 1 = 0:983. this power indicates the
probability to detect a signiÔ¨Åcant effect when two mining
algorithms actually differ by a relatively small difference.
in total (i.e., sum of all combinations), 3472 process models
were generated.
for each of the obtained process models, an event log
containing between 200 and 1000 traces is generated (see
section 2.2.2). for each generated log, we can calculate
the completeness, i.e. the ratio of unique traces in the
log to all possible unique traces according to the model
using the technique described in [26]. fig. 2 shows that the
completeness varies between 0 and the maximum of 1. the
experiment applies the following discovery techniques with
its default parameter settings: alpha+ [10], heuristics [11],
ilp [19] and inductive miner [20]. as such, the choice of
techniques covers most families of discovery approaches
(see [1]).
3.2 analysis of the results of the first experiment
this section reports on the results of the experiments illus-
trated in section 3.1.
the effect of process-discovery techniques, infrequent
paths and different probabilities of duplicate-activity occur-
rences can be analyzed using one-way anova analysis if
the assumptions of homogeneity of variances and normality
3. the power was computed with the g*power tool [25]ieee transactions on knowledge and data engineering 8
table 1: summary of the possible values of the four
variables included in the experimental setup: 56 ( 427)
value combinations. the probability of duplicate activities
indicates the average percentage of duplicated visible activ-
ity labels in the process model.
discovery infrequent probability
technique paths duplicate activities
alpha+ [10] false 0.0, 0.05
heuristics [11] true 0.10, 0.15
ilp [19] 0.15, 0.20
inductive [20] 0.25, 0.30
of the dependent variable hold [13]. however, both assump-
tions were violated for every dependent variable, i.e. f1,
recall and precision. therefore, the non-parametric kruskall-
wallis test (kw) [27] was applied instead.
kw is used for testing whether kindependent samples
are from different populations. it starts by ranking all the
data from the different samples together: assign the highest
score a rank 1 and the lowest a rank n, wherenis
the total number of observations in the ksamples. then,
the average ranking for each sample is computed, e.g. the
mean of sample jis denoted as rj. withnthe number of
observations in each sample, the test statistic kw, which
follows a2distribution with k 1degrees of freedom, can
be calculated as [27]:
kw= [12
(n(n+ 1))kx
j=1nr2
j] 3(n+ 1) (4)
if the calculated kw is signiÔ¨Åcant, then it indicates that
at least one of the samples is different from at least one of the
others. subsequently, the multiple comparison post hoc test
is applied to determine which samples are different. more
speciÔ¨Åcally, for all a pairs of samples riandrjit is tested
whether they differ signiÔ¨Åcantly from each other using the
inequality [27]:
jri rjjz=k (k 1)r
n(n+ 1)
12(2
n) (5)
thez=k (k 1)value can be obtained from a normal
distribution table given a signiÔ¨Åcance level . the formula
adjusts this with a bonferroni correction to compensate
for multiple comparisons. if the the absolute value of the
difference in average ranks is greater than or equal to the
critical value, i.e. the right side of the equation, then the
difference is signiÔ¨Åcant.
finally, the jonckheere test [27] can be used to test for a
signiÔ¨Åcant trend between the ksamples. first, arrange the
samples according to the hypothesized trend, e.g. in case of
a positive trend from smallest hypothesized mean to highest
hypothesized mean. then count the number of times an
observation in sample iprecedes an observation in sample
j, denoted as uij8i < j . the jonckheere test statistic jis
the total number of these counts:
j=kx
i<juij (6)table 2: average ranks per miner. each cell indicates the
average ranking for a speciÔ¨Åc performance dimension (row
header) and for a speciÔ¨Åc miner (column header). one can
compare miners by comparing the average ranks within one
row.
alpha+ heuristics ilp inductive
recall 2361.94 2650.35 505.99 1427.73
precision 2155.57 2624.42 1007.66 1158.35
f1score 2318.14 2646.44 697.00 1284.42
whenjis greater than the critical value (see [27] for the
sampling distribution) for a given signiÔ¨Åcance level , then
the trend between the ksamples is signiÔ¨Åcant.
3.2.1 the effect of process discovery technique
the goal is to learn the effect of a process discovery tech-
nique on each of the dependent variables: recall, precision
andf1score. the other variables (i.e., infrequent paths level
and probability of duplicate activities) are part of the error
term.
we apply the kw method, to test whether the average
rank differs between the four process discovery techniques
(i.e. samples). in this case we ranked all the 3472 averages
over the 10-fold cross validation for recall, precision and
f1values ignoring sample membership (i.e. discovery tech-
nique). the highest value for recall, precision and f1gets
rank 1 (lowest rank), while the lowest absolute value gets
rank 3472 (highest rank). then we computed the average
ranking per miner, i.e. the average position of a discovered
model by that miner for that quality metric on a scale
from 1 to 3472. a higher average ranking means worse
performance. the ranking summary is shown in table 2.
based on the average rankings in table 2, the order
suggested between process discovery techniques is: ilp >
inductive>alpha+>heuristics for recall, precision and f1
scores. it means that the ilp miner creates the best models
in terms of recall, precision and f1scores (see section 4 for
an elaborate discussion). the inductive miner outperforms
the alpha+ miner, which in turn outperforms the heuristics
miner. the results of the kw test conÔ¨Årm that the differences
in average rankings between the four miners are statistically
signiÔ¨Åcant (signiÔ¨Åcance level = 0:05). moreover, the mul-
tiple comparison post-hoc test (cf. supra) also conÔ¨Årms the
statistical signiÔ¨Åcance of the differences between algorithms.
see table 1 in appendix a for a summary of the statistical
test results for the f1scores.
3.2.2 the effect of infrequent paths
the analysis tests whether the presence/absence of infre-
quent paths4has an impact on the average ranking of the
four process discovery techniques for recall, precision and
f1scores. the effect of duplicate activities is part of the
error term.
firstly, the sample is split into two subsets: experiments
with infrequent behavior and experiments without infre-
quent behavior. this division is called blocking (see section 2)
4. infrequent paths are denoted with an imbalance in execution prob-
abilities of the output-branches of each exclusive choice construct in the
model which results in an event log containing infrequent behavior.ieee transactions on knowledge and data engineering 9
table 3: average ranks per miner per probability
(a) average ranks per miner without infrequent behavior
alpha+ heuristics ilp inductive
recall 1196.47 1338.58 262.01 676.93
precision 1063.51 1317.79 485.44 607.26
f1score 1180.24 1338.25 325.71 629.80
(b) average ranks per miner with infrequent behavior
alpha+ heuristics ilp inductive
recall 1162.64 1313.58 242.94 754.85
precision 1088.57 1306.34 523.05 556.04
f1score 1136.22 1310.40 367.71 659.93
which is done to isolate the variation in recall, precision and
f1scores attributable to the absence/presence of infrequent
paths. secondly, the kw test is applied to each subset.
table 3 contains the average rankings per process dis-
covery technique grouped by metric and experiments with
and without infrequent behavior. these rankings suggest
the same order between process discovery techniques in all
cases: ilp>inductive>alpha+>heuristics. this leads
to the assumption that the process discovery techniques
are not inÔ¨Çuenced by the absence or presence of infrequent
behavior. based on the kw and multiple comparison post-
hoc test, only the difference between the ilp and inductive
miner in case of infrequent behavior is not statistically sig-
niÔ¨Åcant for precision (see table 2 in appendix a). therefore,
one cannot accept the assumption that infrequent paths do
not inÔ¨Çuence process discovery techniques.
3.2.3 the effect of duplicate activities
the analysis investigates how the accuracy of each process
discovery technique (in terms of precision, recall and f1
score) is inÔ¨Çuenced by the probability of duplicate activities
(i.e. the average percentage of duplicated visible activity la-
bels in the process models). the effect of infrequent behavior
is part of the error term.
fig. 3a illustrates the average f1scores for all the process
discovery techniques over different probabilities of dupli-
cate activities. this graph indicates a negative trend, i.e. the
probability of duplicate activities has a negative effect on
f1scores. to determine whether such a trend is statistically
signiÔ¨Åcant, an in-depth analysis is performed.
first, the sample is divided into subsets grouped by pro-
cess discovery technique. as such, the variation in accuracy
associated with the discovery technique is isolated. then,
similar to the analysis above, the kw test is applied to
compare the average rankings of the discovered models.
table 4 contains one subtable for each process discovery
technique with the average ranks for all three metrics by the
probability of duplicate activities.
for the alpha+ miner, the data (shown in table 4a)
seems to suggest that as the probability of duplicate ac-
tivities increases, the models generated by alpha+ miner
deteriorate in terms of recall, precision and f1score. to test
this impression statistically, we will rely on the kw and
jonckheere tests. both tests show that there is statisticallytable 4: average ranks of process discovery techniques
per probability duplicate activities
(a) average ranks alpha+ miner per probability duplicate
activities
prob. duplicate0 0.05 0.10 0.15 0.20 0.25 0.30activities
recall 339.47 417.21 428.08 451.02 435.54 479.52 490.66
precision 346.37 421.59 423.21 449.60 431.10 478.01 491.62
f1score 339.46 417.56 427.86 450.78 435.69 479.36 490.78
(b) average ranks heuristics miner per probability duplicate
activities
prob. duplicate0 0.05 0.10 0.15 0.20 0.25 0.30activities
recall 432.08 429.27 435.26 428.28 442.85 437.97 435.79
precision 431.96 429.40 434.90 428.14 442.76 438.51 435.83
f1score 432.04 429.34 435.19 428.27 442.85 438.06 435.75
(c) average ranks ilp miner per probability duplicate activi-
ties
prob. duplicate0 0.05 0.10 0.15 0.20 0.25 0.30activities
recall 466.09 438.65 457.05 462.85 416.74 418.97 381.15
precision 172.53 295.21 369.48 431.76 521.84 604.08 646.60
f1score 185.64 288.92 370.51 430.34 519.42 602.04 644.64
(d) average ranks inductive miner per probability duplicate
activities
prob. duplicate0 0.05 0.10 0.15 0.20 0.25 0.30activities
recall 239.90 339.92 415.75 462.62 492.83 515.94 574.54
precision 241.90 331.42 405.01 478.28 496.85 490.82 597.22
f1score 219.71 339.45 410.69 474.73 500.88 505.77 590.27
signiÔ¨Åcant negative trend in the relative quality of the
generated models as the probability of duplicate activities
increases. a pairwise comparison of each probability of
duplicate activities does not provide a clear picture how this
trend looks like for recall, with many comparisons statisti-
cally insigniÔ¨Åcant. for precision and f1on the other hand,
the quality of the models decreases signiÔ¨Åcantly whenever
the probability of duplicate activities increases from 0% to
more than or equal to 15% (see table 3 in appendix a).
the models discovered using the heuristics miner seem
insensitive to the probability of duplicate activities (see
table 4b). the kw and jonckheere tests conÔ¨Årm that there
is indeed statistically insufÔ¨Åcient evidence of a trend in
recall, precision and f1score as the probability of duplicate
activities increases (see table 4 in appendix a). a possible
explanation will be discussed in section 4.
the results for the ilp miner in table 4c suggest a
positive trend in the probability of duplicate activities in
terms of recall! however, in terms of precision, the ilp
miner shows high sensitivity to the probability of dupli-ieee transactions on knowledge and data engineering 10
(a) duplicated activities
 (b) loops
(c) or
 (d) silent transitions
(e) long-term dependencies
fig. 3:f1scores for process discovery techniques for different probabilities of process control-Ô¨Çow characteristics
cate activities. the kw and jonckheere tests conÔ¨Årm both
statements. the pairwise comparisons of duplicate activities
reveals the signiÔ¨Åcant negative trend in terms of precision
andf1scores of the generated models as the probability of
duplicate activities increases (see table 5 in appendix a).
the Ô¨Åndings for the inductive miner indicate that as
the probability of duplicate activities increases, the model
quality in terms of recall, precision and f1score deterio-
rates. this effect, though, seems to level off as we reach
higher probabilities of duplicate activities. the kw and jon-
ckheere tests show that there is indeed a signiÔ¨Åcant negative
trend in the relative quality of the generated models as the
probability of duplicate activities increases. however, at a
probability of around 15% of duplicate activities, this effect
seems to have reached a plateau and stays stable (see table 6
in appendix a).3.3 extended experiment
the above experiments have validated the usefulness of the
proposed evaluation framework to support the benchmark
and sensitivity analysis evaluation objectives. the proposed
framework is also Ô¨Çexible as it allows users to easily
setup extended experiments. here, we have extended the
above experiment with other control-Ô¨Çow characteristics.
the probability of the basic characteristics, sequence, par-
allel and exclusive choice, is set the same as in the previous
experiments. in this experiment, for each process charac-
teristic, we have varied the probability of its occurrence
while setting the probability of the others to zero. instead
of 3472 observations as in the Ô¨Årst experiment, the extended
experiment results in 17360 observations. an in-depth dis-
cussion of the results as done for the duplicate activities is
not included in this paper due to lack of space. the graphs
in fig. 3 show the average f1score for all the discoveryieee transactions on knowledge and data engineering 11
techniques over different probabilities of inclusion of the
control-Ô¨Çow characteristics. section 4 details a thorough
discussion of the results of this extended experiment, along
with the Ô¨Årst experiment.
4 d iscussion andfuture research
this section discusses the overall results found in the exper-
iments section and describes future research opportunities.
fig. 3 illustrates how the different algorithms score in terms
off1score with varying probability of the constructs.
first, the graphs clearly highlight that ilp and inductive
miner perform signiÔ¨Åcantly better than alpha+ and heuris-
tic miner. in fact, this is not surprising because the latter
two miners are not guaranteed to produce sound models,
which allow executions to be carried out till completion.
models discovered with alpha+ and heuristic miner can
contain deadlocks, livelocks, and other anomalies [1]. when
a model is indeed not sound, it cannot replay traces until
the end and, hence, the confusion matrix may contain few
true positives (often none), causing precision, recall and,
hence,f1scores to be very low (often zero). this is not
trivial because, although the theory already postulated it, it
was not clear how much the lack of soundness guarantee
was practically affecting the results. ultimately this means
that alpha+ miner and heuristic miner can be useful to
gain an initial insight into the general structure of the
process but cannot be used for more mature answers or for
automatically generating models that can be plugged into
a process management system to enforce certain process
behavior.
looking at fig. 3, ilp miner tends to perform better than
inductive miner in terms of f1score. this is observed for all
constructs and all occurrence probabilities. in particular, for
such constructs as silent transitions and long-term depen-
dencies, the f1score is steadily around 1, which indicates
almost perfect precision and recall. this result is far from
being trivial: as discussed [19], the ilp miner focuses on
producing models that can replay every trace of the event
log, without trying to maximize precision. furthermore,
because ilp miner only aims at replaying the traces in
the event log used for discovery, one would expect that a
different event log, used e.g. for testing, would not let the
discovered models score high in recall, either.
the superiority of ilp miner is further supported by
visually comparing the models that ilp generates and those
from the inductive miner, such as the models in figures 4
and 5 respectively discovered through the inductive and ilp
miner. the red boxes in the Ô¨Ågure illustrate the unprecise
parts of the model. for the inductive-miner model, the
transitions in the box can be executed in any order and,
because of the loop, an arbitrary number of time. of course,
in the reality, these transitions should occur in a more
precise order; but the miner is unable to ‚Äúsee it‚Äù. conversely,
for the model discovered through the ilp miner, the only
‚Äúsource of imprecision‚Äù is related to the ‚ÄúÔ¨Çoating transition‚Äù
abut it is just one out of 26 transitions. this does not affect
the precision. as discussed in section 2.2.4, to punish for
imprecise behavior, our framework injects noise into Ô¨Åtting
traces. in case of the mode by the ilp miner, the probability
that the noise would involve the only ‚ÄúÔ¨Çoating transition‚Äù ais low. on the other hand, the probability that noise affects
activities present in precise regions of the model is high.
such deviations in very precise regions are easily detected,
resulting in high f1scores for the ilp miner. the same
reasoning is shared among most of models.
another interesting result for both inductive and ilp
miner is that the values of f1score seem not to be really
affected by the amount of occurrences of the process con-
structs, except for duplicate activities and, limitedly, from
the or construct. the or is known to be a hard construct
and neither of the two miners provides speciÔ¨Åc support
for it (for inductive miner, at least for the version being
evaluated). for duplicate activities, this can be explained by
the fact that both ilp and inductive miner do not natively
support mining models where different transitions share
the same activity label. this means that duplicate activities
are ‚Äúemulated‚Äù through loops and Ô¨Çoating transitions (see
above), which would underÔ¨Åt the behavior observed in the
event log, thereby yielding low precision.
we acknowledge in this paper that the results are also
affected by the fact that training event logs do not contain
noise, namely traces that are not generated by the original,
artiÔ¨Åcial models. as an example, ilp miner tends to be very
sensitive to noise: since it discovers models that are able to
replay every event trace, if the logs contain noise, the dis-
cover models would incorporate behavior that should not
be allowed, thus negatively affecting precision. conversely,
inductive miner would likely be less affected because it
features some noise detection, able to detect whether a trace
is really part of the process or a noise/outlier. this is based
on the frequencies of occurrences of certain patterns in the
traces of the event log [20]. as future work, we aim to
add new ingredients to our analysis and consider a variable
percentage of training-log noise and to study how discovery
algorithms are affected by the amount of noise, in terms of
f1score.
a future interesting extension to our framework is pa-
rameter sensitivity. every miner that we employed in our
experiments can be customized by setting the values of
certain parameters. in this paper, we ruled out the param-
eter sensitivity by using the default parameter values. for
instance, inductive miner can be customized by varying the
threshold of noise detection, also known in the algorithm
as-value, which can vary from zero to one. the model
in fig. 4 was mined with the default -value, which is
0.2, leading to a f1score of 0.25. for the speciÔ¨Åc case,
we manually reduced to 0, thus not supporting noise
detection. this led to an increase of f1till a clearly better
0:67, which is due to the fact that, as mentioned, the training
logs do not contain noise.
however, we believe that not addressing these aspects
do not invalidate the arguments stated in this paper. while it
is easy to accommodate them in the framework, the current
experiments can illustrate that our analysis framework does
already properly address the research objectives stated in
section 1. first, even though we always translate the discov-
ered models to petri nets, it was related to the fact that the
available conformance checker requires it. our framework
is modelling notation independent and as such there is
nothing that is speciÔ¨Åc for petri nets. second, the results
are based on a statistically-signiÔ¨Åcant sample of models andieee transactions on knowledge and data engineering 12
fig. 4: model discovered by the inductive miner
fig. 5: model discovered by the ilp miner
event logs from a population with several characteristics,
which make the results generally valid.
5 r elated work
several frameworks for evaluating process discovery algo-
rithms have been proposed. rozinat et al. [28] introduced
the Ô¨Årst evaluation framework, wang et al. [29] and ribeiro
et al. [30], [31] extended the rozinat framework to evaluate
and predict the best algorithm. weber et al. [32] proposed an
alternative framework that takes a probabilistic perspective.
in addition to the evaluation frameworks, de weerdt et
al. [5], vanden broucke et al. [33], [34] and augusto et al. [35]
performed benchmarking studies of process discovery tech-
niques.as indicated in section 1, our framework evaluates the
quality of models on the basis of measures of precision and
recall that are not bound to any modelling notation. con-
versely, the existing body of research is based on metrics that
are applicable to one notation, mostly petri net [5], [6], [28],
[29], [30], [31], [32], [33], [34], [35]. this means that, not only
would one need to introduce a new conformance checker
for the new notation, but also one would need to redeÔ¨Åne
the precision and recall metrics. the introduction of a new
conformance checker is also necessary in our framework
and it cannot be prevented because it is necessary that the
checker is aware of the replaying semantics of the notation.
section 1 also indicated that the second and third advan-
tage of our framework is that it is based on the generation of
a sufÔ¨Åciently-large number of artiÔ¨Åcial models to guarantee
a statistical validity of the analysis. conversely, the existing
frameworks base their conclusions on samples that are
small, either a few real-life event logs [5], [30], [35], either
artiÔ¨Åcial but not randomly generated [5], [28], [29], [30], [31],
[32], [33], thus limiting the statistical validity of the analysis.
also, the artiÔ¨Åcial process models are not generated by con-
trolling the probability of certain constructs to be present.
this means that the event logs generated from these models
do not allow one to evaluate the correlation between the
quality of the discovered models and the presence of certain
process constructs.
furthermore, all frameworks, except weber et al. [32],
leverage on the typical process-mining notions of precision,
generalization and Ô¨Åtness from literature to evaluate the
quality of the discovered models (see, e.g., [1]). there is a
clear correlation between the precision and recall that we
employ and the typical process-mining measures of model
quality. however, the process-mining measures are de-
signed considering that the real process model is not known
and that one only observes the positive cases, namely the
traces that are part of the real process. the negative cases,
i.e. the executions/traces that do not Ô¨Åt the real process,
are not known because they would require to know the
real model. therefore the process-mining measures of model
quality try to artiÔ¨Åcially generate the negative cases based
on estimation and, hence, the measure results are estimates
(see, in this respect, also [36]). since we know the realieee transactions on knowledge and data engineering 13
process model, we can generate both positive and negative
traces and label them correctly. this leads to metric results
that are certain and, hence, accurate.
the frameworks reported in [16], [23] are clearly not the
only to generate process models and event logs. while the
framework would allow one to plug different model and
log generators, the choice has fallen onto those frameworks
because they provide an api that allows one to invoke them
from code, as our scientiÔ¨Åc workÔ¨Çow requires. for example,
plg [37] only allows a gui interaction; also, plg does not
support certain patterns, namely long-term dependencies,
silent transitions and duplicate activity labels.
finally, the classiÔ¨Åcation approach of the proposed eval-
uation framework builds upon established principles and
methods from the machine learning domain. see [38] for
more information on the empirical evaluation of learning
algorithms using a classiÔ¨Åcation perspective.
6 c onclusions
many process discovery algorithms have been proposed in
recent years. as a result the evaluation of process discovery
techniques to decide which technique performs best on a
given event log has gained importance. however, existing
evaluation frameworks have several important drawbacks.
this paper presented a new evaluation framework to
overcome existing limitations. the new framework is in-
dependent from the discovered model‚Äôs modeling notation
by adopting a classiÔ¨Åcation approach. it starts by deÔ¨Åning
a population of process models using different behavioral
characteristics. from this population a set of models and
event logs is randomly sampled. using a 10-fold cross-
validation approach, the event logs are split into training
and test logs. then the framework adds noise to half of
the test traces to generate non-Ô¨Åtting traces. the discovery
algorithm learns a model based on the training log and
classiÔ¨Åes the test traces as Ô¨Åtting or non-Ô¨Åtting. the frame-
work then combines the classiÔ¨Åcation results in a confusion
matrix together with the metrics recall, precision and f1
score. these metrics are the input for the Ô¨Ånal statistical
tests that are used to determine whether signiÔ¨Åcant differ-
ences between algorithms exist or whether certain model or
log characteristics have a signiÔ¨Åcant effect on algorithm‚Äôs
performance.
the framework is designed as a scientiÔ¨Åc workÔ¨Çow.
the workÔ¨Çow is then implemented in the rapidminer tool
so that evaluation experiments can be automated, shared
between researchers and extended to include new dis-
covery techniques. the framework allows researchers to
benchmark discovery algorithms as well as to perform a
sensitivity analysis to evaluate whether certain model or
log characteristics have a signiÔ¨Åcant effect on algorithm‚Äôs
performance.
the framework has been validated by conducting an
extensive experiment involving four process discovery al-
gorithms, Ô¨Åve control-Ô¨Çow characteristics and two levels of
infrequent behavior. the experiment has shown the useful-
ness and Ô¨Çexibility of the framework. additionally, future
research opportunities were identiÔ¨Åed.references
[1] w. van der aalst, process mining: data science in action . springer,
2016.
[2] r. agrawal, d. gunopulos, and f. leymann, ‚Äúmining process
models from workÔ¨Çow logs,‚Äù in advances in database technology
- edbt ‚Äô98 , h. j. schek, f. saltor, i. ramos, and g. alonso, eds.,
vol. 1377. springer-verlag berlin heidelberg, 1998, pp. 467‚Äì483.
[3] q. shao, y. chen, s. tao, x. yan, and n. anerousis, ‚ÄúefÔ¨Åcient ticket
routing by resolution sequence mining,‚Äù in proceedings of the 14th
acm sigkdd international conference on knowledge discovery and
data mining . acm, 2008, pp. 605‚Äì613.
[4] w. gaaloul, s. bhiri, and c. godart, ‚Äúdiscovering workÔ¨Çow trans-
actional behavior from event-based log,‚Äù in coopis/doa/odbase
(1). springer, 2004, pp. 3‚Äì18.
[5] j. de weerdt, m. de backer, j. vanthienen, and b. baesens, ‚Äúa
multi-dimensional quality assessment of state-of-the-art process
discovery algorithms using real-life event logs,‚Äù information
systems , vol. 37, no. 7, pp. 654‚Äì676, nov. 2012.
[6] a. bolt, m. de leoni, and w. m. van der aalst, ‚ÄúscientiÔ¨Åc
workÔ¨Çows for process mining: building blocks, scenarios, and
implementation,‚Äù software tools for technology transfer , vol. 18,
no. 6, p. 22, 2016.
[7] a. barker and j. van hemert, ‚ÄúscientiÔ¨Åc workÔ¨Çow: a survey
and research directions,‚Äù in parallel processing and applied
mathematics . springer, 2007, pp. 746‚Äì753.
[8] r. e. kirk, experimental design . wiley online library, 1982.
[9] t. mcphillips, s. bowers, d. zinn, and b. ludscher, ‚ÄúscientiÔ¨Åc
workÔ¨Çow design for mere mortals,‚Äù future generation computer
systems , vol. 25, no. 5, pp. 541‚Äì551, may 2009.
[10] w. m. p . van der aalst, a. j. m. m. weijters, and l. maruster,
‚ÄúworkÔ¨Çow mining: discovering process models from event
logs,‚Äù ieee transactions on knowledge and data engineering , vol. 16,
no. 9, pp. 1128‚Äì1142, sept 2004.
[11] a. j. m. m. weijters and w. m. p . van der aalst, ‚Äúrediscovering
workÔ¨Çow models from event-based data using little thumb,‚Äù
integrated computer-aided engineering , vol. 10, no. 2, pp. 151‚Äì162,
2003.
[12] s. r. a. fisher, the design of experiments . oliver and boyd
edinburgh, 1960, vol. 12, no. 6.
[13] d. voss and others, design and analysis of experiments . new
york: springer, 1999.
[14] n. russell, a. h. m. ter hofstede, w. m. p . van der aalst, and
n. mulyar, ‚ÄúworkÔ¨Çow controlÔ¨Çow patterns: a revised view,‚Äù
tech. rep. 06-22, 2006.
[15] w. van der aalst, j. buijs, and b. van dongen, ‚Äútowards improving
the representational bias of process mining,‚Äù in international sym-
posium on data-driven process discovery and analysis . springer,
2011, pp. 39‚Äì54.
[16] t. jouck and b. depaire, ‚Äúptandloggenerator: a generator for
artiÔ¨Åcial event data,‚Äù in proceedings of the bpm demo track
2016 (bpmd 2016) , vol. 1789. rio de janeiro: ceur workshop
proceedings, 2016, pp. 23‚Äì27.
[17] l. maruster, ‚Äúa machine learning approach to understand
business processes,‚Äù ph.d. dissertation, technische universiteit
eindhoven, eindhoven, 2003.
[18] a. kalenkova, m. de leoni, and w. m. p . van der aalst, ‚Äúdis-
covering, analyzing and enhancing bpmn models using prom,‚Äù
inproceedings of the bpm demo sessions 2014 co-located with the
12th international conference on business process management (bpm
2014), eindhoven, the netherlands, september 10, 2014. , ser. ceur
workshop proceedings, vol. 1295. ceur-ws.org, 2014, p. 36.
[19] s. j. van zelst, b. f. van dongen, w. m. p . vander aalst, and
h. m. w. verbeek, ‚Äúdiscovering workÔ¨Çow nets using integer linear
programming,‚Äù computing , 2017, to appear. doi: 10.1007/s00607-
017-0582-5.
[20] s. j. j. leemans, d. fahland, and w. m. p . van der aalst,
‚Äúdiscovering block-structured process models from event logs -
a constructive approach,‚Äù in application and theory of petri nets
and concurrency , ser. lecture notes in computer science, j.-m.
colom and j. desel, eds. springer berlin heidelberg, 2013, vol.
7927, pp. 311‚Äì329.
[21] f. mannhardt, m. de leoni, h. a. reijers, and w. m. p .
van der aalst, ‚Äúbalanced multi-perspective checking of process
conformance,‚Äù computing , vol. 98, no. 4, pp. 407‚Äì437, 2016.
[22] a. rozinat and w. m. p . van der aalst, ‚Äúconformance checking
of processes based on monitoring real behavior,‚Äù information
systems , vol. 33, no. 1, pp. 64‚Äì95, 2008.ieee transactions on knowledge and data engineering 14
[23] t. jouck and b. depaire, ‚Äúsimulating process trees using
discrete-event simulation,‚Äù hasselt university, technical report,
feb. 2017.
[24] m. kunze, a. luebbe, m. weidlich, and m. weske, ‚Äútowards
understanding process modeling - the case of the bpm academic
initiative,‚Äù in international workshop on business process modeling
notation . springer, 2011, pp. 44‚Äì58.
[25] f. faul, e. erdfelder, a. buchner, and a.-g. lang, ‚Äústatistical
power analyses using g* power 3.1: tests for correlation and
regression analyses,‚Äù behavior research methods , vol. 41, no. 4, pp.
1149‚Äì1160, 2009.
[26] g. janssenswillen, b. depaire, and t. jouck, ‚Äúcalculating the
number of unique paths in a block-structured process model,‚Äù in
proceedings of the international workshop on algorithms & theories
for the analysis of event data 2016 , 2016.
[27] s. siegel and n. j. castellan jr, nonparametric statistics for the behav-
ioral sciences , 2nd ed. new york: mcgraw-hill book company,
1988.
[28] a. rozinat, a. a. de medeiros, c. w. gnther, a. weijters, and
w. m. van der aalst, ‚Äútowards an evaluation framework for
process mining algorithms,‚Äù bpm center report , vol. 0706, 2007.
[29] j. wang, r. k. wong, j. ding, q. guo, and l. wen, ‚ÄúefÔ¨Åcient
selection of process mining algorithms,‚Äù services computing,
ieee transactions on , vol. 6, no. 4, pp. 484‚Äì496, 2013.
[30] j. ribeiro, j. carmona, m. msr, and m. sebag, ‚Äúa recommender
system for process discovery,‚Äù in business process management ,
ser. 8659. springer, 2014, pp. 67‚Äì83.
[31] j. ribeiro and j. carmona, ‚Äúa method for assessing parameter
impact on control-flow discovery algorithms.‚Äù wil van der
aalst, robin bergenthum, josep carmona, jun. 2015.
[32] p . weber, b. bordbar, and p . tino, ‚Äúa framework for the analysis
of process mining algorithms,‚Äù ieee transactions on systems,
man, and cybernetics: systems , vol. 43, no. 2, pp. 303‚Äì317, 2013.
[33] s. k. vanden broucke, c. delvaux, j. freitas, t. rogova,
j. vanthienen, and b. baesens, ‚Äúuncovering the relationship
between event log characteristics and process discovery
techniques,‚Äù in business process management workshops . springer,
2014, pp. 41‚Äì53.
[34] s. k. l. m. vanden broucke and j. de weerdt, ‚Äúfodina: a robust
and Ô¨Çexible heuristic process discovery technique,‚Äù decision
support systems , vol. 100, no. supplement c, pp. 109‚Äì118, aug.
2017.
[35] a. augusto, r. conforti, m. dumas, m. la rosa, f. m. maggi,
a. marrella, m. mecella, and a. soo, ‚Äúautomated discovery
of process models from event logs: review and benchmark,‚Äù
arxiv:1705.02288 [cs] , may 2017, arxiv: 1705.02288.
[36] s. k. l. m. vanden broucke, j. de weerdt, b. vanthienen,
jan, and b. baesens, ‚Äúdetermining process model precision
and generalization with weighted artiÔ¨Åcial negative events,‚Äù
knowledge and data engineering, ieee transactions on , vol. 26,
no. 8, pp. 1877‚Äì1889, 2014.
[37] a. burattin, ‚Äúplg2: multiperspective process randomization with
online and ofÔ¨Çine simulations,‚Äù in proceedings of the bpm demo
track 2016 co-located with the 14th international conference on busi-
ness process management (bpm 2016), rio de janeiro, brazil, septem-
ber 21, 2016. , ser. ceur workshop proceedings, vol. 1789. ceur-
ws.org, 2017, pp. 1‚Äì6.
[38] n. japkowicz and m. shah, evaluating learning algorithms: a
classiÔ¨Åcation perspective . cambridge university press, 2011.
[39] m. hofmann and r. klinkenberg, rapidminer: data mining use
cases and business analytics applications . crc press, 2013.
toon jouck received the m.sc. degree busi-
ness and information systems engineering at
hasselt university, belgium. he is currently a
ph.d. candidate in the department of busi-
ness informatics, hasselt university, and his cur-
rent research interests include business process
mining and management, data analytics and ex-
perimental design.
alfredo bolt received the m.sc. degree in com-
puter science at pontiÔ¨Åcia universidad catolica
de chile, chile. he is currently a ph.d. can-
didate in the department of mathematics and
computer science at the technische universiteit
eindhoven (tu/e), the netherlands. his current
research interests include process cubes, pro-
cess comparison and process mining workÔ¨Çows.
benoÀÜ ƒ±t depaire is an associate professor at
hasselt university, belgium. he has authored
and co-authored numerous papers published in
international journals and conference proceed-
ings. his current research interests include busi-
ness process management, experimental de-
sign, process simulation and it -business mod-
els. his aim is to gain empirically-validated in-
sights from process-related data to understand
and improve business processes.
massimiliano de leoni massimiliano de leoni
is an assistant professor of computer science
at the technische universiteit eindhoven (tu/e),
the netherlands. he is constantly publishing pa-
pers for the major conference venues and high-
reputation journals in business process man-
agement and information systems. his research
interests are in the area of process-aware
information systems and business process
management, predominantly focusing on multi-
perspective process mining, process-aware de-
cision support systems and olap-based process-mining techniques.
wil van der aalst prof.dr.ir. wil van der aalst
is a professor at aachen. his research interests
include process mining, petri nets, business pro-
cess management, workÔ¨Çow management, pro-
cess modeling, and process analysis. wil van
der aalst has published over 200 journal papers,
20 books (as author or editor), 450 refereed
conference/workshop publications, and 65 book
chapters. he is also an elected member of the
royal netherlands academy of arts and sci-
ences, the royal holland society of sciences
and humanities, and the academy of europe.