conformance checking using cost-based fitness analysis
a. adriansyah, b.f. van dongen, w.m.p. van der aalst
department of mathematics and computer science
technische universiteit eindhoven
p .o. box 513, 5600 mb eindhoven, the netherlands
email: {a.adriansyah,b.f.v.dongen,w.m.p.v.d.aalst }@tue.nl
abstract —the growing complexity of processes in many or-
ganizations stimulates the adoption of business process analysistechniques. typically, such techniques are based on processmodels and assume that the operational processes in realityconform to these models. however, experience shows thatreality often deviates from hand-made models. therefore, theproblem of checking to what extent the operational processconforms to the process model is important for process man-agement, process improvement, and compliance.
in this paper, we present a robust replay analysis technique
that is able to measure the conformance of an event log for agiven process model. the approach quanti ﬁes conformance and
provides intuitive diagnostics (skipped and inserted activities).
our technique has been implemented in the prom 6
framework. comparative evaluations show that the approachovercomes many of the limitations of existing conformancechecking techniques.
keywords -business process management, ﬁtness analysis,
conformance checking, process mining, business process anal-ysis
i. i ntroduction
as business processes become more complex and change
frequently, reliable process models become more important.such models are used to document business processes or to
conﬁgure the information system. moreover, process models
are used to analyze processes, e.g., to check conformance orto evaluate the performance of business process redesigns.
however, many studies show that models often deviate
from reality (cf. [11]–[13]). process models can be obsolete,outdated, idealized, or simply disconnected from reality [15].
hence, before any sort of analysis is applied to process mod-
els, it is imperative to know how well reality conforms tothe model and vice versa. legislation such as the sarbanes-
oxley act, basel ii, and hipaa, illustrate the importance
of a good alignment between the real process and its model.moreover, many organizations seek a balance between ﬂexi-
bility (people can deviate from the standard way of working)
and control (deviations need to be monitored and acted
upon if needed). therefore, the importance of conformance
checking is increasing.
conformance checking measures how “good” a model
of a process is with respect to an event log that records
the executions of the process. in this paper, we focus on
theﬁtness dimension of conformance [13], [17]. fitnessmeasures the extent process models capture the observed
behavior as recorded in event logs. given a process model
and a sequence of activities from a log showing the execution
of a process instance, the ﬁtness of a trace is high (i.e. good)
if the same sequence of activities (or a very similar one) isallowed by the model.
event logs may not necessarily contain all the activities
executed– logging everything might be costly and affect
the performance of process executions. still, the unlogged
activities can in ﬂuence process behavior. identifying such
unobservable activities in event logs is important in mea-
suring ﬁtness, as mistakes in doing so may lead to false-
negative results.
given a process model and an event log, deviations in
theﬁtness dimension manifest as either skipped orinserted
activities. skipped activities refer to activities that should
be performed according to the model, but do not occur inthe log. in contrast, inserted activities refer to activities that
occur in the log, but should not happen according to the
model.
in reality, the severity of skipping/inserting activities may
depend on characteristics of the activity, e.g., some activities
may be skipped without severe problems while the insertionof an important activity may lead to signi ﬁcant problems.
take for example a typical process of handling insurance
claims in an insurance company, shown as a petri net infigure 1. in cases where the amount of claim is relatively
small, “check documents” or “check cause” activities are
often skipped. nevertheless, the severity of skipping these
activities is less than the severity of skipping essential
activities, such as “send money”. another example; in caseswhere the claimed amount is large, double checking on the
start
register
check causedecide
inform rejection archivecheck documents
inform acceptance
endsend money
figure 1. a petri net describing an insurance claim handling processclaims is often performed, which leads to inserted executions
of “check documents” or “check cause” not possible in the
model. although multiple executions of the two activitiesare also deviations, their severity to the overall process is
small compared to multiple executions of “send money”.
classical techniques that measure ﬁtness (e.g. [13]) penal-
ize conformance for existence of either skipped or inserted
activities. however, heuristics often result in incorrect esti-mations of ﬁtness. moreover, they do not consider the dif-
ferent severities of skipping/inserting the different activities.
as a result, the ﬁtness does not correspond to the perceived
degree of conformance.
in this paper, given a process model and an event log, we
propose a cost-based replay technique that measure ﬁtness
and taking into account the cost of skipping and inserting
individual activities. the technique is based on the 
∗
algorithm and can be tailored to answer speci ﬁc questions
(e.g. does the log conforms to the model? which activitiesare often skipped? are there any inserted activities in the
log?). section ii introduces the basic concepts needed to
understand this paper. the idea to measure ﬁtness based on
skipped and inserted activities is provided in section iii.
we propose an 
∗-based approach to measure the ﬁtness in
section iv. experimental results are discussed in section vi,
and related work is discussed in section vii. section viii
concludes the paper. for proofs of the theorems presentedin this paper, as well as a more detailed analysis of the
experiments, we refer to [2].
ii. b
asic concepts
our ﬁtness calculation uses the ∗algorithm [6], an
algorithm originally invented to ﬁnd a shortest path between
two nodes in a directed graph with arc costs. hence, weformalize a graph with arc costs and related concepts.
denotes the set of natural numbers . we write afor
theuniverse of activity names ,⊆afor a set of activities,
and6∈afor unobservable activities (i.e., activities in the
model not recorded in the event log).
letb eas e t .f o r( ﬁnite) sequences of elements over a
setwe use the following notation: the empty sequence
is denoted with ; a non-empty sequence is given by listing
its elements between angled brackets. a concatenation of
sequences 
1and2is denoted with 1·2and we use 
to denote shorter sequences, i.e. 1 2i fa n do n l yi ft h e r e
is a sequence 36=with2=1·3.∗denotes the set
of all ﬁnite sequences over and+=∗\{}. we refer
to the-th element of a sequence asand we use ||
to represent the length of the sequence . the projection
of a sequence ∈∗on⊆is denoted as ↓, e.g.,
h i↓{}=h i.w es a yt h a t is apreﬁxof0
if and only if 0.
abagoveris a mapping :→.w eu s e
+and−for the sum and the difference of two bags and
=≤≥for comparison of bags, which are de ﬁned inthe standard way. we overload the set notation, writing ∅for
the empty bag and ∈for the element inclusion. we write e.g.
=2 []+[]for a bag with()=2 ,()=1 ,a n d
()=0 for all6∈{}.a su s u a l , ||stands for the
total number of elements in bag (e.g. |2[]+[]|=3).
deﬁnition ii.1. (directed graph with arc cost) a directed
g r a p hw i t ha r cc o s t si sat u p l e =( )whereis
a set of nodes, ⊆×is a set of directed arcs, and
:→is a function assigning non-negative costs to
arcs.
let∈,w ed e n o t et h es e to f successor nodes of node
as•={0∈|(0)∈}and the predecessor
nodes of nodeas•={0∈|(0)∈}. we omit
the superscript if the context is clear.
apath fromto0∈i sas e q u e n c eo fe d g e s
h(12)(23) (−1)i∈+where1=∧
=0holds. by ã0we denote that a path from
to0exists (we omit the superscript if the context is
clear). we say that is an acyclic graph if∀∈6ã
holds. the set of all possible paths from to0is denoted
byb(0)⊆∗.w ea l s od e ﬁne a path cost function
b:∗→that returns the cost of a path where
b()=p||
=1().
deﬁnition ii.2. (the a∗algorithm) let=( )be
a directed graph with distances associated to arcs. let ∈
be a source node and let ⊆(\{})be a set of
target nodes in .t h e∗algorithm returns a path ∈
b()with the smallest distance from the source
node to one of the target nodes where ∈.h e n c e ,
∀∈@0∈(b()\{})b(0)b()holds.
the target node is also called the preferred target node.
the algorithm works by iteratively exploring successors
of nodes, starting from the source node .l e t∈
b ean o d ei n and let∈b()be the path with
the smallest distance so far from to, the algorithm
relies on an evaluation function()=()+(),w h e r e
:→is a function that returns the smallest distance of
paths from the source node to(so far), and :→
is a heuristic function that underestimates the distance of
path from any node to its preferred target node ∈.
to determine which visited node whose successors are
going to be explored in the next iteration, the algorithmcalculates the distance of every node whose successors
haven’t been explored yet, using an evaluation function
:→. then, it selects the one that has the minimal
distance. the iteration stops under two conditions: either a
node that is a member of 
is selected as the node to
be explored in the next iteration (implies that we get the
solution path), or there is no other nodes to be explored
( i m p l i e st h a tn op a t ht oa n yt a r g e tn o d e se x i s t s ) .
as long as the heuristic function returns a value
that underestimates the distance of a path from a nodeto its preferred target node and the evaluation function is
increasing with the increasing number of visited nodes, the
∗algorithm is guaranteed to ﬁnd a path with the smallest
distance [6].
measuring ﬁtness requires an event log and a process
model. we formalize event logs, process models, and related
concepts as follows:
deﬁnition ii.3. (event logs) an event log over a set of
activities is deﬁned as=( â), where:
•is aﬁnite set of events,
•is aﬁnite set of cases (process instances),
•:→is a function relating each event to an
activity,
•:→is a surjective function relating each event
to a case.
•â⊆×imposes a total ordering on the events in
. we write 2â1as a shorthand to (21)∈â.
in reality, cases are executed independently from each
other. for example, in an insurance company, the way a
claim is handled does not directly in ﬂuence how other claims
are handled. therefore, events of a case are often treated
independently from events of other cases. let ∈be a
case identi ﬁer. with,w ed e n o t et h e events of case ,i . e .
=h1 ||iwhere∀∈(()=)⇔(∈),
furthermore ∀1≤≤||â.
a process model typically describes a set of activities that
have to be performed and their ordering. many languages
are used to model business process, like epc and bpmn1.
in this paper, we use petri nets [10] to model processes,
however, our approach is applicable to any kind of model,
as long as it can be decided if a given execution is a valid
one (there is no need to be able to decide which activities
can occur in the future, only if a given activity could haveoccurred at a given point in time).
deﬁnition ii.4. (petri net) a petri net over a set of
activities is a tuple =( ),w h e r eand
is a set of places and transitions, respectively, ⊆(×
)∪(×)is a set of directed arcs connecting places
and transitions, :→∪{}is a function mapping
transitions to either activities or (unobservable activities),
such that ∀
∈∃∈()=. note that any net is also
a directed graph (∪ )where∀∈()=1 .
a marking ofis a bag over ,i n d i c a t i n gt h es t a t e
of. a transition ∈can be executed (i.e. ﬁred) from
markingif and only if ≥•. firing transition resulted
in a new marking 0where0def=−•+•.w ed e n o t e
this relation between and0as−→0.as e to f
runs offrom marking 0is a set of all sequences of
transitions r⊆∗where for all h1i∈r,01−→
112−→2 −1−→hold.
1business process modeling notation, see http://www.bpmn.org/a b x y cτ
figure 2. a petri net for running example
iii. i deal cost -based replay
g i v e na ne v e n tl o g =( â)and a petri net
=( )with initial marking 0,e v e n t so fc a s e ∈
ﬁt the net if the sequence of activities that is constructed
by mapping each event of the case to an activity can also
be constructed by mapping each transition of a run of the
n e tt oa na c t i v i t y .w ed e ﬁne formally a ﬁtting set of events
of a case as follows:
deﬁnition iii.1. (perfect ﬁt)let=( )be a
petri net over a set of activities with an initial marking
0.l e tr⊆∗be the set of all possible runs of starting
in0.l e t=( â)be an event log over .
let∈b eac a s ea n dl e t be the sequence of events
of case.
ﬁtsif there exists a run ∈rsuch that ()↓=
(), where we lift the use of andto sequences2.
take for an example a petri net in fig. 2. both cases
1
=h iand2
=h iperfectly ﬁtt h e
net according to def. iii.1. the case 3
=h i,
does not ﬁt to the model, since any run in the model will
containafter.
unfortunately, in practice, knowing whether a case is devi-
ating or not is not useful for further analysis. in cases where
deviations occur, such as the case 3
, it is more important
to know the extent of the deviations, and furthermore why
they occur.
to measure the extent of deviations, ﬁtness is best mea-
sured on a per-event basis. from section i, we know thatthere are two possible causes of deviations: skipping or
inserting activities. therefore, the ideal ﬁtness calculation
should penalize ﬁtness value based on the existence of each
of these two types of deviations. however, identifying such
a c t i v i t i e si sn o tt r i v i a l .c o n s i d e rt h en e ti nf i g .2a n dt h e
case
3
. the case can be interpreted as one of the following:
is inserted in the event log, is skipped in the model,
oris inserted in the log (removing results in a ”good”
preﬁx).
as mentioned in section i, the cost of skipping and
inserting activities can be different for individual activities.
therefore, we assume the existence of cost functions thatreturn the cost of skipping as well as inserting activities. we
deﬁne cost function 
:→that returns non-negative
cost of inserting extra activities in the log, and another cost
2let=h1 ibe a sequence over some set and let
:→be a function from to some set ,t h e n()=
h(1) ()i.function:∪{}→that returns non-negative cost
of skipping transitions in the model (including the unlabeled
ones). these functions need to be determined by processexperts.
when identifying the deviations between cases in the log
and processes, we assume that we are interested in the actual
execution of which the costs of deviation are minimal. thus,
suppose that the cost functions for activities involved in the
net in fig. 2 are de ﬁned as follows: 
()=()=
()=1()=1 0()=5()=()=
()=1()=3()=1 0()=0 .f o r
case3
, the cost of either inserting or inserting is
higher than the cost of skipping (i.e.()()
and()()), hence the deviation in the case most
likely occurred because activity was skipped (hence the
case should have been h i).
considering cost functions and both skipped and inserted
activities, we de ﬁne our ﬁtness metric as follows:
deﬁnition iii.2. (cost-based ﬁtness metric) let=
( )be a petri net over a set of activities with an
initial marking 0.l e tr⊆∗be the set of all possible
runs ofstarting in 0.l e t=( â)be an
event log over .l e t∈b eac a s ea n dl e t be the
sequence of events of case .l e tandbe the cost
functions for skipping and inserting activities respectively.
assuming that skipped activities in the case are identi ﬁed
as a bag over∪{}, and all inserted activities,
manifested as events, are identi ﬁed as a set ⊆,w e
deﬁne a ﬁtnessas one minus the ratio between the total
cost of having inserted/skipped activities and the total cost
of considering all events as inserted activities, i.e.
=1−p
∈()×()+p
∈(())p
∈(())
the intuition behind the metric is that ﬁtness value should
decrease as more activities are inserted/skipped. in the worstcase, given a process model and a set of events of a case,
all of the events can be considered as inserted activities.
the cost of such extreme case is used to normalize ourﬁtness metric. note that due to the absence of information
about skipped activities in the log, one can assume as many
skipped activities as allowed by the model. in case there is a
large number of skipped activities, (e.g., in a loop executed
repeatedly ) may become negative. however, the “best
run” has a value between 0 and 1.
the cost functions 
anddeﬁned above are an
important contribution of this paper. by providing the user
with options to change these parameters, the user can specifywhat he thinks is more problematic. for example, by giving
relatively low costs to skipping activities, the user can
specify that an activity that should be executed in the modelbut cannot be found in the log should be considered as
being executed anyway, while a high value indicates that
this transition indeed did not happen.the ﬁtness metric de ﬁn e di nd e f .i i i . 2a s s u m e st h a t
skipped and inserted activities are known in advance. in this
paper, we are interested in ﬁnding inserted/skipped activities
that give minimal cost such that the highest possible ﬁtness
value is obtained. we describe our approach to identify such
activities in section iv.
iv. i
dentify skipped and inserted activities
a case in an event log ﬁts a petri net if each events
performed in the case can be mimicked by ﬁring a transition
in the net that refers to the same activity as the event, eitherdirectly from the current state of the net or indirectly after
ﬁring sequence of -labeled transitions from the current
state. skipped activities should only be introduced when
according to the model, a transition that should be able
to mimic an event cannot be ﬁred without ﬁring non- -
labeled transitions. only in cases where the cost of skipping
activities is higher than the cost to assume that an event
under consideration is inserted, we consider the event torepresent an inserted activity.
therefore, ﬁnding both skipped and inserted activities in
a given case can be formulated as a problem of constructing
the best matching instance of a given net based on the events
of the case. a set of events of a case ﬁts a petri net (i.e. all
e v e n t sc a nb eg e n e r a t e db yt h en e t )i fa n do n l yi ft h e r ei sa n
instance of the net matching the events in which each non-
transition instance represents an event and partial order
between events is honored by transition instance. we usethe standard de ﬁnition of an instance of petri net (sometimes
referred to as occurrence net [9]) since a run of a net does
not capture causal dependencies and concurrencies. this isa standard concept in petri nets, therefore we simply use it
without explaining it in detail.
deﬁnition iv .1. (instance of petri net) let =
( )be a petri net over a set of activities with
an initial marking 
0.l e t=(pitifi0
0)be a
tuple where is a set of place instances, is a set of
transition instances, ⊆(×)∪(×)is a set
of edge instances, :→is a function mapping place
instances to places in ,:→is a function mapping
a ba b x y cτpetri net
(i)
(iii)(ii)instances of the net
a bτ
a b x y
figure 3. examples of instances of a given petri nettransition instances to transitions in ,a n d0
0is a bag of
that indicates the initial marking of .
is an instance ofif and only if the following holds:
•for all ()∈,i f∈then (()())∈,
else (()())∈,
•for all∈,induces a bijection from •to•()
and from •to()•
•∀∈0
0()≤1∧|•|≤1∧|•|≤1
•for all∈,•=∅i fa n do n l yi f 0
0()=1 ,
•∀∈p
∈ ()=0
0()=0()
•the transitive closure of is irre ﬂexive, i.e. it is a
partial order over ∪
note that when we consider petri net instances, we gener-
ally consider their equivalence classes, i.e. two instances are
equivalent if their exists a graph isomorphism that respects
the mapping functions. furthermore, we use ↓to denote the
projection of an instance onto a subset of its transitions, i.e.
↓0with0⊆is the same petri net as ,b u t
without the transition instances not in 0, without the arcs
connected to these transitions and without any disconnected
places.
figure 3 shows some possible instances of the petri
net given in fig. 2. as shown in figure 3, there are no
conﬂicts/choices in an instance. places and transitions need
to be on a path starting on one of the initially marked places.
when a set of events is replayed on a petri net, we
iteratively construct instances from its pre ﬁxes. for each pair
consisting of a pre ﬁx and a constructed instance, we match
events in the pre ﬁx (possibly partial) to transition instances
that refer to the same activities. matched events correspond
toﬁrings of transitions. events in the pre ﬁx without any
match indicate inserted activities because they happened in
reality, but should not happen according to the net. non- -
labeled transition instances in the petri net instance that are
not associated with any events represent skipped activities
as they should be performed according to the net, but werenot performed in reality.
given a pre ﬁx of a case, an instance of a petri net with a
function matching events in the pre ﬁx to transition instances
is said to be matching the pre ﬁx.
deﬁnition iv .2. (instance matching a pre ﬁx)let
=
( â)be an event log over a set of activities .
let∈be a case identi ﬁer. letbe the sequence
of events of case .l e t0b eap r e ﬁxo f.l e t=
( )b eap e t r in e to v e r with initial marking 0,
and let=(pitifi0
0)be an instance of .
let:09be a partial function mapping events to
transition instances such that induces a bijection from its
domain (dom ()⊆0) to its range (rng ()⊆). we
saymatches0with match if and only if:
1)∀12∈dom ()(1)ã(2)⇒1â2,i . e .t h eo r -
dering of events is in the pre ﬁx is respected in the
instance, anda b
prefix e’ = <a,b> prefix e’ = <a,b>(i) (ii)
(iii)a b
(iv)a b x
a b x y (v) ca b x y cτ
event log la= (e, c, α,   ,    ) , case c ∈c,
events of c, defined as ec = <a,b,x,c>
petri net
skipped
inserted
prefix e’ = <a,b,x>
a bτ
c
prefix e’ = <a,b,x,c>
inserted
prefix e’ = <a,b,x,c>skippedlegend
skipped activities
inserted activities
valid activities
figure 4. example of matching instances, given a petri net and a set of
events of a case
2)∀∈dom ()(())∈{∈|()=()},i . e .
each event mapped by in the pre ﬁxi sm a p p e dt oa
transition that corresponds to the activity represented
by this event.
we use (0)to denote a tuple consisting of an arbitrary
instancethat matches pre ﬁx0with match , and we use
=0to denote the (possibly in ﬁnite) set of all tuples that
consists of an instance matching pre ﬁx0and its match (i.e.
(0)∈=0).is a partial function. for convenience we
write()=⊥to indicate that is not in the domain of .
take for example several instances of a petri net that
match a set of events of a case in fig. 4, each with its
own matching function that (partially) maps the events
to transition instances. transition instances that have eventsmapped to them are shaded. as shown by matching instances
(i) and (ii), matching functions may partially map events to
transition instances. in instance (i), both events in the pre ﬁx
hiare mapped to the transition instances and.i n
instance (ii) however, the second event is not mapped to the
second transition instance, i.e. the event is identi ﬁed as
being an inserted activity and the transition instance is
identi ﬁed as a skipped activity.
matching instances may reveal different reasons for de-
viations (if there are any). matching instance (iii) shows no
deviations for the current pre ﬁx, while in instance (iv), the
whole case is considered in which event is identi ﬁed as
being an inserted activity. in instance (v), again the whole
case is considered, but now the transition instance is
skipped, while is no longer an inserted activity.pre f i x  =  < >
pre f i x =  <a > pre f i x =  < > pre f i x  =  <a >
a bpre f i x  =  <a , b >
a bpre f i x =  <a , b >
apre f i x  =  <a , b >
...
... ... ...insert aaas a valid event 
according to modelstart node
pre f i x  =  < a , b ,x ,c >
a b x y cpre f i x =  < a,b , x ,c>target node target nodeskip a
bas a valid event according to model skip binsert barc with cost
a b ca alegend
<p r ef i x  o f  a  c a s e > no d e ,  
re pre s e nti ng  a n 
in s t a n c e m a t chi ng  a  
pre f i x
<information>ins t a nc e  w i th e v e nt m a ppe d to  i t
ar c ,  w it h  in fo r m a t io n  h o w  it  
is c o n st r u c t e d
figure 5. example of a search by the ∗algorithm
to determine which of the instances is most likely describ-
ing the occurring deviations in a given case, we utilize the
cost functions of skipping activities and inserting extra
activities . the idea is that we construct an instance that
has the least cost of deviations. for example, if the cost ofskipping activity (i.e.
()) is less than inserting activity
(i.e.()), then instance (v) is the best ﬁtting instance,
otherwise instance (iv) is.
so far, we have de ﬁned the notion of ﬁtness and we
have shown both how to quantify ﬁtness and how to locate
deviations if we have an instance matching a pre ﬁx. in
the next section, we present our ∗based algorithm for
constructing the best matching instance.
v. c onstructing the best matching instance
since our aim is to construct a matching instance for any
given case, we ﬁrst prove that such an instance always exists,
not only for every instance, but also for every pre ﬁxo fa n
instance.
lemma v .1. (matching instance exists for any pre ﬁx)let
=( â)be an event log over set of activities
.l e t∈be a case identi ﬁer, letbe the sequence
of events of case ,a n dl e t 0⊆be a pre ﬁx. let=
( )b eap e t r in e to v e r with initial marking 0,
and let=(0
0)be an instance of net .
we show that ()∈=0for anywith dom ()=∅.
we identify a petri net instance that best matches our
case using the ∗approach. before we introduce the formal
technique, fig. 5 illustrates our approach roughly in using
the petri net and the set of events example in fig. 4.
we associate a directed graph in the ∗problem domain
with an acyclic search space graph to seek the best matchinginstance, given a set of events of a case and a net. nodes in
the search space graph represent instances of the given net
matching a pre ﬁx of the case.in the
∗problem domain, the graph structure is typically
known in advance, but in our technique, it is constructed dur-
ing replay. given a case to be replayed on a net, we start
by constructing the search space graph consisting of only an
instance matching the empty set (i.e. the instance consistingonly of places that are initially marked as indicated by the
start node in figure 5).
based on the instance, we construct other instances as
successors in the graph. a successor is again a matchinginstance such that:
•it has one matching transition instance more than itspredecessor, in which case one transition instance is
added to the net and the pre ﬁx is extended with a
corresponding event or
•it has one inserted activity more, i.e., the net stays the
same, but the pre ﬁx contains one more event, or
•it has one skipped activity more, i.e., the net has
one more transition instance but the pre ﬁx remains
the same. note that more than one transition can be
enabled, hence there may be more than one successor
in the graph with an added skipped activity.
the steps above are repeated until one of the nodes in
the graph with the shortest distance from the start node is
actually a target node, i.e. a node of which the pre ﬁxi st h e
entire case.
the distance between two adjacent nodes depends on the
difference between these nodes in the number of events
mapped by the matching function and the number of un-mapped non- -labeled transitions. furthermore, the heuristic
functionrequired by the 
∗algorithm, is de ﬁned as the
number of events in the same case that do not belong to thecurrent pre ﬁx.
in order to obtain the distances associated to the arcs, we
use the notion of costs again, where costs are de ﬁned on
nodes and the distance between two nodes is the differencein costs.
deﬁnition v .2. (cost of a matching instance) let=
( â)be an event log over a set of activities
.l e t∈be a case identi ﬁer, and let be the
sequence of events of case .l e t0b eap r e ﬁxo f.l e t
=( )b eap e t r in e to v e r with initial marking
0, and let (0)∈=0be a tuple of an instance of 
matching 0with match .0=(0
0).
letandbe cost functions for skipping and inserting
activities respectively.
we denote transition instances that are not mapped to any
event as=\rng()and denote a set of events that
are not mapped to any transitions as =0\dom ().w e
deﬁn eac o s tf u n c t i o n :=0→where
((0)) =x
∈((())) +x
∈(())
the cost function has a close relation with the cost-
based ﬁtness metric de ﬁn e di nd e f .i i i . 2 .t h es e to fs k i p p e d
transition instances is the same as the bag of skipped
activities, hence deﬁnes the nominator of the fraction.
using the costs of two matching instances, we can de ﬁne
the distance between them as follows.
deﬁnition v .3. (distance between matching instances) let
=( â)be an event log over a set of activities
.l e t∈be a case identi ﬁer, and let be the sequence
of events of case .l e t000be two pre ﬁxes of.l e t
=( )b eap e t r in e to v e r with initial marking
0,l e tand0be two instances of , and let ()∈=0
and (00)∈=00be two tuples of instances matching 0
with match and00with match 0respectively.
we de ﬁne the distance between ()and(00)as:
(()(00)) =((00))−(()) +|00|−|0|
the number of events of each pre ﬁxi sa l s oa d d e da sp a r t
of the distance de ﬁnition as the value of the function is
inﬂuenced by the number of events in each pre ﬁx. note that
it is easy to see that the function is transitive.
although we de ﬁned the distance between any two match-
ing instances, our approach only considers instances thatdiffer either by one transition, or by one event in the pre ﬁx.
therefore, we de ﬁne a partial order on matching instances
as follows:
deﬁnition v .4. (partial order between instances) let

=( â)be an event log over a set of activities
.l e t∈be a case identi ﬁer, and let be the
sequence of events of case .l e t12be two pre ﬁxes
of.l e t=( )be a petri net over with
initial marking 0,l e t1=(11 1111
0)
and2=(22 2222
0)be two instances of
.l e t (11)∈=1and(22)∈=2be two tuples of
instances matching 1with match 1and2with match
2respectively.we de ﬁne a partial order between matching instances
(11)and (22), denoted by (11)i(22)if and
only if
•2=1·and there exist ∈2\1with
2=1∪{},2()=,∀0∈11(0)=2(0)
and1=2↓1, i.e. a transition that corresponds to
an event is added at the end of the instance, or
•2=1and there exist ∈2\1with
2=1∪{},∀∈21()=2()and1=2↓
1, i.e. one skipped activity is added to the end of the
instance, or
•2=1·and∀∈21()=2()and1()=⊥
and1=2, i.e. one inserted activity is identi ﬁed at
the end of the instance.
finally, we formalize our search space and heuristic
function using this partial order on matching instances.
deﬁnition v .5. (search space graph and heuristic func-
tion) let=( â)be an event log over a set
of activities and let=( )be a petri net over
with initial marking 0.l e t∈be a case, and let 
be the events of case .l e tandbe cost functions for
skipping and inserting activities respectively. we de ﬁne a
search space graph of replaying onas=( )
with heuristic function :→(see def. ii.2) as
follows:
•is a (possibly in ﬁnite) set nodes, de ﬁned as=s
0≤=0
•={(12)∈×|1i2}is a set of arcs.
•:→is a heuristic cost function that estimates
the least cost of any paths from a node to its preferred
target node. let 0≤be a pre ﬁx of events and let
∈.w ed e ﬁne()=||−|0|,i . e .t h en u m b e r
of events in case still not used to construct .
•for all (12)∈holds that ((12)) =(12).
the source ∈and target nodes ⊆are de ﬁned
as follows:
• =( ( {∈0}∅∅0
0)), i.e. =hi=
{},a n d
•==is a set of all instances matching and
their matching functions .
to guarantee that the ∗algorithm will actually ﬁnd
one of the target nodes from the source node, we need toprove three things: (i) at least one target node is reachable,
(ii) the heuristic function gives an underestimation of the
distance to the target nodes, and (iii) the evaluation function
is monotonously increasing. the ﬁrst is trivial, as the target
node where each event is considered a inserted activity isreachable by adding the inserted activities incrementally (i.e.
following part 3 of def. v.4). furthermore, if the heuristic
function underestimates the distance to the target nodes andall distances are non-negative then due to the transitivity of
the function the evaluation function will be monotonously
increasing.lemma v .6. (non-negative cost of arc) let=
( â)be an event log over a set of activities ,
let∈be a case and let be the events of case .l e t
=( )be a search space and let (12)∈be
an edge in the search space. we show that ((12))≥0,
i.e. that(12)≥0.
theorem v .7. (heuristic function gives underestimation)
let=( â)be an event log over a set of
activities ,l e t∈be a case and let be the events of
case.l e t=( )be a search space and let 0∈
be two nodes in the search space, such that 0ã
and∈. we show that (0)≤((0)).
this theorem shows that we can use an ∗-based ap-
proach for conformance checking. it is important to realize
that the search space de ﬁn e di nd e f .v . 5i si n ﬁnite in case
there are loops in the petri net. if the costs of executing
such a loop is not greater than 0,t h e nt h e ∗algorithm
has to consider the in ﬁnite search space, hence it is not
guaranteed to terminate. therefore, each loop should have
an activity with positive costs for skipping. as our approach
works based on costs, the selection of cost functions and
is essential. we present experiments where we compare
different values for these cost functions.
vi. e xperiments
we implemented the proposed ﬁtness calculation ap-
proach as a prom 6 plug-in3and performed experiments
using various cost parameter values for different goals. asthe costs of skipping/inserting individual activities require
speciﬁc knowledge about processes under consideration, in
our experiments we assume ﬁxed costs for skipping and
inserting activities, i.e., we are not using domain knowledge
to limit the number of parameters in our experiments.furthermore, the costs of skipping a labeled transition
are assumed to be 0, since we do not have loops of such
transitions in the model.
3see http://www.processmining.org
0.50.60.70.80.91.0
1234561
a
t
1
1
2
1
5
number of skipped activitiesfitness value:     = 1:1
:     = 1:2
:     = 2:1
:     = 1:5
:     = 5:1
baseline
figure 6. experiment results showing that ﬁtness values tend to decrease
as the number of skipped activities increasesa. in ﬂuence of cost ratios
given a model and cases with different number of de-
viations, good ﬁtness measurements should give cases with
high number of deviations less ﬁtness value than the ones
with less number of deviations. to see which cost con-
ﬁguration gives good ﬁtness measurement in the presence
of deviations, we conducted a set of experiments where
only one of the two types of deviations occur. we use a
petri net with unobservable activities, duplicate transitions(i.e. transitions representing the same activity), and complex
control- ﬂow patterns such as the multi-choice pattern (or-
split), milestone, and iterations. to get a controlled test-
ing environment, experiments with deviating activities are
performed with relatively small number of events. the setof events required for experiments with skipped activities
is obtained by generating a relatively small number of 25
events from the model and delete the events randomly asmany as the desired number of skipped activities. similarly,
the set of events to conduct experiments with inserted
activities is obtained from 10 events, generated from the
model, and then add activities as many as the number of
inserted activities needed. for each experiment with a case,we also calculate the ratio between deviating events and the
number of events in the case as baseline. the results of the
experiments are shown in fig. 6 and 7.
ourﬁtness measurement approach produces good results
in the experiments where the cost of skipping activities is
higher than the cost of inserting activities (e.g. experiments
with
():()equal to either 1:2 or1:5 ). with
such cost settings, ﬁtness values are close to the baseline
values and tend to decrease as the number of deviations
increases. however, there are few exceptions on experiments
with skipped activities, where ﬁtness increases along with
the increasing number of skipped activities (see fig. 6).
these exceptions occur because our measurement approach
is guaranteed to ﬁnd the biggest ﬁtness value. rather than
identifying skipped activities that penalize ﬁtness severely
(due to cost settings), marking some events as inserted
0.50.60.70.80.91.0
123456number of inserted activitiesfitness value:     = 1:1
:     = 1:2
:     = 2:1
:     = 1:5
:     = 5:1
baseline
figure 7. experiment results showing that ﬁtness values tend to decrease
as the number of inserted activities increasestable i
fitness v alue from experiments on real -life logs and models
log #cases #events#events per case process model fitness (():()=1:3 ) [13]min max avg #places #trans. min max avg.ﬁtness / case
bezwaar 65 683 6 20 10 15 27 0.00 1.00 0.76 0.86
bezwaarwoz 1981 11278 1 17 5 12 18 0.00 1.00 0.55 0.74
bouwverg. 714 9116 1 32 12 23 33 0.00 1.00 0.46 0.66
afschriften 370 742 1 5 2 11 8 1.00 1.00 1.00 0.50
activities gives higher ﬁtness in such exception cases.
setting the costs such that inserting activities is more
costly than skipping activities always give high ﬁtness val-
ues, because it allows the approach to ﬁnd skipped activities
that enable un ﬁreable transitions. the bigger the cost of
skipping compare to the cost of inserting activities, thehigher the ﬁtness due to less penalty for skipping activities.
b. real-life experiments
the second set of experiments is conducted to see whether
the approach can handle real-life cases. we use four pairs
of model and real-life log from a municipality in thenetherlands, describing process executions of handling two
type of objections, handling building permission applications
and giving out copies of documents. experiment settings andresults are shown in table i. the results are compared to the
results of the classical ﬁtness calculation described in [13].
from our previous experiment, we know that setting the
cost of inserting to be lower than the cost of skipping
activities provides a better ﬁtness metric. therefore, we use
the value 1:3 as the ratio between inserting and skipping
activities to measure ﬁtness and obtain results as shown
in table i. in most cases, our approach provides less
ﬁtness values than the ones provided by classical ﬁtness
measurements. only in the experiments with “afschriften”log that our ﬁtness measurement gives higher values than
the classical ﬁtness measurement. this happens because
our metric does not penalize ﬁtness for not terminating
properly. thus, our ﬁtness measurement is more suitable to
measure ﬁtness in cases where the completeness of process
executions are not guaranteed. in addition, no performance
issues were found as ﬁtness calculations were done within
seconds.
fitness = 0.33horenvoorbereiden
tr 39
hertaxeren
administratieadministratiestart vordering
cost of inserting an activity = 1, 
cost of skipping an activity = 1uitspraakuitspraak
fitness = 0.00uitspraak
hertaxerenadministratiestart vordering
cost of inserting an activity = 1, 
cost of skipping an activity = 3fitness = 0.67
cost of inserting an activity = 3, 
cost of skipping an activity = 1uitspraak
administratiehorenvoorbereiden
tr39
hertaxeren
uitspraak wachtadministratie
start vorderinguitspraak
uitspraakadministratie
skipped activities inserted activities     unobservable activities    valid activities legend
figure 8. analysis with different cost values to reveal the cause of
deviations in a real-life casewe obtain better diagnostics for analysis of the cause
of deviations than the classical ﬁtness measurement that
relies on manual analysis. for example, we take one of
the cases that have extremely low ﬁt n e s sv a l u e s( 0 . 0 0 )i n
log “bezwaarwoz”. the ﬁtness value is provided when the
cost of inserting:skipping activities is 1:3 (see fig. 8). asshown in the left side of fig. 8, all events in the case are
identi ﬁed as inserted activities. to see what causes such
lowﬁtness value, we decrease the cost of skipping an
activity such that ratio between inserting:skipping activities
becomes 1:1. with such ratio, two skipped activities are
revealed: “v oorbereiden” and “horen”. these two activities
are supposed to be executed early in the case. by increasing
the cost of inserting an activity such that the ratio betweenthe cost of inserting and skipping activities becomes 3:1,
we identi ﬁed one more activity that is skipped: “uitspraak
wacht”. by tuning the cost parameters such that the cost
of skipping activities is less than the cost of inserting
activities, one can obtain results that reveal possible causes
of deviations and exploit the information for further analysis
(e.g. if an activity is often skipped, process model should
also allow such skipping).
vii. r
elated work
the notion of conformance has appeared in many dif-
ferent contexts, such as business process compliance [14],
auditing [16], security, and process mining. conformancecomprises of several orthogonal dimensions, such as ﬁtness ,
precision ,generalization ,a n d structural [13], [17]. from
all dimensions of conformance, ﬁtness is one of the most
important dimensions and therefore typically measured ﬁrst.
ifﬁtness value between a given model and process execution
is low, not much useful information can be obtained from
measuring conformance on other dimensions.
many of existing ﬁtness metrics are created to evaluate
process discovery techniques. there are already various
metrics proposed related to the ﬁtness dimension [1], [3],
[5], [7], [8], [13]. a comprehensive lists of these metric are
provided in [17]. fitness is measured on different level of
granularity. our proposed metric penalize ﬁtness only for
individual execution of activity that is not ﬁt.
we consider the work on the classical conformance
checking with a metric based on the number of missing,remaining, produced, and consumed tokens, proposed by
rozinat et al. [13] as a benchmark. the approach have been
tested against several real-life case studies (e.g. [11], [12]).however, the proposed ﬁtness is sensitive to the structure of
the model. furthermore, it is shown that in the presence of
duplicate transitions/unobservable activities, heuristics maylead to incorrect results. experiment results in section vi
show that our approach manage to provide correct results in
the presence of duplicate transitions/unobservable activities.
our work in this paper is closely related to the work
of cook et al. (see [3], [4]). to our knowledge, the work
propose one of the most early ﬁtness-related measurements
that consider the severity of deviations based on event logs.
given a model and an execution of a process, the approach
in [3] measures conformance by comparing an event streamg e n e r a t e db yt h em o d e la n da ne v e n ts t r e a mt h a ti sd e r i v e d
from the execution. fitness is measured in terms of string
edit distance ( ssd) and non-linear string distance metric
(nsd) that can be weighted per-activity. the problem that is
still unsolved in [3] is the selection of heuristic estimator thatguarantee the minimum cost goal. in this paper, we solve the
problem by proposing admissibl e heuristics that guarantees
optimal result (see thm. v .7). however, we do not coverﬁtness measurement in cases where process executions are
a s s u m e dt ob ec o m p l e t e d .
viii. c
onclusion
in this paper, we provide a robust cost-based technique to
replay event logs on process models that is not only capable
to deal with unobservable activities, but can also identify
both skipped activities in process models and inserted activ-ities in event logs.
a st h ew o r ki nt h i sp a p e ri sb a s e do nag e n e r a lf r a m e w o r k
using the 
∗approach that guarantees to identify the best
ﬁt of a case in a petri net, it provides a solid basis for
benchmarking and further analysis based on replay, such as
process conformance and performance analysis.
finally, the bene ﬁto fa l w a y s ﬁnding the best possible
sequence of transitions to ﬁre given the cost parameters
comes at the cost of computational complexity, but real-life
experiments show practical applicability.acknowledgements. this research is funded by the
european community’s seventh framework programme
fp7/2007-2013 under grant agreement n
o257593 (acsi).
references
[1] a. adriansyah, b.f. van dongen, and w.m.p. van der aalst.
towards robust conformance checking. in proceedings
of the 6th workshop on business process intelligence (bpi2010) , 2010.
[2] a. adriansyah, b.f. van dongen, and w.m.p. van der aalst.
cost-based conformance checking using the a* algorithm.bpm center report bpm-11-11, bpmcenter.org, 2011.
[3] j.e. cook, c. he, and c. ma. measuring behavioral corre-
spondence to a timed concurrent model. in software main-
tenance, 2001. proceedings. ieee international conferenceon, pages 332 –341, 2001.[4] j.e. cook and a.l. wolf. software process validation:
quantitatively measuring the correspondence of a processto a model. acm transactions on software engineering and
methodology (tosem) , 8:147–176, april 1999.
[5] a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p.
van der aalst. genetic process mining: an experimentalevaluation. data mining and knowledge discovery , 14:245–
304, 2007. 10.1007/s10618-006-0061-7.
[6] r. dechter and j. pearl. generalized best- ﬁrst search
strategies and the optimality of a*. journal of the acm
(jacm) , 32(3):505–536, 1985.
[7] s. goedertier, d. martens, j. vanthienen, and b. baesens.
robust process discovery with arti ﬁcial negative events.
the journal of machine learning research , 10:1305–1340,
2009.
[8] g. greco, a. guzzo, l. pontieri, and d. sacca. discovering
expressive process models by clustering log traces. ieee
trans. on knowl. and data eng. , 18:1010–1027, august
2006.
[9] k.l. mcmillan and d.k. probst. a technique of state
space search based on unfolding. formal methods in system
design , 6:45–65, 1995. 10.1007/bf01384314.
[10] t. murata. petri nets: properties, analysis and applications.
proceedings of the ieee , 77(4):541–580, august 2002.
[11] a. rozinat, i.s.m. de jong, c.w. g ¨unther, and w.m.p. van der
aalst. conformance analysis of asml’s test process.inproceedings of the second international workshop on
governance, risk and compliance (grcis’09) , volume 459,
pages 1–15. ceur-ws.org, 2009.
[12] a. rozinat, i.s.m. de jong, c.w. g¨ unther, and w.m.p. van der
aalst. process mining applied to the test process of wafer
steppers in asml. ieee transactions on systems, man and
cybernetics - part c , 39:474–479, 2009.
[13] a. rozinat and w.m.p. van der aalst. conformance checking
of processes based on monitoring real behavior. information
systems , 33:64–95, march 2008.
[14] w.m.p. van der aalst. business alignment: using process
mining as a tool for delta analysis and conformancetesting. requirements engineering , 10:198–211, november
2005.
[15] w.m.p. van der aalst. process mining: discovery, confor-
mance and enhancement of business processes .s p r i n g e r
verlag, 2011. isbn:978-3-642-19344-6.
[16] w.m.p. van der aalst, k.m. van hee, j.m. van der werf, and
m. verdonk. auditing 2.0: using process mining to supporttomorrow’s auditor. computer , 43:90–93, march 2010.
[17] j. d. weert, m. d. backer, j. vanthienen, and b. baesens.
a critical evaluation study of model-log metrics in processdiscovery. in proceedings of the 6th workshop on business
process intelligence (bpi 2010) , 2010.