deÔ¨Åning cases and variants for object-centric
event data
jan niklas adams
chair for process and data science (pads)
rwth aachen university , aachen, germany
niklas.adams@pads.rwth-aachen.dedaniel schuster
institute for applied information technology (fit)
fraunhofer , sankt augustin, germany
daniel.schuster@Ô¨Åt.fraunhofer.de
seth schmitz , g¬®unther schuh
laboratory for machine tools (wzl)
rwth aachen university , aachen, germany
fs.schmitz,g.schuhg@wzl.rwth-aachen.dewil m.p. van der aalst
chair for process and data science (pads)
rwth aachen university , aachen, germany
wvdaalst@pads.rwth-aachen.de
abstract ‚Äîthe execution of processes leaves traces of event data
in information systems. these event data can be analyzed through
process mining techniques. for traditional process mining tech-
niques, one has to associate each event with exactly one object,
e.g., the company‚Äôs customer. events related to one object form
an event sequence called a case. a case describes an end-to-end
run through a process. the cases contained in event data can be
used to discover a process model, detect frequent bottlenecks, or
learn predictive models. however, events encountered in real-life
information systems, e.g., erp systems, can often be associated
with multiple objects. the traditional sequential case concept
falls short of these so-called object-centric event data since these
data exhibit a graph structure. one might force object-centric
event data into the traditional case concept by Ô¨Çattening it. how-
ever, Ô¨Çattening manipulates the data and removes information.
therefore, a concept analogous to the case concept of traditional
event logs is necessary to enable the application of different
process mining tasks on object-centric event data. in this paper,
we introduce the case concept for object-centric process mining:
process executions. these are graph-based generalizations of
cases as considered in traditional process mining. furthermore,
we provide techniques to extract process executions. based on
these executions, we determine equivalent process behavior with
respect to an attribute using graph isomorphism. equivalent
process executions with respect to the event‚Äôs activity are object-
centric variants, i.e., a generalization of variants in traditional
process mining. we provide a visualization technique for object-
centric variants. the contribution‚Äôs scalability and efÔ¨Åciency are
extensively evaluated. furthermore, we provide a case study
showing the most frequent object-centric variants of a real-
life event log. our contributions might be used as a basis to
adapt traditional process mining techniques by researchers and
to generate initial control-Ô¨Çow insights into object-centric event
logs by practitioners.
index terms ‚Äîobject-centric process mining, variants
i. i ntroduction
process mining [1] is an umbrella term for techniques
discovering knowledge about processes from event data that
these processes generated. these event data come as an event
the authors would like to thank the marga und walter boll-stiftung for
the kind support within the research project.
(a)traditional event logs.
 (b)object-centric event logs.
fig. 1: traditional event logs take the form of (a): each event is
associated to exactly one object, called the case. object-centric event
logs (b) drop this restriction, events can be associated to multiple
objects of different types.
log. each event of an event log describes an activity executed
in the process, together with its associated data.
one of the most fundamental concepts in process mining are
cases . a case is an event sequence describing one observed
end-to-end behavior in a process. each event is associated
to the object for which the event was conducted, e.g., the
customer. this object is called the case of the event and each
object can be associated to multiple events, forming the event
sequence of end-to-end behavior. the event sequences of all
objects are the fundamental starting point of many process
mining algorithms: control-Ô¨Çow visualization [2], i.e., frequent
sequences of conducted actions, bottleneck analysis [3], or
outcome prediction [4]. an event log in traditional process
mining exhibits the structure depicted in fig. 1a: a collection
of event sequences, one for each case.
object-centric event data [5] is a generalized form of
traditional event data. we drop the assumption that one event
can only be related to one object. each object is still associated
to a sequence of events, but one event may belong to multiplearxiv:2208.03235v1  [cs.db]  5 aug 2022sequences. an example of the resulting structure of object-
centric event data is depicted in fig. 1b. some events are
shared between objects, e.g., event 5. the sequential structure
of the event data is lost by dropping the assumption of single-
object association. the event data takes a graph structure.
furthermore, objects are associated to different object types .
an information system may record data for the conducted
actions of objects of different types, e.g., products and delivery
objects in an ordering process. in traditional process mining,
all objects are assumed to be of the same type, e.g., all events
describe an action conducted for a customer, leading to homo-
geneous events. in object-centric event logs, the homogeneity
assumption is dropped, leading to differently typed objects and
events. in conclusion, traditional event data describe homo-
geneously typed event sequences, while object-centric event
data describe heterogeneously typed event graphs. object-
centric event data is closer to the reality experienced in many
real-life information systems: it is encountered in production
processes [6], high volume manufacturing data [7], and order-
to-cash processes [8]. object-centric event data exhibiting a
graph structure was already observed in [9], [10]
most process mining techniques rely on the existence of
cases. to apply these techniques to object-centric event logs,
the case concept and object-centric event logs must be con-
nected. there are two ways to bridge the gap between the case
concept and object-centric event logs: either moving object-
centric event logs to the traditional case concept or moving the
traditional case concept to object-centric event logs. first, one
can force object-centric event data into traditional event log
format, enforcing homogeneity and sequentiality. this is called
Ô¨Çattening [11]. second, one can generalize the concept of cases
from homogeneous sequences to heterogeneous graphs and
adapt process mining techniques accordingly. when Ô¨Çattening
an object-centric event log, one chooses an object type (also:
case notion), removes events with no objects of this type, and
duplicates events with multiple objects of that type. the output
of Ô¨Çattening is a traditional event log. while Ô¨Çattening is fast
and straightforward, it manipulates the event data: information
about diversity in object types is discarded and a sequential
structure removes dependencies contained in the event data [8],
[11]. for these reasons, we aim to move the case concept
towards object-centric event data in this paper. we provide
the following contributions:
c1we generalize the case concept of traditional process
mining from homogeneous sequences to heterogeneous
graphs for object-centric event logs. these are called
process executions.
c2we provide a general approach for extracting process
executions from an object-centric event log. furthermore,
we provide two speciÔ¨Åc extraction techniques.
c3we use graph isomorphism to determine equivalent
process executions. isomorphic graphs can be used to
group equivalent behavior, e.g., object-centric variants for
equivalent control-Ô¨Çow behavior.
c4we propose an algorithm to visualize equivalent behavior
fig. 2: conceptual difference between our work and the current state-
of-the-art for process mining on object-centric event logs. current
approaches Ô¨Çatten the event log leading to manipulated and removed
information. the generated results might, therefore, also be mislead-
ing. we propose a graph-based case concept for object-centric event
data called process executions. these can accurate represent object-
centric event data.
with a focus on visualizing object-centric variants. this
visualization is an extension of traditional variant visual-
ization.
these contributions aim to provide a foundation for moving
process mining from traditional event data to object-centric
event data. using process executions, one may adapt existing
algorithms and create new algorithms to discover new insights
while leveraging the full, available information.
we discuss related work for this paper in sec. ii and
continue with basic deÔ¨Ånitions on object-centric event data in
sec. iii. these deÔ¨Ånitions build the basis for the introduction
of process executions and their extraction in sec. iv. we dis-
cuss equivalent process executions and variant visualization in
sec. v. the technical side of the contributions, i.e., scalability
and efÔ¨Åciency, are evaluated in sec. vi. we demonstrate the
utility of our contributions in a case study in sec. vii. we
conclude the paper in sec. viii and provide directions for
future contributions.
ii. r elated work
object-centric process mining deals with generating insights
for event data with multiple objects. the problem of ob-
ject multiplicity in real-life information systems was already
formulated several years ago [12]. early approaches dealt
with the problem from a modeling perspective [13], [14]
and with different object types being investigated separately.
object-centric process mining introduced a data-driven way
to approach the problem and has recently gained attention [5],
[8], [9], [15], [16]. so far, different tasks of process mining
have been adapted to the object-centric setting. we group
these into three categories corresponding to this paper‚Äôs focus:
approaches operating case agnostically, approaches working
with Ô¨Çattening [11] and approaches working with graphs
as case concept. the techniques that were introduced for
discovery [5] and conformance checking [10] work without
the explicit use of a case concept. galanti et al. [15] propose
to Ô¨Çatten the event log to apply predictive process mining
techniques to the Ô¨Çattened event log. the Ô¨Çattened event data isa traditional event log and can be used as input to all traditional
process mining techniques. however, Ô¨Çattening is associated to
the problems of deÔ¨Åciency ,convergence . and divergence [11].
by not Ô¨Çattening the data and generalizing the case concept
to a graph, these problems can be avoided. the conceptual
differentiation between our work and previous work based on
Ô¨Çattening is depicted in fig. 2. to the best of our knowledge,
we are the Ô¨Årst paper deÔ¨Åning a graph-based case concept and
variants for object-centric event data.
iii. p reliminaries and event data
given a setx, a sequence 2xof lengthn2nassigns
an enumeration to elements of the set :f1;:::;ng!x. we
use the notation =h1;:::; ni. for an element x2xand a
sequence2x, we overload the notation x2, expressing
the occurrence of element xin the sequence x2range ().
we are dealing with event data of different object types.
tdeÔ¨Ånes the universe of types. there can be multiple in-
stantiations of one type. we refer to each instantiation as an
object.odeÔ¨Ånes the universe of objects. each object is of
one typetype :o!t . we deÔ¨Åne an event log containing
events and objects of different types, assigning each object to
an event sequence. edenotes the universe of event identiÔ¨Åers,
adenotes the universe of event attributes and vdenotes the
universe of attribute values.
deÔ¨Ånition 1 (event log) .an event log l=(e;o; trace;attr)
is a tuple where
ee is a set of events,
oo is a set of objects,
trace :o!emaps each object to an event sequence,
attr :ea9vmaps event attributes onto values.
we deÔ¨Åne some further notations used throughout the paper.
deÔ¨Ånition 2 (further notations) .letl=(e;o; trace;attr)
be an event log. we deÔ¨Åne the following notations:
objl(e) =fo2oje2trace (o)gfore2edenote the
objects associated to an event.
conl=f(e;e0)2eej9o2otrace (o) =he1;:::;e ni
91i<ne=ei^e0=ei+1gdeÔ¨Ånes the directly-follows
relationships for all events and all objects.
an example of an event log is tabularly depicted in fig. 3.
multiple objects are given: o1, o2, m1, m2, m3, and m4.
objects are of different types, e.g., o1 is of type type1. each
object is associated to a sequence of events, e.g., trace (o1) =
he3;e4;e6i.
the right-hand side of fig. 3 depicts the events enriched
with the information of objlandconl. the result is a graph
(also: event-object graph [10]), where the events form the
nodes, labeled with the object information. the edges are
formed by directly-follows relationships between events for an
object. this graph describes the dependencies between events.
events with a path between them depend on each other, while
event pairs with an absence of a path are independent. for
example,e3is a prerequisite for e4ande5. however,e4and
e5have an arbitrary order. since the object-centric event dataeventattr. object types
: : : type1 type2
e1 : : : m1
e2 : : : m2
e3 : : : o1 m1, m2
e4 : : : o1
e5 : : : m1, m2
e6 : : : o1 m1, m2
e7 : : : o2 m3, m4
e8 : : : o2
e9 : : : m3
e10 : : : m4
e11 : : : m3, m4
e12 : : : o2 m3, m4
fig. 3: object-centric event log and the corresponding event-object
graph. events following each other for one object are connected.
fig. 4: example of the object graph for fig. 3. each connected
subgraph, indicated by the dashed lines, can extract a process
execution.
exhibit a graph structure, we base our concept of a process
execution on a graph rather than a sequence.
iv. p rocess execution extraction
this section introduces the concept of process executions
and techniques to extract process executions from an object-
centric event log. the case concept in traditional process
mining describes the event sequence for a single object. we
generalize this concept to process executions describing the
event graphs of multiple interdependent objects.
a. process executions
before introducing the concept of a process execution, we
Ô¨Årst deÔ¨Åne the relationships between objects through the object
graph. in this graph, objects form the nodes and are connected
if they share an event.
deÔ¨Ånition 3 (object graph) .letl=(e;o; trace;attr)be an
event log. the object graph is an undirected graph ogl=
(o;c o)withco=ffo1;o2goj 9e2eo1;o22objl(e)^
o16=o2g. we denote the length of the shortest path between
to objectso;o02o0inoglwith dist :o0o0!r[f?g
where?denotes the absence of a path.
fig. 4 depicts an example of the object graph for the object-
centric event log in fig. 3. the graph tells us which objects
co-appear in events and, therefore, which objects depend on
each other, directly and transitively.
we now generalize the case concept used for traditional
event data such that a process execution from an object-centric
event log covers multiple objects instead of one. however,
these objects must be co-dependent, i.e., they must form a
connected subgraph in the object graph. a process execution
is a graph formed from the events and their directly-follows
relationships for a set of connected objects.deÔ¨Ånition 4 (process execution) .letl=(e;o; trace;attr)
be an event log and o0obe a subset of objects that forms
a connected subgraph in ogl. the process execution of o0
is a directed graph po0=(e0;d)where
e0=fe2ejo0\objl(e)6=;gare the nodes, and
d=conl\(e0e0)are the edges.
the dashed lines in fig. 4 indicate the different connected
subgraphs of the object graph that each may deÔ¨Åne a process
execution. as an example we focus on the black dashed
lines, i.e., the two connected components of the object graph.
using each of these two object sets, we retrieve two process
executions, which are equal two the weakly connected com-
ponents of the event-object graph in fig. 3. a selection of
different subgraphs leads to an extraction of different process
executions. this is by design, as object graphs and their
dependencies can grow very large. splitting this graph apart
or selecting only some relationships of interest can be done
by only selecting speciÔ¨Åc subgraphs. in the following section,
we introduce two speciÔ¨Åc extraction techniques.
a) process executions through connected components:
our Ô¨Årst technique retrieves the largest possible process execu-
tions, capturing all the dependencies and interactions contained
in the event data. we do this by determining the connected
components of the object graph. each connected component
is used to extract one process execution. the connected
components of the object graph in fig. 4 are indicated with
black dashes.
deÔ¨Ånition 5 (connected component extraction) .letl=
(e;o; trace;attr)be an event log and ogl= (o;c o)its
object graph. extcomp (l) =fpo0jo0o^(o0;co\(o0
o0))is a connected component of oglgextracts process ex-
ecutions by connected components.
this technique has two main advantages. it is parameter-
free, i.e., no interaction of the user is required, and it captures
all dependencies between events and objects, forming a base
for extensive exploration of interdependencies in the resulting
process executions. however, this technique also comes with
disadvantages. connected components in the object graph can
grow extremely big. in the worst case, the whole object graph
is one single component leading to the extraction of only one
single process execution. for these reasons, we introduce a
second technique of extracting process executions that neglects
some connections to retrieve smaller process executions.
b) process executions through a leading type: since
every connected subgraph of the object graph can be used
to extract process executions, we introduce a technique that
identiÔ¨Åes subgraphs of the object graph that revolve around a
leading type. such subgraphs have one node of an object of
the leading type that is connected to nodes of objects of other
types only by paths of the same length for each type. to Ô¨Ånd
these subgraphs, the object graph is traversed in a breadth-
Ô¨Årst manner for each object of the leading type. objects for
which objects of the same type were not already traversed in
an earlier level are added to the process execution and to thebreadth-Ô¨Årst search. other objects are discarded.
deÔ¨Ånition 6 (leading type extraction) .letl=(e;o; trace;
attr)be an event log, let ogl=(o;c o)be its object
graph and ot2t be an object type. extlead(l;ot)=fpo0j
o2o^type(o)=ot^o0=fo02ojdist(o;o0)6=? ^
:9o002otype(o0)=type(o00)^dist(o;o00)<dist(o;o0)gre-
trieves process execution through the leading type ot.
the idea behind these subgraphs is the following: for any
given object, the objects that are closest in the object graph
are assumed to be the ones with the most dependencies. these
close objects should be added to a process execution until
objects of the same type have already been added with a
shorter path length. in this way, the closest objects of each
(reachable) type are added. in fig. 4, the subgraphs obtained
with the leading type technique for type type1 are indicated
with black dashes, for type type2 with red dashes. the light
blue dashed lines indicate other possible subgraphs that could
be used to extract process executions but are retrievable with
neither of the two introduced techniques.
v. o bject -centric variants
in general, determining similar process executions is a form
of clustering. some general function fdist(p;p0)can be used
to determine a distance between two process executions p;p0.
based on these distances, clustering of process executions can
be performed. when speaking of equivalent process executions
we deal with a speciÔ¨Åc instance of this problem. two process
executions can be equivalent with respect to an event attribute
a2aif one cannot distinguish between the executions under
consideration of the event‚Äôs associated object types and the
event‚Äôs chosen attribute. if the considered attribute is the
event‚Äôs activity, one typically speaks of control-Ô¨Çow variants.
anfdistis necessary that yields a value of zero if and only
if process executions are equivalent. process executions with
distance zero can subsequently be grouped into equivalence
classes. the problem of determining graph isomorphism ful-
Ô¨Ålls these criteria.
a. equivalence class mining
first, we boil a process execution down to type, order, and
attribute information by projecting it onto the event attribute
and types of the events.
deÔ¨Ånition 7 (projected process execution) .letl =
(e;o; trace;attr)be an event log, o0obe a set of objects
forming a connected subgraph in oglandpo0= (e0;d)the
corresponding process execution. for an attribute a2a, the
projected process execution po0#a= (e0;d;l e;ld)is deÔ¨Åned
as a graph with two label functions:
le(e) = (attr(e;a);f(t;n)2t  n0jn=jfo2o0j
o2objl(e)^type(o)=tgjg)fore2e0,
ld((e1;e2)) =f(t;n)2t  n0jn=jfo2o0jo2
objl(e1)^o2objl(e2)^type(o)=tgjgfor(e1;e2)2d.class equivalence class visualization
1
offer_1
offer_2
send invoice
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan ‚Ä¶place 
orderplace 
order
place 
orderproduce 
on dem.
produce 
on dem.pickup 
pickup 
paypay 
pay machine_2machine_1
ordersecond 
machine
offer_1
offer_2
send 
invoiceplace 
orderplace 
order
place 
orderpickup 
pickup 
paypay 
pay machine_2machine_1produce 
to stock
produce 
to stockfirst 
machine
2
offer_1
offer_2
send invoice
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan ‚Ä¶place 
orderplace 
order
place 
orderproduce 
on dem.
produce 
on dem.pickup 
pickup 
paypay 
pay machine_2machine_1
ordersecond 
machine
offer_1
offer_2
send 
invoiceplace 
orderplace 
order
place 
orderpickup 
pickup 
paypay 
pay machine_2machine_1produce 
to stock
produce 
to stockfirst 
machine
table i: example of the visualization of two variants for ordering
machines using the activity attribute.
two process executions p;p0that are equivalent with respect
to an attribute a2aifp#aandp0#aare isomorphic under
consideration of the node and edge labels.
graph isomorphism is a well-studied problem in computer
science for which, up to this point, no general polynomial-
time algorithm is known [17]. for the problem of determining
groups of isomorphic graphs from a set of graphs, the naive so-
lution would be to conduct a one-to-one isomorphism match-
ing for each pair of graphs. we, however, employ a technique
introduced by rensink [18] in the groove framework. this
two-step technique Ô¨Årst calculates an invariant hash code for
each graph. graphs with different hash codes can not be
isomorphic. however, this does not mean graphs with the same
hash code are isomorphic. therefore, the initial equivalence
classes of graphs with equal hash codes are reÔ¨Åned through
one-to-one comparisons. an additional beneÔ¨Åt of employing
this idea is retrieving an approximation of the equivalence
classes by the initial, unreÔ¨Åned classes of the hash codes. the
weisfeiler-lehman graph hashing [19] is used as a hashing
function. we use the vf2 algorithm [20] for reÔ¨Ånement of the
initial classes, as it has shown superior performance for small,
sparse graphs [21]. we verify the results by conducting a one-
to-one comparison with the vf2 algorithm. as the calculation
of graph hashes is known to have scalability problems for some
graphs [22], we compare the running times of the employed
two-step technique with a one-to-one checking using the vf2
algorithm.
we denote this two-step function to derive equivalence
classes by isoa:fp1;:::;p ng!f 1;:::;mg, retrieving mn
equivalence classes for process executions fp1;:::;p ngand an
attributea2a. an equivalence class is a set of process execu-
tionseqa=fp1;:::;p kgsuch that isoa(p1)=:::=isoa(pk).
the set of all mined equivalence classes is denoted by eqa.
the relative frequency of an equivalence class eqa2eq ais
given by
feqa=jeqajp
eq0a2eq ajeq0aj:
b. variant visualization
the techniques introduced before allow us to determine fre-
quent process executions w.r.t. an event attribute. however, the
mathematical object retrieved by these techniques is a graphalgorithm 1 horizontal positioning of events
require:po0#a- projected process execution, e2e- event
ensure:xstart;xendhorizontal position for the event
xstart get xstart (po0#a;e)
xend get xend(po0#a;e)
function get xstart (po0#a;e)
pre predecessors of einpo0#a
ifjprej= 0 then
return x=0
end if
return max( get xstart (po0#a;e0) for e‚Äô in pre) +1
end function
function get xend(po0#a;e)
suc successors of einpo0#a
ifjsucj= 0 then
return get xstart (po0#a;e0)
end if
return min( get xstart (po0#a;e0) for e‚Äô in suc) 1
end function
with complex edge and node labels. these graphs are hard
to interpret and understand, especially with increasing size.
therefore, we focus on delivering an improved visualization
for control-Ô¨Çow variants using the activity attribute. to provide
an accessible and understandable visualization, we introduce
an extension of variant visualization used in process mining
and business process management [2], [23] for control-Ô¨Çow
variants. traditionally, variants are visualized as a sequence
of chevrons containing the activity labels.
an example of the result from the proposed visualization
technique is depicted in table i for two variants. there are two
object types: orders (blue) and machines (green). both variants
have two objects of type machine, indicated by different
shades of green. in the Ô¨Årst variant, an order is placed for
two machines. while an invoice for the order is sent, the
machines are each produced and picked up concurrently, i.e.,
these events happen in an arbitrary order. for example, sending
the invoice is not dependent on the production of any of the
machines. to conclude, the order for both machines is paid.
in the second variant, the machines are produced to stock in
the beginning.
in our visualization, each type has a speciÔ¨Åc base color,
and each object of such a type has a particular shade of
the base color. each object has a lane showing the event
sequence for the object. each event is depicted as a chevron
with the activity label inside the chevron. if an event is shared
between objects, it is placed on all corresponding object lanes
and colored with the corresponding colors. the shared events
are placed at the same horizontal position to respect the
partial orders between events. since the horizontal position
of events depends on the previously occurring shared events
and their predecessors, we introduce a layouting algorithm
to determine the horizontal positions of events. the objects
determine the vertical position, each object is associated todata setnumber of number of number ofextraction techniquenumber of events per execution objects per execution number of
events types objects executions (max, min, avg) (max, min, avg) variants
ds1loan application process 507553 2 67498connected components 28509 (61;7;17:8) (11;2;2:4) 3420
leading type: application 28509 (61;7;17:8) (11;2;2:4) 3420
leading type: offer 38989 (56;7;18:7) (2;2;2) 7763
ds2order management process 22367 3 11484connected components 83 (1382;8;269:5) (717;3;138:4) 83
leading type: items 8159 (155;8;57:9) (11;3;6) 8155
leading type: orders 2000 (179;8;51:3) (68;3;19:4) 1998
leading type: packages 1325 (155;8;49:7) (32;3;10:5) 1325
ds3customer incident management 119998 2 25598connected components 4825 (259;2;24:3) (53;2;5:1) 3388
leading type: incident 19966 (144;2;25:2) (3;2;2) 16935
leading type: customer 4826 (259;2;24:3) (53;2;5:1) 3389
ds4farmer subsidies process 852610 6 58747connected components 14507 (2973;31;58:8) (22;3;4:2) 7274
leading type: payment application 14507 (2973;31;58:8) (22;3;4:2) 7274
leading type: control summary 14507 (2973;31;58:8) (22;3;4:2) 7274
leading type: entitlement application 205 (279;43;68:6) (9;5;5:1) 190
leading type: geo parcel document 14507 (2973;31;58:8) (22;3;4:2) 7274
leading type: inspection 1999 (2941;48;155:2) (6;5;5) 1955
leading type: reference alignment 14503 (2973;31;58:8) (22;4;4:2) 7270
table ii: overview of extracted process executions for different techniques, their properties, and variants.
fig. 5: running times of execution extraction for different subset
sizes, logs, and extraction techniques.
one unique vertical position grouped by type. algorithm 1
describes retrieve the starting and ending horizontal position
of an event. the starting position is determined recursively
based on the predecessor events. the ending position is based
on the starting position of the successor events.
vi. a lgorithmic evaluation
in this section, we evaluate the four contributions proposed
in this paper. we use four event logs described in table ii.
three of them, ds1[24],ds3andds4[25], are real-life
event logs, while ds2is a synthetic event log, consisting of
an especially high amount of connected objects and variability.
first, we evaluate the results and running times of the different
process execution extraction techniques. then, we evaluate
our employed two-step equivalence class calculation technique
[18] and compare the running time to a one-to-one matching
using the vf2-algorithm [20]. we use the event activity
attribute for each data set to determine equivalence classes,
i.e., we calculate variants. at last, we show the running times
of our equivalence class layouting algorithm. our experiments
and data sets are publicly available on github1. the tool
oc[26]2can be used to explore the individual variants of
1https://github.com/niklasadams/occasesandvariants.git
2https://www.ocpi.aithe different event logs in and end-to-end application of our
contributions.
a. process execution extraction
table ii depicts the number of executions, the maximum,
minimum, and average number of events and objects per
execution for all data sets, and the two introduced execu-
tion extraction techniques. for leading type, the extraction
is performed for each type. for some data sets, like ds1,
the results are quite similar. however, for ds2the raw data
contains large connected components where many objects
get entangled, visible by the low number of executions with
connected components and their high average number of
events. using leading type, the executions increase in number
but decrease in size, allowing for a tighter focus.
fig. 5 shows the running times for each execution extraction
technique for different sizes of each event log. line plots
without a marker refer to connected components extraction.
a linear development of the running times can be observed
for the given sublogs. a relationship of the slope and charac-
teristics of the event logs, e.g., the average size of executions,
seems likely. in general, the extraction by leading types is
slightly faster than connected components. both, connected
components and leading type, show promising scalability for
the application on real-life event data.
b. variants
in this section, we Ô¨Årst discuss the number of variants
calculated for each event log. we then compare the results
of our employed two-step technique with a baseline technique
of determining isomorphic graphs from a set of graphs.
for the real-life logs, i.e., ds1,ds3, andds4, the
number of variants is often signiÔ¨Åcantly smaller than the
number of executions (cf. table ii). this observation shows
that these types of event data contain several equivalent
process executions. only for the synthetic data set ds2
the number of equivalence classes is almost the number of
process executions. through this event log‚Äôs highly entangled
and interconnected nature, almost no process execution is
equivalent to any other execution. a clustering or subgraph
mining approach might be more suited for such extreme cases.(a)ds 1
 (b)ds 2
 (c)ds 3
 (d)ds 4
fig. 6: running times of the two-step algorithm compared to the vf2-algorithm for determining isomorphism.
fig. 7: running time of the layouting algorithm depending on the
number of events and the number of objects, indicated by the size
and color of the points. the running times are collected over all event
logs and variants.
we evaluate our employed technique‚Äôs correctness and run-
ning time against a baseline. this baseline works similarly to
the two-step technique. however, it starts with all executions
in one equivalence class and then reÔ¨Ånes it. while doing so,
it performs a matching under consideration of edge and node
labels using the vf2-algorithm.
fig. 6 depicts the running times for our employed technique
and the baseline, i.e., vf2, for each event log. the measures
are collected by calculating equivalence classes for different
subset sizes of the process executions from different extraction
techniques. generally, the two-step approach shows good
scalability and efÔ¨Åciency compared to the baseline technique.
c. variant visualization
in this section, we evaluate the scalability of our variant lay-
outing algorithm. we perform the layouting for all executions
retrieved for all logs by extracting connected components. we
sort the running times for each equivalence class based on the
number of events in a corresponding process execution and
plot the results in fig. 7. furthermore, each point is colored
and sized according to the number of objects associated with
the equivalence class. we observe increasing running times
with an increase of events and objects. in general, the results
show promising scalability of the layouting.
vii. e nd-to-endapplication
this section showcases the end-to-end application of our
contributions to an event log to retrieve insights about the mostfrequent variants. we use the event log provided by ds1. this
data set describes customers applying for loans in a Ô¨Ånancial
institution. after assessing an application, a loan offer is made.
this offer can be accepted, refused, or canceled. subsequently,
new offers for the same application can be made. we use
connected components/leading type application (both lead to
the same result) to extract process executions. we extract the
object-centric variants and visualize them using our layouting
algorithm. table iii depicts the results.
11%, which amounts to more than 3000 process executions,
show equivalent behavior: after some application steps are
performed, an offer is created and sent to the customer. after
a phone call, the application and the offer are canceled.
however, in the second most frequent execution, the offer is
returned and accepted after the phone call. executions with
multiple offers are also relatively frequent. the fourth and
Ô¨Åfth depicted equivalence classes show executions where the
second offer is canceled or accepted. the variant visualization
provides intuitive insights into the creation and concurrency
of objects.
viii. c onclusion
this paper presented four contributions to translate the
concept of cases and variants to object-centric event data. the
case concept is generalized to process executions which are
event graphs of multiple, dependent objects. we use connected
subgraphs of the object graph to extract process executions
and provide two speciÔ¨Åc algorithms. using graph isomorphism
algorithms we can determine equivalent process executions.
we use these algorithms to determine object-centric variants
and propose a visualization extending traditional variant visu-
alization. in sec. vii, we provided an end-to-end application
of all these contributions to visualize the object-centric variants
of a loan application process.
the work presented in this paper can be extended in
two major directions: additional extraction techniques and
different clustering techniques. the two extraction techniques
introduced are just two of many possible ones that could
extract patterns of interest from the object graph. our equiv-
alence class calculation is one speciÔ¨Åc type of clustering.
process executions could be clustered in other ways based
on other distance measures. clustering would also help with
generating insights for highly entangled event sequences.activity abbreviations: aca = create application, as = application submitted, acon = application concept, wca = application workÔ¨Çow
completed, aa = application accepted, oco = create offer, ocre = offer created, osmo = offer sent mail & online, wcao = calling
after offer, acom = application complete, acan = application cancelled, ocan = offer cancelled, or = offer returned, wv a = validate
application, a v = validating, wcif = calling for incomplete files, ai = application incomplete, oa = offer accepted, ap = pending
variant number (corresponding frequency) & visualized object-centric variant
1
(11%)
aca as acon wca aa ocoosma
acom acan ocreocre
wcaowcao ocan
ocan
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av wcif ai wva av oaoa
ap
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av oaoa
ap
aca ocoosma
acom ocreocre
wcao ocanoffer_2offer_1
wcao
ocreocre osma
acan ocanocan
ocan
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan‚Ä¶
‚Ä¶applicationfirst offer
second offer
2
(5%)
aca as acon wca aa ocoosma
acom acan ocreocre
wcaowcao ocan
ocan
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av wcif ai wva av oaoa
ap
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av oaoa
ap
aca ocoosma
acom ocreocre
wcao ocanoffer_2offer_1
wcao
ocreocre osma
acan ocanocan
ocan
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan‚Ä¶
‚Ä¶applicationfirst offer
second offer
3
(4%)
aca as acon wca aa ocoosma
acom acan ocreocre
wcaowcao ocan
ocan
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av wcif ai wva av oaoa
ap
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av oaoa
ap
aca ocoosma
acom ocreocre
wcao ocanoffer_2offer_1
wcao
ocreocre osma
acan ocanocan
ocan
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan‚Ä¶
‚Ä¶applicationfirst offer
second offer
14
(2%)
aca as acon wca aa ocoosma
acom acan ocreocre
wcaowcao ocan
ocan
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av wcif ai wva av oaoa
ap
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av oaoa
ap
aca ocoosma
acom ocreocre
wcao ocanoffer_2offer_1
wcao
ocreocre osma
acan ocanocan
ocan
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan‚Ä¶
‚Ä¶applicationfirst offer
second offer
35
(0:4%)
aca as acon wca aa ocoosma
acom acan ocreocre
wcaowcao ocan
ocan
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av wcif ai wva av oaoa
ap
aca as acon wca aa ocoosma
acom ocreocre
wcaowcao or
wva av oaoa
ap
aca ocoosma
acom ocreocre
wcao ocanoffer_2offer_1
wcao
ocreocre osma
acan ocanocan
ocan
aca oco wcif ocreocre
av wvaoffer_2offer_1
wvaosma
ai ocan av oa apor oa
osma wcao
wcao acom oco ocreocre
ocan
ocan‚Ä¶
‚Ä¶applicationfirst offer
second offer
table iii: the three most frequent object-centric variants in the loan application process. additionally, we depict two variants with multiple
offers for one application. activities are abbreviated using the Ô¨Årst letters.
cases are essential for traditional process mining tech-
niques. with this paper, we provide a technique to extract
the object-centric equivalent of cases. these can be used to
adapt existing process mining techniques to the object-centric
setting and develop new techniques providing novel insights.
references
[1] w. m. p. van der aalst, process mining: data science in action .
springer, 2016.
[2] d. schuster, s. j. van zelst, and w. m. p. van der aalst, ‚Äúcortado -
an interactive tool for data-driven process discovery and modeling,‚Äù in
petri nets . springer, 2021, pp. 465‚Äì475.
[3] a. senderovich, m. weidlich, l. yedidsion, a. gal, a. mandelbaum,
s. kadish, and c. a. bunnell, ‚Äúconformance checking and performance
improvement in scheduled processes: a queueing-network perspective,‚Äù
inf. syst. , vol. 62, pp. 185‚Äì206, 2016.
[4] n. tax, i. verenich, m. l. rosa, and m. dumas, ‚Äúpredictive business
process monitoring with lstm neural networks,‚Äù in caise . springer,
2017, pp. 477‚Äì492.
[5] w. m. p. van der aalst and a. berti, ‚Äúdiscovering object-centric petri
nets,‚Äù fundam. informaticae , vol. 175, no. 1-4, pp. 1‚Äì40, 2020.
[6] g. schuh, a. g ¬®utzlaff, s. cremer, s. schmitz, and a. ayati, ‚Äúa data
model to apply process mining in end-to-end order processing processes
of manufacturing companies,‚Äù in ieem . ieee, 2020, pp. 151‚Äì155.
[7] q. qi and f. tao, ‚Äúdigital twin and big data towards smart manufacturing
and industry 4.0: 360 degree comparison,‚Äù ieee access , vol. 6, pp.
3585‚Äì3593, 2018.
[8] p. waibel, l. pfahlsberger, k. revoredo, and j. mendling, ‚Äúcausal
process mining from relational databases with domain knowledge,‚Äù
corr , vol. abs/2202.08314, 2022.
[9] s. esser and d. fahland, ‚Äúmulti-dimensional event data in graph
databases,‚Äù j. data semant. , vol. 10, no. 1, pp. 109‚Äì141, 2021.
[10] j. n. adams and w. m. p. van der aalst, ‚Äúprecision and Ô¨Åtness in
object-centric process mining,‚Äù in icpm . ieee, 2021, pp. 128‚Äì135.[11] w. m. p. van der aalst, ‚Äúobject-centric process mining: dealing with
divergence and convergence in event data,‚Äù in sefm . springer, 2019,
pp. 3‚Äì25.
[12] w. m. p. van der aalst et al., ‚Äúprocess mining manifesto,‚Äù in bpm
workshops . springer, 2011, pp. 169‚Äì194.
[13] d. fahland, ‚Äúdescribing behavior of processes with many-to-many
interactions,‚Äù in petri nets . springer, 2019, pp. 3‚Äì24.
[14] e. h. j. nooijen, b. f. van dongen, and d. fahland, ‚Äúautomatic discov-
ery of data-centric and artifact-centric processes,‚Äù in bpm workshops ,
m. l. rosa and p. soffer, eds. springer, 2012, pp. 316‚Äì327.
[15] r. galanti, m. de leoni, n. navarin, and a. marazzi, ‚Äúobject-centric
process predictive analytics,‚Äù corr , vol. abs/2203.02801, 2022.
[16] g. park, j. n. adams, and w. m. p. van der aalst, ‚Äúopera: object-
centric performance analysis,‚Äù corr , vol. abs/2204.10662, 2022.
[17] m. grohe and d. neuen, ‚Äúrecent advances on the graph isomorphism
problem,‚Äù corr , vol. abs/2011.01366, 2020.
[18] a. rensink, ‚Äúisomorphism checking in groove,‚Äù electron. commun.
eur. assoc. softw. sci. technol. , vol. 1, 2006.
[19] n. shervashidze, p. schweitzer, e. j. van leeuwen, k. mehlhorn, and
k. m. borgwardt, ‚Äúweisfeiler-lehman graph kernels,‚Äù j. mach. learn.
res., vol. 12, pp. 2539‚Äì2561, 2011.
[20] l. p. cordella, p. foggia, c. sansone, and m. vento, ‚Äúan improved
algorithm for matching large graphs,‚Äù in iapr-tc15 , 2001, pp. 149‚Äì
159.
[21] p. foggia, c. sansone, and m. vento, ‚Äúa performance comparison of Ô¨Åve
algorithms for graph isomorphism,‚Äù in iapr tc-15 , 2001, pp. 188‚Äì199.
[22] d. conte, p. foggia, c. sansone, and m. vento, ‚Äúthirty years of graph
matching in pattern recognition,‚Äù int. j. pattern recognit. artif. intell. ,
vol. 18, no. 3, pp. 265‚Äì298, 2004.
[23] m. dumas, m. l. rosa, j. mendling, and h. a. reijers, fundamentals
of business process management, second edition . springer, 2018.
[24] b. van dongen, ‚Äúbpi challenge 2017,‚Äù https://doi.org/10.4121/uuid:
5f3067df-f10b-45da-b98b-86ae4c7a310b.
[25] ‚Äî‚Äî, ‚Äúbpi challenge 2018,‚Äù https://doi.org/10.4121/uuid:
3301445f-95e8-4ff0-98a4-901f1f204972.
[26] j. n. adams and w. m. p. van der aalst, ‚Äúoc : object-centric process
insights,‚Äù in petri nets . springer, 2022, pp. 139‚Äì150.