life after bpel?
w.m.p. van der aalst1,2,m .d u m a s2, a.h.m. ter hofstede2, n. russell2,
h.m.w. verbeek1, and p. wohed3
1eindhoven university of technology, eindhoven, the netherlands.
w.m.p.v.d.aalst@tm.tue.nl
2queensland university of technology, brisbane, australia.
{m.dumas,a.terhofstede,n.russell }@qut.edu.au
3universit´ eh e n r ip o i n c a r ´ e, nancy, france. petia.wohed@cran.uhp-nancy.fr
abstract. thebusiness process execution language for web services
(bpel) has emerged as a standard for specifying and executing pro-
cesses. it is supported by vendors such as ibm and microsoft and posi-
tioned as the “process language of the internet”. this paper provides acritical analysis of bpel based on the so-called workﬂow patterns .i ta l s o
discusses the need for languages like bpel. finally, the paper addresses
several challenges not directly addressed by bpel but highly relevantto the support of web services.
1 introduction
web services, an emerging paradigm for architecting and implementing busi-
ness collaborations within and across organizational boundaries, are currentlyof interest to both software vendors and scientists. in this paradigm, the func-
tionality provided by business applications is encapsulated within web services:
software components described at a semantic level, which can be invoked byapplication programs or by other services through a stack of internet standards
including http, xml, soap, wsdl and uddi [3, 12]. once deployed, web
services provided by various organizations can be inter-connected in order toimplement business collaborations, leading to composite web services .
the business process execution language for web services (bpel4ws, or
bpel for short) has emerged as the de-facto standard for implementing pro-
cesses based on web services [9]. systems such as oracle bpel process man-
ager, ibm websphere application server enterprise, ibm websphere studioapplication developer integration edition, and microsoft biztalk server 2004
support bpel, thus illustrating the practical relevance of this language. al-
though intended as a language for connecting web services, its application is notlimited to cross-organizational processes. it is expected that in the near future
a wide variety of process-aware information systems [13] will be realized using
bpel. whilst being a powerful language, bpel is diﬃcult to use. its xmlrepresentation is very verbose and only readable to the trained eye. it oﬀers
many constructs and typically things can be implemented in many ways, e.g.,
using links and the ﬂow construct or using sequences and switches. as a resultonly experienced users are able to select the right construct. several vendors
oﬀer a graphical interface that generates bpel code. however, the graphicalrepresentations are a direct reﬂection of the bpel code and are not intuitive to
end-users. therefore, bpel is closer to classical programming languages than
e.g. the more user-friendly workﬂow management systems available today.
it is interesting to put bpel in a historical perspective. in the seventies, peo-
ple like skip ellis [15], anatol holt [27], and michael zisman [48] were already
working on so-called oﬃce information systems, which were driven by explicit
process models. it is interesting to see that the three pioneers in this area inde-
pendently used petri-net variants to model oﬃce procedures. in the seventies,
organizations were not connected and only few people inside one organizationwere linked through some kind of network. during the seventies and eighties
there was great optimism about the applicability of oﬃce information systems.
unfortunately, few applications succeeded. as a result of these experiences, boththe application of this technology and research almost stopped for a decade. con-
sequently, hardly any advances were made in the eighties. in the nineties, once
again there was huge interest in these systems. the number of workﬂow prod-ucts developed in the past decade and the many papers on workﬂow technology
illustrate the revival of oﬃce information systems. today workﬂow management
systems are readily available [4, 33, 37] and workﬂow technology is hidden inmany applications, e.g., erp, crm, and pdm systems. however, their appli-
cation is still limited to speciﬁc industries such as banking and insurance. since
2000 there has been a growing interest in web services. this resulted in a stackof internet standards (http, xml, soap, wsdl, and uddi) which needed
to be complemented by a process layer. several vendors proposed competing
languages, e.g., ibm proposed wsfl (web services flow language) [32] build-
ing on flowmark/mqseries and microsoft proposed xlang (web services for
business process design) [45] building on biztalk. bpel [9] emerged as a com-promise between both languages.
the goal of this paper is to critically analyze bpel. we analyze the language
itself using a patterns-based approach [5]. in addition, we discuss the focus of
bpel. in our view organizations do notneed to agree on a common execution
language. we will argue that there are more important issues to be addressed,
e.g., having a higher-level language to describe both processes and interactions
and being able to monitor running composite web-services/choreographies.
the remainder of this paper is organized as follows. section 2 brieﬂy intro-
duces the bpel language and its focus. in section 3 we discuss existing work on
workﬂow patterns and relate this to bpel. in section 4 we question the need fora language like bpel. section 5 proposes the real challenges we should focus on
in the context of bpel: (1) generating and analyzing bpel code (section 5.1),
(2) “real” choreography (section 5.2), and (3) process mining, conformance test-ing and mediation (section 5.3). section 6 concludes the paper by providing some
pointers to the “petri and pi” initiative which aims at combining eﬀorts on the-
ory, languages, tools, and applications in the web services domain.2 bpel
bpel [9] supports the modeling of two types of processes: executable and ab-
stract processes. an abstract , (not executable) process is a business protocol,
specifying the message exchange behavior between diﬀerent parties without re-
vealing the internal behavior for any one of them. this abstract process viewsthe outside world from the perspective of a single organization or (composite)
service. an executable process views the world in a similar manner, however,
things are speciﬁed in more detail such that the process becomes executable,i.e., an executable bpel process speciﬁes the execution order of a number of
activities constituting the process, the partners involved in the process, the mes-
sages exchanged between these partners, and the faultand exception handling
required in cases of errors and exceptions.
a bpel process itself is a kind of ﬂow-chart, where each element in the pro-
cess is called an activity . an activity is either a primitive or a structured activity.
the set of primitive activities contains: invoke , invoking an operation on a web
service; receive , waiting for a message from an external source; reply , replying
to an external source; wait, pausing for a speciﬁed time; assign , copying data
from one place to another; throw , indicating errors in the execution; terminate ,
terminating the entire service instance; and empty , doing nothing.
to enable the presentation of complex structures the following structured
activities are deﬁned: sequence , for deﬁning an execution order; switch ,f o r
conditional routing; while , for looping; pick, for race conditions based on timing
or external triggers; flow, for parallel routing; and scope , for grouping activities
to be treated by the same fault-handler. structured activities can be nested and
combined in arbitrary ways. within activities executed in parallel the executionorder can further be controlled by the usage of links (sometimes also called
control links, or guarded links), which allows the deﬁnition of directed graphs.
the graphs too can be nested but must be acyclic.
as indicated in the introduction, bpel builds on ibm’s wsfl (web services
flow language) [32] and microsoft’s xlang (web services for business process
design) [45] and combines the features of a block structured language inheritedfrom xlang with those for directed graphs originating from wsfl. as a result
simple things can be implemented in two ways. for example a sequence can be
realized using the sequence orflowelements (in the latter case links are used
to enforce a particular order on the parallel elements), a choice based on certain
data values can be realized using the switch orflowelements, etc. however, for
certain constructs one is forced to use the block structured part of the language,
e.g., a deferred choice (see next section and [5]) can only be modeled using the
pickconstruct. for other constructs one is forced to use the links, i.e., the more
graph-oriented part of the language, e.g., two parallel processes with a one-way
synchronization require a linkinside a flow. in addition, there are very subtle
restrictions on the use of links: “a link must not cross the boundary of a
while activity, a serializable scope, an event handler or a compensation handler...
in addition, a link that crosses a fault-handler boundary must be outbound,
that is, it must have its source activity within the fault handler and its targetactivity within a scope that encloses the scope associated with the fault handler.
finally, a link must not create a control cycle, that is, the source activitymust not have the target activity as a logically preceding activity, where an
activity a logically precedes an activity b if the initiation of b semantically
requires the completion of a. therefore, directed graphs created by links arealways acyclic.” (see page 64 in [9]). all of this makes the language complex
for end-users. a detailed or complete description of bpel is beyond the scope
of this paper. for more details, the reader is referred to [9] and various websites such as the web site of the oasis technical committee on ws-bpel:
http://www.oasis-open.org/committees/tc
home.php?wg abbrev=wsbpel .
3 patterns-based analysis of bpel
based on earlier experiences in the workﬂow domain, we have evaluated bpel
using the so-called workﬂow patterns [5]. the initial set of 20 workﬂow patterns
focused exclusively on control-ﬂow aspects. we will brieﬂy discuss our experi-ences with bpel based on these patterns. however, before doing so, we would
like to emphasize that the patterns initiative ( www.workflowpatterns.com )i s
not limited to control-ﬂow. we have developed a comprehensive set of data pat-
terns [43]. these patterns describe the diﬀerent ways of dealing with data in
the context of some process-aware information systems [13] (e.g., a workﬂow
management system like staﬀware, an erp system like sap r/3, or integra-tion middleware like websphere). in the context of workﬂow management, we
distinguish four classes of data patterns: data visibility (relating to the extent
and manner in which data elements can be viewed by various components of aworkﬂow process), data interaction (focusing on the manner in which data is
communicated between active elements within a workﬂow), data transfer (con-
sidering the means by which the actual transfer of data elements occurs between
workﬂow components and describe the various mechanisms by which data ele-
ments can be passed across the interface of a workﬂow component) and data-
based routing (characterizing the manner in which data elements can inﬂuence
the operation of other aspects of the workﬂow, particularly the control ﬂow per-
spective). we have also developed a comprehensive set of resource patterns [42]
that capture the various ways in which resources are represented and utilized
in workﬂows. these patterns are also grouped into a number of categories: cre-
ation patterns ,push patterns ,pull patterns ,detour patterns ,auto-start patterns ,
visibility patterns ,a n d multiple resource patterns . since they are less relevant in
the context of bpel, we do not elaborate on them in any detail. other related
work includes colored petri net (cpn) patterns [38], enterprise applicationintegration (eai) patterns [26], and service interaction (si) patterns [10].
for a detailed description and discussion of the patterns and more pointers we
refer the reader to www.workflowpatterns.com and [5, 43]. as an illustration,
we describe control-ﬂow pattern wcfp16 (deferred choice).
wcfp16 deferred choice a point in a process where one among several al-ternative branches is chosen based on information which is not necessarily avail-
able when this point is reached. this diﬀers from the normal exclusive choice, inthat the choice is not made immediately when the point is reached, but instead
several alternatives are oﬀered, and the choice between them is delayed until the
occurrence of some event.example: when a contract is ﬁnalized, it has to be reviewed and signed either
by the director or by the operations manager, whoever is available ﬁrst. both
the director and the operations manager would be notiﬁed that the contract isto be reviewed: the ﬁrst one who is available will proceed with the review.
note that wcfp16 is diﬀerent from the wcfp 4 (i.e., exclusive choice):
the choice is not based on a decision or data but on a choice resolved by the
environment. bpel clearly supports this pattern. the pick(for race conditions
based on timing or external triggers) directly oﬀers the desired functionality.
table 1. an analysis of bpel based on the workﬂow control-ﬂow patterns [47].
pattern pattern name bpel
wcfp1 sequence +
wcfp2 parallel split +
wcfp3 synchronization +
wcfp4 exclusive choice +
wcfp5 simple merge +
wcfp6 multi choice +
wcfp7 synchronizing merge +
wcfp8 multi merge –
wcfp9 discriminator –
wcfp10 arbitrary cycles –
wcfp11 implicit termination +
wcfp12 multiple instances no synchronization +
wcfp13 multiple instances design time knowledge +
wcfp14 multiple instances runtime knowledge –
wcfp15 multiple instances without a priori knowledge –
wcfp16 deferred choice +
wcfp17 interleave parallel routing +/–
wcfp18 milestone –
wcfp19 cancel activity +
wcfp20 cancel case +
tables 1 and 2 summarize the results of our pattern-based evaluation of
bpel. for each control-ﬂow and data pattern, we checked whether it is possibleto realize the pattern with bpel. if bpel directly supports the pattern through
one of its constructs, it is rated +. if the pattern is not directly supported, it
is rated +/-. any solution that results in “spaghetti-like constructs” or is notpossible at all, is considered as giving no direct support and is rated –. these
ratings should be interpreted with care as indicated in [5, 43].
we cannot give a detailed explanation of each pattern or of the evaluation of
bpel based on this material (for this we refer to [5, 43, 47]). however, a general
observation that we would like to make is that bpel is more powerful thantable 2. an analysis of bpel based on the workﬂow data patterns [43].
pattern pattern name bpel
wdp1 task data +/–
wdp2 block data –
wdp3 scope data +
wdp4 folder data –
wdp5 multiple instance data –
wdp6 case data +
wdp7 workﬂow data –
wdp8 environment data +
wdp9 data interaction between tasks +
wdp10 data interaction – block task to decomposition –
wdp11 data interaction – decomposition to block task –
wdp12 data interaction – to multiple instance task –
wdp13 data interaction – from multiple instance task –
wdp14 data interaction – case to case +/–
wdp15 data interaction – task to environment – push-oriented +
wdp16 data interaction – environment to task – pull-oriented +
wdp17 data interaction – environment to task – push-oriented +/–
wdp18 data interaction – task to environment – pull-oriented +/–
wdp19 data interaction – case to environment – push-oriented –
wdp20 data interaction – environment to case – pull-oriented –
wdp21 data interaction – environment to case – push-oriented –
wdp22 data interaction – case to environment – pull-oriented –
wdp23 data interaction – workﬂow to environment – push-oriented –
wdp24 data interaction – environment to workﬂow – pull-oriented –
wdp25 data interaction – environment to workﬂow – push-oriented –
wdp26 data interaction – workﬂow to environment – pull-oriented –
wdp27 data passing by value – incoming +
wdp28 data passing by value – outgoing +
wdp29 data passing – copy in/copy out –
wdp30 data passing by reference – unlocked +
wdp31 data passing by reference – locked +/–
wdp32 data transformation – input –
wdp33 data transformation – output –
wdp34 task precondition – data existence +/–
wdp35 task precondition – data value +
wdp36 task postcondition – data existence –
wdp37 task postcondition – data value –
wdp38 event-based task trigger +
wdp39 data-based task trigger +/–
wdp40 data-based routing +
most traditional process languages. the control-ﬂow part of bpel inherits al-
most all constructs of the block structured language xlang and the directed
graphs of wsfl. therefore, it is no surprise that bpel indeed supports theunion of patterns supported by xlang and wsfl. bpel oﬀers direct support
for the multi choice (wcfp6) and synchronizing merge (wcfp7), but not for
arbitrary cycles (wcfp10). this is a consequence of the “dead-path elimina-tion” principle inherited from wsfl. bpel, through the concept of serializable
scopes, is one of the few languages to support the interleaved parallel routingpattern (wcfp17), although with some restrictions. bpel is also one of the
few languages that fully supports the notion of scope data elements (wdp3). it
provides support for a scope construct which allows related activities, variablesand exception handlers to be logically grouped together. the default binding for
data elements in bpel is at case level and they are visible to all of the compo-
nents in a process. however, variables can be bound to scopes within a processdeﬁnition which may encompass a number of tasks and there is also the ability
for messages to be passed between tasks when control passes from one task to
another.
so the overall observation is that bpel is an expressive language with some
limitations. however, bpel is also a very complicated language with many
concepts. this complexity is reﬂected in the large number of issues that havebeen raised within the oasis ws-bpel standardization committee (217 as of
june 2005), and which have delayed the release of the ws-bpel 2.0 standard
speciﬁcation.
4 do we need bpel?
in the previous section, we concluded that bpel may be too complex but,compared to other languages, it is also very powerful. in this section, we do notfocus on the speciﬁc qualities of bpel. instead we focus on the question: “do
we need a language like bpel?”.
although bpel can be used as a classical workﬂow language, its devel-
opment was triggered by the web service paradigm. therefore, bpel was in-
tended initially for pure cross-organizational processes in a web services context:
“bpel4ws provides a language for the formal speciﬁcation of business processesand business interaction protocols. by doing so, it extends the web services in-
teraction model and enables it to support business transactions.” (see page 1
in [9]). however, it can also be used to support intra-organizational processes.the authors of bpel [9] envision two possible uses of the language: “business
processes can be described in two ways. executable business processes model
actual behavior of a participant in a business interaction. business protocols, in
contrast, use process descriptions that specify the mutually visible message ex-
change behavior of each of the parties involved in the protocol, without revealingtheir internal behavior. the process descriptions for business protocols are called
abstract processes. bpel is meant to be used to model the behavior of both ex-
ecutable and abstract processes .” in our view, executable and abstract processes
should not be supported by a single language. most attention has been devoted
to bpel as an execution language. in our opinion bpel failed as a language
for modeling abstract processes. moreover, a bpel speciﬁcation is always givenfrom the viewpoint of oneof the interacting partners. web services provided by
partners can be used to perform work in a bpel business process. invoking an
operation on such a service is a basic activity that can be speciﬁed using bpel.figure 1 shows the two possible uses of bpel. the ﬁgure clearly illustrates that
in both cases the work is seen from the perspective of one of the partners !
bpel
executable codepartners
(a) executable business process modelbpel
non-executable
codepartners
(b) abstract business process model
fig. 1. the two ways in which bpel can be used.
figure 1 raises the question why every partner should standardize on bpel
as a process language. a partner providing a service may implement its underly-ing processes in any language without the other partner knowing, i.e., interacting
partners do not need to agree on a language like bpel. therefore, the answer
to “do we need a language like bpel?” is no! nevertheless, bpel has becomethe de-facto standard and may in the future facilitate organizations migrating
from one system to another. in addition, bpel incorporates a number of spe-
cialized features for web services development including direct support for xmldata deﬁnition and manipulation, a dynamic binding mechanism based on ex-
plicit manipulation of endpoint references, a declarative mechanism for correlat-
ing incoming messages to process instances (which is essential for asynchronouscommunication), etc. as such, bpel may be seen as an attractive alternative
to conventional (object-oriented) programming languages when it comes to de-
veloping web services.
5 let us focus on the real challenges!
although a language like bpel is not essential for parties to cooperate, its dom-inance raises the question of how to facilitate the use of bpel and to identify the
missing functionality. in other words: we want to address the “real” challenges
in the context of bpel. this is the reason the title of this paper is “life af-ter bpel?”. in this section we brieﬂy discuss three challenges: “generating and
analyzing bpel code”, “real choreography”, and “process mining, conformance
testing, and mediation”.5.1 generating and analyzing bpel code
since bpel is increasingly supported by various engines it becomes interesting
to link it to other types of models. this is useful for two reasons: (1) bpelmore closely resembles a programming language than a modeling language and
(2) bpel itself does not allow for any form of analysis other than being exe-
cutable (e.g., no veriﬁcation, performance analysis, etc.). therefore, there aretwo interesting translations: (1) a translation from a “higher-level” notation to
bpel and (2) a translation from bpel to a model that allows for analysis.
until now, attention has focused on the second translation. several attempts
have been made to capture the behavior of bpel in a formal way. some ad-vocate the use of ﬁnite state machines [19–21], others process algebras [18, 31],
and yet others use abstract state machines [16, 17] or petri nets [39, 35, 44]. a
comparative summary of mappings from bpel to formal languages is given intable 3. the columns of the table correspond to the following criteria:
–tech indicates the formalization technique used: fsm for ﬁnite state ma-
chines, pa for process algebra, asm for abstract state machines and pnfor petri nets.
–saindicates whether the mapping covers structured activities fully (+),
partially (+/–) or not at all (–). it can be seen that this feature is covered
by all proposed mappings.
–clindicates whether the formalization covers control links. here a +/- rat-
ing is given for partial mappings of control links (e.g. not covering join con-
ditions which is a feature associated to control links).
–ehindicates whether the formalization covers event and exception handling.
some references cover fault handling, but do not cover compensation and/orevent handling, in which case, a +/– rating is assigned.
–comm indicates whether the mapping can be applied to systems of intercon-
nected bpel processes (+) or if they are restricted to individual processes
(–). in the former case, it is possible to use the mapping to detect potentialmismatches between two or more bpel processes which are expected to
communicate with each other.
–tav indicates whether a tool for automatic veriﬁcation is provided. some
authors [19, 31] have developed and/or used tools for bpel veriﬁcation but
only to perform simple syntactic checks such as detecting cyclic dependencies
generated by control links, or unnecessary checks such as deadlock-freeness ofindividual bpel processes.
1in these cases a +/– rating is given. this latter
rating is also given to proposals where formal analysis is possible but requires
signiﬁcant manual steps. finally, some authors refer to the possibility ofperforming formal veriﬁcation [18, 17], but do not develop any automated
means of doing so. in this case, a – rating is given.
in industry, various tools and mappings are being developed to generate
bpel code from a graphical representation. tools such as the ibm websphere
1individual bpel processes are deadlock-free by construction [35].table 3. a comparative summary of some of the related work on bpel formalization
and analysis.
tech saclehcomm tav
[21] fsm +––+ +
[20] fsm +––++/–
[19] fsm +–+/– –+/–
[18] pa +–+ – –
[31] pa ++– –+/–
[17] asm ++/– – – –
[35,44] pn ++/– + ++/–
[39] pn +++ – +
choreographer and the oracle bpel process manager oﬀer a graphical notation
for bpel. however, this notation directly reﬂects the code and there is no
intelligent mapping. this implies that users have to think in terms of bpel
constructs (e.g., blocks, syntactical restrictions on links, etc.). more interestingis the work of stephen white that discusses the mapping of bpmn to bpel
[46] and the work by jana koehler and rainer hauser on removing loops in the
context of bpel [30]. however, none of these publications provides a mapping of
some (graphical) process modeling language onto bpel: [46] merely presents the
problem and discusses some issues using examples and [30] focuses on only onepiece of the puzzle. this motivated us to develop a mapping from colored petri
nets (cpns) to bpel [6]. clearly, both types of mappings are highly relevant.
however, the quality of these mappings needs to be improved and there shouldbe more agreement on the precise semantics of bpel.
5.2 real choreography
as indicated in section 4 interacting partners do not need to agree on a language
like bpel. however, they need to agree on an overall global process. currentlyterms like choreography and orchestration are used to refer to the problem of
agreeing on a common process. some people distinguish between choreography
and orchestration, e.g., “in orchestration, there’s someone – the conductor –who tells everybody in the orchestra what to do and makes sure they all play in
sync. in choreography, every dancer follows a pre-deﬁned plan - everyone inde-
pendently of the others.” we will not make this distinction and simply assume
that choreographies deﬁne collaborations between interacting parties , i.e., the co-
ordination process of interconnected web services all partners need to agree on.figure 2 illustrates the notion of a choreography.
within the web services choreography working group of the w3c, a work-
ing draft deﬁning version 1.0 of the web services choreography description lan-
guage (ws-cdl) has been developed [29]. the scope of ws-cdl is deﬁned as
follows: “using the web services choreography speciﬁcation, a contract con-
taining a global deﬁnition of the common ordering conditions and constraintsunder which messages are exchanged, is produced that describes, from a global
viewpoint, the common and complementary observable behavior of all the par-
ties involved. each party can then use the global deﬁnition to build and testbpel choreography
fig. 2. a choreography deﬁnes collaborations between interacting parties.
solutions that conform to it. the global speciﬁcation is in turn realized by a
combination of the resulting local systems, on the basis of appropriate infras-
tructure support. the advantage of a contract based on a global viewpoint asopposed to any one endpoint is that it separates the overall global process be-
ing followed by an individual business or system within a domain of control (an
endpoint) from the deﬁnition of the sequences in which each business or systemexchanges information with others. this means that, as long as the observable
sequences do not change, the rules and logic followed within a domain of control
(endpoint) can change at will and interoperability is therefore guaranteed.” [29].this deﬁnition is consistent with the critique in section 4 and figure 2. unfor-
tunately, like most standards in the web services stack, the language is verbose
and complex. somehow the essence as shown in figure 2 is lost. moreover, thelanguage again deﬁnes concepts such as “sequence”, “choice”, and “parallel” in
some ad-hoc notation with unclear semantics. this suggests that some parts of
the language are an alternative to bpel while they are not. the main problemis that ws-cdl is not declarative. a choreography should allow for the spec-
iﬁcation of the “what” without having to state the “how”. this is similar to
the diﬀerence between a program and its speciﬁcation. one can specify what an
ordered sequence is without specifying an algorithm to do so!
in [1] we describe a more theoretical approach to the problem. the paper
describes the p2p (public-to-private) approach which addresses one of the mostnotorious problems in this domain: how to design an inter-organizational work-
ﬂow such that there is local autonomy without compromising the consistency of
the overall process. the approach uses a notion of inheritance and consists ofthree steps: (1) create a common understanding of the inter-organizational work-
ﬂow by specifying the shared public workﬂow, (2) partition the public workﬂow
over the organizational entities involved, and (3) for each organizational entity:create a private workﬂow which is a subclass of the relevant part of the pub-
lic workﬂow. in [1] it is shown that this approach avoids typical anomalies in
business-to-business collaboration (e.g., deadlocks and livelocks) and yields aninter-organizational workﬂow which is guaranteed to realize the behavior speci-
ﬁed in the public workﬂow. the p2p approach relies heavily on the use of petrinets and a formal notion of inheritance. nevertheless, it would be interesting
to adopt these ideas in the context of languages such as ws-cdl and bpel.
another, more declarative, approach could be based on temporal logic [34, 40].
languages such as linear temporal logic (ltl) allow for the deﬁnition and
veriﬁcation of desirable behavior [23–25].
5.3 process mining, conformance testing, and mediation
assuming that there is a running process (possibly implemented using bpel)
and a choreography speciﬁcation (possibly speciﬁed in ws-cdl), it is interestingto check whether each partner/web-service is well behaved. note that partners
have no control over each other’s services. moreover, partners will not expose
the internal structure and state of their services. the closed and uncontrollablenature of web-services may generate a variety of problems. fortunately, process
mining [7] and conformance testing [2] techniques may be of assistance. for both
we need to assume the existence of an event log [7]. for example, one may log
the messages exchanged between all parties involved in a choreography (either
distributed or through some coordinator). using this event log, we may use
process mining techniques to reconstruct part of the process that actually tookplace. this way one can “discover” the actual choreography. however, in an ideal
situation this choreography is given in terms of a predeﬁned process model. the
coexistence of event logs and process models raises the question of conformance.this question may be viewed from two angles. first of all, the model may be
assumed to be “correct” because it represents the way partners should work,
and the question is whether the events in the log are consistent with the process
model. for example, the log may contain “incorrect” event sequences not possible
according to the model. this may indicate violations of choreography all partiespreviously agreed upon. second, the event log may be assumed to be “correct”
because it is what really happened. in the latter case the question is whether
the choreography that has been agreed upon is no longer valid and should bemodiﬁed. to actually measure conformance, we have developed a tool called
conformance checker . this tool has been developed in the context of the prom
framework
2. the prom framework oﬀers a wide range of tools related to process
mining, i.e., extracting information from event logs [7]. at this point in time we
are investigating the addition of plug-ins speciﬁc for the mining of web services.
some preliminary investigations have been reported in [14, 22].
another prominent issue, complementary to conformance, is that of media-
tion. when it is found (either a priori through model comparison or a posteriori
through mining), that the conversation protocol that a given service provides
does not match the conversation protocol that it is expected to provide, there
are basically two options: (1) modify the service to suit the new expected conver-sation protocol; or (2) mediate between the conversation protocol of the service
2both documentation and software can be downloaded from www.processmining.org .as it is, and the conversation protocol as it should be. the former option is usu-
ally not suitable because the same service may interact with other services thatrely on the conversation protocol that the service currently provides. in other
words, the same service may participate in diﬀerent collaborations such that in
each of these collaborations a diﬀerent conversation protocol is expected from it.thus, mediation between the provided conversation protocol of a service, and the
various conversation protocols that are expected from it (i.e., the required con-
versation protocols ), is generally unavoidable. this issue has been widely studied
in the area of software components where it is known as adaptation . however,
most of the work on component adaptation focuses on structural mediation (i.e.,
mediating diﬀerent structural interfaces and speciﬁcally, between diﬀerent datatypes). since services are expected to participate in collaborations driven by pro-
cess models, behavioral mediation is a prominent requirement. some work has
been done in this area both in the components and services community [28, 11, 8],
but there is still no overarching framework and supporting tools for behavioral
service mediation are missing.
6 petri and pi
in discussions, petri nets [41] and pi calculus [36] are often mentioned as twopossible formal languages that could serve as a basis for languages such as bpeland ws-cdl. some vendors claim that their systems are based on petri nets or
pi calculus and other vendors suggest that they do not need a formal language
to base their system on. in essence there are three “camps” in these discussions:the “petri net camp”, the “pi calculus” (or process algebra) camp, and the
“practitioners camp” (also known as the “no formalism camp”). this was the
reason for starting the “petri nets and pi calculus for business processes” workinggroup ( http://www.smartgroups.com/groups/petri
andpi) in june 2004. its
goal is to have discussions and meetings on the formal foundations of bpm in
general and languages like bpel in particular. the working group was initiated
by robin milner, wil van der aalst, rob van glabbeek, roger whitehead, and
keith harrison-broninski. the ﬁrst meeting of this working group took place injune 2005 at eindhoven university of technology. interesting elements of the
ﬁrst meeting were the identiﬁcation of meaningful patterns and the sharing of
solutions of common examples using languages such as bpel, ws-cdl, coloredpetri nets, pi calculus, yawl, statecharts, ccs, sos, rad, etc.
most of the topics discussed in this paper are relevant to the petri and pi
working group. in fact, this paper was inspired by the eindhoven workshop ofthis group. interested readers are invited to join this working group by sending
an e-mail to petri
andpi-owner@smartgroups.com or one of its members with
the request to become a member.
references
1. w.m.p. van der aalst. inheritance of interorganizational workﬂows: how to agreeto disagree without loosing control? information technology and management
journal , 4(4):345–389, 2003.
2. w.m.p. van der aalst. business alignment: using process mining as a tool for
delta analysis and conformance testing. requirements engineering journal , 2005
(to appear).
3. w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. web service composi-
tion languages: old wine in new bottles? in proceeding of the 29th euromicro
conference: new waves in system architecture , pages 298–305. ieee computer
society, los alamitos, ca, 2003.
4. w.m.p. van der aalst and k.m. van hee. workﬂow management: models, methods,
and systems . mit press, cambridge, ma, 2002.
5. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
6. w.m.p. van der aalst and k.b. lassen. translating workﬂow nets to bpel4ws.
beta working paper series, eindhoven university of technology, eindhoven,
2005.
7. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237–267, 2003.
8. m. altenhofen, e. boerger, and j. lemcke. an execution semantics for mediation
patterns. in proceedings of the bpm 2005 workshops: workshop on choreography
and orchestration for business process managament , nancy, france, september
2005.
9. t. andrews, f. curbera, h. dholakia, y. goland, j. klein, f. leymann, k. liu,
d. roller, d. smith, s. thatte, i. trickovic, and s. weerawarana. business processexecution language for web services, version 1.1. standards proposal by bea
systems, international business machines corporation, and microsoft corpora-
tion, 2003.
10. a. barros, m. dumas, and a.h.m. ter hofstede. service interaction patterns: to-
wards a reference framework for service-based business process interconnection.
qut technical report, fit-tr-2005-012, queensland university of technology,brisbane, 2005. (to appear in bpm 2005.)
11. b. benatallah, f. casati, d. grigori, h. motahari-nezhad, and f. toumani. devel-
oping adapters for web services integration. in proceedings of the international
conference on advanced information systems engineering (caise) ,p o r t o ,p o r -
tugal, june 2005. springer verlag.
12. e. christensen, f. curbera, g. meredith, and s. weerawarana. web services
description language (wsdl) 1.1. http://www.w3.org/tr/wsdl, 2001.
13. m. dumas, w.m.p. van der aalst, and a.h.m. ter hofstede. process-aware infor-
mation systems . wiley & sons, 2005.
14. s. dustdar, r. gombotz, and k. baina. web services interaction mining. technical
report tuv-1841-2004-16, information systems institute, vienna university oftechnology, wien, austria, 2004.
15. c.a. ellis. information control nets: a mathematical model of oﬃce information
flow. in proceedings of the conference on simulation, measur ement and modeling
of computer systems , pages 225–240, boulder, colorado, 1979. acm press.
16. d. fahland and w. reisig. asm-based semantics for bpel: the negative control
ﬂow. in proc. 12th international workshop on abstract state machines ,p a g e s
131–151, paris, france, 2005.17. r. farahbod, u. gl¨ asser, and m. vajihollahi. speciﬁcation and validation of the
business process execution language for web services. in abstract state machines
2004, volume 3052 of lecture notes in computer science , pages 79–94, lutherstadt
wittenberg, germany, may 2004. springer-verlag, berlin.
18. a. ferrara. web services: a process algebra approach. in proceedings of the 2nd
international conference on service oriented computing , pages 242–251, new york,
ny, usa, 2004. acm press.
19. j.a. fisteus, l.s. fern´ andez, and c.d. kloos. formal veriﬁcation of bpel4ws
business collaborations. in proceedings of the 5th international conference on
electronic commerce and web technologies (ec-web ’04) , volume 3182 of lecture
notes in computer science , pages 79–94, zaragoza, spain, august 2004. springer-
verlag, berlin.
20. h. foster, s. uchitel, j. magee, and j. kramer. model-based veriﬁcation of web
service composition. in proceedings of 18th ieee international conference on
automated software engineering (ase) , pages 152–161, montreal, canada, octo-
ber 2003.
21. x. fu, t. bultan, and j. su. analysis of interacting bpel web services. in
international world wide web conference: proceedings of the 13th international
conference on world wide web , pages 621–630, new york, ny, usa, 2004. acm
press.
22. w. gaaloul, s. bhiri, and c. godart. discovering workﬂow transactional be-
havior from event-based log. in on the move to meaningful internet systems
2004: coopis, doa, and odbase: otm confederated international conferences,coopis, doa, and odbase 2004 , volume 3290 of lecture notes in computer sci-
ence, pages 3–18, 2004.
23. d. giannakopoulou and k. havelund. automata-based veriﬁcation of temporal
properties on running programs. in proceedings of the 16th ieee international
conference on automated software engineering (ase’01) , pages 412–416. ieee
computer society press, providence, 2001.
24. k. havelund and g. rosu. monitoring programs using rewriting. in proceedings
of the 16th ieee international conference on automated software engineering
(ase’01) , pages 135–143. ieee computer society press, providence, 2001.
25. k. havelund and g. rosu. synthesizing monitors for safety properties. in pro-
ceedings of the 8th international conference on tools and algorithms for the con-
struction and analysis of systems (tacas 2002) , volume 2280 of lecture notes
in computer science , pages 342–356. springer-verlag, berlin, 2002.
26. g. hohpe and b. woolf. enterprise integration patterns . addison-wesley profes-
sional, reading, ma, 2003.
27. a. w. holt. coordination technology and petri nets. in advances in petri nets
1985, volume 222 of lecture notes in computer science , pages 278–296. springer-
verlag, berlin, 1985.
28. h.w. schmidt and r.h. reussner. generating adapters for concurrent component
protocol synchronisation. in proceedings of the fifth ifip international confer-
ence on formal methods for open object-based distributed systems (fmoods) ,
enschede, the netherlands, march 2002. kluwer academic publishers.
29. n. kavantzas, d. burdett, g. ritzinger, t. fletcher, and y. lafon. web services
choreography description language, version 1.0. w3c working draft 17-12-04,2004.
30. j. koehler and r. hauser. untangling unstructured cyclic flows a solu-
tion based on continuations. in on the move to meaningful internet systems2004: coopis, doa, and odbase: otm confederated international conferences,
coopis, doa, and odbase 2004 , volume 3290 of lecture notes in computer sci-
ence, pages 121–138, 2004.
31. m. koshkina and f. van breugel. veriﬁcation of business processes for web ser-
vices. technical report cs-2003-11, york university, october 2003. available from:
http://www.cs.yorku.ca/techreports/2003/.
32. f. leymann. web services flow language, version 1.0, 2001.33. f. leymann and d. roller. production workﬂow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
34. z. manna and a. pnueli. the temporal logic of reactive and concurrent systems:
speciﬁcation . springer-verlag, new york, 1991.
35. a. martens. analyzing web service based business processes. in proceedings of the
8th international conference on fundamental approaches to software engineering(fase 2005) , volume 3442 of lecture notes in computer science , pages 19–33.
springer-verlag, berlin, 2005.
36. r. milner. communicating and mobile systems: the pi-calculus .c a m b r i d g e
university press, cambridge, uk, 1999.
37. m. zur muehlen. workﬂow-based process controlling: foundation, design and
application of workﬂow-driven process information systems . logos, berlin, 2004.
38. n.a. mulyar and w.m.p. van der aalst. patterns in colored petri nets. beta
working paper series, wp 139, eindhoven university of technology, eindhoven,
2005.
39. c. ouyang, w.m.p. van der aalst, s. breutel, m. dumas, a.h.m. ter hofstede, and
h.m.w. verbeek. formal semantics and analysis of control flow in ws-bpel.
bpm center report bpm-05-13, bpmcenter.org, 2005.
40. a. pnueli. the temporal logic of programs. in proceedings of the 18th ieee
annual symposium on the foundations of computer science , pages 46–57. ieee
computer society press, providence, 1977.
41. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
42. n. russell, w.m.p.van der aalst, a.h.m. ter hofstede, and d. edmond. work-
ﬂow resource patterns: identiﬁcation, representation and tool support. in pro-
ceedings of the 17th conference on advanced information systems engineering(caise’05) , volume 3520 of lecture notes in computer science , pages 216–232.
springer-verlag, berlin, 2005.
43. n. russell, a.h.m. ter hofstede, d. edmond, and w.m.p. van der aalst. work-
ﬂow data patterns: identiﬁcation, representation and tool support. accepted
for publication in proceedings of the 24th international conference on conceptual
modeling (er’2005) , springer-verlag, berlin, 2005.
44. c. stahl. transformation von bpel4ws in petrinetze (in german). master’s
thesis, humboldt university, berlin, germany, 2004.
45. s. thatte. xlang web services for business process design, 2001.46. s. white. using bpmn to model a bpel process. bptrends , 3(3):1–18, march
2005.
47. p. wohed, w.m.p. van der aalst, m. dumas, and a.h.m. ter hofstede. analysis
of web services composition languages: the case of bpel4ws. in 22nd inter-
national conference on conceptual modeling (er 2003) , volume 2813 of lecture
notes in computer science , pages 200–215. springer-verlag, berlin, 2003.
48. m.d. zisman. representation, speciﬁcation and automation of oﬃce procedures .
phd thesis, university of pennsylvania, warton school of business, 1977.