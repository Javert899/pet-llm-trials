mining local process models
tax, n.; sidorova, n.; haakma, r.; van der aalst, w.m.p.
published in:
journal of innovation in digital ecosystems
doi:
10.1016/j.jides.2016.11.001
published: 01/01/2016
document version
publisher’s pdf, also known as version of record (includes final page, issue and volume numbers)
please check the document version of this publication:
• a submitted manuscript is the author's version of the article upon submission and before peer-review. there can be important differences
between the submitted version and the official published version of record. people interested in the research are advised to contact the
author for the final version of the publication, or visit the doi to the publisher's website.
• the final author version and the galley proof are versions of the publication after peer review.
• the final published version features the final layout of the paper including the volume, issue and page numbers.
link to publication
citation for published version (apa):
tax, n., sidorova, n., haakma, r., & van der aalst, w. m. p. (2016). mining local process models. journal of
innovation in digital ecosystems, 3(2), 183-196. doi: 10.1016/j.jides.2016.11.001
general rights
copyright and moral rights for the publications made accessible in the public portal are retained by the authors and/or other copyright owners
and it is a condition of accessing publications that users recognise and abide by the legal requirements associated with these rights.
            • users may download and print one copy of any publication from the public portal for the purpose of private study or research.
            • you may not further distribute the material or use it for any profit-making activity or commercial gain
            • you may freely distribute the url identifying the publication in the public portal ?
take down policy
if you believe that this document breaches copyright please contact us providing details, and we will remove access to the work immediately
and investigate your claim.
download date: 14. jan. 2018j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
available online at www.sciencedirect.com
sciencedirect
journal homepage: www.elsevier.com/locate/jides
mining local process models
niek taxa,b,∗, natalia sidorovaa, reinder haakmab,
wil m.p. van der aalsta
aeindhoven university of technology, p.o. box 513, eindhoven, the netherlands
bphilips research, prof. holstlaan 4, 5665 aa eindhoven, the netherlands
h i g h l i g h t s
•this paper presents a new data mining method called local process model (lpm) mining.
•lpm mining extends sequential pattern mining techniques to more complex patterns.
•lpm mining enables process mining of noisy data by focusing on local structures.
a r t i c l e i n f o
article history:
published online 2 december 2016
keywords:
process mining
knowledge discovery
data mininga b s t r a c t
in this paper we describe a method to discover frequent behavioral patterns in event
logs. we express these patterns as local process models . local process model mining can
be positioned in-between process discovery and episode/sequential pattern mining. the
technique presented in this paper is able to learn behavioral patterns involving sequential
composition, concurrency, choice and loop, like in process mining. however, we do not
look at start-to-end models, which distinguishes our approach from process discovery and
creates a link to episode/sequential pattern mining. we propose an incremental procedure
for building local process models capturing frequent patterns based on so-called process
trees. we propose five quality dimensions and corresponding metrics for local process
models, given an event log. we show monotonicity properties for some quality dimensions,
enabling a speedup of local process model discovery through pruning. we demonstrate
through a real life case study that mining local patterns allows us to get insights in
processes where regular start-to-end process discovery techniques are only able to learn
unstructured, flower-like, models.
c⃝2016 qassim university. production and hosting by elsevier b.v.
this is an open access article under the cc by-nc-nd license
(http://creativecommons.org/licenses/by-nc-nd/4.0/).
1. introduction
process mining aims to extract novel insight from event
data [1]. process discovery, the task of discovering a process
model that is representative for the set of event sequences
peer review under responsibility of qassim university.
∗corresponding author at: eindhoven university of technology, p.o. box 513, eindhoven, the netherlands.
e-mail address: n.tax@tue.nl (n. tax).in terms of start-to-end behavior, i.e. from the start of a case
till its termination, plays a prominent role in process mining.
many process discovery algorithms have been proposed
and applied to a variety of real life cases (see [1] for an
overview). a different perspective on mining patterns in event
http://dx.doi.org/10.1016/j.jides.2016.11.001
2352-6645/ c⃝2016 qassim university. production and hosting by elsevier b.v. this is an open access article under the cc by-nc-nd
license (http://creativecommons.org/licenses/by-nc-nd/4.0/).184 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
sequences can be found in the data mining field, where
the episode mining [2] and sequential pattern mining [3]
subfields focus on finding frequent patterns that are local, not
necessarily describing the whole event sequences from start
to end. episode mining and sequential pattern mining have
e.g. been used to analyze telecommunication networks [2],
web navigational logs [2,4], and retail sales transactions [5].
sequential pattern mining and episode mining are limited
to the discovery of sequential orderings orpartially ordered
sets of events, while process discovery methods aim to
discover a larger set of event relations, including sequential
orderings, (exclusive) choice relations, concurrency, and
loops, represented in process models such as petri nets [6],
bpmn [7], and process trees [8]. process models that can
be discovered with process discovery methods distinguish
themselves from more traditional sequence mining methods
like hidden markov models [9] and recurrent neural
networks [10,11] in that process models can be visually
represented and their visual representation can be used
for communication between process stakeholders. however,
process discovery is normally limited to the discovery of a
model capturing the behavior of process instances as a whole,
and not local patterns within instances. our goal is to develop
methods allowing to mine local process models positioned in-
between simple patterns (e.g. subsequences) and start-to-end
models. local process models focus on a subset of the process
activities and describe some behavioral pattern that occurs
frequently within event sequences. such local process models
cannot be discovered by using standard techniques.
imagine a sales department where multiple sales of ficers
perform four types of activities: (a) register a call for bids,
(b) investigate a call for bids from the business perspective,
(c) investigate a call for bids from the legal perspective, and
(d) decide on participation in the call for bid. the event
sequences (fig. 1(a)) contain the activities performed by one
sales of ficer throughout the day. the sales of ficer works
on different calls for bids and not necessarily performs all
activities for a particular call himself. applying discovery
algorithms, like the inductive miner [12], yields models
allowing for any sequence of events (fig. 1(c)). such “ flower-
like” models do not give any insight in typical behavioral
patterns. when we apply any sequential pattern mining
algorithm using a threshold of six occurrences, we obtain the
seven length-three sequential patterns depicted in fig. 1(d)
(results obtained using the spmf [14] implementation of
the pre fixspan algorithm [13]). however, the data contains
a frequent non-sequential pattern where a sales of ficerfirst
performs a, followed by band a cin arbitrary order (fig. 1(b)).
this pattern cannot be found with existing process discovery
and sequential pattern mining techniques. the two numbers
shown in the transitions (i.e., rectangles) represent (1) the
number of events of this type in the event log that fit this local
process model and (2) the total number of events of this type
in the event log. for example, 13 out of 19 events of type c
in the event log fit transition c, which are indicated in bold
in the log in fig. 1(a). underlined sequences indicate non-
continuous instances, i.e. instances with non- fitting events
in-between the events forming the instance of the local
process model.in this paper we describe a method to extract frequently
occurring local process models , allowing for choice, concur-
rency, loops, and sequence relations. we leverage process
trees [15] to search for local process models, and describe a
way to recursively explore candidate process trees up to a cer-
tain model size. for convenience, we often use the petri net
representations for process trees. in fact, results can also be
visualized as bpmn [7], epc [16], uml activity diagram [17],
or uml statechart diagram [17]. we de finefive quality dimen-
sions that express the degree of representativeness of a local
process model with regard to an event log: support ,confidence ,
language fit,coverage , and determinism . based on quality met-
rics, we describe monotonicity properties over some quality
dimensions and show how they can be used to make the re-
cursive search over process trees more ef ficient.
the paper is organized as follows. section 2 introduces the
basic concepts used in this paper. section 3 describes related
work in the fields of process discovery and sequential pat-
tern mining. section 4 describes our local process model min-
ing approach. section 5 introduces quality dimensions and
metrics for local process models and discusses monotonic-
ity properties. section 6 describes a local process model eval-
uation approach based on alignments. section 7 shows the
relevance of the proposed technique using two real life data
sets and compares the results with the results obtained with
several related techniques. section 8 concludes the paper.
2. preliminaries
in this section we introduce process modeling notations,
including petri nets, process trees, which are used in later
sections of this paper.
x∗denotes the set of all sequences over a set xand
σ= ⟨a1,a2, . . . , an⟩a sequence of length n;⟨⟩is the empty
sequence and σ1·σ2is the concatenation of sequences σ1, σ2.
σqis the projection of σonq, e.g. ⟨a,b,c,a,b,c⟩{a,c}=
⟨a,c,a,c⟩. #a(σ)denotes the number of occurrences of element
ain sequence σ, e.g. # a(⟨a,b,c,a⟩)=2.
definition 1 (applying functions to sequences ).a partial func-
tion f∈x9ycan be lifted to sequences over xusing the
following recursive de finition: (1) f(⟨⟩)= ⟨⟩; (2) for any σ∈x∗
and x∈x:
f(σ· ⟨x⟩)=
f(σ) ifx̸∈dom(f),
f(σ)· ⟨f(x)⟩ifx∈dom(f).
we assume the set of all process activities σlto be given.
anevent eis the occurrence of an activity e∈σl. we call
a sequence of events t∈σl∗atrace . an event log l∈nσl∗
is afinite multiset of traces. for example, the event log l=
[⟨a,b,c⟩2,⟨b,a,c⟩3]consists of 2 occurrences of trace ⟨a,b,c⟩
and three occurrences of trace ⟨b,a,c⟩. we lift the sequence
projection to the multisets of sequences in the standard way.
for example, for the log lgiven above l{a,c}= [⟨a,c⟩5]. we
lift the number of occurrences in a sequence to multisets of
sequences in the standard way, for example, # a(l)=5.
petri nets are directed bipartite graphs consisting of tran-
sitions and places, connected by arcs. transitions represent
activities, while places represent the enabling conditions ofj o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 185
fig. 1 – (a) a log lof sales officer event sequences with highlighted instances of the frequent pattern. (b) the local process
model showing frequent behavior in l. (c) the petri net discovered on lwith the inductive miner algorithm [12]. (d) the
sequential patterns discovered on lwith the prefixspan algorithm [13].
transitions. labels are assigned to transitions to indicate the
type of activity that they model. a special label τis used to
represent invisible transitions, which are only used for rout-
ing purposes and not recorded in the execution log.
definition 2 (labeled petri net ).alabeled petri net n=
⟨p,t,f,σm, ℓ⟩is a tuple where pis afinite set of places, tis
afinite set of transitions such that p∩t= ∅,f⊆(p×t)∪(t×p)
is a set of directed arcs, called the flow relation, σmis afinite
set of labels representing activities, with τ̸∈σmbeing a label
representing invisible events, and ℓ:t→σm∪{τ}is a labeling
function that assigns a label to each transition.
for a node n∈(p∪t)we use •nand n•to denote the set of
input and output nodes of n, defined as •n= {n′|(n′,n)∈f}
and n• = { n|(n,n′)∈f}.
a state of a petri net is de fined by its marking m∈npbeing
a multiset of places. a marking is graphically denoted by
putting m(p)tokens on each place p∈p. a pair (n,m)is called
a marked petri net. state changes occur through transition
firings. a transition tis enabled (can fire) in a given marking
mif each input place p∈ •tcontains at least one token. once
a transition fires, one token is removed from each input place
oftand one token is added to each output place of t, leading
to a new marking m′defined as m′=m− •t+t•. afiring of a
transition tleading from marking mto marking m′is denoted
asml(t)− →m′.m1l(σ)− →m2indicates that m2can be reached from
m1through a firing sequence σ′∈σm∗.
often it is useful to consider a petri net in combination
with an initial marking and a set of possible final markings.
this allows us to de fine the language accepted by the petri net
and to check whether some behavior is part of the behavior
of the petri net (can be replayed on it).
definition 3 (accepting petri net ).anaccepting petri net is a
triple apn=(n,m0,mf), where nis a labeled petri net, m0∈
npis its initial marking, and mf⊆npis its set of possible final
markings, such that ∀m1,m2∈mfm1̸⊆m2. a sequence σ∈t∗
is called a trace of an accepting petri net apn ifm0σ− →mffor
some final marking mf∈mf. the language l(apn)ofapn is
the set of all its traces.
fig. 2 shows an example of an accepting petri net. circles
represent places and rectangles represent transitions. invis-
ible transitions (labeled τ) are depicted as black rectangles.
places that belong to the initial marking contain a token and
places belonging to a final marking contain a bottom right la-
belfiwith iafinal marking identi fier, or are simply marked
fig. 2 – example of an accepting petri net.
as
 in case of a single final marking. the language of this
accepting petri net is {⟨a,b,c⟩,⟨a,c,b⟩}.
a different process representation is a process tree [15].
process trees can only model sound (deadlock-free and
livelock-free) processes. the recursive de finition of process
trees make them a convenient representation to iteratively
expand process models into larger process models.
definition 4 (process tree ).let a∈σmbe a finite set of
activities with τ̸∈σm.= {→ ,×,∧,}is the set of process
treeoperators.
•ifa∈σm∪ {τ}then q=ais a process tree.
•ifq1,q2are process trees, and ⊕ ∈, then q= ⊕(q1,q2)
is a process tree.
aprocess tree is a tree structure consisting of operator and
activity nodes, such that each leaf node is an activity node
and each non-leaf node is an operator node.
the loop operator ( ) has two child nodes, with the
first child the “do” part and the second child the “redo”
child. process tree p1=(a,b)accepts language l(p1)=
{⟨a⟩,⟨a,b,a,⟩,⟨a,b,a,b,a⟩, . . .}.
the sequence operator ( →) has two children, such that the
first child is executed prior to execution of the second child.
the language of process tree p2=→(a,b)isl(p2)= {⟨a,b⟩}.
the exclusive choice operator ( ×) has two children,
indicating that either the first or the second child will be
executed, but not both. the language of process tree p3=
×(a,b)isl(p3)= {⟨a⟩,⟨b⟩}.
the concurrency operator ( ∧) has two children, indicating
that the both children will be executed in parallel. process
tree p4= ∧(→(a,b),→(c,d))accepts language l(p4)=
{⟨a,b,c,d⟩,⟨a,c,b,d⟩,⟨a,c,d,b⟩,⟨c,a,b,d⟩,⟨c,a,d,b⟩,⟨c,d,a,b⟩}.
letp5= × ((a,b),∧(c,d)). fig. 3 shows the graphical
representation of p5. because the do and redo children of a
loop operator can be executed an arbitrary number of times,
process trees containing a loop operator have a language of
infinite size.
we de finen-restricted language , consisting of all language
traces of at most length n∈n, asln= {t∈l| |t| ≤186 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
fig. 3 – graphical representation of process tree
×((a,b),∧(c,d)).
n}. the n-restricted language is guaranteed to be of finite
size, independent of the operators in the process tree. the
5-restricted language of the process tree p5isl5(p5)=
{⟨a⟩,⟨a,b,a⟩,⟨a,b,a,b,a⟩,⟨c,d⟩,⟨d,c⟩}.
3. related work
prom’s episode miner [18] is a method that can be considered
to be in-between episode mining and process mining, as it
discovers a collection of patterns from an event log where
each pattern consists of partial order constructs. however,
contrary to the technique that we describe in this paper,
prom’s episode miner does not support loop and exclusive
choice constructs and is not easily extensible to include new
types of constructs.
lu et al. propose a method called post sequential patterns
mining (pspm) [19] that takes a input a set of sequential pat-
terns and post-processes them into a single graph consisting
of sequential and exclusive choice constructs, which they call
a sequential pattern graph (sgp) [20]. a later extension by lu
et al. adds the capability to mine concurrency relations [21].
an sgp can be discovered from an event log by first applying
any existing sequential pattern mining algorithm followed by
pspm on the discovered set of sequential patterns. the re-
liance of pspm methods on the output of sequential pattern
mining techniques can also be considered to be a drawback
of the approach. when two activities aand bare in paral-
lel then both the orderings ⟨a,b⟩and⟨b,a⟩will be present
in the complete log. however, if one of the two orderings is
more frequent than the other due to chance, one of the two
orderings might not reach the support set in the sequential
pattern mining, making it impossible for pspm methods to
discover the concurrency of aand b. a more fundamental dis-
tinction between pspm and local process model (lpm) discov-
ery is that pspm merges all relations into one single pattern
while lpm discovery aims at discovering a collection of pat-
terns. merging separate patterns into a single graph could re-
sult in one single overgeneralizing graph. for example in the
case of log l= [⟨b,a,c⟩100,⟨d,a,e⟩100], sequential pattern min-
ing techniques will find two sequential patterns: b,a,cand
d,a,e. merging them into a single graph where ais followed
by either coreand is preceded by either bordresults in the
loss the long term dependency where balready determines
the occurrence of a cafter the a.
jung et al. [22] describe a method to mine frequent pat-
terns from a collection of process models by transforming
each business process to a vector format and then applyingagglomerative clustering. diamantini et al. [23,24] take a sim-
ilar approach, but apply graph clustering techniques instead
of a traditional clustering approach. these techniques differ
from lpm discovery as they take as input a set of process mod-
els instead of an event log. however, in many situations there
are no existing process models available and, as shown in the
introduction, it is not always possible to mine structured pro-
cess models from an event log using process discovery tech-
niques.
in later work, diamantini et al. [25] describe a method to
mine frequent patterns in process model notation through a
two step approach. first each trace from the event log is trans-
formed into a so called instance graph [26], which is graph
representation of a trace that shows which steps in the trace
are performed sequentially and which steps are performed in
parallel (i.e. overlapping in time). in the second step they ap-
ply a graph clustering technique to obtain frequent subgraphs
from this set of instance graphs. however, since instance
graphs are limited to sequential and parallel constructs, other
process constructs, such as choices and loops, cannot be dis-
covered with the approach described in diamantini et al. [25],
while they can be discovered with lpm discovery.
the techniques developed in the area of trace cluster-
ing [27–30] are related to lpm discovery in the sense that both
aim to enable extraction of process insight from event logs
where the process is too unstructured for existing process dis-
covery techniques to find a structured process model. trace
clustering techniques aim to solve this by clustering similar
traces together to prevent mixing different usage scenarios
into one single unstructured process model. trace clustering
techniques work well when the original event log does not
originate from one single process, but in fact originates from
multiple processes. however, not in all types of complex and
flexible event data there is a cluster tendency in the data. an
example for such non-clusterable event data can be found in
the log shown in fig. 1(a), where no clustering over the traces
would enable the discovery of the frequent pattern shown in
fig. 1(b). the traces in the log have large parts of randomness
within the traces, while trace clustering helps for cases where
there is a large degree of variety between traces.
declarative process models, such as declare [31], de fine
the allowed behavior through constraints that must be re-
spected while carrying out the process. this contrasts pro-
cedural process models, which are dominant in the process
discovery field and specify all possible orderings of events ex-
plicitly. t wo examples of process discovery approaches that
generate declarative process models are the dpil miner [32]
and the declare miner [33]. both approaches specify a set of
rule templates that consists of two activity variables and their
relation. an example of such a template is sequence (a,b), in-
dicating that some activity ais followed by b. concrete rules
are extracted from the event log based on this template-based
search. however, since the rule templates are limited to rela-
tions between two activities, more complex relations between
three or more activities cannot be discovered. imagine that
for some event log a declarative process discovery method
finds two relations: sequence (a,b)and sequence (b,c), indicat-
ing that both the occurrences of activity bafter aand the oc-
currences of activity cafter bmeet some support threshold.
the binary relations sequence (a,b)and sequence (b,c)combinedj o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 187
do not imply a tertiary relation equivalent to process tree
→(a,→(b,c)), since it could be the case that speci fically those
occurrences of bthat are preceded by aare rarely followed by
c. the lpm discovery approach discussed in this paper enables
discovery of relations between three or more activities.
hybrid process discovery [34] aims at discovering a process
model that consists partially of procedural process model
constructs and partially of declarative process model con-
structs. existing hybrid process discovery approaches consist
of afirst step where activities are separated into a group of
structured activities and a group of unstructured activities,
based on the number of unique predecessors and successors
of an activity. however, some activities, such as activity ain
the event log of fig. 1(a), are part of a frequent pattern, but
also to occur as noise at random point in the traces. such ac-
tivities would be classi fied as noisy activities by existing hy-
brid process discovery approaches, resulting in this activity
being modeled with binary declarative constructs.
the fuzzy miner [35] is a process discovery technique de-
veloped to deal with complex and flexible process models.
it connects nodes that represent activities with edges indi-
cating follows relations, taking into account the relative sig-
nificance of follows/precedes relations and allowing the user
tofilter out edges using a slider. however, the process mod-
els obtained using the fuzzy miner lack formal semantics,
e.g. when a node has two or more outgoing edges, it is un-
defined whether this represents a choice, an exclusive choice,
or parallel execution of the connected nodes.
we have described several techniques that are related in
that sense that (i) they aim to enable mining of process insight
from less structured processes on which traditional process
discovery methods fail, or (ii) they aim to extract a collection
of process models that each represent some subprocess.
however, none of the existing techniques in category (i) is
able to deal with event logs where some frequent patterns
are surrounded by random events, as is the case in the
event log in fig. 1(a), and all of the existing methods in
category (ii) either require a completely different type of input
(a collection of graphs), or they support only a part of the
constructs supported by the lpm discovery approach.
4. local process model discovery approach
a local process model (lpm) aims to describe frequent
behavior in an event log in local, i.e. smaller, patterns,
typically between three and five activity nodes. a lpm does
not aim to describe all behavior in a trace completely,
but instead aims to describe traces partially, focusing on
frequently occurring patterns. a lpm lnrepresents behavior
overσmand accepts language l(ln). the closure of the
accepting language with respect to alphabet σlis defined as
l(ln,σl)= {σ∈σl∗|σσm∈l(ln)}.
here, we introduce a local process model discovery approach
that consists of four main steps:
(1)generation generate the initial set cm1(so i=1)
of candidate lpm in the form of process trees
consisting of one leaf for each activity a∈σl. fig. 4
shows this set of elementary process trees for an
event log over alphabet σl= {a,b, . . . , z}. create
selected set of selected lpms sm= ∅.
fig. 4 – set of elementary process trees over
σl= {a,b,..., z}.
(2)evaluation evaluate lpms in current candidate set cmi
based on a set of quality criteria.
(3)selection based on evaluation results, a set scmi⊆cmi
of candidate lpms are selected. sm=sm∪scmi. if
scmi= ∅ori≥max_iterations : stop.
(4)expansion expand scmiinto a set of larger, expanded,
candidate process models, cmi+1. goto step 2 using
the newly created candidate set cmi+1.
expansion consists of the replacement of one of the leaf
activity nodes aof the process tree by an operator node of
one of the operator types, where one of the child nodes is
the replaced activity node aand the other is a new activity
node representing one of the activities b∈σl. fig. 5 shows
the set of expansion operations to leaf node a, consisting of
six possible expansions. t wo types of expansion operations
are de fined for the sequence ( →) and the loop ( ) operator
types, as →(a,b)̸≡ → (b,a)and(a,b)̸≡(b,a).
however, only one expansion operation is needed for the ∧
and×operators because of their symmetry ( ∧(a,b)≡ ∧(b,a)
and×(a,b)≡ ×(b,a)). we call ∧and×symmetrical operators.
expanding the first leaf node ( a) of process tree ×(a,b)
with the ×operator and some activity c∈σlresults in the
leftmost process tree depicted on the right, while applying the
same expansion the second leaf node ( b) of the same process
tree results in a behaviorally equivalent process tree (as
shown on the right). the same holds for expansion of ∧(a,b)
with the ∧operator. therefore, the number of expansions
can be reduced further by restricting expansion of a leaf
node that has a symmetrical operator as parent with the
same symmetrical operator only to the rightmost child. this
prevents unnecessary computation by generating both of the
behaviorally equivalent trees shown on the right.
the number of possible expansion operations for a process
tree pgrows with the size of the alphabet of the event log |σl|
and the number of activity nodes in p. this is easy to see,
as each type of expansion operation can be applied to each
activity node in p, leading to 6 × |σl|expansion operations
per activity node. at every point in the expansion process, the
number of activity nodes in the tree is equal to the number of
expansion operations performed plus one, as each expansion
operation adds one activity node to the process tree.
the local process model discovery procedure stops when
no process tree in the current set of candidate process models
meets the quality criteria, or, to guarantee termination, when
a maximum number of expansion steps, max_iterations , is
reached.
the approach of iteratively expanding, selecting, and
expanding process trees described above is not theoretically188 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
fig. 5 – the set of process tree expansion operations to leaf node a, where b∈σl.
limited to the set of operator nodes described above, and can
easily be extended to other operators, such as an inclusive
choice operator or a long-term dependency operator. adding
extra operators, however, comes with the price of increased
computational complexity as it increases the number of ways
to expand a process tree.
5. quality criteria & metrics
assume for now that we have an oracle function λlnthat
generates a segmentation of a given trace σ:λln(σ)=
γ0ξ1γ1ξ2. . . ξkγk, with ξi∈l(ln)andγi̸∈l(ln), such that the
number of events in {ξ1, . . . , ξk}is maximized: the higher the
number of events in ξi∈l(ln)segments, the larger the share
of trace σexplained by the lpm. a higher value kindicates
more frequent presence of lpm execution traces in σ.λk
ln(σ)
denotes the number of ξ∈l(ln)segments in λln(σ).λξ
ln(σ)
denotes the multiset of segments ξi∈l(ln). here we discuss a
number of quality criteria for lpm with regard to an event log.
support relates to the number of fragments in the event log
that can be considered to be an instance of the lpm under
evaluation. the rationale behind this quality dimension: an
lpm whose execution traces are observed more frequently
in the event log represents it better. we transform the count
of pattern instances of lninlinto a [0,1)-interval number
through the following transformation:
support (ln,l)=
σ∈lλk
ln(σ)


σ∈lλk
ln(σ)
+1.
confidence an event fits an lpm when it is part of a segment
ξ∈l(ln). the con fidence of event type e∈σmin lpm ln
given event log l, is the ratio of events of type ainlthatfit
ln:
confidence (a,l)=
σ∈l#a(λξ
ln(σ))
#a(l).
we use the harmonic mean to aggregate con fidence values for
individual activities to a single metric, as it is more sensitive
to a single lower-than-average value than the geometric
mean. we de fine the con fidence of an lpm lngiven an event
loglto be the harmonic mean of the individual con fidence
scores of the event types of ln:
confidence (ln,l)=|σm|

a∈σm1
confidence (a,l).
language fitlanguage fit expresses the ratio of the behavior
allowed by the lpm that is observed in the event log. lpms
that allow for much more behavior than what is observed
are likely to overgeneralize and therefore do not describe thebehavior in the event log well. the language fit of an lpm ln
given log lis:
language _fit(ln,l)=|{φ∈l(ln)|∃σ∈l:φ∈λξ
ln(σ)}|
|l(ln)|.
since |l(ln)| = ∞ in case lncontains a loop, language _fit(ln,l)
=0 for any lncontaining a loop. restricting the language and
the lpm instances to sequences of a bounded length allows
us to approximate language fit for models with in finite size
language. language fit restricted to bound n∈nis defined as:
language _fitn(ln,l)=|{φ∈ln(ln)|∃σ∈l:φ∈λξ
ln(σ)}|
|ln(ln)|.
determinism flower-like process trees, like the one shown on
the right, are not desirable as they provide little insight in
what behavior we are likely to observe. deterministic lpms
have more predictive value in with regard to future behavior.
when the language of lpm lncontains traces if type σaγ1
andσbγ2, the continuation of the trace after observing pre fix
σcan be either aorb, leaving some uncertainty. lpms with
a high degree of certainty are preferable over lpms with a
low degree of certainty. a metric for the determinism quality
dimension is dependent on the process model and not only
on its language. let r(ln)be a set of reachable states of an
lpm ln.wl:r(ln)→nrepresents a function assigning the
number of times a state is reached while replaying the fitting
segments of log lonln.d:r(ln)→nrepresents a function
assigning the number of transitions enabled in a certain state
inln. determinism is de fined as:
determinism (ln,l)=
m∈r(ln)wl(m)

m∈r(ln).wl(m)·d(m).
coverage letlnbe an lpm and lbe an event log. let # ∗(l)
denote the total number of events of event log l. coverage is
defined as the ratio of the number of events in the log after
projecting the event log on the labels of lnto the number of
all events in the log:
coverage (ln,l)=#∗(lσm)
#∗(l).
5.1. local process model selection & ranking
the quality dimensions and metrics de fined are used to
select and rank local process models generated through thej o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 189
recursive process tree exploration approach. often, one is
interested in multiple quality criteria at the same time. a
high-support local process model that has a low determinism
score (e.g., a small flower pattern) does not generate much
process insight, while a deterministic pattern that has low
support does not describe the behavior in the log very well.
so it is possible to set thresholds per dimension. it is also
useful to rank patterns according to a weighted average
over the quality criteria. the appropriate weighting of the
quality dimensions depends on the business questions and
the situation at hand.
5.2. monotonicity properties & pruning
often one is not interested in local process models with a
low support, con fidence, or determinism. setting a minimum
threshold for these quality criteria allows us to prune away
those parts of the search space where we know that expan-
sions of a candidate local process model can never meet the
criteria because of monotonicity, resulting in a speedup of
the proposed recursive process tree exploration procedure.
pruning based on monotonicity is similar to the pruning per-
formed in the well-known apriori algorithm [36], and other
algorithms inspired by the apriori algorithm, such as [3].
any expansion of process tree pwhere a leaf node a∈pis
replaced by subtree →(a,b),→(b,a),∧(a,b), or(a,b)for any
b∈σlis guaranteed to be less frequent, i.e. has lower support,
than p. the intuition behind this is that expansion put
additional requirements of the alignments, possibly causing
some fitting segments for a trace σobtained by λξ
p(σ)to not fit
the expansion of p. therefore, when pdoes not meet support
threshold min sup, its expansions of any activity node ainto
→(a,b),→(b,a),∧(a,b), and(a,b)can be pruned from the
search space.
process tree pis guaranteed to be at least as deterministic
as its expansion where activity node a∈pis replaced by
subtree ×(a,b)or∧(a,b)for any b∈σl. therefore, when p
does not meet determinism threshold mindet, its expansions
of any activity node ainto×(a,b), and ∧(a,b)can be pruned
from the search space.
6. alignment-based evaluation of local pro-
cess models
we now describe a way to de fine function λln. we evaluate
lpms using petri nets because of the rich set of analysis tech-
niques available for petri nets. important for the de finition of
λlnis the notion of alignments [37], which aims to find a se-
quence of model firings starting at the initial marking and
ending in a final marking that is an optimal approximation of
the behavior in the event log. alignments relate model traces
and event log traces through a series of three types of moves:
synchronous moves ,moves on model , and moves on log . when an
event in the event log trace can be performed in the process
model, log and model can move synchronously . however, when
a trace of the log does not fit the model, log and model cannot
move synchronously from the start to the end of the trace.
amove on model corresponds to a firing of a transition in the
model that cannot be mapped to an event in the log. a move onlogcorresponds to an event in the log that cannot be mapped
to a transition firing in the model. since both moves on model
and moves on log are suboptimal behavior, they are often as-
signed certain costs such that the alignment will only chose
to do moves on model ormoves on log when these moves are un-
avoidable. moves on model enable the unwanted behavior that
a partial execution of the lpm can be identi fied as an lpm
execution trace. to avoid this behavior, we use a version of
alignments where moves on model on non-silent transitions
are prohibited (in finite costs).
alignments aim to match an event log trace with a single
execution of a process model. however, an event log trace
can contain more than one execution trace of an lpm. we
modify the petri net representation of the lpm such that we
connect each final marking to the initial marking through
a silent transition, allowing the alignment to relate a single
trace to multiple executions of the model. fig. 6(a) shows
an example lpm and fig. 6(b) shows the corresponding petri
net after transformation. we transform lpm ln(n,m0,mf)
with n=(p,t,f,σm, ℓ)into lnbl(nbl,m0,{m0})with nbl=
(p,tbl,fbl,σm, ℓbl), such that:
•tbl=t∪ {tblm|m∈mf},
•fbl=f∪ {(p,tblm)|m∈mf∧p∈m} ∪ {tblm|m∈mf∧p∈m0},
•ℓbl∈tbl→σm∪ {τ}with:
ℓbl=
ℓ(t),ift∈t,
τ, otherwise .
lnblcontains a set of added silent transitions, {tblm|m∈
mf}, consisting of one silent transition for each final marking
m∈mf.backloop :mf→tblis a bijective mapping from
afinal marking m∈mfto a silent transition tblm. a silent
transition tblmhas all places in final marking mas input and
place m0as output. the number of executions of backloop
transitions {tblm|m∈mf}in the alignments of lonln
indicates the number of executions of traces of lninl. note
that alignments require the model to be in a marking m∈mf
at the end of the alignment. this is impossible to obtain
when pattern lnis absent in log l. therefore, we set the final
marking to {m0}, allowing the alignments to make a complete
sequence of moves on log , resulting in zero executions of the
model.
fig. 6(c) illustrates the concept of alignments through
an example, showing the alignment of the non- fitting trace
⟨a,a,c,b,a,a,c,b,b,c⟩on the model of fig. 6(b). the top row
of the alignments represents the behavior of the log, while
the middle row and the bottom row represent the behavior
of the model. ≫indicates no move , with a ≫in the top row
indicating a move on model and in the middle row indicating a
move on log . the model is able to mimic the first event of the
trace by executing t1with label a, but is not able to mimic the
second ain the log, resulting in a move on log . the cand bin
the log can be mimicked (by t3and t2respectively). next event
ain the log can only be mimicked by the model by firstfiring
tbl1, resulting in a move on model , represented by the ≫in the
log. afterwards, acan be mimicked and another move on log
is needed for the second a.cand bcan again be mimicked,
after which a move on log is again needed as the log cannot
mimic tbl1. would we not have prohibited moves on models on
non-silent transition, the alignment could now have executed190 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
fig. 6 – (a) an example local process model, ln. (b) process model lnbl, constructed from lnby adding a silent connection
from final to initial marking, and the final marking set to the initial marking. (c) alignment of the trace t1onlnblwhen
disallowing model moves on non-silent transitions.
table 1 – number of transitions enabled at each point in
the alignment.
a c b τ τ a c b τ τ
t1 t3 t2 t4 tbl1t1 t3 t2 4 tbl1
1 2 1 1 1 1 2 1 1 1
amove on model ona, enabling synchronous moves on both b
and c, falsely giving the impression that the lpm would have
a third occurrence in the trace. as we prohibited the model
move ona, the only option is to decide a move on log onb
and c, thereby not counting the incomplete occurrence of the
pattern.
lpm lnis evaluated on event log lby projecting lon
the set of labels of ln,l′=lσm. the middle row of the
alignment of l′onlnblrepresents the segmentation λξ
ln,
where τmoves on a transition tbli∈ {tblm|m∈mf}indicates
the start of a new segment. the alignment in fig. 6(c) shows
that λξ
ln(⟨a,a,c,b,a,a,c,b,b,c⟩)= [⟨a,c,b⟩2].
6.1. determinism on petri nets
we now explain through an example how to calculate deter-
minism for petri nets. each transition firing in a petri net cor-
responds to a change in the marking of the net. table 1 shows
the transitions fired in the alignment of fig. 6(c). the bottom
row represents the number of transitions that were enabled
in the petri net when the transition fired. when t3fired, the
petri net was in a marking where both t2and t3were enabled.
the determinism of the net corresponds to one divided by
the average number of enabled transitions during replay. in
the example, determinism (ln,l)=10
12.
7. case studies
we now evaluate the proposed local process model mining
method on two real life data sets.7.1. bpic’12 data set
the business process intelligence challenge (bpic)’12 data
set originates from a personal loan or overdraft application
process in a global financial institution. we transformed the
event log to obtain traces of all activities in a single day
performed by one speci fic resource (bank employee). this
resource was selected randomly to be resource id 10939. the
event log for this speci fic resource contains 49 cases (working
days), 2763 events, and 14 activities. discovering the local
process models with the approach described in this paper
took 34 s on a machine with a 4-core 2.4 ghz processor using
a support threshold of 0.7.
fig. 7 shows the petri net discovered for resource 10939
with the inductive miner infrequent with a noise threshold of
20%. the discovered model only contains 13 non-silent tran-
sitions, as the activity w_valideren aanvraag isfiltered out by
the inductive miner because of its low frequency. the process
model in fig. 7 is very close to a “ flower model”, which is the
model that allows all behavior over its activities. the induc-
tive miner without noise filtering returns exactly the flower
model over the 14 activities in the log. the discovered pro-
cess is unstructured because of a high degree of variance of
the event log, which is caused by (1) the resource perform-
ing work on multiple applications interleaved, and (2) the re-
source only performing only a subset of the process steps for
each application, and which process steps he performs might
differ per application. for such a high-variance event log, it
is likely that no start-to-end process model exists that accu-
rately describes the behavior in the event log.
fig. 8 shows five local process models discovered with the
approach described in this paper, which give process insights
that cannot be obtained from the start-to-end process model
in fig. 7. local process model (a) shows that all occurrences
of events of type o_selected ,o_created, and o_sent ,
occur in this exact order. fig. 7 overgeneralizes by suggesting
that for example o_selected can be followed by three skip
(black) transitions, after which another o_selected or a
a_accepted can be performed, which never happens in
reality. o_selected and o_created in fig. 7 can be separated
bya_finalized , which makes the dependency betweenj o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 191
fig. 7 – process model of the behavior of resource 10939 in the bpic’12 log, obtained using the inductive miner infrequent
(20%).
fig. 8 – five local process models discovered on the bpi’12 log using the technique presented in this paper. clearly these
models provide more insight than fig. 7 .192 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
o_selected and o_created a long-term dependency, of
which discovery is still one of the open problems in process
mining [38] the local process model discovery method does
find this long term dependency, because each local process
model candidate is evaluated on a version of the event log
that is projected on the set of labels of candidate under
evaluation.
lpm (b) is an extension of lpm (a) as the last three activities
in the sequence are the same, therefore, each occurrence
of lpm (b) in the log will also be an occurrence of (a). lpm
(b) starts with an additional activity a_accepted of which
103 out of 104 events follow this sequential pattern. the
confidence of lpm (b) is lower than the con fidence of (a),
because only 103 out of 124 events of the last three activities
of the sequence in lpm (b) can be explained by the model
while each event of these activities is explained by lpm (a).
from this we can conclude that there are 21 occurrences of
the sequence o_selected, o_created, o_sent that are not
preceded by a_accepted . partly this can be explained by
a_accepted only occurring 104 times, however, the model
also shows that there is one a_accepted event that is not
followed by o_selected ,o_created , and o_sent . it might
be the case that this a_accepted event does not fit the
regular work flow, or alternatively it might be the case that the
other process steps of after a_accepted were executed by a
different resource. note that the determinism of lpms (a) and
(b) is 1.0, since both lpms are sequential. language fit of both
lpms is also 1.0, since both allow for only one execution path,
which is observed in the log.
local process model (c) shows that all instances of
a_finalized are in parallel with o_selected , and ultimately
followed by o_created and o_sent . this is more informative
than fig. 7, which allows for much more behavior over activi-
ties a_finalized ,o_selected ,o_created , and o_sent .
local process model (d) shows that each o_created
and o_sent is preceded by either o_canceled (29 times)
ora_finalized (95 times). also most of the o_canceled
events (29 out of 34) and most of the a_finalized events (95
out of 104) are followed by o_created and o_sent . fig. 7
does not provide the insight that o_canceled is followed
byo_created and o_sent . note that the determinism of
lpm (d) is lower than the determinism of lpm (c). this
is in agreement with the intuition of determinism, as the
concurrency at the start of lpm (c) can be regarded as a choice
between two activities followed by a deterministic step of
executing the other activity, while lpm (d) starts with a choice
between two activities. after the concurrency in lpm (c) and
the choice in lpm (d) respectively, the two models proceed
identically. local process model (d) has higher con fidence
than lpms (b) and (c) as only five of the o_canceled and nine
of the a_finalized events cannot be explained by the model.
lpm (d) has a higher con fidence than lpm (c), mostly because
all occurrences of o_created and o_sent could be aligned in
lpm (d) while only 104 out of 124 could be aligned in lpm (c).
notice that the number of events that were aligned on
a_finalized is lower in lpm (d) than in lpm (c). this
indicates that there are six occurrences where the alignments
aligned on o_canceled while it was possible as well to
align on a_finalized (as both occurred). therefore, an
inclusive choice construct would have been a more correctrepresentation than the exclusive choice that is currently
included in the lpm. note that our process tree based
discovery approach allows for easy extension with additional
operators, like e.g. an inclusive choice operator.
lpm (e) shows an example of a weaker local process
model that performs lower on some quality metrics but
can still be discovered with the described approach. the
coverage of lpm (e) is much higher than the other models as
w_nabellen offertes (dutch for “calling after call for bids”) is a
frequently occurring event in the log. the con fidence of lpm
(e) is however much lower it explains only a fraction of the
w_nabellen offertes events.
7.2. comparison with related techniques
in this section we apply some of the related techniques
described in section 3 to the event log of bpi’12 resource
10939 and compare the insights that can be obtained with
those methods with the insights that we obtained with lpm
discovery.
we start with the declare miner [33], which mines a set of
binary constraints from the data based on a set of constraint
templates. fig. 9(b) shows the result of the declare miner [33]
on the bpi’12 resource 10939 event log with a support
threshold of 90%, requiring that the constraints hold in 90%
of the cases. the model shows that a choice constraint holds
between o_selected and w_nabellen offertes , indicating that
on each working day either at least one event of type
o_selected orw_nabellen offertes occurs. the same can be
said about the pairs of event w_nabellen offertes and o_sent ,
w_nabellen offertes and o_created , and w_nabellen offertes
and o_completeren aanvraag . furthermore a not chain succession
constraint is discovered between w_nabellen offertes and
o_sent , indicating that w_nabellen offertes and o_sent never
directly follow each other. not chain succession constraints are
also discovered between w_nabellen offertes and o_selected ,
and between w_nabellen offertes and o_created . note that
the none of the insights that we obtained from the lpms in
fig. 8 could be obtained from this declare model.
by lowering the support threshold parameter of the de-
clare miner to 80%, we obtain a larger set of constraints. an
exclusive choice constraint is found between w_valideren aan-
vraag and w_nabellen offertes , indicating that 80% of the cases
contain one of the two activities but not both. the same
type of constraint is found between w_valideren aanvraag and
w_completeren aanvraag . the rest of the constraints found are
not chain succession constraints.
tofind constraints that can be deduced from the lpms of
fig. 8, such as the sequential ordering between o_selected
and o_created from lpm (a), the support threshold would
need to be lowered even further, leading to an overload
of constraints being found by the declare miner. declare
miner evaluates the constraints based on the ratio of cases
in which the constraint holds. however, when activities are
often repeated within cases, this is not a useful evaluation
criterion. employee 10939 performs most of the activities
multiple times during a working day, therefore, to assess
whether an activity ais generally followed by an activity bit is
more useful to count the ratio of occurrences of activity athatj o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 193
fig. 9 – (a) the result of the declare miner [33] with a support threshold of 80% on the bpi’12 resource 10939 event log. (b)
the result of the same method on the same log with support threshold 90%.
are followed by bas in lpm discovery, instead of the number
of cases that contain an aevent that is followed by a bevent.
even more important is the fact that declare miner is
limited to binary constraints while lpm discovery mines
n-ary relations. that is likely to be the cause of declare
mining not finding any of the lpm relations found in fig. 8.
at the same time this difference provides an explanation
why declare mining finds so many uninteresting not chain
succession constraints between activities: when there are
multiple aevents in a trace, you are likely to find at least one
athat is in a not chain succession relation with some activity
b, leading to a high ratio of traces that ful fill such a not chain
succession constraint.
fig. 10 shows the result of the fuzzy miner on the
bpi’12 resource 10939 event log with default parameters.
the discovered fuzzy model does contain a path from
o_selected through o_created too_sent , which were
shown to be in a sequential relation by lpm (a). however,
the fuzzy model allows for many more paths, therefore the
sequential relation between those three activities cannot be
inferred from the fuzzy model. lpm (c) showed a sequential
path between o_created and o_sent that is preceded by an
arbitrary ordering of activities o_selected and a_finalized .
the fuzzy model also shows arrows from both o_selected
and a_finalized too_created , however, as a fuzzy model
does not make a distinction between parallelism, inclusive
choice constructs and exclusive choice constructs, it does not
answer the question whether o_selected is preceded by both
o_selected and a_finalized , or just by one of the two.
fig. 11 shows the first four episodes found with prom’s
episode miner on the bpi’12 resource 10939 event log. the
first two episodes show the same sequential ordering from
o_selected ,o_created , and o_sent that is represented by
lpm (a). the first episode suggests that the o_created event
is optional, and can be skipped. lpm (a) however shows thatall of the o_selected events are followed by an o_created
event, therefore it is never skipped. episode (c) indicates that
o_selected and o_created can happen in any order, but
both of them have to occur before o_sent occurs and episode
(d) indicates that o_selected has to happen before o_sent
and o_created can occur. episodes (a), (c) and (d) can be
considered to be less speci fic versions of episode (b). prom’s
episode miner is not able to discover patterns with choice
constructs like lpm (d), or patterns with loops.
7.3. gazelle data set
the gazelle data set is a real life data set used in the
kdd-cup’2000 and contains customers’ web click-stream
data provided by the blue martini software company. the
gazelle data set has been frequently used for evaluating
sequential pattern mining algorithms. for each customer
there is a series of page views, in which each page view is
treated as an event. the data set contains 29 369 sequences
(customers), 87 546 events (page views), and 1423 distinct
event types (web pages). the average sequence length is
three events. more detailed information on the gazelle data
set can be found in [39]. we compare the local process
models found on this data set with the sequential patterns
obtained with the well-known sequential pattern mining
algorithm pre fixspan [13] as implemented in the spmf [14]
sequential pattern mining library. we set the minimal support
parameter of the sequential pattern mining algorithms to 10%
of the number of input sequences. all obtained sequential
patterns were also discovered by the local process model
miner. additionally, several non-sequential patterns were
discovered that cannot be discovered with sequential pattern
mining techniques, an example of which is shown in fig. 12.
this shows that this well-known sequential pattern mining
evaluation data set contains frequent and high-con fidence194 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
fig. 10 – result of the fuzzy miner [35] with default parameters on the bpi’12 resource 10939 event log.
fig. 11 – the first four episodes discovered by prom’s episode miner [18] on the bpi’12 resource 10939 event log.
patterns that cannot be found with sequential pattern mining
approaches, but can be found with the local process model
discovery approach. this indicates the applicability of local
process model discovery to the field of pattern mining.
8. conclusion & future work
this paper presents a method to discover local process mod-
els that can express the same rich set of relations between
activities as business process models, but describe frequent
fragments instead of complete start-to-end processes. we
presented five quality criteria and corresponding metrics
fig. 12 – a non-sequential local process model discovered
on the gazelle data set.
quantifying the degree of representativeness of a local pro-
cess model for an event log. we describe monotonicity prop-j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6 195
erties of quality metrics that can be used to prune the search
space and speed up computation. we illustrate through two
case studies on real-life data sets that the proposed method
enables the user to obtain process insight in the form of valu-
able patterns when the degree of randomness/variance of the
event data prevents traditional process discovery techniques
to discover a structured start-to-end process model. further-
more, the proposed local process model discovery approach
is able to discover long-term dependencies, which most pro-
cess discovery approaches have dif ficulties with, as a result of
evaluating the local process models on a projected version of
the event log.
the computational time involved in discovering local
process models rapidly grows with the number of activities in
the event log. therefore, we consider automatic discovery of
projections on the event log (limiting search to a promising
subset of the activities) to be an important area of future
work, as it would enable the discovery of local process models
on logs with larger numbers of activities. an alternative
approach to deal with larger numbers of activities that is
to be explored is the use of meta-heuristic search methods,
e.g. simulated annealing, which allows partial exploration of
the search space.
finally, we consider it to be a relevant future direction of
research to enhance local process models with guards, time
information, and resource information.
r e f e r e n c e s
[1] w.m.p. van der aalst, process mining: data science in action,
springer, 2016.
[2] h. mannila, h. toivonen, a.i. verkamo, discovery of frequent
episodes in event sequences, data min. knowl. discov. 1 (3)
(1997) 259–289.
[3] r. agrawal, r. srikant, mining sequential patterns, in: pro-
ceedings of the 11th international conference on data engi-
neering, icde, ieee, 1995, pp. 3–14.
[4] g. casas-garriga, discovering unbounded episodes in se-
quential data, in: proceedings of the 7th european confer-
ence on principles and practice of knowledge discovery in
databases, pkdd, vol. 7, springer science & business media,
2003, p. 83.
[5] m. atallah, w. szpankowski, r. gwadera, detection of signif-
icant sets of episodes in event sequences, in: proceedings of
the 4th ieee international conference on data mining, icdm,
ieee, 2004, pp. 3–10.
[6] w. reisig, petri nets: an introduction, vol. 4, springer science
& business media, 2012.
[7] object management group, notation (bpmn) version 2.0,
omg speci fication.
[8] j.c.a.m. buijs, flexible evolutionary algorithms for mining
structured process models (ph.d. thesis), technische univer-
siteit eindhoven, eindhoven, the netherlands, 2014.
[9] l.r. rabiner, a tutorial on hidden markov models and
selected applications in speech recognition, proc. ieee 77 (2)
(1989) 257–286.[10] c. goller, a. kuchler, learning task-dependent distributed
representations by backpropagation through structure,
in: ieee international conference on neural networks, 1996.,
vol. 1, ieee, 1996, pp. 347–352.
[11] s. hochreiter, j. schmidhuber, long short-term memory,
neural comput. 9 (8) (1997) 1735–1780.
[12] s.j.j. leemans, d. fahland, w.m.p. van der aalst, discovering
block-structured process models from event logs - a
constructive approach, in: application and theory of petri
nets and concurrency, springer, 2013, pp. 311–329.
[13] j. pei, j. han, b. mortazavi-asl, h. pinto, q. chen, u. dayal,
m.-c. hsu, pre fixspan: mining sequential patterns ef ficiently
by pre fix-projected pattern growth, in: proceedings of the
17th international conference on data engineering, icde,
ieee, 2001, pp. 215–224.
[14] p. fournier-viger, a. gomariz, t. gueniche, a. soltani, c.-w.
wu, v.s. tseng, spmf: a java open-source pattern mining
library, j. mach. learn. res. 15 (1) (2014) 3389–3393.
[15] j.c.a.m. buijs, b.f. van dongen, w.m.p. van der aalst, a genetic
algorithm for discovering process trees, in: proceedings of the
2012 ieee congress on evolutionary computation, cec, ieee,
2012, pp. 1–8.
[16] g. keller, a.-w. scheer, m. nüttgens, semantische prozeß-
modellierung auf der grundlage” ereignisgesteuerter
prozeßketten (epk)”, institut für wirtschaftsinformatik,
1992.
[17] international organization for standardization, iso/iec
19505-1:2012 - information technology - object management
group uni fied modeling language (omg uml) - part 1:
infrastructure.
[18] m. leemans, w.m.p. van der aalst, discovery of frequent
episodes in event logs, in: data-driven process discovery and
analysis, springer, 2014, pp. 1–31.
[19] j. lu, w. chen, o. adjei, m. keech, sequential patterns post-
processing for structural relation patterns mining, in: strate-
gic advancements in utilizing data mining and warehousing
technologies: new concepts and developments, 2009, p. 216.
[20] j. lu, x.-f. wang, o. adjei, f. hussain, sequential patterns
graph and its construction algorithm, chinese j. comput. 27
(6) (2004) 782–788.
[21] j. lu, w. chen, m. keech, graph-based modelling of
concurrent sequential patterns, exploring adv. interdiscip.
data min. anal.: new trends (2011) 110.
[22] j.-y. jung, j. bae, l. liu, hierarchical business process
clustering, in: proceedings of the 2008 ieee international
conference on services computing, scc, vol. 2, ieee, 2008,
pp. 613–616.
[23] c. diamantini, d. potena, e. storti, mining usage patterns
from a repository of scienti fic work flows, in: proceedings of
the 27th annual acm symposium on applied computing,
sac, acm, 2012, pp. 152–157.
[24] c. diamantini, l. genga, d. potena, e. storti, pattern discovery
from innovation processes, in: proceedings of the 2013
international conference on collaboration technologies and
systems, cts, ieee, 2013, pp. 457–464.
[25] c. diamantini, l. genga, d. potena, behavioral process mining
for unstructured processes, j. intell. inf. syst. (2016) 1–28.
[26] b.f. van dongen, w.m.p. van der aalst, multi-phase process
mining: building instance graphs, in: international confer-
ence on conceptual modeling, springer, 2004, pp. 362–376.
[27] m. song, c.w. günther, w.m.p. van der aalst, trace clustering
in process mining, in: business process management
workshops, springer, 2008, pp. 109–120.
[28] r.p. jagadeesh chandra bose, w.m.p. van der aalst, context
aware trace clustering: towards improving process mining
results, in: proceedings of the 2009 siam international
conference on data mining, siam, 2009, pp. 401–412.196 j o u r n a l o f i n n o v a t i o n i n d i g i t a l e c o s y s t e m s 3 ( 2 0 1 6 ) 1 8 3 – 1 9 6
[29] f. folino, g. greco, a. guzzo, l. pontieri, mining usage
scenarios in business processes: outlier-aware discovery
and run-time prediction, data knowl. eng. 70 (12) (2011)
1005–1029.
[30] b.f.a. hompes, j.c.a.m. buijs, w.m.p. van der aalst, p.m. dixit,
j. buurman, discovering deviating cases and process variants
using trace clustering, in: proceedings of the 27th benelux
conference on arti ficial intelligence, bnaic, november, pp.
5–6.
[31] m. pesic, h. schonenberg, w.m.p. van der aalst, declare:
full support for loosely-structured processes, in: enterprise
distributed object computing conference, 2007. edoc 2007.
11th ieee international, ieee, 2007, pp. 287–298.
[32] s. schönig, c. cabanillas, s. jablonski, j. mendling, mining
the organisational perspective in agile business processes,
in: enterprise, business-process and information systems
modeling, springer, 2015, pp. 37–52.
[33] f.m. maggi, a.j. mooij, w.m.p. van der aalst, user-guided
discovery of declarative process models, in: 2011 ieee
symposium on computational intelligence and data mining,
cidm, ieee, 2011, pp. 192–199.[34] f.m. maggi, t. slaats, h.a. reijers, the automated discovery
of hybrid processes, in: business process management,
springer, 2014, pp. 392–399.
[35] c.w. günther, w.m.p. van der aalst, fuzzy mining–adaptive
process simpli fication based on multi-perspective met-
rics, in: business process management, springer, 2007,
pp. 328–343.
[36] r. agrawal, r. srikant, et al., fast algorithms for mining
association rules, in: proceedings of the 20th international
conference on very large data bases, vldb, vol. 1215,
morgan kaufmann, 1994, pp. 487–499.
[37] w.m.p. van der aalst, a. adriansyah, b.f. van dongen,
replaying history on process models for conformance
checking and performance analysis, wiley interdiscip. rev.:
data min. knowl. discov. 2 (2) (2012) 182–192.
[38] w.m.p. van der aalst, a.j.m.m. weijters, process mining: a
research agenda, comput. ind. 53 (3) (2004) 231–244.
[39] r. kohavi, c.e. brodley, b. frasca, l. mason, z. zheng, kdd-
cup 2000 organizers’ report: peeling the onion, acm sigkdd
explor. newslett. 2 (2) (2000) 86–93.