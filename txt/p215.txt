workﬂow mining: current status and future
directions
a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
department of technology management, eindhoven university of technology
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
{a.k.medeiros, w.m.p.v.d.aalst, a.j.m.m.weijters }@tm.tue.nl
abstract. current workﬂow management systems require the ex-
plicit design of the workﬂows that express the business process of an
organization. this process design is very time consuming and errorprone. considerable work has been done to develop heuristics tomine event-data logs to produce a process model that can supportthe workﬂow design process. however, all the existing heuristic-basedmining algorithms have their limitations. to achieve more insight intothese limitations the starting point in this paper is the α-algorithm [3]
for which it is proved under which conditions and process constructs the
algorithm works. after presentation of the α-algorithm, a classiﬁcation
is given of the process constructs that are diﬃcult to handle for thistype of algorithms. then, for some constructs (i.e. short loops) it isillustrated in which way the α-algorithm can be extended so that it can
correctly discover these constructs.
keywords: process mining, workﬂow mining, petri nets, workﬂow petri
nets.
1 introduction
every company wants to produce more in less time. one way to accomplish this
is having a well-deﬁned business process model that reﬂects the dependenciesamong tasks and also tasks that can be processed in parallel. workﬂow man-
agement (wfm) systems oﬀer the functionality to design and enact operational
processes.
in an ideal situation, well-deﬁned business processes should be designed be-
fore enactment is possible and, redesigned whenever changes happen. however,in practice a lot of time is spent on modelling business process while the result-ing workﬂow models are typically still error prone, because knowledge about thewhole process is scattered among employees and paper procedures.
to avoid the above mentioned diﬃculties, instead of starting with a process
design, our process mining starts by gathering information about the processesas they take place. we assume that it is possible to record events such that(i) each event refers to a task (i.e., a well-deﬁned step in the process), (ii) eachevent refers to a case (i.e., a process instance), and (iii) events are totally ordered.any information system using transactional systems such as erp (enterprise
r. meersman et al. (eds.): coopis/doa/odbase 2003, lncs 2888, pp. 389–406, 2003.
c/circlecopyrtspringer-verlag berlin heidelberg 2003390 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
resource planning), crm (customer relationship management), b2b (busi-
ness to business), scm (supply chain management) and wfm systems willoﬀer this information in some form. note that we do not assume the presence ofa wfm system. the only assumption we make, is that it is possible to collect aprocess log that records the order in which the events take place.
table 1. a process log.
case identiﬁer task identiﬁer
case 1 task a
case 2 task a
case 3 task a
case 3 task b
case 1 task b
case 1 task c
case 2 task c
case 4 task a
case 2 task b
case 2 task d
case 5 task e
case 4 task c
case 1 task d
case 3 task c
case 3 task d
case 4 task b
case 5 task f
case 4 task d
to illustrate the principle of process mining, we consider the process log
shown in table 1. this log contains information about ﬁve cases (i.e., processinstances) and six tasks (a..f). based on the information shown in table 1 andby making some assumptions about the completeness of the log (i.e., assumingthat the cases are representative and a suﬃcient large subset of possible behaviorsis observed) we can deduce for example the process model shown in figure 1.the model is represented in terms of a petri net [17]. after executing a, tasks band c are in parallel. note that for this example we assume that two tasks arein parallel if they appear in any other. by distinguishing between start eventsand end events for tasks it is possible to explicitly detect parallelism. instead ofstarting with a the process can also start with e. task e is always followed bytask f. table 1 contains the minimal information we assume to be present.
for this simple example, it is quite easy to construct a process model that is
able to regenerate the process log. for larger process models this is much morediﬃcult. for example, if the model exhibits alternative and parallel routing, thenthe process log will typically not contain all possible combinations. moreover,certain paths through the process model may have a low probability and there-fore remain undetected. noisy data (i.e., logs containing exceptions) can furtherworkﬂow mining: current status and future directions 391
ab
cd
e f
fig. 1. a process model corresponding to the process log.
complicate matters. these are just some of the problems that we need to face in
process mining research.
the focus of most research in the domain of process mining is on mining
heuristics based on ordering relations of the events in the process log (cf. sec-tion 5). considerable work has been done on heuristics to mine event-data logsto produce a process model that can support the workﬂow design process. how-ever, all the existing heuristic-based mining algorithms have their limitations.typically, more advanced process constructs are diﬃcult to handle for existingmining algorithms. some of these problematic constructs are common in work-ﬂows and, therefore, need to be addressed to enable practical application. toachieve more insight into these limitations, the focus of this paper is a moreanalytical approach. the starting point of this paper is the α-algorithm [3]. also
theα-algorithm is primarily based on the ordening relations between events.
however, the mining algorithm is not based on a heuristic, but on a formal algo-rithm for which it is proved under which conditions and process constructs the
algorithm works. by discussing the weaknesses and strengths of the α-algorithm,
we show how concepts in workﬂow mining could be improved in order to allowthe correct mining of common constructs that appear in workﬂow system (loops,duplicate tasks, implicit places, non-free-choice constructs, etc.). our ﬁnal goalis to extend the α-algorithm so that the class of constructs for which we can
prove that we can mine them correctly becomes larger. for some constructs (i.e.
short loops) it is illustrated how the α-algorithm can be extended so that it can
correctly handle these constructs.
the rest of the paper is organized as follows. in section 2, the α-algorithm
is explained. problematic constructs that are not adequately tackled by α-
algorithm are explained in section 3. possible ways to tackle these constructsare discussed in section 4. section 5 discusses related work on process mining.the ﬁnal observations and comments are given in section 6.
2 workﬂow mining: the α-algorithm
theα-algorithm receives as input an event log and returns as output a place/-
transition net (p/t-net) [17]. this section shows the main concepts required tounderstand the α-algorithm. a complete description and its properties is given
in [3].
in the more theoretical approach, we do not focus on issues such as noise.
we assume that there is no noise and that the workﬂow log contains “suﬃcient”information. under these ideal circumstances we investigate whether the αal-392 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
gorithm is possible to rediscover the workﬂow process, i.e., for which class of
workﬂow models is it possible to accurately construct the model by merely look-ing at their logs. the αalgorithm is based on four ordering relations which can
be derived from the log: >
w,→w,#w, and /bardblw.
deﬁnition 2.1. (log-based ordering relations) letwbe a workﬂow log
overt, i.e., w∈p(t∗). let a, b∈t:
–a>wbif and only if there is a trace σ=t1t2t3...tn−1andi∈{1,...,n −2}
such that σ∈wandti=aandti+1=b,
–a→wbif and only if a>wbandb/negationslash>wa,
–a#wbif and only if a/negationslash>wbandb/negationslash>wa, and
–a/bardblwbif and only if a>wbandb>wa.
relation →wsuggests causality and relations /bardblwand # ware used to diﬀer-
entiate between parallelism and choice. since all relations can be derived from>
w, we assume the log to be complete with respect to >w(i.e., if one task can
follow another task directly, then the log should have registered this potentialbehavior). structured workﬂow petri nets (swf-nets) are a subclass of workﬂownets (wf-nets) in which the net structure explicitly shows its behavior. conse-quently, in swf-nets (i) choice and synchronization are not mixed, and (ii) ifthere is a synchronization, all of its preceding transitions will have ﬁred. theseconstraints are illustrated in figure 2. additionally, swf-nets do not allow forimplicit places in the net structure [3].
(i) (ii)
fig. 2. constructs not allowed in swf-nets.
to formally deﬁne the αalgorithm we introduce some basic terminology.
deﬁnition 2.2. ( ∈,ﬁrst,last)lettbe a set of tasks. let σ=a1a2...a n∈t∗
a sequence over tof length n.∈,ﬁrst, and lastare deﬁned as follows:
1.a∈σif and only if a∈{a1,a2,...a n},
2. ifn≥1, then ﬁrst(σ)=a1and last(σ)=an.
now we can give the formal deﬁnition of the αalgorithm followed by a more
intuitive explanation.
deﬁnition 2.3. (mining algorithm α)letwbe a workﬂow log over t.α(w)
is deﬁned as follows.
1.tw={t∈t|∃σ∈wt∈σ},
2.ti={t∈t|∃σ∈wt=ﬁrst(σ)},workﬂow mining: current status and future directions 393
3.to={t∈t|∃σ∈wt=last(σ)},
4.xw={(a, b)|a⊆tw∧b⊆tw∧∀ a∈a∀b∈ba→wb∧
∀a1,a2∈aa1#wa2∧∀ b1,b2∈bb1#wb2},
5.yw={(a, b)∈xw|∀(a/prime,b/prime)∈xwa⊆a/prime∧b⊆b/prime=⇒(a, b)=(a/prime,b/prime)},
6.pw={p(a,b )|(a, b)∈yw}∪{iw,ow},
7.fw={(a, p (a,b ))|(a, b)∈yw∧a∈a}∪{ (p(a,b ),b)|(a, b)∈
yw∧b∈b}∪ {(iw,t)|t∈ti}∪ {(t, ow)|t∈to}, and
8.α(w)=(pw,tw,fw).
theα-algorithm works as follows. first, it examines the log traces and (step 1)
creates the set of transitions ( tw) in the workﬂow, (step 2) the set of output
transitions ( ti) of the source place , and (step 3) the set of the input transitions
(to) of the sink place1. in steps 4 and 5, the α-algorithm creates sets ( xwand
yw, respectively) used to deﬁne the places of the mined workﬂow net. in step
4, it discovers which transitions are causally related. thus, for each tuple ( a, b)
inxw, each transition in set acausally relates to alltransitions in set b, and
no transitions within a(orb) follow each other in some ﬁring sequence. these
constraints to the elements in sets aandballow the correct mining of and-
split/join and or-split/join constructs. note that the or-split/join requires thefusion of places. in step 5, the α-algorithm reﬁnes set x
wby taking only the
largest elements with respect to set inclusion. in fact, step 5 establishes the exactamount of places the mined net has (excluding the source place i
wand the sink
place ow. the places are created in step 6 and connected to their respective
input/output transitions in step 7. the mined workﬂow net is returned in step8.
deﬁnition 2.4. (ability to rediscover) letn=(p,t,f ) be a sound wf-
net and let the αbe a mining algorithm which maps workﬂow logs of nonto
sound wf-nets. if for any complete workﬂow log wofnthe mining algorithm
returns n(modulo renaming of places), then the αis able to rediscover n.
an algorithm/heuristic is said to rediscover a workﬂow net if this algorithm is
able to regenerate the exact net structure of the original net, abstracting from
the place labels (see deﬁnition 2.4). the α-algorithm is proved to (re)discover all
swf-nets if the swf-net does not contain short-loops. that means that shortloops are a ﬁrst limitation of the α-algorithm. however, if the notion of ability to
rediscover is relaxed to behaviorally equivalent (i.e. both generate the same log
traces), then the α-algorithm is able to mine other sound wf-nets, like the one
in figure 3. this net is not an swf-net because transition gcan be enabled
without the ﬁring of transitions eandf. however, even with this relaxed notion
ofability to rediscover and the restriction on short-loops, the α-algorithm cannot
be proved to correctly mine all sound wf-nets.the next section classiﬁes the situations to which the α-algorithm fails to mine
sound wf-nets. understanding the limitations of α-algorithm helps in develop-
ing new algorithms/heuristics to tackle these limitations.
1in a workﬂow net, the source place ihas no input transitions and the sink place o
has no output transitions.394 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
i xb
o
dg
f
p2cep1or-join
and-join
fig. 3. a wf-net that can be rediscovered by the α-algorithm, although it is not an
swf-net.
3 limitations of the α-algorithm: loops, invisible tasks,
and duplicate tasks
as motivated in the previous section the α-algorithm can successfully mine swf-
nets that do not contain short-length loops. but, the α-algorithm has also serious
limitations. although it is possible to represent many real workﬂows using swf-nets, these nets do not support other common constructs like invisible tasks and
duplicate tasks . in this section we present a classiﬁcation of possible common
constructs the α-algorithm cannot mine correctly, and relations between these
constructs. some of the constructs are within the scope of swf-nets (like short
loops), but others are beyond the scope of swf-nets (like duplicate tasks ).
to ﬁnd out the constructs the α-algorithm cannot mine correctly, it is nec-
essary to understand how it works. basically, the α-algorithm has the following
behavior:
–a task exists in the resulting net if it is in any log trace;
–a task has ingoing arc(s) in the resulting net if (i) this task is the ﬁrsttask
in a log trace, or (ii) this task causally follows another task.
–a task has outgoing arc(s) in the resulting net if (i) this task is the lasttask
in a log trace, or (ii) this task is causally followed by another task.
if a task is not the ﬁrst or last task in any trace log, andis not involved
in any causal relation, the α-algorithm does not generate ingoing and outgoing
arcs for this task. for instance, see net n
3in figure 4. note that task bis not
connected to any place in the resulting net. however, even if all the transitionsare connected in the resulting net, this does not guarantee that the α-algorithm
correctly mined the net. for instance, see the original and resulting nets in ﬁgures5, 6, 7 and 8.
places are created based on the causal (→
w) and exclusive (#w) relations.
however, in some situations the resulting net does not have the same number ofplaces the original net has. for instance, consider the net in figure 3 and net n
1
in figure 5. both nets are non-swf-net and have similar net structures. in fact,
these nets are not the same because each task eandfhas only oneoutgoing
arc in net n1. this slight diﬀerence in the net structure leads to the inferring
of diﬀerent causal and exclusive relations to these two nets. consequently, theα-algorithm cannot correctly mine n
1, but it can mine the net in figure 3.workﬂow mining: current status and future directions 395
n5b i x a o yresulting net:
n6n1i x
ao ybn0i x
ao yb
ba
i xa
o
by
n2i xa
o
byresulting net:
i xa
o
by
n3i x a ob
yresulting net:
i x a ob
y
n4i x
ao y
bresulting net: i x
ao y
b
resulting net:
i x a b o y
i x a o
byresulting net:
i xa
ob
y
fig. 4. example of the existing relations between duplicate tasks, invisible tasks and
one/two-length loops.
resulting net:
n1and-join
i xb
o
dg
fceor-join
n2i xb
od
g
fceand-join
or-joinx
b d
gfc
ei
o
fig. 5. mined and original nets have diﬀerent number of places.396 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
i a
ba
ob
n3n1 i xa
a
bb
o
n2 ia
a
bb
oresulting net:
i a b oresulting net:
i xa
bo
resulting net:
ia
bo
fig. 6. nets with duplicate tasks.
there are problems in the resulting net the α-algorithm produces when its in-
putis incomplete and/or has noise (because diﬀerent relations may be inferred).
but even if the log is noise free and complete, there are a number of workﬂowconstructs that causes problems for the α-algorithm. below we will discuss them.
one-length loop. in a one-length loop, the same task can be executed multiple
times in sequence. thus, all ingoing places of this task are also its outgoing placesin the wf-net. in fact, for swf-nets, a one-length-loop task can only have onesingle place connected to it. as an example, see net n
5in figure 7, and also net
n1in figure 4. note that in the resulting nets, the one-length-loop transitions
do not have the same place as its ingoing and outgoing place. this happensbecause, to generate a place with a common ingoing and outgoing task, the α-
algorithm requires the causal relation task→
wtask. but it is impossible to
havetask > wtaskandtask/negationslash>wtaskat the same time.
two-length loop. in this case, the α-algorithm infers the two involved tasks
are in parallel and, therefore, no place is created between them. for instance,see nets n
3andn4in figure 4. note that there are no arcs between tasks a
andbin the resulting net. however, the α-algorithm would correctly mine both
n3andn4if the relations a→wbandb→wawere inferred, instead of the
relation a||wb.
invisible tasks. invisible tasks do not appear in any log trace. consequently,
they do not belong to tw(set of transitions in the mined net) and cannot be
present in the net the α-algorithm generates. two situations lead to invisible
tasks: (i) a task is not registered in the log, for instance, because it may haveonly a routing purpose (e.g., see tasks without label in net n
2, figure 5), or (ii)
there is noise in the log generation and real tasks are missing in the log traces.duplicate tasks. sometimes a task appear more than once in the same work-
ﬂow. in this case, the same label is given (and thus registered in the log) tomore than one task. this can happen, for instance, when modelling the bookingworkﬂow mining: current status and future directions 397
i x
ao y n5n6i x a o yn2ixa
o
ay
n3i x a o
ayn1i x a o a y
n4i x a o y
resulting net: i x a o y
resulting net:
i x
ao y
fig. 7. example of the existing relations between duplicate tasks, invisible tasks and
one-length loops.
process in a travel agency. clients can go there to book a ﬂight only, book a hotel
only, or both. thus, a workﬂow model describing this booking situation could be
like net n3, in figure 6 (assume a=“book ﬂight” and b=“book hotel”). note
that the resulting net for net n3contains only one task with label aand one
withb. the α-algorithm will never capture task duplication because it cannot
distinguish diﬀerent task with the same label (see also the other nets in figure6). in fact, in an swf-net it is assumed that tasks are uniquely identiﬁable.thus, a heuristic to capture duplicate tasks will have to generate wf-nets inwhich tasks can have identical labels.implicit places. swf-nets do not have implicit places. places are implicit if
their presence or absence does not aﬀect the possible log traces of a workﬂow.for example, places p3 and p4 are implicit in net n
3(see figure 8). note that
the same causal relations are inferred when these implicit places are present orabsent. however, the α-algorithm creates places according to the existing causal
relations. thus, implicit places cannot be captured because they do not inﬂuencecausal relations between tasks. note also that this same reason prevents the α-
algorithm of generating explicit places between tasks that do not have a causal
relation. as an example, see places p1 and p2i nn e t n
2(also in figure 8). both
places constrain the execution of tasks dandebecause the choice between the
execution of these tasks is made after the execution of aorb, respectively, and
not after the execution of c. in fact, if the places p1 and p2 are removed from
n2, netn4is obtained (see figure 8). however, in n4, the choice between the
execution of tasks dandeis made after the execution of task c. consequently,
a log trace like xacey can be generated by n4, but cannot by n2.
non-free choice. the non-free choice construct combines synchronization and
choice. thus, it is not allowed in swf-nets because it corresponds to construct(i) in figure 2. nets containing non-free choice constructs are not always minedcorrectly by the α-algorithm. for instance, consider the non-free-choice net n
2,
figure 8. the α-algorithm does not mine correctly n2because this net cannot398 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
non-free
choice
constructn1
n4i xa
o
by
e cd c
n2i xa
o
by
ecdp1
p2
n3i xa
o
by
e cd c
p4p3
resulting net:i xa
o
by
ecdimplicit
places
i xa
o
by
ecd
fig. 8. example of existing relations between duplicate tasks, non-free choice nets,
implicit places and swf-nets.
generate any log trace with the substring adand/or be. consequently, there
is no causal relation a→wdandb→we, and no creation of the respec-
tive places p1 and p2 in the resulting net. however, there are non-free choice
constructs which the α-algorithm can mine correctly. as an example, consider
netn1in figure 9. this net is similar to net n2in figure 8, but n1has two
additional tasks fandg. the α-algorithm can correctly mine n1because there
is a causal relation f→wd(enabling the creation of place p1) and g→we
(enabling the creation of p2). thus, the α-algorithm can correctly mine non-free-
choice constructs as far as the causal relations can be inferred.synchronization of or-join places. the synchronization of or-join places
is a non-swf-net construct because it correspond to construct (ii) in figure 2.however, although this is a non-swf-net construct, sometimes the α-algorithm
can correctly mine it. for instance, see the wf-net in figure 3. places p1 and p2
are or-join places. p1 is an or-join place because it contains a token if task bor
eorfis executed. similarly, p2 if task doreorfis executed. besides, both
p1 and p2 are synchronized at task g, since this task can happen only when there
is a token in both p1andp2. note that this construct corresponds to a non-swf-
net because task gcan be executed whenever some of the tasks that precede it
have been executed. if the net in figure 3 were an swf-net, task gcould be
executed only after the execution of tasks b,d,eandf. however, although
the net in figure 3 is a non-swf-net, the α-algorithm can correctly mine it
because the necessary and suﬃcient causal (→
w) and exclusive (#w) relations
are inferred. however, for some synchronization of or-join places constructs,
the inferred causal and exclusive relations are not enough to correctly minethe net. for instance, consider net n
1in figure 5. the resulting net the α-
algorithm mines is not equal to n1because it contains two additional placesworkﬂow mining: current status and future directions 399
among tasks b,d,e,fand task g. this net structure with extra places derives
from the inferred relations. note that because b/bardblwdande/bardblwfin net n1,
butb#we,b#wf,d#weandd#wf, the places p({b,e},{g}),p({b,f},{g}),
p({d,e},{g})andp({d,f},{g})are created by the α-algorithm, when only places
p({b,e},{g})andp({d,f},{g})would do. thus, in this case, the inferred relations
do not allow the α-algorithm to correctly mine the net. however, the resulting
net is behaviorally equivalent to the original net, even if their structures are
diﬀerent because both nets generate exactly the same set of traces.
non-free choice
constructn1i xa
o
by
ecdp1
p2f
g
fig. 9. example of a non-free choice net which the α-algorithm can mine correctly.
there are relations among the problematic constructs that imply in trade-oﬀs.
the problematic constructs are related because (i) the same set of log tracescan satisfy the current notion of log completeness, and/or (ii) the same set ofordering relations can be inferred when the original net contains one of theconstructs. therefore, no mining algorithm can detect which of the constructsare in the original net. in fact, any mining algorithm must choose which one ofthe related constructs is going to be used in the resulting net. some examplesdemonstrating that the problematic constructs are related:duplicate tasks (sequence vs parallel vs choice). duplicate tasks can
be in sequential ,paral lel ,o r choice structures in the wf-net. these duplicate
task structures are related because the same complete log can satisfy diﬀerentwf-nets containing them. as an example, see the respective nets n
1,n2andn3
in figure 7. note that a log containing onlythe trace xaay would be complete
for the three nets n1,n2, and n3. thus, given this input trace, it is impossible
for a mining algorithm to determine which duplicate task structure really existsin the original net.invisible tasks vs duplicate tasks. wf-nets with the same ordering re-
lations can be created either using invisible tasks or using duplicate tasks. forinstance, consider nets n
3andn4in figure 7. their ordering relations are the
same whatever the workﬂow log. additionally, note that a log containing only
the trace xaay would be complete also for nets n1−3andn4.
invisible tasks vs loops. behaviorally equivalent wf-nets can be created
either using invisible tasks or using loops. for instance, consider nets n5andn6
in figure 7. these nets generate exactly the same set of log traces.
invisible tasks vs synchronization of or-join places. see nets n1and
n2in figure 5. the α-algorithm generates the same resulting net for both n1
andn2because these nets are behaviorally equivalent.
non-free choice vs duplicate tasks. netsn1andn2in figure 8 are
behaviorally equivalent.400 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
loops vs invisible tasks together with duplicate tasks. nets with equal
sets of ordering relations can be created if loops or invisible tasks in combinationwith duplicate tasks are used. for instance, see nets n
0andn1in figure 4. net
n0has duplicate tasks and invisible tasks in its structure. net n1has two one-
length loops, involving tasks aandb. these two nets lead to the same set of
ordering relations because, whatever the complete log, the inferred causal andparallel ordering relations will always be x→
wa,x→wb,x→wy,
b→wy,a→wy, and a||wb.
in fact, these relations raise questions like: is it possible to develop heuristicsthat detect both loops and invisible tasks? duplicate tasks and invisible tasks?if it is not, what problematic constructs should have priority in the mining? inwhat situations? these are the kind of questions our current research is tryingto answer. in the following section we explain possible approaches to tackle theclasses of structural constructs the α-algorithm cannot mine correctly. addition-
ally, we give examples on how to apply these approaches.
4 approaches to tackle structural problematic
constructs
process mining can be viewed as a three-phase process: pre-processing ,process-
ingand post-p rocessing . in the pre-processing phase, based on the assumption
that the input log satisﬁes the required notion of log completeness, the order-ing relations are inferred. the processing phase corresponds to the executionof the mining algorithm, given the log and the ordering relations as input. inour case, the mining algorithm is the α-algorithm. during post-processing, the
mined petri-net can be ﬁne-tuned and a graphical representation can be build.possible approaches to tackle structural problematic constructs focus on one ormore of these phases.
in this section, we use the problematic constructs one- and two-length loops in
swf-nets to exemplify how approaches can be developed to tackle problematicconstructs. we chose to tackle them ﬁrst because in this way we can extend the α-
algorithm to mine all swf-nets (including short loops). subsection 4.1 containsan approach to tackle one-length loops. this is a mixed approach that focussesboth on the pre- and post-processing phases. subsection 4.2 presents an approachto tackle two-length loops. this approach focusses on the pre-processing phase.
4.1 example of a mixed approach focusing on the pre- and
post-processing phases
to develop an approach to tackle one-length loops in swf-nets, we ﬁrst deter-
mine (i) how one-length loops can be identiﬁed in the input log and (ii) whatkind of patterns can be used to build them in swf-nets.identiﬁcation. one-length loops can be identiﬁed by checking if there are log
traces containing the substring t
1t1. for instance, any complete log for n5in
figure 7 contains the trace xaay .workﬂow mining: current status and future directions 401
wf-structure. for swf-nets, it can be proven that one-length-loop tasks are
connected to a single place. the wf-structure is illustrated in figure 10.
x y p1
a
fig. 10. structure of one-length loops in swf-nets.
the reasoning used to identify this single structure is as follows. let task abe
in a one-length loop. first, acan never be connected to source/sink places in an
swf-net because the source place ihas no ingoing task and the sink place ohas
no outgoing task. second, task acannot have more than one ingoing place (see
n1in figure 11) because swf-nets do not allow for synchronization and choice
to mixed (recall construct (i) in figure 2). third, task acannot be connected
to places that are only its outgoing places (see n2in figure 11) because these
places can contain more than one token. all places in swf-nets contain at most
one token. finally, at least two other tasks ( xandy) are necessary. the xtask
puts a token in the place connected to a(all tasks are live in swf-nets). the
yremoves a token from this place (in swf-nets, no tasks can execute after the
process termination).
n1n2 i x y o
ai x y o
a
fig. 11. illustration of the reasoning used to determine the single structure of one-
length loops in swf-nets.
the unique structure in which one-length loops appears in swf-nets is repre-
sented in figure 10. three distinct tasks can be distinguished: the one-length-
loop task ( a), one ingoing task (x) and one outgoing task (y). consequently, for
every one-length-loop pattern, there are at least the causal relations: x→wy,
x→waanda→wy. besides, every one-length-loop task ais connected to
a single place ( p1 in figure 10) because we are working with swf-nets. thus,
if we remove afrom this pattern, it is still possible to mine p1 in this pattern
because the causal relation x→wystill exists. in order words, it is possible to
mine the basic swf-net structure of the workﬂow process without consideringthe one-length-loop tasks when inferring the ordering relations. this reasoningis the base for the following mixed approach.
first, in a pre-processing phase the one-length-loop tasks and their respective
neighbors are identiﬁed and recorded. then, the one-length-loop tasks are elimi-nated from the log. secondly, the α-algorithm is applied to the pre-processed log.402 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
the result is a wf-net with the x→wycausal relation and the p1place. in
the post-p rocessing phase, based on the recorded data, the one-length loop tasks
are connected to the right places in the wf-net generated by α-algorithm. note
that this approach does not modify the processing phase (i.e. the αalgorithm)
itself.
4.2 example of an approach focusing on the pre-processing phase
to build an approach to tackle two-length loops in swf-nets, we ﬁrst need to
set (i) how two-length loops can be identiﬁed and (ii) what kind of patterns canbe used to build them in swf-nets.identiﬁcation. the current notion of log completeness does not allow the diﬀer-
entiation between tasks in parallel and tasks in a two-length loop. this happensbecause a log can be complete without having one trace in which the two-length-loop tasks follow one another in a row. in other words, if t
1andt2belong to
a two-length loop in an swf-net, a log can be complete without having thepattern t
1t2t1. for instance, see net n1in figure 12. the log containing the
traces xay,xabw ,xw,zbw ,zbay andzyis complete. however, this
log does not contain the pattern aba. thus, any approach to tackle two-length
loops in swf-nets requires a new notion of log completeness.
n1i x o y
zw
a
b
fig. 12. example of an swf-net for which the new notion of log completeness is
required to correctly capture 2-length loops.
wf-structure. recall that the current deﬁnition of ordering relations infers
that tasks in two-length loops are in parallel. in contrast to one-length-loops thepossible structure for two-length loops is not completely clear. our discoveriesso far shows that two-length loops can be mined correctly if the causal relationsof tasks involved in the two-length loop are correctly mined.
our proposed solution for the two-length-loop problem is an adaptation of
the original deﬁnition of log completeness and an adaptation of the deﬁnition ofsome the basic relations.
in the original deﬁnition of log completeness (section 2), we assume the log
to be complete with respect to >
w(i.e., if one task can follow another task
directly, then the log should have registered this potential behavior). in theadapted version not only the binary >
wrelation, but also triples are involved.
if the pattern t1t2t1is possible, a complete log must contain this triple.
using this insight, we redeﬁne deﬁnition 2.1, i.e., we provide new deﬁnitions
for the four basic ordering relations >w,→w,#w, and /bardblw.workﬂow mining: current status and future directions 403
deﬁnition 4.1. (ordering relations capturing two-length loops) letw
be a loop-complete workﬂow log over t, i.e., w∈p(t∗). let a, b∈t:
–a>/prime/prime
wbif and only if there is a trace σ=t1t2t3...tn−1andi∈{1,...,n −2}
such that σ∈wandti=aandti+1=b,
–a→/prime/prime
wbif and only if ( a>wband (b/negationslash>waor∃σ∈w[σ=t1t2t3...tnand
i∈{1,...,n −2}andti=ti+2=aandti+1=b])) ,
–a#/prime/prime
wbif and only if a/negationslash>wbandb/negationslash>wa, and
–a/bardbl/prime/prime
wbif and only if a>wbandb>waand¬∃σ∈w[σ=t1t2t3...tnand
i∈{1,...,n −2}andti=ti+2=aandti+1=b])).
note that deﬁnition 4.1 considers the new notion of log completeness. the
main idea is that two tasks t1andt2(with t1/negationslash=t2), will be in parallel if, and
only if, there is no log trace containing the substring t1t2t1.i ft h e α-algorithm
is applied using the new deﬁnition 4.1, an swf-net containing two-length loopscan be mined. examples are the nets n
3andn4in figure 4, and net n1in
figure 12. note that this approach enables the mining of swf-nets with two-length-loops by modifying only the pre-processing phase (establishing the basicrelations →
w,#w, and /bardblw).
5 literature on process mining
the idea of process mining is not new [4,6,7,8,10,11,12,14,15,18,19,2,20,3]. cook
and wolf have investigated similar issues in the context of software engineeringprocesses. in [6] they describe three methods for process discovery: one usingneural networks, one using a purely algorithmic approach, and one markovianapproach. the authors consider the latter two the most promising approaches.the purely algorithmic approach builds a ﬁnite state machine where states arefused if their futures (in terms of possible behavior in the next k steps) areidentical. the markovian approach uses a mixture of algorithmic and statisticalmethods and is able to deal with noise. note that the results presented in [6] arelimited to sequential behavior. cook and wolf extend their work to concurrentprocesses in [7]. they propose speciﬁc metrics (entropy, event type counts, pe-riodicity, and causality) and use these metrics to discover models out of eventstreams. however, they do not provide an approach to generate explicit processmodels. recall that the ﬁnal goal of the approach presented in this paper is toﬁnd explicit representations for a broad range of process models, i.e., we wantto be able to generate a concrete petri net rather than a set of dependencyrelations between events. in [8] cook and wolf provide a measure to quantifydiscrepancies between a process model and the actual behavior as registeredusing event-based data. the idea of applying process mining in the context ofworkﬂow management was ﬁrst introduced in [4]. this work is based on workﬂowgraphs, which are inspired by workﬂow products such as ibm mqseries work-ﬂow (formerly known as flowmark) and inconcert. in this paper, two problemsare deﬁned. the ﬁrst problem is to ﬁnd a workﬂow graph generating events ap-pearing in a given workﬂow log. the second problem is to ﬁnd the deﬁnitions404 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
of edge conditions. a concrete algorithm is given for tackling the ﬁrst problem.
the approach is quite diﬀerent from other approaches: because the nature ofworkﬂow graphs there is no need to identify the nature (and or or) of joinsand splits. as shown in [13], workﬂow graphs use true and false tokens whichdo not allow for cyclic graphs. nevertheless, [4] partially deals with iteration byenumerating all occurrences of a given task and then folding the graph. however,the resulting conformal graph is not a complete model. in [15], a tool based onthese algorithms is presented. schimm [18,19] has developed a mining tool suit-able for discovering hierarchically structured workﬂow processes. this requiresall splits and joins to be balanced. herbst and karagiannis also address the is-sue of process mining in the context of workﬂow management [11,10,12] using aninductive approach. the work presented in [12] is limited to sequential models.the approach described in [11,10] also allows for concurrency. it uses stochastictask graphs as an intermediate representation and it generates a workﬂow modeldescribed in the adonis modeling language. in the induction step task nodesare merged and split in order to discover the underlying process. a notable dif-ference with other approaches is that the same task can appear multiple timesin the workﬂow model, i.e., the approach allows for duplicate tasks. the graphgeneration technique is similar to the approach of [4,15]. the nature of splitsand joins (i.e., and or or) is discovered in the transformation step, wherethe stochastic task graph is transformed into an adonis workﬂow model withblock-structured splits and joins. in contrast to the previous papers, our work[14,20] is characterized by the focus on workﬂow processes with concurrent be-havior (rather than adding ad-hoc mechanisms to capture parallelism). in [20]a heuristic approach using rather simple metrics is used to construct so-called“dependency/frequency tables” and “dependency/frequency graphs”. the pre-liminary results presented in [20] only provide heuristics and focus on issues suchas noise. in [1] the emit tool is presented which uses an extended version ofα-algorithm to incorporate timing information. for a detailed description of the
α-algorithm and a proof of its correctness we refer to [3].
more from a theoretical point of view, the rediscovery problem discussed in
this paper is related to the work discussed in [5,9,16]. in these papers the lim-its of inductive inference are explored. for example, in [9] it is shown that thecomputational problem of ﬁnding a minimum ﬁnite-state acceptor compatiblewith given data is np-hard. several of the more generic concepts discussed inthese papers could be translated to the domain of process mining. it is possi-ble to interpret the problem described in this paper as an inductive inferenceproblem speciﬁed in terms of rules, a hypothesis space, examples, and criteriafor successful inference. the comparison with literature in this domain raises in-teresting questions for process mining, e.g., how to deal with negative examples(i.e., suppose that besides log wthere is a log vof traces that are not possible,
e.g., added by a domain expert). however, despite the many relations with thework described in [5,9,16] there are also many diﬀerences, e.g., we are mining atthe net level rather than sequential or lower level representations (e.g., markovchains, ﬁnite state machines, or regular expressions). for a survey of existingresearch, we also refer to [2].workﬂow mining: current status and future directions 405
6 discussion and future work
the focus of this paper has been on process mining algorithms and heuristics
primarily based on binary ordering relations of the events in a process log. as anrepresentative example of this type of algorithms we introduced the α-algorithm
and we explained why it cannot correctly mine short loops, invisible tasks, du-
plicate tasks, implicit places, non-free choice and synchronization of or-join
places , which are all common constructs in workﬂows. it is important to note
that these limitations are not speciﬁc for the α-algorithm but apply to most of
the approaches described in literature.
additionally, we have showed how two problematic constructs (i.e., loops of
length one and length two) can be handled by adapting one or more processmining phases: pre-processing ,processing orpost-p rocessing .
our future research will be driven by the problems identiﬁed in this paper.
first, we want to extend the class of wf-nets the α-algorithm can correctly
mine. secondly, we want to extend our mining algorithm in such a way that itcan handle workﬂows beyond the scope of wf-nets (for instance workﬂows withduplicate or invisible tasks). finally, we try to combine formal results with morepractical approaches in which we try to develop mining heuristics so that we canhandle more workﬂow logs (i.e., logs with noise and logs that are incomplete).
references
1. w.m.p. van der aalst and b.f. van dongen. discovering workﬂow performance
models from timed logs. in y. han, s. tai, and d. wikarski, editors, international
conference on engineering and deployment of cooperative information systems(edcis 2002) , volume 2480 of lecture notes in computer science , pages 45–63.
springer-verlag, berlin, 2002.
2. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workﬂow mining: a survey of issues and approaches. dataand knowledge engineering, accepted for publication, 2003.
3. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workﬂow mining:
discovering process models from event logs. ieee transactions on knowledgeand data engineering (tkde), accepted for publication, 2003.
4. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ﬂow logs. in sixth international conference on extending database technology ,
pages 469–483, 1998.
5. d. angluin and c.h. smith. inductive inference: theory and methods. computing
surveys , 15(3):237–269, 1983.
6. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215–249, 1998.
7. j.e. cook and a.l. wolf. event-based detection of concurrency. in procee dings
of the sixth international symposium on the foundations of software engineering(fse-6) , pages 35–45, 1998.
8. j.e. cook and a.l. wolf. software process validation: quantitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147–176, 1999.406 a.k.a. de medeiros, w.m.p. van der aalst, and a.j.m.m. weijters
9. e.m. gold. complexity of automaton identiﬁcation from given data. information
and control , 37(3):302–320, 1978.
10. j. herbst. dealing with concurrency in workﬂow induction. in u. baake, r. zo-
bel, and m. al-akaidi, editors, european concurrent engineering conference . scs
europe, 2000.
11. j. herbst. ein induktiver ansatz zur akquisition und adaption von workﬂow-
modellen . phd thesis, universit¨ at ulm, november 2001.
12. j. herbst and d. karagiannis. integrating machine learning and workﬂow man-
agement to support acquisition and adaptation of workﬂow models. international
journal of intelligent systems in accounting, finance and management , 9:67–92,
2000.
13. b. kiepuszewski. expressiveness and suitability of languages for control flow
modelling in workﬂows (submitted) . phd thesis, queensland university of tech-
nology, brisbane, australia, 2002. available viahttp://www.tm.tue.nl/it/research/patterns.
14. l. maruster, a.j.m.m. weijters, w.m.p. van der aalst, and a. van den bosch.
process mining: discovering direct successors in process logs. in procee dings of
the 5th international conference on discovery science (discovery science 2002) ,
volume 2534 of lecture notes in artiﬁcial intelligence , pages 364–373. springer-
verlag, berlin, 2002.
15. m.k. maxeiner, k. k¨ uspert, and f. leymann. data mining von workﬂow-
protokollen zur teilautomatisierten konstruktion von prozeßmodellen. in pro-
ceedings of datenbanksysteme in b¨ uro, technik und wissenschaft , pages 75–84.
informatik aktuell springer, berlin, germany, 2001.
16. l. pitt. inductive inference, dfas, and computational complexity. in k.p. jan-
tke, editor, procee dings of international workshop on analogical and inductive
inference (aii) , volume 397 of lecture notes in computer science , pages 18–44.
springer-verlag, berlin, 1889.
17. w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models ,
volume 1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
18. g. schimm. process mining. http://www.processmining.de/.19. g. schimm. process miner – a tool for mining process schemes from event-
based data. in s. flesca and g. ianni, editors, procee dings of the 8th european
conference on artiﬁcial intelligence (jelia) , volume 2424 of lecture notes in
computer science , pages 525–528. springer-verlag, berlin, 2002.
20. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workﬂow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151–162, 2003.