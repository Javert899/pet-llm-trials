aligning event logs and declarative process models for
conformance checking
massimiliano de leoni?, fabrizio m. maggi, and wil m. p. van der aalst
eindhoven university of technology, eindhoven, the netherlands
fm.d.leoni,f.m.maggi,w.m.p.v.d.aalst g@tue.nl
abstract. process mining can be seen as the ‚Äúmissing link‚Äù between data min-
ing and business process management. although nowadays, in the context of
process mining, process discovery attracts the lion‚Äôs share of attention, confor-
mance checking is at least as important. conformance checking techniques ver-
ify whether the observed behavior recorded in an event log matches a modeled
behavior. this type of analysis is crucial, because often real process executions
deviate from the predeÔ¨Åned process models. although there exist solid confor-
mance checking techniques for procedural models, little work has been done
to adequately support conformance checking for declarative models . typically,
traces are classiÔ¨Åed as Ô¨Åtting or non-Ô¨Åtting without providing any detailed diag-
nostics. this paper aligns event logs and declarative models, i.e., events in the log
are related to activities in the model if possible. the alignment provides then so-
phisticated diagnostics that pinpoint where deviations occur and how severe they
are. the approach has been implemented in prom and has been evaluated using
both synthetic logs and real-life logs from dutch municipalities.
1 introduction
traditional workÔ¨Çow management systems (wfmss) are based on the idea that pro-
cesses are described by procedural languages where the completion of a task may en-
able the execution of other tasks. while such a high degree of support and guidance
is certainly an advantage when processes are repeatedly executed in the same way, in
dynamic settings (e.g., healthcare) a wfms is considered to be too restrictive. users
often need to react to exceptional situations and execute the process in the most appro-
priate manner. therefore, in these environments systems tend to provide more freedom
and do not restrict users in their actions. comparing such dynamic process executions
with procedural models may reveal many deviations that are, however, not harmful. in
fact, people may exploit the Ô¨Çexibility offered to better handle cases. in such situations
we advocate the use of declarative models . instead of providing a procedural model
that enumerates all process behaviors that are allowed, a declarative model simply lists
the constraints that specify the forbidden behavior, i.e., ‚Äúeverything is allowed unless
explicitly forbidden‚Äù.
in this paper, we focus on conformance checking for declarative models . confor-
mance checking techniques take an event log and a process model and compare the
?the research of dr. de leoni has received funding from the european community‚Äôs seventh
framework programme fp7/2007-2013 under grant agreement no 257593 (acsi).fig. 1: declare model consisting of six constraints and eight activities
observed behavior with the modeled behavior [3‚Äì5, 16]. along with process discov-
ery(learning process models from event logs) and process enhancement (e.g., extend-
ing process models using information extracted from the actual executions recorded in
event logs), conformance checking belongs to the area of process mining [3].
since often the actual execution deviates from the prescriptions of theoretical mod-
els, this type of analysis is critical in many domains, e.g., process auditing [17] or risk
analysis [11]. however, while there is a large stream of research about conformance
checking of procedural models, little work has been conducted for declarative models.
existing approaches exclusively focus on determining whether a given process instance
conforms with a given process model or not [7, 6, 9, 1]. in this paper, we want to provide
diagnostics at the event log level rather than a simple yes/no answer at the trace level.
moreover, our approach is able to pinpoint where deviations more frequently occur and
how severely a process instance does not comply the process model.
there are different quality dimensions for comparing process models and event
logs, e.g., Ô¨Åtness ,simplicity ,precision , and generalization [3, 15, 10]. in this paper, we
focus on Ô¨Åtness : a model with good Ô¨Åtness allows for most of the behavior seen in the
event log. a model has a perfect Ô¨Åtness if all traces in the log can be replayed by the
model from the beginning to the end. our approach is applied to declare , a declarative
language supported by a toolset that includes a designer, a workÔ¨Çow engine, a worklist
handler, and various analysis tools [20, 2].1due to space reasons we cannot provide a
detailed description of declare and only highlight some of the most relevant features of
the language through an example.
example 1 a travel agency has enacted a process to handle health insurance claims. a claim
can be classiÔ¨Åed as high or low, depending on the amount that the customer claims to receive
back. fig. 1 shows a simple declare model with some example constraints to describe this pro-
cess. the model includes eight activities (depicted as rectangles, e.g., contact hospital ) and six
constraints (shown as connectors between the activities). for low claims, two tasks low insur-
ance check andlow medical history need to be executed. the co-existence constraint indicates
that these activities always occur together (in any order). if a claim is classiÔ¨Åed as low, no ac-
tivities referring to high claims can be executed and vice versa. the not co-existence constraint
indicates that low insurance check andhigh insurance check can never coexist in the same pro-
cess instance. moreover, in case of high claims, the medical history check ( high medical history )
1declare web site - http://www.win.tue.nl/declare/can only be executed together with the insurance check ( high insurance check ), even though they
can be executed in any order. nevertheless, it is possible to execute high insurance check without
executing high medical history . all this is enforced by the responded existence constraint. for
every claim, it is also possible to contact the doctor/hospital for veriÔ¨Åcation. however, in case of
high claims, this cannot be done before the insurance check. this is deÔ¨Åned by the not succession
constraint, that means that contact hospital cannot be followed in the same process instance by
high insurance check . in this process, a questionnaire is also created and eventually sent to the
applicant (modeled by the response constraint); after having sent the questionnaire, the applicant
can possibly decide whether to Ô¨Åll it in or not ( precedence constraint).
the approach we propose is based on the principle of Ô¨Ånding an alignment of an
event log and a process model. the concept of alignment has successfully been used in
the context of procedural models (e.g., [4, 5, 12]); here, we adapt it for declarative mod-
els. similarly to what has been proposed for procedural models, in our approach, events
in the log are mapped onto executions of activities in the process model. a cost/weight
is assigned to every potential deviation. we use the a* algorithm [4, 8] to Ô¨Ånd, for each
trace in the event log, an optimal alignment, i.e., an alignment that minimizes the cost of
the deviations. the application of the a* algorithm is more challenging for declarative
models than for procedural models. this is due to the fact that, since in a declarative
model everything is allowed unless constrained otherwise, the set of admissible behav-
iors is generally far larger than the set of behaviors allowed by procedural models. this
implies that the search space where to Ô¨Ånd an optimal alignment of a log and a declar-
ative model is much larger. therefore, for this type of models, it is essential to avoid
exploring search-space nodes that certainly lead to non-optimal solutions.
in addition to simply returning an optimal alignment for each trace, we also provide
the process analyst with a summary that gives a helicopter view of the conformance of
the model with respect to the entire log. in particular, we aggregate the information as-
sociated to the optimal alignments and visualize the deviations upon the process model.
in fact, we generate a ‚Äúmap‚Äù thus highlighting on a declare model which constraints are
more often violated during the performance and which activities are mostly involved in
the deviations. the approach has been implemented in prom and has been evaluated on
a variety of synthetic and real-life logs.
the paper is structured as follows. section 2 introduces event logs and declare
models. section 3 describes the notion of alignment and how it can be used for con-
formance checking. section 4 describes the application of the a* algorithm to Ô¨Ånd an
optimal alignment. here, we also introduce an optimization of the algorithm to prune
large irrelevant parts of the search space (that do not lead to an optimal solution). sec-
tion 5 shows which diagnostics and feedback we can provide to the process analyst.
section 6 presents the plug-ins we have implemented and reports some performance
results. here we also validate our approach by applying it to real-life logs of dutch
municipalities. section 7 concludes the paper highlighting future work.
2 basic concepts
declare is a language that provides both an intuitive graphical representation and a for-
mal semantics for declarative process models. in particular, declare is grounded in lin-
ear temporal logic (ltl) with a Ô¨Ånite-trace semantics and every declare constraintis formally deÔ¨Åned through an ltl formula.2for instance, the response constraint
in fig. 1 can be formally represented using ltl as (create questionnaire !
send questionnaire ). this means that ‚Äúwhenever activity create questionnaire
is executed, eventually activity send questionnaire is executed‚Äù. in the following, we
refer to a declare modeld= (a;), whereais a set of activities and is a set of
declare constraints deÔ¨Åned over activities in a.
to identify potential deviations of a log from a reference declare model, we need to
map each activity in the log onto an activity in the model. each process instance in a log
follows a trace of events and different instances may follow the same trace. therefore,
an event log can be seen as a multi-set of traces, i.e., l2b(al)3, wherealis the set
of activities in the log. since declare is an ‚Äúopen‚Äù language, it allows for the execution
of any activity which is not in the model. therefore, the set of activities in the log may
include all activities in the model and more, i.e., aal.
for conformance checking, we do not need to distinguish the activities in the set
alnaas they do not appear in the model. this allows us to reduce the space of
the allowed behaviors. note that we cannot completely abstract from the activities in
alnabecause some constraints use ltl‚Äôs next operator (e.g., the chain response and
chain precedence constraints). therefore, we map all events referring to some activity
inalnatox. afterwards, the log l2b(al)is converted intol02b()with
=a[fxg. we use function 2al!that maps each activity in alonto.
8a2a:(a) =aand8a2(alna):(a) =x, i.e., every occurrence of an activity
in a log trace that is also deÔ¨Åned in the model is mapped onto the activity itself, whereas
other events are mapped onto x.
example 1 (cont.). the set of activities of the declare model in fig. 1 is
a=hlow insurance check ;low medical history ;high insurance check ;
high medical history ;contact hospital ;create questionnaire ;
send questionnaire ;receive questionnaire response i
let us assume to have a log that contains the following trace:
l=hregister;low insurance check ;create questionnaire ;
prepare notiÔ¨Åcation content ;create questionnaire ;
send notiÔ¨Åcation by e-mail ;send notiÔ¨Åcation by post ;archivei
this log trace is deÔ¨Åned over an activity set althat includes a. using the mapping function ,
lcan be transformed into 0
l.
0
l=hx;low insurance check ;create questionnaire ;x;
create questionnaire ;x;x;xi
note that register, send notiÔ¨Åcation by e-mail, send notiÔ¨Åcation by post, archive are mapped
ontox.
in the remainder, we only consider event logs after mapping unconstrained activities
ontox, i.e.,l 2b(). to check whether a log trace l2 l is compliant with
2for compactness, in the following we will use the ltl acronym to denote ltl on Ô¨Ånite traces.
3b(x)the set of all multi-sets over xandxis the set of all Ô¨Ånite sequences over x.0 start 1
23nflic;lmhg
flicg
flmhgnflmhg
flmhg
nflicgflicg-
(a) constraint automaton for the co-existence
constraint0 start 1nfrqr;sqg
fsqg
fsqg
(b) constraint automaton for
the precedence constraint
fig. 2: constraint automata for two declare constraints in fig. 1
adeclare constraint2, using the technique described in [19], we translate the
corresponding ltl formula into a Ô¨Ånal-state automaton that accepts all traces that do
not violate constraint .
deÔ¨Ånition 1 (constraint automaton). letd= (a;)be a declare model,2
and=a[fxg. the constraint automaton a= (;	; 0;;f)is the Ô¨Ånal-
state automaton which accepts precisely those traces 2satisfying, where:
‚Äì=a[fxgis the input alphabet;
‚Äì	is a Ô¨Ånite, non-empty set of states;
‚Äì 02	is an initial state;
‚Äì2	!	is the state-transition function;
‚Äìf	is the set of Ô¨Ånal states.
we create a constraint automaton afor every constraint 2. these automata
can be used to check the conformance of a log trace with respect to each constraint in
d.
example 1 (cont.). for the co-existence constraint and the precedence constraint in fig. 1,
we obtain the automata depicted in fig. 2a and 2b. in both cases, state 0is the initial state and
accepting states are indicated using a double outline. a transition is labeled with the set of the
activities triggering it (we use the initial letters to denote an activity, e.g., we use lic to indicate
low insurance check ). this indicates that we can follow the transition for any event included in
the set (e.g., we can execute event high insurance check from state 0of the precedence automaton
and remain in the same state).
the process behavior set pdof a declare modeld= (a;)is the set of
traces that are accepted by all automata awith2, i.e., all process executions that
comply the modeld.3 the conformance checking framework
to check the conformance of an event log lwith respect to a declare modeld, we
adopt an approach where we search for an alignment of the log and the model. such an
alignment shows how the event log can be replayed on the declare model.
an alignment relates moves in log and to moves in model as explained in the follow-
ing deÔ¨Ånition. here, we explicitly indicate no move with.=[fg , where
denotes the input alphabet of each constraint automaton in d.
deÔ¨Ånition 2 (alignment). a pair (s0;s00)2()nf(;)gis
‚Äìamove in log ifs02ands00=,
‚Äìamove in model ifs0=ands002,
‚Äìamove in both ifs02,s002ands0=s00.
a= ()nf(;)gis the set of the legal moves .
thealignment of two execution traces 0;002is a sequence 2asuch
that the projection on the Ô¨Årst element (ignoring ) yields0and the projection on the
second element yields 00.
in particular, if 0=l2l and002pd, we refer to the alignment as a
complete alignment oflandd. an alignment of the event log land the declare
modeldis a multi-seta2b(a)of alignments such that, for each log trace l,
there exists an alignment 2a oflandd. the deÔ¨Ånition of aas a multi-set is
motivated by the fact that an event log can contain the same log trace lmultiple times
and, hence, the same alignment can be given for all its occurrences.
example 1 (cont.). given the log trace l=hx;lic;cq;x;cq;x;x;xi, there are
many possible complete alignments of land the declare model in fig. 1. for instance, the
following are valid complete alignments:
1=l:xliccqxcqxxx
p:xcqxcqsqxxx2=l:xliccqxcqxxx
p:xliclmhxxxx
3=l:xliccqxcqxxx
p:xliclmhcqxcqsqxxx4=l:xliccqxcqxxx
p:xxxxx
conversely,0=l:xliccqxcqxxx
p:xliccqxcqxxxis not a complete alignments since lis
not in the process behavior set of the declare model. indeed, the co-existence constraint is
violated, because low insurance check occurs in the log trace and low medical history does
not. moreover, two occurrences of create questionnaire are not followed by send questionnaire ,
as prescribed by the response constraint.
in order to quantify the severity of a deviation, we introduce a cost function on the
legal moves 2a!r+
0. one can use a standard cost function with unit costs for
moves in log or in model. however, the costs may also depend on the speciÔ¨Åc charac-
teristics of the process, e.g., it may be more costly to skip an insurance check for high
claims than for low claims. therefore, a different cost function needs to be deÔ¨Ånedfor individual processes. the cost of an alignment is deÔ¨Åned as the sum of the costs
of the individual moves in the alignment, k() =p
(s0;s00)2(s0;s00).
given a log trace l2l, our goal is to Ô¨Ånd a complete alignment of land a valid
tracem2pdthat minimizes the cost with respect to all 0
m2pd. this complete
alignment is referred to as an optimal alignment .
deÔ¨Ånition 3 (optimal alignment). letl2lbe a log trace anddadeclare model.
let (l;d)be the set of the complete alignments of landd. a complete alignment
2 (l;d)is an optimal alignment ofl2l anddiff802 (l;d):k(0)
k(). the projection of on the second element (ignoring ) yieldsm2pd, i.e., a
valid trace ofdthat is the closest to l.
example 1 (cont.). in our example, we can suppose that deviations for activity send question-
naire are less severe than those referring to the other activities, since this activity is automatically
performed by a system. moreover, moves associated to xcan be weighted less than any other,
since they refer to activities that are not in the model. therefore, a reasonable cost function on
legal moves can be deÔ¨Åned as follows:
(a0;) =(;a0) =8
<
:1ifa0=x
2ifa0=send questionnaire
4otherwise
(a0;a00) =0 ifa0=a00
1 ifa06=a00^a06= ^a006=
using this cost function, alignments 1,2,3and4have the following costs: k(1) = 6 ,
k(2) = 12 ,k(3) = 6 andk(4) = 12 . therefore,1and3are better complete alignments.
according to the given cost function, 1and3are, in fact, optimal alignments.
when focusing on the Ô¨Åtness dimension of conformance, we are not only interested
in Ô¨Ånding the optimal alignment and, hence, diagnosing where a log trace does not
conform with a model. we also need to quantify the Ô¨Åtness level of traces and logs.
therefore, we introduce a Ô¨Åtness functionf 2 (2)![0;1].f(l;d) =
1iflcan be replayed by the model from the beginning to the end with no non-
conformance costs. conversely, f(l;d) = 0 denotes a very poor Ô¨Åtness. k()cannot
be used as Ô¨Åtness function directly, as we are interested in expressing the Ô¨Åtness level as
a number between 0 and 1. the normalization between 0 and 1 can be done in several
ways. in our approach, we divide the cost of the optimal alignment by the maximal
possible alignment cost. typically, the greatest possible cost of an alignment of a log
tracel=hal
1;:::;al
niand a model trace m=ham
1;:::;am
mi2pdis obtained for
thereference alignment in which there are only moves in model and in log:
ref
(l;m)=l:al
1:::al
n
p:am
1:::am
m:
therefore, the Ô¨Åtness level of a log trace can be deÔ¨Åned as follows:
deÔ¨Ånition 4 (fitness level). letl2be a log trace and let dbe a declare
model. leto2abe an optimal alignment of landdandm2pdthe modeltrace in the optimal alignment. the Ô¨Åtness level of landdis deÔ¨Åned as follows:
f(l;d) = 1 k(o)
k(ref
(l;m))
therefore, the Ô¨Åtness of landdis valued 1 if in the alignment there are only
moves in both, i.e., there are no deviations. f(l;d) = 0 if the optimal alignment
only contains moves in log and in model. note that this Ô¨Åtness function always returns
a value between 0 and 1: if o2ais an optimal alignment, any other alignment,
includingref
(l;m), must have the same or a higher cost.
in the next section, we introduce an approach to create an optimal alignment with
respect to a custom cost function . the approach is based on the a* algorithm that
is intended to Ô¨Ånd the path with the lowest overall cost between two nodes in a direct
graph with costs associated to nodes.
4 the a* algorithm for conformance checking
let us suppose to have a graph vwith costs associated to arcs. the a* algorithm,
initially proposed in [8], is a pathÔ¨Ånding search in v. it starts at a given source node
v02vand explores adjacent nodes until one node of a given target setvtrgvof
destination nodes is reached, with the intent of Ô¨Ånding the path with the overall lowest
cost. every node v2vis associated to a cost, which is determined by an evaluation
functionf(v) =g(v) +h(v), where
‚Äìg:v!r+
0is a function that returns the smallest path cost from v0tov;
‚Äìh:v!r+
0is an heuristic function that estimates the smallest path cost from vto
any target node v02vtrg.
functionhis said to be admissible if it never underestimates the smallest path cost
to reach any target node: for each node v2vand for each target node v02vtrg
reachable from v,h(v)g(v0). technical results in [8] shows that if his admissible,
a* Ô¨Ånds a path that is guaranteed to have the overall lowest cost.
the a* algorithm keeps a priority queue of nodes to be visited: a higher priority is
given to nodes with lower costs so as to traverse those with the lowest costs Ô¨Årst. the
algorithm works iteratively: at each step, the node vwith lowest cost is taken from the
priority queue. if vbelongs to the target set, the algorithm ends returning v. otherwise,
vis expanded: every successor v0ofvis added to the priority queue with cost f(v0).
4.1 usage of a* to find an optimal alignment
we use a* to Ô¨Ånd any of the optimal alignments of a log trace l2and a declare
modeld. in order to be able to apply a*, an opportune search space needs to be deÔ¨Åned.
every nodeof the search space vis associated to a different alignment that is a preÔ¨Åx
of some complete alignment of landd. since a different alignment is also associated
to every node and vice versa, later on we use the alignment to refer to the associatednode. the source node is the empty alignment 0=hiand the set of target nodes
includes every complete alignment of landd. since the successors of an alignment
are obtained by adding a move to it, the search space is, in fact, a tree.
let us denote the length of a trace withkk. given a node/alignment 2v,
the search-space successors of include all alignments 02vobtained from by
concatenating exactly one move. let us consider a custom cost function and denote
withminthe smallest value returned by greater than 0. given an alignment 2v
of0
land0
m, the cost of a path from the initial node to 2vis deÔ¨Åned as:
g() =mink0
lk+k():
it is easy to check that, given two complete alignments 0
cand00
c,k(0
c)<k(0
c),
g(0
c)< g(00
c)andk(0
c) =k(0
c),g(0
c) =g(00
c). therefore, an optimal
solution returned by the a* algorithm coincides with an optimal alignment. we have
added the term mink0
lk(which does not affect the optimality) to deÔ¨Åne a more
efÔ¨Åcient and admissible heuristics. given an alignment 2vof0
land0
m, we utilize
the following heuristic:
h() =min(klk k0
lk)
for an alignment , the number of moves to add in order to reach a complete alignment
cannot exceed the number of moves of lthat have not been included yet in the align-
ment, i.e.,klk k0
lk. since the additional cost to traverse a single node is at least
min, the cost to reach a target node is at least h(), corresponding to the case in which
the part of the log trace that still needs to be included in the alignment (i.e., ln0
l)
Ô¨Åts in full.
4.2 search space reduction
declarative models allow for more Ô¨Çexibility and, therefore, for more behavior than
procedural models. hence, the search space in the a* algorithm may be extremely large.
nevertheless, many search-space nodes (i.e., partial alignments) are, in fact, equivalent,
i.e., some partial alignments can be extended with the same moves:
deÔ¨Ånition 5 (alignment equivalence). letd= (a;)be a declare model and let
a= (;	; 0;;f)be the constraint automaton for 2. letl2be
a log trace. let 0and00be alignments of 0
land0
m, and of00
land00
m, where
0
land00
lare preÔ¨Åxes of land0
mand00
mare preÔ¨Åxes of model traces in pd.
let 0
=
( 0;0
m)and 00
=
( 0;00
m)be the states reached by awhen
replaying0
mand00
mon it.4alignments0and00are equivalent with respect to d, if
0
l=00
land, for all2, 0
= 00
. we denote this with 0d00.
4given a state-transition function and a symbol sequence =hs1;:::;s ni,( 0;)de-
notes the recursive application of the state-transition function over a symbol sequence start-
ing from state  0, i.e.,( 0;) = nwhere, for all 0<in, iis recursively deÔ¨Åned as
 i=( i 1;si).if two partial alignments 0and00are equivalent, the cost of the least expensive path
to reach a target node (i.e., a complete alignment) from 0is the same as from 00.
indeed, since they are equivalent, they both can be extended with the same sequences
of alignment moves. in order to get an optimal alignment, it is only necessary to visit
one of them, speciÔ¨Åcally the one with lowest gcost. therefore, it is possible to prune
the sub-trees with roots in the nodes/alignments that do not have to be visited.
theorem 1. letdbe adeclare model. letlbe a log trace to be aligned. let  (l;d)
be the set of complete alignments of landd. let0and00be two alignments such
that0d00andg(0)>g(00). for all complete alignments 0b2 (l;d), there
exists a complete alignment 00e2 (l;d)such thatg(0b)g(00e).
proof. let0
lbe the portion of laligned by0and00. let0=0b2 (l;d)
be one of the complete alignments with the lowest cost among the ones that can be
obtained by extending 0. since0d00, alignment 00can also be extended with
b, i.e.,00=00b2 (l;d).g(0) =kminklk+k(0b)andg(00) =
kminklk+k(00b). suppose that g(00)> g(0)withg(0)> g(00). if this
holds,k(00b) =k(00) +k(b)>k(0b) =k(00) +k(b). therefore,
k(00)>k(0)and, hence,g(00)> g(0), which is a contradiction. therefore, there
is a complete alignment 00obtained by extending with cost lower or equal to g(0),
i.e., the lower bound of the costs of all complete alignments obtained by extending 0.
we maintain a set  vof nodesthat have already been visited and their costs g().
when a new node-alignment 0is encountered, we check whether it is a candidate
node to be visited, i.e., whether its successors need to be added to the priority queue of
nodes to be visited. node 0is a candidate if for every node 002 vequivalent to 0
g(00)>g(0). it is also a candidate if there is no equivalent node in  v.
5 provided diagnostics
this section details some advanced diagnostics that we build on top of the optimal
alignments that have been returned for all traces in the event log. first, we indicate why
an optimal alignment includes a certain move in log/model: in fact, such a move was
introduced to solve a violation of a constraint that occurred in the log trace. second, we
provide a helicopter view that allows one to determine which activities are mostly in-
volved in deviations and which constraints are more often violated. on this concern, we
provide metrics to measure the ‚Äúdegree of conformance‚Äù of single activities and con-
straints in a declare model against the entire event log, in addition to simply evaluating
the Ô¨Åtness level (deÔ¨Ånition 4) of each log trace against the entire declare model.
5.1 why do i need this move?
let=h(al
1;ap
1);:::; (al
n;ap
n)ibe an optimal alignment of landd. letabe
the constraint automaton for 2. for each move (al
i;ap
i)2in log or in model
of an alignment (i.e., s.t. either al
i=orap
i=), we indicate which constraint(s)
in the declare model the move aims to solve. for this purpose, we build an executiontraceiobtained fromhap
1;:::;ap
i 1;al
i;ap
i+1;:::;ap
niby removing all. then, for
each constraint 2, we check whether iis accepted bya. if it is not accepted,
(al
i;ap
i)has been introduced to solve a violation in . note that, a move in log or in
model always solves at least one violation.
example 1 (cont.). let us again consider the optimal alignment 1(see page 6). it contains
two moves in log or in model: (lic;)and (;sq ). for (lic;), we build the execution
trace1=hx;lic;cq;x;cq;x;x;xi. this sequence is accepted by all the constraint
automata in the declare model, apart from the constraint automaton for the co-existence con-
straint (see fig. 2a). similarly, for (;sq ),5=hx;cq;x;cq;x;x;xiis accepted by
all the constraint automata, apart from the constraint automaton for the precedence constraint
(shown in fig. 2b). therefore, (lic;)has been introduced to solve a violation in the co-
existence constraint and (;sq )has been introduced to solve a violation in the precedence
constraint.
5.2 degree of conformance
we denote with mc()the metric representing the number of moves in model and
in log of a complete alignment that contribute to solve a violation of . fora2,
we denote with mm(a)the number of amoves in model, with ml(a)the num-
ber ofamoves in log and with mb(a)the number of amoves in both model and
log.mc(),mm(a),ml(a)andmb(a)can be used to quantify the degree of
conformance.
for reliability, we average over all optimal alignments. let  =f1;:::;ngbe
the set of the optimal alignments of a log l=f1;:::;ngandd. the degree of
conformance ofa2with respect to  is deÔ¨Åned as follows:
dconf (a) = 1 1
nx
2 mm(a) +ml(a)
mm(a) +ml(a) +mb(a):
dconf (a) = 1 if the moves that involve aare only moves in both (i.e., there are no
deviations related to a).dconf (a)decreases with the fraction of moves in model or
in log. dconf (a) = 0 if all moves that involve aare only moves in log or moves in
model.
given a constraint 2, the degree of conformance with respect to  is deÔ¨Åned
as follows:
dconf () = 1 1
nx
2 mc()
kk:
dconf () = 1 ifis never violated. dconf ()decreases towards 0 as the fraction
of moves in model and in log needed to solve violations of increases.
6 implementation and experiments
to check the conformance of declare models, we have implemented two plug-ins of
prom , a generic open-source framework for implementing process mining functionalityfig. 3: results of the experiments conducted on synthetic logs with different combina-
tions of sizes and degrees of non-conformance
[18]. the Ô¨Årst plug-in is the declare replayer that takes as input a declare model and an
event log and, using the algorithm described in section 4, Ô¨Ånds an optimal alignment for
each trace in the event log. starting from the results of the declare replayer , a second
plug-in, the declare diagnoser generates a map based on the diagnostics described in
section 5.
section 6.1 reports some experiments to analyze the performance of our approach.
then, section 6.2 presents our plug-ins and illustrates how diagnostics are graphically
visualized in a map. most of the experiments in section 6.1 use synthetic logs. never-
theless, we have also validated our approach on a real case study in the context of the
coselog project5involving 10 dutch municipalities.
6.1 performance experiments
to carry out our experiments, we have generated a set of synthetic logs by modeling
the process described in example 1 in cpn tools (http://cpntools.org) and by simu-
lating the model. we use logs with different degrees of non-conformance. a degree
of non-conformance of 90% means that each constraint in the log is violated with a
probability of 90%. note that multiple constraints can be violated at the same time in
a log trace. in our experiments, the logs have varying degrees of non-conformance:
0%;15%;30%;45%;60%;75% and90%. for all degrees of non-conformance, we use
randomly generated logs including 250;500and750instances to verify the scalability
of the approach when varying the log size. the experiments have been conducted on a
dual-core cpu at 2.40 ghz.
fig. 3 shows the execution times for the declare replayer plug-in (implementing
the a* algorithm) for the different logs. for each combination of log size ( 250;500or
750) and degree of non-conformance (x-axis), the Ô¨Ågure plots the average value of the
execution time over 5 runs. the three lines show the trends for the three different log
sizes. fig. 3 illustrates the scalability of the algorithm.
5http://www.win.tue.nl/coselogemployed technique visited nodes tree size execution time
optimized a* 21 181 30 seconds
without pruning 30 252 40 seconds
without heuristics 123419 1204699 ca. 7 hours
table 1: comparison of the execution time of the declare replayer when all optimiza-
tions are enabled with respect to the cases when they are selectively turned off. the
results refer to a log with 250 instances and a degree of non-conformance of 15%
table 1 shows the effect of pruning the state space and of the heuristics. if we do not
prune the search-space employing the technique described in section 4.2, the declare
replayer has to visit 41% of extra nodes and, consequently, the execution time increases
by 33%. table 1 also shows a dramatic reduction in time and nodes achieved by the
heuristics described in section 4.1. without using the heuristics, the needed amount of
memory increases from 300 mbs to 3.5 gbs.
we have also performed various experiments using real-life event logs from the
coselog project. for the validation reported here, we have used two logs of processes
enacted by two different dutch municipalities. process instances in these event logs re-
fer to permissions for building or renovating private houses. we have Ô¨Årst discovered a
declare model using an event log of one municipality using the declare miner plug-in
inprom [14, 13]. then, using the declare replayer , we have checked the conformance
of the mined model with respect to an event log of the second municipality, where ev-
ery deviation is assigned the same cost/weight. analysis showed commonalities and
interesting differences. from a performance viewpoint the results were also encourag-
ing: 3271 traces with 14338 events could be replayed in roughly 8 minutes, i.e., 137
milliseconds per trace. section 6.2 provides more details about this experiment.
6.2 user interface and diagnostics
fig. 4 illustrates the output produced by the declare replayer . the screenshot shows
an analysis used in the context of a case study involving two municipalities. an event
log of one municipality is compared with a declare model learned from an event log of
another municipality.
each sequence of triangles in fig. 4 refers to an alignment of a trace with respect to
the model. each triangle is a different alignment move; the color of the move depends
on its type (see the legend on the right-hand side), i.e., move in log (yellow), move in
model (purple) or move in both (green). each sequence is also associated with a number
that identiÔ¨Åes the Ô¨Åtness level of the speciÔ¨Åc trace. a button detail is also associated to
each trace; it allows us to show the alignment details at the bottom (e.g., for trace 1649
in the screenshot). each rectangle represents a different move and is annotated with the
activity involved in the move. also here, the color of the move depends on its type,
i.e., move in log (yellow), move in model (purple) or move in both (green). in case of
moves in log or in model, when moving with the mouse over the rectangle, the declare
replayer shows which constraint violation it aims to solve, in line with the diagnostics
described in section 5.1. in the Ô¨Ågure, for trace 1649, the 8th alignment move concerns
a move in log for verzenden beschikking . this move has been introduced to solve afig. 4: a screenshot showing the output of the declare replayer plug-in. for clarifying,
we provide the english translation of the dutch activity names. administratie, toetsing,
beslissing, verzenden beschikking andrapportage can be translated with administra-
tion, veriÔ¨Åcation, judgement, sending outcomes andreporting , respectively
fig. 5: a screenshot showing the output of the declare diagnoser plug-inviolation in a precedence constraint modeling that if activity verzenden beschikking
occurs in the log, beslissing must precede, being beslissing not present beforehand.
the declare replayer also provides the average Ô¨Åtness with respect to all log traces
(0:8553808 ). this value indicates that the declare model mined from the Ô¨Årst event log
is not fully conforming with the second log, i.e., the two municipalities execute the two
processes in a slightly different manner.
the results obtained through the declare replayer can be ‚Äúprojected‚Äù on the de-
clare model by the declare diagnoser plug-in. the declare diagnoser plug-in anno-
tates activities and constraints of the declare model with the degree of conformance. in
this way, the process analyst can easily understand where the deviations occur most fre-
quently. fig. 5 depicts a screenshot of the output of this second plug-in when taking as
input the alignments shown in fig. 4. activities and constraints are annotated with num-
bers showing the degree of conformance. to make the visualization more effective also
colors are used. green and red nodes and arcs indicate a degree 1 or 0 of conformance,
respectively. intermediate shades between green and red reÔ¨Çect values in-between these
two extremes.
the coloring of activities and constraints in fig. 5 shows that the level of confor-
mance is reasonable (most parts are close to green). as shown, most of the detected
deviations are related to activities toetsing andadministratie , which have the lowest
degree of conformance ( dconf (toetsing ) = 0:608anddconf (administratie ) =
0:721). the other activities have degree of conformance close to 1. by selecting an
activity, a better insight is provided: in the Ô¨Ågure, the selected activity beslissing is in-
volved 12 times in a move in log, 52 times in a move in model and 1372 times in a move
in both. the degree of conformance of a constraint indicates whether the constraint is
somewhere violated. for instance, dconf (precedence (beslissing;administratie ))
= 0:97highlights that moves in log and/or in model have been included in some align-
ments to solve a violation in this constraint. dconf (notsuccession (administratie;
beslissing )) = 1 indicates that this constraint is never violated.
7 conclusion
this paper presents a novel conformance checking approach tailored towards declara-
tive models. the many conformance checking techniques deÔ¨Åned for procedural mod-
els (e.g., petri nets) are not directly applicable to declarative models. moreover, these
techniques tend to provide poor diagnostics, e.g., just reporting the fraction of Ô¨Åtting
cases. we adapted alignment-based approaches to be able to deal with the large search
spaces induced by the inherent Ô¨Çexibility of declarative models. based on such align-
ments we provide novel diagnostics, at the trace level, showing why events need to be
inserted/removed in a trace, and at the model level, coloring constraints and activities
in the model based on their degree of conformance. as future work, we plan to extend
our approach in order to incorporate in our analysis data and resource perspectives.
references
1. van der aalst, w.m.p., de beer, h.t., van dongen, b.f.: process mining and veriÔ¨Åcation of
properties: an approach based on temporal logic. in: proceedings of the otm 2005 con-federated international conferences coopis, doa, and odbase. lecture notes in com-
puter science, vol. 3760, pp. 130‚Äì147. springer (2005)
2. van der aalst, w.m.p., pesic, m., schonenberg, h.: declarative workÔ¨Çows: balancing be-
tween flexibility and support. computer science - r&d pp. 99‚Äì113 (2009)
3. van der aalst, w.m.p.: process mining - discovery, conformance and enhancement of busi-
ness processes. springer (2011)
4. van der aalst, w.m.p., adriansyah, a., van dongen, b.f.: replaying history on process mod-
els for conformance checking and performance analysis. wiley interdisciplinary reviews:
data mining and knowledge discovery 2(2), 182‚Äì192 (2012)
5. adriansyah, a., van dongen, b., van der aalst, w.: conformance checking using cost-
based fitness analysis. in: ieee international enterprise distributed object computing
conference. pp. 55‚Äì64. ieee computer society (2011)
6. awad, a., decker, g., weske, m.: efÔ¨Åcient compliance checking using bpmn-q and tem-
poral logic. in: 6th international conference on business process management (bpm 2008).
lecture notes in computer science, vol. 5240, pp. 326‚Äì341. springer (2008)
7. bauer, a., leucker, m., schallhart, c.: runtime veriÔ¨Åcation for ltl and tltl. acm trans-
actions on software engineering and methodology (2011)
8. dechter, r., pearl, j.: generalized best-Ô¨Årst search strategies and the optimality of a*. jour-
nal of the acm (jacm) 32, 505‚Äì536 (july 1985)
9. governatori, g., milosevic, z., sadiq, s.w.: compliance checking between business pro-
cesses and business contracts. in: proceedings of the 10th ieee international enterprise
distributed object computing conference. pp. 221‚Äì232. ieee computer society (2006)
10. greco, g., guzzo, a., pontieri, l., sacca, d.: discovering expressive process models by
clustering log traces. ieee trans. on knowl. and data eng. 18(8), 1010‚Äì1027 (2006)
11. hulstijn, j., gordijn, j.: risk analysis for inter-organizational controls. in: proceedings of
the 12th international conference on enterprise information systems. scitepress (2010)
12. de leoni, m., van der aalst, w.m.p., van dongen, b.f.: data- and resource-aware con-
formance checking of business processes. in: 15th international conference on business
information systems. lecture notes in business information processing, vol. 117, pp. 48‚Äì
59. springer verlag (2012)
13. maggi, f.m., bose, r.p.j.c., van der aalst, w.m.p.: efÔ¨Åcient discovery of understandable
declarative process models from event logs. in: proceedings of the 24th international con-
ference on advanced information systems engineering (2012)
14. maggi, f.m., mooij, a.j., van der aalst, w.m.p.: user-guided discovery of declarative pro-
cess models. in: proceedings of the ieee symposium on computational intelligence and
data mining, cidm 2011. pp. 192‚Äì199. ieee (2011)
15. munoz-gama, j., carmona, j.: enhancing precision in process conformance: stability, con-
Ô¨Ådence and severity. in: ieee symposium on computational intelligence and data mining
(cidm 2011). pp. 184 ‚Äì191 (april 2011)
16. rozinat, a., van der aalst, w.m.p.: conformance checking of processes based on monitor-
ing real behavior. information systems 33(1), 64‚Äì95 (2008)
17. vasarhelyi, m., alles, m., kogan, a.: principles of analytic monitoring for continuous as-
surance. journal of emerging technologies in accounting 1(1), 1‚Äì21 (2004)
18. verbeek, h.m.w., buijs, j.c.a.m., van dongen, b.f., van der aalst, w.m.p.: xes, xesame,
and prom 6. in: proceedings of information systems evolution (caise forum 2010). lec-
ture notes in business information processing, vol. 72, pp. 60‚Äì75 (2011)
19. westergaard, m.: better algorithms for analyzing and enacting declarative workÔ¨Çow lan-
guages using ltl. in: proceedings of the 9th business process management conference
(bpm‚Äô11). lecture notes in computer science, vol. 6896, pp. 83‚Äì98. springer berlin (2011)
20. westergaard, m., maggi, f.m.: declare: a tool suite for declarative workÔ¨Çow modeling and
enactment. ceur workshop proceedings, vol. 820. ceur-ws.org (2011)