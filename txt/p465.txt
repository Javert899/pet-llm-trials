supporting flexible processes through
recommendations based on history
helen schonenberg, barbara weber, boudewijn van dongen
and wil van der aalst
eindhoven university of technology, eindhoven, the netherlands
fm.h.schonenberg, b.f.v.dongen, w.m.p.v.d.aalst@tue.nl g@tue.nl
department of computer science, university of innsbruck, austria
barbara.weber@uibk.ac.at
abstract. in today's fast changing business environment exible pro-
cess aware information systems (paiss) are required to allow companies
to rapidly adjust their business processes to changes in the environment.
however, increasing exibility in large paiss usually leads to less guid-
ance for its users and consequently requires more experienced users. in
order to allow for exible systems with a high degree of support, intelli-
gent user assistance is required. in this paper we propose a recommenda-
tion service, which, when used in combination with exible paiss, can
support end users during process execution by giving recommendations
on possible next steps. recommendations are generated based on similar
past process executions by considering the specic optimization goals. in
this paper we also evaluate the proposed recommendation service, which
is implemented in prom, by means of experiments.
1 introduction
in todays fast changing business environment, exible process aware informa-
tion systems (paiss) are required to allow companies to rapidly adjust their
business processes to changes in the environment [6, 7]. paiss oer promising
perspectives and there are several paradigms, e.g., adaptive process manage-
ment [13], case handling systems [17] and declarative processes [10, 11] (for an
overview see [3,19,21]). in general, in exible pais it occurs frequently that users
working on a case have the option to decide between several activities that are
enabled for that case. however, for all exibility approaches, the user support
provided by the pais decreases with increasing exibility (cf. fig. 1), requiring
users to have in-depth knowledge about the processes they are working on. tra-
ditionally, this problem is solved by educating users (e.g., by making them more
aware of the context in which a case is executed), or by restricting the pais
by introducing more and more constraints on the order of activities and thus
sacricing exibility. both options, however, are not satisfactory and limit the
practical application of exible paiss. in this paper, we present an approach
for intelligent user assistance which allows paiss to overcome this problem and
to provide a better balance between exibility and support. we use event logsof paiss to gain insights into the process being supported without involving
a process analyst and we propose a tooling framework to provide continuously
improving support for users of exible paiss. at the basis of our approach lie
so-called recommendations. a recommendation provides a user with information
about how he should proceed with a partially completed case (i.e., a case that
was started but not nished yet), to achieve a certain goal (e.g., minimizing cycle
time, or maximizing prot). in this paper we discuss several methods for calcu-
lating log-based recommendations. in addition, we describe the implementation
of our approach as recommendation service and its evaluation. the remainder of
this paper is structured as follows. in section 2, we present the requirements and
a detailed overview of the recommendation service. then, in section 3 we dene
a log-based recommendation service. in section 4, we describe the experiment we
conducted to evaluate whether recommendations indeed help to achieve a partic-
ular goal. finally, we discuss related work in section 5 and provide conclusions
in section 6.
2 overview
fig. 2 illustrates the envisioned support of users of exible paiss through a
recommendation service. in general, each business process to be supported is
described as process model in the respective pais. we consider both imperative
and declarative process models. in fact, our approach is most useful when the
process model provides the user a lot freedom to manoeuvre, i.e., multiple activ-
ities are enabled during execution of a case. at run-time, cases are created and
executed considering the constraints imposed by the process model. in addition,
the pais records information about executed activities in event logs. typically,
event logs contain information about start and completion of activities, their
ordering, resources which executed them and the case they belong to [1].
as illustrated in fig. 2, the recommendation service is initiated by a request
from the user for recommendations on possible next activities to execute. in this
request, the user sends the recommendation service information about the par-
tially executed case, i.e., (1) the currently enabled activities, and (2) the history
of executed activities, which we call the partial trace. information about the
partial trace is required because the decision which activities to perform next
for a particular case usually depends on the activities already performed for
this case. in addition, only enabled activities are considered to ensure that no
recommendations are made that violate the constraints imposed by the process
model. the recommendation service then provides the pais a recommendation
result, i.e., an ordering of recommendations where each recommendation refers
to one activity and some quality attributes (e.g., expected outcome) explaining
the recommendation. recommendations are ordered such that the rst recom-
mendation in the list is most likely to help the user achieving his goal, i.e.,
optimizing a certain target, such as prot, cost, or cycle time.ad-hoc 
workflow groupware production 
workflow case 
handling low high 
flexi
bility supportfig. 1. pais trade-os [4].
recommendation 
service process engine process 
aware 
information 
system recommendation 
request
partial trace 
enabled activities 
recommendation result
ordering enabled activities end user
e.g. declare optimization 
goal
event 
log logs uses fig. 2. an overview of the recommendation service.
3 log-based recommendation service
in this section, we present a concrete denition of a log-based recommendation
service for providing users with recommendations on next possible activities to
execute. recommendations for an enabled activity provide predictive informa-
tion about the user goal, based on observations from the past, i.e., fully com-
pleted traces accompanied by their target value (e.g., cost, cycle time, or prot),
that have been stored in an event log. the log-based recommendation service
requires the presence of an event log that contains such information about cases
that have been executed for a certain process.
3.1 preliminaries
letabe a set of activities. adenotes a set of nite sequences over a. a
trace2ais a nite sequence of activities, given by an injective function
:f1;:::;ng!a, wherejj=nis the length of the sequence. sequences are
denoted as =ha1;a2;:::;ani, where81in(i) =ai.
on traces, we dene the standard set of operators.
denition 1 (trace operators). let:f1;:::;ng!aand0:f1;:::;mg!
bbe traces with =ha1;a2;:::;aniand0=hb1;b2;:::;bmi.
prex 0()nm^8 1inai=bi
concatenation a0=ha1;a2;:::;an;b1;b2;:::;bmi
membership a2() 9 1inai=a
parikh vector par()(a) = # 0inai=a.
the parikh vector par()(a) denotes the number of occurrences of ain a
trace, e.g.,par(ha;b;c;a;b;c;di)(a) = 2.
for multi-sets (bags), we introduce standard notation to denote the universe
of multi-sets over a given set. let sbe a set, then the universe of multi-sets over
sis denoted byb(s) =s!n, i.e.,x2b(s) is a multi-set, where for all s2s
holds that x(s) denotes the number of occurrences of sinx(s). we will use
ja;b2;c3kto denote the multi-set of one a, twob's and three c's as a shorthandfor the multi-set x2b(a) wherea=fa;b;cg,x(a) = 1;x(b) =c;x(c) = 3.
furthermore, multi-set operators such as for for union ], intersection c, and
submulti-setv,<are dened in a straightforward way and can handle a mixture
of sets and multi-sets.
denition 2 (event log). letabe a set of activities. an event log l2b(a)
is a multi-set of traces referring to the activities in a.
recall that each recommendation contains predictive information regarding
the user goal. for now, we assume that this goal can be captured by a function
on a trace, i.e., each trace in an event log has a target value (e.g., cost, cycle
time, or prot) attached to it.
denition 3 (target function). letabe a set of activities and l2b(a)
an event log over a. a target function :l!ris a function which attaches a
target value to each trace in the log.
3.2 recommendations
a recommendation is initiated by a recommendation request, which consists of
a partial trace and a set of enabled activities. formally, we dene a recommen-
dation request as follows.
denition 4 (recommendation request). letabe a set of activities and
2aa partial trace. furthermore, let eabe a set of enabled activities .
we callr= (;e)a recommendation request.
an activity accompanied by predictive information regarding the user goal is
called a recommendation. for each enabled activity, we determine the expected
target value when doing this activity ( do), and the expected target value for
alternatives of the enabled activity, i.e., other enabled activities ( dont). precise
denitions of doanddont are given in denitions 10 and 11. a recommendation
result is an ordering over recommendations.
denition 5 (recommendations). letabe a set of activities and l2
b(a)an event log over a. furthermore, let (;e)be a recommendation re-
quest withea,jej=nande2ean enabled activity.
{ 
e;do(e;;l );dont(e;;l )
2erris a recommendation. we use r
to denote the universe of recommendations.
{a recommendation result r=h 
e1;do(e1;;l );dont(e1;;l )
; 
e2;do(e2;;
l);dont(e2;;l )
;:::; 
en;do(en;;l );dont(en;;l )
iis a sequence of rec-
ommendations, such that r2rand81i<jnei6=ej.
the nature of the ordering over recommendations is kept abstract, however,
we provide a possible ordering for a recommendation result in example 1, section
3.6. in the next section we describe how recommendations are generated by the
recommendation service based on an existing event log l.3.3 trace abstraction
when generating log-based recommendations only those traces from the event
log should be considered, which are relevant for determining the predictive infor-
mation of an enabled activity. from those traces the ones with a high degree of
matching with the partial trace execution should be weighted higher than those
with small or no match.
to determine which log traces are relevant to provide recommendations for
a given partial trace and to weight them according to their degree of match-
ing we need suitable comparison mechanisms for traces. our recommendation
service provides three dierent trace abstractions based on which traces can be
compared, namely, prex, set and multi-set abstraction. the prex abstraction
basically allows for a direct comparison between the partial trace and a log trace.
in practice such a direct comparison is not always relevant, e.g., when the order-
ing, or frequency of activities is not important. therefore we provide with set
and multi-set two additional abstractions. they are independent of the domain
context, e.g., they do not assume the process to be a procurement process or an
invoice handling process [16].
denition 6 (trace abstraction). letabe a set of activities, l2b(a)be
an event log and 2lbe a trace. p=denotes the prex abstraction of ,
s=faja2gdenotes the set abstraction of andm=par()denotes the
multi-set abstraction of , i.e., for all a2holds thatm(a) =par()(a).
in section 3.4 we explain how we determine which log traces are relevant
for obtaining predictive information of an enabled activity. in section 3.5 we
describe how we calculate the weighting of log traces.
3.4 support
the relevance of log traces for a recommendation is determined on basis of sup-
port. typically, traces that are relevant are those that support the enabled ac-
tivity for which the recommendation is computed. what support exactly means
here, depends on the trace abstraction used.
for the prex abstraction, we say that a log trace supports enabled activity
e, if and only if e occurs in at the same index as in the partial trace , when this
activity is executed. for set abstraction, we consider a log trace to support the
enabled activity ewhenever activity ehas been observed at least once in the log
trace. to support an enabled activity ein multi-set abstraction of trace , the
the frequency of activity ein the partial trace must be less than the frequency
in the log trace , i.e., by executing eafter, the total number of e's does not
exceed the number of e's in.
denition 7 (activity support functions). letabe a set of activities,
;2aand enabled activity e2a. we use the predicate s(;;e )to statethat log trace supports the execution of eafter partial trace . the predicate is
dened for the three abstractions by:
sp(;;e )()p(jj+ 1) =e
ss(;;e )()e2s
sm(;;e )()m(e)<m(e)
the support predicate is used to lter the event log by removing all traces
that do not support an enabled activity.
denition 8 (support ltering). letabe a set of activities and l2b(a)
an event log over a. furthermore, let (;e)be a recommendation request with
2aandea. we dene the log ltered on support of enabled activity
e2eand partial trace asls
(;e)=j2ljs(;;e )k1
log traces from ls
(;e)support enabled activity eand are used for the recom-
mendation of e. next, we dene a weighing function ( !) to express the relative
importance of each of these log traces for the recommendation of an enabled
activitye.
3.5 trace weight
the support of an enabled activity determines the part of the log that serves as
a basis for a recommendation. however, from the traces supporting an enabled
activity, not every one is equally important, i.e., some log traces match the
partial trace better than others. hence, we dene weighing functions that assign
a weight to each log trace. the weight of a trace can be between 1 and 0, where a
value of 1 indicates that two traces fully match and 0 that they do not match at
all. the calculation of the degree of matching depends on the trace abstraction.
for prexes, the weight of a log trace is 1 if the partial trace is a prex of the
log trace, otherwise, the weight is 0. for the set abstraction, the weight of the
log trace is dened as the fraction of distinct partial trace activities that the
partial trace abstraction and log trace abstraction have in common. the weight
of a trace for the multi-set abstraction is similar to the set-weight, however, the
frequency of activities is also considered.
denition 9 (weight functions). letabe a set of activities and ;2a.
we dene!(;),i.e., the relative importance of a log trace when considering
the partial trace as follows:
!p(;) =1;ifpp
0;otherwise; !s(;) =js\sj
jsj; !m(;) =jmcmj
jmj
1note thatranges over a multi-set traces.3.6 expected outcome
denition 5 states that a recommendation for enabled activity econtains pre-
dictive information about the target value. we dene the expected outcome of
the target value ( dovalue), when eis executed in the next step, as a weighted
average over target values of log traces from ls
(;e), the log ltered on support
ofe. the target value of each trace from ls
(;e)is weighted ( !) on basis of the
degree of matching with the partial trace.
denition 10 ( docalculation). letabe a set of activities, a target func-
tion,;2a,l2b(a)ande2eaan enabled activity. the expected
target value when is completed by the user after performing activity enext is
dened as:
do(e;;l ) =p
2ls
(;e)!(;)()
p
2ls
(;e)!(;)
similarly, we dene the expected target value of not doing an enabled activity
e2. the dont function determines the weighted average over allalternatives of
e, i.e., all traces that do not support the execution of eafter, but do support
any of the alternatives e0after.
denition 11 ( dontcalculation). letabe a set of activities, a target func-
tion,;2a,l2b(a)ande;e02eaenabled activities. the expected
target value when is completed by the user after not performing activity enext
is dened as:
dont(e;;l ) =p
e02enfegp
2ls
(;e)nls
(;e 0)!(;)()
p
e02enfegp
2ls
(;e 0)nls
(;e)!(;)
next, we provide an example calculation for a recommendation, based on a
concrete partial trace, a set of enabled events and a log.
example 1 (recommendation). suppose=hd;fiis a partial trace and e=
fa;b;cgis the set of enabled activities. together, they form a recommenda-
tion request ( ;e). the log is given by l=jha;b;ci;hd;b;ci;:::k, with
(ha;b;ci) = 900,(hd;b;ci) = 500, etc. (cf. fig. 3). for convenience, we
also provide the values for support ( ss(;;e )) and trace weight ( !s(;)). for
each log trace, support is denoted by >. the user wants to minimize the cost
and uses set abstraction. the doand dont values for the recommendation are
calculated as follows.
2note that in both doanddontranges over a multi-set of traceslog weight and support
cost!s(;) ss(;;e )
e=ae=b e=c
abc 900 0> > >
dbc 500 0.5> >
fbc 500 0.5> >
dfa 1000 1>
dfb 1500 1>
dfc 2000 1 >
dfh 1260 1
cca 1680 0> >
fig. 3. example log, with weight and support values.
do(a;hd;fi;l) =0900 + 11000 + 01680
0 + 1 + 0= 1000
do(b;hd;fi;l) =0900 + 0:5500 + 0:5500 + 11500
0 + 0:5 + 0:5 + 1= 1000
do(c;hd;fi;l) =0900 + 0:5500 + 0:5500 + 12000 + 01680
0 + 0:5 + 0:5 + 1 + 0= 1250
dont(a;hd;fi;l) =(0:5500 + 0:5500 + 11500)
(0:5 + 0:5 + 1) + (0:5 + 0:5 + 1)+
(0:5500 + 0:5500 + 12000)
(0:5 + 0:5 + 1) + (0:5 + 0:5 + 1)= 1125
dont(b;hd;fi;l) =(11000 + 01680) + (12000 + 01680)
(1 + 0:5) + (1 + 0)= 1500
dont(c;hd;fi;l) =(11000) + (11500)
(1) + (1)= 1250
the implementation of our recommendation service orders the enabled ac-
tivities on the dierence between doand dont, i.e., the bigger the dierence,
the more attractive the activity is. the recommendations for the enabled ac-
tivities are (a, 1000, 1125),(b, 1000, 1500) and (c, 1250, 1250), with the dif-
ferences of -125, -500 and 0 respectively. thus, the recommendation result is
h(b;1000;1500);(a;1000;1125);(c;1250;1250)i. if the user goal would be to
maximize costs, the order will be reversed.
4 evaluation based on a controlled experiment
to evaluate the eectiveness of our recommendation service we conducted a
controlled experiment. section 4.1 describes the design underlying our experi-
ment and section 4.2 describes the preparatory steps we conducted. section 4.3
explains the experiment procedure including data analysis. the results of our
experiment are presented in section 4.4. factors threatening the validity of our
experiment are discussed in 4.5.prefix set multi set
pref60
sampleset60
samplemulti60
samplepref30
sampleset30
samplemulti30
samplepref5
sampleset5
samplemulti5
sample5
30
60
120pref120
sampleset120
samplemulti120
sampleabstraction abslog size krecommendations randoma.) experiment procedure
b.) experiment design
random
sample2.) random log creation (for object â€žset-up time modelâ€œ)
create traces
randomly
trace 1
random sample 
with 30 observationsmean 
cycle time
?tr
ace 1 .. 30log l
with size ktrace 1create traces
using 
recommendation service 
from log l with 
abstraction absmean 
cycle time
?abstraction
abs
sample abs / k
with 30 observations (*)tr
ace 1 .. 30
(*) levels used for log size k = {5,30,60,120} and abstractions abs = {prefix, set, multiset} resulting
in 12 samples = {pref5, pref30, â€¦. , multiset60, multiset120}1.) log creation based on recommendations (for object â€žset-up time modelâ€œ)fig. 4. the experiment design.
in our experiment we use the recommendation service to support a busi-
ness process, for which the set-up time plays an important role. five activities
(a;b;c;d;e ) have to be executed exactly once and can be executed in any
order. each activity has a cycle time of 10 time units, however, if cis directly
executed after b, then there is no closing-time for activity band no set-up time
for activity cleading to a cycle time reduction. in this case only 35 time units
are needed for the entire trace instead of 50. during execution, only activities
that have not been executed before, are enabled. for the experiment we assume
that the user goal is to minimize the cycle time for cases of this process and that
the recommendation service is used for support.
4.1 experiment design
this section describes the design underlying our experiment.
{ object: the object to be studied in our experiment are the traces created
for the set-up time model with the help of our recommendation service.
{ independent variables: in our experiment we consider the log abstraction
and the log size as independent variables. for variable log abstraction we
consider levels abs2 fprex;set;multisetg(cf section 3.3). variable log
sizekrepresents the number of instances in the event log, i.e., the amount
of learning material based on which recommendations are made. as levels
k2f5;30;60;120gare considered.
{ response variable: the response variable in our experiment is the cycle
time of a trace created by the recommendation service using a log of a given
size and a given abstraction.
{ experiment goal: the main goal of our experiment is to investigate
whether changes in the log signicantly eect the cycle time3of the cre-
3note that our approach can also be used for costs, quality, utilization, etc. however,
for simplicity we focus on the cycle time only.ated traces given an abstraction. another goal is to investigate whether the
traces created by our recommendation service yield signicantly better re-
sults than randomly created traces.
4.2 experiment preparation
this section describes the preparatory steps we conducted for the experiment.
{ implementing the recommendation service in prom. as a prepa-
ration for our experiment we implemented the recommendation service de-
scribed in section 3 as a plug-in for the (pro)cess (m)ining framework prom4.
prom is a pluggable framework that provides a wide variety of plug-ins to ex-
tract information about a process from event logs [20], e.g., a process model,
an organizational model or decision point information can be discovered. to
implement the recommendation service we had to make several extensions to
prom as the recommendation service, in contrast to other plug-ins, is not a
posteriori mining technique, but recommendations are provided in real-time
during process execution. the implementation of our recommendation ser-
vice is able to provide a process engine with recommendations on possible
next steps knowing the enabled activities and the partial trace. in addition,
the recommendation service provides means to add nished cases to the
event log to make them available for recommendations in future executions.
{ implementing a log creator and log simulator. in addition to the
recommendation service we implemented a log creator and log simulator.
while the log creator allows us to randomly create logs of size kfor a given
process model, the log simulator can be used to create traces using the rec-
ommendation service with a log of size kand an abstraction abs. the log
simulator takes the constraints imposed by the process model into consid-
eration and ensures that no constraint violations can occur. thus, the log
simulator can be seen as a simulation of a process engine. both the log cre-
ator and the log simulator have been implemented in java using fitnesse5
as user interface. this allows us to congure our experiments in a fast and
ecient way using a wiki and to fully automate their execution.
4.3 experiment execution and data analysis
the experiment procedure including the analysis of the collected data is de-
scribed in this section.
{ generation of data. as illustrated in fig. 4 our experiment design com-
prises two independent variables (i.e., log abstraction absand log size k). as
a rst step a log of size kis randomly created using the log creator, which
is then - in a second step - taken by the log simulator as input to create
4the prom framework can be downloaded from www.processmining.org .
5fitness acceptance testing framework fitnesse.orgtraces for each combination of abstractions and log sizes. traces are created
based on the recommendations provided by the recommendation service de-
scribed in section 3. the recommendations given by the recommendation
service are used throughout the entire execution of the case whereby the
best recommendation (i.e., the one with the highest dierence of doand
dont values, see. section 3.6) is taken. for each completed trace the log sim-
ulator records the cycle time. we repeated (n=30) the process of producing
a log and creating a trace using the log simulator with this log as input. in
total we obtained 12 samples covering all combinations of log size levels and
abstraction levels. for example, sample pref5 represents the sample with
abs=prex andk= 5.
in addition to the 12 samples which are created using recommendations, we
created one sample with 30 randomly created traces to compare this sample
with the ones created using the recommendation service.
{ eects of changes in log size and abstraction. to analyse the eects
of changes in the log size and the selection of a particular abstraction on the
cycle time of the created traces we calculated 95% condence intervals (ci
95%) on the mean cycle time for each sample. doing so, we can say with
95% probability, for a given log size and a given abstraction, that the cycle
time of a created trace will be within the calculated condence interval.
if we then compare the condence intervals of two samples of a given ab-
straction (e.g., pref5 and pref10 ) and these intervals do not overlap, we
can assume that the two samples have statistically dierent cycle times.
{ eectiveness of abstractions. to investigate whether the traces created
by our recommendation service yield signicantly better results than ran-
domly created traces we compared the condence interval of the random
sample with the condence intervals of each of the other 12 samples.
4.4 experiment results
the results of our experiment are summarized in figures 5-10. the results of
our experiments are summarized in figures 5-10. figures 5-7 depict the eect of
the log size on the mean cycle time for the 12 samples created using recommen-
dations. in figures 8-10 we compare the dierent abstractions and the random
strategy for a xed log size.
{ increasing the log size. figure 5 clearly shows the impact of increasing
the log size on the cycle time for prex abstraction. the mean cycle time
for sample pref5 is given by a ci 95% [38.68,44.32] and for samples pref30 ,
pref60 and pref120 the mean cycle time is 35 (with a standard deviation
of 0), which is also the optimum cycle time. when studying the results
of fig. 5 changing the log size from k= 5 tok= 30 yields a signicant
decrease of the cycle time. as the condence intervals of samples pref5 and
pref30 are not overlapping the dierence in their cycle times is statistically
signicantly dierent. further increases in the log size have no eect since
the optimum cycle time has already been found for sample pref30 . figure 61206030595% ci  for the mean cycle time50
48
46
44
42
40
38
36
log size
page 1fig. 5. prex.
1206030595% ci for the mean cycle time  50
48
46
44
42
40
38
36
log size
page 1 fig. 6. set.
1206030595% ci for the mean cycle time  50
48
46
44
42
40
38
36
log size
page 1 fig. 7. multi-set
multi-set
set
prefix
random95% ci  for the mean cycle time50
48
46
44
42
40
38
36
page 1
fig. 8. log size = 5.
multi-set
set
prefix
random95% ci for the mean cycle time50
48
46
44
42
40
38
36
page 1 fig. 9. log size = 30.
multi-set
set
prefix
random95% ci for the mean cycle time  50
48
46
44
42
40
38
36
page 1 fig. 10. log size = 60.
and 7 shows the results for the set and multi-set abstraction. as all intervals
are overlapping we can conclude that there is no signicant improvement in
the cycle time for the set and multi-set abstraction.
{ comparing the abstractions. figure 8-10 compares randomly created
traces with the samples for prex, set and multi-set. it can be observed
that the prex abstraction (i.e., samples pref5 ,pref30 and pref60 ) has
signicantly better cycle times compared to the random sample and thus
outperforms the random selection strategy. as illustrated in figure 8-10 the
dierence between random selection and prex abstraction becomes bigger
with increasing log size. the prex abstraction also outperforms the multi-
set abstraction for all considered log sizes. a comparison of the set and prexabstraction reveals that no signicant dierences exist between pref5 and
set5, while pref30 and set30 as well as pref60 and set60 signicantly
dier. finally, between the samples of the set and multi-set abstraction no
signicant dierences can be observed.
in summary, our results show that an increase of the log size does eect the
mean cycle time for the prex abstraction and that this abstraction signicantly
outperforms the random selection strategy. for the set and multi-set abstraction
changes in the log size do not signicantly eect the mean cycle time. as these
abstractions cannot exploit the order characteristics of the traces in the log they
do not outperform the random selection strategy.
4.5 risk analysis
in the following we discuss factors potentially threatening the validity of our
experiment. in general, it can be dierentiated between threats to the internal
validity ( are the claims we made about our measurements correct? ) and threats
to the external validity ( can we generalize the claims we made? ) [9]. for our
experiment most relevant threats aect the external validity:
{ selection of process model. in the selection of the business process for
our experiment constitutes a threat to the external validity of our experi-
ment. given the properties of the chosen process model, a particular order
of executing activities yields a benet. as the prex abstraction considers
the exact ordering of activities, while the set and multi-set abstractions dis-
regard this information, the chosen process model is favouring the prex
abstraction. for process models with dierent characteristics other abstrac-
tions might be more favourable. therefore it cannot be generalized that the
prex abstraction is always better than the set and multi-set abstraction.
a family of experiments using process models with dierent characteristics
is needed for generalization. initial investigations with a business process
which is not order-oriented show that set and multi-set abstraction can per-
form signicantly better than random selection.
{ method of log creation. for our experiment the method we used for log
creation might constitute another threat to the external validity. we assume
a log that only contains randomly created traces as the input for the log
simulator. using the simulator we then create, based on this log, an addi-
tional trace considering recommendations. in practice such an assumption
might not always be realistic as a real-life log will most probably contain
a mixture of randomly created traces and traces created using recommen-
dations., i.e., by random/explorative and experience-based ways of working.
first experiments indicate that the degree to which a log contains random
traces compared to traces created based on recommendations also inuences
the cycle time. however, like for completely random logs an increase of the
log size has led to decreases in the cycle time, but the slope of the decrease
tends to be steeper for higher ratios of random behaviour in the log. anextensive investigation of logs with dierent ratios of random traces will be
subject of further studies.
5 related work
the need for exible paiss has been recognized and several competing paradigms
(e.g., adaptive process management [8, 13, 23], case-handling systems [17] and
declarative processes [11]) have been proposed by both academia and industry
(for an overview see [21, 22]). in all these approaches the described trade-o
between exibility requiring user assistance can be observed.
adaptive pais represent one of these paradigms by enabling users to make
structural process changes to support both the handling of exceptions and the
evolution of business processes. related work in the context of adaptive paiss
addresses user support in exceptional situations. both procycle [12, 14] and
cake2 [8] support users to conduct instance specic changes through change
reuse. while their focus is on process changes, our recommendation service assists
users in selecting among enabled activities. procycle and cake2 use case-based
reasoning techniques to support change reuse. therefore suggestions to the users
are based on single experiences, (i.e., the most similar case from the past), while
in our approach recommendations are based on the entire log.
in [18] recommendations are used to select the step, which meets the per-
formance goals of the process best. like in our approach selection strategies
(e.g., lowest cost, shortest remaining processing time) are used. however, the
recommendations are not based on a log, but on a product data model.
except for adaptive process management technology, which allows for struc-
tural changes of the process model and the case-handling paradigm, which pro-
vides exibility by focusing on the whole case, many approaches support exibil-
ity by allowing the design of a process with regions (placeholders) whose contents
is unknown at design-time and whose content is specied (late modeling) or se-
lected (late binding) during execution of the tasks (for details see [21, 22]).
examples of such approaches are, for instance, worklets [2] or the pockets of
flexibility [15] approach. both approaches provide user assistance by providing
simple support for the reuse of previously selected or dened strategies, recom-
mendations as envisioned in our approach are not considered.
in addition to the approaches described above there is a third paradigm
for exible workows, which relies on a declarative way of modeling business
processes. as opposed to imperative languages that \procedurally describe se-
quences of action", declarative languages \describe the dependency relation-
ships between tasks" [5]. generally, declarative languages propose modeling con-
straints that drive the model enactment [11]. when working with these systems,
users have the freedom to choose between a variety of possibilities as long as
they remain within the boundaries set by the constraints [10,11]. in the context
of declarative workows user assistance has not been addressed so far.6 conclusion
existing paiss are struggling to balance support and exibility. classical work-
ow systems provide process support by dictating the control-ow while group-
ware-like systems oer exibility but provide hardly any process support. by
using recommendations, we aim at oering support based on earlier experiences
but not limit the user by imposing rigid control-ow structures. in this paper
we presented an approach based on recommendations, i.e., based on a process
model providing a lot of exibility the set of possible activities is ranked based
ondoand dont values. the recommendation is based on (1) a congurable ab-
straction mechanism to compare the current partial case with earlier cases and
(2) a target function (e.g., to minimize costs or cycle time). the whole approach
has been implemented by extending prom and can be combined with any pais
that records events and oers work through worklists.
the experimental results in this paper show the value of information , i.e.,
the more historic information is used, the better the quality of the recommen-
dation. we experimented with dierent abstractions and log sizes. clearly, the
performance depends on the characteristics of the process and the abstraction.
however, the experiments show that traces executed by support of recommenda-
tions often outperform traces executed without such support. this is illustrated
by the dierence in performance between the random selection and appropriate
guided selection.
future work will aim at characterizing the suitability of the various abstrac-
tion notions. through a large number of real-life and simulated experiments we
aim at providing insights into the expected performance of the recommendation
service. moreover, we aim at an intelligent selection of the horizon for the log
used to \train" the recommendation service. our experiments show that it is not
wise to provide recommendations based on just a few observations. however, if
there are many observations, it makes sense to only use a subset (e.g., only the
most recent traces). this way the performance of the approach improves for
long-running processes and the recommendation strategy can easily adapt to
changing circumstances.
acknowledgements the authors would like to thank maja pesic and christian
g unther, isaac corro ramos, christian haisjackl for their help and contributions.
references
1. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
2. m. adams, a.h.m. ter hofstede, d. edmond, and w.m.p. van der aalst. a service-
oriented implementation of dynamic flexibility in workows. in coopis'06 , 2006.
3. s. carlsen, j. krogstie, a. slvberg, and o.i. lindland. evaluating exible workow
systems. in proc. hicss-30) , 1997.
4. b.f. van dongen and w.m.p. van der aalst. a meta model for process mining
data. in emoi-interop , 2005.5. p. dourish, j. holmes, a. maclean, p. marqvardsen, and a. zbyslaw. freeow:
mediating between representation and action in workow systems. in proc. cscw
'96, pages 190{198, 1996.
6. m. hammer and s.a. stanton. the reengineering revolution { the handbook .
harper collins publ., 1995.
7. p. heinl, s. horn, s. jablonski, j. neeb, k. stein, and m. teschke. a comprehen-
sive approach to flexibility in workow management systems. in proc. wacc
'99, pages 79{88, new york, ny, usa, 1999. acm.
8. m. minor, a. tartakovski, d. schmalen, and r. bergmann. agile workow tech-
nology and case-based change reuse for long-term processes. international
journal of intelligent information technologies , 1(4):80{98, 2008.
9. b. mutschler, b. weber, and m. u. reichert. workow management versus case
handling: results from a controlled software experiment. in proc. sac'08 . acm
press, 2008.
10. m. pesic and w.m.p van der aalst. a declarative approach for flexible business
processes. in proc. dpm'06 , pages 169{180, 2006.
11. m. pesic, m.h. schonenberg, n. sidorova, and w.m.p v. d. aalst. constraint-
based workow models: change made easy. in coopis'07 , 2007.
12. j. pinggera, s. zugal, b. weber, w. wild, and m. reichert. integrating case-
based reasoning with adaptive process management. technical report, ctit,
university of twente, enschede, 2008.
13. m. reichert and p. dadam. adept flex{ supporting dynamic changes of work-
ows without losing control. jiis, 10(2):93{129, 1998.
14. s. rinderle, b. weber, m. reichert, and w. wild. integrating process learning
and process evolution - a semantics based approach. in bpm 2005 , pages 252{267,
2005.
15. s. sadiq, w. sadiq, and m. orlowska. a framework for constraint specication
and validation in flexible workows. information systems , 30(5):349 { 378, 2005.
16. w.m.p. van der aalst, v. rubin, b.f. van dongen, e. kindler, , and c.w. g unther.
process mining: a two-step approach using transition systems and regions. tech-
nical report bpm-06-30, bpmcenter.org, 2006.
17. w.m.p. van der aalst, m. weske, and d. gr unbauer. case handling: a new
paradigm for business process support. data and knowledge engineering. ,
53(2):129{162, 2005.
18. i. vanderfeesten, h.a. reijers, and w.m.p. van der aalst. product based workow
support: a recommendation service for dynamic workow execution. technical
report bpm-08-03, bpmcenter.org, 2008.
19. w.m.p. v.d. aalst and s. jablonski. dealing with workow change: identication
of issues an solutions. int'l journal of comp. systems, science and engineering ,
15(5):267{276, 2000.
20. w.m.p v.d. aalst, b.f van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m weijters. workow mining: a survey of issues and approaches. data and
knowledge engineering , 27(2):237{267, 2003.
21. b. weber, s. rinderle, and m. reichert. change patterns and change support
features in process-aware information systems. in proc. caise'07 , pages 574{
588, 2007.
22. b. weber, s. rinderle, and m. reichert. change support in process-aware infor-
mation systems - a pattern-based analysis. technical report tr-ctit-07-76,
university of twente, 2007.
23. m. weske. formal foundation and conceptual design of dynamic adaptations in
a workow management system. in proc. hicss-34 , 2001.