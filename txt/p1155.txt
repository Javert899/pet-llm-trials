incremental discovery of
hierarchical process models
daniel schuster1/envelope, sebastiaan j. van zelst1;2, and wil m.p. van der aalst1;2
1fraunhofer institute for applied information technology fit, sankt augustin,
germanyfdaniel.schuster,sebastiaan.van.zelst g@fit.fraunhofer.de
2rwth aachen university, aachen, germany
fs.j.v.zelst,wvdaalst g@pads.rwth-aachen.de
abstract. many of today's information systems record the execution of
(business) processes in great detail. process mining utilizes such data and
aims to extract valuable insights. process discovery, a key research area
in process mining, deals with the construction of process models based
on recorded process behavior. existing process discovery algorithms aim
to provide a \push-button-technology", i.e., the algorithms discover a
process model in a completely automated fashion. however, real data
often contain noisy and/or infrequent complex behavioral patterns. as a
result, the incorporation of all behavior leads to very imprecise or overly
complex process models. at the same time, data pre-processing tech-
niques have shown to be able to improve the precision of process models,
i.e., without explicitly using domain knowledge. yet, to obtain superior
process discovery results, human input is still required. therefore, we
propose a discovery algorithm that allows a user to incrementally extend
a process model by new behavior. the proposed algorithm is designed to
localize and repair nonconforming process model parts by exploiting the
hierarchical structure of the given process model. the evaluation shows
that the process models obtained with our algorithm, which allows for
incremental extension of a process model, have, in many cases, supe-
rior characteristics in comparison to process models obtained by using
existing process discovery and model repair techniques.
keywords: process miningincremental process discovery process
treesprocess model repair.
1 introduction
process discovery is one of the three main elds in process mining , along with
conformance checking and process enhancement [4]. in process discovery, the
data generated during process executions and stored in information systems are
utilized to generate a process model that describes the observed behavior. we
refer to such data as event data . the obtained process models are used for a
variety of purposes, e.g., to provide insights about the actual process performed
and to analyze and improve performance and compliance problems.2 d. schuster et. al.
most process discovery techniques are fully automated, i.e., no interaction
with the algorithm is possible during discovery. these techniques require event
data as input and return a process model that describes the given observed
behavior. moreover, it is not directly possible, i.e., using process discovery tech-
niques, to extend an existing process model with additional behavior, except
by re-applying the algorithm to the entire extended event data. process model
repair techniques have been developed to add additional behavior to an existing
model. however, they are not designed to be applied iteratively to a given event
log to mimic an (incremental) process discovery algorithm.
in this paper, we propose an approach to incrementally discover process mod-
els. the algorithm allows the user to incrementally discover a process model by
adding the behavior, trace by trace, to an existing process model. thereby, the
process model under construction gets incrementally extended. hence, our ap-
proach combines the usually separate phases of event data ltering and discovery.
in addition, the algorithm oers the possibility at any point in time to \auto-
complete", i.e., observed behavior not yet processed is automatically added to
the process model under construction. our approach takes behavior that is not
yet described by the process model and detects which parts of the process model
must be altered. we focus on hierarchical, also called block-structured, process
models and exploit their structure to determine the process model parts that
must be changed. the evaluation of our proposed approach shows that the ob-
tained process models have a comparable and in many cases superior quality
compared to non-incremental process discovery algorithms, which have to be ex-
ecuted on the whole extended event data each time behavior is added. further-
more, the conducted experiments show that our proposed approach outperforms
an existing process model repair technique [12] in many cases.
the remainder of the paper is structured as follows. we present related work
in section 2. in section 3, we present concepts, notations and denitions used
throughout the paper. in section 4, we present our novel approach to incremen-
tally discover process models. afterwards, we discuss the results of the conducted
experiments in section 5. finally, we summarize the paper in section 6.
2 related work
various process discovery algorithms exist. an overview is beyond the scope of
this paper, hence, we refer to [11]. we mainly focus on process model repair
techniques, incremental and interactive process discovery.
the term process model repair was introduced in [12] and an extended algo-
rithm to repair a process model was presented in [13]. in the paper, an event log
land a process model pis assumed, i.e., a petri net, which does not accept all
traces inl. the goal is to nd a process model p0that accepts l. in comparison
to our proposed approach, an essential goal for the authors is that the repaired
modelp0is structurally similar to the original model psince their focus is on
model repair and not on process discovery. since our proposed approach is anincremental discovery of hierarchical process models 3
incremental algorithm for process discovery, similarity of the resulting model to
the original model is not a requirement.
in [15], an incremental process discovery architecture was introduced that is
based on merging new discovered process models into existing ones. in detail,
an existing process model pis assumed and, for unseen behavior, a new process
model is discovered and then merged into the existing model p. furthermore,
the approach is explicitly designed to work in an automated fashion. two other
approaches [14,19] calculate ordering relations of activities based on the given
process model and on a yet unprocessed event log. the two obtained relations
are then merged together and are used to retrieve a model. in [7] the authors
describe a repair approach that incrementally highlights deviations in a process
model with respect to a given event log. the user has to manually repair this
deviations under the guidance of the algorithm.
next to incremental process discovery algorithms, there is the eld of inter-
active process mining [9]. in [10] an interactive process discovery algorithm is
presented that assumes constant feedback from a user. moreover, the user con-
trols the algorithm by specifying how the process model should be altered. the
algorithm supports the user by indicating favourable actions, e.g, where to place
an activity in the process model (and also provides an \auto-complete option").
furthermore, the algorithm ensures that the process model under construction
retains certain properties, i.e., soundness.
3 background
in this section, we introduce notations and denitions used in this paper.
given an arbitrary set x, we denote the set of all sequences over xasx,
e.g.,ha;b;bi2fa;b;cg. we denote the empty sequence by hi. for a given sequence
, we denote its length as jjand fori2f1;:::;jjg,(i) represents the i-th
element of. given two sequences and0, we denote the concatenation of these
two sequences by 0. for instance,haihb;ci=ha;b;ci. we extend theoperator
to sets of sequences, i.e., let s1;s2xthens1s2=f12j12s1^22s2g.
for given traces ;0, the set of all interleaved sequences is denoted by 0.
for example,ha;bihci=fha;b;ci;ha;c;bi;hc;a;big. we extend theoperator to
sets of sequences. let s1;s2be two sets of sequences. s1s2denotes the set of
interleaved sequences, i.e., s1s2=f12j12s1^22s2g.
for a setx, a multi-set over xallows multiple appearances of the same
element. formally, a multi-set is a function f:x!n0that assigns a multiplicity
to each element in x. for instance, given x=fa;b;cg, a multi-set over xis
[a3;c], which contains three times an element a, noband onec. we denote all
possible multi-sets over xasb(x). furthermore, given two multi-sets xand
y,x]ydenotes the union of two multi-sets, e.g., [ x2;a]][x;y2]=[x3;a;y2].
next, we introduce projection functions. given a set x, a sequence 2x
andx0x. we recursively dene #x02x0with:hi#x0=hi, (hxi)#x0=hxi#x0
ifx2x0and (hxi)#x0=#x0otherwise.4 d. schuster et. al.
table 1: example of an event log
event-id case-id activity name timestamp 
    
200 13 create order (c) 2020-01-02 15:29:24 
201 27 receive payment (r) 2020-01-02 15:44:34 
202 43 dispatch order (d) 2020-01-02 16:29:24 
203 13 pack order (p) 2020-01-02 19:12:13 
204 13 cancel order (a) 2020-01-03 11:32:21 
    
lett=(x1;:::;xn)2x1:::xnbe ann-tuple overnsets. we dene projec-
tion functions that extract a specic element of t, i.e.,1(t)=x1;:::;n(t)=xn.
for example, 2((a;b;c )) =b.
analogously, given a sequence of length mwithn-tuples=h(x1
1;:::;x1
n);:::;
(xm
1;:::;xm
n)i, we dene 
1()=hx1
1;:::;xm
1i;:::;
n()=hx1
n;:::;xm
ni. for in-
stance,
2(h(a;b);(a;c);(b;a)i)=hb;c;ai.
3.1 event data & event logs
the execution of (business) processes generates event data in the corresponding
information systems. such data describe the activities performed, which process
instance they belong to and they contain various metadata about the activities
performed. activities performed in the context of a specic process instance are
referred to as a trace, i.e., a sequence of activities.
consider table 1 in which we present an example of an event log. for in-
stance, if we consider all events related to the case-id 13, we observe the trace
hcreate order (c), pack order (p), cancel order (a) i. for simplicity, we abbreviate
activities with letters. a variant describes a unique sequence of activities which
can occur several times in an event log. since, in the context of this paper, we are
only interested in the traces that occurred, we dene an event log as a multiset
of traces. note that, event data as depicted in table 1 can be translated easily
into a multiset of traces.
denition 1 (event log). letadenote the universe of activities. an event
logis a multiset of sequences over a, i.e.,l2b(a).
3.2 process models
a process model describes the (intended) behavior of a process. many process
modeling formalisms exist, ranging from informal textual descriptions to math-
ematical models with exact execution semantics. in the eld of process mining,
workow nets [1] are often used to represent process models since concurrent be-
havior can be modelled in a compact manner. in this paper we focus on process
trees that represent hierarchical structured, sound workow nets, i.e., block-
structured workow nets [16]. we formally dene process trees in denition 2.incremental discovery of hierarchical process models 5
t3:1 t3:2t2:1t1:1 t1:2t0
!
	

!
at4:1
bt4:2^
ct4:3
dt4:4t2:2^
et2:3
ft2:4
fig. 1: example of a process tree t0
denition 2 (process tree). letabe the universe of activities and let =2a.
let=f!;;^;	gbe the set of process tree operators.
{given an arbitrary a2a[fg,ais a process tree
{givenn1process trees t1;t2;:::;tnand an operator2f!;;^g,t=
(t1;t2;:::;tn)is a process tree
{given two process trees t1;t2,t=	(t1;t2)is a process tree
we denote the set of all process trees over aasta. furthermore, we denote
for a process tree tthe set of its leaf nodes by lt. note that, by denition, leaf
nodes always contain activities or the silent activity , and inner nodes and the
root node always contain process tree operators. consider fig. 1 which shows an
example of a process tree t0. note that the tree can also be presented textually:
!(	((!(a;b);^(c;d)););^(e;f)).
for given process trees tandt0, we callt0asubtree oftift0is contained
int. for instance, t3:2is a subtree of t1:1(fig. 1). given two subtrees tx;ty
of a treet, we dene the lowest common ancestor (lca) as the treetlca such
that the distance between t's root node and tlca's root node is maximal and
tx;tyare contained in tlca. for example, given the two subtrees t4:2andt2:2
oft0(fig. 1),t1:1is the lca of t4:2andt2:2.
in the following, we rst informally describe the semantics of a process tree
and afterwards, present formal denitions. the sequence operator !indicates
that the subtrees have to be sequentially executed. for example, the root of
process tree t0is a sequence operator. hence, the left subtree t1:1has to be
executed before the right one t1:2. the loop operator 	, which has by denition
two subtrees, contains a loop body which is the rst subtree and a redo part, the
second subtree. the loop body has to be executed at least once. afterwards, the
redo part can be optionally executed. in case the redo part is executed, the loop
body must be executed afterwards again. the choice operator , i.e., exclusive
or, indicates that exactly one subtree must be executed. the parallel operator ^
indicates a parallel (interleaved) execution of the subtrees. for instance, for the
treet1:2the activities eandfcan be executed in any order.6 d. schuster et. al.
abcf
a
(t4:1)b
(t4:2)
(t2:2)d
(t4:4)c
(t4:3)f
(t2:4)e
(t2:3)abcf
a
(t4:1)b
(t4:2)f
(t2:4)e
(t2:3)
fig. 2: two possible alignments for process tree t0(fig. 1) andha;b;c;fi
we denote the language of a process tree t2ta, i.e., the set of accepted
traces overa, asl(t). for instance,ha;b;f;ei;hd;c;a;b;e;fi2l(t0) andhd;c;a;e;fi;
ha;c;e;fi=2l(t0). next, we dene the semantics of process trees based on [4].
denition 3 (semantics of process trees). for a process tree t2ta, we
recursively dene its language l(t).
{ift=a2a,l(t)=fhaig
{ift=,l(t)=fhig
{ift=!(t1;:::;tn),l(t)=l(t1):::l(tn)
{ift=^(t1;:::;tn),l(t)=l(t1):::l(tn)
{ift=(t1;:::;tn),l(t)=l(t1)[:::[l(tn)
{ift=	(t1;t2),l(t)=f10
120
2:::mjm1^81im(i2l(t1))^
81im(0
i2l(t2))g
3.3 alignments
alignments have been developed to map observed behavior onto modeled behav-
ior [5]. they are used to determine if a given trace conforms to a given process
model. in the case of deviations, alignments indicate the detected deviations in
the process model and in the trace.
in fig. 2, two possible alignments for the process tree t0(fig. 1) and the
traceha;b;c;fiare given. the rst row, the trace part, always corresponds to the
given trace (ignoring the skip symbol ). the second row, the model part, always
corresponds to a trace that is accepted by the given process model (ignoring ).
an alignment move corresponds to a single column in fig. 2. we distinguish
four dierent alignment moves. synchronous moves, highlighted in light gray,
indicate that the observed behavior in the trace can be replayed in the process
model. for example, the rst two moves of the left alignment in fig. 2 represent
synchronous moves, i.e., the observed activities aandbcould be replayed in
the process model. log moves, highlighted in black, indicate additional observed
behavior that cannot be replayed in the process model and therefore represent
a deviation. model moves, highlighted in dark gray, indicate that behavior is
missing in the given trace according to the process model. model moves can
be further dierentiated into visible and invisible model moves. given the rst
alignment from fig. 2, the rst model move represents an invisible model move
because the executed activity is the silent activity . note that invisible model
moves do not represent deviations. the second model move represents a visible
model move since the executed activity d6=. visible model moves represent
deviations because a modeled activity was not observed.incremental discovery of hierarchical process models 7
abcdabef
a
(t4:1)b
(t4:2)
(t2:2)c
(t4:3)d
(t4:4)
(t2:2)a
(t4:1)b
(t4:2)e
(t2:3)f
(t2:4)
t0t0t0t0t0t0t0t0t0t0
t1:1t1:1t1:1t1:1t1:1t1:1t1:1t1:1
t2:1t2:1t2:1t2:1t2:1t2:1
t3:1t3:1 t3:1t3:1
t3:2t3:2
t1:2t1:2
(a) alignment and listing of subtrees containing the exe-
cuted process tree leave nodest0[ha;b;c;d;a;b;e;fi]
t1:1[ha;b;c;d;a;bi]
t2:1 [ha;bi2;hc;di]
t3:1 [ha;bi2]
t3:2 [hc;di]
t1:2 [he;fi]
(b) sub event logs
fig. 3: calculation of the sub event log for t0(fig. 1) and l=[ha;b;c;d;a;b;e;fi]
denition 4 (alignment). letadenote the universe of activities, let 2a
be a trace and let t2tabe a process tree with the set of leaf nodes lt. a sequence
2((a[fg )(lt[fg ))is an alignment i:
1.=
1()#a
2.
2()#lt2l(t)
3.(;)=2
4.(a1;a2)=2fora12a;a22lts.t.a16=a2
for giventand, the set of all possible alignments is denoted by  (;t).
since many alignments exist for a given trace and a process model, there is
the concept of optimal alignments. in general, an optimal alignment minimizes
the number of mismatches between the process model and the trace. to deter-
mine optimal alignments, costs are assigned to alignment moves. a cost minimal
alignment for a given trace and a process model is considered to be an optimal
alignment. in this paper, we assume the standard cost function that assigns cost
0 to synchronous and invisible model moves. furthermore, it assigns cost 1 to
visible model and log moves. note that there can be several optimal alignments
for a given model and trace. the calculation of optimal alignments was shown
to be reducible to the shortest path problem [5]. note that there can be several
optimal alignments.
we denote the set of optimal alignments for andtby (;t). observe that,
under the standard cost function, an alignment 2 (;t) indicates a deviation
between the trace and the process tree tif the costs are higher than 0.
3.4 sub event logs for process trees
in this section, we dene the concept of a sub event log. assume a process tree
tand a perfectly tting event log l, i.e.,f2lgl(t). we dene for each
subtree inta sub event log that reects which parts of the given traces from l
are handled by the subtree.
assume the event log l=[ha;b;c;d;a;b;e;fi] and the process tree t0(fig. 1).
the event log lis perfectly tting because the only trace =ha;b;c;d;a;b;e;fiin
lis accepted by t0, i.e.,2l(t0). to calculate sub event logs, we rst calculate8 d. schuster et. al.
algorithm 1: calculation of sub event logs for process trees
input:l2b(a),t2ta(assumption:f2lgl(t)))
output: sub event log for each subtree of t, i.e.,s:ta!b(a)
begin
1 forall subtreest0oftdo
2s(t0) [ ] // initialize sub event logs
3 forall2ldo
4 let2 (;t) // calculate optimal alignment for andt
5 forall subtreest0oftdo
6 t(t0) hi // initialize trace for each subtree
7 fori2f1;:::;jjgdo
8 m (i) // extract i-th alignment move
9 tl 2(m) // extract executed process leaf node
10 forall subtreest0oftdo
11 iftlis subtree of t0_tl=t0then
12 t(t0) t(t0)h2(m)i// add executed activity to t0's trace
13 else ift(t0)6=hithen
14 s(t0) s(t0)][t(t0)] // add trace to t0's sub event log
15 t(t0) hi // reset trace
16 return s
alignments for each trace in the given event log. the alignment of andt0is
depicted in the upper part of fig. 3a. since is accepted by t0, we only observe
invisible model moves and synchronous moves. below the depicted alignment, all
subtrees are listed that contain the executed leaf nodes. for example, the rst
executed leaf node a(t4:1) is a subtree of t0;t1:1;t2:1andt3:1.
obviously, all executed leaf nodes are subtrees of t0. hence, we add the
complete trace to t0's sub event log (fig. 3b). note that the sub event log
of the whole process tree, i.e., t0, is always equal to the given event log. the
subtreet1:1contains all executed leaf nodes from the 1stleafa(t4:1) to the
last execution of b(t4:2). this sequence of executed leaf nodes corresponds to
the traceha;b;c;d;a;bithat is added to t1:1's sub event log. the subtree t2:1
contains the rst two executed leaf nodes, i.e., a(t4:1) andb(t4:2). the 3rd
executed leaf node (t2:2) is not contained in t2:1. therefore, we add the trace
that corresponds to the rst two executed leaf nodes, i.e., ha;bi, tot2:1's sub
event log. the 4thand 5thexecuted leaf nodes are again a subtree of t2:1, but not
the 6thleaf node. hence, we add the trace hc;di, which corresponds to the 4th
and 5thexecuted leaf node, to t2:1's sub event log. the 7thand 8thexecuted leaf
nodes are again subtrees of t2:1, and therefore, we add the trace ha;bitot2:1's
sub event log. by processing the alignment for each subtree in the presented
way, we obtain sub event logs for each subtree in t0as shown in fig. 3b.
in alg. 1 we present a formal description of the sub event log calculation. we
successively calculate an alignment for each trace in l(line 4). first, we initializeincremental discovery of hierarchical process models 9
an empty trace for each subtree t0oftthat will be eventually added to t0's sub
log (line 6). next, we iterate over the alignment, i.e., the executed process tree
leaf nodes since the alignment contains only synchronous and invisible model
moves. for every subtree that contains the current executed leaf node, we add
the corresponding activity to its trace (line 14). if the current executed leaf
node is not contained in a subtree t0, we add the corresponding trace, if it is
not empty, to t0's sub log (line 14) and reset the trace (line 15).
4 incremental discovery of process trees
in this section, we present our approach to incrementally discover process trees.
in general, we assume an initially given process tree t, which is incrementally
modied trace by trace. if a new trace iis not accepted by the current process
treet, we calculate an optimal alignment and localize the nonconforming parts
int. we then modify the identied process tree part(s) to make the obtained
process tree t0accepti. afterwards, we continue with t0and process the next
tracei+1analogously. in case a trace is already accepted by the current process
tree, we move on to the next trace without modifying the current process tree.
the remainder of this section is structured as follows. first, we introduce an
approach to repair a single deviation.we then present a more advanced approach
that additionally handles blocks of deviations and uses the previously mentioned
approach as a fallback option.
4.1 repairing single deviations
in this section, we present an approach to repair a single alignment move which
corresponds to a deviation in a process tree. we assume that a process tree
t, a traceand an alignment 2 (t;) are given. moreover, we assume that
potential deviations in the given alignment are repaired from left to right.
next, we present process tree modications to repair various deviations.
assume that the given alignment contains a visible model move, i.e., =

a. since a model move indicates that a modeled activity was not observed,
we make the corresponding leaf node aoptional. therefore, we replace the leaf
nodeaby the choice construct (a;) (fig. 4a). this ensures that the activity
is optional in the process model and no longer causes a model move.
if the alignment contains a log move, we have to dierentiate two cases, i.e.,
the standard case and the root case. for the standard case the alignment is of
the form=ab
aor=b
, i.e., directly before the deviation,
there is either a synchronous or an invisible model move. in this case, we extend
the process tree such that we ensure that after the activity aorit is possible
to optionally execute the missing activity in the process model. therefore, we
replace the leaf node aby!(a;(b;)) (fig. 4b). accordingly, we change the
process tree for a preceding invisible model movement, i.e., we replace by
(;b) (fig. 4c). in the other case, the root case, the log move is at the beginning10 d. schuster et. al.
t
at

a=)make activity
aoptional
(a) repairing a visible model movet
at
!
a
b=)add missing
activityb
as option
(b) repairing a log move with pre-
ceding synchronous move
t
t

b=)add missing
activityb
as option
(c) repairing a log move with pre-
ceding invisible model movett!

a =)add missing
activitya
as option
(d) repairing a log move (root case)
fig. 4: repairing a single deviation - process tree repair modications
of the alignment, i.e., =a
. in this case, we add the possibility to optionally
execute the missing activity abefore the current tree. let tbe the given process
tree, we alter tto!((a;);t) (fig. 4d), i.e., we extend the given process tree
at the root node. since we assume that deviations in an alignment are repaired
from left to right, one of the two cases always applies to log moves.
the presented approach allows us to x multiple deviations in an align-
ment by separately repairing all deviations from left to right. furthermore, the
approach is deterministic because in each iteration we repair a deviation of the
given alignment. moreover, we always add behavior to the process tree and never
remove behavior, i.e., we always extend the language of accepted traces. in the
next section, we present a further approach that additionally handles blocks of
deviations and uses the presented approach as a fallback option.
4.2 repairing blocks of deviations
in this section, we present our more advanced approach that additionally handles
blocks of deviations. first, we present the conceptual idea and an example.
afterwards, we introduce the algorithm.
conceptual idea the proposed lca approach assumes an initial process tree
t, a perfectly tting event log l, i.e.,f2lgl(t), and a trace . the event log
lrepresents the traces processed so far, i.e., traces that must be accepted by the
process tree t. furthermore, the lca approach assumes a process tree discoveryincremental discovery of hierarchical process models 11
![ha;b;c;d;a;b;e;fi]
	[ha;b;c;d;a;bi]
[ha;bi2;
hc;di]
![ha;bi2]
ab^[hc;di]
cd^[he;fi]
ef
lca![ha;b;c;d;a;b;e;fi]
	[ha;b;c;d;a;bi]
[ha;bi2;
hc;di]
![ha;bi2;
ha; b; b i]
a	
b^[hc;di]
cd^[he;fi]
ef)
fig. 5: conceptual idea of the proposed lca approach
algorithmdisc:b(a)!tathat, given any event log, returns a perfectly tting
process tree.3the proposed lca approach returns a process tree t0such that
the given trace and the log lare accepted.
assume the process tree t0(fig. 1), the event log l=[ha;b;c;d;a;b;e;fi] and
the trace=ha;b;b;e;fi, which is not accepted by t0. when we apply the lca
approach, we rst calculate an optimal alignment.
abbef
a
(t4:1)b
(t4:2)e
(t2:3)f
(t2:4)
we always repair the rst occurring (block of successively occurring) devia-
tion(s). in the given example, we observe a log move on band before and after
the deviation a synchronous move. next, we calculate the lca of a(t4:1) and
b(t4:2) that encompass the deviation. the lca is t3:1and its sub event log is
[ha;bi2] as depicted in the left process tree in fig. 5. the calculated lca cor-
responds to a subtree that causes the deviation and must therefore be changed.
hence, we add the trace ha; b;b itot3:1's sub event log and apply the given disc
algorithm on the extended sub event log. for instance, we could get !(a;	(b;))
depending on the concrete instantiation of disc. finally, we replace t3:1by the
discovered process tree, i.e., t0
0=!(	((!(a;	(b;));^(c;d)););^(e;f)).
next, we again compute an alignment of the updated process tree t0
0and
. in case of further deviations, we repair them in the above-described man-
ner. otherwise, we return the modied process tree and the extended event log
l0=l][ha;b;b;e;fi]. hereinafter, we formally describe the algorithm in detail.
algorithmic description first, an optimal alignment is calculated for the
given trace and the process tree t, i.e.,2 (t;). in case there exist no
deviations, we return t. in case of deviations, we repair the rst (block of)
deviation(s). assume the alignment is of the form as depicted below.
3for example, the inductive miner algorithm [16] fullls the listed requirements.12 d. schuster et. al.
=x0
ixideviation(s)xjx0
j
t0
itideviation(s)tjt0
j
we have a (block of) deviation(s), i.e., visible model moves and/or log moves,
and directly before and after the (block of) deviation(s) there is no deviation,
i.e., either a synchronous move or an invisible model move in each position. let
tibe the process tree leaf node executed before the deviation(s) and tjbe the
one after the deviation(s). we then calculate the lca of tiandtj, hereinafter
referred to as tlca. note that tiandtjare subtrees of tlca.
next, we check which of the executed process tree leaf nodes preceding tiare
also a subtree of tlca. assumet0
iis a subtree of tlca and all process tree leafs
fromt0
iuntiltiare a subtree of tlca too. besides, either the process tree leaf
node executed before t0
iis not a subtree of tlca, ort0
iis the rst executed leaf
node in the alignment. since we repair the rst occurring (block of) deviation(s),
we know that before tionly synchronous or invisible model moves occur.
analogously, we check which executed process tree leaf nodes after tjare a
subtree oftlca. note that there is a dierence because log moves and visible
model moves potentially occur after tjbecause we always repair the rst (block
of) deviation(s). however, except that we ignore log moves, we proceed as de-
scribed above. let t0
jbe the last leaf node s.t. all executed leaf nodes from tjto
t0
jare a subtree of tlca. in addition, either the next executed leaf node after
t0
jis not a subtree of tlca or there exist no more executed tree leaves after t0
j.
givent0
iandt0
j, we add the trace hx0
i;:::;x0
ji#a(ignoring) totlca's sub
event logltlca, i.e.,l0
tlca=ltlca][hx0
i;:::;x0
ji#a]. next, we apply the given
discalgorithm on l0
tlcaand replace tlca by the newly discovered process tree
disc(l0
tlca). since the process tree disc(l0
tlca) accepts the trace hx0
i;:::;x0
ji#a,
we repaired the rst (block of) deviation(s). afterwards, we again calculate an
optimal alignment on the updated process tree and . if there are still deviations,
we again repair the rst (block of) deviation(s).
in the case that before or after the (block of) deviation(s) no process tree leaf
node was executed and hence, we cannot compute a lca, we apply the repair
approach from the previous section, which repairs a single deviation, on the rst
log or visible model move. afterwards, we apply the above described algorithm
again on the updated process tree. thereby, we ensure that the proposed lca
approach is deterministic since in every iteration a (block of) deviation(s) is
repaired either by rediscovering the determined lca or by applying the single
deviation repair approach. next, we rene the calculation of a lca to minimize
the aected subtrees getting altered.
lowering an lca in the tree hierarchy for a process tree with a low
height, it is likely that the proposed lca approach determines the root as lca
and therefore, re-discovers the entire process tree. this behavior is not desirable
since in this case the quality of the returned process tree solely depends on
the givendisc algorithm and most often, deviations can be repaired at a lower
subtree.incremental discovery of hierarchical process models 13
!
t1titjtn !
t1!
titjtn 
=)
t0
lcatlca
fig. 6: pulling down a sequence lca in the process tree hierarchy
to keep the aected subtrees that get rediscovered small, we introduce ex-
pansion rules to lower the detected lca in the tree hierarchy. for this purpose,
we use language preserving reduction rules in the reverse direction [17].
assume that the determined lca, denoted by tlca, contains the sequence
operator and has nchild nodes. furthermore, assume that the deviation was lo-
calized between two children of tlca, i.e., between tiandtj. hence, the process
tree is of the form tlca=!(t1;:::;ti;:::;tj;:::tn). then we know that all
child nodes of tlca which are not between tiandtjare not responsible for the
deviation. hence, we can cut ti;:::;tjand replace the nodes by a new sequence
operator with the cut subtrees as children, i.e., !(t1;:::;!(ti;:::;tj);:::tn)
(fig. 6). if we re-compute the lca, we will get t0
lca=!(ti;:::;tj).
in case the lca contains the parallel or choice operator, we lower the de-
tected lca in a similar manner. assume the deviation was localized between
two children of tlca, i.e., between tiandtj, and that tlca hasnchild
nodes. hence, the process tree is of the form tlca=(t1;:::;ti;:::;tj;:::tn)
for2f;^g. in this case, we extract the two child nodes tiandtjand pull
them one level down in the process tree: tlca=(t1;:::;(ti;tj);:::tn).
5 evaluation
we evaluated the proposed lca approach on the basis of a publicly available,
real event log. in the following section, we present the experimental setup. sub-
sequently, we present and discuss the results of the conducted experiments.
5.1 experimental setup
in the experiments, we compare the lca approach against the inductive miner
(im) [16], which discovers a process tree that accepts the given event log, and
the model repair approach presented in [13]. note that the repair algorithm
does not guarantee to return a hierarchical process model. we implemented the
lca approach extending pm4py [8], a process mining library for python. since
both the lca approach and the im algorithm guarantee the above mentioned
properties for the returned process tree, we use the im algorithm as a comparison
algorithm. furthermore, we use the im algorithm inside our lca approach as
an instantiation of the disc-algorithm, which is used for rediscovering subtrees.14 d. schuster et. al.
as input, we use a publicly available event log that contains data about a
road ne management process [18]. we use the complete event log, e.g., we do not
lter outliers. we sorted the event log based on variant frequencies in descending
order, i.e., the most occurring variant rst. we chose this sorting since in real
applications it is common to consider rst the most frequent behavior and lter
out infrequent behavior. note that the order of traces inuences the resulting
process model in our approach and in the model repair approach.
to compare the obtained process models, we use the f-measure regarding the
whole event log. the f-measure takes the harmonic mean of the precision and
the tness of a process model with respect to a given event log. fitness reects
how good a process model can replay a given event log. in contrast, precision
reects how much additional behavior next to the given event log is accepted by
the process model. the aim is that both the tness and the precision and thus,
the f-measure are close to 1. we use alignment-based approaches for tness [2]
and precision calculation [6].
the procedure of the conducted experiments is described below. first, we
discover a process tree on the rst variant with the im algorithm since the lca
approach and the model repair algorithm require an initial process model. note
that the lca approach can be used with any initial model. afterwards, we add
variant by variant to the initially given process model with the lca approach.
analogously, we repair the initially given process model trace by trace with the
model repair algorithm. in addition, we iteratively apply the im algorithm on
the 1stvariant, the 1st+2ndvariant, etc.
5.2 results
in fig. 7 we present the obtained results. we observe that the f-measures (fig. 7a)
of the process models obtained by the lca approach are higher compared to
models obtained by the im and the model repair algorithm for the majority
of processed variants. note that the im algorithm returns process trees with a
higher f-measure in the end. however, for real process discovery applications it
is unusual to incorporate the entire behavior in an event log. reasons for not
trying to incorporate all observed behavior are data quality issues, outliers and
incomplete behavior. furthermore, observe that after processing the rst 15% of
all variants, we already cover >99% of all recorded traces (fig. 7b) and obtain
a process model with the lca approach that outperforms the other techniques
(fig. 7a). the jump in the f-measure for the im algorithm at 70% processed
variants results from the fact that the im gets more behavior as input, i.e., a
larger event log, and therefore, detects a more suited pattern which leads to a
more precise process tree in this case.
in fig. 7c the precision values are depicted. these inuence the f-measure
most because we guarantee perfect tness w.r.t. the added trace variants. also
here we can see that for most of the processed variants the lca approach delivers
more precise models. however, if we add more than 70% of all variants, the
im algorithm suddenly delivers more precise models. for tness (fig. 7d) the
dierences between lca and im are minor.incremental discovery of hierarchical process models 15
(a) f-measure
 (b) event log coverage
(c) precision
 (d) fitness
fig. 7: results on f-measure, precision, tness and event log coverage
the higher f-measure of the lca approach in many cases compared to the
im algorithm can be explained by the dierences in the representational bias [3].
the lca approach may return models that have duplicate labels, i.e., the same
activity can occur in multiple leaf nodes. in comparison, the models returned
by the im algorithm do not allow for duplicate labels. note that also the model
repair algorithm allows duplicate labels.
6 conclusion
in this paper, we presented a novel algorithm to incrementally discover a process
tree. the approach utilizes the hierarchical structure of a process tree to localize
the deviating subtree and rediscovers it. the conducted experiments show that
the obtained process models have in many cases better quality in comparison
to models produced by a process discovery and model repair algorithm with
same guarantees about the resulting model, i.e., replay tness. actually, it is
surprising that our incremental discovery approach works so well. we do not use
domain knowledge and see many ways to improve the technique. the potential
to outperform existing approaches even further is therefore high.16 d. schuster et. al.
while most process discovery algorithms are fully automated, i.e., they as-
sume an event log and return a process model, the lca approach is able to
incrementally add behavior to an existing model. therefore, it can be used to
evolve a process model trace by trace. this makes it easy for the user to see the
impact on the process model when a trace is added. thus, by the incremental
selection of traces by a user, the usually separated phases of event data ltering
and process discovery are connected. hence, our approach enables the user to
interactively discover a process model by selecting iteratively which behavior
should be covered by the process model.
as future work, we plan to investigate both the impact of the initially given
model and the ordering of traces incrementally given to the lca approach on
the resulting process model. furthermore, we plan to explore dierent strate-
gies for determining the deviating subtree next to the lca calculation. we also
plan to further develop this algorithm into an advanced interactive process dis-
covery algorithm that provides further user interaction possibilities next to the
incremental selection of traces/observed behavior.
references
1. van der aalst, w.m.p.: the application of petri nets to workow management.
journal of circuits, systems, and computers 8(1), 21{66 (1998), http://dx.doi.
org/10.1142/s0218126698000043
2. van der aalst, w.m.p., adriansyah, a., van dongen, b.f.: replaying his-
tory on process models for conformance checking and performance analy-
sis. wiley interdiscip. rev. data min. knowl. discov. 2(2), 182{192 (2012).
https://doi.org/10.1002/widm.1045, https://doi.org/10.1002/widm.1045
3. van der aalst, w.m.p.: on the representational bias in process mining.
in: reddy, s., tata, s. (eds.) 20th ieee international workshops on en-
abling technologies: infrastructures for collaborative enterprises, wetice 2011,
paris, france, 27-29 june 2011, proceedings. pp. 2{7. ieee computer soci-
ety (2011). https://doi.org/10.1109/wetice.2011.64, https://doi.org/10.1109/
wetice.2011.64
4. van der aalst, w.m.p.: process mining - data science in action, second edition.
springer (2016), https://doi.org/10.1007/978-3-662-49851-4
5. adriansyah, a.: aligning observed and modeled behavior. ph.d. thesis, eindhoven
university of technology, department of mathematics and computer science (jul
2014), https://dx.doi.org/10.6100/ir770080
6. adriansyah, a., munoz-gama, j., carmona, j., van dongen, b.f., van der aalst,
w.m.p.: measuring precision of modeled behavior. inf. syst. e-business man-
agement 13(1), 37{67 (2015). https://doi.org/10.1007/s10257-014-0234-7, https:
//doi.org/10.1007/s10257-014-0234-7
7. armas-cervantes, a., van beest, n.r.t.p., rosa, m.l., dumas, m., garc a-
ba~ nuelos, l.: interactive and incremental business process model repair. in: otm
2017 conferences - coopis, c&tc, and odbase 2017, rhodes, greece, october
23-27, 2017, proceedings, part i. pp. 53{74 (2017). https://doi.org/10.1007/978-3-
319-69462-7 5
8. berti, a., van zelst, s.j., van der aalst, w.m.p.: process mining for python
(pm4py): bridging the gap between process-and data science. in: proceedings ofincremental discovery of hierarchical process models 17
the icpm demo track 2019, co-located with 1st international conference on pro-
cess mining (icpm 2019), aachen, germany, june 24-26, 2019. p. 13{16 (2019),
http://ceur-ws.org/vol-2374/
9. dixit, p.: interactive process mining. ph.d. thesis, department of mathematics
and computer science (6 2019)
10. dixit, p.m., verbeek, h.m.w., buijs, j.c.a.m., van der aalst, w.m.p.: in-
teractive data-driven process model construction. in: trujillo, j., davis, k.c.,
du, x., li, z., ling, t.w., li, g., lee, m. (eds.) conceptual modeling -
37th international conference, er 2018, xi'an, china, october 22-25, 2018,
proceedings. lecture notes in computer science, vol. 11157, pp. 251{265.
springer (2018). https://doi.org/10.1007/978-3-030-00847-5 19, https://doi.org/
10.1007/978-3-030-00847-5 19
11. van dongen, b.f., de medeiros, a.k.a., wen, l.: process mining: overview and
outlook of petri net discovery algorithms. trans. petri nets and other models
of concurrency 2, 225{242 (2009). https://doi.org/10.1007/978-3-642-00899-3 13,
https://doi.org/10.1007/978-3-642-00899-3 13
12. fahland, d., van der aalst, w.m.p.: repairing process models to reect real-
ity. in: barros, a.p., gal, a., kindler, e. (eds.) business process management
- 10th international conference, bpm 2012, tallinn, estonia, september 3-6,
2012. proceedings. lecture notes in computer science, vol. 7481, pp. 229{245.
springer (2012). https://doi.org/10.1007/978-3-642-32885-5 19, https://doi.org/
10.1007/978-3-642-32885-5 19
13. fahland, d., van der aalst, w.m.p.: model repair - aligning process models to
reality. inf. syst. 47, 220{243 (2015), https://doi.org/10.1016/j.is.2013.12.007
14. kalsing, a., do nascimento, g.s., iochpe, c., thom, l.h.: an incremental pro-
cess mining approach to extract knowledge from legacy systems. in: proceedings
of the 14th ieee international enterprise distributed object computing confer-
ence, edoc 2010, vit oria, brazil, 25-29 october 2010. pp. 79{88. ieee computer
society (2010). https://doi.org/10.1109/edoc.2010.13, https://doi.org/10.1109/
edoc.2010.13
15. kindler, e., rubin, v.a., sch afer, w.: incremental workow mining based on doc-
ument versioning information. in: li, m., boehm, b.w., osterweil, l.j. (eds.)
unifying the software process spectrum, international software process work-
shop, spw 2005, beijing, china, may 25-27, 2005, revised selected papers.
lecture notes in computer science, vol. 3840, pp. 287{301. springer (2005).
https://doi.org/10.1007/11608035 25, https://doi.org/10.1007/11608035 25
16. leemans, s.j.j., fahland, d., van der aalst, w.m.p.: discovering block-structured
process models from event logs - a constructive approach. in: colom, j.m., de-
sel, j. (eds.) application and theory of petri nets and concurrency - 34th interna-
tional conference, petri nets 2013, milan, italy, june 24-28, 2013. proceedings.
lecture notes in computer science, vol. 7927, pp. 311{329. springer (2013)
17. leemans, s.j.j., fahland, d., van der aalst, w.m.p.: scalable process discov-
ery and conformance checking. software and systems modeling 17(2), 599{
631 (2018). https://doi.org/10.1007/s10270-016-0545-x, https://doi.org/10.1007/
s10270-016-0545-x
18. de leoni, m., mannhardt, f.: road trac ne management process -
event log. 4tu.centre for research data (2015), https://doi.org/10.4121/uuid:
270fd440-1057-4fb9-89a9-b699b47990f5, (accessed: 2019-10-12)
19. sun, w., li, t., peng, w., sun, t.: incremental workow mining with optional
patterns and its application to production printing process. international journal
of intelligent control and systems 12, 45{55 (2007)