dynamic and context-aware process
adaptation
michael adams, arthur ter hofstede, nick russell
and wil van der aalst
abstract. this chapter re-examines the principles that under-
pin business process technologies to derive a novel approach that
moves beyond the traditional assembly-line metaphor. using a set
of principles derived from activity theory , a system has been im-
plemented, using a service oriented architecture, that provides
support for dynamic and extensible °exibility, evolution and ex-
ception handling in business processes, based on accepted ideas of
how people actually perform their work tasks. the resulting sys-
tem, called the worklet service , makes available all of the bene¯ts
o®ered by process aware information systems to a wider range of
organisational environments.
1.introduction
organisations are constantly seeking e±ciency improvements for their
business processes. to help achieve those goals, many are turning to
process-aware information systems (pais) to con¯gure and control
those processes (dumas et al., 2005; van der aalst & van hee, 2004)
by supporting their modelling, analysis, enactment and management
(zur muehlen, 2004; casati, 1998). the key bene¯ts organisations seek
by implementing pais solutions include: improved e±ciency, better
process control, improved customer service and business process im-
provement.
the use of pais has grown by concentrating on modelling rigidly
structured business processes that in turn derive well-de¯ned work°ow
instances (bider, 2005; joeris, 1999; reichert & dadam, 1997). how-
ever, the proprietary process de¯nition frameworks imposed make it
di±cult to support (i) dynamic evolution and adaptation (i.e. modify-
ing process de¯nitions during execution) following unexpected or de-
velopmental change in the business processes being modelled (borgida
& murata, 1999); and (ii) deviations from the prescribed process model
at runtime (rinderle et al., 2004; casati, 1998).
but change is unavoidable in the modern workplace. to remain
e®ective and competitive, organisations must continually adapt their
business processes to manage the rapid changes demanded by the dy-
namic nature of the marketplace or service environment. also, a large
1proportion of workplaces undertake activities that do not easily con-
form to rigid or constricting representations of their work practices.
and even in the most concrete processes deviations will occur within
almost every instantiation.
if pais could be extended to meet the challenges of evolutionary and
unexpected change in business processes, then their applicability would
widen to include a far greater proportion of workplaces. such support
would not only bene¯t existing users of process-aware technologies, but
would also introduce those businesses which employ more creative or
ad-hoc processes to the range of bene¯ts that pais o®er.
this chapter o®ers one solution designed to meet that challenge.
the primary objectives of this chapter are to provide:
²an overview of literature on approaches to exception handling
and °exibility in process-aware information systems
²a discussion of theoretical underpinnings of work practices
²a discussion of a comprehensive framework for exception han-
dling
²the introduction of a concrete approach for exception handling
based on this framework
²the introduction of a concrete approach to processes that require
on-the-°y change
²a description of an (open source) implementation of these ap-
proaches within a state-of-the-art work°ow system; and
²the presentation of an elaborated example.
2.background
a business process can be de¯ned as a composite set of tasks that
comprise coordinated computer-based and human activities (leymann,
2006). a business process model or schema is a formal representation
of work procedures that controls the sequence of performed tasks and
the allocation of resources to them (oberweis, 2005).
the development of a business process model typically begins with
an analysis of current business procedures and processes. subsequently,
a model is developed based on those practices and business rules, then
input into a pais and repetitively executed, supporting and giving
formal structure and °ow control to those processes. however, trans-
lating abstract concepts and descriptions of business practices and rules
into tangible process models is a far from trivial exercise. there are
sizeable development costs involved in mapping an abstract process
to a structured schema, which must be weighed against the perceived
cost bene¯ts that the system will deliver. therefore, current systems
are most advantageous where they provide support for standardised,
repetitive activities that do not vary between execution instances.but even in highly structured environments, it is di±cult (if not
impossible) to successfully capture all work activities, and in particu-
lar all of the task sequences possible, in a static process model. it is
also the case that, for any given human activity, the process for suc-
cessfully completing the activity is constantly evolving. change can
also be introduced via many sources, including government regulation,
new competitors, new markets, improvements in plant and equipment,
workforce and resource availability and so on.
a recent work°ow management coalition survey found that 75 per
cent of respondents reported they were currently performing work on
improving existing processes (up to 92 per cent for the finance sec-
tor) and 56 per cent were currently involved in a major business pro-
cess redesign (palmer, 2007). such statistics underscore the frequency
of organisational change and importance of providing a process man-
agement system which supports °exibility and the ability to adapt to
change.
it is because of the discrepancies between real-world activities and
formal representations of them that process instances typically experi-
ence exceptions during their execution. rather than being considered
an error, an exception in a business process is simply a deviation from
the expected control °ow or was unaccounted for in the original process
model. exceptions are a fundamental part of most organisational pro-
cesses (kammer et al., 2000); in fact, a substantial proportion of the
everyday tasks carried out in a business can be categorised as exception
handling work (barthelmess & wainer, 1995). historically, exception
handling within pais has fallen well short, particularly after execution
has commenced (kammer et al., 2000).
thus a large group of business processes do not easily map to the
rigid modelling structures provided, due to the lack of °exibility inher-
ent in a framework that, by de¯nition, imposes rigidity. this in°exi-
bility extends to the management of exceptions, which places further
limits on how accurately a process model can re°ect the actual busi-
ness process it is based on. rather, process models are `system-centric',
meaning that work processes are straight-jacketed (van der aalst et al.,
2005) into the paradigm supplied, rather than the paradigm re°ecting
the way work is actually performed (bider, 2005). as a result, users are
forced to work outside of the system, and/or constantly revise the pro-
cess model, in order to successfully complete their activities, thereby
negating the perceived e±ciency gains sought by implementing a pro-
cess management solution in the ¯rst place.
survey of literature and related systems. the following reviews
the levels of support for °exibility and exception handling in several of
the leading commercial process management products and a number ofacademic prototypes1. unless explicitly stated otherwise, information
regarding the products has been gleaned from product manuals, pub-
lished literature and white papers. the version numbers speci¯ed for
the commercial products are the versions that were reviewed.
since the mid-nineties much research has been carried out on is-
sues related to dynamic °exibility and exception handling in work°ow
management systems. such research was initiated because, generally,
commercial work°ow management systems provide only basic support
for handling exceptions (russell et al., 2006; zur muehlen, 2004) (be-
sides modelling them directly in the main `business logic'), and, where
extant, each deals with them in a proprietary manner; they typically
require the model to be fully de¯ned before it can be instantiated; and
changes must be incorporated by modifying the model statically. fur-
ther, there is minimal support for handling: workitem failures (and
even when that support is o®ered, they must be manually terminated);
external triggers; and only one system reviewed o®ers some constraint
violation management (russell et al., 2006).
tibco iprocess suite (version 10.5) (formerly sta®ware ) (tibco,
2006) provides constructs called event nodes , from which a separate
pre-de¯ned exception handling path or sequence can be activated when
an exception occurs at that point. it may also suspend a process either
inde¯nitely or wait until a deadline occurs. if a workitem cannot be
processed it is forwarded to a `default exception queue' where it may be
manually purged or re-submitted. a compensation workitem may be
initiated when a deadline occurs. also, a workitem may be externally
triggered, or `wait' until an external trigger occurs. certain tasks may
be manually skipped at runtime.
an optional component of the iprocess suite is the process orches-
trator (george® & pyke, 2003), which provides for the dynamic al-
location of sub-processes at runtime. it requires a construct called a
\dynamic event" to be explicitly modelled that will execute a number
of sub-processes listed in a prede¯ned `array' when execution reaches
that event. which sub-processes execute depend on prede¯ned data
conditionals matching the current case. there is no scope for dynami-
cally re¯ning conditionals, nor adding sub-processes at runtime.
cosa (version 5.4) (cosa, 2005) provides for the de¯nition of ex-
ternal `triggers' or events that may be used to start a sub-process.
all events and sub-processes must be de¯ned at design time, although
models can be modi¯ed at runtime (but only for future instantiations).
when a workitem fails the activity can be rolled back or restarted. a
compensating activity can be triggered either externally or on deadline
expiry. cosa also allows manual ad-hoc runtime adaptations such as
reordering, skipping, repeating, postponing or terminating steps.
1space considerations limit this discussion to the more popular and/or recent sys-
tems and prototypes; a more complete discussion can be found in adams (2007)websphere mq work°ow (version 6.0) (ibm, 2005) supports dead-
lines and, when they occur, will branch to a pre-de¯ned exception path
and/or send a noti¯cation message to a pre-de¯ned user or admin-
istrator. administrators can manually suspend, restart or terminate
processes, or reallocate tasks. only transaction-level exceptions are
recognised, and they are simply recorded in the audit log.
sap work°ow (version 6.20) (sap, 2006) supports conditional branch-
ing, where a list of conditions (each linked to a process branch) is parsed
and the ¯rst evaluating to true is taken; all branches are pre-de¯ned.
exception events are provided for cancelling work°ow instances, for
checking workitem pre and post constraints, and for `waiting' until an
external trigger occurs. exception handling processes may be assigned
to a work°ow based on the type of exception that has occurred, al-
though the handlers for each are speci¯ed at design time, and only one
may be assigned to each type | that is, ¯ltering through a set of pos-
sible handlers based on the context of the case is not supported. when
an exception occurs and a corresponding handler is found, all tasks in
the block where the exception is caught are cancelled.
flower (version 2.1) (berens, 2005), is of the `case-handling' par-
adigm); the process model (or `plan') describes only the preferred way
of doing things and a variety of mechanisms are o®ered to allow users
to deviate in a controlled manner (van der aalst et al., 2005). for ex-
ample, a deadline expiry can automatically complete a workitem. also,
some support for constraint violation is o®ered: a plan may be auto-
matically created or completed when a speci¯ed condition evaluates to
true (russell et al., 2006).
there have been a number of academic prototypes developed in the
last decade (although activity was greater during the ¯rst half); very
few have had any impact on the o®erings of commercial systems (zur
muehlen, 2004). several of the more widely acknowledged are discussed
here.
adept (reichert et al., 2005) supports modi¯cation of a process
during execution (i.e. add, delete and change the sequence of tasks)
both at the model (dynamic evolution) and instance levels (ad-hoc
changes). such changes are made to a traditional monolithic model and
must be achieved via manual intervention, abstracted to a high level
interaction. the system also supports forward and backward `jumps'
through a process instance, but only by authorised sta® who instigate
the skips manually (reichert et al., 2003).
theadaptflow prototype (greiner et al., 2004) provides a hybrid
approach to °exibility and exception handling. it supports eca rules-
based detection of exceptions and the dynamic adaptation of process
instances, although each adaptation must be con¯rmed manually by
an authorised user before it is applied (alternate manual handling to
override the dynamic adaptation o®ered is also supported). also, therule classi¯cations and available exception handling actions are limited
to medical treatment scenarios.
agentwork (muller et al., 2004) provides the ability to modify pro-
cess instances by dropping and adding individual tasks based on events
and eca rules. however, changes are limited to individual tasks,
rather than the task-process-speci¯cation hierarchy. also, the possibil-
ity exists for con°icting rules to generate incompatible actions, which
requires manual intervention and resolution.
a further approach using incompletely speci¯ed process de¯nitions
is found in the swindew (swinburne decentralised work°ow) project
(yan et al., 2004). swindew is a peer-to-peer based decentralised
model, where a process de¯nition is split into a set of task partitions and
distributed to peers, and on-the-°y process elaboration is performed at
runtime. thus, a multi-tiered process modelling and execution frame-
work is provided.
cbrflow (weber et al., 2004) uses a case-based reasoning approach
to support adaptation of prede¯ned work°ow models to changing cir-
cumstances by allowing (manual) annotation of business rules during
run-time via incremental evaluation by the user. thus users must be
actively involved in the inference process during each case.
an approach, which integrates cbrflow into the adept frame-
work, is described in (rinderle et al., 2005). in doing so, semantic
information about the reasons for change, and traceability data, are
presented to the adept user/administrator to support decision mak-
ing processes. the information can also be used to facilitate reuse of
ad-hoc changes from similar scenarios. when deviations from a process
schema are required, the case-based reasoning component assists the
user to ¯nd similar previous cases through a series of questions and an-
swers, one of which may then be applied to the current instance. while
the process is quite user-intensive, the approach does provide a good
example of the combination of contextual information with exception
handling techniques.
pesic and van der aalst (2006) point out that the majority of lan-
guages used to described and de¯ne business process models are of a
procedural nature, which limits their e®ectiveness in very °exible envi-
ronments, and introduce a declarative approach to process modelling,
called decserflow . a graphical language, it avoids many of the as-
sumptions, constraints, conditions and rules that must be explicitly
speci¯ed in procedural languages to perform °exible activities, the in-
clusion of which typically lead to an over-speci¯cation of the process.
in summary, approaches to °exibility and exception handling usually
rely on a high-level of runtime user and/or administrator interactivity,
which directly impedes on the basic aim of pais (to bring greater
e±ciencies to work practices) and distracts users from their primary
work roles into process support activities. another common limitationis the complex update, modi¯cation and migration issues required to
evolve process models.
3.theoretical foundation
whenever a series of actions is undertaken with a view to achieving
a pre-conceived result, some plan or set of principles is implemented
that guide and shape those actions towards that goal. to be e®ective,
a plan must be described using constructs and language that are rele-
vant to both the actions being performed and the desired result, and
be comprehensible by its participants and stakeholders. in business
process terms, analysts seek to model some aspect of the real world
by using a metaphor that bears some resemblance to the real world,
but also represents an understanding of computational processes. such
metaphors are abstract constructs that form a common reference model
that assist in representing the external world through computers.
the fundamental and widely understood computational metaphor
(stein, 1999) takes a set of inputs, performs a series of functional steps
in a strict sequence, and, on completion, produces some output that
represents the goal of the process. this metaphor describes a single,
centralised thread of control, which very much re°ects its mathematical
ancestry but also reveals an underlying misconception in the common
perception of technological `progress'. technological developments are,
according to holt (1997), \as much a®ected by fashion as clothing".
technologies do not evolve automatically (as marx assumed) but rather
re°ect prevailing human culture (mumford, 1963). that is, new tech-
nologies are derived from perceived needs and realised, not in isolation,
but through the conventions and norms of their social milieu .
thus the traditional computational metaphor reveals the in°uence
of pioneers such as von neumann and his team, and especially turing,
whose abstract machine proposed `step-at-a-time' processing (turing,
1936), and which in turn re°ects the in°uence on prevailing thought
of the contemporaneous development of assembly-line manufacturing
(hendriks-jansen, 1996).
as contempory technological advances in°uenced the structure of
early computers, so too has the computational metaphor become a sig-
ni¯cant model system for the conceptualisation and interpretation of
complex phenomena, from cognition to economics to ecology (stein,
1999). of particular interest is the way the metaphor has been applied
to the de¯nition of organisational work processes. the computational
metaphor remains applicable to well-de¯ned problem domains where
goal-directed, sequential, endpoint-driven planning is required (stein,
1999). such domains were the early bene¯ciaries of process manage-
ment systems. consequently, current commercial process management
systems provide support for standardised, repetitive activities that do
not vary between execution instances.adherence to the metaphor by pais has been an important factor
in their acceptance by organisations with structured work practices.
descriptions can be found throughout the work°ow literature to the
'processing', 'manufacturing' and 'assembly-line' modelling metaphors
that are employed by commercial systems. however, while the work-
°ow management coalition claims that \even o±ce procedures can
be processed in an assembly line" (work°ow management coalition,
2002), there are many aspects where administrative and service pro-
cesses di®er from manufacturing processes (van der aalst & berens,
2001). it may be that the computational metaphor has been an in-
hibiting factor in the development of systems able to e®ectively support
°exible work practices.
a process management system that better supports °exible work
environments requires a sound theoretical foundation that avoids the
computing metaphor, but rather describes how work is actually con-
ceived, carried out and re°ected upon. one such theoretical base can
be found in activity theory .
activity theory is a powerful and clarifying descriptive tool, rather
than a strongly predictive theory, and incorporates notions of inten-
tionality, history, mediation, collaboration and development, focussing
on understanding everyday practice in the real world (nardi, 1996).
activity theory originated in the former soviet union in the 1920's
and 30's as part of the cultural-historical school of psychology founded
by vygotsky, who began working on the theory at a time when the
prevailing psychological theories were based on re°exology (which at-
tempted to reduce all psychological phenomena to a series of stimulus-
response chains).
in the form presented by leontiev (1974), activity theory subse-
quently became one of the major soviet psychology theories, and was
used in areas such as the education of disabled children and the er-
gonomic design of equipment control panels.
in the 1980's and 90's, activity theory came to the attention of
scandinavian information technology researchers (for example: (nardi,
1996), (kuutti, 1996) and (b¿dker & greenbaum, 1993). their con-
tribution was a revised formulation of activity theory, and also the
application of activity theory to human-computer interface design.
brie°y, activity theory states that human activity has four basic
characteristics (bardram, 1997):
(1)every activity is directed towards a material or ideal object
satisfying a need, which forms the overall motive of the activity.
(2)every activity is mediated by artefacts, either external (a tool)
or internal (cognitive: using concepts, knowledge and experi-
ence).
(3)each individual activity is almost always part of collective activ-
ities, structured according to the work practice in which theytake place. for example, a patient diagnosis can seldom be
established without reference to a diversity of medical infor-
mation. thus collective activities are organised according to a
division of labour.
(4)finally, human activity can be described as a hierarchy with
three levels: activities realised through chains of actions , and
performed through operations :
²anactivity consists of one or more actions, and describes
the overall objective or goal.
²anaction equates to a single task carried out to achieve
some pre-conceived result. each action is achieved through
operations determined by the actual conditions in the con-
text of the activity.
²operations describe the actual performance of the action,
and are dependant on the context, or conditions that exist
for each action.
in adams et al. (2003), ten fundamental principles, representing an
interpretation of the central themes of activity theory applicable to
an understanding of organisational work practices, were derived and
are summarised below.
²principle 1: activities are hierarchical an activity con-
sists of one or more actions. each action consists of one or more
operations.
²principle 2: activities are communal an activity almost
always involves a community of participants working towards a
common objective.
²principle 3: activities are contextual contextual condi-
tions and circumstances deeply a®ect the way the objective is
achieved in any activity.
²principle 4: activities are dynamic activities are never
static but evolve asynchronously, and historical analysis is often
needed to understand the current context of the activity.
²principle 5: activities are mediated an activity is medi-
ated by tools, rules and divisions of labour.
²principle 6: actions are chosen contextually a reper-
toire of actions and operations is created, maintained and made
available to any activity, which may be performed by making
contextual choices from the repertoire.
²principle 7: actions are understood contextually the
immediate goal of an action may not be identical to the objec-
tive of the activity of which the action is a component. it is
enough to have an understanding of the overall objective of the
activity to motivate successful execution of an action.
²principle 8: plans guide work a plan is not a blueprint or
prescription of work to be performed, but merely a guide whichis modi¯ed depending on context during the execution of the
work.
²principle 9: exceptions have value exceptions are merely
deviations from a pre-conceived plan. deviations will occur
with almost every execution of the plan, and give rise to a
learning experience which can then be incorporated into future
executions.
²principle 10: granularity based on perspective a partic-
ular piece of work might be an activity or an action depending
on the perspective of the viewer.
table 1 shows a summary mapping of the 10 principles to a set of
criteria that a pais supporting the principles would meet.
activity theory o®ers a number of interesting insights into process
management domains, particularly the related issues of adaptability,
°exibility, evolution and exception handling. the principles derived
in this chapter have formed the theoretical foundations for the imple-
mentation and deployment of the system described in the following
sections.
4.conceptual framework
in the previous section, a set of principles was derived from activity
theory and applied to the issues of °exibility and exception handling
for work°ow systems. from that mapping of principles to issues, it was
found that:
(1)work°ow management systems typically have trouble support-
ing all but the most rigid business processes precisely because
their frameworks are based on computing metaphors rather
than accepted ideas of actual work practices.
(2)a work°ow management system that sought to overcome those
issues must be built around a framework that better mirrors
the way people perform work activities in organisational envi-
ronments.
the consideration of these ¯ndings formed the conceptual founda-
tions of a discrete service that transforms otherwise static work°ow pro-
cesses into fully °exible and dynamically extensible process instances
that are also supported by dynamic exception handling capabilities.
that service has been named the worklet service .
4.1.worklets: a conceptualisation. fundamentally, a work°ow
management system that is based on the principles derived from ac-
tivity theory would satisfy the following criteria:
²a °exible modelling framework | a process model is to be re-
garded as a guide to an activity's objective, rather than a pre-
scription for it;table 1. summary mapping of activity theory princi-
ples vs. work°ow functionality criteria
flexibility &
re-useadaptation
via re°ec-
tiondynamic
evolutionlocality of
changecomprehen-
sibility of
modelsexceptions
as `first-
class
citizens'
activities
are hierar-
chicalx x x
activities
are commu-
nalx
activities
are contex-
tualx x
activities
are dy-
namicx x x
mediation
of activity x x x
actions
are chosen
contextu-
allyx x
actions are
understood
contextu-
allyx x
plans guide
work x x x
exceptions
have value x x x
granularity
based on
perspectivex²a repertoire of actions | extensible at any time, the reper-
toire would be made available for each task during each process
instance;
²dynamic, contextual choice | from the repertoire at runtime
by considering the speci¯c context of the executing instance;
and
²dynamic process evolution | allow the repertoire to be dynam-
ically extended, thus providing support for unexpected process
deviations for all current and future instantiations of the pro-
cess, leading to natural process evolution.
thus, to accommodate °exibility, such a system would provide each
task of a process instance with the ability to be linked to an extensible
repertoire of actions, one of which to be contextually and dynami-
cally chosen at runtime to carry out the task. to accommodate ex-
ception handling, such a system would provide an extensible repertoire
of exception-handling processes to each process instance, members of
which to be contextually and dynamically chosen to handle exceptions
as they occur.
using a service-oriented architecture, such a system, the worklet ser-
vice, has been implemented. to support °exibility, the service presents
the repertoire-member actions as worklets . in e®ect, a worklet is a
small, self-contained, complete work°ow process which handles one spe-
ci¯c task (action) in a larger, composite process (activity).2a top-level
or parent process model is developed that describes the work°ow at a
macro level. from a manager process instance, worklets may be con-
textually selected and invoked from the repertoire of each enabled task,
using an associated extensible set of selection rules. new worklets may
be added to the repertoire of a task at any time (even during process
execution) as di®erent approaches to completing a task are developed,
derived from the context of each process instance. importantly, the
new worklet becomes an implicit part of the process model for all cur-
rent and future instantiations, avoiding issues of migration and version
control (van der aalst & basten, 2002; van der aalst, 2001; kradolfer
& geppert, 1999; joeris & herzog, 1998). in this way, the process
model undergoes implicit, dynamic, natural evolution.
in addition, for each anticipated exception, a separate repertoire
of exception handling processes, known as exlets may be de¯ned, to
be dynamically incorporated into a running process instance on an
as-needed basis. that is, for any exception that may occur at the
task, case instance or speci¯cation level, a repertoire of exlets may be
provided, the most appropriate one system-selected at runtime based
on the context of the case and the type of exception that has occurred.
2in activity theory terms, a worklet may represent one action within an activity,
or may represent an entire activity.further, worklets that are invoked as compensation processes within
an exlet are constructed in exactly the same way as those created to
support °exibility, which in turn are constructed in the same way as
ordinary, static process models.
in the occurrence of an unanticipated exception (i.e. an event for
which a handling exlet has not yet been de¯ned), then either an exist-
ing exlet can be manually selected (re-used) from the repertoire, one
may be adapted on the °y to handle the immediate situation, or a
new exlet constructed and immediately deployed, in each case allowing
execution of the process instance that raised the exception to take the
necessary action and either continue unhindered, or, if speci¯ed in the
exception handler, to terminate, as required. crucially, the method
used to handle the new exception and a record of its context are cap-
tured by the system and immediately become an implicit part of the
parent process model, and so a history of the event and the method
used to handle it is recorded for future instantiations.
4.2.context, rules and worklet selection. for any situation,
there are multiple situational and personal factors that combine to
in°uence a choice of action. that set of factors that are deemed to be
relevant to the current situation we call its context .
a taxonomy of contextual data that may be recorded and applied to
a work°ow instance may be categorised as follows (examples are drawn
from a medical treatment process):
²generic (case independent): data attributes that can be
considered likely to occur within any process (of course, the
data values change from case to case). such data would include
descriptors such as when created, created by, times invoked,
last invoked, current status; and role or agent descriptors such
as experience, skills, rank, history with this process and/or task
and so on. process execution states and process log data also
belong to this category.
²case dependent with a priori knowledge: that set of data
that are known to be pertinent to a particular case when it is
instantiated. generally, this data set re°ects the data variables
of a particular process instance. examples are: patient name
and id, blood pressure readings, height, weight, symptoms and
so on; deadlines both approaching and expired; and diagnoses,
treatments and prescribed medications.
²case dependent with no a priori knowledge: that set
of data that only becomes known when the case is active and
deviations from the known process occur. examples in this
category may include complications that arise in a patient's
condition after triage, allergies to certain medications and so
on.methods for capturing contextual propositions typically focus on col-
lecting a complete set of knowledge from an `expert' and representing
it in a computationally suitable way (kang et al., 1998). such ap-
proaches depend heavily on the expert's ability to interpret their own
expertise and express it in non-abstract forms (manago & kodrato®,
1987). consequently, the lack of systematic dissemination of expertise
has proved a major barrier to the development and use of improve-
ments in exception handling methods in business processes (klein &
dellarocas, 2000).
one bottom-up approach to the capture of contextual data that o®ers
an alternative method to global knowledge construction is ripple down
rules (rdr), which comprise a hierarchical set of rules with associated
exceptions, ¯rst devised by compton and jansen (1988).
the fundamental feature of rdr is that it avoids the di±culties
inherent in attempting to pre-compile a systematic understanding, or-
ganisation and assembly of all knowledge in a particular domain. the
rdr method is well established and fully formalised (sche®er, 1996)
and has been implemented as the basis for a variety of commercial ap-
plications, including systems for reporting dna test results, environ-
mental testing, intelligent document retrieval, fraud detection based
on patterns of behaviour, personal information management and data
mining of large and complex data sets (paci¯c knowledge systems,
2003).
an rdr knowledge base is a collection of rules of the form \if con-
dition then conclusion " (together with other associated descriptors),
conceptually arranged in a binary tree structure (cf. figure 1. each
rule node may have a false (`or') branch and/or a true (`exception')
branch to another rule node, except for the root node, which contains
a default rule and can have a true branch only. if a rule is satis¯ed,
the true branch is taken and the associated rule is evaluated; if it is
not satis¯ed, the false branch is taken and its rule evaluated (drake &
beydoun, 2000). when a terminal node is reached, if its rule is sat-
is¯ed, then its conclusion is taken; if its rule is not satis¯ed, then the
conclusion of the last rule satis¯ed on the path to that node is taken.
if the conclusion returned is found to be unsuitable for a particu-
lar instance | that is, while the conclusion was correct based on the
current rule set, the context of the instance make the conclusion an
inappropriate choice | a new rule is formulated that de¯nes the con-
textual di®erences between the instance and the selected rule and is
added as a new leaf node using the following algorithm:
²if the conclusion returned was that of a satis¯ed terminal rule,
then the new rule is added as a local exception to the exception
`chain' via a new true branch from the terminal node. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 0 
true 
default 
1 
ticketssold < (seating * 0.75) 
suspend workitem 
run changetomidvenue 
continue workitem  
3 
equipmentinstalled = false 
suspend case 
run rescheduleconcert 
continue case  2 
ticketssold < (seating * 0.5) 
suspend workitem 
run changetosmallvenue 
continue workitem  
4 
ticketssold < (seating * 0.2) 
suspend case 
run cancelshow 
remove case  condition not satisfied condition satisfied condition 
conclusion figure 1. example rule tree (itempreconstraint tree
for doshow task of organiseconcert)
²if the conclusion returned was that of a non-terminal, ancestor
node (that is, the condition of the terminal rule was not satis-
¯ed), then the new rule is added via a new false branch from
the unsatis¯ed terminal node.
in essence, each added exception rule is a re¯nement of its parent
rule. this method of de¯ning new rules allows the construction and
maintenance of the rule set by \sub-domain" experts (i.e. those who
understand and carry out the work they are responsible for) without
regard to any engineering or programming assistance or skill (kang
et al., 1998).
each rule node incorporates a set of case descriptors, called the `cor-
nerstone case', which describe the actual case context that was the
catalyst for the creation of the rule. when a new rule is added to the
rule set, its condition is determined by comparing the descriptors of the
current case to those of the cornerstone case and identifying a sub-set
of di®erences. not all di®erences will be relevant | only the factor or
factors that make it necessary to handle the current case in a di®erent
fashion to the cornerstone case are required to de¯ne a new rule. the
identi¯ed di®erences are expressed as attribute-value pairs, using the
normal conditional operators. the current case descriptors become the
cornerstone case for the newly formulated rule; its condition is formed
by the identi¯ed attribute-value pairs and represents the context of the
case instance that caused the addition of the rule.rather than impose the need for a closed knowledge base that must
be completely constructed a priori , this method allows for the identi-
¯cation of that part of the universe of discourse that di®erentiates a
particular case as the need arises . indeed, the only context of interest
is that needed for di®erentiation, so that rule sets evolve dynamically,
from general to speci¯c, through experience gained as they are applied.
ripple-down rules are well suited to the worklet and exlet selection
processes, since they:
²provide a method for capturing relevant, localised contextual
data;
²provide a hierarchical structuring of contextual rules;
²do not require the top-down construction of a global knowledge
base of the particular domain prior to implementation;
²explicitly provide for the de¯nition of exceptions at a local level;
²do not require expert knowledge engineers for its maintenance;
and
²allow a rule set to evolve and grow, thus providing support for
a dynamic learning system.
each worklet is a representation of a particular situated action that
relies on the relevant context of each instance, derived from case data
and other (archival) sources, to determine whether it is invoked to
ful¯l a task in preference to another worklet within the repertoire.
when a new rule is added, a worker describes the contextual conditions
as a natural part of the work they perform3. this level of human
involvement | at the `coalface', as it occurs | greatly simpli¯es the
capturing of contextual data. thus rdr allows the construction of an
evolving, highly tailored local knowledge base about a business process.
4.3.a conceptual framework for exception handling. the work-
°ow exception patterns (russell et al., 2006) were developed with the
general aim of providing a conceptual framework for exception handling
in work°ow systems. they aim to describe the notion of a work°ow
exception in a general sense and the various ways in which they can
be triggered and handled. an exception is anticipated to be a distinct,
identi¯able event which occurs at a speci¯c point in time during the
execution of a process instance. the manner in which the exception is
handled will depend on the type of exception that has been detected.
the types of events that give rise to exceptions can be classi¯ed into
¯ve distinct groups:
work item failure where during the course of its execution, a work
item to unable progress any further. this may be a consequence of
3in practice, the worker's contextual description would be passed to an administra-
tor, who would add the new rule.software or hardware failure or may be triggered by the user themselves
as a means of signalling failure to the work°ow engine;
deadline expiry where a deadline that is associated with a work
item (either for commencement or completion) is not met;
resource unavailability where the resources that are required in
order to commence or complete a work item are not available;
external trigger where signals are received from the operating envi-
ronment that an event has occurred that impacts on the work item or
process instance and requires some form of handling; and
constraint violation where constraints have been speci¯ed in rela-
tion to elements in the control-°ow, data or resource perspectives that
need to be maintained to ensure the integrity and operational consis-
tency of the work°ow process is preserved.
the actual recovery response to any given class of exception can be
speci¯ed as a pattern which succinctly describes the form of recovery
that will be attempted. speci¯c exception patterns may apply in mul-
tiple situations in a given process model (i.e. for several distinct con-
structs), possibly for di®erent types of exception. exception patterns
take the form of tuples comprising the following elements:
²how the task on which the exception is based should be handled;
²how the case and other related cases in the process model in
which the exception is raised should be handled; and
²what recovery action (if any) is to be undertaken.
exception handling at work item level. in general an exception will
relate to a speci¯c work item in a process instance and the way in which
the exception is handled depends on the current state of execution of
the work item. figure 2 illustrates as solid arrows the states through
which a work item progresses during normal execution. figure 2 also
shows ¯fteen strategies as dashed arcs from one work item state to
another, which to distinct approaches for handling the current item in
various states when a speci¯c type of exception is detected.
exception handling at case level. exceptions always occur in the con-
text of one or more cases (process instances) that are in the process
of being executed. in addition to dealing with the speci¯c work item
to which the exception relates, there is also the issue of how the case
should be dealt with in an overall sense, particularly in regard to other
work items that may currently be executing or will run at some future
time. there are three alternatives for handling work°ow cases:
(1)continue work°ow case (cwc) { the work°ow case can be
continued, with no intervention occurring in the execution of
any other work items;force−fail (sff)
startedfailed
completefail
force−complete (sfc)allocatedstart allocateoffered
withdrawncompleted withdrawcontinue−offer (oco)
reoffer (oro)force−fail−o (off)
force−complete−o (ofc)continue−allocation (aca)
reallocate (ara)reoffer−a (aro)force−fail−a (aff)
force−complete−a (afc)continue−execution (sce)
restart (srs)reallocate−s (sra)reoffer−s (sro)figure 2. options for handling work items
(2)remove current case (rcc) { selected or all remaining work
items in the case can be removed (including those currently
executing); or
(3)remove all cases (rac) { selected or all remaining work
items in both this and all other currently executing cases which
correspond to the same process model can be removed.
in the latter two scenarios, a selection of work items to be removed
can be speci¯ed using both static design time information relating to
the corresponding task de¯nition (e.g. original role allocation) as well
as relevant runtime information (e.g. actual resource allocated to, start
time).
recovery action. the ¯nal consideration in regard to exception han-
dling is what action will be taken to remedy the e®ects of the situation
that has been detected. there are three alternate courses of action:
(1)no action (nil) { do nothing;
(2)rollback (rbk) { rollback the e®ects of the exception; or
(3)compensate (com) { compensate for the e®ects of the ex-
ception.
rollback and compensation are analogous to their usual de¯nitions.
when specifying a rollback action, the point in the process (i.e. the
task) to which the process should be undone can also be stated. by
default this is just the current work item. similarly with compensation
actions, the corresponding compensation task(s) must also be identi-
¯ed.
5.implementation
theworklet service has been implemented as a yawl custom ser-
vice (van der aalst & ter hofstede, 2005; van der aalst et al., 2004).
the yawl environment was chosen as the implementation platform   
worklet 
service 
     
 x 
selection 
exception    
yawl 
engine 
 a 
b rule s 
logs  
 
yawl 
worklist 
 /computers1  
rules 
editor 
  
yawl 
editor 
 worklet 
specs 
 
 
user  figure 3. external architecture of the worklet service
since it provides a very powerful and expressive work°ow language
based on the work°ow patterns identi¯ed together with a formal se-
mantics (van der aalst et al., 2003). it also provides a work°ow en-
actment engine, and an editor for process model creation, that support
the control °ow, data and resource perspectives. the yawl environ-
ment is open-source and has a service-oriented architecture, allowing
the worklet paradigm to be developed as a service independent to the
core engine. thus the deployment of the worklet service is in no way
limited to the yawl environment, but may be ported to other envi-
ronments (for example, bpel engines) by making the necessary links
in the service interface.
custom yawl services interact with the yawl engine through
xml/http messages via certain interface endpoints. speci¯cally,
custom services may elect to be noti¯ed by the engine when certain
events occur in the life-cycle of nominated process instantiations (for
example: when a workitem becomes enabled, when a workitem is can-
celled, when a case completes), to signal the creation and completion
of process instances and workitems, or to notify of certain events or
changes in the status of existing workitems and cases.
the worklet service (including its rules editor), source code and
accompanying documentation, can be freely downloaded from http:
//www.yawl-system.com .
5.1.service architecture. the service consists of a number of j2ee
classes and servlet pages, organised in a series of packages.
the external architecture of the worklet service is shown in figure 3.
the entities `worklet specs', `rules' and `logs' comprise the worklet
repository . the service uses the repository to store rule sets, workletspeci¯cations for uploading to the engine, and generated process and
audit logs. any yawl speci¯cation may have an associated rule set.
the rule set for each speci¯cation is stored as xml data in a disk ¯le
within the worklet repository. the yawl process editor is used to
create new worklet speci¯cations, and may be invoked from the worklet
rules editor, which is used to create new or augment existing rule sets,
making use of certain selection logs to do so, and may communicate
with the worklet service via a jsp/servlet interface to override worklet
selections following rule set additions. the service also provides servlet
pages that allow users to directly communicate with the service to raise
external exceptions and to create and carry out administration tasks.
theworklet service comprises two discrete but complementary sub-
services: a selection service , which enables dynamic °exibility for pro-
cess instances, and an exception service , which provides facilities to
handle both expected and unexpected process exceptions at runtime.
the selection service. the selection service enables dynamic °ex-
ibility by allowing a process designer to designate certain workitems
to each be substituted at runtime with a dynamically selected worklet ,
which contextually handles one speci¯c task in a larger, composite
process activity. each worklet is a complete extended work°ow net
(ewf-net) compliant with de¯nition 1 of the yawl semantics (van
der aalst & ter hofstede, 2005). each worklet may be designed and
provided to the selection service at any time, even while a parent pro-
cess instance is executing , as opposed to a static sub-process that must
be de¯ned at the same time as, and remains a static part of, the main
process model.
an extensible repertoire of worklets is maintained by the service
for each task in a speci¯cation. each time the service is invoked for a
workitem, a choice is made from the repertoire based on the contextual
data values within the workitem and other sources, using a set of ripple-
down rules to determine the most appropriate substitution.
the workitem is checked out of the work°ow enactment engine, the
corresponding data inputs of the original workitem are mapped to the
inputs of the worklet, and the selected worklet is launched in the engine
as a separate case. when the worklet has completed, its output data
is mapped back to the original workitem, which is then checked back
into the engine, allowing the original process to continue.
from an engine perspective, the worklet and its parent are two dis-
tinct, unrelated cases. the worklet service tracks the relationships,
data mappings and synchronisations between cases, and creates a pro-
cess log that may be combined with the engine's process logs via case
identi¯ers to provide a complete operational history of each process
instance and may be used as a data source for the evaluation of rule
conditions.each task that is associated with a worklet repertoire is said to
be `worklet-enabled'. this means that a process may contain both
worklet-enabled tasks and non-worklet-enabled (or ordinary) tasks.
any process instance that contains a worklet-enabled task will become
the parent process instance for any worklets invoked from it.
importantly, a worklet-enabled task remains a valid (ordinary) task
de¯nition, rather than being considered as a vacant 'placeholder' for
some other activity (i.e. a worklet). the distinction is crucial because,
if an appropriate worklet for a worklet-enabled task cannot be found at
runtime (based on the context of the case and the rule set associated
with the task), the task is allowed to run as an `ordinary' task, as it
normally would in a process instance. so, instead of the parent process
being conceived as a template schema or as a container for a set of
placeholders, it is to be considered as a complete process containing
one or more worklet-enabled tasks, each of which may be contextually
and dynamically substituted at runtime.
worklets may be associated with either an atomic task, or a multiple-
instance atomic task. any number of worklets can form the repertoire
of an individual task, and any number of tasks in a particular speci¯-
cation can be associated with the worklet service. a worklet may be
a member of one or more repertoires | that is, it may be re-used for
several distinct tasks within and across process speci¯cations. in the
case of multiple-instance tasks, a separate worklet is launched for each
child workitem. because each child workitem may contain di®erent
data, the worklets that substitute for them are individually selected,
and so may all be instances of di®erent worklet speci¯cations.
the exception service. the exception service allows designers to
de¯ne exception handling processes (called exlets for parent work°ow
instances, to be invoked when certain events occur. it has been de-
signed so that the enactment engine, besides providing noti¯cations at
certain points in the life cycle of a process instance, needs no knowledge
of an exception occurring, or of any invocation of handling processes
| all exception checking and handling is provided by the service.
the exception service uses the same repertoire and dynamic rules
framework as the selection service. there are, however, two fundamen-
tal di®erences between the two sub-services. first, where the selection
service selects a worklet as the result of satisfying a rule in a rule set,
the result of an exception service rule being satis¯ed is an exlet. second,
while the selection service is invoked for certain nominated tasks in a
process, the exception service, when enabled, is invoked for every case
and task instance executed by the enactment engine, and will detect
and handle up to ten di®erent kinds of process exceptions.
as part of the exlet de¯nition, a process designer may choose from
various actions (such as cancelling, suspending, completing, failing andrestarting) and apply them at a workitem, case and/or speci¯cation
level. and, since the exlets can include compensatory worklets, the
original parent process model only needs to reveal the actual business
logic for the process, while the repertoire of exlets grows as new excep-
tions arise or di®erent ways of handling exceptions are formulated.
an extensible repertoire of exlets is maintained by the service for
each type of potential exception within each work°ow speci¯cation.
each time the service is noti¯ed of an exception event, either actual or
potential (i.e. a constraint check) the service ¯rst determines whether
an exception has in fact occurred, and if so, where a rule tree for that
exception type has been de¯ned, makes a choice from the repertoire
based on the type of exception and the context of the workitem/case.
if an exlet executed by the exception service contains a compensation
action (i.e. a worklet to be executed as a compensatory process) it is
run as a separate case in the enactment engine, so that from an engine
perspective, the worklet and its `parent' (i.e. the process that invoked
the exception) are two distinct, unrelated cases. figure 4 shows the
relationship between a `parent' process, an exlet repertoire and a com-
pensatory worklet, using an organise concert process as an example.
since a worklet is launched as a separate case, it is treated as such by
the worklet service and so may have its own worklet/exlet repertoire.
the service responds to the following exception types:
constraint types. constraints are rules that are applied to a workitem
or case immediately before and after execution. thus, there are four
sub-types of constraint exception: casepreconstraint ,itemprecon-
straint ,itempostconstraint , and casepostconstraint .
the service receives noti¯cation from the work°ow engine when each
of these constraint events occurs within each case instance, then checks
the rule set associated with the speci¯cation to determine, ¯rstly, if
there are any rules of that exception type de¯ned for the speci¯cation,
and if so, if any of the rules evaluate to true using the contextual data
of the case or workitem. if the rule set ¯nds a rule that evaluates to
true for the exception type and data, an associated exlet is selected
and invoked.
timeout. a timeout event occurs when a deadline set for a workitem
is reached. in this case, the work°ow engine noti¯es the service of the
timeout event, passing to the service a reference to the workitem. if
the workitem has an associated timeout rule set, the relevant exlet is
invoked.
externally triggered types. externally triggered exceptions occur, not
through context internal to the process instance, but because of the
occurrence of an event in the external environment, that may have an
e®ect on the continuing execution of the process. noti¯cation of these
events is typically triggered by a user or administrator. depending on
the actual event and the context of the case or workitem, a particular 
book stadium  sell tickets do show ‘parent’ process  itempreconstraint 
             exlets  c 
c 
c cancel stadium book theatre  advise fans compensation worklet  
organiseconcert changetomidvenue 
c figure 4. process { exlet { worklet hierarchy
exlet will be invoked if the associated rule exists. there are two types of
externally triggered types, caseexternaltrigger (for case-level events)
anditemexternaltrigger (for item-level events).
itemabort. an itemabort event occurs when a workitem reports that
it has been aborted before normal completion.
resourceunavailable. this event occurs when an attempt has been
made to allocate a workitem to a resource and the resource reports
that it is unable to accept the allocation or the allocation cannot pro-
ceed.
constraintviolation. this event occurs when a data constraint has been
violated for a workitem during its execution (as opposed to pre- or post-
execution).
when any of the above exception event noti¯cations occur, an appro-
priate exlet for that event, if de¯ned, will be invoked. each exlet may
contain any number of steps, or primitives , and is de¯ned graphically
using a rules editor (cf. figure 5.
the set of primitives that may be used to construct an exlet (as seen
left to right on the left of figure 5) are: figure 5. example handler process in the rules editor
²remove workitem : removes (or cancels) the workitem; execu-
tion ends, and the workitem is marked with a status of can-
celled. no further execution occurs on the process path that
contains the workitem.
²remove case : removes the case. case execution ends.
²remove all cases : removes all case instances for the speci¯ca-
tion in which the task of which the workitem is an instance is
de¯ned, or of which the case is an instance.
²suspend workitem : suspends (or pauses) execution of a workitem,
until it is continued, restarted, cancelled, failed or completed, or
the case that contains the workitem is cancelled or completed.
²suspend case : suspends all `live' workitems in the current case
instance (a live workitem has a status of ¯red, enabled or exe-
cuting), e®ectively suspending execution of the entire case.
²suspend all cases : suspends all `live' workitems in all of the
currently executing instances of the speci¯cation in which the
task of which the workitem is an instance is de¯ned, e®ectively
suspending all running cases of the speci¯cation.
²continue workitem : un-suspends (or continues) execution of
the previously suspended workitem.
²continue case : un-suspends execution of all previously sus-
pended workitems for the case, e®ectively continuing case exe-
cution.
²continue all cases : un-suspends execution of all workitems
previously suspended for all cases of the speci¯cation in which
the task of which the workitem is an instance is de¯ned or of
which the case is an instance, e®ectively continuing all previ-
ously suspended cases of the speci¯cation.
²restart workitem : rewinds workitem execution back to its
start. resets the workitem's data values to those it had when
it began execution.²force complete workitem : completes a `live' workitem. exe-
cution of the work-item ends, and the workitem is marked with
a status of forcedcomplete , which is regarded as a successful
completion, rather than a cancellation or failure. execution
proceeds to the next workitem on the process path.
²force fail workitem : fails a `live' workitem. execution of the
workitem ends, and the workitem is marked with a status of
failed , which is regarded as an unsuccessful completion, but not
as a cancellation | execution proceeds to the next workitem
on the process path.
²compensate : run one or more compensatory processes (i.e.
worklets). depending on previous primitives, the worklets may
execute simultaneously to the parent case, or execute while the
parent is suspended.
optionally, an array of worklets may be de¯ned for a particular com-
pensation primitive | when multiple worklets are de¯ned for a partic-
ular compensation primitive via the rules editor, they are launched
concurrently as a composite compensatory action when the exlet is
executed.
the selection and exception sub-services can be used in combina-
tion within particular case instances to achieve dynamic °exibility and
exception handling simultaneously.
6.exemplary study
film and television production is a multi-billion dollar industry. in
australia alone, there are over two thousand ¯lm and video production
services actively employing almost twenty thousand people (trewin,
2004). however, the industry is extremely competitive and has be-
come progressively global in its scope. even though the work processes
of the industry are highly creative and goal-oriented, organisations are
increasingly recognising the value of more conventional business man-
agement strategies, such as pais, to gain and maintain a competitive
edge (lee & holt, 2006; irving & rea, 2006).
that is not to say that any work°ow solution is able to be applied
across the board to support all aspects of a ¯lm production process.
but there are many aspects of the industry where meaningful bene¯ts
can be gained through the use of a work°ow solution to assist in the
management of a project, including:
²back-o±ce administrative and support processes;
²the allocation of resources to tasks;
²routing of ¯lm stock, documentation and other materials amongst
employees; and
²facilitating inter-team communication and goal-setting.this study will examine a process occurring in the post-production
phase and discuss the applicability of implementing a worklet-service-
based solution. the process originates from a cooperative project be-
tween the queensland university of technology (qut) and the aus-
tralian film, television, and radio school (aftrs) within the context
of qut's centre of excellence for creative industries and innovation .
rather than coming at the end of production (as the name might
imply), work within the post-production phase operates concurrently
with several other phases of production. tasks in this phase include
the merging of video and audio components (voice, sound e®ects, music
and so on) and editing to produce a coherent, ¯nal piece, and as such
includes tasks that are both acutely technical and highly creative. the
process, referred to as the master process, can be logically divided into
three phases:
²pre-edit: the pre-edit phase begins with the delivery of the
day's footage (`the rushes') to the post-production team. there
are two possible entry points into the process, one for each type
of media that may be used (¯lm and videotape). it may be
the case that both types of media are used for a particular set
of rushes, so in terms of the model's entry points, inputs may
arrive at both simultaneously. videotape does not require the
same degree of processing as ¯lm, but for both media types, a
low resolution copy is digitised and stored on computer ¯le to
be used as a guide for the remaining process. accompanying
the ¯lm and/or tape is the `rushes paperwork', a set of docu-
mentation which may include items such as an annotated script,
and video and audio reports. this documentation is regarded
as an important source of information about the footage, and
is thus made available throughout the post production process.
²edit: in the edit phase, the video and audio components are
handled separately. further, video editing is divided into low
and high resolution edits. low resolution editing is represented
by the o²ine task, which allows editing decisions to be made
and documented before the high resolution editing begins. the
result of the o²ine task is the edl (edit decision list). video
e®ects production takes place concurrently with the o²ine
task. when the o²ine task completes, the high-resolution
editing, along with the sound and music editing, can begin.
for ¯lm, the high resolution editing takes place in the film fin-
ishing task, where the original negative is spliced into pieces,
some of which are rejoined; for tape, it occurs in the online
task, where the video is rearranged using an editing suite and
recorded to a tape master. both take the edl output from the
low resolution edit and each performs the actions listed in the
respective edl on distribution quality media.²post-edit: after the edit phase, an edited, high resolution,
distribution quality ¯lm and/or tape, together with completed
visual e®ects and sound and music, is completed, and now must
be `¯nished' for distribution. the ¯nishing may be required for
any or all of the ¯lm, tape and disk mediums, which are output
in the form of a release print, master tape or release version
respectively.
the process description reveals some of the complicating factors that
come in to play when rendering this process to a particular modelling
framework. for instance, it contains constraints which are designed
to remove some tasks from the eventual process if certain preceding
tasks were not included in a particular con¯guration of the process.
for example, the removal of the prepare film for edit andfilm finish
tasks is required if the rushes were not received on ¯lm; similarly, the
online task will not be required if tape media was not received. in
addition, because there are two entry points, there are three possible
media combinations that may start a case instance (i.e. tape, ¯lm, or
both tape and ¯lm), and so a nominal model will require a number of
or splits and joins to accommodate the various combinations and the
tasks they entail.
a representation of the process in the yawl language shows com-
plications in the describing the process and its possible °ow paths via
a static model (figure 6). there are several or splits and joins; con-
ditionals are required to be embedded into each or split output arc
to determine whether they `¯re' or not. all are dependent simply on
which media formats have been supplied to the process. for example,
the ¯rst or split task controls whether one or both arcs ¯re (one for
tape, one for ¯lm); the or split preceding the online andfile finish
tasks has a similar function, and so on. thus in static representations
such as this, the control °ow logic is embedded into the business pro-
cess logic. as a result, it is not obvious from the model which path
may be taken during a particular instance.
with the °exibility mechanisms available through the worklet ser-
vice, the process can be modelled without much of the complexity,
particularly by negating the need for the or splits and joins. figure 7
shows the worklet-enabled process. immediately apparent is the fact
that, in this case, all of the or splits and joins have been removed
from the process model.
the ¯rst task in the process, prepareforedit , is worklet-enabled.
associated with this task is the selection rule tree shown in figure 8.
the rule tree shows that, if either tape or ¯lm has been supplied,
the corresponding rule will be satis¯ed and the service will launch the
appropriate worklet for that media. if the rushes have been delivered
on both ¯lm and tape media, node 2 will be last satis¯ed, resulting in
the launching of two discrete worklets, one for each medium (the two figure 6. static post production master process
(yawl language)
 
figure 7. post production master process (worklet-enabled)
worklets are shown in figure 9). note that the conditional expressions
for nodes 2 and 3 are identical in this tree, but their conclusions di®er
| node 3 will be tested if node 1 evaluates to false (i.e. there is no tape
media), while node 2 will be tested only if node 1 evaluates to true.
the worklet-enabled master task performs a similar service to pre-
pareforedit | it will launch a worklet to carry out the online process
if tape media is provided, and/or for the film finish process if ¯lm
media is provided.
the finalise task models the processing of `¯nishing' the output
for distribution. there are three possible sub-processes to perform:
tape ¯nish, disk ¯nish and release printing | each has a corresponding
worklet in the speci¯cation's repertoire. therefore, there are six possi-
ble worklet launch combinations, as speci¯ed in the selection rule tree
for the finalise task (figure 10). each worklet consists of one task,
corresponding to each of the three tasks at the post-edit end of the
original static process model. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 0 
true 
default 
1 
tapeshoot = true 
 
select pppreparetapeforedit 
  
3 
 
filmshoot = true 
 
select  pppreparefilmforedit 
 2 
filmshoot = true 
select pppreparetapeforedit, 
           pppreparefilmforedit 
 figure 8. selection rule tree for the prepareforedit task
 
 
 
 
 
 
figure 9. worklets pppreparefileforedit and pppre-
paretapeforedit
in summary, the worklet service allows a parent or master process
to be de¯ned without much of the explicit branching mechanisms nec-
essary in the control °ow of static models. as a result, the parent
process models are cleaner, easier to verify and maintain, and easier
for stakeholders to gain an understanding of the process logic. once the
parent process is worklet-enabled, it is able to access all the features of
the worklet paradigm, including support for exception handling. some
exceptions that may occur in a post production process include dam-
aged ¯lm or tape stock, equipment malfunctions and breakdowns, and
time and budget overruns, to name but a few. all of these exceptions 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 0 
true 
default 
1 
totape  = true 
 
select pptapefinish 
  
3 
 
tofilm = true 
 
select  ppfilmfinish 
 2 
tofilm = true 
select pptapefinish, 
           ppfilmfinish 
 
6 
todisk = true 
 
select ppdiskfinish 
 5 
todisk = true 
select ppdiskfinish, 
           ppfilmfinish 
 4 
todisk = true 
select ppdiskfinish, 
           pptapefinish, 
           ppfilmfinish 
 figure 10. selection rule tree for the finalise task
may be handled by adding an appropriate exlet to the speci¯cation's
repertoire.
7.conclusion
this chapter began by identifying key problems that describe the
fundamental limitations of current work°ow technologies with respect
to the rigidity enforced by the in°exible frameworks employed, and the
consequent di±culties in placing more dynamic, information intensive
processes within those frameworks. then, a description of ten prin-
ciples derived from activity theory that represent an interpretation
of its central themes applicable to understanding organisational work
practices was provided.
based on the derived principles of activity theory, the worklet ser-
vice was then conceptualised, implemented and validated. a primary
feature of the service is that it has been designed and implemented
as a discrete service, and so o®ers all of its bene¯ts to a wide range
of work°ow management systems, allowing them to fully `worklet-ise'
their otherwise static processes. the worklet service:
²keeps the parent model clean and relatively simple;²promotes the reuse of sub-processes in di®erent models;
²allows standard processes to be used as exception handling
compensation processes, and vice versa;
²maintains an extensible repertoire of actions that can be con-
structed during design and/or runtime and can be invoked as
required;
²allows a speci¯cation to implicitly build a history of executions,
providing for a learning system that can take the appropriate
actions for certain contexts automatically;
²maintains a repertoire of fully encapsulated, discrete worklets
that allow for easier veri¯cation and modi¯cation;
²allows a model to evolve without the need to stop and modify
the design of the whole speci¯cation when an exception occurs;
²by de-coupling the monolithic process model, models can be
built that vary from loosely to tightly de¯ned and so supports
late binding of processes; and
²allows a model to be considered from many levels of granularity.
there are a number of further research topic possibilities that arise
from this work, such as: deeper empirical studies comparing the worklet
approach to classic work°ow approaches and measuring the relative
bene¯ts of each; porting the worklet service to other work°ow systems
(for example, ibm websphere and/or oracle bpel); exploring the ad-
vantages of mixing di®erent modelling styles and approaches, leading to
recommendations of in what circumstances the various approaches are
best used; and stronger support for process mining analysis using both
the process logs generated by the service and the structure, content
and evolution of the various ripple-down rule sets of speci¯cations.
in summary, through a combination of the framework on which it is
built and the mechanisms available through both its selection and ex-
ception handling sub-services, the worklet service o®ers a wide-ranging
solution to the issues of °exibility and exception handling in process-
aware information systems. in fact, the bene¯ts o®ered through each
sub-service can be combined to deliver a far-reaching set of capabili-
ties that serve the needs of a wide variety of work environments and
processes.
references
van der aalst, w. (2001). exterminating the dynamic change bug: a
concrete approach to support work°ow change. information systems
frontiers ,3(3), 297{317.
van der aalst, w., aldred, l., dumas, m., & ter hofstede, a. (2004).
design and implementation of the yawl system. in a. persson, &
j. stirna (eds.) proceedings of the 16th international conference on
advanced information systems engineering (caise 04) , vol. 3084oflecture notes in computer science , (pp. 142{159). riga, latvia:
springer verlag.
van der aalst, w., & basten, t. (2002). inheritance of work°ows:
an approach to tackling problems related to change. theoretical
computer science ,270((1-2)), 125{203.
van der aalst, w., & berens, p. (2001). beyond work°ow management:
product-driven case handling. in s. ellis, t. rodden, & i. zigurs
(eds.) proceedings of the international acm siggroup confer-
ence on supporting group work , (pp. 42{51). new york: acm
press.
van der aalst, w., & van hee, k. (2004). work°ow management:
models, methods and systems . cambridge, massachusetts: the mit
press, new ed ed.
van der aalst, w., ter hofstede, a., kiepuszewski, b., & barros, a.
(2003). work°ow patterns. distributed and parallel databases ,
14(3), 5{51.
van der aalst, w., & ter hofstede, a. (2005). yawl: yet another
work°ow language. information systems ,30(4), 245{275.
van der aalst, w., weske, m., & grä unbauer, d. (2005). case handling:
a new paradigm for business process support. data & knowledge
engineering ,53(2), 129{162.
adams, m. (2007). facilitating dynamic flexibility and exception han-
dling for work°ows . phd thesis, queensland university of technol-
ogy.
adams, m., edmond, d., & ter hofstede, a. h. (2003). the application
of activity theory to dynamic work°ow adaptation issues. in pro-
ceedings of the 2003 paci¯c asia conference on information systems
(pacis 2003) , (pp. 1836{1852). adelaide, australia.
bardram, j. e. (1997). i love the system - i just don't use it! in
proceedings of the international acm siggroup conference on
supporting group work (group'97) , (pp. 251{260). phoenix, ari-
zona, usa: acm.
barthelmess, p., & wainer, j. (1995). work°ow systems: a few de¯ni-
tions and a few suggestions. in proceedings of the acm conference
on organizational computing systems (coocs'95) , (pp. 138{147).
milpitas, california, usa: acm.
berens, p. (2005). the flower case handling approach: beyond
work°ow managment , chap. 15, (pp. 363{395). in dumas et al.
(2005).
bider, i. (2005). masking °exibility behind rigidity: notes on how
much °exibility people are willing to cope with. in j. castro, &
e. teniente (eds.) proceedings of the caise'05 workshops , vol. 1,
(pp. 7{18). porto, portugal: feup edicoes.
b¿dker, s., & greenbaum, j. (1993). design of information systems:
things versus people. in e. green, j. owen, & d. pain (eds.)gendered by design?: information technology and o±ce systems ,
chap. 3, (pp. 53{63). london: taylor and francis.
borgida, a., & murata, t. (1999). tolerating exceptions in work°ows:
a uni¯ed framework for data and processes. in proceedings of the
international joint conference on work activities, coordination and
collaboration (wacc'99) , (pp. 59{68). san francisco, california,
usa: acm press.
casati, f. (1998). a discussion on approaches to handling exceptions
in work°ows. in proceedings of the cscw workshop on adaptive
work°ow systems . seattle, usa.
compton, p., & jansen, b. (1988). knowledge in context: a strategy
for expert system maintenance. in j.siekmann (ed.) proceedings of
the 2nd australian joint arti¯cial intelligence conference , vol. 406
oflecture notes in arti¯cial intelligence , (pp. 292{306). adelaide,
australia: springer-verlag.
cosa (2005). cosa bpm product description. http://www.
cosa-bpm.com/project/docs/cosa_bpm_5_productdescription_
eng.pdf . accessed 13 march, 2008.
drake, b., & beydoun, g. (2000). predicate logic-based incremental
knowledge acquisition. in p. compton, a. ho®mann, h. motoda, &
t. yamaguchi (eds.) proceedings of the sixth paci¯c international
knowledge acquisition workshop , (pp. 71{88). sydney, australia.
dumas, m., van der aalst, w., & ter hofstede, a. (eds.) (2005).
process-aware information systems: bridging people and software
through process technology . new york: wiley-interscience.
george®, m., & pyke, j. (2003). dynamic process orchestration. white
paper, sta®ware plc.
greiner, u., ramsch, j., heller, b., lä o²er, m., mä uller, r., & rahm, e.
(2004). adaptive guideline-based treatment work°ows with adapt-
°ow. in k. kaiser, s. miksch, & s. tu (eds.) proceedings of the
symposium on computerized guidelines and protocols (cgp 2004) ,
(pp. 113{117). prague: ios press.
hendriks-jansen, h. (1996). catching ourselves in the act : situated
activity, interactive emergence, evolution, and human thought . cam-
bridge, mass: mit press.
holt, a. w. (1997). organized activity and its support by computer .
kluwer academic publishers, dordrecht.
ibm (2005). ibm websphere mq work°ow: concepts and architec-
ture. http://publibfp.boulder.ibm.com/epubs/pdf/h1262857.
pdf. accessed 14 march, 2008.
irving, d. k., & rea, p. w. (2006). producing and directing the short
film and video . burlington, oxford, united kingdom: focal press,
3rd ed.joeris, g. (1999). de¯ning °exible work°ow execution behaviors.
in p. dadam, & m. reichert (eds.) enterprise-wide and cross-
enterprise work°ow management: concepts, systems, applications ,
vol. 24 of ceur workshop proceedings , (pp. 49{55). paderborn,
germany.
joeris, g., & herzog, o. (1998). managing evolving work°ow speci¯ca-
tions. in proceedings of the 3rd ifcis international conference on
cooperative information systems (coopis '98) , (pp. 310{319). new
york, new york, usa: ieee computer society.
kammer, p., bolcer, g., taylor, r., hitomi, a., & bergman, m. (2000).
techniques for supporting dynamic and adaptive work°ow. com-
puter supported cooperative work (cscw) ,9(3), 269{292.
kang, b. h., preston, p., & compton, p. (1998). simulated expert
evaluation of multiple classi¯cation ripple down rules. in proceed-
ings of the 11th workshop on knowledge acquisition, modeling and
management . ban®, alberta, canada.
klein, m., & dellarocas, c. (2000). a systematic repository of knowl-
edge about handling exceptions. ases working paper ases-wp-
2000-03 ases-wp-2000-03, massachusetts institute of technology,
cambridge, ma, united states.
kradolfer, m., & geppert, a. (1999). dynamic work°ow schema evo-
lution based on work°ow type versioning and work°ow migration. in
proceedings of the 1999 ifcis international conference on cooper-
ative information systems (coopis'99) , (pp. 104{114). edinburgh,
scotland: ieee computer society.
kuutti, k. (1996). activity theory as a potential framework for
human-computer interaction research , (pp. 17{44). in nardi
(1996).
lee, j. j., & holt, r. (2006). the producer's business handbook .
burlington, oxford, united kingdom: focal press, 2nd ed.
leontiev, a. (1974). the problem of activity in psychology. soviet
psychology ,13(2), 4{33.
leymann, f. (2006). work°ow-based coordination and cooperation in
a service world. in r. meersman, & z. tari (eds.) proceedings of the
14th international conference on cooperative information systems
(coopis'06) , vol. 4275 of lecture notes in computer science , (pp.
2{16). montpellier, france: springer-verlag.
manago, m. v., & kodrato®, y. (1987). noise and knowledge acquisi-
tion. in proceedings of the tenth international joint conference on
arti¯cial intelligence , vol. 1, (pp. 348{354). milano, italy: morgan
kaufmann.
zur muehlen, m. (2004). work°ow-based process controlling. foun-
dation, design, and implementation of work°ow-driven process in-
formation systems , vol. 6 of advances in information systems and
management science . berlin: logos.muller, r., greiner, u., & rahm, e. (2004). agentwork: a work°ow
system supporting rule-based work°ow adaptation. data & knowl-
edge engineering ,51(2), 223{256.
mumford, l. (1963). technics and civilization . harcourt brace jo-
vanovich, new york.
nardi, b. a. (1996). activity theory and human-computer interac-
tion, (pp. 7{16). in nardi (1996).
nardi, b. a. (ed.) (1996). context and consciousness: activity the-
ory and human-computer interaction . mit press, cambridge, mas-
sachusetts.
oberweis, a. (2005). person-to-application processes: work°ow man-
agement , chap. 2, (pp. 21{36). in dumas et al. (2005).
paci¯c knowledge systems (2003). products: rippledown, http:
//www.pks.com.au/products/validator.htm . accessed 23 april,
2002.
palmer, n. (2007). a survey of business process initiatives. http:
//wfmc.org/researchreports/survey_bpi.pdf . accessed 4 april,
2008.
pesic, m., & van der aalst, w. (2006). a declarative approach for °ex-
ible business processes. in j. eder, & s. dustdar (eds.) proceedings
of the first international workshop on dynamic process manage-
ment (dpm 2006) , vol. 4103 of lecture notes in computer science ,
(pp. 169{180). vienna, austria: springer-verlag, berlin, germany.
reichert, m., & dadam, p. (1997). a framework for dynamic changes
in work°ow management systems. in proceedings of the 8th inter-
national workshop on database and expert systems applications
(dexa 97) , (pp. 42{48). toulouse, france: ieee computer soci-
ety press.
reichert, m., dadam, p., & bauer, t. (2003). dealing with forward
and backward jumps in work°ow management systems. software and
systems modeling ,2(1), 37{58.
reichert, m., rinderle, s., kreher, u., & dadam, p. (2005). adaptive
process management with adept2. in proceedings of the 21st in-
ternational conference on data engineering (icde'05) , (pp. 1113{
1114). tokyo, japan: ieee computer society press.
rinderle, s., reichert, m., & dadam, p. (2004). correctness criteria for
dynamic changes in work°ow systems: a survey. data and knowledge
engineering ,50(1), 9{34.
rinderle, s., weber, b., reichert, m., & wild, w. (2005). integrating
process learning and process evolution a semantics based approach.
in w. van der aalst, b. benatallah, f. casati, & f. curbera (eds.)
proceedings of the 3rd international conference on business process
management (bpm'05) , vol. 3649 of lecture notes in computer sci-
ence, (pp. 252{267). nancy, france: springer verlag.russell, n., van der aalst, w., & ter hofstede, a. (2006). work°ow
exception patterns. in e. dubois, & k. pohl (eds.) proceedings of
the 18th international conference on advanced information systems
engineering (caise 2006) , (pp. 288{302). luxembourg: springer.
sap (2006). sap advanced work°ow techniques. https:
//www.sdn.sap.com/irj/servlet/prt/portal/prtroot/docs/
library/uuid/82d03e23-0a01-0010-b482-dccfe1c877c4 . ac-
cessed 17 march, 2008.
sche®er, t. (1996). algebraic foundation and improved methods of
induction of ripple down rules. in proceedings of the 2nd paci¯c
rim workshop on knowledge acquisition , (pp. 279{292). sydney,
australia.
stein, l. a. (1999). challenging the computational metaphor: impli-
cations for how we think. cybernetics and systems ,30(6).
tibco (2006). tibco iprocess suite whitepaper. http:
//www.staffware.com/resources/software/bpm/tibco_
iprocess_suite_whitepaper.pdf . accessed 13 march, 2008.
trewin, d. (2004). televison, ¯lm and video production in aus-
tralia (publication 8679.0). australian bureau of statistics http:
//www.ausstats.abs.gov.au/ausstats/subscriber.nsf/0/
14f1a528655e8486ca256ede00782780/file/86790_2002-03.pdf .
accessed 13 april, 2008.
turing, a. (1936). on computable numbers, with an application to
the entscheidungsproblem. proceedings of the london mathematical
society ,2(42), 230{265.
weber, b., wild, w., & breu, r. (2004). cbrflow: enabling adap-
tive work°ow management through conversational case-based rea-
soning. in p. funk, & p. a. gonz¶ alez calero (eds.) proceedings of
the 7th european conference for adavances in case based reason-
ing (eccbr'04) , vol. 3155 of lecture notes in computer science ,
(pp. 434{448). madrid, spain: springer.
work°ow management coalition (2002). introduction to work°ow.
http://www.wfmc.org/introduction_to_workflow.pdf . accessed
14 november 2004.
yan, j., yang, y., & raikundalla, g. (2004). towards incompletely
speci¯ed process support in swindew - a peer-to-peer based work-
°ow system. in w. shen, z. lin, j. barthµ es, & t. li (eds.) proceed-
ings of the 8th international conference on computer supported co-
operative work in design (cscwd 2004) , vol. 3168 of lecture notes
in computer science , (pp. 328{338). xiamen, china: springer.key terms
activity theory. a meta-model or framework used to describe, the-
orise and research organised human activities, originating from soviet
cultural-historical psychology in the 1920's.
exlet. an exception handling process, consisting of a number of ex-
ception handling primitives such as suspend workitem, remove case,
compensate, and so on, which de¯nes what action should be taken in
the event of an exception of a certain type and context.
process-aware information system (pais). a software system
that manages and executes operational processes involving people, ap-
plications, and/or information sources on the basis of process models
(dumas et al., 2005, 7).
ripple-down rules (rdr). a hierarchical, extensible set of rules
of the form \if condition then conclusion ", together with cornerstone
case data, conceptually arranged in a binary tree structure.
service-oriented architecture. a software architecture consisting
of a number of discrete (usually web-based) services (software compo-
nents that are accessed or communicate via standard network proto-
cols), that link together as required in order to achieve some task.
worklet. a (usually) small, self-contained, complete process de¯ni-
tion which is designed to be invoked as a substitute for one speci¯c task
in a larger, composite process. each worklet is a complete extended
work°ow net (ewf-net) compliant with de¯nition 1 of the yawl se-
mantics. a set of zero or more worklets may form the repertoire of a
task.