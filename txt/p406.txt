int. j. business process integration and management, vol. x, no. y, xxxx 1
an soa-based architecture framework
wil m.p . van der aalst
department of mathematics and computer science,
eindhoven university of technology,p.o. box 513, eindhoven 5600 mb, the netherlandse-mail: w.m.p.v.d.aalst@tue.nl
michael beisiegel
ibm,somers, new york, usae-mail: mbgl@us.ibm.com
kees m. van hee
department of mathematics and computer science,eindhoven university of technology,p.o. box 513, eindhoven 5600 mb, the netherlandse-mail: k.m.v.hee@tue.nl
dieter könig
ibm böblingen laboratory,schönaicher strasse 220, böblingen 71032, germanye-mail: dieterkoenig@de.ibm.com
christian stahl *
department of mathematics and computer science,
eindhoven university of technology,p.o. box 513, eindhoven 5600 mb, the netherlandse-mail: c.stahl@tue.nl*corresponding author
abstract: we present an service-oriented architecture (soa)-based architecture framework.
the architecture framework is designed to be close to industry standards, especially to the service
componentarchitecture (sca). the framework is language independent and the building blocks ofeach system, activities and data, are ﬁrst class citizens. we present a meta model of the architecture
framework and discuss its concepts in detail. through the framework, concepts of an soa suchas wiring, correlation and instantiation can be clariﬁed.
keywords: service-oriented architecture; soa; architecture framework; service component
architecture; sca
reference to this paper should be made as follows: van der aalst, w.m.p., beisiegel, m.,
van hee, k.m., könig, d. and stahl, c. (xxxx) ‘a soa-based architecture framework’,int. j. business process integration and management , v ol. x, no. y , pp.xxx–xxx.
biographical notes: wil m.p. van der aalst is a full professor of information systems at
the technische universiteit eindhoven (tu/e) having a position in both the department ofmathematics and computer science and the department of technology management. he isalso an adjunct professor at queensland university of technology (qut) working within thebpm group. his research interests include workﬂow management, process mining, petri nets,business process management, process modelling and process analysis. he has published morethan 60 journal papers, 10 books (as author or editor), 150 refereed conference publications and20 book chapters. he has been a co-chair of many conferences and is an editor/member of theeditorial board of several journals.
copyright © xxxx inderscience enterprises ltd.2 w.m.p . van der aalst et al.
michael beisiegel is a distinguished engineer with ibm software group’s strategy and
technology division in somers, ny . he is responsible for the service component architecture
(sca) programming model development. he has worked on systems management products forz/os, visualage for smalltalk cics and ims connection, visualage for java enterprise accessbuilder (eab), common connector framework (ccf) for component broker and websphere,
websphere studio application developer integration edition, websphere process server sca
runtime. he was ibm’s expert on the j2ee connector architecture jsr that is modelled afterccf. currently, he is working with the open soa collaboration (http://www.osoa.org) onthe standardisation of sca. he joined ibm in 1989 and began working for the 390 softwaredevelopment organisations at the ibm laboratory in böblingen, germany. later, he took anassignment (1998–2000) working on java-based integration tools and connector technology atthe ibm toronto laboratory in canada. he joined ibm, us in 2000. he received a masters(dipl. ing.) in electrical engineering from the university of kaiserslautern, germany.
kees m. van hee received a phd in operations research from the technische universiteit
eindhoven (tu/e). from 1994 till 2004, he was managing partner of bakkenist managementconsultants and deloitte consultancy. during 1991–1992, he was a visiting professor at theuniversity of waterloo, ontario. from 1984 till 1994 and again since 2004, he is professorof computer science at tu/e. he published papers and books on the following topics:markov decision processes, applications of queuing theory, decision support systems, formalspeciﬁcation methods and tools, petri nets, database systems and workﬂow management systems.
dieter könig is a senior technical staff member with ibm software group’s laboratory in
böblingen and architect for workﬂow products. he joined the laboratory in 1988. he has workedon resource measurement facility for z/os, websphere mq workﬂow and websphere processserver. he is a member of the oasis ws-bpel technical committee, which is working onan industry standard-based on the speciﬁcation of the web services business process executionlanguage (ws-bpel). he has published many papers and has given talks at conferences about
web services and workﬂow technology and is co-author of two books about web services.
he received a masters (dipl. inform.) in computer science from the university of bonn, germany.
christian stahl studied computer science at humboldt-universität zu berlin, germany.
he received a masters in 2004. since then, he is working as a research assistant in the groupof wolfgang reisig in berlin, and since 2006, also in the group of kees m. van hee and
wil m.p. van der aalst in eindhoven. his research interests include process modelling, process
analysis, formal methods, in particular petri nets and model checking.
1 introduction
the concept of modularisation can be used to master
the complexity of large (software) systems. modules havedifferent names like ‘function’, ‘class’ or ‘component’.
the principle of compositionality is one of the most desirable
requirements for modular systems: a collection of modulesthat are properly connected to each other should behave asone module itself. often, we require more: if we have veriﬁedthat all modules of a system satisfy some property and theyare connected properly, then the system as a whole shouldsatisfy the same property. in the rest of this paper, we willuse the term component for a module.
at a high level, a system is described by its components
and their relationships. such a description is the architecture
of a system. there are several languages to deﬁne componentsand to glue them together. there are also differentarchitectural styles . in this paper, we concentrate on a
style based on the service-oriented architecture (soa)(high et al., 2005). soa can be seen as one of the keytechnologies to enable ﬂexibility and reduce complexityin software systems. today, soa is a set of ideas forarchitectural design and there are some proposals for soaframeworks, including a concrete architectural language: theservice component architecture (sca) (beisiegel et al.,2007) and software tools to design systems in the soa style.in this paper, we present an soa-based architecture
framework by means of a meta model and discuss its concepts
in detail. the architecture framework consists of three models
each representing a particular view.
the component model presents an abstract view on the
components of the system and shows which componentsinteract with each other by message exchange.
every component contains a process, which is a set of
activities. the process model provides a view on these
activities and their relation to the data entities. an activitycan access data entities that are located within and outsideits component by using the concepts of method call andmessage exchange, respectively. we further show that ourprocess model is generic and thus it can be specialisedby process models such as ws-bpel (alves et al., 2007)or petri nets.
the data model is a view on data entities and their
relationships. the architecture framework allows for internalrelationships between data entities (i.e. within a component)and external relationships between data entities (i.e. acrossthe borders of components). these two different relationshipsintroduce hierarchy in the data model.
besides these three views, the architecture framework also
covers important concepts such as component instantiation
andmessage correlation (i.e. deliver messages to their correct
component instance).an soa-based architecture framework 3
to enable the veriﬁcation of systems on the level of
the architecture, we collect a number of constraints forthe architecture framework and specify them using theobject constraint language (ocl) (object managementgroup, 2003). these constraints can be implemented andautomatically checked during the system design.
our architecture framework should be close to industrial
standards, especially sca. therefore, we compare theconcepts of our architecture framework with those of scaand show that it extends sca.
the outline of this paper is as follows. in section 2, we
sketch the practice of component-based software systems.
we also introduce software architectures, in particular, the
soa. our main contribution, the architecture frameworkincluding component, process and data model, is presentedin section 3. in section 4, we compare our proposedframework with sca. finally, section 5 summarises thispaper, discusses related work and describes how our workwill be continued.
2 context
2.1 the component-based world
the idea to use components in software development was
already published by mcilroy (1968). in that paper, mcilroypresented his idea of mass-produced software components.even though much progress has been booked since then,today there is still no universally accepted deﬁnition ofwhat a component is. most cited is the deﬁnition ofszyperski (1998):
“a component is a unit of composition
with contractually speciﬁed interfaces andexplicit context dependencies only. a softwarecomponent can be deployed independently andis subject to composition by third parties.”
as there is no consensus about what a component is, there
is also no agreement on the granularity of components.
a component can be small grained like a graphical object
in a user interface or coarse grained like a debtors register in
an enterprise resource planning (erp) system.
components can be classiﬁed based on their
functionality : there are application-speciﬁc and generic
components. an sap component is an example of anapplication-speciﬁc component whereas a workﬂow engineis a generic component. another classiﬁcation of componentsis based on the conﬁguration of their parameters. in a
predeﬁned component, the version is hard-coded and the
parameters are selected from an option list. an inventorycontrol rule like fifo or lifo would be an example.in contrast, the parameters in a programmable component
are database schemes, process models or business rules.
components may specify non-functional properties.
non-functional properties are also named quality of service(qos). examples are response time and the usage ofresources.
a component may have relevance from a business
perspective (which is the primary focus of soa) or froman it perspective (as in traditional software systems).a system that is developed by composing components is
acomponent-based system . component-based systems will
e v o l v ei na n organic way. there may never be a total renewal
or an upgrade of the overall system. instead, componentswill be replaced periodically by better ones, for example,because the performance was not good enough anymore.
adding new functionality to the system will also be realised
by either adding new components or replacing componentsby better ones. this will reduce the total cost of ownershipof component-based systems.
customers will use component-based systems, because
component-based design has two major beneﬁts whenthe component-based system fulﬁls the compositionalityprinciple. firstly, it structures the design and the developmentof systems and thus reduces the amount of effort neededto verify and maintain systems. secondly, the reuse ofcomponents reduces the development effort and thus timeand costs (bouyssounouse and sifakis, 2005).
in the component-based world, the architecture is of
crucial importance. firstly, the architecture can be used as ablue print for the development of a component. for example,a component can be seen as a black-box (i.e. only the interfaceis visible) or as a white-box (i.e. the internal details ofthe component are visible, too). as the architecture supportssuch different views on a component, it may help to developsoftware in a more structured way. secondly, an architecturefacilitates the work distribution in the software developmentprocess: if the interfaces are speciﬁed, different componentscan be developed independent of each other.
2.2 architecture frameworks
let us now shift our focus from components andcomponent-based systems to software architectures . we start
with a deﬁnition of software architecture in general andintroduce then the soa.
2.2.1 software architectures
just like for the term ‘component’, everyone knows roughlywhat a software architecture is, but there is also nouniversally accepted deﬁnition. a modern deﬁnition ofsoftware architecture is the one of bass et al. (2003):
“the software architecture of a program or
computing system is the structure or structuresof the system, which comprise softwareelements, the externally visible properties ofthose elements and the relationships amongthem.”
referring to this deﬁnition, an architecture shows the
elements of the system. in case of a component-based system,it shows the components and their relationships. we restrictus to ‘the structure of the system’ and we deﬁne this as aset of views . a view is a model of a part or an aspect of a
system. views should be consistent ; that is, no view should
contradict another view on the system. furthermore, viewsshould also be complete . that means, every property of the
system should be modelled by at least one view.
based on these facts, we elaborate the deﬁnition of
a software architecture to the following which is usedthroughout this paper:4 w.m.p . van der aalst et al.
“an architecture of a system is a set of
descriptions that present different views ofthe system. these views should be consistentand complete. each view models a setof components of the system, one ormore functions of each component, and therelationships between these components.”
for example, a view could show a data model
of some components and the inheritance relationshipbetween the components. a speciﬁcation to organiseand develop a software architecture in a speciﬁc styleis an architecture framework . some examples for
software architecture frameworks are uml, corba, koala(ommering et al., 2000), sensoria reference modellinglanguage (fiadeiro et al., 2006) and sca (beisiegel et al.,2007) to name a few. later, in section 4.1, we will give ashort introduction to sca.
2.2.2 service-oriented architecture
one of today’s most popular architecture frameworks isa soa. soa is seen as one of the key technologies toenable ﬂexibility and reduce complexity in software systems(high et al., 2005). it follows the paradigm to explicitlyseparate an implementation from its interface. such an
interface is well-deﬁned ; that is, it is based on standards
such as the web service description language (wsdl)(christensen et al., 2001). implementation and interfacetogether form a component. in a soa, a component isreferred to a service , but we prefer to use the term
component. components are independent of applications andthe computing platforms on which they run. componentsin a soa can be connected without having knowledgeof their technical details; they are loosely coupled .t o
connect components during runtime, soa supports dynamic
binding . for the message exchange between components,
standardised communication protocols are used. further, allthe standards, which are used in a soa, are extensible ,
meaning they are not limited to current standards andtechnologies.
soa distinguishes three different roles of components:
component provider ,component consumer and component
registry . it postulates a general protocol for interaction.
a component provider registers at the component registry
by submitting information about how to interact withits component. the component registry manages suchinformation about all registered component providers andallows a component consumer to ﬁnd an adequate componentprovider. then, the component of the provider and thecomponent of the consumer may bind and start interaction.
a component has two kinds of interfaces. buyinterfaces
specify which services are required by the component.sell interfaces specify which services are provided by the
component. so, in terms of the component roles, in a soa,a component plays the consumer’s role at the buy interfaces,and at the sell interfaces, it plays the provider’s role.
3 a soa-based architecture framework
in this section, we present a meta model of our architectureframework. we introduce its concepts including thethree views, component model, process model and data
model.
3.1 component model
figure 1 shows the complete meta model of our architectureframework. in the following, we concentrate on thecomponent model; that is, we have a detailed look at theconcepts of components, the interface concept and the wiringof components.
the basic concept of the architecture framework is
acomponent . we distinguish atomic components and
composite components . an atomic component consists of a
process , which is a set of activities (cis the name of the
relationship between the entities ‘atomic component’ and‘process’ and kbetween ‘process’ and ‘activity’ in figure 1),
zero or one composite data entities (relationship a) and
methods (relationship b). a composite component, however,
describes a hierarchical relationship between components.it is a container for components; that is, it may containatomic components and other composite components(relationship h).
each component has one or more interfaces (sometimes
called port) with its environment (relationship g).
an interface is either a buyor a sellinterface and consists of
a set of operations (relationship f). an operation describes a
message exchange between two participants. however, it canbe used by any number of components. an operation followsag i v e n operation type (relationship u) which describes
a message exchange pattern between the participants.
we distinguish the four operation types presented in thewsdl 1.1 speciﬁcation (christensen et al., 2001): one-way ,
request-response , solicit-response and notiﬁcation .
in general, an operation type consists of zero or oneinput and/or zero or one output messages and an optionalfault message. each message has a message type .
as can be seen from figure 1, the operation type of
one-way and notiﬁcation has an input and an outputmessage, respectively. operation types solicit-response andrequest-response deﬁne an input message, an output messageand optionally a fault message. both operation types differin their message order. in case of a solicit-response, thecomponent ﬁrst sends a message and then receives amessage whereas in case of a request-response it is theother way around. in practice, operation types one-wayand request-response are predominantly used andsolicit-response and notiﬁcation are less relevant.
an activity may exchange messages through one or more
operations (relationship j) with other components. it may
also access some of the (atomic) data entities of its atomiccomponent by means of method calls (relationship call).
these method calls may change the value of the data entities.
a more detailed look at processes and data entities is
presented in sections 3.2 and 3.3, respectively.
besides wrapping components (relationship h), a
composite component also deﬁnes one or more wires
(relationship i). in general, a wire connects interfaces of
components. more precisely, a wire connects two operationsdepicted by relationships dand e. these two operations have
either the same operation type or they have complementingoperation types, for example, one-way and notiﬁcation.an soa-based architecture framework 5
figure 1 meta model of the proposed architecture framework in uml notation
component interface operation
operation
typewire
vertical
wirehorizontal
wirecomposite
componentatomic
component
activity0..1*
111* *11 1* *
*
1*
message typefault out
0..1 1**one-waysolicit-
responsenotificationrequest-
response
in
1*
in
1*
out
1*
fault
0..1*
in
1*
out
1*df g
i
bj
uh1..
process
1
*
*1
ka*1
e
composite
data entity
atomic
data entitydata
relationship1
*
attribute typemessage * *
**1
1*10..1
f
n
o
p
qrs1
1*
*
reference
data entitysource
data entity1*tinternal data
relationshipexternal data
relationshipmethod1
*c
case
activitybase
activitystart
activity
base
methodcase
methodcase
entitybase
entity
*** **1 1 call
call
call
accessaccess * **0..1
sphere1
l
**
m
logicbuy
interfacesell
interface
wiring two operations with the same operation type can
be seen as a reference . the operation of a component is
propagated to the enclosing composite component. such awire is therefore called a vertical wire . it always connects
an operation of a component by its direct parent operation.in contrast, wiring two operations with complementingoperation types shows the connection of two components.
we call such a wire a horizontal wire . a wire represents
only an abstract view on the communication of a component.it only shows the invocation dependencies of a componentand there can be any number of calls along a wire. figure 2illustrates the different wires.
figure 2 component model of a bank transfer: component
transfer contains two components processing
(receives the customer’s bank transfer) and calculator
(calculates the bank transfer)
i3 i1transferprocessing
w1i2calculator
i4w2
note : it deﬁnes a vertical wire w1and a horizontal wire w2depicted by a
solid line. interfaces i1,…, i4are depicted by a dashed frame. a box
visualises an operation. its operation type is depicted by one or twoarcs inside the box. interface i
1and i2have an operation with
operation type one-way, i3request-response and i4solicit-response.
interface i3is a buy interface. all other interfaces are sell interfaces.
most of the information about wiring operations cannot
be derived from the meta model in figure 1. later, insection 3.4, we will therefore deﬁne the wiring characteristicsusing ocl.3.2 process model
let us now shift our attention from components to processes.first of all, we clarify the relation between process anddata entities and we introduce the two concepts an activitycan access to a data entity. subsequently, the concept ofinstantiation is explained. instantiation makes it necessaryto deliver a message to a concrete component instance.
therefore, we develop a concept of message correlation.
finally, we introduce with ws-bpel and petri nets twospecialisations of our process model.
3.2.1 activities and data entities
a process contains a set of activities (relationship kin
figure 1). every activity consists of zero or more methodcalls and some additional logic (relationships call and m,
respectively). methods are used to read and write the value ofdata elements. logic controls the method calls and evaluatestheir return values. logic can be speciﬁed by functions andtheir signatures. the construction of the logic is the workof programmers after the software architect has designedthe architecture.
the sphere of an activity is deﬁned as the set of data entities
this activity can access using a method call (relationshipsphere ). clearly, the sphere only contains data entities that
are deﬁned in the same atomic component as the activity.in our architecture framework, method calls are restricted toactivities. as a consequence, no data entity can have accessto another data entity. methods and activities are deﬁned inthe same component and activities can only call methodswhich are deﬁned in that component. a method can be usedby several activities. therefore, it is deﬁned at thecomponent level.6 w.m.p . van der aalst et al.
the architecture framework also supports a second
mechanism which is mainly used to access data outside anatomic component. instead of calling a method directly, anactivity sends a message to an operation (relationship j) that
passes it to another activity which contains the respective dataentity in its sphere.
3.2.2 instantiation
one of the most important concepts of an architectureframework is instantiation. in our architecture framework,components can be instantiated multiple times (not shownin figure 1). for the purpose of instantiation, atomiccomponents distinguish between case activities and case
entities on the one hand and base activities and base entities
on the other hand (cf. figure 1). the set of case andbase activities is also called case process and base process ,
respectively. to understand the difference between case andbase, we need to consider the lifecycle of a component.
once an (atomic) component is initialised, its base process
and its base entities are initialised, too. this initialisation canbe seen as the instantiation of the base process. afterwards,the component can be instantiated. to create a case; that
is, a new instance, a start activity (cf. figure 1) is used.
we distinguish two possibilities to create a case, depending
on the start activity being a base or a case activity. a basestart activity can create any number of cases. every caseis identiﬁed by a case id . a case start activity, in contrast,
needs to be triggered by the component’s environment.for this purpose, an atomic component has to be invokedvia its interface. a message is received by the start activity,which then creates a case. a process may have more than onestart activity, but no process may have both a base and a casestart activity. this fact will be speciﬁed with the help of anocl constraint in section 3.4. the instantiation implies thecreation of case activities and case entities which belong toexactly one case. their lifecycle is restricted to its respectivecase. when a case has been ﬁnished, it can be destroyed.
the lifecycle of base activities and base entities, in contrast,
only ends once the component is deactivated.
base activities and entities are independent of a speciﬁc
case. a base activity may create cases and may accessbase entities within its sphere. a case activity, however,may access case and base entities as shown in figure 1.it may also trigger base activities. in contrast, a base activitycan neither access case entities nor trigger case activities.on this account, a base entity can be seen as a conﬁgurationparameter. base activities, however, are typically used formonitoring and conﬁguration of a component.
3.2.3 message correlation
in a component interaction, several cases of the componentsmay be involved. with it, the problem arises how a messagecan be delivered to the correct case of a component.
therefore, our architecture framework provides the concept
ofmessage correlation , which is known from ws-bpel, for
instance. every case is identiﬁed by its case id. in ws-bpel,a case id is called correlation property . typical examples
of correlation properties are customer numbers, order idsand invoice numbers. a message can be delivered to thecorrect case if the case id can be either determined fromthe content of the message or it is an explicit part of the
message. we restrict ourselves to interaction between caseprocesses. the differences, when base processes are alsoinvolved in the interaction, are subject of (van der aalstet al., 2007). before we introduce our concept of messagecorrelation, we present possible scenarios of componentinteraction to demonstrate the requirements of messagecorrelation.
in an interaction between two components sand r, there
is one component, say s, that starts the interaction. there are
two possibilities for sto start the interaction with r.scan
either create a case of ror it can ﬁnd a case of r. a case
can be found if shas a reference (i.e. the case id) to a case
ofr(e.g. from a third party) or vice versa. another possibility
to ﬁnd a case of ris to decide from the message content
whether there exists a case of rthat can handle the request.
this criterion either speciﬁes requirements of sthat have to
be fulﬁled by ror it contains information that have to fulﬁl
the requirements of at least one case of r. obviously, if s
sends a criterion, there might be no matching case in ror
there are several cases that can handle the request sent by s.
if several cases match, one case has to be chosen, for examplenon-deterministically.
now, we deﬁne the term correlation . correlation
of a case cisﬁrstly the set of cases to which c
knows their respective case id and secondly the set ofcomponents to which csent its case id . a correlation
of all cases spans a graph where each node is a case.
this graph has two kinds of directed arcs: reference
arcs and send arcs . let c
1and c2be two cases.
a reference arc is drawn from case c1to case c2ifc1knows
the case id of c2. a send arc, in contrast, is drawn from
case c1to case c2ifc1sent its case id to component c2and
the message was delivered to c2. in the latter case, c1has
only knowledge about component c2and not about case c2.
we call the resulting graph a correlation set .
in our concept of message correlation, we formalise a
message format by a six tuple that consists of the sender’s
address, the receiver’s address, the sender’s case id, thereceiver’s case id, the correlation information (i.e. thecriterion used to decide whether a message matches a case)and ﬁnally, the message content. addresses and messagecontent are mandatory whereas case ids and correlationinformation are optional.
3.2.4 example process models
our proposed architecture framework in figure 1 is highlygeneric and thus it is easy to ﬁt in speciﬁc language proposals.in the following, we demonstrate that we can easily linktwo example process models, ws-bpel and petri nets, intoour architecture framework. these example process modelsspecialise the process model in figure 1.
the web services business process execution language
(ws-bpel) (alves et al., 2007) is a widely used languagefor describing the behaviour of business processes based onweb services. for the speciﬁcation of a business process,
ws-bpel provides activities and distinguishes between
basic and structured activities. a basic activity can
communicate with other ws-bpel processes by messageexchange, for instance. a structured activity deﬁnes a causalan soa-based architecture framework 7
order on the basic activities and can be nested in another
structured activity. for the sake of simplicity, we restrictour view on ws-bpel to activities and do not go intothe details of ws-bpel’s advanced concepts like fault andcompensation handling.
the meta model in uml notation for this restricted
part of ws-bpel is depicted in figure 3 (activitiesthrow, rethrow, compensate, compensatescope, validateand extensionactivity are not shown in figure 3). therelation between entities activity and structured activity
is most relevant for our architecture: every ws-bpelactivity can be contained in a structured activity andevery structured activity can contain one or more activities.entity ‘activity’ in figure 1 coincides with a ws-bpelactivity. thus, ws-bpel can be easily linked intoour framework. this is shown by connecting entity‘activity’ with the already known entities ‘process’ and‘atomic component’ (cf. figure 1). a ‘data entity’(not shown in figure 3) corresponds to a ws-bpelvariable. if ws-bpel is used for describing the processmodel for a component, then this process also implicitlydescribes the data model through its ws-bpel variabledeﬁnitions. ws-bpel does not distinguish base and case;that is, ws-bpel activities, variables and also ws-bpel’sadvanced concepts like fault and compensation handlingalways belong to exactly one case (i.e. to a process instance).
the concept of start activities is also supported in ws-bpel.
activities ‘receive’and ‘pick’can be used to create an instance
of a bpel process if the attribute createinstance is set to yes.
in our framework, every activity can be a start activity. so,we have to add this fact by a constraint. our concept of logiccan be mapped to ws-bpel, too. it is possible to specifyxpath expressions in ws-bpel and there exists extensionsof ws-bpel that allow, for instance, the integration of javacode into the ws-bpel code (blow et al., 2004).
figure 3 meta model for ws-bpel activities
activity
basic
activitystructured
activity
pick
while ifscope sequence flow receive invoke reply assign
wait empty exit*
0..11..1
e
*atomic
component
process1
1c
1l
m0..1start
activity
logic
repeatuntil foreach
the formalism of petri nets has been proven to be an adequate
model for business processes (e.g. van der aalst, 1998).
a petri net (see e.g. (reisig, 1985) for a formal deﬁnition) is a
bipartite graph. it consists of two different nodes, places and
transitions and (directed) arcs. an arc connects either a place
and a transition (input arc) or a transition and a place (outputarc). places can contain (black) tokens which represent adata value. we consider coloured petri nets (cpns) (jensen,1992), an extension of usual petri nets. in a cpn, tokens
have a value (i.e. a colour). that way, ‘real’ data values canbe modelled.
the petri net meta model in uml notation is presented
in figure 4. in the meta model, input arcs and output arcsare distinguished. like ws-bpel, petri nets can be easilylinked into our architecture framework. entity petri net and
entity transition coincide with entities ‘process’and ‘activity’
in figure 1, respectively. a start activity can also be modelledby a petri net transition. more precisely, the transitionhas to generate a new case id. entity ‘logic’ in figure 1coincides with entity label . a label is either a transition guard
(i.e. a boolean expression) or an (arc) inscription. a dataelement can be modelled by a place and the data value by atoken on this place. if we think of a petri net as a model for thebase and the case process, different cases can be expressed bydifferent colours, where each colour represents exactly onecase id, for instance.
figure 4 meta model for petri nets
activity
= transition1
k
*atomic
component
process
= petri net1
1c
place arc
input arc output arc11 11
** **
sourcesourcetarget
target1
l0..1start
activity1
1
* *
logic
= labelm
mmaabb
guard inscription*1
3.3 data model
many architects consider only the information architecture
of a system (i.e. the database schema) when they use theterm architecture. the information architecture is actuallyadata model . it is a view on data entities and their
relationships. the information architecture is very important,because it facilitates the structuring and organising of dataentities. often, architects start the system design withthe development of the information architecture. in thefollowing, we introduce the general concepts of the datamodel, in particular, its hierarchy concept.
the starting point of the data model is again an atomic
component. entity composite data entity in figure 1 is an
er-model. a composite data entity is a set of atomic data
entities (relationship fin figure 1) where every atomic
data entity consists of a set of attributes (relationship p).
relationship qshows that every attribute has a type. atomic
data entities can be accessed by activities (relationshipsphere ) or exchanged by messages (relationship r).
the data model allows for relationships between atomic
data entities. entity data relationship illustrates this fact.
two atomic data entities can be related (relationships8 w.m.p . van der aalst et al.
nand o). we distinguish between internal data relationship
and external data relationship . an internal data relationship
relates two atomic data entities within a composite dataentity. to provide a relationship between two atomic dataentities located in different composite data entities and thusin different atomic components, the meta model distinguishesbetween source data entity and reference data entity .
a reference data entity is a reference to a source data entity.
for every source data entity, there can be any numberof references (relationship t). that way, it is possible to
deﬁne a source data entity in one composite data entity(i.e. in an atomic component) and to have references (with thehelp of reference data entities) in other atomic components.
a reference data entity and its corresponding source data
entity are related by an external data relationship. theseconstraints are speciﬁed in section 3.4 using ocl.
the use of reference data entities introduces hierarchy in
the data model. we distinguish two different views on the datamodel. the ﬁrst and detailed view visualises the relationshipof all atomic entities in a composite entity. on one hand,it shows the internal data relationships between atomic dataentities, that means, how entities within an atomic componentare connected. on the other hand, this view also presents theexternal data relationships; that is, for each reference dataentity, its source data entity (relationship tin figure 1) is
depicted. relationship tshows how an atomic component
is related on the data level to other atomic components byhelp of reference data entities. the second and abstract view,however, is restricted to the external data relationship only.
this hierarchy concept is, in fact, similar to the concept of
atomic and composite components. as an example, a datamodel of two atomic components is shown in figure 5. it ispossible to have more levels of hierarchy by having a deeperhierarchy of (composite) components.
figure 5 two levels of hierarchy in the data model: (a) data
model – concrete level and (b) data model – abstractlevel
c’b
d d’b’
(a) (b)c’b
dd ’b’ a e
f
note : a solid frame depicts an atomic component. inside this frame, the
composite data entity is shown. boxes a–fdepict atomic data
entities. solid boxes and dashed boxes visualise source data entities(e.g. b) and reference data entities (e.g. b
/prime), respectively. undirected
solid arcs connecting two atomic data entities model an internal datarelationship between these entities (e.g. aand b,d
/primeand e). in
contrast, dashed arcs that cross the border of an atomic componentdepict external data relationships and thus which reference data entityis related to which source data entity. examples are band b
/prime,dand
d/prime, and also c/primewith a source data entity not depicted in figure 5(a).
the detailed view is shown in figure 5(a). all atomic data entities
and their internal and external data relationships are visible. theabstract view is shown in figure 5(b). only the three reference dataentities, the two corresponding source data entities and their externaldata relationships are visible.now, we have a look at the relation between internal and
external data relationship on one hand and method call andmessage exchange on the other hand. this is also a relationbetween data model and process model. from the detailsgiven in section 3.2, it is known that activities can changethe value of data elements by method call. an activity has,however, only access to a restricted set of data elements,namely, to the data elements within its sphere (cf. relationshipsphere in figure 1). in the data model, a method call is
reﬂected by an internal data relationship between two atomicdata entities. external data relationships, in contrast, reﬂectmessage exchange between activities. this is deﬁned by anocl constraint in section 3.4.
3.4 constraints
the meta model in figure 1 is in some sense quite general,
because speciﬁc constraints cannot be expressed in uml.
therefore, it is possible to create errors during the design
of the system. however, constraints of uml models can bespeciﬁed using the ocl (object management group, 2003).
they can be implemented in a computer-aided software
engineering (case) tool which can be used to check thesystem at design time. thus, the architect can be preventedfrom creating such errors.
in the following, we present several constraints that
help to formalise concepts like wiring or the relationshipsbetween entities. due to the page limit, we only specifyone constraint as an ocl invariant and describe all otherconstraints informally. for a complete overview of all theseconstraints speciﬁed in ocl, we refer to van der aalst et al.(2007). ocl keywords are depicted in bold font. for theparameters used, we refer to the relationships in figure 1.
1 two atomic data entities, which are related by an
external data relation, are located in different atomiccomponents and one of them is a source data entityand the other one its reference data entity:
context x: external data relationship inv:
x.n.f /negationslash=x.o.f and
((x.n.oclistypeof (reference data entity )and
x.o.oclistypeof (source data entity )and x.n.t=x.o)
or(x.n.oclistypeof (source data entity )and
x.o.oclistypeof (reference data entity )and
x.o.t=x.n))
the keyword invmeans that this ocl expression is
an ocl invariant. this invariant is introduced for thecontext of an ‘external data relationship’. informallyspoken, it speciﬁes that an external data relationshipbetween two data entities only exists if these entitiesare located in different composite data entities and thusin different atomic components. furthermore, one of theentities has to be a source data entity and the otherentity, one of its reference data entities. the second lineof this invariant speciﬁes that both atomic data entitiesare located in different composite data entities.
the remaining lines specify a disjunction. either x.nis
a reference data entity and x.ois a source data entity
(lines three and four) or vice versa (lines ﬁve and six).
to check the type of an atomic data entity, we use ocl’san soa-based architecture framework 9
oclistypeof operator. x.n.t=x.othen speciﬁes that
the reference data entity x.nhas to be a reference of the
source data entity x.o.
2 two atomic data entities which are related by
an internal data relation are located in the sameatomic component.
3 external data relationship means message exchange.4 there is no process having a base start activity and
a case start activity.
5 a horizontal wire connects two components within an
enclosing component.
6 a vertical wire connects a component with its
enclosing component.
7 a vertical wire connects two operations with the same
operation type.
8 a horizontal wire connects two operations with
matching operation types.
in conclusion, these constraints can be merely seen as
examples. once they are implemented, they can beautomatically checked during the design phase of the system.
at this level of design, it is faster and cheaper to ﬁx errors
than in later design phases. nevertheless, constraints are notsufﬁcient to guarantee the correctness of systems.
4 comparing the architecture framework
with sca
4.1 introduction to sca
the sca (beisiegel et al., 2007) provides a model for the
composition of services, the creation of service componentsand the reuse of existing applications within servicecompositions. service components can be implemented indifferent programming languages and accessed via differentprotocols, including web services, asynchronous messagesor synchronous remote procedure calls.
the following paragraphs describe the sca component
model. sca components use a simple interface contract todescribe their partner relationships.
the most important construct of sca is the component
consisting of
1services (i.e. business functions offered to other
components)
2references (i.e. dependencies on business functions
needed from other components)
3properties (i.e. values that inﬂuence the component
implementation)
4implementation (i.e. concrete realisation of the
provided services).
sca provides the concept of a component type deﬁning
the conﬁgurable aspects (or points of variability) of animplementation. a component is a conﬁgured instance ofan implementation.
an sca component may be implemented using traditional
programming languages like c++ or java, scriptinglanguages like php or javascript, declarative languages like
xquery or sql, or as a business process using ws-bpel.
the sca assembly model describes how components can
be assembled into composites , containing the aggregated
components, services, references and properties. compositescan be viewed as an implementation of a higher-levelcomponent and can be nested. composites also contain wires .
the source of a wire may be a component reference or a
composite service. the target of a wire may be a component
service or a composite reference. figure 6 illustrates anexample sca composite. note that the wires (as in figure 1)describe a dependency relationship and not control ﬂow.
figure 6 an example sca composite (for colours see online
version)
an sca system represents the conﬁguration of an sca
run-time environment. it represents a region of conﬁgurationand control and deﬁnes the scope of what can be connectedvia sca wires. in general, an sca run-time environment isdistributed and heterogeneous. it has a logical system levelcomposite of running components that are implemented bysimple implementations or composites.
in sca, services and references can be associated with
bindings and policies .
references use bindings to describe the mechanism used
to call a service and services use bindings to describe theaccess mechanism that clients have to use in order to call theservice. examples for bindings are a web service, a statelesssession ejb, a database stored procedure or an eis servicebinding.
a policy is a declaration of a speciﬁc set of behaviours,
and applies to the implementation of a componentor to an interaction with a component. policies maybe aggregated into proﬁles . examples for policies are
ws-reliablemessaging orws-addressing policies associated
with web service bindings, or a conversation policyassociated with jms bindings.
the interface model is extensible such that detailed partner
interaction semantics could be captured as well, for example,by using concepts like ws-bpel abstract processes. scacomponents may be stateless or stateful; however, sca doesnot provide an explicit data model describing data managedby a component.
4.2 comparison to the architecture framework
to compare sca with our architecture framework, we ﬁrst of
all present in tabl e 1 a comparison of the terms used. then,
we step into the details of both the frameworks.10 w.m.p . van der aalst et al.
table 1 comparing the terms of sca and the architecture
framework
sca framework as depicted in figure 1
component atomic component
composite composite componentsystem outmost composite componentimplementation process implementation like
ws-bpel, petri nets
service sell interfacereference buy interfaceproperty base entity
wire wire
the component concepts in both frameworks are very similar.
both frameworks support atomic and composite components,wires and processes. in sca, it is possible to specifya property for a composite, whereas in our framework,composite components do not have data entities.
in sca, the term implementation is used for the choice
of a process technology like ws-bpel, java or petrinets. so, an sca implementation coincides with a processimplementation in our architecture framework.
at the level of the interface, sca is more extendable
than our interface concept which is restricted to wsdl 1.1.however, we can also easily extend our interface concept.
both frameworks are very general and thus support
different process models. for our framework, we showedthis in section 3.2.4 and the process models supported bysca are listed in the last section.
sca speciﬁes bindings, qos and policies. this is, so
far, not integrated in our framework. as our meta model infigure 1 is general, we could easily add an entity for eachof the three concepts. the semantics had to be deﬁned byadding relationships and additional ocl constraints.
finally, our architecture framework has a data model.
sca, in contrast, has no data model yet. it only supportsthe conﬁguration of components with the help of properties.in our framework, we use base activities for the conﬁgurationof components (cf. section 3.2.2).
to summarise, both frameworks are very similar, in
particular in the component and process model. however,sca does not support a data model yet, which is inour opinion, a very important model as we mentioned insection 3.3.
5 related work and outlook
in this paper, we addressed our efforts in developingan architecture framework for soa. we introduced thearchitecture framework by means of a meta model thatfocused on three different views on software systems:a component view, a process view and a data view.
the proposed architecture framework also covers other
important concepts such as instantiation and messagecorrelation.
we aim at formally verifying systems on the level of
the architecture. for this purpose, we collected a numberof constraints for our architecture framework and speciﬁedthem using the ocl. these constraints can be implemented
and checked by a case tool. that way, architects havetool support during the system design. in (van der aalstet al., 2007), we also presented rules to translate thearchitecture framework into cpns. on the level of cpns,formal veriﬁcation techniques can be applied.
the presented architecture framework is required to be
language independent and close to industry standards, inparticular to sca. we have shown that our architectureframework extends sca, since sca does not provide anexplicit data model yet.
another architectural framework which has been inspired
by sca is the sensoria reference modelling language(srml). srml presents a formal model for components andtheir composition. the process model speciﬁes the languageof interaction of the process but there is no data model sofar. axenath et al. (this special issue) present a meta modelfor business processes modelling (amfibia) which capturesthe aspects, control ﬂow, data and organisation. as in ourapproach, these aspects can be modelled independently ofeach other and it is possible to integrate them later on.
a component model is missing so far, but the approach
is extensible. to summarise, the main contribution of ourframework, the integration of the component, the dataand the process views, is neither provided by srml and
amfibia nor by state-of-the-art architecture frameworks
such as corba, uml and koala.
in ongoing research, we want to extend the architecture
framework, for example with the concept of inheritancewhich allows the reuse of parts of the system. inheritanceis one of the most important concepts in object-orientedprogramming and should therefore be adapted on the levelof architecture frameworks. we also want to spend moreeffort on the veriﬁcation of the architecture and as along-term objective on the development of tools for the designand management of component-based systems.
references
alves, a. et al. (2007) web services business process execution
language version 2.0 , oasis standard, 11 april 2007, oasis.
axenath, b., kindler, e., rubin, v . (this special issue) ‘amfibia: a
meta-model for integrating business process modelling aspects’,int. j. business process integration and management .
bass, l., clements, p. and kazman, r. (2003) ‘ software
architecture in practice ’, 2nd edition, addison wesley
professional.
beisiegel, m., et al. (2007) service component
architecture – assembly model speciﬁcation , sca version 1.00,
15 march 2007, ibm, sap et al.
blow, m., goland, y ., kloppmann, m., leymann, f., pfau, g.,
roller, d. and rowley, m. (2004) bpelj: bpel for java,
whitepaper , bea, ibm.
bouyssounouse, b. and sifakis, j. (ed). (2005) ‘ embedded systems
design – the artist roadmap for research and development ,
v ol. 3436 of lecture notes in computer science , heidelberg:
springer berlin.
christensen, e., curbera, f., meredith, g. and weeravarana, s.
(2001) web service discription language (wsdl) 1.1. , w3c
note 15 march 2001, ariba, international business machinesan soa-based architecture framework 11
corporation, microsoft.
fiadeiro, j.l., lopes, a. and bocchi, l. (2006) ‘a formal approach
to service component architecture’, in m. bravetti, m. núñezand g. zavattaro (eds). web services and formal methods
(ws-fm 2006), proceedings , v ol. 4184 of lecture notes in
computer science , pp.193–213, springer-verlag.
high, r., kinder, s. and graham, s. (2005) ‘ibm’s soa
foundation – an architectural introduction and overview’,
technical report 1.0 , ibm.
jensen, k. (1992) coloured petri nets. basic concepts, analysis
methods and practical use , v ol. 1 of monographs in theoretical
computer science , springer-verlag.
mcilroy, m.d. (1968) ‘mass produced software components’, in
p. naur and b. randell (eds). proceedings of nato software
engineering conference , v ol. 1, pp.138–150, garmisch,
germany.
object management group (2003) uml2.0 object constraint
language (ocl) speciﬁcation , speciﬁcation, object
management group (omg).ommering, r.c., van der linden, f., kramer, j. and magee, j.
(2000) ‘the koala component model for consumer electronicssoftware’, ieee computer , v ol. 33, no. 3, pp.78–85.
reisig, w. (1985) petri nets , berlin, heidelberg, springer-verlag,
tokyo, eatcs monographs on theoretical computer science
edition.
szyperski, c. (1998) component software–beyond object-oriented
programming , addison-wesley and acm press.
van der aalst, w.m.p., beisiegel, m., van hee, k.m., könig, d.
and stahl, c. (2007) ‘a soa-based architecture framework’,computer science report 07/02 , technische universiteit
eindhoven, the netherlands.
van der aalst, w.m.p. (1998) ‘the application of petri nets
to workﬂow management’, journal of circuits, systems and
computers , v ol. 8, no. 1, pp.21–66.