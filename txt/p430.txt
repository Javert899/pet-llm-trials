on the degree of behavioral similarity between business
process models
jan mendlingy, boudewijn van dongenz, wil van der aalstz
yqueensland university of technology
126 margaret street, qld 4000 brisbane, australia
j.mendling@qut.edu.au
zeindhoven university of technology
po box 513, nl-5600 mb eindhoven, the netherlands
b.f.v.dongen@tue.nl ,w.m.p.v.d.aalst@tue.nl
abstract: quality aspects become increasingly important while business process mo-
deling is used in a large-scale enterprise setting. in order to facilitate a storage without
redundancy and an efﬁcient retrieval of relevant process models in model databases it
is required to develop a theoretical understanding of how a degree of behavioral simi-
larity can be deﬁned. in this paper we address this challenge in a novel way. we use
causal footprints as an abstract representation of the behavior captured by a process
model, since they allow us to compare models deﬁned in both formal modeling langua-
ges like petri nets and informal ones like epcs. based on the causal footprint derived
from two models we calculate their similarity based on the established vector space
model from information retrieval. we illustrate this concept with an example from the
sap reference model and present a prototypical implementation as a plug-in to the
prom framework.
1 introduction
business process modeling is gaining increasing attention as a basis for the development
of large-scale enterprise information systems. in this context, business process models
can either be used as a formalization of requirements that guide the implementation, as
input for code generation in a model-driven architecture, or as executable templates on a
dedicated process engine deﬁned e.g. with bpel. all these three scenarios have in com-
mon that various quality issues have to be considered in order to facilitate storage without
redundancy and an efﬁcient retrieval of models. these two goals have in common that
there require a theoretical understanding of how the degree of behavioral similarity can be
formalized. based on such a concept it would be easy to identify those models that should
be integrated with others for maintainability reasons and to rank models that belong to the
answer set of a query. such a functionality would be in particular helpful to analysts who
have to integrate the operations of two enterprises that engage in a merger. we will see in
the related work section that the current state of the art does not provide a general solution
to this problem.
the analysis of behavioral similarity of business process models is complicated by twodcbefh
gi
aprocess model 
causal footprint figure 1: a causal footprint provides a characterization of the process model such that the behavior
of the process is enclosed [dma06].
problems. first, there is a plethora of languages for business process modeling. even
though there is some overlap between the different languages as shown by pattern-based
evaluations [ahkb03], there are striking differences and many subtle semantical issues
that complicate matters. for example, a concept such as the “synchronizing merge”
[ahkb03], also know as the or-join in languages such as bpmn and epcs, can be in-
terpreted in different ways and often leads to semantical paradoxes as shown in [adk02,
kin06]. second, and even worse, most business process modeling languages have no
formal semantics or their semantics is only well-deﬁned for a restricted subset. still, re-
dundancy and retrieval issues matter also for those business process models. in this paper,
we address these problems in a novel way.
the classical approach to comparing process models is to construct a state space or enu-
merate all possible traces and then compare the models based on this. trace equivalence
and bisimulation are typical notions used to compare formal models on such basis. un-
fortunately, these equivalence notions typically only work for models that have formal se-
mantics and have ﬁnite behavior (e.g., the number of traces or states needs to be bounded).
moreover, such notions provide a “yes/no” answer rather than the degree of similarity.
therefore, we abstract from the precise behavior using a concept that is called causal foot-
print [dma06]. the idea of a causal footprint is that it describes a set of conditions on the
order of activities that hold for the process model. these conditions can be used to reason
about similarity of footprints. figure 1 illustrates that the causal footprint gives an approx-
imation of the process behavior in terms of conditions that every process instance has to
obey to. in [dma06] it has been shown that causal footprints can be used to reason about
the soundness of process models. although causal footprints abstract from the detailed
behavior, it is still possible to ﬁnd certain errors (e.g., particular types of deadlocks).
in this paper, we use causal footprints for measuring similarity . unlike our earlier work
[dma06] we do not look at veriﬁcation but at the degree of similarity between two models.
when comparing two models we compare the corresponding causal footprints using the
so-called vector model used in information retrieval [swy75, byrn99].
throughout this paper, we use event-driven process chains (epcs) and petri nets to show
the applicability of causal footprints for both formal and conceptual business process mod-
eling languages. this choice is motivated by the fact that epcs are widely used for the
documentation of business processes, e.g. in the sap reference model. furthermore,
petri nets are a well-understood formalism for the modeling of business processes andhave been used for the formalization of a variety of languages and standards (e.g. bpmn,
bpel, xpdl, uml activity diagrams). against this background the paper is structured
as follows. first, section 2 gives an introduction to epcs and petri nets and shows how
both can be mapped to causal footprints. then, section 3 presents a novel concept for
calculating the degree of behavioral similarity between two process models based on their
causal footprints and inspired by concepts from information retrieval. section 6 discusses
our approach in the light of related work before section 7 concludes the paper with an
outlook on future research.
2 preliminaries
in the introduction, we mentioned two process modeling languages, namely petri nets and
epcs. in this section, we introduce these modeling languages informally and provide for-
mal deﬁnitions for both languages (only syntax). furthermore, we introduce the concept
of a causal footprint and show how to derive causal footprint from epcs and petri nets by
just considering their structure. most modeling languages are graph based. therefore, we
start by introducing some notation speciﬁcally for directed graphs.
deﬁnition 2.1. (pre-set and post-set)
letg= (n; e)be a directed graph consisting of a set of nodes nand a set of edges
eµn£n. moreover, let n2nbe a particular node. we deﬁneg²n=fm2
nj(m; n)2egas the pre-set and ng²=fm2nj(n; m)2egas the post-set of nwith
respect to the graph g. if the context is clear, the superscript gmay be omitted, resulting
in²nandn².
2.1 petri nets and epcs
petri nets can be used to specify (possibly concurrent) processes in an unambiguous man-
ner. since the language has formal and executable semantics, processes modelled in terms
of a petri nets can be executed by an information system. in fact most workﬂow engines
have adopted the basic constructs present in the petri net formalism. for an elaborate in-
troduction to petri nets, the reader is referred to [de95,mur89,rr98]. a petri net consists
of two types of node elements (cf. figure 2): transitions typically correspond to either an
activity which needs to be executed, or to a “silent” step that takes care of routing. a
transition is drawn as a rectangle. places are used to deﬁne the preconditions and postcon-
ditions of transitions. a place is drawn as a circle. transitions and places are connected
through directed arcs in such a way that (i) places and transitions have at least one incident
edge and (ii) in every path, transitions and places alternate (no place is connected to a
place and no transition is connected to a transition). for completeness sake, we mention
that the petri nets we use in this paper correspond to a classic subclass of petri nets, namely
workﬂow nets [aal98], which are tailored towards workﬂow modeling and analysis.deﬁnition 2.2. (workﬂow net)
!= (p; t; f )is a workﬂow net (or wf-net [aal98]) if:
-pis a ﬁnite set of places,
-tis a ﬁnite, non empty set of transitions, such that p\t=;andt6=;,
-fµ(p£t)[(t£p)is the ﬂow relation of the net,
-there exists exactly one pi2p, such that j ²pij= 0,
-there exists exactly one pf2p, such that jpf² j= 0,
-all places and transitions are covered by the paths from pitopf.
in addition to petri nets, we also use epcs to illustrate our ideas. epcs provide an intu-
itive modeling language to model business processes. epcs were introduced by keller,
n¨uttgens, and scheer in 1992 [kns92]. it is important to realize that the language is not
intended to be a formal speciﬁcation of a business process. instead, it serves mainly as
a means of communication. epcs are extensively used in large-scale enterprise model-
ing projects. one prominent example of a publicly available model is the sap reference
model [ckl97, kt98]. an epc consists of three types of node elements (cf. figure 2):
functions correspond to an activity (task, process step) which needs to be executed. a
function is drawn as a box with rounded corners. events describe the situation before
and/or after a function is executed. an event typically corresponds to the pre- or post-
condition of a function. events are drawn as hexagons. connectors can be used to connect
functions and events to specify the ﬂow of control. there are three types of connectors:
^(and), £(xor) and _(or). connectors are drawn as circles, showing the type in
the center. functions, events, and connectors can be connected with edges in such a way
that (i) events have at most one incoming edge and at most one outgoing edge, but at least
one incident edge (i.e. an incoming or an outgoing edge), (ii) functions have precisely one
incoming edge and precisely one outgoing edge, (iii) connectors have either one incoming
edge and multiple outgoing edges, or multiple incoming edges and one outgoing edge, and
(iv) in every path, functions and events alternate (ignoring intermediate connectors).
deﬁnition 2.3. (event-driven process chain)
"= (f; e; c and; cxor; cor; a)is an epc if:
-fis a ﬁnite set of functions,
-eis a ﬁnite set of events,
-c=cand[cxor[coris a ﬁnite set of connectors, such that jcj=jcandj+
jcxorj+jcorj,
-aµ((f[e[c)£(f[e[c))is the ﬂow relation of the net, such that:
-for all f2fthere is one (f; x)2aand one (x; f)2a,
-for all e2ethere is at most one (e; x)2aand at most one (x; e)2a,
-for all c2cthere is either one (c; x)2aand more than one (x; c)2a, or
one(x; c)2aand more than one (c; x)2a,
-on all paths, functions and events alternate.a
bc
d/\ a
bc
d /\figure 2: an epc (left) and a petri net (right) describing a process thats starts with a, followed by
the parallel execution of bandc, and ends with d.
note that in this section, we only provide an abstract syntax of petri nets and epcs and do
not give any semantics. the reason is that we are not interested in the precise semantics.
as illustrated by figure 1 we aim for a causal footprint which is independent of speciﬁc
and/or reﬁned semantical interpretations (e.g., the or-join in epcs).
2.2 causality graphs
as stated in the introduction, we look at a similarity measure for business processes, based
on the high-level concept of causal footprints. at the basis of causal footprints lie causality
graphs .1a causality graph captures the intented behavior that is captured in the process
model. it is important to realize that these causality graphs do not capture the entire process
model as such, in fact they are merely a footprint of the control ﬂow in the given process
model, i.e. they describe the approximate behavior of a system at a very high level.
deﬁnition 2.4. (process behavior/case)
lettbe a set of activities, and let ©tbe a process containing these activities. the
behavior of the process ©tis deﬁned as the set wµt¤, where t¤is the set of all
sequences that are composed of zero of more tasks from t. a¾2wis called a case, i.e.
a possible execution of the process. to denote an activity at a speciﬁc index in ¾, we use
¾[i], where iis the index ranging from 1toj¾j.
we have now formalized the behavior of a process and each of the modeling languages
of section 2 is intended to capture this behavior in a structured way. as we stated before,
we will look at processes at a high level. therefore, we introduce the causality graph ,
representing a footprint of the process.
deﬁnition 2.5. (causality graph)
letnbe a set of activities. we deﬁne a causality graph g= (n; f lb; fla), where:
-nis a ﬁnite set of nodes (activities),
1note that this paper adopts the concept of a causality graph from [dma06]. however, unlike in [dma06]
this concept is used for measuring similarity rather than veriﬁcation.-flbµ(p(n)£n)is a set of look-back links2,
-flaµ(n£ p(n))is a set of look-ahead links .
when a causality graph is used to describe a process, it should be interpreted in the fol-
lowing way. for each look-ahead link , we say that the execution of the source of that link
leads to the execution of at least one of the targets of that link, i.e., if (a; b)2fla, then
any execution of ais followed by the execution of some b2b. a look-ahead link is
denoted as a bullet with one or more outgoing arrows. furthermore, for each look-back
link, the execution of the target is preceded by at least one of the sources of that link, i.e.,
if(a; b)2flb, then any execution of bis preceded by the execution of some a2a. the
notation of a look-back link is a bullet with one or more incoming arrows. note that we
do not give any information about when in the future or past executions took place, but
only that they are there. this way of describing a process is similar to the work presented
in [ejl+99]. however, by splitting up the semantics in the two different directions (i.e.
forward and backward), causal footprints are more expressive. with footprints you can for
example express the fact that task ais always succeeded by b, but thatbcan also occur
beforea, which is typically hard to express in other languages.
if a causality graph indeed describes a process like this, we call it a causal footprint . we
formalize this concept using the notion of cases.
deﬁnition 2.6. (causal footprint)
lettbe a set of activities, ©tbe a process with behaviour w. furthermore, let tiand
tfbe such that ti; tf62tandti6=tf. furthermore, let g= (t[ fti; tfg; flb; fla)be a
causality graph. (for notational purposes, we say that for all ¾2wwithn=j¾j, it holds
that¾[0] = tiand¾[n+ 1] = tf, i.e. we add artiﬁcial starts and ends to each trace). we
say that gis acausal footprint graph of ©t, denoted by g2 f©t, if and only if:
1.for all (a; b)2flaholds that for each ¾2wwithn=j¾j, such that there is a
0·i·n+ 1with¾[i] =a, there is a j:i < j·n+ 1, such that ¾[j]2b,
2.for all (a; b)2flbholds that for each ¾2wwithn=j¾j, such that there is a
0·i·n+ 1with¾[i] =b, there is a j: 0·j < i , such that ¾[j]2a,
it is clear from deﬁnition 2.6 that a causal footprint is not unique, i.e., different processes
can have common footprints. for example, g= (t[ fti; tfg;;;;)is the causal footprint
of any process having activities t. therefore, we aim at footprints that are more informa-
tive without trying to capture detailed semantics. by deriving a transitive closure, a causal
footprint can be extended to be a more informative causal footprint.
in [dma06], the transitive closure of a causal footprint was deﬁned for the soundness
analysis of these footprints. in this paper, we use the same causal closure to describe
similarities between process models.
deﬁnition 2.7. (causal closure)
letg= (n; f lb; fla)be a causality graph. we deﬁne g¤= (n; f¤
lb; f¤
la)to be the causal
closure of g, where f¤
lbandf¤
laare the smallest possible sets, such that:
2withp(n), we denote the powerset of n, i.e.n02 p(n)if and only if n0µnandn06=;.a
cba
cbacbacb
xa
cbva
cb
/\a
cb xacbvacb
/\acbfigure 3: mapping of epcs to causal footprints.
1.(a; b)2flaimplies that (a; b)2f¤
la,
2.(a; b)2flbimplies that (a; b)2f¤
lb,
3.(a; b)2f¤
laimplies that for all n0µnholds that (a; b[n0)2f¤
la,
4.(a; b)2f¤
lbimplies that for all n0µnholds that (a[n0; b)2f¤
lb,
5.(a; b)2f¤
la,b2band(b; c)2f¤
la, implies that (a;(bn fbg)[c)2f¤
la,
6.(b; c)2f¤
lb,b2band(a; b)2f¤
lb, implies that ((bn fbg)[a; c)2f¤
lb,
the rules for causally closing a causal graph obviously apply to a causal footprint as
well. more importantly, the causal closure of a causal footprint is a causal footprint again
[dma06] and we refer to it as a footprint closure . the fact that a causal footprint of a
process is not unique is irrelevant for the work presented in this paper. any property that
can be derived to hold on a causal footprint of a process, holds on the process itself. the
better the causal footprint of a process is, i.e. the more information it contains, the more
properties we are able to deduce. as an example, again consider the graph that only has
the activities of a process as nodes and no edges. this graph is a causal footprint of any
process, but it does not contain any information about the process.
2.3 deriving causal footprints
in this section, we present algorithms to derive causal footprints of epcs and petri nets.
this is done in two stages. first, the models are translated to causality graphs in such a way
that these graphs contain all elements of the modeling languages and only causalities that
can be derived locally (i.e., immediate predecessor and successor relationships). these
graphs are then transitively closed and projected onto the subset of interesting elements,
thus leading to causal footprints.
deﬁnition 2.8. (epc to causal graph)
let"= (f; e; c and; cxor; cor; a)be an epc, with the set of modeling elements n0=
f[e[cand[cxor[cor, the set of initial elements ni=fn2n0j"²n=;g
and the set of ﬁnal elements nf=fn2n0jn"²=;g. we deﬁne a causality graph
g"= (n; f lb; fla)as follows:a a b b
c d c dfigure 4: mapping for petri net.
-n=n0[ fni; nfg, where ni; nf62n0andni6=nf,
-fla=
f(a;fbg)2n£ p(n)ja2f[e[cand^b2a"²g [
f(a; b)2n£ p(n)ja2cor[cxor^b=a"²g [
f(ni; ni)g [ f(a;fnfg)ja2nfg,
-flb=
f(fag; b)2 p(n)£njb2f[e[cand^a2"²bg [
f(a; b)2 p(n)£njb2cor[cxor^a="²bg [
f(nf; nf)g [ f(fnig; a)ja2nig.
deﬁnition 2.8 gives an algorithm to derive a causality graph from an epc. this is illus-
trated by figure 3. it is important to note that the causality graph is derived based on the
structure of the model, i.e., there is no need to ﬁrst construct the set of cases. in some
cases it is useful to restrict the causality graph to a subset of nodes. for epcs for example,
we might only be interested in its functions and connectors. by taking the causal closure
of the causality graph and projecting it onto the functions and connectors (i.e. removing
all events and all edges related to these events), we obtain a causal footprint of the process
modelled by the epc. for this, we ﬁrst deﬁne a projection of a causal graph.
deﬁnition 2.9. (causal graph projection)
letg= (n; f lb; fla)be a causal graph and let n0be a set of nodes, such that n0µn.
we deﬁne the projection g0= (n0; f0
lb; f0
la)ofgonton0, such that flb0=flb\
(p(n0)£n0)andfla0=fla\(n0£ p(n0)).
as we stated before, the translation rules from an epc to a causal graph are given under
the assumption that the epc is sound. however, soundness would imply that there are
clear executable semantics, which is not always the case. therefore, our translation rules
do not require explicit semantics. the only requirement for our rules to hold is that sound-
ness should be deﬁned in such a way that a synchronizing connector is considered to ﬁre
eventually.
similar to epcs, we provide a translation for wf-nets to causality graphs and show that
the result is a causal footprint for the modelled process (cf. figure 4).
deﬁnition 2.10. (workﬂow net to causal footprint)
let!= (p; t; f )be a wf-net, with the set of modeling elements n0=p[t, the initial
place pi2pand ﬁnal place pf2p. we derive a causality graph g!= (n; f lb; fla)asfollows:
-n=t[ fni; nfg, where ni; nf62n0andni6=nf,
-fla=
f(n; n0)2n£ p(n)j 9p2pnfpfgn2!²p^n0=p!²g [
f(ni; pi!²)g [
f(t;fnfg)jt2!²pfg,
-flb=
f(n0; n)2 p(n)£nj 9p2pnfpign2p!²^n0=!²pg [
f(!²pf; nf)g [
f(fnig; t)jt2pi!²g,
as shown in [dma06] causal footprints can be used to detect problems such as deadlocks.
however, the causal footprint also provides a compact but useful characterization of the
corresponding process. therefore, the concept can be used to compare processes which is
useful when searching for similar models or for quantifying the gap between some desired
model and a given model.
3 similarity of business process models
in many scenarios it is important to compare business process models with respect to the
behavior they specify, e.g. in case of a merger of two companies that have models for sim-
ilar business processes, or when looking for a web services closest to the own internal pro-
cesses. in this section, we consider the causal footprints of two models as an input to cal-
culate similarity. this has several advantages compared to related proposals. first, causal
footprints include information about the order of activities beyond direct succession. the
full closure also looks at indirect dependencies and, therefore, it is more powerful than the
approach in [aaw06], since there only direct connections are used for structural similar-
ity. furthermore, causal footprints are robust with respect to problems such as termination
or ﬁniteness of state space which affect true/false behavioral similarity measures, such as
trace-equivalence and (branching) bisimilarity. we calculate similarity directly based on
the causal footprint of two models instead of considering their explicit behavior. in order
to do so we use techniques originating from information retrieval [swy75, byrn99].
3.1 similarity based on the vector model
in information retrieval the degree of similarity between a document and a query plays a
very important role for ranking the returned documents according to their relevance. for
calculating similarity, we use the well-known vector model [swy75, byrn99] which is
one of the basic techniques used for information ﬁltering, information retrieval, and the
indexing of web pages. its classical application is to determine the similarity between a
query and a document. the original vector space model proposed by salton, wong, andyang in [swy75] attaches weights based on term frequency to the so-called “document
vector”. we use a more liberal interpretation, where other weights are possible. however,
to explain the basic mechanism we use terms originating from the domain of information
retrieval, i.e., terms like “document collection”, a set of “terms”, and a set of “weights”
relating to the terms. later we will provide a mapping of these terms to causal footprints.
thedocument collection contains a set of documents. each of these documents is consid-
ered to be a list of terms which are basically the words of the document. the union of all
terms of all documents is then used to describe each document as a vector. for one speciﬁc
document an entry in the vector represents that the term associated with the vector position
of this entry is included in the document. in a simple case the occurrence of a term can be
indicated by a one and the non-occurrence with a zero, however there is also the option to
assign weights to terms in order to address the fact that they differ in relevance. a com-
mon choice is to use one divided by the number of occurrences of a term throughout all
documents of the document collection as a weight which has the effect that scarcely used
terms get a higher weight. a query can also be considered as a document, i.e., a list of
terms.
the similarity between a query and a document is then calculated based on their vector
representation as the cosine of the angle between the two vectors [swy75, byrn99].
calculating this degree of similarity for each document provides a mechanism to rank
them according to their relevance for the query.
our proposal for determining the similarity of two business process models builds on
the vector model and causal footprints. we consider causal footprints of two processes
g1= (n1; f1;lb; f1;la)andg2= (n2; f2;lb; f2;la)as input for the calculation. in order
to apply the vector model, we have to deﬁne (1) the document collection, (2) the set of
terms, and (3) the set of weights.
the document collection includes two entries corresponding to the two causal footprints
that need to be compared. we will refer to these as the ﬁrst and the second causal
footprint (i.e., g1andg2).
the set of terms is build from the union over nodes, look back, and look ahead links of
the two causality closures. we deﬁne £ =n1[f1;lb[f1;la[n2[f2;lb[f2;la
as the set of terms and ¸: £! f1;2; : : :j£jgas an indexing function that assigns
a running number to each term, i.e., the set of all elements appearing in the two
footprints are enumerated. (note that we implicitly assume all sets of nodes and
links to be disjoint in a single model.)
the relevance of each term is closely related to the number of tasks from which it is
built. consider for example two look ahead links xla= (a;fgg)2flaandyla=
(a;fb; c; d; e; f g)2fla.xlarefers to only two tasks: aandg.ylarefers to six tasks
(athrough f). it seems obvious that the look ahead links with fewer tasks are more in-
formative and therefore more important. to address this we use weights depending on the
number of tasks involved in a look-ahead/back link.
the weights are determined using the size of the relations. if µ2£is a single node (i.e.
µ2n1[n2), then we deﬁne the weight of µaswµ= 1. furthermore, since the
number of potential look ahead and look back links depends upon the powerset ofnodes, is seems natural to use exponentially decreasing weights. therefore, for all
links µ2£, we deﬁne the weight of a link wµ= 1=(2jµj¡1), where jµjdenotes the
number of tasks in the link, i.e. for the two look ahead links xla= (a;fgg)and
yla= (a;fb; c; d; e; f g), we get wxla= 1=(22¡1) = 0 :5andwyla= 1=(26¡1) =
0:03125 .
using the document collection, the set of terms and the weights presented above, we deﬁne
the document vectors, which we call footprint vectors .
deﬁnition 3.1. (footprint vectors)
letg1= (n1; f1;lb; f1;la)andg2= (n2; f2;lb; f2;la)be two causal footprints, with £
the set of terms and ¸: £!i nan indexing function. we deﬁne two footprint vectors,¡ !g1= (g1;1; g1;2; : : : g 1;j£j)and¡ !g2= (g2;1; g2;2; : : : g 2;j£j)for the two models as follows.
for each element µ2£, we say that for each i2 f1;2gholds that
gi;¸(µ)=8
><
>:0 ifµ62(ni[fi;lb[fi;la)
wµ=1
2jµj¡1ifµ2(fi;lb[fi;la)
wµ= 1 ifµ2ni
using the two footprint vectors, we can deﬁne the similarity between two footprints as the
cosine of the angle between these two vectors.
deﬁnition 3.2. (footprint similarity)
letg1= (n1; f1;lb; f1;la)andg2= (n2; f2;lb; f2;la)be two causal footprints, with £
the set of terms and ¸: £!i nan indexing function. furthermore, let¡ !g1and¡ !g2be the
corresponding footprint vectors. we say that the similarity between g1andg2, denoted
bysim(g1; g2)is the cosine of the angle between those vectors, i.e.
sim(g1; g2) =¡ !g1£¡ !g2
j¡ !g1j ¢ j¡ !g2j=pj£j
j=1g1;j¢g2;jqpj£j
j=1g2
1;j¢qpj£j
j=1g2
2;j
the value of sim(g1; g2)ranges from 0 (no similarity) to 1 (equivalence). in this pa-
per, we do not elaborate on this formula. if one accepts the weights that we associate to
the “terms” in a causal footprint, then the cosine of the angle between these two vectors
provides a generally accepted way to quantify similarity [swy75, byrn99].
the similarity sim(g1; g2)between footprints can be calculated for any two footprints
g1andg2. however, the best results will be obtained if the causal footprint is a footprint
closure, since then the most information is obtained. to illustrate this, we again take two
examples from the sap reference model.4 application to the sap reference model
to show the practical applicability in real life, we applied our approach in the context of
the sap reference model. in this section, we illustrate the calculation of business pro-
cess model similarity based on the vector model and causal footprints using this reference
model.
since reference models should be comprehensive sets of models serving as a guide when
modelling large information systems, we feel that they should satisfy two properties:
²the reference model should contain models that are correct, i.e. there should not be
any errors in these models.
²the reference model should be searchable, i.e. one should not only be able to search
for models of a speciﬁc process (such as “purchasing” or “invoice management”),
but one should also be able to search through the database to ﬁnd a model that
matches a given model as close as possible. this is in particular needed in merger
situations where similar operations of two enterprise have to be integrated.
the ﬁrst requirement has been extensively discussed in [djvv a, admv06, madv06b,
madv06a, mvd+07] and it was mentioned in [dma06], where we showed how causal
footprints can be used to ﬁnd errors in epcs.
a ﬁrst step towards satisfying the latter of the two requirements is provided in this paper,
i.e. we present a way to compare the behaviour of models based on their structure. in
the work presented here, it is assumed that it is easy to map the activities of one model to
the activities of another model (e.g. by assuming that they are the same objects, or have
the same label). in our application, this mapping was done manually since the labels of
functions not always coincided completely (e.g. “order creation” vs. “refurbishment order
creation”, etc.).
in [djvv a], we presented a guided model selection to ﬁnd errors in the sap reference
model. in that paper, we were guided by one speciﬁc function called “order execution”
that appeared in several epcs (seven in total). in this paper, we take the same guide, i.e.
we look at the seven epcs containing the function “order execution” and we pairwise
compare their similarity. the seven epcs that are investigated are presented in table 1.
for each of the seven models, we calculated the causal footprint and we compared them
using our similarity metric of deﬁnition 3.2. it is important to note that the seven models
do not all meet the ﬁrst requirement stated above, i.e. most of them even show syntactical
problems by having events linked to events. however, since events are not reﬂected in a
causal footprint, this does not inﬂuence our results.
table 2 shows the result of our comparison. again note that at some points, we manually
had to make mappings from the functions in one model to functions in the other model.
figure 5 shows how this mapping was made in the implementation in prom (cf. section 5).
it shows that a mapping was made from “order creation” to “maintenance order creation”,
from “order execution” to “order execution” and from “order release” to “maintenance
order release”. furthermore, for model 2 on the left hand side, the functions “material
planning”, “order permit” and “order printing” were not mapped to any of the functionstable 1: the seven epcs containing the function “order execution” in the sap reference model.
1.plant maintenance / breakdown maintenance processing / order / order,
2.plant maintenance / planned maintenance processing / order / order,
3.plant maintenance / project based maintenance processing / order / order,
4.plant maintenance / refurbishment processing in plant maintenance / order / order,
5.quality management / test equipment management / maintenance order / mainte-
nance order,
6.quality management / test equipment management / service order / service order,
7.treasury / forex spot forward and swap transactions / transaction processing / trans-
action processing.
in the other model. similarly, the functions “overall completion conﬁrmation”, “order
settlement” and “order completion” in model 5 on the right hand side were not mapped to
any of the functions in model 2.
the results presented in table 2 give us valuable insights into the sap reference model.
first, they show that models containing the function “order execution” within the same
module (i.e. “plant maintenance”, “quality management” and “treaury”) are exactly the
same (in terms of behaviour). the question arises whether this is desirable, i.e. should
there be so many copies of exactly the same model?
furthermore, table 2 also shows that the similarity between models in different modules is
rather low. this implies that although these models contain a reference to exactly the same
function “order execution”, the contexts in which this function is executed are rather dif-
ferent and hence that the sap reference model basically contains three different functions,
which are all labelled “order execution”.
finally, it should be noted that the mere fact that two epcs are 26:4%similar in itself is
not too informative. however, in a querying scenario this measure can be used to rank
several process models of the result set (for example, when looking for a model that is
similar to model 1 of table 1 the models 2,3 and 4 are more likely candidates than the
table 2: similarity between epcs containing the function “order execution” in the sap reference
model.
1 2 3 4 5 6 7
1100 % 100 % 100 % 100 % 26.4 % 26.4 % 5.28 %
2 100 % 100 % 100 % 26.4 % 26.4 % 5.28%
3 100 % 100 % 26.4 % 26.4 % 5.28%
4 100 % 26.4 % 26.4 % 5.28%
5 100 % 100 % 5.01%
6 100 % 5.01%
7 100 %figure 5: comparison of two sap models in prom: sim(g2; g5) = 0 :2638 .models 5,6 and 7) and in an merger scenario this value might be high enough to advocate
an integration of the process models as is the case with models 1, 2, 3 and 4 and models 5
and 6.
5 tool support
the (pro)cess (m)ining framework prom has been developed as a completely plug-able
environment for process mining and related topics in the context of business process analy-
sis. it can be extended by simply adding plug-ins, i.e., there is no need to know or to recom-
pile the source code. currently, more than 150 plug-ins have been added [da v+05]. prom
is open-source and can be downloaded from http://www.processmining.org .
in the context of this paper, we developed an analysis plug-in for the comparison of causal
footprints. this analysis plug-in, takes two causal footprints (or models that can be con-
verted to causal footprints, e.g. petri nets and epcs, using the already available plug-ins
presented in [dma06]) and calculates their similarity. the plug-in requires the user to ﬁrst
map the elements of one model onto the elements of the other model. to support this step
the plug-in suggests a mapping based on the labels of corresponding elements. further-
more, by default, the analysis plug-in considers only functions for epcs and only visible
transitions for petri nets, by projecting the footprints on these elements before calculating
similarity. figure 5 shows the comparison of two epcs in prom.
for the practical application of our results it is important to note that the prom framework
is currently capable of reading and writing epcs to aml (native to the aris toolset),
epml (a standard for storing epcs), vdx (the xml format of visio), and the aris graph
format used by aris ppm. for petri nets, multiple formats are available, including the
standard pnml format. prom also supports other languages such as yawl and bpel.
since causal footprints are language independent, different models can be compared, e.g.,
the similarity of a petri net and an epc can be calculated.
6 related work
the concept of a causal footprint based similarity measure relates to two research areas:
(1) declarative approaches for process speciﬁcation and (2) similarity of process models.
causal graphs (or causal footprints) can be seen as a declarative language , i.e., instead of
using explicit control-ﬂow operators like sequence, iterations, etc., constraints are given.
in this paper we consider two types of constraints (look-back links and look-ahead links)
as introduced in [dma06]. these can easily be translated into a temporal logic [mp91].
in [ap06] the declarative service flow language (decserflow) is deﬁned which includes
the two types of constraints used in this paper but also many others. this illustrates that the
approach presented in this paper could be extended to include other types of constraints
in the causal footprint. in [ap06] it is shown how these can be represented in lineartemporal logic (ltl) and a respective implementation of an ltl checker for event logs
is included in the prom framework [abd05].
existing work in the context of determining similarity between process models can be
assigned to three categories: veriﬁcation, integration, and degree of similarity. there are
different notions of equivalence of process models that are subject to veriﬁcation such as
trace equivalence and bisimulation. while trace equivalence is based on a comparison of
the sets of completed execution traces, bisimulation also considers at which point of time
which decisions are taken, i.e., bisimulation is a stricter notion of equivalence. details
on different equivalence notions are given e.g. in [aaw06]. a general problem of such
veriﬁcation approaches is that it provides a true-false answer to the question whether two
models are similar. the quantiﬁcation of a degree of behavioral similarity between process
models is an important contribution for the area of process model integration . while
there are several approaches reported regarding how two models are integrated (see e.g.
[pcs01, grss05, ms06]) the similarity degree gives an answer to the question when two
process models might be a candidate for integration, e.g. in a merger situation.
up to now, there is hardly any work reported on measuring the degree of behavioral sim-
ilarity of two process models. in [aaw06] three similarity notions are discussed related
to the structure, the state space, and the observed behavior of the models. the structural
similarity counts connections between tasks that appear in both models and relates it ei-
ther to the number of connections in the ﬁrst benchmark model (called recall metric) or
to those of the second model (called precision metric). yet, it does not consider transitive
order relations of tasks. the naive behavioral similarity is based on ﬁring sequences of
both models, but bears several problems with respect to termination, moment of choice, or
ﬁniteness of the state spaces. instead, the authors propose a behavioral similarity metric
based on the ﬁtness of a set of event logs. this is indeed valuable for process mining, but
not directly applicable for model comparison where no logs are present, or logs cannot
be directly mapped to the higher-level description of the process (i.e. if there are transac-
tion logs on one side, and a conceptual high level model on the other). in contrast to this
work, causal footprint provide a rich set of information for comparison without the need
to calculate the state space.
finally, there are some approaches discussed for calculating the similarity of process mod-
els based on metadata (see e.g. [kb04, ms04, eko07]). in contrast to the degree of sim-
ilarity based on causal footprints, these contributions hardly use information about the
behavior of the process models. nevertheless, it seems possible to combine some of the
ideas presented in these paper with causal footprints, e.g., semantical mappings between
the labels of activities in different models.
7 conclusion and future work
in this paper, we presented a metric for comparing process models in different formats.
we capture the intent of a process model by deriving a causal footprint . such a foot-
print should be seen as an abstraction of the process behavior. as a causal footprint doesnot require an executable semantics of the process modeling language, we can apply our
analysis technique both to formal languages such as petri nets and to conceptual/informal
languages such as epcs. even though we use only these two languages throughout the
paper to demonstrate the applicability of our technique, it can be easily adapted to other
languages such as uml activity diagrams, bpmn, or bpel. this is especially helpful
regarding the heterogeneity of business process modeling languages. furthermore, the
causal footprints provide a rich set of information over models that can be utilized to de-
termine the degree of similarity between them.
the degree of behavioral similarity based on causal footprints provides the basis for a
more efﬁcient querying and management of large collections of business process models,
even if they are represented in different modeling languages. in particular the reengineer-
ing of such model collections would proﬁt from our concepts since a similarity matrix
might clearly indicate which pairs of process models are likely candidates for integration
or deletion.
references
[aal98] w.m.p. van der aalst. the application of petri nets to workﬂow management. the
journal of circuits, systems and computers , 8(1):21–66, 1998.
[aaw06] w.m.p. van der aalst, a.k. alves de medeiros, and a.j.m.m. weijters. process
equivalence: comparing two process models based on observed behavior. in
s. dustdar, j.l. faideiro, and a. sheth, editors, international conference on busi-
ness process management (bpm 2006) , volume 4102 of lecture notes in computer
science , pages 129–144. springer-verlag, berlin, 2006.
[abd05] w.m.p. van der aalst, h.t. de beer, and b.f. van dongen. process mining and veri-
ﬁcation of properties: an approach based on temporal logic. in r. meersman and
z. tari et al., editors, on the move to meaningful internet systems 2005: coopis,
doa, and odbase: otm confederated international conferences, coopis, doa,
and odbase 2005 , volume 3760 of lecture notes in computer science , pages 130–
147. springer-verlag, berlin, 2005.
[adk02] w.m.p. van der aalst, j. desel, and e. kindler. on the semantics of epcs: a vicious
circle. in m. n ¨uttgens and f.j. rump, editors, proceedings of the epk 2002: business
process management using epcs , pages 71–80, trier, germany, november 2002.
gesellschaft f ¨ur informatik, bonn.
[admv06] w.m.p. van der aalst, b.f. van dongen, j. mendling, and h.m.w. verbeek. fouten in
sap-referentiemodel (in dutch). automatisering gids, 19th may 2006.
[ahkb03] w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros. work-
ﬂow patterns. distributed and parallel databases , 14(1):5–51, 2003.
[ap06] w.m.p. van der aalst and m. pesic. decserflow: towards a truly declarative service
flow language. in m. bravetti, m. nunez, and g. zavattaro, editors, international
conference on web services and formal methods (ws-fm 2006) , volume 4184, pages
1–23, 2006.
[byrn99] r.a. baeza-yates and b.a. ribeiro-neto. modern information retrieval . acm press
/ addison-wesley, 1999.
[ckl97] t. curran, g. keller, and a. ladd. sap r/3 business blueprint: understanding the
business process reference model . enterprise resource planning series. prentice
hall ptr, upper saddle river, 1997.[da v+05] b.f. van dongen, a.k. alves de medeiros, h.m.w. verbeek, a.j.m.m. weijters, and
w.m.p. van der aalst. the prom framework: a new era in process mining tool sup-
port. in application and theory of petri nets 2005 , volume 3536 of lecture notes in
computer science , pages 444–454. springer-verlag, berlin, 2005.
[de95] j. desel and j. esparza. free choice petri nets , volume 40 of cambridge tracts in
theoretical computer science . cambridge university press, cambridge, uk, 1995.
[djvv a] b.f. van dongen, m.h. jansen-vullers, h.m.w. verbeek, and w.m.p. van der aalst.
methods for epc veriﬁcation and application to the aris for mysap reference mod-
els.computers in industry (accepted for publication) .
[dma06] b.f. van dongen, j. mendling, and w.m.p. van der aalst. structural patterns for
soundness of business process models. in edoc ’06: proceedings of the 10th ieee
international enterprise distributed object computing conference (edoc’06) ,
pages 116–128, washington, dc, usa, 2006. ieee computer society.
[ejl+99] h. eertink, w. janssen, p. oude luttighuis, w. b. teeuw, and c. a. vissers. a busi-
ness process design language. in fm ’99: proceedings of the wold congress on
formal methods in the development of computing systems-volume i , pages 76–95,
london, uk, 1999. springer-verlag.
[eko07] m. ehrig, a. koschmider, and a. oberweis. measuring similarity between semantic
business process models. in j.f. roddick and a. hinze, editors, conceptual mod-
elling 2007, proceedings of the fourth asia-paciﬁc conference on conceptual mod-
elling (apccm 2007) , volume 67, pages 71–80, ballarat, victoria, australia, 2007.
australian computer science communications.
[grss05] g. grossmann, y . ren, m. schreﬂ, and m. stumptner. behavior based integration
of composite business processes. in w.m.p. van der aalst, b. benatallah, f. casati,
and f. curbera, editors, business process management, 3rd international conference,
bpm 2005, nancy, france, september 5-8, 2005, proceedings , volume 3649 of lec-
ture notes in computer science , pages 186–204. springer, 2005.
[kb04] m. klein and a. bernstein. toward high-precision service retrieval. ieee internet
computing , 8(1):30–36, 2004.
[kin06] e. kindler. on the semantics of epcs: a framework for resolving the vicious
circle. data and knowledge engineering , 56(1):23–40, 2006.
[kns92] g. keller, m. n ¨uttgens, and a.w. scheer. semantische processmodellierung auf der
grundlage ereignisgesteuerter processketten (epk). ver ¨offentlichungen des instituts
f¨ur wirtschaftsinformatik, heft 89 (in german), university of saarland, saarbr ¨ucken,
1992.
[kt98] g. keller and t. teufel. sap(r) r/3 process oriented implementation: iterative
process prototyping . addison-wesley, 1998.
[madv06a] j. mendling, w.m.p. van der aalst, b.f. van dongen, and h.m.w. verbeek. errors in
the sap reference model. bptrends, june 2006.
[madv06b] j. mendling, w.m.p. van der aalst, b.f. van dongen, and h.m.w. verbeek. referenz-
modell: sand im getriebe - webfehler. ix - magazin f ¨ur professionelle information-
stechnik. (in german) , pages 131–133, august 2006.
[mp91] z. manna and a. pnueli. the temporal logic of reactive and concurrent systems:
speciﬁcation . springer-verlag, new york, 1991.
[ms04] m. momotko and k. subieta. process query language: a way to make workﬂow
processes more ﬂexible. in g. gottlob, a.a. bencz ´ur, and j. demetrovics, editors,
advances in databases and information systems, 8th east european conference, ad-
bis 2004, budapest, hungary, september 22-25, 2004, proceesing , volume 3255 of
lecture notes in computer science , pages 306–321. springer, 2004.[ms06] j. mendling and c. simon. business process design by view integration. in johann
eder and schahram dustdar, editors, proceedings of bpm workshops 2006 , volume
4103 of lecture notes in computer science , pages 55–64, vienna, austria, 2006.
springer-verlag.
[mur89] t. murata. petri nets: properties, analysis and applications. proceedings of the
ieee , 77(4):541–580, april 1989.
[mvd+07] j. mendling, h.m.w. verbeek, b.f. van dongen, w.m.p. van der aalst, and g. neu-
mann. detection and prediction of errors in epcs of the sap reference model. data
and knowledge engineering (accepted) , 2007.
[pcs01] g. preuner, s. conrad, and m. schreﬂ. view integration of behavior in object-oriented
databases. data & knowledge engineering , 36(2):153–183, 2001.
[rr98] w. reisig and g. rozenberg, editors. lectures on petri nets i: basic models , volume
1491 of lecture notes in computer science . springer-verlag, berlin, 1998.
[swy75] g. salton, a. wong, and c.s. yang. a vector space model for automatic indexing.
communications of the acm , 18(11):613–620, 1975.