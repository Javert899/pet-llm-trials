process diagnostics using trace alignment:
opportunities, issues, and challenges
r. p. jagadeesh chandra bosea,b, wil m. p. van der aalsta
adepartment of mathematics and computer science,university of technology, eindhoven,
the netherlands
bphilips healthcare, veenpluis 5{6, best, the netherlands
abstract
business processes leave trails in a variety of data sources (e.g., audit trails,
databases, transaction logs). hence, every process instance can be described by
a trace, i.e., a sequence of events. process mining techniques are able to extract
knowledge from such traces and provide a welcome extension to the repertoire
of business process analysis techniques. recently, process mining techniques
have been adopted in various commercial bpm systems (e.g., bpm jone, futura
reect, aris ppm, fujitsu interstage, businesscape, iontas pdf, qpr pa).
unfortunately, traditional process discovery algorithms have problems dealing
with less structured processes. the resulting models are dicult to comprehend
or even misleading. therefore, we propose a new approach based on trace align-
ment . the goal is to align traces in such a way that event logs can be explored
easily. trace alignment can be used to explore the process in the early stages
of analysis and to answer specic questions in later stages of analysis. hence,
it complements existing process mining techniques focusing on discovery and
conformance checking.
keywords: diagnostics, conformance, alignment, execution patterns, process
mining
1. introduction
today's information systems are recording an abundance of event logs. events
may be scattered over various data sources, e.g., the database of a hospital con-
taining information about patients, the audit trails of a bpm (business process
management) system, the transaction log of an airline's web service, and the
job lists of a printer. by ordering events belonging to each process instance,
we obtain a collection of traces also referred to as an event log . process mining
techniques can extract non-trivial knowledge and interesting insights from these
event logs and exploit these for further analysis [1]. for example, it is possible
to discover a process model from an event log. process mining is not limited to
control-ow and may also be used to discover other perspectives, e.g., the social
preprint submitted to information systems june 26, 2011network of the people working on the process or decision trees explaining the de-
cision points in the process. process mining is not limited to discovery and also
includes conformance checking (identifying points where process instances de-
viate from expected and/or normative behavior) and model enhancement (e.g.,
enriching models based on event logs).
the lion's share of process mining research has been devoted to control-ow
discovery. in this paper, we focus on complementary techniques to diagnose
processes that are based on the alignment of traces . this work is inspired by
practical experiences using classical control-ow discovery techniques. we (our
research group) have applied process mining in over 100 organizations and our
experiences show that processes tend to be less structured than expected. more-
over, event logs tend to be far from complete, i.e., just a fraction of the possible
behavior indeed occurs. therefore, it may be too ambitious to construct a pro-
cess model that also says something about unseen cases, i.e., future process
instances that will leave traces that were not seen before. if processes are less
structured and event logs are incomplete, then it is better to carefully inspect
the event log by grouping and aligning the traces found in the event log . first,
we group similar traces in clusters [2]. second, we visualize these clusters by
aligning the traces. by aligning traces we can see the common and frequent
behavior, and distinguish this from the exceptional behavior.
our approach is inspired by biological sequence alignment [3]. sequence align-
ment is an essential tool in bioinformatics that assists in unraveling the sec-
ondary and tertiary structures of proteins and molecules, their evolution and
functions, and in inferring the taxonomic, phylogenetic or cladistic relationships
between organisms, diagnoses of genetic diseases etc. [4, 5]. process mining also
deals with sequences, i.e., traces of events stored in event logs. multiple se-
quence alignment has been a subject of extensive research in computational
biology for over three decades. there are still many open problems e.g., deal-
ing with ever increasing size and complexity of the data sets, misalignments
and alignment errors [6, 7], obtaining accurate alignments of non-coding and
non-transcribed sequences [8], integrating disparate sources of knowledge when
performing alignments (knowledge-based multiple sequence alignment) [9, 10]
etc. moreover, there are various new challenges when adopting biological se-
quence alignment to trace alignment in the context of business processes e.g.,
traces in an event log in process mining need not be from a coherent set of
cases and can be of dierent lengths, scoring matrices of substitution and inser-
tion/deletion of activities need to be dened/derived, the size of the alphabet
(number of activities) can be large of the order of a few tens or hundreds etc.
the topic of trace alignment has not been explored before. we will show that
it can be used to answer a variety of questions and that it is a welcome addition
to the repertoire of process mining techniques.
to illustrate the importance of trace alignment, consider the dotted chart [11]
in figure 1. every line corresponds to a process instance and every dot cor-
2responds to an event. the color of the event indicates the activity that was
executed. the horizontal dimension describes time. note that the dots are not
aligned. hence, it is dicult to see common patterns among dierent cases.
events are positioned based on their timestamps rather than the activity that
was executed and similarities to events in other instances. figure 2 shows the
figure 1: dotted chart showing all event in one glance. consider a dot at position ( x;y)
having a color c. this dot refers to an event for the process instance corresponding to y(i.e.,
a horizonal line) that occurred at time x(i.e., time increases from left to right). the color
describes a property of the event; in this case the activity that was executed.
eect of trace alignment. both dimensions are used in a similar fashion as be-
fore, i.e., every row corresponds to a process instance and time increases from
left to right. however, now the horizonal position is based on logical time rather
than realtimestamps. when two rows have the same activity name in the same
column, then the corresponding two events are very similar and are therefore
aligned. note that the same activity can appear in multiple columns. by read-
ing a row from left to right, we can see the sequence of activities (i.e., the trace)
that was executed for a process instance. process instances having the same
trace can be grouped into one row to simplify the diagram. clearly, figure 2 is
much more informative than figure 1 if one is interested in commonalities and
dierences among traces.
the challenge is to nd an alignment that is as simple and informative as pos-
sible. for example, the number of columns and gaps should be minimized while
having as much consensus as possible per column. obtaining such high quality
alignments turns out to be a challenging problem.
the remainder of this paper is organized as follows. in section 2, we intro-
duce the basic notations used in the paper and list the questions we would like
to answer. section 3 introduces the concept of trace alignment and discusses
the techniques for nding alignments. in section 4, we propose a framework for
nding alignments over a set of traces. in section 5, we present techniques for
3figure 2: traces aligned using the approach presented in this paper. each row refers to a
process instance. columns describe positions in traces. trace alignment aims a minimizing
the number of gaps and maximizing the consensus.
rening alignments to improve alignment quality. in section 6, we present our
implementation using the process mining framework prom. section 7 discusses
three case studies that demonstrate the applicability of our approach and the
ability to answer a variety of questions. we discuss the computational complex-
ity aspects of the proposed approach and present some quantitative results in
section 8. in section 9, we provide an outlook on some of the opportunities
and problems related to trace alignment. we discuss related work in section 10.
finally, section 11 concludes the paper.
2. event logs, questions, and answers
before explaining our approach to align traces, we introduce some basic con-
cepts and present six diagnostic questions we would like to answer using our new
analysis approach.
process mining is impossible without proper event logs. in some applications
it may be challenging to extract such logs from a variety of data sources, e.g.,
databases, at les, message logs, transaction logs, erp systems, and document
management systems. in other applications, this is straightforward, e.g., when
using a bpm system.
the starting point for process mining is the concept of an event . an event
refers to a process instance , sometimes referred to as a case. each process in-
stance is described by a sequence of events. an event emay have dierent
properties, e.g., a timestamp ( eoccurred on february 15th 2011 at 11:29:31
utc ), resource information ( ewas executed by maria ), activity ( ecorresponds
to a credit check ), transaction type ( eis astart event, i.e., the start of the credit
check by maria), and various data elements ( eis done for customer 991133 who
would like to borrow 5000 euro). all of these properties are optional. the only
requirement is that events are ordered (i.e., no explicit timestamp is needed)
4and that each event belongs to a particular class. for analysis, we need a func-
tion that maps any event einto its class e. in this paper, we assume that each
event is classied based on its activity. hence, for our earlier example e=credit
check .
consider a process instance for whichnevents have been recorded: e1;e2;:::e n.
this process instance has a tracee1;e2;:::enassociated to it. if we use activity
names as a classier, the trace corresponds to a sequence of activities. however,
if we would classify events based on resource information, a trace could corre-
spond to a sequence of person names. in the remainder, we will assume that a
trace is a sequence of activities. however, we could also align traces based on
the people that worked on them etc.
using the above assumption, we can dene an event log as a multi-set of traces.
denition 1. let  denote the set of activities . +is the set of all non-empty
nite sequences of activities from . any t2+is a possible trace. an event
loglis a multi-set of traces.
for example,  = fa;b;cgandl=fabc;abc;abc;aabbcc;aabbcc;acg. event
logldescribes the traces of 6 process instances. note that three instances have
the same trace abcand two instances have trace aabbcc . because dierent pro-
cess instances can have the same trace, a log is multi-set of traces rather than
a set.
we introduce some standard operations for traces.
denition 2. lett=t(1)t(2)t(3):::t(m)2+be a trace:
 jtj=mdenotes the length of the trace t;
t(k) denotes the kthelement of trace t;
tkdenotes the klength prex of t, i.e.,tk=t(1)t(2):::t(k); and
the set of all m-length sequences over the alphabet  is denoted by m.
given an event log, we would like to answer a variety of diagnostic questions:
1.what is the most common (likely) process behavior that is executed?:
given an event log (i.e., multi-set of traces), it would be interesting to
know which process components are essential/critical for this process.
such essential components/functions form the backbone of the process
and should be conserved. process re-design/improvement eorts should
focus on improving such critical components.
2.where do process instances deviate and what do they have in common?:
in practice, there is often a signicant gap between what is prescribed
or supposed to happen, and what actually happens. there is a need to
augment process diagnostics with techniques that can assist in nding
5deviations by analyzing raw traces in the event logs. there are many do-
mains/applications where this requirement is felt. fault diagnosis, anomaly
detection, diagnosis of fraudulent insurance claims are some of the appli-
cations. given an event log containing a mix of traces where the system
process functioned normally and where it malfunctioned, analyzing these
traces to nd deviations in malfunctioned/anomalous traces from normal
traces would give cues in understanding the cause of malfunction/anomaly.
3.are there any common patterns of execution in the traces?: analyzing logs
at the granularity of an individual event might not always be result yield-
ing as one often loses the context information during such analysis. an
analyst would be interested in knowing whether there are any interesting
execution (behavioral) patterns in the log. the absence or presence of such
patterns may indicate the cause of an anomaly (say for e.g., fraudulent
insurance claim) or a security violation or a malfunction.
4.what are the contexts in which an activity or a set of activities is executed
in the event log?: dependencies exist between activities in a process
and activity executions are expected to happen within certain contexts.
there can be short-range and long-range dependencies between activities.
long-range dependencies are dicult to discover. an analyst would be
interested in understanding the contexts of execution of activities and/or
activity sequences.
5.what are the process instances that share/capture a desired behavior ei-
ther exactly or approximately?: often in diagnostics, an analyst would be
interested in nding process instances that share/comply to a particular
desired behavior; the desired behavior can be expressed as a manifestation
of some pattern of activity sequences or some complex form (combination)
of these patterns. though temporal logic approaches can assist in address-
ing this problem to a certain extent by discovering process instances that
capture the desired behavior exactly, one might also be interested in dis-
covering process instances that share the desired behavior approximately.
6.are there particular patterns (e.g., milestones, concurrent activities etc.)
in my process?: workow patterns [12] refer to recurring forms/structures
addressing business requirements. for example, milestones indicate spe-
cic execution points in the process model and provide a mechanism for
supporting the conditional execution of a task or sub-process. an ana-
lyst would be interested in discovering the presence of, and in analyzing
milestone patterns in the process event log. similarly, discovery of process
models with concurrency is one of the challenging problems in process
mining. the presence of concurrent activities creates dierent permuta-
tions of activities in the event log that adds to the complexity of discovery
algorithms. detection of the presence of concurrent activities might also
help in pre-processing the logs.
in the remainder we will show that trace alignment signicantly contributes to
answering these questions.
63. trace alignment
in this section, we formally dene what trace alignment is and discuss tech-
niques for nding optimal alignments.
denition 3. trace alignment over a set of traces t=ft1;t2;:::;t ngis
dened as a mapping of the set of traces in tto another set of traces t=
ft1;t2;:::;tngwhere each ti2([f g )+for 1inand
there is an m2nsuch thatjt1j=jt2j=:::=jtnj=m,
tiis equal totiafter removing all gap symbols \  ",
there is no k2f1;:::;mgsuch that81in,ti(k) = 
min the denition above is the length of the alignment. an alignment over
a set of traces can be represented by a rectangular matrix a=faijg(1
in;1jm) over 0= [f g where \ " denotes a gap. the third
condition in the denition above implies that no column in acontains only
gaps ( ). it is imperative to note that there can be many possible alignments
for a given set of traces and that the length of the alignment, m, satises the
relationlmaxmlsumwherelmaxis the maximum length of the traces in t
andlsumis the sum of lengths of all the traces in t.
3.1. pairwise trace alignment
before we get into the details of aligning a set of traces, let us rst consider a
special case of trace alignment, where the number of traces to align is 2. align-
ing a pair of traces is referred to as pair-wise trace alignment. let us consider
the example of aligning the two traces t1=abcac andt2=acacad . figure 3
depicts three of the many variants of aligning the two traces.
t1a b c a c - -
t2a - c a c a d
(a)t1a b c a c -
t2a c a c a d
(b)t1a b c a c - - - - - -
t2- - - - - a c a c a d
(c)
figure 3: an example of pairwise trace alignments.
alignment between a pair of traces, t1andt2can be considered as a transfor-
mation of the trace t1tot2or viceversa through a set of editing operations
applied to one of the traces iteratively. the traces are said to be aligned after the
transformation, and can be represented as a rectangular matrix as mentioned
earlier. assuming that t1is transformed into t2, the following edit operations
are dened for any column jin the alignment:
the activity pair ( a;b),a;b2, denotes the substitution of activity ain
t1with activity boft2,
the activity pair ( a; ) denotes the deletion of activity aint1, and
7the activity pair (  ;b) denotes the insertion of activity bint1.
it is important to note that insertion and deletion operations are complemen-
tary in that an insertion in one trace can be considered as a deletion in another
trace. henceforth, we refer to insertion and deletion operations as indel op-
eration. indels should be sensitive to the context in which the operations are
performed [2]. for example, in a repair process, it is ok to have an activ-
ityanalyze defect after register but not after start repair (the defect
should rst be analyzed before performing the repair). bose and van der aalst
[2] have considered two notions of context for indels viz., indelrightgivenleft
and indelleftgivenright which indicates the insertion of an activity to the
immediate right of another activity or to the immediate left of another activity
respectively. one can consider both the left and right contexts as well as larger
subsequences of activities rather than an individual activity in dening contexts.
however, this increases the computational complexity of nding alignments. we
consider indelrightgivenleft as the notion of indels for trace alignment.
in order to avoid edit operations that do not make sense in a certain con-
text, a score or cost function needs to be dened for the substitution or indel
operations. the substitution score is a function s: !rwheres(a;b)
denotes the score for substitution of activity awith activity bfor all a;b2.
the indelrightgivenleft score is a function i: [f g [f g! rwhere
i(a;b) denotes the score for inserting or deleting activity bgiven that the left
activity is afor all a;b2.i( ;a) =i(a; ) =i( ; ) = 0 for all a2.
lett1andt2be the aligned traces of t1andt2and letmbe the length of
the alignment. it could be the case that the rst activity in t1ort2had to
be inserted/deleted. the left activity for this case does not exist; so, we dene
t1(0) =t2(0) = . givensandi,the score of a pair-wise alignment can be
dened as the sum of the scores of the edit operations across all columns in the
alignment . in other words:
score (t1;t2) =mx
j=1ej
where
ej=8
><
>:s(a;b) ift1(j) =aandt2(j) =b
i(a;b)(
ift1(j) =b;t1(j 1) = aandt2(j) = or
ift1(j) = ;t2(j) =bandt2(j 1) = a
assuming a unit score function where a substitution of activity pair ( a;b) is
associated with a score of 1 if a=band a score of 1 otherwise, and an indel
score function,i(a;b) = 1, for all a;b2, the alignments enumerated in
figure 3 have the scores 1,  4 and 9 respectively. a \best" alignment can
be considered to be the one with the maximum score. for the above example,
this corresponds to figure 3(i). instead, if we dene the indel score function
8as above but change the substitution score function as s(a;b) = 2 if a=b
ands(a;b) = 1, otherwise, then the alignments enumerated in figure 3 have
the scores 5, 5 and  9 respectively. the maximum alignment score is 5 and
there are two best alignments corresponding to figure 3(i) and figure 3(ii). as
another example, if we dene the substitution score as s(a;b) = 1 if a=b
ands(a;b) = 1, otherwise, and the indel score function as i(a;b) = 1, for all
a;b2, the alignments enumerated in figure 3 have the scores 7,  2 and 9
respectively. the maximum score is 9 and the best alignment corresponds to
figure 3(iii).
it is imperative to note that the best scoring alignment is sensitive to the substi-
tution and indel score functions. furthermore, there can be more than one align-
ment with the maximum score. substitution of uncorrelated/constrasting activ-
ities or insertion/deletion of activities not conforming to a context should be pe-
nalized heavily. similarly, `like' events should be allowed to be replaced/inserted
at a minimal cost [2].
3.2. how to compute alignments
figure 3 depicts just three of the many variants of aligning the two traces
t1andt2. in fact, the number of possible alignments for two traces of length l
is(1 +p
2)2l+1l 1=2[3], e.g., for two traces of length 100, the number of pos-
sible alignments is approximately 1077. therefore, it is infeasible to enumerate
all possible alignments (even for moderate values of l), nd their scores, and
identify the best alignment.
needleman and wunsch [13] have proposed a dynamic programming algorithm
for nding the optimal alignment between two (amino acid) sequences. the
basic idea is to build up an optimal alignment using previous solutions for op-
timal alignments of smaller subsequences. let t1andt2be two traces. a
matrixfindexed by iandj, is constructed where the value f(i;j) is the
score of the best alignment between the prex ti
1oft1and the prex tj
2
oft2.f(i;j) is constructed recursively by initializing f(0;0) = 0 and then
proceeding to ll the matrix from top left to bottom right. it is possible
to calculate f(i;j) iff(i 1;j 1),f(i 1;j) andf(i;j 1) are known.
there are three possible ways that the best score f(i;j) of an alignment up to
ti
1andtj
2could be obtained: t1(i) could be aligned to t2(j), in which case
f(i;j) =f(i 1;j 1) +s(t1(i);t2(j)); ort1(i) is aligned to a gap, in which
casef(i;j) =f(i 1;j) +i(t1(i 1);t1(i)); ort2(j) is aligned to a gap, in
which case f(i;j) =f(i;j 1) +i(t2(j 1);t2(j)). the best score up to ( i;j)
will be the largest of these three options. in other words, we have
f(i;j) = max8
<
:f(i 1;j 1) +s(t1(i);t2(j));
f(i 1;j) +i(t1(i 1);t1(i));
f(i;j 1) +i(t2(j 1);t2(j)):(1)
the values along the top row (when i= 0) and left column (when j= 0) need
9to be handled as follows. the values f(i;0) represent alignments of a prex
oft1to all gaps in t2. so, we can dene f(1;0) = 0 and for i >1;f(i;0) =
f(i 1;0) +i(t1(i 1);t1(i)). similarly, we can dene f(0;j). the value
in the bottom right cell of the matrix, f(jt1j;jt2j), is the best score for an
alignment of t1andt2. to nd the alignment itself, we must nd the path
of choices from (1) that led to this best score, i.e., we move from the current
cell (i;j) to one of the cells ( i 1;j 1);(i 1;j) or (i;j 1) from which the
valuef(i;j) was derived. while doing so, we add a pair of symbols onto the
front of the alignment: t1(i) andt2(j) if the step was to ( i 1;j 1),t1(i)
and the gap symbol `  ' if the step was to ( i 1;j), or ` ' andt2(j) if the step
was to (i;j 1). at the end we will reach the start of the matrix, i=j= 0.
the above procedure, called traceback , will retrieve only one of the alignments
that gives the best score; there can be cases where multiple options of (1) are
equal. in these cases, an arbitrary choice is made. the set of all possible align-
ments for the best score can be enumerated by using graph traversal techniques.
let us consider the two traces t1=abcac andt2=acacad and the unit
score function. figure 4(a) depicts the f matrix for these two traces using the
unit score function. consider the cell at row 4 and column 4, f(4;4); the value
for this cell corresponds to the maximum of the score at f(3;3) + sub( c,a) or
f(3;4) + del( c,b) orf(4;3) + ins( c,c). since in the unit score function, the
score of substitution of unlike activities and the score for indels is -1, we get
f(4;4) = maxf 1; 2;0g= 0. the best score of the alignment is f(6;7) = 1.
figure 4(b) depicts the traceback procedure pertaining to the best alignment.
we start with the bottom right cell at (6 ;7) and identify the cells that led to
the best score recursively until we reach the top left cell at (0,0).
3.3. multiple trace alignment
having discussed the alignment of two traces, let us move on to the alignment
of a set of traces. one of the most popular scoring mechanisms for multiple
sequence alignment of genomic sequences is the sum-of-pairs (sp) method [14,
15]. we adopt the sum-of-pairs method for trace alignment as well. let thand
tkbe two distinct rows extracted from a multiple trace alignment a(over a set
of set ofntraces), and let score (th;tk) be the alignment score calculated in
the same way as ordinary pairwise alignment of thandtk, then the sp score
of a multiple trace alignment ais dened as
score sp(a) =x
1h<knscore (th;tk)
it is possible to generalize the pairwise dynamic programming alignment ap-
proach to the alignment of ntraces. however, it is impractical for more than
a few traces. assuming that the traces are all of roughly the same length l,
the space complexity of the multidimensional dynamic programming algorithm
iso(ln) and the time complexity is o(2nln) [16]. multiple sequence alignment
that maximizes the sp score was shown to be np-complete [17]. since the
10ij
t2 a c a c a d
t1
a
b
c
a
c0 0 1 2 3 4 5
0 1 0 0 1 2 3
 1 0 0 1 1 2 3
 2 1 1 0 0 1 2
 3 1 0 2 1 1 0
 4 2 0 1 3 2 1
max scoresub
insdel
(a)ij
t2 a c a c a d
t1
a
b
c
a
c0 0 1 2 3 4 5
0 1 0 0 1 2 3
 1 0 0 1 1 2 3
 2 1 1 0 0 1 2
 3 1 0 2 1 1 0
 4 2 0 1 3 2 1
t2a - c a c a d
t1a b c a c - -
(b)
figure 4: the f-matrix and the traceback computing an alignment between two traces using
the unit score function.
computation of optimal multiple sequence alignment is prohibitively expensive,
various heuristic algorithms have been proposed in the literature [18].
we adopted the most popular heuristic approach [19], viz., the progressive
alignment approach [20, 21] for trace alignment. the basic idea of progres-
sive alignment is to iteratively construct a succession of pairwise alignments.
alignment is allowed between a pair of traces, a trace and an alignment and
between alignments. the selection of traces for alignment at each iteration
is based on their similarity. traces that are most similar to each other are
aligned rst. once similar traces have been aligned, align the resulting clusters
of traces against each other. a guide tree is built to assist this process. we use
the agglomerative hierarchical clustering algorithm (ahc) [22] with minimum
variance [23] as the join criteria for generating this tree. the choice of ahc is
due to the fact that it produces the tree naturally as a dendrogram while the
tree has to be constructed subsequently if other clustering algorithms such as
k-means is used.
it is important to note that the hierarchy formed using ahc is strongly in-
uenced by the features used to characterize the traces and the distance or sim-
ilarity metrics used. what constitutes a relevant feature is largely dependent on
the domain and the context of analysis [24]. context-aware and process-centric
features dened by common execution patterns are shown to out-perform the
bag-of-activities and k-gram features [25]. we use the maximal repeat feature
set [25], the euclidean distance metric and the f-score similarity measure [26]
in our experiments.
11figure 5 illustrates an example of the progressive alignment strategy. in this
example, we consider 5 traces. a guide tree is generated using ahc. based on
the guide tree, the traces t2andt3would rst be aligned using pairwise trace
alignment. next traces t4andt5would be aligned using pairwise trace align-
ment. subsequently, trace t1is aligned with the alignment obtained from t2
andt3. finally the two alignments obtained from the set of traces ft1;t2;t3g
andft4;t5gare aligned.
t1:j g c f l e b d
t2:j g c l e b d f i
t3:j g c l e b d f
t4:j g c l f e b d
t5:j g c l e f b d it1t2t3t4t5
t1 t2 t3 t4 t5j g c l e b d f i
j g c l e b d f -
j g c l - f e b d -
j g c l e f - b d ij g c f l e b d - -
j g c - l e b d f i
j g c - l e b d f -j g c f l - - e b d - -
j g c - l - - e b d f i
j g c - l - - e b d f -
j g c - l - f e b d - -
j g c - l e f - b d - i
figure 5: an example of progressive alignment approach for multiple trace alignment.
while aligning an alignment a, with another alignment b, (1) is modied as
f(i;j) = max8
<
:f(i 1;j 1) +s(ci
a;cj
b);
f(i 1;j) +i(ci 1
a;ci
a);
f(i;j 1) +i(cj 1
b;cj
b):(2)
12wheres(ci
a;cj
b) denotes the score of substituting column iof alignmentawith
columnjof alignmentband is dened as
s(ci
a;cj
b) =x
a;b2ni
a(a)nj
b(b)s(a;b) (3)
whereni
x(a) denotes the frequency (count) of activity ain columniof alignment
x.i(ci 1
a;ci
a) denotes the score of inserting column iin alignmentagiven
that its left column is i 1 and is dened as
i(ci 1
a;ci
a) =x
a;b2fi
a(a;b)i(a;b) (4)
wherefi
a(a;b) is the frequency of activity bin columniof alignmentagiven
that its neighboring activity is ain columni 1. the procedure for nding the
\best" alignment is similar to that of pairwise alignment.
note that the guide tree enables the visualization of alignments for dierent
subsets of the traces. the alignment at the root of the tree corresponds to the
alignment of all the traces in the event log whereas an alignment at any internal
node of the guide tree depicts the alignment corresponding to the traces consti-
tuting the leaves of the sub-tree at the node. it is often the case that event logs
contain traces capturing dierent execution behavior of a process and clustering
assists in grouping together a coherent set of traces.
4. framework for trace alignment
we propose the framework depicted in figure 6 for trace alignment. the
framework identies the following parts:
preprocess: preprocessing involves steps such as removal of outliers, re-
moval of loop-constructs, abstraction of activities and transformation of
log etc. the detection and removal of outliers (explained later in this
section) is critical for obtaining interesting alignments.
compute scoring matrices: as discussed in section 3, alignments are sen-
sitive to the substitution and indel score functions, sandirespectively.
we use the approach presented in [2] for deriving the substitution and
indel scores from the event log.
build guide tree: a guide tree assists in progressive alignment of multiple
traces as illustrated in figure 5. we use the agglomerative hierarchical
clustering (ahc) approach for building the guide tree. however, other
approaches such as neighbor joining [27] can be used.
generate progressive alignment: the progressive alignment approach is
used to compute the multiple trace alignment. the guide tree generated
in the above step directs the growth of progressive alignment as a series
of pairwise alignments.
13event log
preprocess processed log
build guide treecompute scor-
ing matrices
generate progres-
sive alignment
estimate align-
ment quality
prune and rene
interactive
visualization
figure 6: framework for multiple trace alignment.
estimate alignment quality: progressive alignment being a heuristic ap-
proach, the alignment that is obtained need not be optimal. furthermore,
any error in alignment done in early stages of progressive alignment cannot
be undone (cf. advanced alignment techniques in section 9). hence it is
essential to estimate the quality of an alignment. in this work, we adopt a
metric based on the information score as a means for assessing the quality
of an alignment. the information score of a column in an alignment is
dened as 1 e=e max, whereeis the entropy of activities in the column1
andemaxis the maximum entropy which is equal to log2(jj+ 1).
prune and rene: construction of multiple trace alignment is a very
complex problem, and most heuristic algorithms usually fail to generate
an optimal alignment. disturbances in an alignment can creep in from
many sources thereby making the nal alignment far from optimal. dis-
turbances here refer to the misplacement of gaps in an alignment. ecient
techniques for pruning and rening alignments need to be supported. we
will discuss more about this in the next section.
1the entropy of a column is dened as e=p
a2[f g palog2(pa) wherepais the
probability of occurrence of ain the column.
14interactive visualization: apart from just pictorially depicting the align-
ment, it is desirable to have additional interactive features for the analysts
to explore into the patterns and the alignments uncovered. features such
as editing an alignment, sorting and/or ltering alignment columns based
on activities of interest would all lead to gaining further insights into the
execution of processes.
though the denition of what constitutes an outlier is left open, in the cur-
rent exploration, we have adopted one simple denition of outliers based on the
length of the traces. it could be the case that in an event log there are certain
process instances whose lengths deviate a lot from the average trace length in
the log, e.g., one of the real life event logs that we analyzed has an average trace
length of 47 activities (across 223 traces) while there are 5 traces with lengths
above 250. since an alignment is at least as long as the maximum trace length,
such outlier traces in the log can lead to an alignment with too many gap sym-
bols. hence the removal of such traces is important. note that the denition
of outliers can change based on the perspective of analysis. if we are interested
in nding common execution patterns or the backbone sequence of a process,
the above denition of outliers may work ne. however, if we are interested in
nding non-conforming traces or deviations in anomalous traces from normal
traces, then the above denition might not always be appropriate. recent ef-
forts in detecting and dealing with outliers in process mining have been reported
in [28, 29]. the ecacy of these techniques in the context of trace alignment
needs to be explored.
the presence of loop constructs and the multiple invocations of a process frag-
ment (sub-process) can all lead to variations in the lengths of the traces. loop
constructs and multiple invocations of process fragments manifest as tandem
arrays and maximal repeats in the event logs respectively and can be detected
eciently in linear time [30]. one can identify such patterns and dene abstrac-
tions over them and transform the log to a higher-level [30]. trace alignment
can then be applied on the transformed log.
5. rening alignments to improve alignment quality
variation in the lengths of the traces, the choice of scoring functions used,
the method and parameter choices used in the generation of guide tree, strate-
gies used in resolving conicts during traceback can all lead to disturbances
or misalignments. furthermore, misalignments in earlier stages of progressive
alignment percolate to later stages. it is conjectured that detecting such mis-
alignments and rening them might improve the quality of the nal alignment.
misalignments are more pronounced in cases where there are recurring patterns
of common execution behavior such as the manifestation of loops and multiple
invocations of a functionality.
15figure 7 depicts three scenarios of misalignment. let pbe a sequence of ac-
tivities.pk
iindicates the kthinstance of the manifestation of pin traceti.
in figure 7, there are two instances of pin tracet1and one instance of pin
tracest2andt3. it could be the case that the lone instance of pin tracet2is
split up and aligned to the two instances of pint1as depicted in figure 7(i).
figure 7(ii) depicts the scenario where the lone instance of pint2is aligned to
the second instance of p(p2
1) int1where as one would have preferred it to be
aligned with p1
1. figure 7(iii) depicts an even more undesirable situation where
the lone instance of pint2is aligned to the rst instance of pint1and the lone
instance of pint3gets aligned to the second instance of pint1. what is worse
is that though pmanifests in both t2andt3, they do not get aligned due to
their alignment conict with t1. in this example, a desirable alignment would be
the one where the rst instance of pin all the three traces are aligned together.
t1p1
1 p2
1
t2
p1
2
(a)t1p1
1 p2
1
t2
p1
2
(b)t1p1
1 p2
1
t2
p1
2
t3
p1
3
(c)
figure 7: scenarios of misalignment in the presence of recurring patterns of execution.
in the above examples, we have considered the scenario where the pattern
pmanifests exactly as is (alike) in all the traces. however, the presence of
concurrent activities and/or optional activities in a process might disturb the
manifestation of pin a trace. in other words, there could be instances where
the concurrent/optional activities are interspersed in the manifestation of p.
for example, in the trace t=jgclfebdklebdklebdi , the concurrent activ-
ityfis interspersed in the manifestation of the rst instance of the pattern
lebd . figure 8 depicts two scenarios of misalignments in the presence of con-
current/optional activities. in figure 8(i), there exists a sequence of optional
activities interleaved in p1
2. it could be the case that the alignment of t1andt2
results in the prex of p1
2before the optional activities to be aligned with the
prex ofp1
1. the optional activities and the sux of p1
2following the optional
activities are aligned with gaps as indicated in figure 8(i) resulting in an unde-
sirable alignment. instead, an ideal alignment would be the one that is depicted
under `preferred alignment' in this case. figure 8(ii) illustrates the existence of
a sequence of concurrent activities interspersed in p1
2. a possible misalignment
and the preferred alignment are also depicted in figure 8(ii). for simplicity
reasons, we illustrate the misalignment scenarios with both the traces having
a single instance of pin figure 8. however, one can imagine scenarios where
16multiple instances of pare manifested with uneven numbers across traces, and
with some instances having an interleaved manifestation of optional/concurrent
activities. in such cases, the misalignment scenarios depicted in both figure 7
and figure 8 are (together) possible.
.
t1p1
1
t2
p1
2
(i)misalignment preferred alignment
t1p1
1
t2
p1
2misalignment preferred alignment
(ii)
figure 8: scenarios of misalignment in the presence of concurrent/optional activities inter-
spersed with recurring patterns of execution.
the information score metric dened earlier is not rich enough to capture such
misalignments. robust metrics to assess the quality of (mis-)alignment are
needed. the denition of such quality metrics largely remains an open research
topic in this area. we dene a pattern based misalignment metric, viz., mis-
alignment score in this paper.
misalignment score
lett=ft1;t2;:::;t ngbe a set of traces and t=ft1;t2;:::;tngbe the
corresponding set of aligned traces of t. given a pattern p, letc(p;ti) de-
note the frequency of occurrence (considering both the exact and interspersed
manifestation) of a pattern pin its corresponding original trace ti2t. for
any two aligned traces tiandtj2t, lettu= arg mint2fti;tjgc(p;t) and
tv= arg maxt2fti;tjgc(p;t). in other words, among tiandtj,turepresents
the one that has the lesser number of instances of the pattern pwhiletvrep-
resents the one with a higher number of instances of p.
let pa(p;k;tu;tv) denote the set of all instance numbers of pattern pin
tvto which some activity in the kthinstance of pintuis aligned to. if the
kthinstance of pintuis not aligned to any instance of pintv, i.e., it is
17aligned to only gaps, then pa( p;k;tu;tv) =fg. the misalignment score ma-
trixm=fmsijg(1i;jn) of a pattern pover the set of aligned traces t
is dened as
msij= ms ji=c(p;tu)x
k=1x
r2pa(p;k;tu;tv)jr kj+(k)
where(k) = 1 if any activity in the kthinstance of pattern pintuis aligned
to a gap or any other activity not in pintvand 0 otherwise. tuandtvcor-
respond to that aligned trace with the lesser and higher number of instances
ofprespectively among tiandtjas dened above. the jr kjsignies the
distance of misalignment. ms ijindicates the degree of misalignment pertaining
to all instances of pattern pintu.
let us look at the misalignment score metric with an example. consider the
two aligned traces
t1=jgcl----f---ebdklebdi
t2=jgc-fleb-dklebdklebdi
and the pattern p=lebd . activity fis a concurrent activity in the process
and is interspersed in pint1.c(p;t1) = 2 andc(p;t2) = 3 i.e., there are two
instances of pint1and three instances of pint2.tu=t1andtv=t2.
pa(p;1;tu;tv) =f2gand pa(p;2;tu;tv) =f3gi.e., the rst instance of pin
tuis partially aligned to the second instance of pintvand the second instance
ofpintuis completely aligned to the third instance of pintv.(1) = 1 since
the activity lin the rst instance of pintuis aligned to a gap while (2) = 0.
ms12=j2 1j+(1) +j3 2j+(2) = 3.
as another example, let us consider the pattern p=lebd and the two aligned
traces
t3=jgclfebdklebdklebdklebdi
t4=jgclf-----ebdklebdklebdi
c(p;t3) = 4 and c(p;t4) = 3 i.e., there are four instances of pint3and
three instances of pint4.tu=t4andtv=t3. pa(p;1;tu;tv) =f1;2g,
pa(p;2;tu;tv) =f3gand pa(p;3;tu;tv) =f4gi.e., the rst instance of p
intuis partially aligned to the both the rst and second instances of pintv
while the second and third instances of pintuare completely aligned to the
third and fourth instances of pintvrespectively. (1) =(2) =(3) = 0.
ms34=j1 1j+j2 1j+(1) +j3 2j+(2) +j4 3j+(3) = 3.
once the misalignment score matrix is computed for a given alignment, the
cumulative misalignment score is then dened to be the sum of the elements
in the upper/lower triangle of the matrix (since the matrix is symmetric). an
objective of a renement technique would then be to minimize the cumulative
misalignment score. in the following subsections, we propose a few techniques
of rening alignments.
185.1. global vs. semi-global trace alignment
the alignment procedure described in section 3 is also called as global trace
alignment . depending on the scoring functions, global trace alignment can
sometimes penalize gaps at the beginning and/or end of the traces in the align-
ment. in order to allow gaps to be inserted at the beginning/end of any trace in
an alignment, a variant of the global trace alignment called the semi-global trace
alignment can be considered. here the best score of the alignment is dened to
be the one that is the maximum in the last row or last column of the fmatrix
dened in section 3. traceback procedure starts from that cell and proceeds
until it stops at the rst position it reaches in the top row or left column. gaps
can then be inserted in the appropriate trace in the positions subsequent to the
maximum value cell in the last row/column and prior to the position it reached
in the top row or left column. figure 9 depicts the dierence between global
trace alignment and semi-global trace alignment of two traces aligned using the
same scoring functions. it is easy to see that the alignment obtained using semi-
global alignment is preferable to the one obtained using global-alignment.
t1j g c - a h b - - - - f d
t2j g c f a h b d k a h b d
(a) global trace alignmentt1j g c - a h b f d - - - - -
t2j g c f a h b - d k a h b d
(b) semi-global trace alignment
figure 9: an example of global trace alignment and semi-global trace alignment.
in this example, the two traces have a common execution pattern p=ahbd .
t1has one instance of ahbd whilet2has two instances. global trace alignment
leads to the scenario depicted in figure 7(i) where the lone instance of ahbd
int1is split up and the two splits are aligned to dierent instances of ahbd in
t2. this problem is mitigated with the semi-global trace alignment as depicted
in figure 9(b). the misalignment score for the pattern pis ms 12= 1 for the
resulting alignment using the global trace alignment while it is 0 for the one
obtained using semi-global trace alignment. we recommend to consider semi-
global trace alignment (at any iteration of progressive alignment) in scenarios
where the traces to be aligned dier vastly in their lengths (for example, due to
the manifestation of loop constructs).
5.2. block shift renement
consider the set of traces l=fjgcflebdklebdklebdi ,jgcflebdklebdi ,
jgclfebdklebdklebdi ,jgclfebdklebdklebdklebdi ,jgclfebdklebdi ,
jgclebfdklebdklebdi ,jgclebdfklebdklebdi ,jgclebdklfebdklebdi g. fig-
ure 10(i) depicts the alignment of these 8 traces. it could be seen that there
exists a common execution pattern lebd inland that there are dierent in-
stances of lebd among the traces. a concurrent activity fhas an interleaved
19manifestation among the traces. the misalignment scenarios depicted in fig-
ure 7 and figure 8 can be observed in figure 10(i). for example, the rst
instance of lebd in tracet5is split up and aligned with the rst and third
instances of lebd int4. the rst instance of lebd in tracet2is aligned with
the second instance of lebd int1. figure 11(i) depicts the misalignment score
matrix of the alignment in figure 10(i). the cumulative misalignment score is
53.
jgc-f----leb--dkl-ebdklebdi
jgc----------f--l-ebdklebdi
jgclf-----eb--dkl-ebdklebdi
jgclfebdkleb--dkl-ebdklebdi
jgcl---------f----ebdklebdi
jgcl------eb-fdkl-ebdklebdi
jgcl------ebdf-kl-ebdklebdi
jgcl------eb--dklfebdklebdi
(a)jgc-f----lebd--kl-ebdklebdi
jgc-f----lebd--kl-ebd-----i
jgclfebdklebd--kl-ebd-----i
jgclfebdklebd--kl-ebdklebdi
jgclfebdklebd-------------i
jgcl-eb------fdkl-ebdklebdi
jgcl-ebd-----f-kl-ebdklebdi
jgcl-ebdkl---f----ebdklebdi
(b)jgc-f----lebd--klebdklebdi
jgc-f----lebd--klebd-----i
jgclfebdklebd--klebd-----i
jgclfebdklebd--klebdklebdi
jgclfebdklebd------------i
jgcl-eb------fdklebdklebdi
jgcl-ebd-----f-klebdklebdi
jgcl-ebdkl---f---ebdklebdi
(c)
figure 10: an example of block shift renement. (a) original alignment (b) block shifted
alignment with a gap column (c) block shifted alignment after the removal of gap column in
(b).
1 2 3 4 5 6 7 8
1
2
3
4
5
6
7
80
0
0
0
0
0
0
02
1
3
3
1
1
12
4
1
2
2
23
2
0
1
04
3
4
32
2
21
0 1
(a) original alignment1 2 3 4 5 6 7 8
1
2
3
4
5
6
7
80
0
0
0
0
0
0
00
3
3
2
1
1
22
2
2
1
1
30
0
3
2
30
3
2
22
1
11
2 1
(b) block shifted rened alignment
figure 11: the misalignment score matrices (only the lower triangle is depicted).
it can be seen that the alignment can be improved by a mere adjustment/shifting
of gap blocks. for example, the activity fand the rst instance of lebd int2
can be shifted to the left so that fgets aligned to foft1andlebd gets aligned
20to the rst instance of lebd int1. algorithm 1 presents the renement of an
alignment by shifting non-gap activities to the left. the basic idea is to consider
each trace of the alignment from left to right shifting an activity at a column
preceded by a block of gaps to the left most possible column in that trace where
that activity manifests in any other trace of the alignment. figure 10(ii) depicts
the intermediary alignment after step 13 of algorithm 1. the shifting of ac-
tivities has resulted in an alignment where there exists a column with only the
gap symbol. such columns can be removed. figure 10(iii) depicts the rened
alignment after block shifts. figure 11(ii) depicts the misalignment score matrix
of the block shifted rened alignment. it can be noticed that the alignment of
figure 10(iii) is better than that of figure 10(i) (one can see that the common
execution pattern lebd is much well conserved after renement). accordingly,
the cumulative misalignment score of the rened alignment is 46 which is less
than that of the original alignment.
algorithm 1 block shift renement
require: an alignment,a
1:letmbe the length of the alignment
2:let  jdenote the set of activities in column jofa.
3:for all aligned traces tiinado
4:forj= 1 tomdo
5: ifthere exists a block of gaps of length p(p1) starting at jinti
then
6: ifthere exists a k, such that jk < j +panda(i;j+p)2k
then
7: swapa(i;k) anda(i;j+p). setj=k.
8: else
9: setj=j+p 1.
10: end if
11: end if
12: end for
13:end for
14:remove any column from athat contains only the gap symbol
5.3. concurrency pruning and realignment
concurrent activities manifest in mutually exclusive traces across dierent
columns in an alignment2. the basis for this arises out of the fact that con-
current activities can have dierent contexts of execution. in the alignment
of figure 10(i), activity fis concurrent as it manifests in columns 5, 14, and
2this holds true only in scenarios where the concurrent activity is not involved in a loop
construct. for cases where concurrent activities are involved in a loop, one can consider a
subset of consecutive columns in an alignment demarcating an instance of the loop and then
consider the manifestation of activities in that subset.
2118 and there exists no trace that has fin more than one column. concurrent
activities are one of the primary sources for misalignments. one can improve
the quality of an alignment by identifying the presence of concurrent activities
and handling them in a special way. algorithm 2 presents a procedure for prun-
ing concurrent activities and rening an alignment3. this algorithm only deals
with the specic case of manifestation of concurrent activities in an alignment
as dened in step 2 of algorithm 2. dealing with the other scenario where a
concurrent activity is aligned with another (potentially concurrent) activity is
relatively complex and is beyond the scope of this paper.
algorithm 2 concurrency pruning and realignment
require: an alignmenta
1:letcbe the set of all concurrent activities in a.
2:letcic be the set of all concurrent activities that is aligned to either
only itself or a gap in the alignment.
3:for alla2cido
4: leta0be the alignment obtained from aafter removing the columns in
whichamanifests
5: perform block shift renement on a0. leta00be the rened alignment.
6: insert the concurrent activity aas columns at appropriate positions in
the rened alignment. let a000be the new alignment.
7: seta=a000.
8:end for
figure 12(i) depicts the alignment obtained from figure 10(i) after removing
the columns where the concurrent activity fmanifests (step 4, algorithm 2).
figure 12(ii) depicts the alignment obtained after block shift renement on the
alignment of figure 12(i) (step 5, algorithm 2). as it can be seen, this align-
ment is the ideal alignment of the traces without activity f. the next step
corresponds to the reintroduction of the concurrent activity finto the align-
ment.
letf:nn!nbe a function dened over the set of trace indices, i2n, and
alignment column indices, j2n, that gives the activity index k2ncorrespond-
ing to the trace tiat alignment column jprovideda(i;j)2 (ifa(i;j) = ,
thenf(i;j) = 1). for example, for the alignment in figure 10(i) f(1;5) = 4,
because the activity in column 5 of the aligned trace t1isfandfis the fourth
activity in t1. similarly, f(2;17) = 5 and f(3;19) = 11. in the concurrency
pruned and block shift rened alignment ( a00in step 5, algorithm 2), we insert a
column at index jin the alignment with the concurrent activity in all the traces
i(and gaps for others) if and only if the activity at ti(f(i;j)) corresponds to
the concurrent activity. the resulting alignment after the reintroduction of the
3pruning here refers to deleting the manifestation of the concurrent activity in the aligned
traces
22jgc-----leb-dklebdklebdi
jgc-----------lebdklebdi
jgcl-----eb-dklebdklebdi
jgclebdkleb-dklebdklebdi
jgcl-----------ebdklebdi
jgcl-----eb-dklebdklebdi
jgcl-----ebd-klebdklebdi
jgcl-----eb-dklebdklebdi
(a)jgclebdklebdklebd-----i
jgclebdklebd----------i
jgclebdklebdklebd-----i
jgclebdklebdklebdklebdi
jgclebdklebd----------i
jgclebdklebdklebd-----i
jgclebdklebdklebd-----i
jgclebdklebdklebd-----i
(b)jgcfl-eb-d-kl-ebdklebd-----i
jgcfl-eb-d-kl-ebd----------i
jgc-lfeb-d-kl-ebdklebd-----i
jgc-lfeb-d-kl-ebdklebdklebdi
jgc-lfeb-d-kl-ebd----------i
jgc-l-ebfd-kl-ebdklebd-----i
jgc-l-eb-dfkl-ebdklebd-----i
jgc-l-eb-d-klfebdklebd-----i
(c)
figure 12: an example of concurrent activity pruning and realignment. (a) alignment ob-
tained from figure 10(a) after removing the columns where concurrent activity `f' manifests.
(b) alignment obtained after block shift renement of (a) (c) alignment obtained after in-
serting the concurrent activity in (b).
concurrent activity fin all the possible traces in the alignment of figure 12(ii)
is as shown in figure 12(iii). in this rened alignment, the kthinstance of lebd
(if it exists) among the traces are aligned with each other. the misalignment
score matrix for this rened alignment is a matrix of zero's (the cumulative
misalignment score is zero) which is an improvement from that of the original
(53) and the block-shifted rened alignment (46). in this log, the patterns are
disturbed only by the presence of the concurrent activity fand an appropriate
handling of the concurrent activity during renement led to the conservation of
the patterns in the alignment.
6. realization of the approach
the techniques and framework presented in sections 3, 4 and 5 has been im-
plemented as plugins in prom 6.04. figure 13 depicts the framework along with
the plugins that realize each step in the framework. some trivial preprocessing
techniques such as the ltering of traces based on their length are available as
lter plugins in prom. the construction of guide tree is enabled by the `guide
tree miner' plugin that implements the approaches presented in [2, 25]. the
rest of the steps are handled by the `trace alignment with guide tree' plugin.
figure 14 depicts the screenshot of invoking the guide tree miner plugin. this
plugin requires an event log as input. this plugin supports the features dened
in [2, 25] and implements the agglomerative hierarchical clustering algorithm for
the generation of guide tree. apart from the guide tree, this plugin generates
as output,kevent logs (for a chosen number of clusters k), each containing the
4prom is an extensible framework that provides a comprehensive set of tools/plugins for the
discovery and analysis of process models from event logs. see http://www.processmining.org
for more information and to download prom.
23event log
preprocess processed log
build guide treecompute scor-
ing matrices
generate progres-
sive alignment
estimate align-
ment quality
prune and rene
interactive
visualizationtrace alignment
with guide treeguide tree minerfilter plugins
figure 13: prom plugins realizing the framework for trace alignment.
partitioned traces pertaining to that cluster (specifying the number of clusters
kis optional and is handy in cases where the analyst has apriori knowledge
about the diversity in the process/event log). figure 15 depicts the guide tree
generated by this plugin on an event log.
figure 14: invocation of the `guide tree miner' plugin in prom 6.0. the plugin requires an
event log as input.
figure 16 depicts the invocation of the `trace alignment with guide tree'
plugin. this plugin takes as input a guide tree generated by the guide tree miner
24figure 15: visualization of the mined guide tree. the plugin has been congured to split the
log into four clusters (the number of clusters was chosen to be four based on apriori knowledge
on the process. this guide tree is for the telephone repair event log mentioned in section 7).
the pink nodes depict the root of the sub-tree corresponding to the four clusters. the tree
can be expanded (up to two levels deep) by clicking a non-leaf node. blue nodes indicate
nodes that are expanded.
figure 16: invocation of the `trace alignment with guide tree' plugin in prom 6.0. the
plugin requires a guide tree as input.
plugin. the user can congure the options for generating the substitution/indel
scores and rening alignments as illustrated in figure 17. figure 18 depicts the
visualization of the computed alignments. the alignment visualizer provides
rich interactive functionality for the user to explore and gain insights into the
process execution. for example, as illustrated in figure 18, the `view' menu
has options for enabling the sorting or ltering of activities in a column of an
alignment and other options pertaining to how an alignment is rendered. the
analysis menu provides options for rening alignments as well as for uncover-
ing the potential concurrent activities in the process. concurrent activities, if
any, are then notied in a separate panel. furthermore, if an analyst wishes to
manually rene an alignment, there exists a functionality to do so by editing a
25(a) scoring matrices conguration step
(b) rene alignments conguration step
figure 17: a couple of conguration steps of the trace alignment with guide tree plugin.
trace in an alignment as illustrated in figure 18. for a more detailed explana-
tion of the functionality and usage of the plugins, the reader is referred to the
respective plugin's user manual available at the prom repository.
7. case studies and discussion
we present the results of applying trace alignment on three event logs (one
synthetic and two real-life) in the subsequent sections. the synthetic log cap-
tures the process of xing telephone repairs. the goal of using a synthetic log
is to show the capabilities of trace alignment on a process for which complete
information is known. we also show the applicability of trace alignment and
discuss the insights gained on two real-life logs, one from a rental agency and
the other from a municipality.
7.1. telephone repair log
the telephone repair event log [31] consists of 1104 traces, of which only
77 traces are distinct. since duplicate traces add to the complexity of com-
26analysis menu options
editing a trace
view menu options
figure 18: trace alignment visualization with interactive features
puting an alignment without yielding any additional benets, we applied the
trace alignment on these 77 traces (but at the same time maintain the fact that
there exists identical traces in the log). there are 12 event classes viz., register,
analyze defect-start, analyze defect-complete, repair (simple)-start, repair
(simple)-complete, repair (complex)-start, repair (complex)-complete, in-
form user-complete, restart repair-complete, test repair-start, test repair-
complete and archive repair. this is a synthetic log for which complete in-
formation about this process is known. figure 19 depicts the process model
discovered using the alpha mining algorithm [1]. the log consists of cases
where the repair can be classied as a simple or complex one. for our dis-
cussion here, we further distinguish two types of cases based on the diculty
level of repair viz., cases where the telephone repair was easy and cases where it
was dicult (in both simple and complex types). dicult cases required mul-
tiple tries of the repair diagnosis for failing the quality assessment test after a
repair. the goal of this example is to show the diagnostics for a known process.
as mentioned earlier, the guide tree inherently captures the notion of clus-
tering. we have split the event log into four clusters (using the maximal repeat
feature set [25] and the f-score [26] as a measure of similarity; using this feature
set and similarity metric, we were able to obtain the four clusters mentioned
27figure 19: process model discovered using the alpha miner in prom 5.2 for the telephone
repair log
above) and figure 20 depicts the trace alignment for one of the four clusters.
figure 20(i) depicts the original alignment whereas figure 20(ii) depicts the
alignment obtained after the renement using the concurrent activity pruning
and realignment technique (activity fis concurrent in this example). this clus-
ter corresponds to traces where the diculty level was easy and a complex
repair procedure was done to x the problem. the length of the alignment is
14 for this cluster. the left panel depicts the process instance identier (as
in the log) and identiers with a grey background indicate traces that have
identical duplicates. the number within parenthesis indicate the number of
duplicates. for example there are 7 traces identical to process instance 1018
(corresponding to the trace jgcflebd in the event log) while there are no iden-
tical traces for the process instance 11275. the top panel depicts a sorting
component where the traces involved in the alignment can be sorted based on
the activities in a column and the number in the column indicates the priority
of sorting. for example in figure 20(i), the traces are sorted based on activity
f(which indicates the inform user activity) with traces having fin column
4 having rst priority and then with those having fin column 7 and nally
with those having fin column 11. the bottom panel depicts the information
score metric for each column as well as a consensus sequence for the alignment.
the consensus sequence captures the major activity in each column and can be
considered as a back-bone sequence for the process . the consensus sequence for
this example corresponds to jgclebd with an optional execution of activity i
at the end. columns with an information score of 1 :0 indicate well conserved
patterns. for example in this alignment, the columns 1  3 depicting the en-
coded activity sequence jgc(corresponding to activities register-complete ,
analyze (defect)-start andanalyze (defect)-complete ) is well conserved
and appears in all the traces as the beginning subsequence.
it is obvious to see that the encoded activity fcorresponding to inform user -
complete is a concurrent activity. concurrent activity manifests in mutually ex-
clusive traces across dierent columns in the alignment . the encoded activities
l,e,b,dandicorrespond to repair complex-start ,repair complex-complete ,
5the number of identical traces is used when computing the scores during the alignment;
substitution/indels are accounted for mtimes if there are midentical traces
28(a) (b)sort component
identical traces
information score
consensus sequence
jregister-complete ganalyze (defect)-start canalyze (defect)-complete
lrepair complex-start erepair complex-complete btest repair-start
dtest repair-complete finform user-complete iarchive repair-complete
figure 20: trace alignment of traces in telephone repair event log for one of the clusters. (i)
original alignment (ii) concurrency pruned and rened alignment.
test repair-start ,test repair-complete and archive repair-complete
respectively. annotating the traces with additional information such as perfor-
mance metrics, customer feedback etc. over the alignment might give further
insights. for example, let us assume that the customer was not happy for the
cases 1 and 1009, it is obvious to see that these traces dier from the rest in
that the activity fappears quite late in these traces. it could be inferred that
these customers were not timely informed about the status of their complaint
and thus were not satised.
trace alignment provides a complete perspective of activity executions in a log
including that of long range dependencies (any dependencies between activities
are reected as common execution patterns in the traces where they manifest).
furthermore, with rich interactive visualization (such as the options of ltering
columns containing an activity), trace alignment enables a exible inspection of
the log. in this fashion, trace alignment can assist in uncovering extremely in-
teresting insights and act as probes when analyzing process execution behavior.
figure 21 summarizes how trace alignment can assist in answering some of the
diagnostic questions raised in section 2.
29the rest of the 3 clusters for this event log corresponded to the following dif-
culty level and repair type categories: easy and simple ,dicult and complex ,
anddicult andsimple/complex where the last cluster pertained to cases where
a simple repair procedure was rst tried and nally a complex repair procedure
was done to x the problem.
the consensus sequence rep-
resents the backbone of the
processcommon execution patterns are cap-
tured in the form of well conserved
regionsconcurrent activities manifest in mu-
tually exclusive traces across dierent
columns
deviations, exceptional behavior and rare event
executions are captured in regions that are
sparsely lled i.e., regions with lots of gap sym-
bol `-' or in regions that are well conserved with
a few rare gaps.
figure 21: aligned traces for one of the clusters of the telephone repair log with annotations
indicating how trace alignment can assist in answering some of the diagnostic questions.
7.2. rental agency log
we have applied trace alignment on a real life log of a rental agency where
the cases corresponded to the cancellation of a current rental agreement and
subsequent registration of a new rental agreement. this log was provided by
a large dutch agency that rents houses and apartments (the organization has
approximately 1000 employees and handles 80 ;000 houses). there are 74 event
30classes, one event type (transaction type, complete), 210 process instances and
6100 events in this log. as we can see, this is a reasonably complex log in terms
of the size of the alphabet and the number of cases. this process is less struc-
tured and is not well understood (figure a.25(a) depicts the heuristic net and
figure a.25(b) depicts the dotted chart mined using the log. it is not easy to
unravel the mined results and provide answers to some of the questions raised
in this paper). we now show how trace alignment can assist in uncovering inter-
esting insights from this log. the traces are rst encoded into activity sequences
where each activity is encoded as a two character sequence.
a5a9e9a5 e6c1
f0f5c4 h3 e6c1b7
g6 d4b1e7g6d4a7a7
h2b2
figure 22: trace alignment of the traces in one of the clusters of the rental agency log.
figure 22 depicts the alignment for one of the four clusters of this log. since the
whole alignment is not legible6, we highlight the interesting patterns/activities
(that we refer to for our further discussion) at the top and the bottom of the
gure. the length of the alignment is 71. at the outset, we can see certain com-
mon execution patterns in the form of well conserved regions (columns) in the
alignment. for example, the activity sequence b0e0a5 (at columns 5 7) corre-
sponding to the activities, planning of first inspection ,preparation of
lease termination form , and is first inspection performed? respectively
is common across all the traces. deviations, exceptional behavior and rare event
executions are captured in regions that are sparsely lled i.e., regions with lot of
gap symbols ( ). we will present the results of analysis of some of these devia-
6the actual alignment can be inspected at www.win.tue.nl/ ~jcbose/
miningalignmentanalysis.png
31tions. it could be seen that only one of the traces (sixth trace in the alignment)
has the activity subsequence a9e9a5 in columns 8 10. activity a5in column 7
corresponds to the check, is first inspection performed? and the activity
subsequence a9e9a5 corresponds to the scenario where the result of the check
was negative due to the fact that the tenant was not at home. a9corresponds to
the activity of sending a letter to the tenant and e9corresponds to the activity
of rescheduling the rst inspection.
the activity sequence f0f5 corresponding to the checks is final inspection
done? (f0), and are there new/repaired defects? (f5) is well conserved
across all but one of the traces . we see an exceptional activity sequence e6c1
corresponding to the oering of a at in one of the traces (rst trace) before
the activity sequence f0f5 . it is strange that a at was oered before the -
nal inspection was done as in all the other traces where the at was oered,
it happened subsequent to the nal inspection. upon further inspection, we
observed that though the at was oered, the actual registration/check of the
candidate corresponding to activity b7happened subsequent to the nal inspec-
tion. furthermore, in all the cases where the at was oered and the candidate
registered, the activity sequence d6c1b7 was well conserved except for the rst
trace. trace alignment helps us uncover such anomalies and deviations. sim-
ilarly, we notice that in only one of traces (fth trace) there was a need for
second inspection (activity c4corresponds to the planning of second inspection
andh3corresponds to the check, is second inspection done? ).
the activity e7corresponds to the determination of a candidate tenant and
the activities g6and d4correspond to registration of lease, and getting the
payment and signing of contract respectively. it could also be observed from
the alignment that there is an exceptional behavior in one of the cases where
we see a manifestation of the activity subsequence g6d4b1e7g6d4 subsequent
to activity e7(the activity e7appears twice in this trace). this indicates the
fact that for this case, there was a need for determining the candidate tenant
twice. the determination of the second candidate tenant followed the activity
b1which corresponds to the termination of provisional lease (the provisional
lease was terminated due to nonpayment by the tenant).
furthermore, the activities h2b2 corresponding to the drafting of final note
andarchiving of lease termination is concurrent in this process (as is ev-
ident from the fact that they manifest in dierent columns across mutually ex-
clusive rows in the alignment). figure 23 summarizes how trace alignment can
assist in answering some of the diagnostic questions. the alignments pertaining
to the other clusters also exhibited similar behavior.
7.3. municipality log
we have applied trace alignment on another real life log pertaining to one of
the dutch municipalities where the cases correspond to the processing of build-
ing permit requests. this process is less structured and is not well understood.
32common execution patterns are
captured in the form of well con-
served regionsconcurrent activities manifest in mu-
tually exclusive traces across dierent
columns
the consensus sequence represents
the backbone of the processdeviations, exceptional behavior and rare event ex-
ecutions are captured in regions that are sparsely
lled i.e., regions with lots of gap symbol `-' or in
regions that are well conserved with a few rare gaps.
figure 23: aligned traces for one of the clusters of the rental agency log with annotations
indicating how trace alignment can assist in answering some of the diagnostic questions.
there are 45 event classes, one event type, 2075 process instances, 11582 events
and 71 originators in this event log. as we can see, this is a complex log in
terms of the size of the alphabet and the number of cases (figure a.26(a) de-
picts the heuristic net and figure a.26(b) depicts the dotted chart mined using
the log. the answers to questions raised in this paper is not explicit using the
mined results.). the event log is rst encoded into traces where each activity is
encoded with a unique character. though there are 2075 process instances in
the event log, when encoded as traces, there are only 451 unique traces.
figure 24 depicts the alignment for one of the six clusters of this log. this
cluster has 51 traces. we can see certain common execution patterns such as
yfj,stand dcramong the traces. all the cases start with ycorresponding
to the activity case start . each case is then processed by three dierent de-
partments viz., l(re department), h(environment department) and c(cct)
to verify for the admissibility of the building permit. it is to be noted that
these three activities are concurrent as they manifest across dierent columns
in mutually exclusive rows.
deviations, exceptional behavior and rare event executions are captured in re-
33missing activity l
missing activity sactivity kafter
activity d
figure 24: trace alignment of the traces in one of the clusters of the municipality log
gions that are sparsely lled i.e., regions with lots of gap symbol `-' or in regions
that are well conserved with a few rare gaps. we can notice that in one of
the traces, the activity lis missing indicating that the case was not handled
34by the re department which is a violation of the normal behavior. in another
trace (sixth trace from the top), we notice that the case was referred to these
departments multiple times (three times). once the responses from the three
departments are obtained, the contents are veried (activity s) and a decision
is prepared (activity t). we see an exception to this behavior in one of the
traces where the decision is prepared without the verication (activity tman-
ifests without s). furthermore, in some cases, an optional legal decision is also
taken (activity p).
activity bcorresponds to the decision that no construction is permitted for
one year whereas activity dcorresponds to the rejection of the request. we see
an exceptional behavior in one of the cases that has been rejected{activity k
which corresponds to taxes occurs after the rejection dwhereas in all the other
cases where it had been rejected either kis not present or if present, kalways
occurs before d. in this fashion, trace alignment can assist in uncovering ex-
tremely interesting insights.
the diagnostic question, what are the process instances that share/capture a
desired behavior either exactly or approximately? , can be answered using trace
alignment by formulating the desired behavior as an activity sequence and ap-
plying trace alignment of this sequence with the traces in the log. traces that
share the desired behavior have a lot of their activities aligned with that of the
activities in the desired behavior sequence.
8. computational complexity
the major computation steps in the proposed approach pertains to the com-
putation of guide tree and the progressive alignment of traces. as discussed
earlier, we use the agglomerative hierarchical clustering algorithm to build the
guide tree, which can be informally described as comprising of the following
steps:
step 1. determine all inter-object dissimilarities i.e., determine the dis-
tance between every pair of traces
step 2. form cluster from two closest traces or clusters
step 3. redene dissimilarities between new cluster and other traces or
clusters (all other inter-object dissimilarities remain unchanged).
step 4. return to step 2 until all traces are in one cluster.
the hierarchy involves the construction of n 1 clusters, and so n 1 iterations
(steps 2, 3, and 4). step 1 above requires o(n2) calculations, i.e., n(n 1)=2)
inter-trace dissimilarities, where nis the number of traces. the distance between
the traces can be computed either by dening some features and transforming
each trace into a vector space dened by the features or by using syntactic
35edit distance approaches. we use the vector-space approach to compute the
distances because edit distance approaches are time consuming in that it takes
quadratic time (with respect to the length of the traces) to compute the distance
between a pair of traces. in the vector-space approach, the number of variables
(features) obviously eects the calculation time required, but they are usually
considered constant for any set of data. a naive attempt at step 2 will make
the algorithmo(n3) complex as the minimum of an n2matrix must be found
in each of the n 1 iterations. however, this can be reduced to o(n2) by main-
taining a pointer to the minimum value in each row of the matrix. step 3 can
be carried out in o(n) time using the lance{williams combinatorial formula
[32, 33]. in summary, the guide tree can be constructed in o(n2) time. in all
our case studies, we have used the combination of 3  gram and maximal repeats
[25] as the feature set. the choice of this feature set is primarily because they
are context-aware and process-centric and is shown to perform better when
compared to other approaches [2, 25]. we split the overall time to build the
guide tree into the time to (a) extract the features (b) compute the inter-trace
distance using the features (step 1) and (c) form the hierarchy i.e., grouping
objects (steps 2, 3, and 4). table 1 depicts the computational time (on an i3
core cpu m350 @ 2.27 ghz with 4gb ram running a 64-bit windows 7 os)
required to compute the guide tree for the three case studies. as can be seen,
the feature extraction and the computation of inter-trace dissimilarities are the
major time consuming portions and the grouping of objects is just a fraction
of these. one can slightly reduce the inter-trace dissimilarity computation time
by ltering some features that are insignicant (based on frequency etc.).
the time and space complexity of a single iteration of progressive alignment
iso(l2+nl) [26] where lis the average length of the traces/proles considered
for alignment and nis the number of traces involved in the alignment. there ex-
istsn 1 iterations in the progressive alignment thus making the alignment time
to be polynomial. however, it is to be noted that during the initial iterations,
the value of nis much smaller than the total number of traces. furthermore,
unless the traces to align are heterogeneous the length of the aligned traces tends
to be closer to the average trace length of the input traces. table 1 depicts the
computational time required to align the traces for the three case studies. it
can be seen that the overall alignment can be performed in manageable times
even for large datasets.
9. outlook
finding good quality alignments is notoriously complex. in this section, we
highlight some of the extensions that can be done to further improve the results
of trace alignment. we also mention some of the challenges related to trace
alignment and directions for future research.
multi-phase approach: in order to deal with complex event logs (logs with
a large number of activities/event classes etc.), one can try to nd align-
36log no. no. guide tree using ahc progressive
unique
tracesfeatures feature
extractioninter-
object
distancegrouping
objectsalignment
(msecs) (msecs) (msecs) (msecs)
repair example 77 167 1158308 709 3114 35235
rental agency 210 1415 1542450 25221 780 3865243
municipality 451 1234 1209155 101843 28417 5297400
table 1: computational time required to build the guide tree and align the traces. the
notation used for time is twheretis the mean time over 5 dierent runs and is the 95%
condence interval.
ments in a multi-phase approach. the basic idea is to rst simplify the
log by dening abstractions over the activities and then transforming the
log with these abstractions. sub-logs are created for each abstract activity
during this transformation. trace alignment is then applied on the most
abstract log with a provision to zoom into an abstract activity. upon
zooming into an abstract activity, an alignment obtained on the traces
dened in the sub-log of the abstract activity is shown. the denition
of abstractions and simplication of logs can be enabled by incorporating
semantics in the log specication [31, 34] or through (semi-)automated
means as in [30, 35].
outlier/noise detection: noisy data pose a risk of misleading the align-
ment procedure and thereby resulting in low quality alignments. there
is a need for techniques to identify dicult or even un-alignable sets of
traces. for certain perspectives of analysis such as nding common exe-
cution patterns, backbone/critical elements of a process, such traces can
be safely ignored. however, for certain other perspectives such as nd-
ing deviations/non-conforming traces, it is a tricky proposition to lter
outliers as non-conforming traces could be treated as outliers. ecient
techniques for noise detection and ltering and identifying coherency in
event logs need to be explored and one can take leverage of the techniques
in data mining and machine learning community and adapt them (if need
be) by providing a process tinge to them.
renement strategies to improve the quality of an alignment: in this pa-
per, we have presented three dierent renement techniques to deal with
misplaced gaps. however, robust quality metrics along with realignment
strategies to eectively deal with the variations that might arise due to
the manifestation of dierent process model constructs is highly desirable.
dening and identifying problematic regions in an alignment is a prereq-
uisite to any renement technique. automated means of identifying such
problematic regions is non-trivial and is in itself an interesting area of
research.
37advanced alignment techniques: the progressive alignment approach adopted
in this paper is susceptible to converging at local optima. this is due to the
fact that when aligning an individual trace with an alignment, the trace
is not aligned directly and optimally with every internal trace within the
alignment but with the whole alignment taken as an atomic entity. gaps in
the resulting alignment are inserted into the sequence, or as a column into
the sub-alignment as a whole, but are not optimally distributed through-
out the resultant alignment. as discussed in section 5, the splitting up
of common patterns of execution is an eect of such local optima. recent
advances in multiple sequence alignment such as the one that takes into
consideration some user dened constraints [36] while performing an align-
ment need to be explored. one can specify the conservation of common
execution patterns in the nal alignment as a constraint. such common
execution patterns can be discovered automatically [30]. other techniques
such as the partial-order alignment [37] and the hybrid approach combin-
ing the progressive and partial-order alignments [38] have been shown to
produce better alignments.
10. related work
trace alignment is a log visualization technique that assists in uncovering
interesting insights in process executions. dotted chart analysis [11] is one of
the most commonly used log visualization technique. dotted chart analysis,
analogous to gantt charts, presents a \helicopter view" of the event log and
assists in analyzing process performance by depicting process events in a graph-
ical way and primarily focuses on the time dimension of events. the dotted
chart analysis computes some metrics for performance such as the minimum,
maximum and average interval between events. a business analyst needs to
manually investigate the dotted chart to identify any potential performance is-
sues. for logs with medium to large number of activities (of the order of a
few tens to hundreds), the manual inspection and comprehension of the dotted
chart becomes cumbersome and often infeasible to identify interesting patterns.
trace alignment alleviates this problem, by nding those patterns automatically
and presenting them to the user. in the parlance of dotted chart analysis, trace
alignment considers the logical relative time perspective of the event log. fur-
thermore, it would be simple and a natural extension to project the performance
metrics proposed in [11] onto the aligned traces.
stream scope visualization [39] is a trace visualization technique that is based
on the event class correlations. using stream scope visualization, patterns of
co-occurring events can be easily recognized by their vicinity. however, stream
scope visualization is restricted in that it visualizes each trace separately and
does not provide a holistic view of the event log. in contrast, trace alignment
enables the visualization of multiple traces at a time and is able to uncover
common execution patterns within and across traces.
38one of the applications of trace alignment is in uncovering deviations between
anomalous and normative traces. conformance checking aims at detecting in-
consistencies/deviations between a process model (that captures the expected
behavior) and its corresponding execution log [40]. conformance checking has
inherent limitations in its applicability especially for diagnostic purposes. firstly,
it assumes the existence of a process model. however, in reality, process mod-
els are either not present or if present are incorrect or outdated (their quality
typically leaves much to be desired). one can argue that process models can
be discovered from the event logs and conformance checking be applied on the
discovered models. however, this approach is not suitable for the analysis of
highly complex and/or exible processes, the class of models which most of the
real-life logs fall into and where the discovered models are \spaghetti-like". even
in cases where the process models are available , it is dicult to look inside of
the processes to identify and locate problems especially with models that are
large. trace alignment is complementary to this approach in that it highlights
the deviations by analyzing the raw event traces (avoiding the need for process
models).
trace alignment is largely inspired from multiple sequence alignment (msa)
[5]. however there are challenges in adapting these techniques for trace align-
ment. alignment of biological sequences typically happen over homologous se-
quences and with less variation in length [18]. however, traces in an event
log in process mining need not be from a coherent set of cases and can be of
dierent lengths. variation in lengths can occur due to variation in execution
paths of the instances and due to manifestation of process model constructs such
as choice/loop constructs. in biological sequence alignment, there are standard
scoring matrices for substitution that are derived based on physio-chemical prop-
erties of the amino acids. insertion/deletion operations are primarily considered
either with a constant gap-score (or penalty) or as an ane function. in con-
trast, indel operation in trace alignment is context sensitive (insertion/deletion
of an activity given its left activity, indelrightgivenleft ). scoring matri-
ces for trace alignment need to be derived automatically from the event log or
provided by the domain experts. furthermore, biological sequences deal with
an alphabet size of either 4 (for four nucleic acids) or 20 (for amino acids).
however, the number of distinct activities (event classes) in a typical process
mining log can be of the order of a few hundreds. this adds to the complexity
of deriving good scoring matrices and aligning traces. we took inspiration from
msa techniques [20, 21, 41] and adapted them for trace alignment.
the quality of the nal alignment over a set of traces largely depends on the
order in which the progressive alignment is performed. we have used the ag-
glomerative hierarchical clustering to group traces so that homogenous traces are
aligned in the early iterations of the progressive alignment. context-aware ap-
proaches to trace clustering are shown to form more coherent clusters [2, 25, 24].
however, the choice of the feature set largely depends on the domain and the
context of analysis [24]. similarly, the resulting clusters also depend on the
39choice of the distance/similarity metric e.g., if the input data have elliptical
distributions, then the mahalanobis distance [42] is preferred over euclidean
distance. the inuence of a distance/similarity metric on the formed clusters
and thereby on trace alignment is an interesting topic that needs further research
and is beyond the scope of this paper.
11. conclusions
in this paper, we proposed a novel approach of aligning traces and showed
that this approach uncovers interesting patterns and assists in getting better
insights on process execution. we have listed some of the interesting questions
in process diagnostics and showed how trace alignment can help in diagnostic
eorts. this paper extends the work presented in [43]. in this extended pa-
per, we discussed the various scenarios of misalignment and their impact on the
resulting alignment. a metric that measures the degree of misalignment and
three renement techniques to cope with misalignments have been proposed.
the approach has been implemented in prom and evaluated using three case
studies. this is just a rst step in this direction. due to the computational
complexity of multiple trace alignment, automatic generation of high-quality
alignments is still challenging and there is much to be done to fully exploit the
potential of this approach. moreover, to further validate the approach we plan
to conduct extensive case studies based on real-life event logs.
acknowledgments r. p. j. c. bose and w. m. p. van der aalst are grateful
to philips healthcare for funding the research in process mining.
references
[1] w. m. p. van der aalst, a. j. m. m. weijters, l. maruster, workow
mining: discovering process models from event logs, ieee transactions
on knowledge and data engineering 16 (9) (2004) 1128{1142.
[2] r. p. j. c. bose, w. m. p. van der aalst, context aware trace clustering:
towards improving process mining results, in: proceedings of the siam
international conference on data mining, sdm, 2009, pp. 401{412.
[3] m. s. waterman, introduction to computational biology: maps, sequences
and genomes, chapman & hall/crc, 2000.
[4] s. chan, a. k. c. wong, d. chiu, a survey of multiple sequence com-
parison methods, bulletin of mathematical biology 54 (4) (1992) 563{598.
[5] o. gotoh, multiple sequence alignment: algorithms and applications,
advanced biophysics 36 (1999) 159{206.
[6] j. d. thompson, b. linard, o. lecompte, o. poch, a comprehensive
benchmark study of multiple sequence alignment methods: current chal-
lenges and future perspectives, plos one 6 (3) (2011) e18093.
40[7] m. r. aniba, o. poch, j. d. thompson, issues in bioinformatics bench-
marking: the case study of multiple sequence alignment, nucleic acids
research 38 (21) (2010) 7353{7363.
[8] c. kemena, c. notredame, upcoming challenges for multiple sequence
alignment methods in the high-throughput era, bioinformatics 25 (19)
(2009) 2455{2465.
[9] j. d. thompson, o. poch, new challenges and strategies for multiple
sequence alignment in the proteomics era, in: j. m. walker (ed.), the
proteomics protocols handbook, springer, 2005, pp. 475{492.
[10] k. m. kjer, u. roshan, j. g. gillepie, structural and evolutionary consid-
erations for multiple sequence alignment of rna, and the challenges for
algorithms that ignore them, in: m. s. rosenberg (ed.), sequence align-
ment: methods, models, concepts and strategies, univeristy of california
press, 2009, pp. 105{150.
[11] m. song, w. m. p. van der aalst, supporting process mining by showing
events at a glance, in: proceedings of the 17th annual workshop on
information technologies and systems (wits), 2007, pp. 139{145.
[12] w. m. p. van der aalst, a. h. m. ter hofstede, b. kiepuszewski, a. p. bar-
ros, workow patterns, distributed and parallel databases 14 (1) (2003)
5{51.
[13] s. needleman, c. wunsch, a general method applicable to the search
for similarities in the amino acid sequences of two proteins, journal of
molecular biology 48 (1970) 443{453.
[14] h. carillo, d. lipman, the multiple sequence alignment problem in bi-
ology, siam journal of applied mathematics 48 (5) (1988) 1073{1082.
[15] d. bacon, w. anderson, multiple sequence alignment, journal of molec-
ular biology 191 (1986) 153{161.
[16] r. durbin, s. eddy, a. krogh, g. mitchison, biological sequence analysis:
probabilistic models of proteins and nucleic acids, cambridge university
press, 2002.
[17] l. wang, t. jiang, on the complexity of multiple sequence alignment,
journal of computational biology 1 (4) (1994) 337{348.
[18] c. notredame, recent progress in multiple sequence alignment: a survey,
pharmacogenomics 3 (2002) 131{144.
[19] r. c. edgar, s. batzoglou, multiple sequence alignment, current opinion
in structural biology 16 (2006) 368{373.
41[20] d. feng, r. doolittle, progressive sequence alignment as a prerequisite
to correct phylogenetic trees, journal of molecular evolution 25 (1987)
351{360.
[21] d. feng, r. doolittle, progressive alignment of amino acid sequences and
construction of phylogenetic trees from them, methods in enzymology
266 (1996) 368{382.
[22] a. k. jain, r. c. dubes, algorithms for clustering data, prentice-hall,
inc., upper saddle river, nj, usa, 1988.
[23] j. h. ward, hierarchical grouping to optimize an objective function,
journal of the american statistical association 58 (1963) 236{244.
[24] g. greco, a. guzzo, l. pontieri, et al., discovering expressive process
models by clustering log traces, ieee transactions on knowledge and data
engineering (2006) 1010{1027.
[25] r. p. j. c. bose, w. m. p. van der aalst, trace clustering based on
conserved patterns: towards achieving better process models, in: pro-
ceedings of bpm workshops, vol. 43 of lnbip, 2009, pp. 170{181.
[26] r. c. edgar, muscle: a multiple sequence alignment with re-
duced time and space complexity, bmc bioinformatics 5 (2004) 113.
doi:10.1186/1471-2105-5-113.
[27] m. simonsen, t. mailund, c. n. s. pedersen, rapid neighbor-joining, in:
algorithms in bioinformatics, 2008, pp. 113{122.
[28] l. ghionna, g. greco, a. guzzo, , l. pontieri, outlier detection tech-
niques for process mining applications, in: proceedings of the 17th in-
ternational symposium on methodologies for intelligent systems (ismis),
springer-verlag, 2008, pp. 150{159.
[29] mining usage scenarios in business processes: outlier-aware discovery
and run-time prediction, tech. rep., universit della calabria.
url http://biblio.cs.icar.cnr.it/tr/scaricatr.asp?fileid=84
[30] r. p. j. c. bose, w. m. p. van der aalst, abstractions in process mining:
a taxonomy of patterns, in: proceedings of the international conference
on business process management (bpm), vol. 5701 of lncs, 2009, pp.
159{175.
[31] a. k. a. de medeiros, w. m. p. van der aalst, process mining towards
semantics, in: advances in web semantics-i, 2008, pp. 35{80.
[32] f. murtagh, a survey of recent advances in hierarchical clustering al-
gorithms, the computer journal 26 (4) (1983) 354{359.
[33] g. n. lance, w. t. williams, a general theory of classicatory sorting
strategies, the computer journal 9 (1967) 373{380.
42[34] a. k. a. de medeiros, w. m. p. van der aalst, c. pedrinaci, semantic
process mining tools: core building blocks, in: 16th european conference
on information systems, 2008, pp. 1953{1964.
[35] j. li, r. p. j. c. bose, w. m. p. van der aalst, mining context-dependent
and interactive business process maps using execution patterns, in: m. zur
muehlen, j. su (eds.), bpm 2010 workshops, vol. 66 of lnbip, springer-
verlag, 2011, pp. 109{121.
[36] b. morgenstern, s. j. prohaska, d. p ohler, p. f. stadler, multiple sequence
alignment with user-dened anchor points, algorithms for molecular bi-
ology 1 (6) (2006) 1{12.
[37] c. lee, c. grasso, m. f. sharlow, multiple sequence alignment using
partial order graphs, bioinformatics 18 (3) (2002) 452{464.
[38] c. grasso, c. lee, combining partial order alignment and progressive
multiple sequence alignment increases alignment speed and scalability
to very large alignment problems, bioinformatics 20 (10) (2004) 1546{
1556.
[39] c. w. g unther, process mining in flexible environments, ph.d. thesis,
eindhoven university of technology (2009).
[40] a. rozinat, w. m. p. van der aalst, conformance checking of processes
based on monitoring real behavior, information systems 33 (1) (2008)
64{95.
[41] c. daniel, d. paul, m. vidhya, o. marco, h. eun-jong, w. yaoyu, s. shya-
mal, c. brian, p. shobha, h. enoch, pfaat version 2.0: a tool for
editing, annotating, and analyzing multiple sequence alignments, bmc
bioinformatics 8 (1) (2007) 381.
[42] p. c. mahalanobis, on the generalized distance in statistics, in: pro-
ceedings of the national institute of sciences of india, vol. 2, 1936, pp.
49{55.
[43] r. p. j. c. bose, w. m. p. van der aalst, trace alignment in process
mining: opportunities for process diagnostics, in: proceedings of the in-
ternational conference on business process management (bpm), vol. 6336
of lncs, 2010, pp. 227{242.
43appendix a. appendix
(a) heuristic net
(b) dotted chart mined using the logical relative time perspective
figure a.25: (a) heuristic net and dotted chart mined using the rental agency event log
44(a) heuristic net
(b) dotted chart mined using the logical relative time perspective
figure a.26: heuristic net and dotted chart mined using the municipality event log
45