object-centric behavioral constraint models: a hybrid model
for behavioral and data perspectives
guangming li
eindhoven university of technology
eindhoven, the netherlands
g.li.3@tue.nlrenata medeiros de carvalho
eindhoven university of technology
eindhoven, the netherlands
r.carvalho@tue.nlwil m.p. van der aalst
rwth aachen university
aachen, germany
wvdaalst@pads.rwth-aachen.de
abstract
in order to maintain a competitive edge, enterprises are driven to
improve efficiency by modeling their business processes. existing
process modeling languages often only describe the lifecycles of
individual process instances in isolation. although process models
(e.g., bpmn and data-aware petri nets) may include data elements,
explicit connections to realdata models (e.g., a uml class model)
are rarely made. therefore, the object-centric behavioral constraint
(ocbc) modeling language was proposed to describe the behavioral
and data perspectives, and the interplay between them in one single,
hybrid diagram. in this paper, we describe ocbc models and in-
troduce the extended interactions between the data and behavioral
perspectives on the attribute level. we implement the approach in
a plugin and evaluate it by a comparison with other models.
ccs concepts
•applied computing →enterprise computing ;business pro-
cess management; business process modeling;
keywords
business process modeling, object-centric, databases, class mod-
els, object models, declarative constraints
acm reference format:
guangming li, renata medeiros de carvalho, and wil m.p. van der aalst.
2019. object-centric behavioral constraint models: a hybrid model for
behavioral and data perspectives. in proceedings of acm sac conference,
limassol, cyprus, april 8-12, 2019 (sac’19), 9 pages.
https://doi.org/10.1145/3297280.3297287
1 introduction
information systems are widely used by enterprises and organi-
zations to support their business process executions. currently,
the information systems one encounters in most organizations are
object-centric, i.e., transactions related to some type of objects (e.g.,
customer orders) are stored in the same database table (e.g., the
“order” table) on data perspective, and events are recorded implic-
itly (e.g., in redo logs) and separately without a common case id.
some examples of these systems are customer relationship man-
agement (crm) and/or enterprise resource planning (erp) which
permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. copyrights for third-party components of this work must be honored.
for all other uses, contact the owner/author(s).
sac’19, april 8-12, 2019, limassol, cyprus
©2019 copyright held by the owner/author(s).
acm isbn 978-1-4503-5933-7/19/04. . .$15.00
https://doi.org/10.1145/3297280.3297287provide business functions such as procurement, production, sales,
delivery, finance, etc. in this paper, we abstract business processes
on such systems as three perspectives: control-flow (i.e., the be-
havioral perspective), data schema (i.e., the data perspective) and
communications (indicating how activities in control-flow impact
the corresponding tables in databases) in between, as shown in
figure 1.
control-flow data schema
communications 
modeling
3.delivery
4.invoice               
5.payment1.customer
order      2.order
fulfilment
figure 1: a business process on object-centric information
systems can be modeled as three perspectives: control-flow,
data schema and communications.
existing process modeling languages (bpmn diagrams [ 11], petri
nets [ 27], epcs) assume a case notion in business processes, which
is used to correlate events for a specific process instance. they
work well on process-centric systems such as wfm/bpm systems,
but have problems to describe object-centric systems which do not
assume a case notion. besides, they focus on the behavioral per-
spective, although some models have data elements. for instance,
in bpmn diagrams and data-aware petri nets (dpns) [ 13], activ-
ities can write/read data elements (variables and objects), which
describe the data perspective and the interactions. however, the
more powerful notations used in data modeling language (e.g.,
a uml class model [ 8]) are rarely employed. artifact-centric ap-
proaches [ 7,12,23] are state-of-the-art to solve these problems.
however, they still force one to pick an instance notion for each
artifact, although a case notion for the whole process is not re-
quired. moreover, they can indeed model the data perspective but
the control-flow cannot be related to an overall data model (i.e.,
there is no explicit data model or it is separated from the control-
flow) and interactions between different entities are not visible
(because artifacts are distributed over multiple diagrams) [16].
the proposed object-centric behavioral constraint (ocbc) mod-
eling language [ 2,17] combines ideas from declarative, constraint-
based languages like declare [3], and from data/object modeling
techniques (er, uml, or orm), resulting in ocbc models as shown
48add order 
linecreate order  
draftdisplay  
order
rt1 rt2delete order 
line
productaoc1 aoc2 aoc3 aoc4 aoc5 aoc6c1c2 c3
cr1 cr2 cr3activitybehavioral 
constraint indicating the 
reference activityindicating the scope of 
effects of a constraint 
indicating 
how  activities 
impact
 classesaoc 
relationships 
between 
activities and 
classes
object 
classclass relationship
order order line
sql queries 
(insert , update , 
delete , read )control-flow
data schemacommunications
3.delivery
4.invoice               
5.payment1.customer
order      2.order
fulfilmentfigure 2: an ocbc model to describe the “order” module of the real information system dolibarr.
in figure 2. this paper extends the ocbc modeling language, allow-
ing the definition of attributes for entities (i.e., classes and activities).
the communications perspective is strengthened with the anno-
tation of an interaction type (i.e., add, update, delete or read) and
the possibility to describe interactions on the attribute level. be-
sides, a model editor is available to support ocbc models to design
business processes.
the remainder is organized as follows. section 2 briefly intro-
duces ocbc models based on a running example. section 3 employs
class models to describe the data schema. activity models are de-
fined in section 4 to describe the restrictions between activities
through declarative constraints. section 5 illustrates ocbc models
to combine the above two models. a plugin for designing ocbc
models is introduced in section 6 and section 8 concludes the paper.
2 running example
figure 2 shows an ocbc model example, which describes the busi-
ness process of the “order” module in the real information system
dolibarr.1the model consists of a class model (three classes or-
der, order line and product, and two class relationships rt1and
rt2) at the bottom, an activity model (four activities display order,
create order draft, add order line anddelete order line, and three con-
straints c1,c2andc3) at the top, and six interaction relationships
(i.e., aoc1,...,aoc6) in between. more precisely, the class model de-
scribes the data schema of a database with three related tables, e.g.,
the class “order” corresponds to an “order” table and rt1indicates
the “order line” table refers to the “order” table. four activities and
the constraints indicate the control-flow of the business process. for
instance, c1means that only after executing the “create order draft”
activity, the “display order” activity can be executed (cf. section 4).
whenever an activity is executed, an event (an instance of the
activity) occurs. it may add ( ⊕), update (⊘), delete (⊖) or read ( #)
records in databases. the forms of interactions (indicated by the
different “circle” symbols) show how events impact databases. for
instance, aoc2means one “create order draft” event adds one record
1dolibarr erp/crm is an open source (webpage-based) software package
(www.dolibarr.org).in the “order” table. note that activities and classes have attributes
and interactions can happen on the attribute level by defining a
mapping between attributes (cf. section 5).
note that, in [ 2,17] ocbc models include cardinality constraints
on class relationships and interaction relationships. in this paper, we
focus on the attribute level of ocbc models, and hide the cardinality
constraints for simplicity.
3 modeling the data perspective
databases serve as the backbone of object-centric information sys-
tems by storing all transactions happened in the business processes
supported by these systems. therefore, the structure of databases
should be consistent with the corresponding business processes. as
mentioned, object-centric information systems store transactions
of the same type in the same database table, e.g., all the orders are
stored in the “order” table, as shown in figure 3. in this paper, we
useclasses to represent tables and class relationships to represent the
dependency relationships between tables. classes have attributes
as tables have columns, and class relationships connect attributes
of classes like that dependency relationships connect foreign keys
and primary keys of tables. by integrating the elements mentioned
above, we define a class model to describe the structure of databases,
referring to the notations in [26].
definition 3.1 (class model). letuocbe the universe of object
classes,urtbe the universe of classes relationship types,uattrbe
the universe of attribute names anduvalbe the universe of attribute
values. a class model is a tuple clam =(oc ,attr ,rt ,key ,addi ,
val ,rel)such that
•oc⊆u ocis a set of object classes,
•attr⊆u attris a set of attribute names,
•rt⊆u rtis a set of class relationship types,
•key∈oc→p(attr)\{∅} maps each class onto a set of key
attribute names,2
•addi∈oc→p(attr)maps each class onto a set of addi-
tional attribute names ( key(oc)∩addi(oc)=∅for any class
2p(x)is the power set of x, i.e.,y∈p(x)ify⊆x.
49order (o)
id creation_date customer
o1 2017- 08-11 10:33:37 c1
o2 2017- 08-13 16:28:15 c1
order line ( ol)
id order product quantity price
ol1 o1 phone 2 1190
ol2 o1 cup 4 1
ol3 o2 cup 3 1
ol4 o2 phone 2 1190rt1product(p)
name quantity warehouse
phone 84 paris
cup 99 nice
rt2figure 3: a database with three tables.
oc∈oc). let attr oc=key(oc)∪addi(oc)be a shorthand to
obtain the key and additional attributes of a class.
•val∈attr→p(u val)maps each attribute onto a set of
possible values,
•rel∈rt→(oc×oc)specifies the two classes involved
in a relation. let rel(rt)=(c1,c2)for relationship rt∈rt:
rel1(rt)=c1andrel2(rt)=c2are shorthand forms to obtain
the two individual classes involved in the relationship.
uclam is the universe of class models.
order line 
id:id
order:id
product:text
quantity:integer
price: euro
order  
id:id
creation_date:date
customer: id
product
name:text
quantity:integer
warehouse:text
rt2rt1
figure 4: a class model with attributes
figure 4 shows a class model which describes the database
in figure 3. more precisely, oc={order ,product ,order line}in-
dicates all the tables in the database while rt={rt1,rt2}con-
tains all the dependency relationships between tables. each class
has key attributes indicated by keyand additional attributes in-
dicated by addi, e.g, key(product)={name}andaddi(product)=
{quantity,warehouse}.
a class model abstracts a database in a conceptual way. in other
words, it defines a space of possible objects. in this paper, we use
the term object to abstract a record in database tables. an object can
be considered as an instance of a class, instantiating all attributes of
the class. for example, a record o1in the “order” table (the first row)
in figure 3 can be considered as an object of class “order”. each
value (e.g., “c1”) in the record can be considered as an attribute of
the object.
definition 3.2 (object model). letclam =(oc ,attr ,rt ,key ,
addi ,val ,rel)be a class model and mclam={map∈attr↛uval|
∀attr∈dom(map):map(attr)∈val(attr)}be the set of map-
pings of clam .oclam={(oc,map)∈oc×mclam|dom(map)=attr oc}is the set of all objects of clam .onull={(oc,map null)|oc∈
oc∧map null∈∅→u val}is the set of inexistent (uninitialized)
objects. an object model of clam is a set of objects om⊆oclam.
letvom be the set of valid object models of clam .om∈vom
if and only if ∀(oc,map),(oc,map′)∈oclam:((∀attr∈key(oc):
map(attr)=map′(attr))⇒ map =map′), i.e., key values must be
unique.
product
name:phone
quantity:84
warehouse:paris
product
name:cup
quantity:99
warehouse:nice
order line 
id:ol1
order_id:o1
product:phone
quantity :2
price: 1190
order line 
id:ol2
order_id:o1
product:cup
quantity :4
price: 1
order line 
id:ol3
order_id:o2
product:cup
quantity :3
price: 1
order line 
id:ol4
order_id:o2
product:phone
quantity :2
price: 1190
order 
id:o1
creation_date:t1
customer_id:c1
order 
id:o2
creation_date:t2
customer_id:c1
figure 5: an object model with attributes.
an object(oc,map)assigns a proper value to each attribute
of its corresponding class oc, indicated by map. for instance, the
first record in the “product” table in figure 3 can be formalized
as(oc,map)where oc=product ,dom(map)={name ,quantity,
warehouse}, and map(name)=phone ,map(quantity)=84and
map(warehouse)=paris . an object model is a set of objects and it
is valid if each object has a unique id, i.e., there do not exist two
objects which have the same value for each key attribute. an ob-
ject model represents the state of a database at some moment. for
instance, figure 5 shows an object model representing the state of
the database in figure 3. this object model contains 8 objects, i.e.,
om={o1,o2,ol1,ol2,ol3,ol4,phone ,cup}.
4 modeling the behavioral
perspective
the behavioral perspective of a business process indicates the con-
straints between activities. there exist temporal restrictions on
activities, e.g., “display order” activity can happen only after “create
order draft” activity happens. in this section, we abstract the re-
strictions as behavioral constraints between activities. for instance,
the restriction mentioned above can be described as a constraint
between activity “create order draft” and activity “display order”.
in object-centric information systems, the behavioral perspec-
tive is quite flexible. it should be generic enough to enable users to
deal with the flexible and dynamic business environments. there-
fore, we choose declarative constraints inspired by declare [3] to
model restrictions. compared with procedural languages like petri
nets, declarative languages are “open” languages, i.e., they allow for
anything which is not explicitly forbidden by constraints, and they
are more suitable for modeling flexible business processes. a con-
straint has a reference activity, a target activity and a corresponding
constraint type which specifies the restriction.
definition 4.1 (constraint types). uct={x⊆i n×i n|x,∅}
defines the universe of all possible constraint types. any element of
50delete order line
id:id
order_id:id
product:text
qty:integer
price: euro
display order
id:id
creation_date:date
customer_id:id
create order draft 
id:id
creation_date:date
customer_id:id
add order line
id:id
order_id:id
product:text
qty:integer
on_sale:booleanc1 c2 c3
(response)
before ≥ 0 and 
after ≥ 1before = 1 and 
after ≥ 0(unary-precedence)
before = 1 and 
after ≥ 0(unary-precedence)figure 6: an activity model with attributes.
uctspecifies a non-empty set of pairs of integers: the first integer
defines the number of target events before the reference event and
the second integer defines the number of target events after the
reference event.
figure 6 shows an activity model with three constraints c1,c2
andc3. the black dot indicates the reference activity and the ar-
row indicates the constraint type. for instance, “display order” is
the reference activity and “create order draft” is the target activ-
ity of c1. constraints c1andc3correspond to the constraint type
{(before ,after)∈i n×i n|before =1∧after≥0}(referred to as
unary-precedence and depicted as a single arrow) and constraint
c2corresponds to the constraint type {(before ,after)∈i n×i n|
before≥0∧after≥1}(referred to as response and depicted as a
double arrow).
here, we only give two constraint types, but actually all possible
constraint types are allowed in activity models. for instance, in
order to make the model in figure 6 more precise, one can add
negative constraints, e.g., a non-response ({(before ,after)∈i n×i n|
before≥0∧after =0}) constraint between “create order draft”
(target activity) and “display order” (reference activity), which re-
quires that “create order draft” cannot happen after “display order”.
[2] shows the graphical representations and semantics for more
constraint types. an activity model is formally defined as follows.
definition 4.2 (activity model). letuabe the universe of ac-
tivities. an activity model is a tuple actm =(a,attr′,c,πref ,πtar ,
type ,addi′,val′), where
•a⊆u ais a set of activities (denoted by rectangles),
•attr′⊆u attris a set of attribute names,
•cis a set of constraints (denoted by various types of edges),
•πref∈c→adefines the reference activity of a constraint
(denoted by a black dot connecting constraint and activity),
•πtar∈c→adefines the target activity of a constraint (the
side without a black dot), and
•type∈c→u ctspecifies the type of each constraint (de-
noted by the type of edge).
•addi′∈a→p(attr)maps each activity onto a set of addi-
tional attribute names,and
•val′∈attr→p(u v al)maps each attribute onto a set of
possible values.
an activity model is a collection of activities and constraints.
figure 6 shows an activity model actm =(a,attr′,c,πref ,πtar ,
type ,addi′,val′)with four activities, i.e., a={create order draft ,
displayorder ,add order line ,delete order line}, eight attributes, i.e.,
attr′={id,create _date , ...,price}, and three constraints, i.e., c=
{c1,c2,c3}. consider the constraint c1as example. πref(c1)=displayorder ,πtar(c1)=create order draft ,type(c1)={(before ,after)∈
i n×i n|before =1∧after≥0}(unary-precedence). addi′(display
order)={id,create _date ,customer}andval′(id)=id(represent-
ingi n).
the reference (target) activity of a constraint defines the corre-
sponding set of reference (target) events. for each reference event,
the number of its related target events should meet the require-
ments of the constraint. in traditional process modeling notations,
a constraint is defined for one process instance (case) in isolation.
this means that the related target events for a reference event are
all target events corresponding to the same case. as discussed be-
fore, the case notion is often too rigid. there may be multiple case
notions at the same time, causing one-to-many or many-to-many
relations. in ocbc models, events are correlated based on the data
perspective using the approaches in [ 2,15], which is out of the
scope of this paper.
definition 4.3 (events). letactm =(a,attr′,c,πref ,πtar ,type ,
addi′,val′)be an activity model and mactm={map∈attr′↛
uval|∀attr∈dom(map):map(attr)∈val′(attr)}be the set of
mappings of actm .eactm={(a,map)∈a×mactm|dom(map)=
addi′(a)}is the set of all events of actm .
each event is related to an activity and instantiates the attributes
of the activity. an event example is e=(create order draft ,map)
where create order draft is an activity, and map(creation _date)=
t1,map(id)=o1andmap(customer _id)=c1(i.e., the first event in
figure 8).
5 object-centric behavioral
constraint models
up to now, we have introduced class models, i.e., classes and class
relationships, and activity models, i.e., activities and constraints. in
this section, we combine them through interaction models to cover
the three perspectives in figure 1 in one single diagram.
definition 5.1 (object-centric behavioral constraint model). an
object-centric behavioral constraint model is a tuple ocbcm =
(clam ,actm ,interm), where
•clam =(oc ,attr ,rt ,key ,addi ,val ,rel)is a class model,
•actm =(a,attr′,c,πref ,πtar ,type ,addi′,val′)is an activity
model, and
•interm =(aoc ,form ,linkattr)is an interaction model be-
tween clam andactm where
–aoc⊆a×ocis a set of relationships between activities
and classes,
51–form∈aoc→opgives the type of a relationship, i.e.,
how the activity impacts the class, where op={⊕ ,⊘,⊖,#},
–linkattr∈aoc×attr↛attr′maps a pair of a relation-
ship and an attribute from its class onto an attribute from
its activity.
for convenience, we say that an event e=(a,mape)corre-
sponds to an object o=(oc,map)byaoc=(a,oc), denoted as
eaoc∼oif∀attr∈key(oc):map(attr)=mape(attr′)where
attr′=linkattr((aoc ,attr)).
order line 
id:id
order_id:id
quantity:integer
product:text
price: euro
add order line
id:id
order_id:id
qty:integer
product:text
on_sale:booleandelete order line
id:id
order_id:id
qty:integer
product:text
price: euro
product
name:text
quantity:integer
warehouse:text
m3
m4
m5
m6
m8m11
m12
m13
m14
m15
m18order 
id:id
creation_date:date
customer_id:id
create order draft 
id:id
creation_date:date
customer_id:idm1
m2display order
id:id
creation_date:date
customer_id:idm9
m10m0
m7m16
m17(aoc2) (aoc1)
(aoc3) (aoc4)
(aoc6) (aoc5)
figure 7: the interactions (corresponding to aoc1,...,aoc6 in
figure 2) on attribute level.
an interaction model interm mainly consists of a set of aoc
relationships between (a)ctivities and (o)bject (c)lasses, which can
be described by two levels. for instance, figure 2 shows six aoc
relationships ( aoc1, ...,aoc6) on the entity level and figure 7 shows
the interactions on the attribute level. each relationship is repre-
sented by a dashed line with a circle in the middle on the entity
level, and directed edges between class attributes and activity at-
tributes on the attribute level. function form gives the type of each
relationship, i.e.,⊕(insert),⊘(update),⊖(delete) and #(read). con-
sider aoc3=(add order line ,order line)in figure 2 as an example.
form(aoc3)=⊕, denoting that one “add order line” event inserts an
“order line” object,
function linkattr builds a mapping between activity attributes
and class attributes for each aoc relationship, as shown in fig-
ure 7. for instance, m3,m4,m5andm6show the interaction on
the attribute level for aoc3andlinkattr(aoc3 ,quantity)=qty, indi-
cated by m5. note that, for each relationship (a,oc),linkattr must
connect each key attribute of octo an attribute of a.3for instance,
the attribute “price” of “order line” is allowed to have no connected
activity attribute, but the attribute idmust be connected to an ac-
tivity attribute since idis the key attribute of “order line”. besides,
we assume that linkattr is injective, i.e., it is impossible two class
attributes correspond to the same activity attribute.
3the domain of linkattr dom(linkattr)⊇{(( a,oc),attr)|(a,oc)∈aoc∧attr∈
key(oc)}.an ocbc model consists of a class model, an activity model
and an interaction model. an example is shown in figure 2. the
formalization of effects of events from the activity model on objects
of the class model is given in definition 5.2. such interactions
(effects) are given in terms of aoc relationships in the interaction
model.
definition 5.2 (effect of an event). letinterm =(aoc ,form ,
linkattr)be an interaction model. through an aoc relationship
aoc=(a,oc)∈aoc , an event e=(a,mape)changes an object
from the old state oold=(oc,map old)to the new state onew =
(oc,map new), denoted as oolde−−−→aoconew, if and only if
(1)form(aoc)=⊕, then oold∈onull,onew∈oclamand∀attr∈
dom(map new):
•map new(attr)=mape(attr′)ifattr′∈dom(mape), and
•map new(attr)=null otherwise,4
(2)form(aoc)=⊘, then eaoc∼ooldand∀attr∈dom(map new):
•map new(attr)=oper(mape(attr′),map old(attr))ifattr′∈
dom(mape), and
•map new(attr)=map old(attr)otherwise,
(3)form(aoc)=⊖, then eaoc∼ooldandonew∈onull, and
(4)form(aoc)=#, then eaoc∼ooldandonew=oold,
where attr′=linkattr((aoc ,attr))andoper is a given function based
on domain knowledge (explained next).
definition 5.2 employs some rules to describe how an event
impacts objects through one aoc relationship. more precisely, rule
1 indicates that an “add” event (i.e., the type of the aoc relationship
is⊕) creates a new object. each attribute of the object is initialized
as the same value as its corresponding event attribute (indicated
by function linkattr ), or “null” if it has no corresponding event
attribute. rule 2 means that an event updates its corresponding
object (which is identified by the operator ∼, cf. definition 5.1).
more precisely, each attribute of the object is updated by oper,
or remains unchanged if it has no corresponding event attribute.
note that oper gives a way to compute the new value of an object
attribute (i.e., map new(attr)) based on the corresponding event
attribute value (i.e., mape(attr′)) and the old value of the object
attribute (i.e., map old(attr)). this enables complex operations (e.g.,
summations and subtraction) to update object attributes based on
domain knowledge. for instance, we can make oper(a,b)=aif
we want that the object value is updated as the event value, or
oper(a,b)=b−aif we want that the new object value is the result
of subtracting the event value from the old object value. rule 3
denotes that an event removes its corresponding object while, for
rule 4, an event reads its corresponding object.
figure 8 gives an example to show how events change objects
in the object model through aoc relationships in figure 7. for
instance, the first event inserts an “order” object o1through the
aoc relationship aoc2, copying all its attributes to the object. the
second event inserts an “order line” object ol1through aoc3and up-
dates the attribute “quantity” of the “product” object phone through
aoc6. similarly, the third event adds an “order line” object ol2and
updates the “product” object cup. the fourth event reads the infor-
mation of the “order” object o1without changing anything. the last
4null means that the attribute attris blank after the creation of its corresponding
object.
52add order line
id:ol1
order_id:o1
product:phone
qty:2
on_sale:yestime
behavioral perspective
data perspectiveadd order line
id:ol2
order_id:o1
product:cup
qty:4
on_sale:yescreate order draft 
id:o1
creation_date:t1
customer_id:c1
order 
id:o1
creation_date:t1
customer_id:c1
product
name:phone
quantity:88
warehouse:paris
t1
product
name:cup
quantity :106
warehouse:nice
delete order line
id:ol1
order_id:o1
product:phone
qty:2
price: nullt2 t3 t4 t5
create order draft 
id:o1
creation_date:t1
customer_id:c1
event
order 
id:o1
creation_date:t1
customer_id:c1
objectobject modelorder line 
id:ol1
order_id:o1
product:phone
quantity :2
price: null
order line 
id:ol2
order_id:o1
product:cup
quantity :4
price: null
product
name:cup
quantity:102
warehouse:nice
product
name:phone
quantity:88
warehouse:paris
order 
id:o1
creation_date:t1
customer_id:c1
display order
id:o1
creation_date:t1
customer_id:c1
activity
classproduct
name:phone
quantity:88
warehouse:paris
product
name:cup
quantity:106
warehouse:nice
order 
id:o1
creation_date:t1
customer_id:c1
product
name:phone
quantity:86
warehouse:paris
product
name:cup
quantity:106
warehouse:nice
order line 
id:ol1
order_id:o1
product:phone
quantity :2
price: null
order 
id:o1
creation_date:t1
customer_id:c1
product
name:phone
quantity:86
warehouse:paris
product
name:cup
quantity:102
warehouse:nice
order line 
id:ol2
order_id:o1
product:cup
quantity :4
price: null
order line 
id:ol1
order_id:o1
product:phone
quantity :2
price: null
order 
id:o1
creation_date:t1
customer_id:c1
product
name:phone
quantity:86
warehouse:paris
product
name:cup
quantity:102
warehouse:nice
order line 
id:ol2
order_id:o1
product:cup
quantity :4
price: null
changed by eventfigure 8: an event may add, update, delete or read one or more objects in the object model.
event removes the “order line” object ol1through aoc4and updates
the “product” object phone through aoc5. note that an “add order
line” event updates the attribute “quantity” of an “product” object
based on oper(a,b)=b−a, i.e., subtracting the value of the event
attribute “qty” from the old value of the object attribute “quantity”.
for instance, at the moment t2, “quantity” of the object phone is
updated as “86”, since its old value is “88” and the value of the event
attribute “qty” is “2”. in contrast, a “delete order line” event updates
the attribute “quantity” based on oper(a,b)=b+a. for instance,
at the moment t5, “quantity” of the object phone is updated as “88”,
since its old value is “86” and the value of the event attribute “qty” is
“2”. one event can change multiple objects. in the database context,
such an event corresponds to a transaction consisting of several
sql statements. a database system must ensure proper executionof transactions despite failures, i.e., either the entire transaction
executes, or none of it does.
6 evaluation
we have implemented the ocbc modeling language as a plugin
“ocbc model editor” in prom nightly builds (installing the ocbc
package ) to support designing business processes.5figure 9 shows
the interface of the plugin and a designed model in panel 5. by
dragging a node from panel 2to panel 5, one can add an activity
or a class. when locating the mouse cursor in the center of a node,
one can drag out an edge for the node to connect another node.
when a node or an edge is selected, it is highlighted in red and
5access http://www.win.tue.nl/ocbc/ for more information, such as tools, manuals and
ocbc model examples.
53adding different 
types of nodes 
showing  interactions on 
the attribute level
zooming in or outimporting or 
exporting models 
selected aoc relationship 
is highlighted1
2
3
45figure 9: the ocbc model editor in prom.
its attribute information can be viewed or edited in panel 3. it
is possible to zoom in/out models by operating panel 4. after
designing a model, one can export the model in panel 1 .
the idea of evaluating ocbc models is to compare its ability with
other models by describing the same business process. the otc
(order-to-cash) business process is a typical and significant scenario
in enterprises. it is supported by erp systems, e.g., dolibarr, an open
source erp system for small and medium enterprises. the otc
business process covers a range of modules from creating orders
to paying bills. figure 10 employs an informal notation to describe
the business process of “order” module (including the behavioral
perspective, data perspective and the communications in between)
in dolibarr.
first, we explain the behavioral (i.e., control-flow) perspective
including four activities and three constraints. the edges with sin-
gle arrows indicate the temporal orders between activities while
the cardinalities on edges indicate the restriction on the correspon-
dences (e.g., one-to-many) between activities. for instance, the edge
2means that after a “create order draft” event, one or more “add
order line” events can happen. indicated by 3, each “add order line”
event is followed by at most one “delete order line” event, and each“delete order line” event must have precisely one corresponding
“add order line” event before.6
create
order draftdisplay 
order
delete order 
lineadd order 
line1*
1..*1
1 0..1
order line product (stock)11
2233
5599 10
create
order display
createdelete
increase 
quantity
4466 77 88 11
decrease 
quantity
figure 10: an informal model to describe the “order” module
in the otc business process in dolibarr.
6an event ahaving a corresponding event bbefore does not mean that ahappens
directly after b, i.e., it is possible that other events happen between banda.
54events on the behavioral perspective may add, update or delete
objects on the data perspective. the process in figure 10 contains
three types of objects, i.e., “order”, “order line” and “product”, and
4and 5indicate the associations between these types. dotted
lines with arrows are employed to show the interactions between
the behavioral perspective and data perspective. for instance, 6
denotes that a “create order draft” event creates an “order” object
and 7means that a “display order” event displays all contents in
an order. 8and 9indicate that an “add order line” event adds an
order line to the order and meanwhile decreases the quantity of
the corresponding product, respectively. in contrast, 10and 11
signify that an “add order line” event removes an order line from the
order and meanwhile increases the quantity of the corresponding
product, respectively.
figure 2 employs an ocbc model to describe the process ex-
plained above. note that the process is quite flexible and there
exist one-to-many relations (i.e., multiple instances), e.g., one “cre-
ate order draft” event may correspond to multiple “add order line”
events. in the ocbc model, we do not assume a case notion, and
use the data perspective to correlate events and distinguish mul-
tiple instances. based on this, declarative constraints are used to
describe the process more precisely. the interaction types indicate
how events on the behavioral perspective impact (i.e., add, update,
delete or read) the objects on the data perspective. besides, figure 4,
figure 6 and figure 7 show the attribute level of the process from
different perspectives. by doing this, the interactions are presented
more clearly. for instance, with the support of interaction types
and the attribute level, one can know that an “add order line” event
updates the “quantity” value of a “product” object .
create
order 
draftcreate
order 
draftadd
order 
lineadd
order 
linedelete
order 
linedelete
order 
line
display
orderdisplay
orderquantity
figure 11: a dpn example to describe the “order” module.
next, we use other modeling techniques to describe the process.
figure 11 presents the process with a dpn diagram. due to the
one-to-many relation ( 2in figure 10), “add order line” and “delete
order line” events can happen multiple times in the process. ac-
cordingly, the dpn diagram employs several silent transitions (and
loops) to allow the occurrence of multiple instances, resulting in
an underfitting model (allowing to much behavior). for instance,
the constraint ( 3in figure 10) indicating that a “delete order line”
event can happen only after its corresponding “add order line” event
is not contained in the model. dpn diagrams support modeling
the data perspective with variables. for instance, “quantity” is a
variable which indicates that “add order line” and “delete order line”
events modify the quantity of corresponding product.
create 
order 
draftdelete 
order 
lineadd order 
line
display 
order data
objectdata 
symbols
orderorder 
line
messagedata 
store
data 
association`productfigure 12: a bpmn example to describe the “order” module.
figure 12 employs a bpmn diagram to describe the “order” mod-
ule. its behavioral perspective is also too general, and fails to present
the constraint between activities “delete order line” and “add order
line”. the bpmn notation has data symbols to support modeling
the data perspective of business processes, e.g., data object, data
store, message and data association. in figure 12, three data objects
are created to show the interactions between the behavioral per-
spective and data perspective. however, the objects are considered
in isolation (there are no relations between objects) and the inter-
actions on the attribute level are not shown, e.g., “add order line”
events modify the “quantity” attribute of the product object.
in summary, in the flexible scenario with multiple instances, dpn
and bpmn notations suffer an underfitting behavioral perspective.
furthermore, the data perspective and interactions between events
and data in both models are not as powerful as those in the ocbc
model. in contrast, ocbc models can explicitly represent one-to-
many and many-to-many relations, as well as interactions between
different process instances in a single, hybrid diagram.
7 related work
process modeling languages play an important role in the design
and analysis of business processes. over time researchers have pro-
posed various languages and models to describe business processes
[10, 21, 24].
most models mainly focus on one aspect of business processes.
for instance, petri nets [ 27] and declare models [ 3] are both fo-
cusing on the behavioral perspective to describe the workflows. in
contrast, petri nets are procedural and strict while declare mod-
els are declarative and flexible. er diagrams mainly describe the
data perspective, e.g., the structure of the databases corresponding
to business processes. besides, integration definition (idef) [20],
unified modeling language (uml) [ 5,8] and systems modeling
language (sysml) [ 4,9] provide a bunch of diagrams, in which
each diagram mainly models processes from a specific angle.
there exist some models which can describe multiple perspec-
tives in one single diagram. consider for example the various types
of colored petri nets, i.e., petri nets add “color” on tokens to rep-
resent attributes and values [ 13]. data-aware petri nets (dpns)
[19,22] model the data elements by writing/reading variables and
adding guards on transitions. bpmn [ 11], data flow chart [ 6,14]
and uml activity diagram can describe behavioral perspective
55and its communication with data perspective by data objects (e.g.,
documents) and data stores (e.g., tables). [ 25] provides a concrete
framework, called raw-sys, to model the control-flow, the data
and their interaction, and to verify data-aware processes. artifact-
centric approaches [ 7,12,23] (including the earlier work on proclets
[1]) aim to capture business processes in terms of so-called business
artifacts, i.e., key entities which drive a company’s operations and
whose lifecycles and interactions define an overall business process.
artifacts have data and lifecycles attached to them, thus relating
both perspectives.
these process-centric approaches (e.g., dpn and bpmn dia-
grams) can describe the data perspective to some extent. they try
to consider the data perspective by adding data elements, such as
attributes, values, variables and objects, onto the control-flow. how-
ever they do not support explicit data modeling as can be found in
er models. artifact-centric approaches need to identify artifacts
beforehand based on domain knowledge, and within an artifact
(proclet, or subprocess), one is forced to pick a single instance no-
tion. besides, the description of the end-to-end behavior needs to
be distributed over multiple diagrams (e.g., one process model per
artifact).
compared with existing approaches, an ocbc model can de-
scribe the data perspective, the behavioral perspective and the
interplay in between in one single diagram, which provides a pic-
ture of the whole system. besides, it is powerful on presenting
the interactions through mapping class attributes onto activity
attributes.
8 conclusion and future work
an ocbc model is a hybrid model consisting of: a class model
describing the structure of databases; an activity model describing
the possible events and restrictions between events; and an inter-
action model describing how events modify the database tables.
this paper strengthens the proposed ocbc models by (i) adding
attribute onto classes and activities, (ii) adding interaction types on
aoc relationships and (iii) formalizing the interactions (i.e., how
events change objects) on the attribute level.
ocbc models outperform existing approaches when describing
flexible business processes on object-centric information systems,
since it is more powerful to model communications and shows
three perspectives of a business process in one single diagram.
besides, we implemented the language as an editor, which supports
designing models to describe business processes.
moreover, the ocbc models serve as a starting point for a new
line of research. based on event logs extracted from data generated
by object-centric information systems [ 18], automatically discover-
ing ocbc models [ 17] should be further developed to incorporate
the discovery of attributes and the interactions related. the con-
formance checking techniques [ 2] will be able to detect different
kinds of deviations taking the attribute level into consideration.
finally, the behavioral perspective can be extended to incorporate
data-aware constraints (which may be comparable to the guards in
dpn diagrams).
references
[1]w.m.p. van der aalst, p. barthelmess, c.a. ellis, and j. wainer. 2001. proclets:
a framework for lightweight interacting workflow processes. internationaljournal of cooperative information systems 10, 4 (2001), 443–481.
[2]w.m.p. van der aalst, g. li, and m. montali. 2017. object-centric behavioral
constraints. corr technical report. arxiv.org e-print archive. available at
https://arxiv.org/abs/1703.05740.
[3]w.m.p. van der aalst, m. pesic, and h. schonenberg. 2009. declarative workflows:
balancing between flexibility and support. computer science - research and
development 23, 2 (2009), 99–113.
[4]l. balmelli et al .2007. an overview of the systems modeling language for
products and systems development. journal of object technology 6, 6 (2007),
149–177.
[5]g. booch. 2005. the unified modeling language user guide. pearson education
india.
[6]p.d. bruza and t. van der weide. 1989. the semantics of data flow diagrams.
citeseer.
[7]d. cohn and r. hull. 2009. business artifacts: a data-centric approach to
modeling business operations and processes. ieee data engineering bulletin 32,
3 (2009), 3–9.
[8]h.e. eriksson and m. penker. 2000. business modeling with uml. new york
(2000), 1–12.
[9]s. friedenthal, a. moore, and r. steiner. 2014. a practical guide to sysml: the
systems modeling language. morgan kaufmann.
[10] g.m. giaglis. 2001. a taxonomy of business process modeling and information
systems modeling techniques. international journal of flexible manufacturing
systems 13, 2 (2001), 209–228.
[11] object management group. 2010. business process model and notation. omg.
[12] r. hull et al .2011. business artifacts with guard-stage-milestone lifecycles:
managing artifact interactions with conditions and events. in international
conference on distributed event-based systems (debs 2011). acm.
[13] k. jensen. 1996. coloured petri nets: basic concepts, analysis methods and practical
use. springer-verlag, berlin.
[14] p.g. larsen, n. plat, and h. toetenel. 1994. a formal semantics of data flow
diagrams. formal aspects of computing 6, 6 (1994), 586–606.
[15] g. li, r.m.de carvalho, and w.m.p. van der aalst. 2018. configurable event
correlation for process discovery from object-centric event data. in 2018 ieee
international conference on web services (icws). 203–210. https://doi.org/10.
1109/icws.2018.00033
[16] g. li and r.m. de carvalho. 2018. dealing with artifact-centric systems: a
process mining approach. in proceedings of the 9th emisa, may 24–25, 2018.
80–84.
[17] g. li, r.m. de carvalho, and w.m.p. van der aalst. 2017. automatic discovery of
object-centric behavioral constraint models. in business information systems:
20th international conference, bis 2017, june 28–30, 2017, proceedings. springer,
43–58.
[18] g. li, e. gonzález lópez de murillas, r.m. de carvalho, and w.m.p. van der
aalst. 2018. extracting object-centric event logs to support process mining on
databases. in information systems in the big data era, caise forum 2018, jan
mendling and haralambos mouratidis (eds.). springer international publishing,
cham, 182–199.
[19] m. de leoni and w.m.p. van der aalst. 2013. data-aware process mining: discov-
ering decisions in processes using alignments. in proceedings of the 28th annual
acm symposium on applied computing. acm, 1454–1461.
[20] c. menzel and r.j. mayer. 1998. the idef family of languages. in handbook on
architectures of information systems. springer, 209–241.
[21] h. mili et al .2010. business process modeling languages: sorting through the
alphabet soup. acm computing surveys (csur) 43, 1 (2010), 4.
[22] n. sidorova, c. stahl and n. trčka. 2011. soundness verification for concep-
tual workflow nets with data: early detection of errors with the most precision
possible. information systems 36, 7 (2011), 1026–1043.
[23] a. nigam and n.s. caswell. 2003. business artifacts: an approach to operational
specification. ibm systems journal 42, 3 (2003), 428–445.
[24] o.s. noran. 2000. business modelling: uml vs. idef. school of computing and
information technology, griffith university (2000).
[25] r. de masellis, c. di francescomarino, c. ghidini, m. montali and s. tessaris.
2017. add data into business process verification: bridging the gap between
theory and practice.. in aaai. 1091–1099.
[26] w.m.p. van der aalst. 2015. extracting event data from databases to unleash
process mining. in bpm-driving innovation in a digital world. springer, 105–128.
[27] w.m.p. van der aalst and k.m. van hee. 1996. business process redesign: a
petri-net-based approach. computers in industry 29, 1-2 (1996), 15–26.
56