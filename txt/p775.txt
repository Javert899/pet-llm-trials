process mining in the large: a tutorial
wil m.p. van der aalst
department of mathematics and computer science, eindhoven university of
technology, eindhoven, the netherlands;
business process management discipline, queensland university of technology,
brisbane, australia; and
international laboratory of process-aware information systems, national research
university higher school of economics, moscow, russia.
w.m.p.v.d.aalst@tue.nl
abstract. recently, process mining emerged as a new scientic disci-
pline on the interface between process models and event data. on the
one hand, conventional business process management (bpm) and work-
ow management (wfm) approaches and tools are mostly model-driven
with little consideration for event data. on the other hand, data min-
ing (dm), business intelligence (bi), and machine learning (ml) focus
on data without considering end-to-end process models. process mining
aims to bridge the gap between bpm and wfm on the one hand and
dm, bi, and ml on the other hand. here, the challenge is to turn tor-
rents of event data (\big data") into valuable insights related to process
performance and compliance. fortunately, process mining results can be
used to identify and understand bottlenecks, ineciencies, deviations,
and risks. this tutorial paper introduces basic process mining techniques
that can be used for process discovery and conformance checking. more-
over, some very general decomposition results are discussed. these allow
for the decomposition and distribution of process discovery and confor-
mance checking checking problems, thus enabling process mining in the
large.
key words: process mining, big data, process discovery, confor-
mance checking
1 introduction
like most it-related phenomena, also the growth of event data complies with
moore's law. similar to the number of transistors on chips, the capacity of hard
disks, and the computing power of computers, the digital universe is growing
exponentially and roughly doubling every 2 years [55, 65]. although this is not a
new phenomenon, suddenly many organizations realize that increasing amounts
of \big data" (in the broadest sense of the word) need to be used intelligently
in order to compete with other organizations in terms of eciency, speed and
service. however, the goal is not to collect as much data as possible. the real
challenge is to turn event data into valuable insights. only process mining tech-
niques directly relate event data to end-to-end business processes [2]. existing2 w.m.p. van der aalst
business process modeling approaches generating piles of process models are
typically disconnected from the real processes and information systems. data-
oriented analysis techniques (e.g., data mining and machines learning) typically
focus on simple classication, clustering, regression, or rule-learning problems.
process 
mining
data-oriented analysis  
(data mining, machine learning, business intelligence)process model analysis  
(simulation, verification, optimization, gaming, etc.)
performance-
oriented 
questions, 
problems and 
solutionscompliance-
oriented 
questions, 
problems and 
solutions
fig. 1. process mining provides the missing link between on the one hand process
model analysis and data-oriented analysis and on the other hand performance and
conformance.
process mining aims to discover, monitor and improve real processes by ex-
tracting knowledge from event logs readily available in today's information sys-
tems [2]. starting point for any process mining task is an event log . each event
in such a log refers to an activity (i.e., a well-dened step in some process) and
is related to a particular case (i.e., a process instance ). the events belonging to
a case are ordered and can be seen as one \run" of the process. the sequence of
activities executed for a case is called a trace. hence, an event log can be viewed
as a multiset of traces (multiple cases may have the same trace). it is important
to note that an event log contains only example behavior , i.e., we cannot assume
that all possible traces have been observed. in fact, an event log often contains
only a fraction of the possible behavior [2].
the growing interest in process mining is illustrated by the process mining
manifesto [58] recently released by the ieee task force on process mining .
this manifesto is supported by 53 organizations and 77 process mining experts
contributed to it.
the process mining spectrum is quite broad and includes techniques like
process discovery, conformance checking, model repair, role discovery, bottleneck
analysis, predicting the remaining ow time, and recommending next steps. in
this paper, we focus on the following two main process mining problems:process mining in the large: a tutorial 3
a
starta = register for exam
b = theoretical exam
c = practical exam
d = evaluate result
e = register for additional attempt  
f = obtain degree
b
cd f e
endabcdf
abcdecbdf
acbdf
abcdebcdf
abcdf
acbdebcdf
acbdecbdebcdf
...
event log
process modelprocess 
discovery
fig. 2. starting point for process discovery is an event log consisting of traces. in this
example each trace describes activities related to an exam candidate. based on the
observed behavior a process model is inferred that is able to reproduce the event log.
for example, both the traces in the event log and the runs of the process model always
start witha(register for exam) and end with f(obtain degree). moreover, ais always
directly followed by borc,bandcalways happen together (in any order), dcan only
occur after both bandchave happened, dis always directly followed by eorf, etc.
there are various process discovery techniques to automatically learn a process model
from raw event data.
{process discovery problem : given an event log consisting of a collection of
traces (i.e., sequences of events), construct a petri net that \adequately" de-
scribes the observed behavior (see figure 2).1
{conformance checking problem : given an event log and a petri net, diagnose
the dierences between the observed behavior (i.e., traces in the event log)
and the modeled behavior (i.e., ring sequences of the petri net). figure 3
shows examples of deviations discovered through conformance checking.
both problems are formulated in terms of petri nets. however, any other process
notation can be used, e.g., bpmn models, bpel specications, uml activity
diagrams, statecharts, c-nets, and heuristic nets.
the incredible growth of event data is also posing new challenges [85]. as
event logs grow, process mining techniques need to become more ecient and
highly scalable. dozens of process discovery [2, 19, 21, 26, 50, 28, 32, 33, 34, 52,
66, 86, 93, 94] and conformance checking [9, 22, 23, 25, 31, 35, 52, 69, 70, 80, 91]
approaches have been proposed in literature. despite the growing maturity of
these approaches, the quality and eciency of existing techniques leave much
to be desired. state-of-the-art techniques still have problems dealing with large
and/or complex event logs and process models. consider for example philips
1as will be shown later, there are dierent ways of measuring the quality of a process
discovery result. the term \adequately" is just an informal notion that will be
detailed later.4 w.m.p. van der aalst
a
startb
cd f e
endacdf
abcdecbdf
acbdf
abcdebcdf
abcfd
acdecfd
acbdecbdebcdf
...
conformance 
checking
a
startb
cd f e
endb is sometimes 
skipped
d and f are 
sometimes swappedacdf
abcdecbdf
acbdf
abcdebcdf
abcfd
acdecfd
acbdecbdebcdf
...b is skipped 
in acdf
b is skipped 
twice in 
acdecfdd and f are 
swapped
d and f are 
swapped
fig. 3. conformance checking starts with an event log and a process model. ideally,
events in the event log correspond to occurrences of activities in the model. by replaying
the traces on the model one can nd dierences between log and model. the rst trace
shown cannot be replayed because activity bis missing (although no theoretical exam
was made the result was evaluated). the fth trace cannot be replayed because d
andfare swapped, i.e., the candidate obtained a degree before the formal decision
was made). the sixth trace has both problems. conformance checking results can be
diagnosed using a log-based view (bottom left) or a model-based view (bottom right).
healthcare, a provider of medical systems that are often connected to the in-
ternet to enable logging, maintenance, and remote diagnostics. more than 1500
cardio vascular (cv) systems (i.e., x-ray machines) are remotely monitored by
philips. on average each cv system produces 15,000 events per day, resulting
in 22.5 million events per day for just their cv systems. the events are stored
for many years and have many attributes. the error logs of asml's lithography
systems have similar characteristics and also contain about 15,000 events per
machine per day. these numbers illustrate the fact that today's organizations
are already storing terabytes of event data. process mining techniques aiming at
very precise results (e.g., guarantees with respect to the accuracy of the model or
diagnostics), quickly become intractable when dealing with such real-life event
logs. earlier applications of process mining in organizations such as philips and
asml, show that there are various challenges with respect to performance (re-
sponse times), capacity (storage space), and interpretation (discovered process
models may be composed of thousands of activities) [29]. therefore, we also
describe the generic divide and conquer approach presented in [7]:
{ for conformance checking , we decompose the process model into smaller partly
overlapping model fragments. if the decomposition is done properly, then any
trace that ts into the overall model also ts all of the smaller model fragments
and vice versa. hence, metrics such as the fraction of tting cases can be
computed by only analyzing the smaller model fragments.process mining in the large: a tutorial 5
{ to decompose process discovery , we split the set of activities into a collection of
partly overlapping activity sets. for each activity set, we project the log onto
the relevant events and discover a model fragment. the dierent fragments
are glued together to create an overall process model. again it is guaranteed
that all traces in the event log that t into the overall model also t into the
model fragments and vice versa.
this explains the title of this tutorial: \process mining in the large".
the remainder of this paper is organized as follows. section 2 provides an
overview of the process mining spectrum. some basic notions are introduced in
section 3. section 4 presents two process discovery algorithms: the -algorithm
(section 4.1) and region-based process discovery (section 4.2). section 5 in-
troduces two conformance checking techniques. moreover, the dierent quality
dimensions are discussed and the importance of aligning observed and modeled
behavior is explained. section 6 presents a very generic decomposition result
showing that most process discovery and conformance checking can be split into
many smaller problems. section 7 concludes the paper.
2 process mining spectrum
figure 4 shows the process mining framework described in [2]. the top of the
diagram shows an external \world" consisting of business processes, people, and
organizations supported by some information system. the information system
records information about this \world" in such a way that events logs can be
extracted. the term provenance used in figure 4 emphasizes the systematic, re-
liable, and trustworthy recording of events. the term provenance originates from
scientic computing, where it refers to the data that is needed to be able to repro-
duce an experiment [62, 39]. business process provenance aims to systematically
collect the information needed to reconstruct what has actually happened in a
process or organization [37]. when organizations base their decisions on event
data it is essential to make sure that these describe history well. moreover, from
an auditing point of view it is necessary to ensure that event logs cannot be tam-
pered with. business process provenance refers to the set of activities needed to
ensure that history, as captured in event logs, \cannot be rewritten or obscured"
such that it can serve as a reliable basis for process improvement and auditing.
as shown in figure 4, event data can be partitioned into \pre mortem" and
\post mortem" event logs. \post mortem" event data refer to information about
cases that have completed, i.e., these data can be used for process improvement
and auditing, but not for inuencing the cases they refer to. \pre mortem" event
data refer to cases that have not yet completed. if a case is still running, i.e.,
the case is still \alive" (pre mortem), then it may be possible that information
in the event log about this case (i.e., current data) can be exploited to ensure
the correct or ecient handling of this case.
\post mortem" event data are most relevant for o-line process mining , e.g.,
discovering the control-ow of a process based on one year of event data. for6 w.m.p. van der aalst
information system(s)
current 
data“world”people
machinesorganizations
business 
processes documents
historic 
data
resources/
organizationdata/rulescontrol-flowde jure models
resources/
organizationdata/rulescontrol-flowde facto modelsprovenanceexplore
predict
recommend
detect
check
compare
promote
discover
enhance
diagnosecartography navigation auditingevent logs
models“pre 
mortem”“post 
mortem”
fig. 4. overview of the process mining spectrum [2].
online process mining mixtures of \pre mortem" (current) and \post mortem"
(historic) data are needed. for example, historic information can be used to learn
a predictive model. subsequently, information about a running case is combined
with the predictive model to provide an estimate for the remaining ow time of
the case.
the process mining framework described in [2] also distinguishes between
two types of models: \de jure models" and\de facto models" .a de jure model is
normative , i.e., it species how things should be done or handled. for example,
a process model used to congure a bpm system is normative and forces people
to work in a particular way. a de facto model is descriptive and its goal is not to
steer or control reality. instead, de facto models aim to capture reality. as shown
in figure 4 both de jure and de facto models may cover multiple perspectives
including the control-ow perspective (\how?"), the organizational perspective
(\who?"), and the case perspective (\what?"). the control-ow perspectiveprocess mining in the large: a tutorial 7
describes the ordering of activities. the organizational perspective describes re-
sources (worker, machines, customers, services, etc.) and organizational entities
(roles, departments, positions, etc.). the case perspective describes data and
rules.
in the middle of figure 4 ten process mining related activities are depicted.
these ten activities are grouped into three categories: cartography ,auditing , and
navigation . the activities in the cartography category aim at making \process
maps". the activities in the auditing category all involve a de jure model that is
confronted with reality in the form of event data or a de facto model. the activ-
ities in the navigation category aim at improving a process while it is running.
activity discover in figure 4 aims to learn a process model from examples
stored in some event log. lion's share of process mining research has been devoted
to this activity [2, 47]. a discovery technique takes an event log and produces
a model without using any additional a-priori information. an example is the
-algorithm [21] that takes an event log and produces a petri net explaining
the behavior recorded in the log. if the event log contains information about
resources, one can also discover resource-related models, e.g., a social network
showing how people work together in an organization.
since the mid-nineties several groups have been working on techniques for
process discovery [18, 21, 26, 34, 38, 44, 45, 93]. in [12] an overview is given of
the early work in this domain. the idea to apply process mining in the context
of workow management systems was introduced in [26]. in parallel, datta [38]
looked at the discovery of business process models. cook et al. investigated sim-
ilar issues in the context of software engineering processes [34]. herbst [54] was
one of the rst to tackle more complicated processes, e.g., processes containing
duplicate tasks.
most of the classical approaches have problems dealing with concurrency.
the-algorithm [21] is an example of a simple technique that takes concurrency
as a starting point. however, this simple algorithm has problems dealing with
complicated routing constructs and noise (like most of the other approaches
described in literature). process discovery is very challenging because techniques
need to balance four criteria: tness (the discovered model should allow for
the behavior seen in the event log), precision (the discovered model should not
allow for behavior completely unrelated to what was seen in the event log),
generalization (the discovered model should generalize the example behavior
seen in the event log), and simplicity (the discovered model should be as simple
as possible). this makes process discovery a challenging and highly relevant
research topic.
activity enhance in figure 4 corresponds any eort where event data are
used to repair a model (e.g., to better reect reality) or to extend a model (e.g.,
to show bottlenecks). when existing process models (either discovered or hand-
made) can be related to events logs, it is possible to enhance these models. the
connection can be used to repair models [49] or to extend them [79, 83, 81, 82].
activity diagnose in figure 4 does not directly use event logs and focuses on
classical model-based process analysis, e.g., simulation or verication.8 w.m.p. van der aalst
activity detect compares de jure models with current \pre mortem" data
(events of running process instances) with the goal to detect deviations at run-
time. the moment a predened rule is violated, an alert is generated [17, 63, 64].
activity check in figure 4 analyzes conformance-related questions using event
data. historic \post mortem" data can be cross-checked with de jure models.
the goal of this activity is to pinpoint deviations and quantify the level of
compliance. various conformance checking techniques have been proposed in
literature [9, 22, 23, 31, 35, 52, 69, 70, 80, 91]. for example, in [80] the tness of
a model is computed by comparing the number of missing and remaining tokens
with the number of consumed and produced tokens during replay. the more
sophisticated technique described in [9, 22, 23] creates as so-called alignment
which relates a trace in the event log to an execution sequence of the model
that is as similar as possible. ideally, the alignment consists of steps where log
and model agree on the activity to be executed. steps where just the model
\makes a move" or just the log \makes a move" have a predened penalty. this
way the computation of tness can be turned into an optimization problem:
for each trace in the event log an alignment with the lowest costs is selected.
the resulting alignments can be used for all kinds of analysis since any trace
in the event log is related to an execution sequence of the model. for example,
timestamps in the model can be used to compute bottlenecks and extend the
model with performance information (see activity enhance in figure 4).
activity compare highlights dierences and commonalities between a de jure
model and a de facto model. traditional equivalence notions such as trace equiv-
alence, bisimilarity, and branching bisimilarity [51, 68] can only be used to de-
termine equivalence using a predened equivalence notion, e.g., these techniques
cannot be used to distinguish between very similar and highly dissimilar pro-
cesses. other notions such a graph-edit distance tend to focus on the syntax
rather than the behavior of models. therefore, recent bpm research explored
various alternative similarity notions [42, 43, 59, 60, 67, 92]. also note the great-
est common divisor (gcd) and least common multiple (lcm) notions dened
for process models in [11]. the gcd captures the common parts of two or more
models. the lcm embeds all input models. we refer to [42] for a survey and
empirical evaluation of some similarity notions.
activity promote takes (parts of) de facto models and converts these into
(parts of) de jure models, i.e., models used to control or support processes are
improved based on models learned from event data. by promoting proven \best
practices" to de jure models, existing processes can be improved.
the activities in the cartography and auditing categories in figure 4 can
be viewed as \backward-looking". the last three activities forming the naviga-
tion category are \forward-looking" and are sometimes referred to as operational
support [2]. for example, process mining techniques can be used to make predic-
tions about the future of a particular case and guide the user in selecting suitable
actions. when comparing this with a car navigation system from tomtom or
garmin, this corresponds to functionalities such as predicting the arrival time
and guiding the driver using spoken instructions.process mining in the large: a tutorial 9
activity explore in figure 4 visualizes running cases and compares these cases
with similar cases that were handled earlier. the combination of event data and
models can be used to explore business processes at run-time and, if needed,
trigger appropriate actions.
by combining information about running cases with models (discovered or
hand-made), it is possible to make predictions about the future, e.g., predicting
the remaining ow time or the probability of success. figure 4 shows that activity
predict uses current data and models (often learned over historic data). various
techniques have been proposed in bpm literature [20, 46, 77]. note that already
a decade ago staware provided a so-called \prediction engine" using simulation
[87].
activity recommend in figure 4 aims to provide functionality similar to the
guidance given by car navigation systems. the information used for predicting
the future can also be used to recommend suitable actions (e.g. to minimize
costs or time) [17, 84]. given a set of possible next steps, the most promising
step is recommended. for each possible step, simply assume that the step is
made and predict the resulting performance (e.g., remaining ow time). the
resulting predictions can be compared and used to rank the possible next steps.
the ten activities in figure 4 illustrate that process mining extends far be-
yond process discovery. the increasing availability and growing volume of event
data suggest that the importance of process mining will continue to grow in the
coming years.
it is impossible to cover the whole process mining spectrum in this tutorial
paper. the reader is referred to [2, 6] for a more complete overview.
3 preliminaries
this section introduces basic concepts related to petri nets and event logs.
3.1 multisets, functions, and sequences
multisets are used to represent the state of a petri net and to describe event
logs where the same trace may appear multiple times.
b(a) is the set of all multisets over some set a. for some multiset b2b(a),
b(a) denotes the number of times element a2aappears inb. some examples:
b1= [ ],b2= [x;x;y ],b3= [x;y;z ],b4= [x;x;y;x;y;z ],b5= [x3;y2;z] are
multisets over a=fx;y;zg.b1is the empty multiset, b2andb3both consist
of three elements, and b4=b5, i.e., the ordering of elements is irrelevant and a
more compact notation may be used for repeating elements.
the standard set operators can be extended to multisets, e.g., x2b2,b2]
b3=b4,b5nb2=b3,jb5j= 6, etc.fa2bgdenotes the set with all elements
afor whichb(a)1. [f(a)ja2b] denotes the multiset where element f(a)
appearsp
x2bjf(x)=f(a)b(x) times.10 w.m.p. van der aalst
a relationrxyis a set of pairs. 1(r) =fxj(x;y)2rgis the domain
ofr,2(r) =fyj(x;y)2rgis the range of r, and!(r) =1(r)[2(r) are
the elements of r. for example, !(f(a;b);(b;c)g) =fa;b;cg.
to the (total) function f2x!ymaps elements from the set xonto
elements of the set y, i.e.,f(x)2yfor anyx2x.f2x6!yis a partial
function with domain dom(f)xand range rng(f) =ff(x)jx2xgy.
f2x!yis a total function, i.e., dom(f) =x. a partial function f2x6!y
is injective if f(x1) =f(x2) impliesx1=x2for allx1;x22dom(f).
denition 1 (function projection). letf2x6!ybe a (partial) function
andqx.fqis the function projected on q: dom (fq) =dom(f)\qand
fq(x) =f(x)forx2dom(fq).
the projection can also be used for multisets, e.g., [ x3;y;z2]fx;yg= [x3;y].
=ha1;a2;:::;ani2xdenotes a sequence over xof lengthn.hiis the
empty sequence. multsk() = [a1;a2;:::;ak] is the multiset composed of the
rstkelements of .mults () =multsjj() converts a sequence into a multiset.
mults2(ha;a;b;a;bi) = [a2] and mults (ha;a;b;a;bi) = [a3;b2].
sequences are used to represent paths in a graph and traces in an event log.
12is the concatenation of two sequences and qis the projection of on
q.
denition 2 (sequence projection). letxbe a set and qxone of its
subsets.q2x!qis a projection function and is dened recursively: (1)
hiq=hiand (2) for 2xandx2x:
(hxi)q=(
q ifx62q
hxiqifx2q
sohy;z;yifx;yg=hy;yi. functions can also be applied to sequences: if dom(f) =
fx;yg, thenf(hy;z;yi) =hf(y);f(y)i.
denition 3 (applying functions to sequences). letf2x6!ybe a
partial function. fcan be applied to sequences of xusing the following recursive
denition (1) f(hi) =hiand (2) for 2xandx2x:
f(hxi) =(
f() ifx62dom(f)
hf(x)if()ifx2dom(f)
summation is dened over multisets and sequences, e.g.,p
x2ha;a;b;a;bif(x) =p
x2[a3;b2]f(x) = 3f(a) + 2f(b).
3.2 petri nets
we use petri nets as the process modeling language used to introduce pro-
cess mining (in the large). however, as mentioned in section 1 the results pre-
sented in the paper can be adapted for various other process modeling notationsprocess mining in the large: a tutorial 11
(bpmn models, bpel specications, uml activity diagrams, statecharts, c-
nets, heuristic nets, etc.). this does not imply that these notations are equivalent.
there are dierences in expensiveness (e.g., classical petri nets are not turing
complete, but most extension of petri nets are) and suitability (cf. research on
the workow patterns [15]). translations are often \lossy", i.e., the model after
translation may allow for more or less behavior. however, in practice this is not
a problem as the basic concepts are often the same. there is also a trade-o be-
tween accuracy and simplicity. for example, inclusive or-joins are not directly
supported by petri nets, because an or-join may need to synchronize a variable
(at design-time unknown) number of inputs. using a rather involved transla-
tion it is possible to model this in terms of classical petri nets using so-called
\true" and \false" tokens [15]. this only works if there are no arbitrary unstruc-
tured loops. see for example the many translations proposed for the mapping
from bpel to petri nets [56, 61, 73]. there also exists a na ve much simpler
translation that includes the original behavior (but also more) [1, 10]. using
single-entry single-exit (sese) components and the rened process structure
tree (rpst) [88, 75] it is often possible to convert aan unstructured graph-based
model into a structured model. also see the approaches to convert petri nets and
bpmn models into bpel [16, 74].
the above examples illustrate that many conversions are possible depend-
ing on the desired outcome (accuracy versus simplicity). it is also important to
stress that the representational bias used during process discovery may be dif-
ferent from the representational bias used to present the result to end-users. for
example, one may use petri nets during discovery and convert the nal result to
bpmn.
in this paper we would like to steer away from notational issues and conver-
sions and restrict ourselves to petri nets as a representation for process models.
by using petri nets we minimize the notational overhead allowing us the focus
on the key ideas.
denition 4 (petri net). a petri net is a tuple n= (p;t;f )withpthe set
of places,tthe set of transitions, p\t=;, andf(pt)[(tp)the
ow relation.
figure 5 shows a petri net n= (p;t;f ) withp=fstart;c1;:::;c 9;endg,
t=ft1;t2;:::;t 11g, andf=f(start;t1);(t1;c1);(t1;c2);:::; (t11;end)g. the
state of a petri net, called marking , is a multiset of places indicating how many
tokens each place contains. [ start ] is the initial marking shown in figure 5.
another potential marking is [ c110;c25;c45]. this is the state with ten tokens in
c1, ve tokens in c2, and ve tokens in c4.
denition 5 (marking). letn= (p;t;f )be a petri net. a marking mis a
multiset of places, i.e., m2b(p).
a petri net n= (p;t;f ) denes a directed graph with nodes p[tand edges
f. for anyx2p[t,nx=fyj(y;x)2fgdenotes the set of input nodes and12 w.m.p. van der aalst
a
start
a = register request
b = examine file
c = check ticket
d = decide
e = reinitiate request 
f = send acceptance letter
g = pay compensation
h = send rejection letterb
cdg
h
eendc1
c2c3
c4c5t1f
t2
t3
t4t5
t6t7t8
t9
t10t11
c6c7 c8
c9
fig. 5. a labeled petri net.
xn=fyj(x;y)2fgdenotes the set of output nodes we drop the superscript
nif it is clear from the context.
a transition t2tisenabled in marking mof netn, denoted as ( n;m )[ti,
if each of its input places tcontains at least one token. consider the petri net
nin figure 5 with m= [c3;c4]: (n;m )[t5ibecause both input places of t5 are
marked.
an enabled transition tmay re, i.e., one token is removed from each of the
input placestand one token is produced for each of the output places t. for-
mally:m0= (mnt)]tis the marking resulting from ring enabled transition
tin marking mof petri net n. (n;m )[ti(n;m0) denotes that tis enabled in
mand ringtresults in marking m0. for example, ( n;[start ])[t1i(n;[c1;c2])
and (n;[c3;c4])[t5i(n;[c5]) for the net in figure 5.
let=ht1;t2;:::;tni2tbe a sequence of transitions. ( n;m )[i(n;m0)
denotes that there is a set of markings m0;m1;:::;mnsuch thatm0=m,
mn=m0, and (n;mi)[ti+1i(n;mi+1) for 0i < n . a marking m0isreach-
able frommif there exists a such that ( n;m )[i(n;m0). for example,
(n;[start ])[i(n;[end]) with=ht1;t3;t4;t5;t10ifor the net in figure 5.
denition 6 (labeled petri net). a labeled petri net n= (p;t;f;l )is
a petri net (p;t;f )with labeling function l2t6! uawhereuais some
universe of activity labels. let v=ha1;a2;:::;ani 2 uabe a sequence of
activities. (n;m )[vb(n;m0)if and only if there is a sequence 2tsuch
that(n;m )[i(n;m0)andl() =v(cf. denition 3).
ift62dom(l), it is called invisible. an occurrence of visible transition t2dom(l)
corresponds to observable activity l(t). the petri net in figure 5 is labeled.process mining in the large: a tutorial 13
the labeling function is dened as follows: dom(l) =ft1;t3;t4;t5;t6;t8;t9;
t10g,l(t1) =a(ais a shorthand for \register request"), l(t3) =b(\examine
le"),l(t4) =c(\check ticket"), l(t5) =d(\decide"), l(t6) =e(\reinitiate re-
quest"),l(t8) =f(\send acceptance letter"), l(t9) =g(\pay compensation"),
andl(t10) =h(\send rejection letter"). unlabeled transitions correspond to
so-called \silent actions", i.e., transitions t2,t7, andt11 are unobservable.
given the petri net nin figure 5: ( n;[start ])[vb(n;[end]) forv=
ha;c;d;f;gibecause (n;[start ])[i(n;[end]) with=ht1;t2;t4;t5;t7;t8;t9;t11i
andl() =v.
in the context of process mining, we always consider processes that start in
an initial state and end in a well-dened end state. for example, given the net
in figure 5 we are interested in so-called complete ring sequences starting in
minit= [start ] and ending in mnal= [end]. therefore, we dene the notion of
asystem net .
denition 7 (system net). a system net is a triplet sn = (n;m init;mnal)
wheren= (p;t;f;l )is a labeled petri net, minit2b(p)is the initial marking,
andmnal2b(p)is the nal marking. usnis the universe of system nets .
denition 8 (system net notations). let sn = (n;m init;mnal)2u sn
be a system net with n= (p;t;f;l ).
{tv(sn) =dom(l)is the set of visible transitions in sn ,
{av(sn) =rng(l)is the set of corresponding observable activities in sn ,
{tu
v(sn) =ft2tv(sn)j8t02tv(sn)l(t) =l(t0))t=t0gis the set of
unique visible transitions in sn (i.e., there are no other transitions having
the same visible label), and
{au
v(sn) =fl(t)jt2tu
v(sn)gis the set of corresponding unique observable
activities in sn .
given a system net, (sn) is the set of all possible visible traces, i.e., complete
ring sequences starting in minitand ending in mnalprojected onto the set of
observable activities.
denition 9 (traces). let sn = (n;m init;mnal)2u snbe a system net.
(sn) =fvj(n;m init)[vb(n;m nal)gis the set of visible traces starting
inminitand ending in mnal.f(sn) =fj(n;m init)[i(n;m nal)gis the
corresponding set of complete ring sequences.
for figure 5: (sn) =fha;c;d;f;gi;ha;c;b;d;f;gi;ha;c;d;hi;ha;b;c;d;e;c;d;hi;
:::gandf(sn) =fht1;t2;t4;t5;t7;t8;t9;t11i;ht1;t3;t4;t5;t10i;:::g. because
of the loop involving transition t6 there are innitely many visible traces and
complete ring sequences.
traditionally, the bulk of petri net research focused on model-based analysis .
moreover, the largest proportion of model-based analysis techniques is limited to
functional properties . generic techniques such as model checking can be used to
check whether a petri net has particular properties, e.g., free of deadlocks. petri-
net-specic notions such as traps, siphons, place invariants, transition invariants,14 w.m.p. van der aalst
and coverability graphs are often used to verify desired functional properties, e.g.,
liveness or safety properties [78]. consider for example the notion of soundness
dened for workflow nets (wf-nets) [13]. the petri net shown in figure 5 is
a wf-net because there is a unique source place start , a unique sink place end,
and all nodes are on a path from start toend. a wf-net is sound if and only
if the following three requirements are satised: (1) option to complete : it is
always still possible (i.e., from any reachable marking) to reach the state which
just marks place end, (2) proper completion : if place endis marked all other
places are empty, and (3) no dead transitions : it should be possible to execute
an arbitrary transition by following the appropriate route through the wf-net.
the wf-net in figure 5 is sound and as a result cases cannot get stuck before
reaching the end (termination is always possible) and all parts of the process
can be activated (no dead segments). obviously, soundness is important in the
context of business processes and process mining. fortunately, there exist nice
theorems connecting soundness to classical petri-net properties. for example,
a wf-net is sound if and only if the corresponding short-circuited petri net
is live and bounded. hence, proven techniques and tools can be used to verify
soundness.
although the results in this paper are more general and not limited of wf-
nets, all examples in this paper use indeed wf-nets. as indicated most of petri
net literature and tools focuses on model-based analysis thereby ignoring actual
observed process behavior. yet, the confrontation between modeled and observed
behavior is essential for understanding and improving real-life processes and
systems.
3.3 event log
as indicated earlier, event logs serve as the starting point for process mining. an
event log is a multiset of traces . each trace describes the life-cycle of a particular
case (i.e., a process instance ) in terms of the activities executed.
denition 10 (trace, event log). letauabe a set of activities. a trace
2ais a sequence of activities. l2b(a)is an event log, i.e., a multiset of
traces.
an event log is a multiset of traces because there can be multiple cases having
the same trace. in this simple denition of an event log, an event refers to just an
activity . often event logs store additional information about events. for example,
many process mining techniques use extra information such as the resource (i.e.,
person or device) executing or initiating the activity, the timestamp of the event,
ordata elements recorded with the event (e.g., the size of an order). in this paper,
we abstract from such information. however, the results presented can easily be
extended to event logs containing additional information.
an example log is l1= [ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5].l1
contains information about 20 cases, e.g., 10 cases followed trace ha;c;d;f;gi.
there are 105 + 54 + 59 = 115 events in total.process mining in the large: a tutorial 15
the projection function x(cf. denition 2) is generalized to event logs,
i.e., for some event log l2b(a) and setxa:lx= [xj2l]. for
example,l1fa;g;hg= [ha;gi15;ha;hi5]. we will refer to these projected event
logs as sublogs .
4 process discovery
process discovery is one of the most challenging process mining tasks. in this
paper we consider the basic setting where we want to learn a system net
sn= (n;m init;mnal)2u snfrom an event log l2b(a). we will present
two process discovery techniques: the -algorithm and an approach based on
language-based regions. these techniques have many limitations (e.g., unable to
deal with noise), but they serve as a good starting point for better understanding
this challenging topic.
4.1 alpha algorithm
first we describe the -algorithm [21]. this was the rst process discovery tech-
nique able to discover concurrency. moreover, unlike most other techniques, the
-algorithm was proven to be correct for a clearly dened class of processes
[21]. nevertheless, we would like to stress that the basic algorithm has many
limitations including the inability to deal with noise, particular loops, and non-
free-choice behavior. yet, it provides a good introduction into the topic. the
-algorithm is simple and many of its ideas have been embedded in more com-
plex and robust techniques. we will use the algorithm as a baseline for discussing
the challenges related to process discovery.
the-algorithm scans the event log for particular patterns . for example, if
activityais followed by bbutbis never followed by a, then it is assumed that
there is a causal dependency between aandb.
denition 11 (log-based ordering relations). letl2b(a)be an event
log overa, i.e.,l2b(a). leta;b2a:
{a>lbif and only if there is a trace =ht1;t2;t3;:::tniandi2f1;:::;n 1g
such that2landti=aandti+1=b;
{a!lbif and only if a>lbandb6>la;
{a#lbif and only if a6>lbandb6>la; and
{aklbif and only if a>lbandb>la.
consider for instance event log l2= [ha;b;c;di3;ha;c;b;di2;ha;e;di]. for
this event log the following log-based ordering relations can be found.
>l2=f(a;b);(a;c);(a;e);(b;c);(c;b);(b;d);(c;d);(e;d)g
!l2=f(a;b);(a;c);(a;e);(b;d);(c;d);(e;d)g
#l2=f(a;a);(a;d);(b;b);(b;e);(c;c);(c;e);(d;a);(d;d);(e;b);(e;c);(e;e)g
kl2=f(b;c);(c;b)g16 w.m.p. van der aalst
relation>l2contains all pairs of activities in a \directly follows" relation. c>l2
dbecauseddirectly follows cin traceha;b;c;di. however, d6>l2cbecausec
never directly follows din any trace in the log. !l2contains all pairs of activities
in a \causality" relation, e.g., c!l2dbecause sometimes ddirectly follows c
and never the other way around ( c>l2dandd6>l2c).bkl2cbecauseb>l2c
andc >l2b, i.e., sometimes cfollowsband sometimes the other way around.
b#l2ebecauseb6>l2eande6>l2b.
for any log loveraandx;y2a:x!ly,y!lx,x#ly, orxkly, i.e.,
precisely one of these relations holds for any pair of activities. the log-based
ordering relations can be used to discover patterns in the corresponding process
model as is illustrated in fig. 6. if aandbare in sequence, the log will show
a!lb. if afterathere is a choice between bandc, the log will show a!lb,
a!lc, andb#lcbecauseacan be followed by bandc, butbwill not be
followed by cand vice versa. the logical counterpart of this so-called xor-split
pattern is the xor-join pattern as shown in fig. 6(b-c). if a!lc,b!lc,
anda#lb, then this suggests that after the occurrence of either aorb,cshould
happen. figure 6(d-e) shows the so-called and-split and and-join patterns. if
a!lb,a!lc, andbklc, then it appears that after abothbandccan be
executed in parallel (and-split pattern). if a!lc,b!lc, andaklb, then the
log suggests that cneeds to synchronize aandb(and-join pattern).
a b
(a) sequence pattern: a→b
ab
c
(b) xor-split pattern:
a→b, a→c, and b#ca
bc
(c) xor-join pattern:
a→c, b→c, and a#b
ab
c
(d) and-split pattern:
a→b, a→c, and b||ca
bc
(e) and-join pattern:
a→c, b→c, and a||b
fig. 6. typical process patterns and the footprints they leave in the event log
figure 6 only shows simple patterns and does not present the additional con-
ditions needed to extract the patterns. however, it provides some initial insights
useful when reading the formal denition of the -algorithm [21].process mining in the large: a tutorial 17
denition 12 ( -algorithm). letl2b(a)be an event log over a.(l)
produces a system net and is dened as follows:
1.tl=ft2aj92lt2g,
2.ti=ft2aj92lt=rst()g,
3.to=ft2aj92lt=last()g,
4.xl=f(a;b)jatl^a6=; ^btl^b6=; ^ 8a2a8b2ba!l
b^ 8a1;a22aa1#la2^ 8b1;b22bb1#lb2g,
5.yl=f(a;b)2xlj8(a0;b0)2xlaa0^bb0=)(a;b) = (a0;b0)g,
6.pl=fp(a;b)j(a;b)2ylg[fil;olg,
7.fl=f(a;p(a;b))j(a;b)2yl^a2ag[f (p(a;b);b)j(a;b)2yl^b2
bg [f (il;t)jt2tig [f (t;ol)jt2tog,
8.ll2tl!awithl(t) =tfort2tl, and
9.(l) = (n;m init;mnal)withn= (pl;tl;fl;ll),minit= [il],mnal=
[ol].
in step 1 it is checked which activities do appear in the log ( tl). these
are the observed activities and correspond to the transitions of the generated
system net. tiis the set of start activities, i.e., all activities that appear rst in
some trace (step 2). tois the set of end activities, i.e., all activities that appear
last in some trace (step 3). steps 4 and 5 form the core of the -algorithm.
the challenge is to determine the places of the petri net and their connections.
we aim at constructing places named p(a;b)such thatais the set of input
transitions (p(a;b)=a) andbis the set of output transitions ( p(a;b)=b)
ofp(a;b).
a1
...a2
amb1
b2
bnp(a,b) ...
a={a1,a2, … am} b={b1,b2, … bn}ti1
ti={ti1,ti2, …}...ti2to1
to={to1,to2, …}...to2 ilol
fig. 7. placep(a;b )connects the transitions in set ato the transitions in set b,ilis
the input place of all start transition ti, andolis the output place of all end transition
to.
the basic motivation for nding p(a;b)is illustrated by fig. 7. all elements
ofashould have causal dependencies with all elements of b, i.e., for all ( a;b)2
ab:a!lb. moreover, the elements of ashould never follow one another, i.e.,
for alla1;a22a:a1#la2. a similar requirement holds for b. let us consider
l2= [ha;b;c;di3;ha;c;b;di2;ha;e;di] again. clearly, a=fagandb=fb;eg
meet the requirements stated in step 4. also a0=fagandb0=fbgmeet the18 w.m.p. van der aalst
same requirements. xlis the set of all such pairs that meet the requirements
just mentioned. in this case:
xl2=f(fag;fbg);(fag;fcg);(fag;feg);(fag;fb;eg);(fag;fc;eg);
(fbg;fdg);(fcg;fdg);(feg;fdg);(fb;eg;fdg);(fc;eg;fdg)g
if one would insert a place for any element in xl2, there would be too many
places. therefore, only the \maximal pairs" ( a;b) should be included. note that
for any pair ( a;b)2xl, non-empty set a0a, and non-empty set b0b,
it is implied that ( a0;b0)2xl. in step 5, all non-maximal pairs are removed,
thus yielding:
yl2=f(fag;fb;eg);(fag;fc;eg);(fb;eg;fdg);(fc;eg;fdg)g
every element of ( a;b)2ylcorresponds to a place p(a;b)connecting tran-
sitionsato transitions b. in addition plalso contains a unique source place il
and a unique sink place ol(cf. step 6). in step 7 the arcs of the petri net are
generated. all start transitions in tihaveilas an input place and all end transi-
tionstohaveolas output place. all places p(a;b)haveaas input nodes and b
as output nodes. figure 8 shows the resulting system net. since transition iden-
tiers and labels coincide ( l(t) =tfort2tl) we only show the labels. for any
event logl,(l) = (n;m init;mnal) withn= (pl;tl;fl;ll),minit= [il],
mnal= [ol] aims to describe the behavior recorded in l.
a dp({a},{b,e})
il olb
cep({b,e},{d})
p({a},{c,e}) p({c,e},{d})
2 2
fig. 8. system net (l2) = (n;[il2];[ol2]) for event log l2=
[ha;b;c;di3;ha;c;b;di2;ha;e;di].
next, we consider the following three events logs l3a= [ha;c;di88;ha;c;ei82;
hb;c;di83;hb;c;ei87],l3b= [ha;c;di88;hb;c;ei87],l3c= [ha;c;di88;ha;c;ei2;
hb;c;di3;hb;c;ei87].(l3a) = sn3a, i.e., the system net depicted in figure 9
without places p3andp4(modulo renaming of places). it is easy to check that
all traces in l3aare allowed by the discovered model sn3aand that all ring
sequences of the sn3aappear in the event log. now consider l3b. surprisingly,
(l3b) =(l3a) = sn3a(modulo renaming of places). note that event logs
l3aandl3bare identical with respect to the \directly follows" relation, i.e.,
>l3a=>l3b. the-algorithm is unable to discover sn3bbecause the de-
pendencies between on the one hand aanddand on the other hand candeare
non-local:a,d,candenever directly follow one another. still, (l3a) allowsprocess mining in the large: a tutorial 19
for all behavior in l3b(and more). sometimes it is not so clear which model
is preferable. consider for example l3cwhere two traces are infrequent. sn3a
allows for all behavior in l3c, including the infrequent ones. however, sn3bis
more precise as it only shows the \highways" in l3c. often people are inter-
ested in the \80 =20 model", i.e., the process model that can describe 80% of the
behavior seen in the log. this model is typically relatively simple because the
remaining 20% of the log often account for 80% of the variability in the process.
hence, people may prefer sn3bover sn3aforl3c.
bca
ed
p1 p2p3
p4il ol
fig. 9. sn 3a= (n3a;[il];[ol]) is the system net depicted without placesp3andp4.
sn 3b= (n3b;[il];[ol]) is the same net but now including placesp3andp4. (only the
transition labels are shown.)
if we assume that all transitions in figure 5 have a visible label and we have
an event log lthat is complete with respect to the \directly follows" relation
(i.e.,x >lyif and only if ycan be directly followed by xin the model), then
the-algorithm is able to rediscover the original model. if t7 is invisible (not
recorded in event log), then a more compact, but correct, model is derived by the
-algorithm. if t2 ort11 is invisible, the -algorithm fails to discover a correct
model, e.g., skipping activity b(t2) does not leave a trail in the event log and
requires a more sophisticated discovery technique.
4.2 region-based process discovery
in the context of petri nets, researchers have been looking at the so-called synthe-
sis problem , i.e., constructing a system model its desired behavior. state-based
regions can be used to construct a petri net from a transition system [36, 48].
language-based regions can be used to construct a petri net from a prex-closed
language. synthesis approaches using language-based regions can be applied di-
rectly to event logs. to apply state-based regions, one rst needs to create a
transition system as shown in [19]. here, we restrict ourselves to an informal
introduction to language-based regions.
suppose, we have an event log l2b(a). for this log one could construct
a system net snwithout any places and just transitions being continuously
enabled. given a set of transitions with labels athis system net is able to
reproduce any event log l2b(a). such a petri net is called the \ower model"
and adding places to this model can only limit the behavior. language-based20 w.m.p. van der aalst
regions aim at nding places such that behavior is restricted properly, i.e., allow
for the observed and likely behavior [27, 28, 32, 94].
a1
a2b1
b2d
prec1
cf
y x
fig. 10. regionr= (x;y;c ) corresponding to place pr:x=fa1;a2;c1g=pr,
y=fb1;b2;c1g=pr, andcis the initial marking of pr
consider for example place prin fig. 10. removing place prwill not remove
any behavior. however, adding prmay remove behavior possible in the petri
net without this place. the behavior gets restricted when a place is empty while
one of its output transitions wants to consume a token from it. for example,
b1 is blocked if pris unmarked while all other input places of b1 are marked.
suppose now that we have a multiset of traces l. if these traces are possible in
the net with place pr, then they are also possible in the net without pr. the
reverse does not always hold. this triggers the question whether prcan be added
without disabling any of the traces in l. this is what regions are all about.
denition 13 (language-based region). letl2b(a)be an event log.
r= (x;y;c )is aregion oflif and only if:
{xais the set of input transitions of r;
{yais the set of output transitions of r;
{c2f0;1gis the initial marking of r; and
{ for any2l,k2f1;:::;jjg:
c+x
t2xmultsk 1()(t) x
t2ymultsk()(t)0:
r= (x;y;c ) is a region of lif and only if inserting a place prwithpr=x,
pr=y, and initially ctokens does not disable the execution of any of the traces
inl. to check this, denition 13 inspects all events in the event log. let 2l
be a trace in the log. a=(k) is thek-th event in this trace. this event should
not be disabled by place pr. therefore, we calculate the number of tokens m(pr)
that are in this place just before the occurrence of the k-th event.process mining in the large: a tutorial 21
m(pr) =c+x
t2xmultsk 1()(t) x
t2ymultsk 1()(t)
multsk 1() is the multiset of events that occurred before the occurrence of
thek-th event.p
t2xmultsk 1()(t) counts the number of tokens produced for
placepr,p
t2ymultsk 1()(t) counts the number of tokens consumed from this
place, andcis the initial number of tokens in pr. therefore, m(pr) is indeed
the number of tokens in prjust before the occurrence of the k-th event. this
number should be positive. in fact, there should be at least one token in prif
a2y. in other words, m(pr) minus the number of tokens consumed from pr
by thek-th event should be non-negative. hence:
m(pr) x
t2y[a](t) =c+x
t2xmultsk 1()(t) x
t2ymultsk()(t)0:
this shows that a region r, according to denition 13, indeed corresponds to a
so-called feasible place pr, i.e., a place that can be added without disabling any
of the traces in the event log.
the requirement stated in denition 13 can also be formulated in terms
of an inequation system. to illustrate this we use the example log l3b=
[ha;c;di88;hb;c;ei87] for which the -algorithm was unable to nd a suitable
model. there are ve activities. for each activity twe introduce two variables:
xtandyt.xt= 1 if transition tproduces a token for prandxt= 0 if not.yt= 1
if transition tconsumes a token from prandyt= 0 if not. a potential region
r= (x;y;c ) corresponds to an assignment for all of these variables: xt= 1 if
t2x,xt= 0 ift62x,yt= 1 ift2y,yt= 0 ift62y. the requirement stated
in denition 13 can now be reformulated in terms of the variables xa,xb,xc,
xd,xe,ya,yb,yc,yd,ye, andcfor event log l3b:
c ya0
c+xa (ya+yc)0
c+xa+xc (ya+yc+yd)0
c yb0
c+xb (yb+yc)0
c+xb+xc (yb+yc+ye)0
c;xa;:::;xe;ya;:::;ye2f0;1g
note that these inequations are based on all non-empty prexes of ha;c;diand
hb;c;ei. any solution of this linear inequation system corresponds to a region.
some example solutions are:22 w.m.p. van der aalst
r1= (;;fa;bg;1)
c=ya=yb= 1; xa=xb=xc=xd=xe=yc=yd=ye= 0
r2= (fa;bg;fcg;0)
xa=xb=yc= 1; c=xc=xd=xe=ya=yb=yd=ye= 0
r3= (fcg;fd;eg;0)
xc=yd=ye= 1; c=xa=xb=xd=xe=ya=yb=yc= 0
r4= (fd;eg;;;0)
xd=xe= 1; c=xa=xb=xc=ya=yb=yc=yd=ye= 0
r5= (fag;fdg;0)
xa=yd= 1; c=xb=xc=xd=xe=ya=yb=yc=ye= 0
r6= (fbg;feg;0)
xb=ye= 1; c=xa=xc=xd=xe=ya=yb=yc=yd= 0
consider for example r6= (fbg;feg;0). this corresponds to the solution
xb=ye= 1 andc=xa=xc=xd=xe=ya=yb=yc=yd= 0. if we ll out
the values in the inequation system, we can see that this is indeed a solution.
if we construct a petri net based on these six regions, we obtain sn3b, i.e., the
system net depicted in figure 9 including places p3andp4(modulo renaming of
places).
suppose that the trace ha;c;eiis added to event log l3b. this results in three
additional inequations:
c ya0
c+xa (ya+yc)0
c+xa+xc (ya+yc+ye)0
only the last inequation is new. because of this inequation, xb=ye= 1 and
c=xa=xc=xd=xe=ya=yb=yc=yd= 0 is no longer a solution. hence,
r6= (fbg;feg;0) is not a region anymore and place p4 needs to be removed
from the system net shown in figure 9. after removing this place, the resulting
system net indeed allows for ha;c;ei.
one of the problems of directly applying language-based regions is that the
linear inequation system has many solutions. few of these solutions correspond
to sensible places. for example, xa=xb=yd=ye= 1 andc=xc=xd=
xe=ya=yb=yc= 0 also denes a region: r7= (fa;bg;fd;eg;0). however,
adding this place to figure 9 would only clutter the diagram. another example
isc=xa=xb=yc= 1 andxc=xd=xe=ya=yb=yd=ye= 0, i.e.,
regionr8= (fa;bg;fcg;1). this region is a weaker variant of r2as the place is
initially marked.
another problem is that classical techniques for language-based regions aim
at a petri net that does not allow for any behavior not seen in the log [28].
this means that the log is considered to be complete. this is very unrealis-
tic and results in models that are complex and overtting. to address theseprocess mining in the large: a tutorial 23
problems dedicated techniques have been proposed. for instance, in [94] it is
shown how to avoid overtting and how to ensure that the resulting model has
desirable properties (wf-net, free-choice, etc.). nevertheless, pure region-based
techniques tend to have problems handling noise and incompleteness.
4.3 other process discovery approaches
the-algorithm and the region-based approach just presented have many limita-
tions. however, there are dozens of more advanced process discovery approaches.
for example, consider genetic process mining techniques [66, 30]. the idea of ge-
netic process mining is to use evolution (\survival of the ttest") when searching
for a process model. like in any genetic algorithm there are four main steps: (a)
initialization, (b) selection, (c) reproduction, and (d) termination. in the ini-
tialization step the initial population is created. this is the rst generation of
individuals to be used. here an individual is a process model (e.g., a petri net,
transition system, markov chain or process tree). using the activity names ap-
pearing in the log, process models are created randomly. in a generation there
may be hundreds or thousands of individuals (e.g., candidate petri nets). in the
selection step , the tness of each individual is computed. a tness function de-
termines the quality of the individual in relation to the log.2tournaments among
individuals and elitism are used to ensure that genetic material of the best pro-
cess models has the highest probability of being used for the next generation:
survival of the ttest . in the reproduction phase the selected parent individuals
are used to create new ospring. here two genetic operators are used: crossover
(creating child models that share parts of the genetic material of their parents)
andmutation (e.g., randomly adding or deleting causal dependencies). through
reproduction and elitism a new generation is created. for the models in the new
generation tness is computed. again the best individuals move on to the next
round (elitism) or are used to produce new ospring. this is repeated and the
expectation is that the \quality" of each generation gets better and better. the
evolution process terminates when a satisfactory solution is found, i.e., a model
having at least the desired tness.
next to genetic process mining techniques [66, 30] there are many other
discovery techniques. for example, heuristic [93] and fuzzy [53] mining techniques
are particularly suitable for practical applications, but are outside the scope of
this tutorial paper (see [2] for a more comprehensive overview).
5 conformance checking
conformance checking techniques investigate how well an event log l2b(a)
and a system net sn= (n;m init;mnal) t together. note that snmay have
2note that \tness" in genetic mining has a dierent meaning than the (replay) tness
at other places in this paper. genetic tness corresponds to the more general notion
of conformance including replay tness, simplicity, precision, and generalization.24 w.m.p. van der aalst
been discovered through process mining or may have been made by hand. in any
case, it is interesting to compare the observed example behavior in lwith the
potential behavior of sn.
5.1 quality dimensions
conformance checking can be done for various reasons. first of all, it may be
used to audit processes to see whether reality conforms to some normative or
descriptive model [14, 41]. deviations may point to:
{fraud (deliberate non-conforming behavior),
{ineciencies (carelessness or sloppiness causing unnecessary delays or costs),
{exceptions (selected cases are handled in an ad-hoc manner because of special
circumstances not covered by the model),
{poorly designed procedures (to get the work done people need to deviate from
the model continuously), or
{outdated procedures (the process description does not match reality anymore
because the process evolved over time).
second, conformance checking can be used to evaluate the performance of a pro-
cess discovery technique. in fact, genetic process mining algorithms use confor-
mance checking to select the candidate models used to create the next generation
of models [66, 30].
there are four quality dimensions for comparing model and log: (1) replay
tness , (2) simplicity , (3) precision , and (4) generalization [2]. a model with
good replay tness allows for most of the behavior seen in the event log. a model
has a perfect tness if all traces in the log can be replayed by the model from
beginning to end. if there are two models explaining the behavior seen in the
log, we generally prefer the simplest model. this principle is known as occam's
razor. fitness and simplicity alone are not sucient to judge the quality of a
discovered process model. for example, it is very easy to construct an extremely
simple petri net (\ower model") that is able to replay all traces in an event log
(but also any other event log referring to the same set of activities). similarly,
it is undesirable to have a model that only allows for the exact behavior seen
in the event log. remember that the log contains only example behavior and
that many traces that are possible may not have been seen yet. a model is
precise if it does not allow for \too much" behavior. clearly, the \ower model"
lacks precision. a model that is not precise is \undertting". undertting is the
problem that the model over-generalizes the example behavior in the log (i.e.,
the model allows for behaviors very dierent from what was seen in the log). at
the same time, the model should generalize and not restrict behavior to just the
examples seen in the log. a model that does not generalize is \overtting" [8, 9].
overtting is the problem that a very specic model is generated whereas it is
obvious that the log only holds example behavior (i.e., the model explains the
particular sample log, but there is a high probability that the model is unable
to explain the next batch of cases). process discovery techniques typically have
problems nding the appropriate balance between precision and generalizationprocess mining in the large: a tutorial 25
because the event log only contains \positive examples", i.e., the event log does
not indicate what could nothappen.
in the remainder, we will focus on tness. however, replay tness is the
starting point to the other quality dimensions [8, 9, 30].
5.2 token-based replay
a simple tness metric is the fraction of perfectly tting traces. for exam-
ple, the system net shown in figure 8 has a tness of 0.8 for event log
l4= [ha;b;c;di3;ha;c;b;di3;ha;e;di2;ha;di;ha;e;e;di] because 8 of the 10 traces
t perfectly. such a na ve tness metric is less suitable for more realistic pro-
cesses because it cannot distinguish between \almost tting" traces and traces
that are completely unrelated to the model. therefore, we also need a more re-
ned tness notion dened at the level of events rather than full traces. rather
than aborting the replay of a trace once we encounter a problem we can also
continue replaying the trace on the model and record all situations where a tran-
sition is forced to re without being enabled, i.e., we count all missing tokens.
moreover, we record the tokens that remain at the end.
a db
ce1:p2:c2:p
2:p3:c 3:p
4:c 4:p5:c
5:c5:p6:cp=6
c=6
m=0
r=0
fig. 11. replaying trace 1=ha;b;c;dion the system net shown in figure 8:
tness (1) =1
2(1 0
6) +1
2(1 0
6) = 1. (place and transition identiers are not
shown, only the transition labels are depicted.)
to explain the idea, we rst replay 1=ha;b;c;dion the system net shown
in figure 8. we use four counters: p(produced tokens), c(consumed tokens), m
(missing tokens), and r(remaining tokens). initially, p=c= 0 and all places
are empty. then the environment produces a token to create the initial marking.
therefore, the pcounter is incremented: p= 1 (step 1 in figure 11). now we
need to re transition arst. this is possible. since aconsumes one token and
produces two tokens, the ccounter is incremented by 1 and the pcounter is
incremented by 2 (step 2 in figure 11). therefore, p= 3 andc= 1 after ring
transitiona. then we replay the second event ( b). firing transition bresults in
p= 4 andc= 2 (step 3 in figure 11). after replaying the third event (i.e. c)
p= 5 andc= 3. they we replay d. sincedconsumes two tokens and produces
one, the result is p= 6 andc= 5 (step 5 in figure 11). at the end, the
environment consumes a token from the sink place (step 6 in figure 11). hence
the nal result is p=c= 6 andm=r= 0. clearly, there are no problems when
replaying the 1, i.e., there are no missing or remaining tokens ( m=r= 0).26 w.m.p. van der aalst
the tness of trace is dened as follows:
tness () =1
2
1 m
c
+1
2
1 r
p
the rst parts computes the fraction of missing tokens relative to the number of
consumed tokens. 1  m
c= 1 if there are no missing tokens ( m= 0) and 1 m
c= 0
if all tokens to be consumed were missing ( m=c). similarly, 1 r
p= 1 if there
are no remaining tokens and 1  r
p= 0 if none of the produced tokens was
actually consumed. we use an equal penalty for missing and remaining tokens.
by denition: 0tness ()1. in our example, tness (1) =1
2(1 0
6) +
1
2(1 0
6) = 1 because there are no missing or remaining tokens.
a db
ce1:p2:c2:p
2:p3:m
3:m3:c
3:c3:p4:cp=4
c=4
m=2
r=24:r
4:r
fig. 12. replaying trace 2=ha;dion the system net shown in figure 8: tness (2) =
1
2(1 2
4) +1
2(1 2
4) = 0:5.
let us now consider a trace that cannot be replayed properly. figure 12
shows the process of replaying 2=ha;di. initially,p=c= 0 and all places
are empty. then the environment produces a token for the initial marking and
thepcounter is updated: p= 1. the rst event ( a) can be replayed (step 2
in figure 12). after ring a, we havep= 3,c= 1,m= 0, andr= 0. now
we try to replay the second event. this is not possible, because transition dis
not enabled. to re d, we need to add a token to each of the input places of
dand record the two missing tokens (step 3 in figure 12) the mcounter is
incremented. the pandccounter are updated as usual. therefore, after ring d,
we havep= 4,c= 3,m= 2, andr= 0. at the end, the environment consumes
a token from the sink place (step 4 in figure 12). moreover, we note the two
remaining tokens on the output places of a. hence the nal result is p=c= 4
andm=r= 2. figure 12 shows diagnostic information that helps to understand
the nature of non-conformance. there was a situation in which doccurred but
could not happen according to the model ( m-tags) and there was a situation
in whichbandcorewere supposed to happen but did not occur according to
the log (r-tags). moreover, we can compute the tness of trace 2based on the
values ofp,c,m, andr:tness (2) =1
2 
1 2
4
+1
2 
1 2
4
= 0:5.
figures 11 and 12 illustrate how to analyze the tness of a single case. the
same approach can be used to analyze the tness of a log consisting of many
cases. simply take the sums of all produced, consumed, missing, and remaining
tokens, and apply the same formula. let pdenote the number of producedprocess mining in the large: a tutorial 27
tokens when replaying onn.c,m,rare dened in a similar fashion, e.g.,
mis the number of missing tokens when replaying . now we can dene the
tness of an event log lon a given system net:
tness (l) =1
2
1 p
2ll()mp
2ll()c
+1
2
1 p
2ll()rp
2ll()p
by replaying the entire event log, we can now compute the tness of event log
l4= [ha;b;c;di3;ha;c;b;di3;ha;e;di2;ha;di;ha;e;e;di] for the system net shown
in figure 8. the total number of produced tokens is p= 36+36+26+14+18 =
60. there are also c= 60 consumed tokens. the number of missing tokens is
m= 30 + 30 + 20 + 12 + 12 = 4. there are also r= 4 remaining tokens.
hence, tness (l4) =1
2 
1 4
60
+1
2 
1 4
60
= 0:933.
typically, the event-based tness is higher than the na ve case-based tness.
this is also the case here. the system net in figure 8 can only replay 80% of
the cases from start to end. however, about 93% of the individual events can be
replayed. for more information on token-based replay we refer to [2, 80].
an event log can be split into two sublogs: one event log containing only
tting cases and one event log containing only non-tting cases . each of the
event logs can be used for further analysis. for example, one could construct
a process model for the event log containing only deviating cases. also other
data and process mining techniques can be used, e.g., one can use classication
techniques to further investigate non-conformance.
5.3 aligning observed and modeled behavior
there are various ways to quantify tness [2, 9, 22, 52, 66, 69, 70, 80]. the simple
procedure of counting missing, remaining, produced, and consumed tokens has
several limitations. for example, in case of multiple transitions with the same
label or transitions that are invisible, there are all kinds of complications. which
path to take if multiple transitions with the same label are enabled? moreover,
in case of poor tness the petri net is ooded with tokens thus resulting in
optimistic estimates (many transitions are enabled). the notion of cost-based
alignments [9, 22] provides a more robust and exible approach for conformance
checking.
to measure tness, we align traces in the event log to traces of the pro-
cess model. consider the following three alignments for the traces in l1=
[ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5] and the system net in figure 5:
1=acdfg
acdfg
t1t4t2t5t7t8t9t112=acdh
acdh
t1t4t2t5t10
3=abcdecdgf
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t1128 w.m.p. van der aalst
the top row of each alignment corresponds to \moves in the log" and the bottom
two rows correspond to \moves in the model". moves in the model are repre-
sented by the transition and its label. this is needed because there could be
multiple transitions with the same label. in alignment 1the rst column refers
to a \move in both", i.e., both the event log and the process model make an a
move. if a move in the model cannot be mimicked by a move in the log, then
a \" (\no move") appears in the top row. this situation is referred to as a
\move in model". for example, in the third position of 1the log cannot mimic
the invisible transition t2. theabovet2 indicates that t262dom(l). in the
remainder, we write l(t) =ift62dom(l). note that all \no moves" (i.e., the
sevensymbols) in 1 3are \caused" by invisible transitions.
let us now consider some example alignments for the deviating event log
l0
1= [ha;c;d;fi10;ha;c;d;c;hi5;ha;b;d;e;c;d;g;f;h i5] and system net snin
figure 5:
4=acdf
acdfg
t1t4t2t5t7t8t9t115=acdch
acdh
t1t4t2t5t10
6=abdecdgfh
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
alignment 4shows a \" (\no move") in the top row that does not cor-
respond to an invisible transition. the model makes a gmove (occurrence of
transitiont9) that is not in the log. alignment 6has a similar move in the
third position: the model makes a cmove (occurrence of transition t4) that is
not in the log. if a move in the log cannot be mimicked by a move in the model,
then a \" (\no move") appears in the bottom row. this situation is referred
to as a \move in log". for example, in 5thecmove in the log is not mimicked
by a move in the model and in 6thehmove in the log is not mimicked by
a move in the model. note that the \no moves" not corresponding to invisible
transitions point to deviations between model and log.
amove is a pair (x;(y;t)) where the rst element refers to the log and the
second element refers to the model. for example, ( a;(a;t1)) means that both
log and model make an \ amove" and the move in the model is caused by the
occurrence of transition t1. (;(g;t9)) means that the occurrence of transition
t9 with label gis not mimicked by corresponding move of the log. ( c;) means
that the log makes an \ cmove" not followed by the model.
denition 14 (legal moves). letl2b(a)be an event log and let sn =
(n;m init;mnal)2 u snbe a system net with n= (p;t;f;l ).alm =
f(x;(x;t))jx2a^t2t^l(t) =xg[f (;(x;t))jt2t^l(t) =
xg[f (x;)jx2agis the set of legal moves .
an alignment is a sequence of legal moves such that after removing all sym-
bols, the top row corresponds to a trace in the log and the bottom row cor-
responds to a ring sequence starting in minitand ending mnal. hence, the
middle row corresponds to a visible path when ignoring the steps.process mining in the large: a tutorial 29
denition 15 (alignment). letl2lbe a log trace and m2f(sn)
a complete ring sequence of system net sn . an alignment oflandmis
a sequence 2almsuch that the projection on the rst element (ignoring
) yieldsland the projection on the last element (ignoring and transition
labels) yields m.
1{3are examples of alignments for the traces in l1and their corresponding r-
ing sequences in the system net of figure 5. 4{6are examples of alignments for
the traces in l0
1and complete ring sequences of the same system net. the pro-
jection of6on the rst element (ignoring ) yieldsl=ha;b;d;e;c;d;g;f;h i
which is indeed a trace in l0
1. the projection of 6on the last element (ignor-
ingand transition labels) yields m=ht1;t3;t4;t5;t6;t4;t2;t5;t7;t9;t8;t11i
which is indeed a complete ring sequence. the projection of 6on the middle el-
ement (i.e., transition labels while ignoring and) yieldsha;b;c;d;e;c;d;g;f i
which is indeed a visible trace of the system net of figure 5.
given a log trace and a process model there may be many (if not innitely
many) alignments. consider the following two alignments for ha;c;d;fi2l0
1:
4=acdf
acdfg
t1t4t2t5t7t8t9t110
4=acdf
acbdh
t1t4t3t5t7t10
4seems to be better alignment than 0
4because it has only one deviation (move
in model only; (;(g;t9))) whereas 0
4has three deviations: ( ;(b;t3)), (f;),
and (;(h;t11)). to select the most appropriate one we associate costs to un-
desirable moves and select an alignment with the lowest total costs. to quantify
the costs of misalignments we introduce a cost function .
denition 16 (cost of alignment). cost function 2alm!i nassigns
costs to legal moves. the cost of an alignment 2almis the sum of all costs:
() =p
(x;y)2(x;y).
moves where log and model agree have no costs, i.e., (x;(x;t)) = 0 for all
x2a. moves in model only have no costs if the transition is invisible, i.e.,
(;(;t)) = 0 ifl(t) =.(;(x;t))>0 is the cost when the model makes
an \xmove" without a corresponding move of the log (assuming l(t) =x6=).
(x;)>0 is the cost for an \ xmove" in just the log. these costs may depend
on the nature of the activity, e.g., skipping a payment may be more severe than
sending too many letters. however, in this paper we often use a standard cost
functionsthat assigns unit costs: s(x;(x;t)) = 0,s(;(;t)) = 0, and
s(;(x;t)) =s(x;) = 1 for all x2a. for example, s(1) =s(2) =
s(3) = 0,s(4) = 1,s(5) = 1, and s(6) = 2 (simply count the number
ofsymbols not corresponding to invisible transitions). now we can compare
the two alignments for ha;c;d;fi2l0
1:s(4) = 1 ands(0
4) = 3. hence, we
conclude that 4is \better" than 0
4.
denition 17 (optimal alignment). letl2b(a)be an event log with
auaand let sn2usnbe a system net with (sn)6=;.30 w.m.p. van der aalst
{ forl2l, we dene:  l;sn =f2almj 9m2f(sn)is an
aligment of landmg.
{ an alignment 2 l;snisoptimal for tracel2land system net sn if
for any02 l;m:(0)().
{sn2a!almis a deterministic mapping that assigns any log trace l
to an optimal alignment, i.e., sn(l)2 l;snandsn(l)is optimal.
{ costs (l;sn;) =p
l2l(sn(l))are the misalignment costs of the whole
event log.
1 6is are optimal alignments for the corresponding six possible traces in
event logs l1andl0
1and the system net in figure 5. 0
4is not an optimal
alignment forha;c;d;fi.costs (l1;sn;s) = 10s(1) + 5s(2) + 5
s(3) = 100 + 50 + 50 = 0. hence, l1is perfectly tting system net sn.
costs (l0
1;sn;s) = 10s(4)+5s(5)+5s(6) = 101+51+52 = 25.
it is possible to convert misalignment costs into a tness value between 0
(poor tness, i.e., maximal costs) and 1 (perfect tness, zero costs). we refer to
[9, 22] for details.
only perfectly tting traces have costs 0 (assuming (sn)6=;). hence,
event loglis perfectly tting system net snif and only if costs (l;sn;) = 0.
once an optimal alignment has been established for every trace in the event
log, these alignments can also be used as a basis to quantify other conformance
notations such as precision and generalization [9]. for example, precision can
be computed by counting \escaping edges" as shown in [69, 70]. recent results
show that such computations should be based on alignments [24]. the same
holds for generalization [9]. therefore, we focus on alignments when decomposing
conformance checking problems in section 6.
5.4 beyond conformance checking
the importance of alignments cannot be overstated. alignments relate observed
behavior with modeled behavior. this is not only important for conformance
checking, but also for enriching and repairing models. for example, timestamps
in the event log can be used to analyze bottlenecks in the process model. in
fact, partial alignments can also be used to predict problems and to recommend
appropriate actions. this is illustrated by figure 13. see [2, 9] for concrete
examples.
6 decomposing process mining problems
the torrents of event data available are an important enabler for process min-
ing. however, the incredible growth of event data also provides computational
challenges. for example, conformance checking can be time consuming as po-
tentially many dierent traces need to be aligned with a model that may allow
for an exponential (or even innite) number of traces. event logs may containprocess mining in the large: a tutorial 31
modeled (normative or 
descriptive) behaviordeviating behavior may be squeezed into model for analysis 
(e.g., performance analysis, prediction, and decision mining) 
deviating behavior can be 
identified and subsequently used 
for conformance checking 
fig. 13. the essence of process mining: relating modeled and observed behavior.
millions of events. finding the best alignment may require solving many opti-
mization problems [22] or repeated state-space explorations [80]. in worst case
a state-space exploration of the model is needed per event. when using genetic
process mining, one needs to check the tness of every individual model in ev-
ery generation [66, 30]. as a result, thousands or even millions of conformance
checks need to be done. for each conformance check, the whole event log needs
to be traversed. given these challenges, we are interested in reducing the time
needed for conformance checking by decomposing the associated petri net and
event log. see [4, 3, 7] for an overview of various decomposition approaches. for
example, in [4] we discuss the vertical partitioning andhorizontal partitioning of
event logs.
event logs are composed of cases. there may be thousands or even millions
of cases. in case of vertical partitioning these can be distributed over the nodes
in the network, i.e., each case is assigned to one computing node. all nodes work
on a subset of the whole log and in the end the results need to be merged.
cases are composed of multiple events. we can also partition cases, i.e.,
part of a case is analyzed on one node whereas another part of the same case
is analyzed on another node. this corresponds to a horizontal partitioning of
the event log. in principle, each node needs to consider all cases. however, the
attention of one computing node is limited to a particular subset of events per
case.
even when only one computing node is available, it may still be benecial
to decompose process mining problems. due to the exponential nature of most
conformance checking techniques, the time needed to solve \many smaller prob-
lems" is less than the time needed to solve \one big problem". in the remainder,
we only consider the so-called horizontal partitioning of the event log.32 w.m.p. van der aalst
6.1 decomposing conformance checking
to decompose conformance checking problems we split a process model into
model fragments. in terms of petri nets: the overall system net snis decomposed
into a collection of subnets fsn1;sn2;:::; snngsuch that the union of these
subnets yields the original system net. the union of two system nets is dened
as follows.
denition 18 (union of nets). let sn1= (n1;m1
init;m1
nal)2u snwith
n1= (p1;t1;f1;l1)and sn2= (n2;m2
init;m2
nal)2usnwithn2= (p2;t2;
f2;l2)be two system nets.
{l32(t1[t2)6!uawith dom (l3) = dom(l1)[dom(l2),l3(t) =l1(t)if
t2dom(l1), andl3(t) =l2(t)ift2dom(l2)ndom(l1)is the union of l1and
l2,
{n1[n2= (p1[p2;t1[t2;f1[f2;l3)is the union of n1andn2, and
{ sn1[sn2= (n1[n2;m1
init]m2
init;m1
nal]m2
nal)is the union of system
nets sn1and sn2.
using denition 18, we can check whether the union of a collection of sub-
netsfsn1;sn2;:::; snngindeed corresponds to the overall system net sn. it
suces to check whether sn=s
1insni=sn1[sn2[:::[snn. a
decompositionfsn1;sn2;:::; snngisvalid if the subnets \agree" on the orig-
inal labeling function (i.e., the same transition always has the same label), each
place resides in just one subnet, and also each invisible transition resides in just
one subnet. moreover, if there are multiple transitions with the same label, they
should reside in the same subnet. only unique visible transitions (i.e., tu
v(sn),
cf. denition 8) can be shared among dierent subnets.
denition 19 (valid decomposition). let sn2usnbe a system net with
labeling function l.d=fsn1;sn2;:::; snngu snis a valid decomposition
if and only if
{ sni= (ni;mi
init;mi
nal)is a system net with ni= (pi;ti;fi;li)for all
1in,
{li=ltifor all 1in,
{pi\pj=;for1i<jn,
{ti\tjtu
v(sn)for1i<jn, and
{ sn =s
1insni.
d(sn)is the set of all valid decompositions of sn .
every system net has a trivial decomposition consisting of only one subnet, i.e.,
fsng2d (sn). however, we are often interested in a maximal decomposition
where the individual subnets are as small as possible. figure 14 shows the max-
imal decomposition for the system net shown in figure 5.
in [7] it is shown that a unique maximal valid decomposition always exists.
moreover, it is possible to decompose nets based on the notion of passages [3]process mining in the large: a tutorial 33
a
startt1sn1
a
c
ec2t1
t4
t6sn3ab
d
ec1 c3
t1t2
t3
t5
t6sn2
dg
h
ec5f
t5
t6t7t8
t9
t10c6c7sn5
cd
c4
t4t5sn4g
hendf
t8
t9
t10t11c8
c9
sn6
fig. 14. maximal decomposition of the system net shown in figure 5 with minit=
[start ] andmnal= [end]. the initial and nal markings are as follows: m1
init= [start ]
andmi
init= [ ] for 2i6,mi
nal= [ ] for 1i5, andm6
nal= [end].
or using single-entry single-exit (sese) components [71]. in the remainder, we
assume a valid decomposition without making any further assumptions.
next, we show that conformance checking can be done by locally inspecting
the subnets using correspondingly projected event logs. to illustrate this, con-
sider the following alignment for trace ha;b;c;d;e;c;d;g;f iand the system net
in figure 5:
3=123456789101112
abcdecdgf
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
for convenience, the moves have been numbered. now consider the following six
alignments:
1
3=1
a
a
t12
3=124578
abded
abded
t1t3t5t6t2t53
3=1356
acec
acec
t1t4t6t4
4
3=3468
cdcd
cdcd
t4t5t4t55
3=45891011
dedgf
dedgf
t5t6t5t7t9t86
3=101112
gf
gf
t9t8t11
each alignment corresponds to one of the six subnets sn1;sn2;:::sn6in fig-
ure 14. the numbers are used to relate the dierent alignments. for example 6
3
is an alignment for trace ha;b;c;d;e;c;d;g;f iand subnets sn6in figure 14. as
the numbers 10, 11 and 12 indicate, 6
3corresponds to the last three moves of
3.34 w.m.p. van der aalst
to create sublogs for the dierent model fragments, we use the projection
function introduced in section 3. consider for example the overall log l1=
[ha;c;d;f;gi10;ha;c;d;hi5;ha;b;c;d;e;c;d;g;f i5].l1
1=l1fag= [hai20],l2
1=
l1fa;b;d;eg= [ha;di15;ha;b;d;e;di5],l3
1=l1fa;c;eg= [ha;ci15;ha;c;e;ci5], etc.
are the sublogs corresponding to the subnets in figure 14.
the following theorem shows that any trace that ts the overall process model
can be decomposed into smaller traces that t the individual model fragments.
moreover, if the smaller traces t the individual model fragments, then they can
be composed into an overall trace that ts into the overall process model. this
result is the basis for decomposing a wide range of process mining problems.
theorem 1 (conformance checking can be decomposed). letl2
b(a)be an event log with auaand let sn2u snbe a system net. for
any valid decomposition d=fsn1;sn2;:::; snng2d (sn):lis perfectly t-
ting system net sn if and only if for all 1in:lav(sni)is perfectly tting
sni.
proof. see [7].u t
theorem 1 shows that any trace in the log ts the overall model if and only if
it ts each of the subnets.
let us now consider trace ha;b;d;e;c;d;g;f;h iwhich is not perfectly tting
the system net in figure 5. an optimal alignment is:
6=12345678910111213
abdecdgfh
abcdecdgf
t1t3t4t5t6t4t2t5t7t9t8t11
the alignment shows the two problems: the model needs to execute cwhereas
this event is not in the event log (position 3) and the event log contains g,f,
andhwhereas the model needs to choose between either gandforh(position
13). the cost of this optimal alignment is 2. optimal alignment 6for the overall
model can be decomposed into alignments 1
6 6
6for the six subnets:
1
6=1
a
a
t12
6=124578
abded
abded
t1t3t5t6t2t53
6=1356
aec
acec
t1t4t6t4
4
6=3468
dcd
cdcd
t4t5t4t55
6=4589101113
dedgfh
dedgf
t5t6t5t7t9t86
6=10111213
gfh
gf
t9t8t11
alignments 1
6and2
6have costs 0. alignments 3
6and4
6have costs 1 (move in
model involving c). alignments 5
6and6
6have costs 1 (move in log involving h).
if we would add up all costs, we would get costs 4 whereas the costs of optimalprocess mining in the large: a tutorial 35
alignment6is 2. however, we would like to compute an upper bound for the
degree of tness in a distributed manner. therefore, we introduce an adapted
cost function q.
denition 20 (adapted cost function). letd=fsn1;sn2;:::; snng2
d(sn)be a valid decomposition of some system net sn and 2alm!i n
a cost function (cf. denition 16). cq(a;(a;t)) =cq(;(a;t)) =cq(a;) =
jf1inja2aigjcounts the number of subnets having aas an observable
activity. the adapted cost function qis dened as follows: q(x;y) =(x;y)
cq(x;y)
for(x;y)2almandcq(x;y)6= 0.
an observable activity may appear in multiple subnets. therefore, we divide its
costs by the number of subnets in which it appears: q(x;y) =(x;y)
cq(x;y). this way
we avoid counting misalignments of the same activity multiple times. for our
example,cq(;(c;t4)) =jf3;4gj= 2 andcq(h;) =jf5;6gj= 2. assuming
the standard cost function sthis implies q(;(c;t4)) =1
2andq(h;) =1
2.
hence the aggregated costs of 1
6 6
6are 2, i.e., identical to the costs of the
overall optimal alignment.
theorem 2 (lower bound for misalignment costs). letl2b(a)be an
event log with aua, sn2u snbe a system net, and a cost function. for
any valid decomposition d=fsn1;sn2;:::; snng2d (sn):
costs (l;sn;)x
1incosts (lav(sni);sni;q)
proof. see [7].u t
the sum of the costs associated to all selected optimal local alignments (using
q) can never exceed the cost of an optimal overall alignment using . hence,
it can be used as an optimistic estimate, i.e., computing an upper bound for
the overall tness and a lower bound for the overall costs. more important,
the tness values of the dierent subnets provide valuable local diagnostics.
the subnets with the highest costs are the most problematic parts of the model.
the alignments for these \problem spots" help to understand the main problems
without having to look at very long overall alignments.
theorem 2 only provides a lower bound for the misalignment costs. the total
misalignment costs may be higher than the costs associated to the optimal local
alignments. to understand this, consider the following optimal alignments for
traceha;b;c;diand the (decomposed) process model shown in figure 15:
=abcd
ab
t1t20=abcd
cd
t3t41=abc
ab
t1t22=bcd
cd
t3t4
there are two optimal alignments ( and0) forha;b;c;diand the overall system
net shown in figure 15(a). both optimal alignments ( and0) have two moves36 w.m.p. van der aalst
a b
c dc1c2
startend
(a)  original modelsn1
a b
cc1
startb
c dc2endsn2
(b)  decomposed modelt1t1t2
t3 t4t2 t2
t3 t3 t4
fig. 15. example showing that the total misalignment costs may be higher than the
costs associated to the two optimal local alignments.
in log only (i.e., these events cannot be mimicked by the model). hence, s() =
s(0) = 2. now consider the decomposition shown in figure 15(b). the cost
of the optimal alignment 1for subnet sn1isq(1) = 0 + 0 + q(c;) =
s(c;)
cq(c;)=1
2= 0:5. the cost of the optimal alignment 2for subnet sn2is
q(2) =q(b;) + 0 + 0 =s(b;)
cq(b;)=1
2= 0:5. sinceq(1) +q(2) = 1 and
s() = 2, we can observe the misalignment costs for are indeed higher than the
costs associated to the two optimal local alignments ( 1and2). this is caused
by the fact that the two optimal local alignments don't agree on the moves with
respect to activities bandc.1suggests a move in both for activity band a move
in model for c.2makes a dierent choice and suggests a move in both for activity
cand a move in model for d. therefore, 1and2cannot be stitched back into
an overall alignment with costs 1. practical experiences show that the dierence
between costs (l;sn;) andsum 1incosts (lav(sni);sni;q) increases when
the fragments are getting smaller. hence, there is tradeo between the accuracy
of the lower bound and the degree of decomposition. if the subnets are chosen
large enough, accuracy tends to be quite good.
theorem 2 uses a rather sophisticated denition of tness. we can also simply
count the fraction of tting traces . in this case the problem can be decomposed
easily using the notion of valid decomposition.
corollary 1 (fraction of perfectly fitting traces). letl2 b(a)be
an event log with auaand let sn2u snbe a system net. for any valid
decomposition d=fsn1;sn2;:::; snng2d (sn):
j[2lj2(sn)]j
jlj=j[2lj81inav(sni)2(sni)]j
jlj
the corollary follows directly from the construction used in theorem 1. a trace is
tting the overall model if and only if it ts all subnets. as corollary 1 suggests,
traces in the event log can be marked as tting or non-tting per subnet . these
results can be merged easily and used to compute the fraction of traces tting
the overall model . note that corollary 1 holds for any decomposition of sn.process mining in the large: a tutorial 37
6.2 decomposing process discovery
process discovery, i.e., discovering a process model from event data, is highly
related to conformance checking. this can be observed when considering genetic
process mining algorithms that basically \guess" models and recombine parts of
models that have good tness to discover even better models [66, 30]. the tness
computation in genetic process mining is in essence a conformance check.
using theorem 1 we can distribute anyprocess discovery algorithm by (1)
decomposing the overall event log into smaller sublogs , (2) discovering a model
fragment for each sublog , and (3) merging the discovered models into one overall
process model .
given an event log lcontaining events referring to a set of activities
a, we decompose discovery by distributing the activities over multiple sets
a1;a2;:::;an. the same activity may appear in multiple sets as long as
a=a1[a2[:::[an. for each activity set ai, we discover a system net
sniby applying a discovery algorithm to sublog lai, i.e., the overall event log
projected onto a subset of activities. subsequently, the discovered system nets
are massaged to avoid name clashes and to make sure that transitions with a
visible label are merged properly. by combining the resulting system nets we ob-
tain an overall system net sn=sn1[sn2[:::[snndescribing the behavior
in the overall event log l[7].
the quality of the system net obtained by merging the process models dis-
covered for the sublogs highly depends on the way the activities are decomposed
and the characteristics of the discovery algorithm used per sublog. however, the
system nets discovered for the sublogs are always a valid decomposition of the
overall model. this implies that we can apply theorem 1 (conformance check-
ing can be decomposed), theorem 2 (lower bound for misalignment costs),
and corollary 1 (fraction of perfectly fitting traces). if the discovery algorithm
is able to create a perfectly tting model for each sublog, then the overall model
is also perfectly tting. moreover, if the discovery algorithm has problems nd-
ing a perfectly tting model for a particular sublog, then the overall model will
also exhibit these problems. for example, the fraction of traces tting the overall
model equals the fraction of traces tting all individual models.
6.3 decomposition strategies
the decomposition results for conformance checking and process discovery are
not tailored towards a particular type of decomposition. recently, several papers
have been published on dierent ways of decomposing process mining problems.
in [3, 89, 90] it is shown that so-called \passages" can be used to decompose both
process discovery and conformance checking problems. in [72, 71] it is shown
that so-called sese (single-exit-single-entry) components obtained through
the rened process structure tree (rpst) [75, 88] can be used to decompose
conformance checking problems. these papers use a particular particular decom-
position strategy. however, as shown in [7], there are many ways to decompose
process mining problems.38 w.m.p. van der aalst
the above papers are all using petri nets as a representation. however, as
shown in [5] the essence of the decomposition results is not limited to petri nets
at al.
experimental results shows that signicant speed-ups are possible through
decomposition [71, 89]. process mining algorithms are typically linear in the
number of cases and exponential in the average length of traces or the number
of unique activities. through a vertical partitioning [4] many process mining al-
gorithms can be decomposed trivially. consider for example conformance check-
ing problems. these are solved per case. hence, by distributing the cases over
dierent computing nodes it is easy to realize a linear speedup. discovery algo-
rithms often use some variant of the \directly follows" relation ( >l) discussed
in the context of the -algorithm. obviously a vertical partitioning (e.g. using a
map-reduce [76, 40] programming style) can be used to create such a relation
in a distributed fashion.
in this paper we focused on a horizontal partitioning of the event log be-
cause process mining algorithms tend to be exponential in the average length of
traces or the number of unique activities. hence, the potential gains of horizontal
partitioning are much larger. just like the state space of a petri net may grow
exponentially in the number of transitions, the search space may grow rapidly
as the number of dierent activities increases. hence, the time needed to solve
\many smaller problems" is often less than the time needed to solve \one big
problem", even when this is done sequentially. in fact, horizontal partitioning
may lead to super linear speedups. consider for example conformance checking
approaches that use state-space analysis (e.g., in [80] the shortest path enabling
a transition is computed) or optimization over all possible alignments (e.g., in
[22] theaalgorithm is used to nd the best alignment). these techniques do
notscale linearly in the number of activities. therefore, decomposition is often
useful even if the checks per subnet are done on a single computer. moreover,
decomposing conformance checking is not just interesting from a performance
point of view: decompositions can also be used to pinpoint the most problematic
parts of the process and provide localized diagnostics [71]. decompositions are
not just interesting for conformance diagnostics; also performance-related diag-
nostics (e.g., bottleneck analysis) benet from a hierarchical structuring of the
whole process.
7 conclusion
the torrents of event data available in most organizations enable evidence-based
business process management (ebbpm). we predict that there will be a re-
markable shift from pure model-driven or questionnaire-driven approaches to
data-driven process analysis as we are able to monitor and reconstruct the real
business processes using event data. at the same time, we expect that machine
learning and data mining approaches will become more process-centric . thus
far, the machine learning and data mining communities have not been focusingprocess mining in the large: a tutorial 39
on end-to-end processes that also exhibit concurrency. hence, it is time to move
beyond decision trees, clustering, and (association) rules.
process mining can be used to diagnose the actual processes. this is valuable
because in many organizations most stakeholders lack a correct, objective, and
accurate view on important operational processes. process mining can subse-
quently be used to improve such processes. conformance checking can be used
for auditing and compliance. by replaying the event log on a process model
it is possible to quantify and visualize deviations. similar techniques can be
used to detect bottlenecks and build predictive models. given the applicabil-
ity of process mining, we hope that this tutorial encourages the reader to start
using process mining today. the book [2] provides a comprehensive introduc-
tion into the process mining eld. moreover, the open source process mining
tool prom can be downloaded from www.processmining.org . many of the
ideas developed in the context of prom have been embedded in commercial
tools such as fluxicon's disco ( www.fluxicon.com ), perceptive process mining
(www.perceptivesoftware.com ), celonis ( www.celonis.de ), and qpr proces-
sanalyzer ( www.qpr.com ). this illustrates the practical relevance of process min-
ing.
in the last part of this tutorial we discussed some very general decomposition
results. clearly, highly scalable analysis approaches are needed to deal with the
ever-growing amounts of event data. this requires additional research eorts.
moreover, we refer to the process mining manifesto by the ieee task force on
process mining [57] for additional challenges in this exciting new research eld.
acknowledgements
this work was supported by the basic research program of the national re-
search university higher school of economics (hse).
references
1. w.m.p. van der aalst. formalization and verication of event-driven process
chains. information and software technology , 41(10):639{650, 1999.
2. w.m.p. van der aalst. process mining: discovery, conformance and enhancement
of business processes . springer-verlag, berlin, 2011.
3. w.m.p. van der aalst. decomposing process mining problems using passages. in
s. haddad and l. pomello, editors, applications and theory of petri nets 2012 ,
volume 7347 of lecture notes in computer science , pages 72{91. springer-verlag,
berlin, 2012.
4. w.m.p. van der aalst. distributed process discovery and conformance checking.
in j. de lara and a. zisman, editors, international conference on fundamental
approaches to software engineering (fase 2012) , volume 7212 of lecture notes
in computer science , pages 1{25. springer-verlag, berlin, 2012.
5. w.m.p. van der aalst. a general divide and conquer approach for process min-
ing. in m. ganzha, l. maciaszek, and m. paprzycki, editors, federated conference
on computer science and information systems (fedcsis 2013) , pages 1{10. ieee
computer society, 2013.40 w.m.p. van der aalst
6. w.m.p. van der aalst. business process management: a comprehensive survey.
isrn software engineering , pages 1{37, 2013. doi:10.1155/2013/507984.
7. w.m.p. van der aalst. decomposing petri nets for process mining: a generic
approach. distributed and parallel databases , 31(4):471{507, 2013.
8. w.m.p. van der aalst. mediating between modeled and observed behavior: the
quest for the \right" process. in ieee international conference on research
challenges in information science (rcis 2013) , pages 31{43. ieee computing
society, 2013.
9. w.m.p. van der aalst, a. adriansyah, and b. van dongen. replaying history
on process models for conformance checking and performance analysis. wires
data mining and knowledge discovery , 2(2):182{192, 2012.
10. w.m.p. van der aalst, a. adriansyah, and b.f. van dongen. causal nets: a mod-
eling language tailored towards process discovery. in j.p. katoen and b. koenig,
editors, 22nd international conference on concurrency theory (concur 2011) ,
lecture notes in computer science, pages 28{42. springer-verlag, berlin, 2011.
11. w.m.p. van der aalst and t. basten. identifying commonalities and dierences
in object life cycles using behavioral inheritance. in j.m. colom and m. koutny,
editors, application and theory of petri nets 2001 , volume 2075 of lecture notes
in computer science , pages 32{52. springer-verlag, berlin, 2001.
12. w.m.p. van der aalst, b.f. van dongen, j. herbst, l. maruster, g. schimm, and
a.j.m.m. weijters. workow mining: a survey of issues and approaches. data
and knowledge engineering , 47(2):237{267, 2003.
13. w.m.p. van der aalst, k.m. van hee, a.h.m. ter hofstede, n. sidorova, h.m.w.
verbeek, m. voorhoeve, and m.t. wynn. soundness of workow nets: classi-
cation, decidability, and analysis. formal aspects of computing , 23(3):333{363,
2011.
14. w.m.p. van der aalst, k.m. van hee, j.m. van der werf, and m. verdonk. audit-
ing 2.0: using process mining to support tomorrow's auditor. ieee computer ,
43(3):90{93, 2010.
15. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workow patterns. distributed and parallel databases , 14(1):5{51, 2003.
16. w.m.p. van der aalst and k.b. lassen. translating unstructured workow pro-
cesses to readable bpel: theory and implementation. information and software
technology , 50(3):131{159, 2008.
17. w.m.p. van der aalst, m. pesic, and m. song. beyond process mining: from
the past to present and future. in b. pernici, editor, advanced information sys-
tems engineering, proceedings of the 22nd international conference on advanced
information systems engineering (caise'10) , volume 6051 of lecture notes in
computer science , pages 38{52. springer-verlag, berlin, 2010.
18. w.m.p. van der aalst, h.a. reijers, a.j.m.m. weijters, b.f. van dongen, a.k.
alves de medeiros, m. song, and h.m.w. verbeek. business process mining: an
industrial application. information systems , 32(5):713{732, 2007.
19. w.m.p. van der aalst, v. rubin, h.m.w. verbeek, b.f. van dongen, e. kindler,
and c.w. g unther. process mining: a two-step approach to balance between
undertting and overtting. software and systems modeling , 9(1):87{111, 2010.
20. w.m.p. van der aalst, m.h. schonenberg, and m. song. time prediction based
on process mining. information systems , 36(2):450{475, 2011.
21. w.m.p. van der aalst, a.j.m.m. weijters, and l. maruster. workow mining:
discovering process models from event logs. ieee transactions on knowledge
and data engineering , 16(9):1128{1142, 2004.process mining in the large: a tutorial 41
22. a. adriansyah, b. van dongen, and w.m.p. van der aalst. conformance checking
using cost-based fitness analysis. in c.h. chi and p. johnson, editors, ieee
international enterprise computing conference (edoc 2011) , pages 55{64. ieee
computer society, 2011.
23. a. adriansyah, b.f. van dongen, and w.m.p. van der aalst. towards robust con-
formance checking. in m. zur muehlen and j. su, editors, bpm 2010 workshops,
proceedings of the sixth workshop on business process intelligence (bpi2010) ,
volume 66 of lecture notes in business information processing , pages 122{133.
springer-verlag, berlin, 2011.
24. a. adriansyah, j. munoz-gama, j. carmona, b.f. van dongen, and w.m.p. van
der aalst. alignment based precision checking. in b. weber, d.r. ferreira, and
b. van dongen, editors, workshop on business process intelligence (bpi 2012) ,
tallinn, estonia, 2012.
25. a. adriansyah, n. sidorova, and b.f. van dongen. cost-based fitness in confor-
mance checking. in international conference on application of concurrency to
system design (acsd 2011) , pages 57{66. ieee computer society, 2011.
26. r. agrawal, d. gunopulos, and f. leymann. mining process models from work-
ow logs. in sixth international conference on extending database technology ,
volume 1377 of lecture notes in computer science , pages 469{483. springer-
verlag, berlin, 1998.
27. e. badouel and p. darondeau. theory of regions. in w. reisig and g. rozenberg,
editors, lectures on petri nets i: basic models , volume 1491 of lecture notes in
computer science , pages 529{586. springer-verlag, berlin, 1998.
28. r. bergenthum, j. desel, r. lorenz, and s. mauser. process mining based on
regions of languages. in g. alonso, p. dadam, and m. rosemann, editors, inter-
national conference on business process management (bpm 2007) , volume 4714
oflecture notes in computer science , pages 375{383. springer-verlag, berlin,
2007.
29. r.p.j.c. chandra bose. process mining in the large: preprocessing, discovery,
and diagnostics . phd thesis, eindhoven university of technology, 2012.
30. j.c.a.m. buijs, b.f. van dongen, and w.m.p. van der aalst. on the role of fit-
ness, precision, generalization and simplicity in process discovery. in r. meers-
man, s. rinderle, p. dadam, and x. zhou, editors, otm federated conferences,
20th international conference on cooperative information systems (coopis 2012) ,
volume 7565 of lecture notes in computer science , pages 305{322. springer-
verlag, berlin, 2012.
31. t. calders, c. guenther, m. pechenizkiy, and a. rozinat. using minimum de-
scription length for process mining. in acm symposium on applied computing
(sac 2009) , pages 1451{1455. acm press, 2009.
32. j. carmona and j. cortadella. process mining meets abstract interpretation. in
j.l. balcazar, editor, ecml/pkdd 210 , volume 6321 of lecture notes in articial
intelligence , pages 184{199. springer-verlag, berlin, 2010.
33. j. carmona, j. cortadella, and m. kishinevsky. a region-based algorithm
for discovering petri nets from event logs. in business process management
(bpm2008) , pages 358{373, 2008.
34. j.e. cook and a.l. wolf. discovering models of software processes from event-
based data. acm transactions on software engineering and methodology ,
7(3):215{249, 1998.
35. j.e. cook and a.l. wolf. software process validation: quantitatively measuring
the correspondence of a process to a model. acm transactions on software
engineering and methodology , 8(2):147{176, 1999.42 w.m.p. van der aalst
36. j. cortadella, m. kishinevsky, l. lavagno, and a. yakovlev. deriving petri nets
from finite transition systems. ieee transactions on computers , 47(8):859{882,
august 1998.
37. f. curbera, y. doganata, a. martens, n. mukhi, and a. slominski. business
provenance: a technology to increase traceability of end-to-end operations. in
r. meersman and z. tari, editors, proceedings of the 16th international conference
on cooperative information systems, coopis 2008, otm 2008, part i , volume
5331 of lecture notes in computer science , pages 100{119. springer-verlag, berlin,
2008.
38. a. datta. automating the discovery of as-is business process models: proba-
bilistic and algorithmic approaches. information systems research , 9(3):275{301,
1998.
39. s. davidson, s. cohen-boulakia, a. eyal, b. ludaescher, t. mcphillips, s. bow-
ers, m. anand, and j. freire. provenance in scientic workow systems. data
engineering bulletin , 30(4):44{50, 2007.
40. j. dean and s. ghemawat. mapreduce: simplied data processing on large
clusters. communications of the acm , 51(1):107{113, 2008.
41. b. depaire, j. swinnen, m. jans, and k. vanhoof. a process deviation analysis
framework. in m. la rosa and p. soer, editors, business process management
workshops, international workshop on business process intelligence (bpi 2012) ,
volume 132 of lecture notes in business information processing , pages 701{706.
springer-verlag, berlin, 2013.
42. r. dijkman, m. dumas, b. van dongen, r. k a arik, and j. mendling. similarity of
business process models: metrics and evaluation. information systems , 36(2):498{
516, 2011.
43. r. dijkman, m. dumas, and l. garcia-banuelos. graph matching algorithms for
business process model similarity search. in u. dayal, j. eder, j. koehler, and
h. reijers, editors, business process management (bpm 2009) , volume 5701 of
lecture notes in computer science , pages 48{63. springer-verlag, berlin, 2009.
44. b.f. van dongen and w.m.p. van der aalst. multi-phase process mining: building
instance graphs. in p. atzeni, w. chu, h. lu, s. zhou, and t.w. ling, editors, in-
ternational conference on conceptual modeling (er 2004) , volume 3288 of lecture
notes in computer science , pages 362{376. springer-verlag, berlin, 2004.
45. b.f. van dongen and w.m.p. van der aalst. multi-phase mining: aggregating
instances graphs into epcs and petri nets. in d. marinescu, editor, proceedings of
the second international workshop on applications of petri nets to coordination,
workow and business process management , pages 35{58. florida international
university, miami, florida, usa, 2005.
46. b.f. van dongen, r.a. crooy, and w.m.p. van der aalst. cycle time prediction:
when will this case finally be finished? in r. meersman and z. tari, editors,
proceedings of the 16th international conference on cooperative information sys-
tems, coopis 2008, otm 2008, part i , volume 5331 of lecture notes in computer
science , pages 319{336. springer-verlag, berlin, 2008.
47. b.f. van dongen, a.k. alves de medeiros, and l. wenn. process mining: overview
and outlook of petri net discovery algorithms. in k. jensen and w.m.p. van
der aalst, editors, transactions on petri nets and other models of concurrency
ii, volume 5460 of lecture notes in computer science , pages 225{242. springer-
verlag, berlin, 2009.
48. a. ehrenfeucht and g. rozenberg. partial (set) 2-structures - part 1 and part 2.
acta informatica , 27(4):315{368, 1989.process mining in the large: a tutorial 43
49. d. fahland and w.m.p. van der aalst. repairing process models to reect reality.
in a. barros, a. gal, and e. kindler, editors, international conference on business
process management (bpm 2012) , volume 7481 of lecture notes in computer
science , pages 229{245. springer-verlag, berlin, 2012.
50. w. gaaloul, k. gaaloul, s. bhiri, a. haller, and m. hauswirth. log-based transac-
tional workow mining. distributed and parallel databases , 25(3):193{240, 2009.
51. r.j. van glabbeek and w.p. weijland. branching time and abstraction in bisim-
ulation semantics. journal of the acm , 43(3):555{600, 1996.
52. s. goedertier, d. martens, j. vanthienen, and b. baesens. robust process dis-
covery with articial negative events. journal of machine learning research ,
10:1305{1340, 2009.
53. c.w. g unther and w.m.p. van der aalst. fuzzy mining: adaptive process sim-
plication based on multi-perspective metrics. in g. alonso, p. dadam, and
m. rosemann, editors, international conference on business process management
(bpm 2007) , volume 4714 of lecture notes in computer science , pages 328{343.
springer-verlag, berlin, 2007.
54. j. herbst. a machine learning approach to workow management. in proceedings
11th european conference on machine learning , volume 1810 of lecture notes in
computer science , pages 183{194. springer-verlag, berlin, 2000.
55. m. hilbert and p. lopez. the world's technological capacity to store, commu-
nicate, and compute information. science , 332(6025):60{65, 2011.
56. s. hinz, k. schmidt, and c. stahl. transforming bpel to petri nets. in w.m.p.
van der aalst, b. benatallah, f. casati, and f. curbera, editors, international
conference on business process management (bpm 2005) , volume 3649 of lecture
notes in computer science , pages 220{235. springer-verlag, berlin, 2005.
57. ieee task force on process mining. process mining manifesto. in bpm work-
shops , volume 99 of lecture notes in business information processing . springer-
verlag, berlin, 2011.
58. ieee task force on process mining. process mining manifesto. in f. daniel,
k. barkaoui, and s. dustdar, editors, business process management workshops ,
volume 99 of lecture notes in business information processing , pages 169{194.
springer-verlag, berlin, 2012.
59. t. jin, j. wang, and l. wen. ecient retrieval of similar workow models based
on structure. in otm 2011 , volume 7044 of lecture notes in computer science ,
pages 56{63. springer-verlag, berlin, 2011.
60. t. jin, j. wang, and l. wen. ecient retrieval of similar workow models based
on behavior. in apweb 2012 , volume 7235 of lecture notes in computer science ,
pages 677{684. springer-verlag, berlin, 2012.
61. n. lohmann, p. massuthe, c. stahl, and d. weinberg. analyzing interacting
bpel processes. in s. dustdar, j.l. fiadeiro, and a. sheth, editors, international
conference on business process management (bpm 2006) , volume 4102 of lecture
notes in computer science , pages 17{32. springer-verlag, berlin, 2006.
62. b. ludaescher, i. altintas, c. berkley, d. higgins, e. jaeger-frank, m. jones,
e. lee, j. tao, and y. zhao. scientic workow management and the kepler
system. concurrency and computation: practice and experience , 18(10):1039{
1065, 2006.
63. f.m. maggi, m. montali, and w.m.p. van der aalst. an operational decision sup-
port framework for monitoring business constraints. in j. de lara and a. zisman,
editors, international conference on fundamental approaches to software engi-
neering (fase 2012) , volume 7212 of lecture notes in computer science , pages
146{162. springer-verlag, berlin, 2012.44 w.m.p. van der aalst
64. f.m. maggi, m. westergaard, m. montali, and w.m.p. van der aalst. runtime
verication of ltl-based declarative process models. in s. khurshid and k. sen,
editors, runtime verication (rv 2011) , volume 7186 of lecture notes in com-
puter science , pages 131{146. springer-verlag, berlin, 2012.
65. j. manyika, m. chui, b. brown, j. bughin, r. dobbs, c. roxburgh, and a. by-
ers. big data: the next frontier for innovation, competition, and productivity.
mckinsey global institute, 2011.
66. a.k. alves de medeiros, a.j.m.m. weijters, and w.m.p. van der aalst. genetic
process mining: an experimental evaluation. data mining and knowledge dis-
covery , 14(2):245{304, 2007.
67. j. mendling, b.f. van dongen, and w.m.p. van der aalst. on the degree of be-
havioral similarity between business process models. in m. nuettgens, f.j. rump,
and a. gadatsch, editors, proceedings of sixth workshop on event-driven process
chains (wi-epk 2007) , pages 39{58, st. augustin, november 2007. gesellschaft
f ur informatik, bonn.
68. r. milner. communication and concurrency . prentice-hall, inc., 1989.
69. j. munoz-gama and j. carmona. a fresh look at precision in process confor-
mance. in r. hull, j. mendling, and s. tai, editors, business process management
(bpm 2010) , volume 6336 of lecture notes in computer science , pages 211{226.
springer-verlag, berlin, 2010.
70. j. munoz-gama and j. carmona. enhancing precision in process conformance:
stability, condence and severity. in n. chawla, i. king, and a. sperduti, editors,
ieee symposium on computational intelligence and data mining (cidm 2011) ,
pages 184{191, paris, france, april 2011. ieee.
71. j. munoz-gama, j. carmona, and w.m.p. van der aalst. conformance checking in
the large: partitioning and topology. in f. daniel, j. wang, and b. weber, editors,
international conference on business process management (bpm 2013) , volume
8094 of lecture notes in computer science , pages 130{145. springer-verlag, berlin,
2013.
72. j. munoz-gama, j. carmona, and w.m.p. van der aalst. hierarchical confor-
mance checking of process models based on event logs. in j.m. colom and
j. desel, editors, applications and theory of petri nets 2013 , volume 7927 of
lecture notes in computer science , pages 291{310. springer-verlag, berlin, 2013.
73. c. ouyang, w.m.p. van der aalst, s. breutel, m. dumas, a.h.m. ter hofstede, and
h.m.w. verbeek. formal semantics and analysis of control flow in ws-bpel.
science of computer programming , 67(2-3):162{198, 2007.
74. c. ouyang, m. dumas, a.h.m. ter hofstede, and w.m.p. van der aalst. pattern-
based translation of bpmn process models to bpel web services. international
journal of web services research , 5(1):42{62, 2007.
75. a. polyvyanyy, j. vanhatalo, and h. v olzer. simplied computation and gen-
eralization of the rened process structure tree. in m. bravetti and t. bultan,
editors, ws-fm 2010 , volume 6551 of lecture notes in computer science , pages
25{41. springer-verlag, berlin, 2011.
76. a. rajaraman and j.d. ullman. mining of massive datasets . cambridge univer-
sity press, 2011.
77. h.a. reijers. case prediction in bpm systems: a research challenge. journal of
the korean institute of industrial engineers , 33:1{10, 2006.
78. w. reisig. petri nets: modeling techniques, analysis, methods, case studies .
springer-verlag, berlin, 2013.process mining in the large: a tutorial 45
79. a. rozinat and w.m.p. van der aalst. decision mining in prom. in s. dustdar,
j.l. fiadeiro, and a. sheth, editors, international conference on business process
management (bpm 2006) , volume 4102 of lecture notes in computer science ,
pages 420{425. springer-verlag, berlin, 2006.
80. a. rozinat and w.m.p. van der aalst. conformance checking of processes based
on monitoring real behavior. information systems , 33(1):64{95, 2008.
81. a. rozinat, r.s. mans, m. song, and w.m.p. van der aalst. discovering col-
ored petri nets from event logs. international journal on software tools for
technology transfer , 10(1):57{74, 2008.
82. a. rozinat, r.s. mans, m. song, and w.m.p. van der aalst. discovering simulation
models. information systems , 34(3):305{327, 2009.
83. a. rozinat, m. wynn, w.m.p. van der aalst, a.h.m. ter hofstede, and c. fidge.
workow simulation for operational decision support. data and knowledge en-
gineering , 68(9):834{850, 2009.
84. h. schonenberg, b. weber, b.f. van dongen, and w.m.p. van der aalst. support-
ing flexible processes through recommendations based on history. in m. dumas,
m. reichert, and m.c. shan, editors, international conference on business pro-
cess management (bpm 2008) , volume 5240 of lecture notes in computer science ,
pages 51{66. springer-verlag, berlin, 2008.
85. a. sheth. a new landscape for distributed and parallel data management. dis-
tributed and parallel databases , 30(2):101{103, 2012.
86. m. sole and j. carmona. process mining from a basis of regions. in j. lilius and
w. penczek, editors, applications and theory of petri nets 2010 , volume 6128 of
lecture notes in computer science , pages 226{245. springer-verlag, berlin, 2010.
87. staware. staware process suite version 2 { white paper . staware plc,
maidenhead, uk, 2003.
88. j. vanhatalo, h. v olzer, and j. koehler. the rened process structure tree. data
and knowledge engineering , 68(9):793{818, 2009.
89. h.m.w. verbeek and w.m.p. van der aalst. an experimental evaluation of
passage-based process discovery. in m. la rosa and p. soer, editors, busi-
ness process management workshops, international workshop on business pro-
cess intelligence (bpi 2012) , volume 132 of lecture notes in business information
processing , pages 205{210. springer-verlag, berlin, 2013.
90. h.m.w. verbeek and w.m.p. van der aalst. decomposing replay problems: a
case study. bpm center report bpm-13-09, bpmcenter.org, 2013.
91. j. de weerdt, m. de backer, j. vanthienen, and b. baesens. a robust f-measure
for evaluating discovered process models. in n. chawla, i. king, and a. sperduti,
editors, ieee symposium on computational intelligence and data mining (cidm
2011) , pages 148{155, paris, france, april 2011. ieee.
92. m. weidlich, r. dijkman, and m. weske. behavioral equivalence and compatibil-
ity of business process models with complex correspondences. computer journal ,
2012.
93. a.j.m.m. weijters and w.m.p. van der aalst. rediscovering workow models
from event-based data using little thumb. integrated computer-aided engi-
neering , 10(2):151{162, 2003.
94. j.m.e.m. van der werf, b.f. van dongen, c.a.j. hurkens, and a. serebrenik.
process discovery using integer linear programming. fundamenta informaticae ,
94:387{412, 2010.