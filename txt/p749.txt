beautiful workows: a matter of taste?
wil m.p. van der aalst1;2;3, michael westergaard1;2, and hajo a. reijers1;4
1architecture of information systems, eindhoven university of technology,
p.o. box 513, nl-5600 mb, eindhoven, the netherlands.
fw.m.p.v.d.aalst,m.westergaard,h.a.reijers g@tue.nl
2international laboratory of process-aware information systems, national
research university higher school of economics (hse),
33 kirpichnaya str., moscow, russia.
3business process management discipline, queensland university of technology,
gpo box 2434, brisbane qld 4001, australia.
4perceptive software,
piet joubertstraat 4, 7315 av apeldoorn, the netherlands.
abstract. workows can be specied using dierent languages. main-
stream workow management systems predominantly use procedural lan-
guages having a graphical representation involving and/xor splits and
joins (e.g., using bpmn). however, there are interesting alternative ap-
proaches. for example, case handling approaches are data-driven and
allow users to deviate within limits, and declarative languages based
on temporal logic (where everything is allowed unless explicitly forbid-
den). recently, rinus plasmeijer proposed the itask system ( itasks )
based on the viewpoint that workow modeling is in essence a particu-
lar kind of functional programming. this provides advantages in terms
of expressiveness, extendibility, and implementation eciency. on the
occasion of his 61st birthday, we compare four workow paradigms: pro-
cedural ,case handling ,declarative , and functional . for each paradigm we
selected a characteristic workow management system: yawl (proce-
dural), bpmjone (case handling), declare (declarative), and itasks
(functional). each of these systems aims to describe and support business
processes in an elegant manner. however, there are signicant dierences.
in this paper, we aim to identify and discuss these dierences.
keywords: workow management, business process management, case
handling, declarative languages, functional programming
1 demand driven workow systems
functional programming and process modeling are related in various ways. for
example, well-known petri nets tools such as cpn tools [14] and exspect [6]
use functional languages to describe the consumption and production behaviors
of transitions in the petri net. however, the dierent communities focusing on
process modeling and analysis are largely disconnected from the functional pro-
gramming community (and vice versa). business process management (bpm),2 wil van der aalst, and michael westergaard, hajo reijers
workow management (wfm), and concurrency-related (e.g., petri nets) com-
munities are rarely using concepts originating from functional languages. there-
fore, the groups of rinus plasmeijer and wil van der aalst submitted the joint
project proposal \controlling dynamic real life workow situations with de-
mand driven workow systems" to stw in 2006. the project was accepted in
2007 and started in 2008. the project completed successfully in 2012.
in the stw project dierent styles of workow modeling and enactment were
used. a new style of functional programming, called task-oriented programming
(top), was developed by rinus and his team [39]. the itask system ( itasks ),
an implementation of top embedded in the well-known functional language
clean , supports this style of workow development [37, 39]. itasks workows
consist of typed tasks that produce results that can be passed as parameters
to other tasks. new combinators can be added to extend the itasks language.
at eindhoven university of technology, maja pesic and michael westergaard
worked on an alternative approach based on the declare system. the de-
clare language is based on the notion of constraints, grounded in ltl, and
also extendible. moreover, previously we worked on procedural workow lan-
guages like yawl and collaborated with pallas athena on the case handling
paradigm.5
in the project we could experience the enthusiasm, dedication, an persistence
of rinus when it comes to functional programming and beautiful code. therefore,
it is an honor to be able to contribute to this festschrift devoted to the 61st
birthday of rinus plasmeijer!
in the remainder, we report on insights obtained in our joint stw project. in
section 2 we discuss four dierent workow paradigms using four representative
examples: yawl (procedural), bpm jone (case handling), declare (declara-
tive), and itasks (functional). section 3 compares the dierent paradigms and
reects on the current bpm/wfm market. section 4 concludes our contribution
to this festschrift.
2 four workow paradigms
business process management (bpm) is the discipline that combines knowledge
from information technology and knowledge from management sciences and ap-
plies this to operational business processes [1, 3, 46]. it has received considerable
attention in recent years due to its potential for signicantly increasing produc-
tivity and saving costs. moreover, today there is an abundance of bpm systems.
these systems are generic software systems that are driven by explicit process
designs to enact and manage operational business processes [3].
bpm can be seen as an extension of workow management (wfm). wfm
primarily focuses on the automation of business processes [8, 28, 30], whereas
bpm has a broader scope: from process automation and process analysis to
operations management and the organization of work. bpm aims to improve
5pallas athena was also involved in the user committee of our joint stw project.beautiful workows: a matter of taste? 3
operational business processes, with or without the use of new technologies.
for example, by modeling a business process and analyzing it using simulation,
management may get ideas on how to reduce costs while improving service levels.
moreover, bpm is often associated with software to manage, control, and support
operational processes. this was the initial focus of wfm. however, traditional
wfm technology aimed at the automation of business processes in a rather
mechanistic manner without much attention for human factors and management
support.
in the remainder we use the terms wfm and bpm interchangeably as we
focus on the modeling and enactment of business processes, i.e., the emphasis
will be on process automation rather than management support.
we identify four very dierent styles of process automation: procedural work-
ows ( yawl ), case handling workows ( bpm jone), declarative workows ( de-
clare ), and functional workows ( itasks ). in the remainder of this section,
these are introduced and subsequently compared in section 3.
2.1 procedural workows (yawl)
procedural programming (also referred to as imperative programming) aims to
dene sequences of commands for the computer to perform in order to reach a
predened goal. procedural programming can be seen as the opposite of more
declarative forms of programming that dene what the program should accom-
plish without prescribing how to do it in terms of sequences of actions to be
taken. despite criticism, procedural programming is still the mainstream pro-
gramming paradigm. a similar observation can be made when looking at the
modeling, analysis, and enactment of business processes. almost all bpm/wfm
languages and tools are procedural (see also section 3.4). examples are bpmn
(business process modeling notation), uml activity diagrams, petri nets, pro-
cess calculi like csp and ccs, bpel (business process execution language),
and epcs (event-driven process chains).
figure 1(a) describes a simple diagnosis process in terms of petri, a wf-
net(workflow net) to be precise [13, 26, 46]. tasks are modeled by labeled
transitions and the ordering of these tasks is controlled by places (represented
by circles). a transition (represented by a square) is enabled if each of its input
places contains a token. an enabled transition may occur thereby consuming
a token from each input place and producing a token for each output place.
the process in figure 1(a) starts with a token in place in(depicted by a black
dot). transition a(admit patient ) can occur if there is a token in place in.
firing acorresponds to removing the token from place inand producing a token
for place p1. after admitting the patient (modeled by transition a), vital signs
may be checked ( b) or not (modeled by the silent transition). then the physical
examination ( c) is conducted. subsequently, the blood is tested ( d), an x-ray is
taken ( e), and an ecg is made ( f) (any ordering is allowed). in the last step,
the diagnosis is nalized ( g). the process instance terminates when place outis
marked. figure 1(c) shows an event log describing some example traces of the4 wil van der aalst, and michael westergaard, hajo reijers
admit patientcheck vital 
signs
make x-rayphysical 
examination
starttest blood
make ecgfinalize 
diagnosis
end
(b)   bpmn (business process modeling notation) modelbcheck vital 
signs
physical 
examinatione
make x-ray
f
make ecgd
test blood
finalize 
diagnosisina c g
out admit 
patient
(a)   petri net abcdefg
acedfg
acfedg
abcdfeg
abcfdeg
acdef
...
(c)   event log p1 p2p3
p4
p5 p8p7p6
fig. 1. a petri net (a) and bpmn model (b) describing a simple medical diagnosis
process. example traces are shown in the event log (c), a=admit patient , etc.
model. the wf-net allows for 12 dierent executions: d,eandfcan be executed
in any order and bmay be skipped.
bpmn, epcs, uml ads, and many other business process modeling nota-
tions have in common that they all use token-based semantics [3, 13, 21, 26, 46].
therefore, there are many techniques and tools to convert petri nets to bpmn,
bpel, epcs and uml ads, and vice versa. as a result, the core concepts of
petri nets are often used indirectly, e.g., to enable analysis, to enact models, and
to clarify semantics. for example, figure 1(b) shows the same control-ow mod-
eled using the business process modeling notation (bpmn) [34]. bpmn uses
activities, events, and gateways to model the control-ow. in figure 1(b) two
types of gateways are employed: exclusive gateways are used to model xor-splits
and joins and parallel gateways are used to model and-splits and joins. bpmn
also supports other types of gateways corresponding to inclusive or-splits and
joins, deferred choices, etc. [21, 26, 46].
in an eort to gain a better understanding of the fundamental concepts un-
derpinning business processes, the workow patterns initiative6was conceived
in the late nineties with the goal of identifying the core architectural constructs
inherent in workow technology [10]. the original objective was to delineate the
fundamental requirements that arise during business process modeling on a re-
curring basis and describe them in an imperative way. the main driver for the
workow patterns initiative was the observation that wfm/bpm languages
and tools diered markedly in their expressive power and the range of concepts
that they were able to capture. the initial set of 20 patterns provided a basis for
valuable comparative discussions on the capabilities of languages and systems.
6seewww.workflowpatterns.com .beautiful workows: a matter of taste? 5
later the original set of 20 patterns was extended into a set of 43 control-ow
patterns supported by additional sets of patterns, e.g., 40 data patterns and 43
resource patterns [26].
fig. 2. screenshot of yawl editor while modeling the process described using fig-
ure 1.
the workow patterns provided the conceptual basis for the yawl language
[9] and yawl workow system [26].7yawl supports most workow patterns
directly, i.e., no workarounds are needed to model and support a wide variety
of imperative process behaviors. petri nets were taken as a starting point for
yawl and extended with dedicated constructs to deal with patterns that petri
nets have diculty expressing, in particular patterns dealing with cancelation,
synchronization of active branches only, and multiple concurrently executing
instances of the same task. the screenshot in figure 2 shows the yawl variant
of the diagnosis process introduced using earlier. the yawl model allows for
the same 12 traces as allowed by the wf-net and bpmn model in figure 1. none
of the advanced features of yawl are needed to model this simple diagnosis
process. note that compared to the petri net there are no explicit places. in
yawl one can connect two tasks directly without inserting a place. however,
internally the places are added to model states. moreover, for workow patterns
such as the deferred choice pattern (the decision is not made automatically from
within the context of the process but is deferred to an entity in the operational
environment) and the milestone pattern (the additional restriction that a task
can only proceed when another concurrent branch of the process has reached
a specic state), places need to be represented explicitly to model the desired
behavior. the aim of yawl is to oer direct support for many patterns while
keeping the language simple. it can be seen as a reference implementation of
the most important workow patterns. over time, the yawl language and
theyawl system have increasingly become synonymous and have garnered
widespread interest from both practitioners and the academic community alike.
over time yawl evolved into one of the most widely used open-source workow
systems.
7yawl can be downloaded from www.yawlfoundation.org .6 wil van der aalst, and michael westergaard, hajo reijers
most mainstream wfm/bpm languages are procedural and use a token-
based semantics. the same holds for analysis techniques relevant for wfm/bpm
eorts. most model-based analysis techniques ranging from verication to per-
formance analysis are tailored towards procedural models. verication is con-
cerned with the correctness of a system or process. performance analysis focuses
on ow times, waiting times, utilization, and service levels. also process mining
techniques driven by event data typically assume procedural models. for exam-
ple,process discovery techniques can be used to learn procedural models based
on event data. conformance checking techniques compare procedural models
(modeled behavior) with event data (observed behavior).
there is an abundance of analysis techniques developed for petri nets ranging
from verication and simulation [13] to process mining [2]. procedural languages
such as bpmn, uml activity diagrams, bpel, and epcs can be converted to
petri nets for verication, performance analysis, and conformance checking. petri
nets can be mapped onto mainstream notations to visualize processes discovered
using process mining.
2.2 case handling workows (bpm jone)
mainstream procedural languages are often criticized for being inexible. case
handling is a paradigm for supporting exible and knowledge intensive business
processes [15]. it is strongly based on data as the typical product of these pro-
cesses. unlike traditional wfm systems, which use predened process control
structures to determine what should be done during a workow process, case
handling focuses on what can be done to achieve a business goal. in case han-
dling, the knowledge worker in charge of a particular case actively decides on
how the goal of that case is reached, and the role of a case handling system is
assisting rather than guiding her in doing so. the core features of case handling
are:
{avoid context tunneling by providing all information available (i.e., present
the case as a whole rather than showing just bits and pieces),
{decide which tasks are enabled on the basis of the information available
rather than the tasks already executed,
{allow for deviations (without certain bounds) that are not explicitly modeled
(skip, redo, etc.),
{separate work distribution from authorization,
{allow workers to view and add/modify data before or after the corresponding
tasks have been executed (e.g., information can be registered the moment it
becomes available).
the central concept for case handling is the case and not the tasks or the ordering
of tasks. the case is the \product" which is manufactured, and at any time
workers should be aware of this context. for knowledge-intensive processes, the
state and structure of a case can be derived from the relevant data objects. a
data object is a piece of information which is present or not present and when itbeautiful workows: a matter of taste? 7
fig. 3. screenshot showing the bpmjone designer and worklist handler.
is present it has a value. in contrast to existing workow management systems,
the state of the case is not determined by the control-ow status but by the
presence of data objects. this is truly a paradigm shift: case handling is also
driven by data-ow and not just by control-ow.
in a procedural workow, workers need to execute all tasks oered by the
system and there is no way to later correct errors if not modeled explicitly. case
handling allows for deviations within certain bounds. for a task at least three
types of roles can be specied:
{the execute role is the role that is necessary to carry out the task or to start
a process.
{the redo role is necessary to undo tasks, i.e., the case returns to the state
before executing the task. note that it is only possible to undo a task if all
following tasks are undone as well.
{the skip role is necessary to bypass tasks, e.g., a check may be skipped by
a manager but not by a regular employee.
case handling is supported by only a few vendors. the best-known example is
bpm jone which is now part of the perceptive platform (lexmark).8bpm jone
is the successor of flower [15] both developed by pallas athena. in turn,
flower was inspired by the echo (electronic case-handling for oces)
system whose development started in 1986 within philips and later moved to
digital. bpm jone supports all of the concepts mentioned (see figure 3). the
system is much more exible than most wfm/bpm systems. this is achieved
without forcing end-users to adapt process models (which is typically infeasible).
8see http://www.perceptivesoftware.com/products/perceptive-process/
business-process-management .8 wil van der aalst, and michael westergaard, hajo reijers
consider the process described in figure 1. using bpm jone one could make
some tasks \skipable", e.g., task make ecg may be skipped by the department
chief even though this is not modeled. similarly, some tasks may be \redo-
able", e.g., after doing the blood test, the process may be rolled-back to the task
physical examination . moreover, tasks may be data driven. if a recent x-ray is
available, task make x-ray is completed automatically without actually making
a new x-ray.
recently, the terms adaptive case management (acm) and dynamic case
management (dcm) received quite some attention. these terms are used to
stress the need for workows to be more human-centric, exible, and content and
collaboration driven. unfortunately, the dierent vendors interpret these terms
in dierent ways and the actual case-handling functionality described before is
often missing.
2.3 declarative workows (declare)
the procedural paradigm focuses on how to accomplish a goal. at any point
a user is presented with a relatively limited selection of possible tasks based
on explicit decisions. declarative workows instead focus on the relationship
between tasks, such as one task cannot be executed together with another or one
task has to be followed by another [12]. for example, in a medical treatment,
one type of medicine may be incompatible with another and cannot be used
together, or surgery must be followed up by retraining.
declarative workows therefore focus on two things, tasks to be executed
and constraints between the tasks, stating properties the aforementioned [12].
in fig. 4, we see an example of a simple medical process for treating wounds
modeled using declare .9tasks are represented as rectangles, e.g., disinfect
wound and constraints are either represented as arcs between tasks (for binary
constraints) or as annotations of tasks (for unary constraints). for example, we
have a initconstraint on the receive patient task, and a precedence constraint
from disinfect wound tostitch wound . we also have a response constraint from
stitch wound toprescribe antibiotics , anon co-existence constraint between pre-
scribe antibiotics and give tetanus vaccine , and a second precedence constraint
from disinfect wound togive tetanus vaccine .
constraints have informal descriptive semantics and formal semantics. the
informal semantics suce for users and the formal semantics are only used by
implementers and for reasoning about processes. we have summed up the formal
semantics of four example declare constraints in table 1. declare comes with
many more constraints, but these suce here for understanding the basic idea.
we rst consider the informal semantics for these constraints. the init constraint
models that any execution has to start with this task, and in our example this
means that the rst thing to do in any execution is to receive a patient. the
precedence constraint models that it is not legal to execute the target before
executing the source of the constraint. in the example, we model that we may not
9declare can be downloaded from www.win.tue.nl/declare/ .beautiful workows: a matter of taste? 9
stitch wound
give tetanus
vaccineprescribe antibiotics disinfect woundrecieve
patientinit
fig. 4. declare model of simple medical treatment.
table 1. selected declare constraints.
name parameters representation semantics
informal formal
init ( a)\jinit j
a start with a xa
precedence ( a;b) a !b nobbefore a ar:b
response ( a;b) a !b afteramust execute bg(a!fb)
not no-existence ( a;b) a = = b not both aandb:fa_:fb
stitch a wound (nor give a tetanus vaccine) before disinfecting the wound. this
does not mean that after disinfection we have to stitch a wound (for example,
if it is not severe), but only that we may not stitch before disinfection. the
response constraint on the other hand means that after executing the source, we
have to execute the target. in our example, we must prescribe antibiotics after
stitching a wound. it is perfectly acceptable to execute the source multiple times
and the target only once, for example stitching a wound two or more times and
only prescribe antibiotics once. the non co-existence constraint models that only
one of the connected tasks can be executed (but none of them has to be). in
our example, we cannot both give a tetanus vaccine and prescribe an antibiotics,
maybe because the eect of the vaccine is diminished or voided by the antibiotics.
we notice that we can rely on the informal semantics to understand local
aspects of a model. we also see that at no point do we talk about any explicit
execution order: anything not explicitly forbidden is allowed . adeclare model
with no constraints allows any execution of any task in the model. in the exam-
ple in fig. 4, after performing patient registration and wound disinfection, the
process allows executing any task in the model. this allows a lot of freedom,
which is often useful in a highly dynamic process, such as a medical process, or
in a process which is not very well-known. the dynamic behavior is present in
processes where a lot of possibilities are available and there is no obvious best
choice. processes can be partially unknown either because they are so complex
nobody fully understands the entire process, or because they are early in the
specication phase. using a declarative approach allows modelers to only spec-
ify known constraints, such as incompatibilities between two treatments or a10 wil van der aalst, and michael westergaard, hajo reijers
required follow-up to one treatment, and not worry about concrete global exe-
cution order.
the formal semantics of declare is given using (nite) linear temporal
logic (ltl). this yields a compact syntax, and an abstract and well-understood
semantical foundation. more interesting is the fact that nite ltl can be trans-
lated into nite automata [24, 47]. these automata can be used to analyze the
process and to provide enactment. as the modeler does not explicitly specify
an execution order, the system has to gure out what constitutes a legal exe-
cution. this is done by instantiating a constraint template for each constraint.
instantiation comprises of taking the formal semantics for each constraint (ta-
ble 1) and replacing the parameters with actual tasks, obtaining for example
x(receive patient ) for the init constraint. we can get a specication of the full
semantics of the entire system by taking the conjunction of all instantiations of
constraint templates, and translating it to a nite automaton with task names
as transition labels. we can use this automaton to enact the system by following
states in the automaton and only allowing tasks that lead to states from which
an accepting state is reachable.
the translation from ltl to automata is exponential in the size of the for-
mula given, so it may seem it would be better to consider each constraint in
isolation. this is not sucient, however, because declare models may have
implicit choices that are not immediately obvious. in our example in fig. 4 we
have an explicit choice between prescribe antibiotics and give tetanus vaccine ,
but we actually have an implicit choice in that system as well. if we consider the
trace receive patient ;disinfect wound ;give tetanus vaccine ;stitch wound , we see
that we do not irreparable violate any constraint, but neither is it possible to
arrive at a situation where all constraints are satised at the same time. after
executing the trace, the response from stitch wound toprescribe antibiotics is
not satised, because we have stitched the wound without prescribing antibiotics
yet. we can satisfy this constraint by prescribing antibiotics, but this would vio-
late the non co-existence between give tetanus vaccine andprescribe antibiotics .
thedeclare system does this analysis and will not allow an execution trace
with both stitch wound and give tetanus vaccine . in [31] we describe how this
can be eciently represented in a single automaton, which keeps track of the
status of individual constraints and of the entire process, and in [47] we give an
ecient means of constructing this automaton.
a very strong point about declarative workows is that models are less con-
cerned with the actual execution, and hence more modular. in our previous ex-
ecution trace, we said that the declare system would prevent executing both
give tetanus vaccine and stitch wound . this can be overridden by the user,
however. for example maybe an initial assessment concludes that stitches are
not necessary and instead gives a tetanus shot. this is subsequently readdressed
and now stitching is deemed necessary. the system can then say that either
the non co-existence constraint or the response will be violated by this action,
and authorized personnel can choose to proceed, ignoring a constraint in the
process. this eectively is a migration from one model to another (with fewerbeautiful workows: a matter of taste? 11
constraints). as removing constraints never removes allowed behavior, this is
guaranteed to be successful. we can also do migration in cases where we add new
constraints as long as the added constraint is not violated and in conict with
another constraint (or the conicting constraints are removed). this means that
a declarative model not only allows exibility by naturally producing permissive
models, but also by allowing deviations from the model and even changing the
model on-the-y [35].
the automaton can obviously also be used a-posteriori to do conformance
checking of models with respect to historical data, or to check for and remove
dead parts of models [29, 33]. declare models can be mined automatically by
systematically instantiating all constraint templates and checking them against
the historical log [32].
2.4 functional workows (itasks)
functional workow specications arise from functional programming. this means
that functional workows automatically inherit properties of functional lan-
guages, importantly explicit ow of data and ability to eciently execute the
resulting specications in complicated computing environments, including par-
allel and distributed execution.
the itask system ( itasks ) augments a standard functional programming
language, clean [36], with connectives useful for workow specication [37,
39].10the basic unit in an itasks process is a task, which is a basic type
describing a process to be executed. itasks builds on the functional idea of
inductively dening values in terms of basic values and composite values. a
basic task value would be inputting an integer into a eld and a composite
task could be sequencing tasks or making a choice. the sequence is already well-
known to procedural programmers but used less in functional programming. the
choice is similar to a conditional in traditional programming, but itasks has a
general choice operator, which can be specialized (and is by default) to provide
semantics of xor, and, or, and parallel splits as well as more specialized
splits, for example a 2-out-of-3 split.
anitasks process consists of specication of the data types used and a
process specication. in listing 1, we see a simple patient registration process for
a hospital. the example illustrates both the major weakness and major strength
of the paradigm: the code is very verbose for a simple descriptive model, but
compact for a full-features implementation of a system for executing the process.
the process comprises data denitions (ll. 4-15), helper functions (ll. 17-23),
and a process description (ll. 25-53). the data denitions describe a patient
record (ll. 4-8) and an insurance record (ll. 10-13). in addition, we have an
instruction to the system to generate a full implementation of these from the
data specication (l. 15). the returnv function (ll. 17-18) is used for technical
reasons, and the hasname andisinsured functions (ll. 20-23) are simple predicates
on patients. lines 25-28 set up the main process, which consists of starting the
10itasks andclean can be downloaded from itasks.cs.ru.nl .12 wil van der aalst, and michael westergaard, hajo reijers
listing 1. itasks model of patient registration. 
1implementation module p a t i e n t r e g i s t r a t i o n
2import itasks
4: :patient =
5 fname : : string
6 , dateofbirth : :maybe date
7 , insurance : : bool
8 g
10: :insuranceinfo =
11 fcompany : : string
12 , insurancenumber : : int
13 g
15derive c l a s s itask patient , insuranceinfo
17returnv : :( taskvalue a )  >task a jitask a
18returnv ( value v )=return v
20hasname ( value fname , dateofbirth , insurance g)=name <>""
21hasname = false
23i s i n s u r e d fname , dateofbirth , insurance g=insurance
25start : :world >world
26start world =startengine ( manageworklist [mainprocess ]) world
28mainprocess =workflow "new patient " "handle apatient " handlepatient
30enterpatient : :task patient
31enterpatient =enterinformation " enter patient information " [ ]
33enterinsurance : :task insuranceinfo
34enterinsurance =enterinformation " enter insurance information " [ ]
36t r e a t : :patient >( task patient )
37t r e a t patient =
38 viewinformation ( " treat patient " , " treating patient " ) [ ]patient
40showinsurance : :insuranceinfo  >( task insuranceinfo )
41showinsurance insurance =
42 viewinformation ( " insurance " , " insurance d e t a i l s " ) [ ]insurance
44handlepatient : :task ( patient , maybe insuranceinfo )
45handlepatient =
46 enterpatient
47 >>[onaction ( action " continue " ) hasname returnv ]
48 >>=npatient >
49 i f( i s i n s u r e d patient )
50 ( ( t r e a t patient  & & 
51 ( enterinsurance >>=showinsurance ) )
52 >>=n(p , i ) >return (p , just i ) )
53 ( t r e a t patient >>=np >return (p , nothing ) ) beautiful workows: a matter of taste? 13
task handlepatient (ll. 44-53) which is a composite task using the primitive tasks
in lines 30-42. the primitive tasks comprises two tasks for inputting information
for each of the two dened data types (ll. 30-34) and two tasks for displaying
information (ll. 36-42). the treat task is a simplied placeholder version of a
full treatment. the handlepatient task is by far the more complicated one and
shows some of the task combinators supported by itasks . first we enter patient
information (l. 46). the >>*combinator allows us to add ways to proceed the
workow; line 47 produces a continue button that is enabled when the hasname
predicate holds for the patient record entered. in that case, the patient record
is passed on. the >>=combinator allows us to pass a result from one task to
the next in a sequence. the combinator expects a function taking the result of
the previous task as the rst parameter, so we make an anonymous function
(l. 48). we then use a common ifstatement (ll. 49-53) to branch according to
whether the patient has an insurance or not. if the patient does (ll. 50-52) we
start treating them (l. 50) in parallel ( -&&- ) with inputting and subsequently
showing insurance information (l. 51). finally, we return the treated patient and
their insurance information (l. 52). if a patient does not have insurance, they
are treated and returned without insurance information (l. 53).
we notice that itasks is very explicit about data ow and types. we ex-
plicitly type all tasks. this is used by the system to automatically generate a
(web-based) user interface. we need to explicitly pass and compute data, and a
strong type system prevents errors. the explicit passing of information is more
verbose than the previously discussed paradigms, but the process oriented com-
binators makes it very simple to do things that are normally very complicated
in programming, such as the parallel split in ll. 50-51 of listing 1. we can easily
change that to an xor split, or split, or sequence as long as we preserve the
types. similarly, the treat task (ll. 36-38) is very abstract and would be detailed
further in a more elaborate implementation. as long as types are preserved, we
can do that without changing the rest of the model. finally, it is possible to
change the type of, e.g., the patient record (ll. 4-8) and add new elds if nec-
essary without changes to most of the tasks; for example, the enterpatient task
(ll. 30-31) explicitly state the type but polymorphism and introspection makes
the user-interface automatically adapt to the changed type. in our example we
need to change the signature of the hasname and isinsured functions (ll. 20-23),
but this can be avoided by using a slightly more verbose syntax we have avoided
here for simplicity.
the fact that itasks is realized as a combinator library in a real program-
ming language, makes it possible to easily extend with features not normally
available in workow languages. for example, modeled processes can natively
communicate over the network, making it possible to easily invoke remote ser-
vices. another advantage is that there is no gap between the model and the
implementation; they are really one and the same in itasks . using a general-
purpose functional language also makes it possible to use traditional functional
techniques, such as making higher-order tasks. in fact, itasks combinators are
just higher order tasks and can be used to create new composite tasks. this14 wil van der aalst, and michael westergaard, hajo reijers
makes it easy to add new combinators as needed. an elegant consequence of this
is that the process of choosing a task to work on and maintaining a worklist
can be considered tasks as well, and in itasks they are realized as such. the
manageworklist used in line 26 is actually just a task taking a list of (wrapped)
tasks and allowing a user to pick which to execute. this makes it possible to
customize how tasks are presented and chosen.
3 comparison and market analysis
after presenting the distinguishing features of yawl ,bpm jone,declare ,
itasks , and the corresponding paradigms, we aim to identify dierences and
commonalities. table 2 shows our main ndings. the characteristics used in
table 2 are based on topics frequently discussed in bpm literature. see for
example the survey paper [3] which identies twenty main bpm use cases based
on an analysis of all 289 papers published at the main bpm conference series in
a ten year period [7], [11], [19], [5], [22], [17], [20], [18], [27], and [42]. the list of
characteristics used in table 2 is far from complete. nevertheless, we feel that
the list is representative for our high-level comparison and discussion of the four
dierent paradigms. in the remainder we discuss these ndings and also provide
an analysis of the bpm/wfm market.
3.1 basic characteristics of the dierent paradigms
table 2 characterizes the four workow paradigms and tools using three charac-
teristics: focus , degree of coupling , and extendibility . procedural languages like
yawl are driven by control-ow [9]. case handling systems like bpm jone
are data driven, i.e., the moment a data element gets a value or changes value,
the state of the process instance is recomputed [15]. declare allows for any
behavior unless forbidden through constraints [12]. itasks species the desired
behavior in terms of a functional program extended with special workow oper-
ators [39]. yawl anddeclare use service-orientation and a clear separation
between data and control-ow to decouple dierent perspectives. in itasks and
bpm jone these are deliberately coupled, e.g., control-ow and data are inter-
twined to provide additional support and expressiveness. declare anditasks
are extendible, i.e., the language can be extended by adding new constraint tem-
plates [12] or combinators [39]. this is not possible in contemporary procedural
workow and case handling systems.
3.2 flexibility support
table 2 list four types of exibility. these originate from the classication in
[44].
flexibility by denition is the ability to incorporate alternative execution
paths within a process denition at design time such that selection of the most
appropriate execution path can be made at runtime for each process instance.beautiful workows: a matter of taste? 15
table 2. comparison of paradigms.
procedural case handling declarative functional
(yawl ) ( bpmjone)(declare ) ( itasks )
characteristics
focus control-owadata
dependenciesbtasks and
constraintscfunctional
programd
coupling of perspectives decoupled tight decoupled tight
extendiblepe[12]p
[37, 39]
flexibility
denitionpf[9, 26]pg[15]ph[12]pi[37, 39]
deviationpj[15]pk[12, 35]
underspecication (p)l[4, 16, 26] (p)m[4, 12]pn[37, 39]
change (p)o pp[35]pq[38]
analysis
vericationp
[13, 26]p
[12, 47] (p)r
performance analysisp
[13, 14, 26]ps
process discoveryp
[2, 26]p
[32]
conformance checkingp
[2]p
[29, 31]
atoken-based semantics (like playing the token game on a petri net).
bavailable data objects and their values determine the state.
canything that is not explicitly forbidden through some combination of constraints
is allowed.
dextendible set of combinator functions are used to specify the ow of work.
ecan be achieved by adding a template and ltl semantics.
fsupports xor/and/or-splits and joins, cancelation regions, deferred choice, mul-
tiple instance tasks, etc.
gsupports xor/and/or-splits and joins next to data-driven behavior.
hanything is allowed unless explicitly forbidden.
icore combinators can be used to express basic workow patterns.
jauthorized users can deviate by skipping and redoing tasks.
kusers can choose to ignore non-mandatory constraints.
lsupported using worklets in yawl but not a common feature for procedural lan-
guages.
mcan defer the task execution to other tools.
nselecting a task is itself a task.
onot supported by yawl , but there are systems like adept that support such
changes [40, 41].
ppossible to migrate cases that do not violate constraints in the new model. migration
is postponed if needed.
qchange is viewed as a type-safe replacement of one task function by another one.
rstatic analysis and common program analysis.
sunder development (combining declare andcpn tools ).16 wil van der aalst, and michael westergaard, hajo reijers
for example, an xor-split dened at design time adds the ability to select one
or more activities for subsequent execution from a set of available activities. par-
allelism dened at design time leaves the actual ordering of activities open and
thus provides more exibility than sequential routing. all wfm/bpm systems
support this type of exibility. however, declarative languages make it easier to
defer choices to runtime.
the classical workow patterns mentioned earlier [10] can be viewed as a
classication of \exibility by denition" mechanisms for procedural languages.
for example, the \deferred choice" pattern [10] leaves the resolution of a choice
to the environment at runtime. note that a so-called \ower place" in a petri
net, i.e., a place with many transitions that have this place as only input and
output place, provides a lot of exibility.
flexibility by deviation is the ability for a process instance to deviate at
runtime from the execution path prescribed by the original process without
altering the process denition itself. the deviation can only encompass changes
to the execution sequence for a specic process instance, and does not require
modications of the process denition. typical deviations are undo ,redo, and
skip.
thebpm jone system of perceptive software is a system that provides var-
ious mechanisms for deviations at runtime. the case handling paradigm [15]
supported by bpm jone allows the user to skip or redo activities (if not explic-
itly forbidden and assuming the user is authorized to do so). moreover, data can
be entered earlier or later because the state is continuously recomputed based on
the available data. declare supports exibility by deviation through optional
constraints.
flexibility by underspecication is the ability to execute an incomplete pro-
cess specication, i.e., a model that does not contain sucient information to
allow it to be executed to completion. an incomplete process specication con-
tains one or more so-called placeholders . these placeholders are nodes which are
marked as underspecied (i.e., \holes" in the specication) and whose content is
specied during the execution of the process. the manner in which these place-
holders are ultimately enacted is determined by applying one of the following
approaches: late binding (the implementation of a placeholder is selected from a
set of available process fragments) or late modeling (a new process fragment is
constructed in order to complete a given placeholder). for late binding, a process
fragment has to be selected from an existing set of fully predened process frag-
ments. this approach is limited to selection, and does not allow a new process
fragment to be constructed. for late modeling, a new process fragment can be
developed from scratch or composed from existing process fragments.
in the context of yawl [9], the so-called worklets approach [16] has been
developed which allows for late binding and late modeling. late binding is sup-
ported through so-called \ripple-down rules", i.e., based on context information
the user can be guided to selecting a suitable fragment. in [43] the term \pockets
of exibility" was introduced to refer to the placeholder for change. in [25] an
explicit notion of \vagueness" is introduced in the context of process modeling.beautiful workows: a matter of taste? 17
the authors propose model elements such as arc conditions and task ordering to
be deliberately omitted from models in the early stages of modeling. moreover,
parts of the process model can be tagged as \incomplete" or \unspecied". in
itasks selecting a task is itself a task [37, 39]. this can be used to support late
binding.
flexibility by change is the ability to modify a process denition at run-time
such that one or all of the currently executing process instances are migrated to a
new process denition. changes may be introduced both at the process instance
and the process type levels. a momentary change (also known as change at
the instance level) is a change aecting the execution of one or more selected
process instances. an example of a momentary change is the postponement of
registering a patient that has arrived to the hospital emergency center: treatment
is started immediately rather than spending time on formalities rst. such a
momentary change performed on a given process instance does not aect any
future instances. an evolutionary change (also known as change at the type level)
is a change caused by modication of the process denition, potentially aecting
all new process instances. a typical example of the evolutionary change is the
redesign of a business process to improve the overall performance characteristics
by allowing for more concurrency. running process instances that are impacted
by an evolutionary or a momentary change need to be handled properly. if a
running process instance is transferred to the new process, then there may not
be a corresponding state (called the \dynamic change bug" in [23]).
flexibility by change is challenging and has been investigated by many re-
searchers. in the context of the adept system, exibility by change has been
examined in detail [40, 41]. this work shows that changes can introduce all kinds
of anomalies (missing data, deadlocks, double work, etc.). for example, it is dif-
cult to handle both momentary changes and evolutionary changes at the same
time, e.g., an ad-hoc change made for a specic instance may be aected by a
later change at the type level. the declarative workow system declare has
been extended to support both evolutionary and momentary changes [35] thus
illustrating that a declarative style of modeling indeed simplies the realization
of all kinds of exibility support. in [38] it is shown that replacing a task can be
seen as a type-safe replacement of one pure function by another one. the itasks
type system ensures that the values passed between task have the correct type
in the initial workow as well as after any number of changes in this workow.
note that such changes are more restrictive than in some of procedural and
declarative approaches, e.g., the degree of concurrency can not be changed other
than by replacing the whole subprocess. moreover, there should be a dedicated
user interface to support such changes. otherwise, it is unrealistic to assume
that end-users can dene new functions on-the-y. however, this holds also for
most other approaches.
3.3 analysis support
table 2 illustrates that procedural and declarative approaches are supported
by a range of analysis techniques. for example, procedural workow languages18 wil van der aalst, and michael westergaard, hajo reijers
benet from the verication [1, 13, 26], simulation [13, 14, 26], and process mining
techniques [2, 26] developed for petri nets. to apply these results to industry-
driven languages such as bpmn, uml activity diagrams, epcs, and bpel
conversions are needed. sometimes there conversions need to make abstractions
(e.g., ignoring data or time). nevertheless, it is fair to say that most analysis
techniques are tailored towards these procedural workow languages.
in recent years, various analysis techniques have been developed for declara-
tive languages like declare [12, 24, 29, 31{33, 35, 47]. these techniques heavily
rely on the fact that the semantics of declare are dened in terms of ltl and
that there are various ways to translate declare constraints into automata.
bpm jone anditasks are more implementation-oriented providing hardly
any dedicated analysis support.11
3.4 overview of bpm/wfm market
given the very dierent styles of process automation that we distinguished and
explained in the previous sections, it seems worthwhile to reect on their use
in practice. one way of doing so is to consider what the dominating paradigms
are that commercial vendors of bpm systems have adopted in their products.
there are more than 100 bpm vendors active at this point of writing, which
makes a full consideration of all existing products infeasible. instead, we will
rely on a subset of these as they are listed in the so-called magic quadrant on
bpm systems provided by gartner [45]. gartner is a market analyst that has
been following the bpm market space for a number of years and its reports are
highly inuential in how companies decide on their selection of products in the
bpm domain. specically, we will rely on their 2010 version of this quadrant; it
is provided in figure 5.
in the diagram, 27 bpm suites of 25 dierent vendors are displayed. while a
bpm suite arguably encompasses more functionality than a bpm system does,
it is safe to say that process automation is at its core.1
two dimensions are used to dierentiate the various oerings in the magic
quadrant. the `ability to execute' refers to the presence of a particular product
in the market place, while the `completeness of vision' reects the analyst's view
on the innovation and breadth of the oering. gartner evaluated over 60 bpm
vendors to select the top performers with respect to these criteria [45]. for these
reasons, we consider this overview as useful for proling both popular and best-
in-class bpm systems.
we conducted a light-weight evaluation of all the products that are described
in the magic quadrant, which comprised of the following steps. first, we checked
whether the products were still available in the market place and in what form.
by doing so, we established that various oerings changed hands because of
11note that simulation and process discovery are supported for the procedural parts
ofbpmjone, but not for the parts specic for case handling.
1note that for this reason we have not used gartner's 2012 magic quadrant on
intelligent bpm suites in which the analytical capabilities play a much bigger role.beautiful workows: a matter of taste? 19
fig. 5. gartner's magic quadrant on the market of bpm suites.
acquisitions. also, vendors decided to integrate multiple solutions they oered.
specically, opentext acquired both metastorm and global 360, perceptive
software acquired pallas athena, singularity is now kofax, and polymita is
acquired by red hat. opentext integrated its two bpm products into one of-
fering; ibm integrated its lombardi and wdpe oerings (its filenet product is
still a separate product). as a result, of the original 27 products in the magic
quadrant, 25 can still be considered to be active.
the second step consisted of the actual evaluation. we consulted the on-
line document information of each of the vendors on their products, specically
related to their modeling approach and tool set. we also studied the samples that
vendors provided of actual models of business processes as specied with their
tools. this approach is light-weight in the sense that there was no interaction
with experts of the vendors and that no hands-on use of these tools took place.
the evaluation led to the insight that of all 25 products, 23 of these domi-
nantly follow a procedural approach for specifying and enacting workows. two
of the 25 products can be said to adhere to the case management paradigm, i.e.
perceptive software's bpm jone and opentext's bpm solution. no products
can be clearly said to support declarative or functional workows.
there are two interesting side-notes to make. first of all, the adherence
to the procedural approach to workow modeling seems closely aligned with
the widely prevalent support among vendors for bpmn [34]. as discussed in20 wil van der aalst, and michael westergaard, hajo reijers
section 2.1, the bpmn notation essentially supports a procedural approach, in
which explicit paths are modeled in a sequential manner. the bpmn standard
does cover a so-called ad hoc process , in which the relations between activities
is less prescribed. the current development eorts by omg to specify the case
management and modeling notation (cmnn) seems to head towards the use
declarative rules and constraints to pinpoint the semantics of this element. as
such, the popularity of bpmn among bpm vendors may pave the way to the
uptake of more declarative aspects in workow specications, although this is a
tentative development.
secondly, case management is a paradigm that is claimed by many vendors as
a feature of their oerings, despite their dominant adherence to the procedural
paradigm. such claims mostly build on the notion that workows provide a
lifecycle of a particular type of case and that a document-centric view on such
cases is provided with their products. despite the value of this idea, it is a far
cry from the paradigm that we described in section 2.2. closely related to the
previous observation is that both the products that adhered to case management
as the dominant paradigm also fully support a procedural approach.
in conclusion, the procedural paradigm can be said to be the overly domi-
nant one in the marketplace. in second place, but a long way behind, is the case
management paradigm. interestingly, case management is perceived as an at-
tractive idea by many vendors although it is never oered as a fully stand-alone
approach (i.e. totally ruling out the use of procedural workows). declarative
and functional approaches are not spotted in the marketplace. since the dif-
ferent approaches are complementary, we hope to see combined approaches in
commercial systems in the future.
4 a matter of taste?
in this paper we compared dierent workow paradigms that all played a role
in the stw project \controlling dynamic real life workow situations with
demand driven workow systems" where we collaborated with rinus plas-
meijer and his team. in our view none of the four paradigms (procedural, case
handling, declarative, and functional) is superior (or inferior). all emphasize dif-
ferent aspects. for example, analysis techniques ranging from verication and
performance analysis to process discovery and conformance checking are best de-
veloped for procedural languages (e.g., petri nets). however, recently, also many
analysis techniques have been developed for declare . case handling systems
likebpm joneand functional language extensions like itasks provide little sup-
port for analysis. instead, these approaches concentrate on the development of
data- and process-centric information systems. both bpm jone anddeclare
focus on oering exibility to end-users. itasks provides a dierent kind of ex-
ibility: workows can be reused and changed easily. in fact, new combinators can
be added making the language extensible (like declare ). the itasks language
would benet from a graphical front-end to make it more understandable. how-
ever, such a graphical front-end could reduce expressiveness and limit exibilitybeautiful workows: a matter of taste? 21
at design time. itasks is very fast compared to existing systems; it has the pro's
and con's of a programming language.
each of the four approaches is beautiful in its own way and has a dierent
appeal to it (analysis, reuse, exibility, maintainability, etc.). for example, dif-
ferent forms of exibility are possible and it is not realistic to assume a single
language that suits all purposes. partly, the choice of language is also a matter
of taste. fortunately, one can combine dierent approaches as discussed in [4]. a
task in one language may correspond to a subprocess in another language. this
way dierent styles of modeling and enactment may be mixed and nested in any
way appropriate.
acknowledgements
this work was supported by the basic research program of the national re-
search university higher school of economics (hse).
references
1. w.m.p. van der aalst. business process management demystied: a tutorial on
models, systems and standards for workow management. in j. desel, w. reisig,
and g. rozenberg, editors, lectures on concurrency and petri nets , volume 3098
oflecture notes in computer science , pages 1{65. springer-verlag, berlin, 2004.
2. w.m.p. van der aalst. process mining: discovery, conformance and enhancement
of business processes . springer-verlag, berlin, 2011.
3. w.m.p. van der aalst. business process management: a comprehensive sur-
vey. isrn software engineering , article id 507984, doi:10.1155/2013/507984:1{
37, 2013.
4. w.m.p. van der aalst, m. adams, a.h.m. ter hofstede, m. pesic, and h. schonen-
berg. flexibility as a service. in l. chen, editor, database systems for advanced
applications (dasfaa 2009) , volume 5667 of lecture notes in computer science ,
pages 319{333. springer-verlag, berlin, 2009.
5. w.m.p. van der aalst, b. benatallah, f. casati, and f. curbera, editors. inter-
national conference on business process management (bpm 2005) , volume 3649
oflecture notes in computer science . springer-verlag, berlin, 2005.
6. w.m.p. van der aalst, p. de crom, r. goverde, k.m. van hee, w. hofman, h. rei-
jers, and r.a. van der toorn. exspect 6.4: an executable specication tool for
hierarchical colored petri nets. in m. nielsen and d. simpson, editors, applica-
tion and theory of petri nets 2000 , volume 1825 of lecture notes in computer
science , pages 455{464. springer-verlag, berlin, 2000.
7. w.m.p. van der aalst, j. desel, and a. oberweis, editors. business process man-
agement: models, techniques, and empirical studies , volume 1806 of lecture notes
in computer science . springer-verlag, berlin, 2000.
8. w.m.p. van der aalst and k.m. van hee. workow management: models, methods,
and systems . mit press, cambridge, ma, 2004.
9. w.m.p. van der aalst and a.h.m. ter hofstede. yawl: yet another workow
language. information systems , 30(4):245{275, 2005.
10. w.m.p. van der aalst, a.h.m. ter hofstede, b. kiepuszewski, and a.p. barros.
workow patterns. distributed and parallel databases , 14(1):5{51, 2003.22 wil van der aalst, and michael westergaard, hajo reijers
11. w.m.p. van der aalst, a.h.m. ter hofstede, and m. weske, editors. international
conference on business process management (bpm 2003) , volume 2678 of lecture
notes in computer science . springer-verlag, berlin, 2003.
12. w.m.p. van der aalst, m. pesic, and h. schonenberg. declarative workows:
balancing between flexibility and support. computer science - research and
development , 23(2):99{113, 2009.
13. w.m.p. van der aalst and c. stahl. modeling business processes: a petri net
oriented approach . mit press, cambridge, ma, 2011.
14. w.m.p. van der aalst, c. stahl, and w. westergaard. strategies for modeling
complex processes using colored petri nets. in k. jensen, k. wolf, w.m.p. van
der aalst, g. balbo, and m. koutny, editors, transactions on petri nets and other
models of concurrency (topnoc) , lecture notes in computer science. springer-
verlag, berlin, 2013.
15. w.m.p. van der aalst, m. weske, and d. gr unbauer. case handling: a new
paradigm for business process support. data and knowledge engineering ,
53(2):129{162, 2005.
16. m. adams, a.h.m. ter hofstede, d. edmond, and w.m.p. van der aalst. worklets:
a service-oriented implementation of dynamic flexibility in workows. in
r. meersman and z. tari et al., editors, on the move to meaningful internet
systems 2006, otm confederated international conferences, 14th international
conference on cooperative information systems (coopis 2006) , volume 4275 of
lecture notes in computer science , pages 291{308. springer-verlag, berlin, 2006.
17. g. alonso, p. dadam, and m. rosemann, editors. international conference on
business process management (bpm 2007) , volume 4714 of lecture notes in com-
puter science . springer-verlag, berlin, 2007.
18. u. dayal, j. eder, j. koehler, and h. reijers, editors. international conference
on business process management (bpm 2009) , volume 5701 of lecture notes in
computer science . springer-verlag, berlin, 2009.
19. j. desel, b. pernici, and m. weske, editors. international conference on business
process management (bpm 2004) , volume 3080 of lecture notes in computer
science . springer-verlag, berlin, 2004.
20. m. dumas, m. reichert, and m.c. shan, editors. international conference on busi-
ness process management (bpm 2008) , volume 5240 of lecture notes in computer
science . springer-verlag, berlin, 2008.
21. m. dumas, m. la rosa, j. mendling, and h. reijers. fundamentals of business
process management . springer-verlag, berlin, 2013.
22. s. dustdar, j.l. fiadeiro, and a. sheth, editors. international conference on busi-
ness process management (bpm 2006) , volume 4102 of lecture notes in computer
science . springer-verlag, berlin, 2006.
23. c.a. ellis, k. keddara, and g. rozenberg. dynamic change within workow
systems. in n. comstock, c. ellis, r. kling, j. mylopoulos, and s. kaplan, editors,
proceedings of the conference on organizational computing systems , pages 10 {
21, milpitas, california, august 1995. acm sigois, acm press, new york.
24. d. giannakopoulou and k. havelund. automata-based verication of temporal
properties on running programs. in proceedings of the 16th ieee international
conference on automated software engineering (ase'01) , pages 412{416. ieee
computer society, 2001.
25. t. herrmann, m. homann, k.u. loser, and k. moysich. semistructured models
are surprisingly useful for user-centered design. in g. de michelis, a. giboin,
l. karsenty, and r. dieng, editors, designing cooperative systems (coop 2000) ,
pages 159{174. ios press, amsterdam, 2000.beautiful workows: a matter of taste? 23
26. a.h.m. ter hofstede, w.m.p. van der aalst, m. adams, and n. russell. modern
business process automation: yawl and its support environment . springer-
verlag, berlin, 2010.
27. r. hull, j. mendling, and s. tai, editors. international conference on business
process management (bpm 2010) , volume 6336 of lecture notes in computer
science . springer-verlag, berlin, 2010.
28. s. jablonski and c. bussler. workow management: modeling concepts, architec-
ture, and implementation . international thomson computer press, london, uk,
1996.
29. m. de leoni, f.m. maggi, and w.m.p. van der aalst. aligning event logs and
declarative process models for conformance checking. in a. barros, a. gal, and
e. kindler, editors, international conference on business process management
(bpm 2012) , volume 7481 of lecture notes in computer science , pages 82{97.
springer-verlag, berlin, 2012.
30. f. leymann and d. roller. production workow: concepts and techniques .
prentice-hall ptr, upper saddle river, new jersey, usa, 1999.
31. f. maggi, m. montali, m. westergaard, and w. van der aalst. monitoring busi-
ness constraints with linear temporal logic: an approach based on colored
automata. in business process management (bpm 2011) , volume 6896 of lecture
notes in computer science , pages 132{147. springer-verlag, berlin, 2011.
32. f.m. maggi, r.p. jagadeesh chandra bose, and w.m.p. van der aalst. ecient
discovery of understandable declarative process models from event logs. in
j. ralyte, x. franch, s. brinkkemper, and s. wrycza, editors, international con-
ference on advanced information systems engineering (caise 2012) , volume 7328
oflecture notes in computer science , pages 270{285. springer-verlag, berlin,
2012.
33. m. montali, m. pesic, w.m.p. van der aalst, f. chesani, p. mello, and s. storari.
declarative specication and verication of service choreographies. acm trans-
actions on the web , 4(1):1{62, 2010.
34. omg. business process model and notation (bpmn). object management
group, formal/2011-01-03, 2011.
35. m. pesic, m. h. schonenberg, n. sidorova, and w.m.p. van der aalst. constraint-
based workow models: change made easy. in f. curbera, f. leymann, and
m. weske, editors, proceedings of the otm conference on cooperative information
systems (coopis 2007) , volume 4803 of lecture notes in computer science , pages
77{94. springer-verlag, berlin, 2007.
36. r. plasmeijer. clean: a programming environment based on term graph
rewriting. electronic notes in theoretical computer science , 2:215{221, 1995.
37. r. plasmeijer, p. achten, and p. koopman. itasks: executable specications of
interactive workow systems for the web. sigplan notices , 42(9):141{152,
2007.
38. r. plasmeijer, p. achten, p. koopman, b. lijnse, t. van noort, and j. van gronin-
gen. itasks for a change: type-safe run-time change in dynamically evolving work-
ows. in proceedings of the 20th acm sigplan workshop on partial evaluation
and program manipulation , pages 151{160, new york, ny, usa, 2011. acm.
39. r. plasmeijer, b. lijnse, s. michels, p. achten, and p. koopman. task-oriented
programming in a pure functional language. in proceedings of the 14th symposium
on principles and practice of declarative programming , pages 195{206, new york,
ny, usa, 2012. acm.24 wil van der aalst, and michael westergaard, hajo reijers
40. m. reichert and p. dadam. adeptex: supporting dynamic changes of
workow without loosing control. journal of intelligent information systems ,
10(2):93{129, 1998.
41. s. rinderle, m. reichert, and p. dadam. correctness criteria for dynamic
changes in workow systems: a survey. data and knowledge engineering ,
50(1):9{34, 2004.
42. s. rinderle, f. toumani, and k. wolf, editors. international conference on busi-
ness process management (bpm 2011) , volume 6896 of lecture notes in computer
science . springer-verlag, berlin, 2011.
43. s. sadiq, w. sadiq, and m. orlowska. pockets of flexibility in workow specica-
tion. in proceedings of the 20th international conference on conceptual modeling
(er 2001) , volume 2224 of lecture notes in computer science , pages 513{526.
springer-verlag, berlin, 2001.
44. h. schonenberg, r. mans, n. russell, n. mulyar, and w.m.p. van der aalst.
process flexibility: a survey of contemporary approaches. in j. dietz, a. albani,
and j. barjis, editors, advances in enterprise engineering i , volume 10 of lecture
notes in business information processing , pages 16{30. springer-verlag, berlin,
2008.
45. j. sinur and j. hill. magic quadrant for business process management suites,
gartner ras core research note g00205212. www.gartner.com , 2010.
46. m. weske. business process management: concepts, languages, architectures .
springer-verlag, berlin, 2007.
47. m. westergaard. better algorithms for analyzing and enacting declarative work-
ow languages using ltl. in business process management (bpm 2011) , volume
6896 of lecture notes in computer science , pages 83{98. springer-verlag, berlin,
2011.